<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-142" class="chapter-number"><a id="_idTextAnchor143"/>7</h1>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor144"/>Developing for Different Platforms</h1>
			<p>One of the main reasons Go is such a powerful language for building a command-line application is how easy it is to develop an application that can be run on multiple machines. Go provides several packages that allow developers to write code that interacts with the computer independent of the specific operating system. These packages include <strong class="source-inline">os</strong>, <strong class="source-inline">time</strong>, <strong class="source-inline">path</strong>, and <strong class="source-inline">runtime</strong>. In the first section, we will discuss some commonly used functions in each of these packages and then provide some simple examples to pair with <span class="No-Break">the explanations.</span></p>
			<p>To further drill down the importance of these files, we will revisit the <strong class="source-inline">audiofile</strong> code and implement a couple of new features that utilize some of the methods that exist in these packages. After all, the best way to learn is by implementing new features with the new functions and methods you’ve <span class="No-Break">learned about.</span></p>
			<p>We will then learn how to use the <strong class="source-inline">runtime</strong> library to check the operating system the application is running on and then use that to switch between codes. By learning about build tags, what they are, and how to use them, we will learn about a cleaner way to switch between code blocks to implement a new feature that can be run on three different operating systems: Darwin, Windows, and Linux.  By the end of the chapter, you’ll feel more confident when building your application, knowing that the code you are writing will work seamlessly, independent of <span class="No-Break">the platform.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">key topics:</span></p>
			<ul>
				<li>Packages for <span class="No-Break">platform-independent functionality</span></li>
				<li>Implementing independent or <span class="No-Break">platform-specific code</span></li>
				<li>Build tags for <span class="No-Break">targeted platforms</span></li>
			</ul>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor145"/>Technical requirements</h1>
			<ul>
				<li>The code files for this chapter are available <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07</span></a><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Packages for platform-independent functionality</h1>
			<p>When you <a id="_idIndexMarker465"/>are building a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) that will be shared with the public, it’s important that the code is platform-independent to support users who are running the CLI on different operating systems. Golang has supportive packages that provide platform-independent interfaces to operating system functionality.  A few of these packages include <strong class="source-inline">os</strong>, <strong class="source-inline">time</strong>, and <strong class="source-inline">path</strong>. Another useful package is the <strong class="source-inline">runtime</strong> package, which helps when detecting the operating system the application is running on, among other things. We will review each of these packages with some simple examples to show how to apply some of the <span class="No-Break">available methods.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>The os package</h2>
			<p>The <strong class="bold">operating system</strong> (<strong class="bold">os</strong>) package <a id="_idIndexMarker466"/>has a<a id="_idIndexMarker467"/> Unix-like design but applies uniformly across all operating systems. Think of all the operating system commands you can run in a shell, including external commands. The <strong class="source-inline">os</strong> package is your go-to package. We discussed calling external commands in the previous chapter; now we will discuss this at a higher level and focus on the commands in certain groups: environmental, file, and <span class="No-Break">process operations.</span></p>
			<h3>Environmental operations</h3>
			<p>As the <a id="_idIndexMarker468"/>name suggests, the <strong class="source-inline">os</strong> package contains functions that give us information about the environment in which the application is running, as well as change the environment for future method calls. These common operations are for the following <span class="No-Break">working directories:</span></p>
			<ul>
				<li><strong class="source-inline">func Chdir(dir string) error</strong>: This changes the current <span class="No-Break">working directory</span></li>
				<li><strong class="source-inline">func Getwd() (dir string, err error)</strong>: This gets the current <span class="No-Break">working directory</span></li>
			</ul>
			<p>There are also operations for the environment, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">func Environ() []string</strong>: This lists environment keys <span class="No-Break">and values</span></li>
				<li><strong class="source-inline">func Getenv(key string) string</strong>: This gets environment variables <span class="No-Break">by key</span></li>
				<li><strong class="source-inline">func Setenv(key, value string) error</strong>: This sets environment variables by key <span class="No-Break">and value</span></li>
				<li><strong class="source-inline">func Unsetenv(key string) error</strong>: This unsets an environment variable <span class="No-Break">by key</span></li>
				<li><strong class="source-inline">func Clearenv()</strong>: This clears <span class="No-Break">environment variables</span></li>
				<li><strong class="source-inline">func ExpandEnv(s string) string</strong>: This expands values of environment variable keys in strings to <span class="No-Break">their values</span></li>
			</ul>
			<p>The <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> code exists on GitHub in the <strong class="source-inline">environment.go</strong> file, where we have provided some<a id="_idIndexMarker469"/> sample code demonstrating using <span class="No-Break">these operations:</span></p>
			<pre class="source-code">
func environment() {
    dir, err := os.Getwd()
    if err != nil {
        fmt.Println("error getting working directory:", err)
    }
    fmt.Println("retrieved working directory: ", dir)
    fmt.Println("setting WORKING_DIR to", dir)
    err = os.Setenv("WORKING_DIR", dir)
    if err != nil {
        fmt.Println("error setting working directory:", err)
    }
    fmt.Println(os.ExpandEnv("WORKING_DIR=${WORKING_DIR}"))
    fmt.Println("unsetting WORKING_DIR")
    err = os.Unsetenv("WORKING_DIR")
    if err != nil {
        fmt.Println("error unsetting working directory:", err)
    }
    fmt.Println(os.ExpandEnv("WORKING_DIR=${WORKING_DIR}"))
    fmt.Printf("There are %d environment variables:\n", len(os.
        Environ()))
    for _, envar := range os.Environ() {
        fmt.Println("\t", envar)
    }
}</pre>
			<p>To briefly<a id="_idIndexMarker470"/> describe the preceding code, we first get the working directory, then set it to the <strong class="source-inline">WORKING_DIR</strong> environment variable. To show the change, we utilize <strong class="source-inline">os.ExpandEnv</strong> to print the key-value pair. We then unset the <strong class="source-inline">WORKING_DIR </strong>environment variable. Again, we show it is unset by using <strong class="source-inline">os.ExpandEnv</strong> to print out the key-value pair. The <strong class="source-inline">os.ExpandEnv</strong> variable will print an empty string if the environment variable is unset. Finally, we print out the count of the environment variables and then range through all to print them. Running the preceding code will produce the <span class="No-Break">following output:</span></p>
			<pre class="console">
retrieved working directory:  /Users/mmontagnino/Code/src/github.com/marianina8/Chapter-7
setting WORKING_DIR to /Users/mmontagnino/Code/src/github.com/marianina8/Chapter-7
WORKING_DIR=/Users/mmontagnino/Code/src/github.com/marianina8/Chapter-7
There are 44 environment variables.
key=WORKING_DIR, value=/Users/mmontagnino/Code/src/github.com/marianina8/Chapter-7
unsetting WORKING_DIR
WORKING_DIR=</pre>
			<p>If you <a id="_idIndexMarker471"/>run this code on your machine rather than Linux, Unix, or Windows, the resulting output will be similar. Try <span class="No-Break">for yourself.</span></p>
			<p class="callout-heading">Notes on running the following examples</p>
			<p class="callout">To run the <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> examples, you’ll first need to run the install command to install the sleep command to your GOPATH. On Unix-like systems, run the <strong class="source-inline">make install </strong>command followed by the <strong class="source-inline">make run</strong> command. On Linux systems, run the<strong class="source-inline"> ./build-linux.sh</strong> script followed by the<strong class="source-inline"> ./run-linux.sh</strong> script. On Windows, run <strong class="source-inline">.\build-windows.ps1</strong> followed by the <strong class="source-inline">.\run-windows.ps1 </strong><span class="No-Break">Powershell script.</span></p>
			<h3>File operations</h3>
			<p>The <strong class="source-inline">os</strong> package <a id="_idIndexMarker472"/>also offers a wide variety of file operations that can be applied universally across different operating systems. Many functions and methods can be applied to files, so rather than going over each by name, I will group the functionality and name a few <span class="No-Break">of each:</span></p>
			<ul>
				<li>The following can be used to change file, directory, and link permissions <span class="No-Break">and owners:</span><ul><li><strong class="source-inline">func Chmod(name string, mode </strong><span class="No-Break"><strong class="source-inline">FileMode) error</strong></span></li><li><strong class="source-inline">func Chown(name string uid, gid </strong><span class="No-Break"><strong class="source-inline">int) error</strong></span></li><li><strong class="source-inline">func Lchown(name string uid, gid </strong><span class="No-Break"><strong class="source-inline">int) error</strong></span></li></ul></li>
				<li>The following can be used to create pipes, files, directories, <span class="No-Break">and links:</span><ul><li><strong class="source-inline">func Pipe() (r *File, w *File, </strong><span class="No-Break"><strong class="source-inline">err error)</strong></span></li><li><strong class="source-inline">func Create(name string) (*</strong><span class="No-Break"><strong class="source-inline">File, error)</strong></span></li><li><strong class="source-inline">func Mkdir(name string, perm </strong><span class="No-Break"><strong class="source-inline">FileMode) error</strong></span></li><li><strong class="source-inline">func Link(oldname, newname </strong><span class="No-Break"><strong class="source-inline">string) error</strong></span></li></ul></li>
				<li>The <a id="_idIndexMarker473"/>following are used to read from files, directories, <span class="No-Break">and links:</span><ul><li><strong class="source-inline">func ReadFile(name string) ([]</strong><span class="No-Break"><strong class="source-inline">byte, error)</strong></span></li><li><strong class="source-inline">func ReadDir(name string) ([]</strong><span class="No-Break"><strong class="source-inline">DirEntry, error)</strong></span></li><li><strong class="source-inline">func Readlink(name string) (</strong><span class="No-Break"><strong class="source-inline">string, error)</strong></span></li></ul></li>
				<li>The following retrieve <span class="No-Break">user-specific data:</span><ul><li><strong class="source-inline">func UserCacheDir() (</strong><span class="No-Break"><strong class="source-inline">string, error)</strong></span></li><li><strong class="source-inline">func UserConfigDir() (</strong><span class="No-Break"><strong class="source-inline">string, error)</strong></span></li><li>func UserHomeDir() (<span class="No-Break">string, error)</span></li></ul></li>
				<li>The following are used to write <span class="No-Break">to files:</span><ul><li>func (f *File) Write(b []byte) (n int, <span class="No-Break">err error)</span></li><li>func (f *File) WriteString(s string) (n int, <span class="No-Break">err error)</span></li><li><strong class="source-inline">func WriteFile(name string, data []byte, perm </strong><span class="No-Break"><strong class="source-inline">FileMode) error</strong></span></li></ul></li>
				<li>The following are used for <span class="No-Break">file comparison:</span><ul><li><strong class="source-inline">func SameFile(fi1, fi2 </strong><span class="No-Break"><strong class="source-inline">FileInfo) bool</strong></span></li></ul></li>
			</ul>
			<p>There is a <strong class="source-inline">file.go</strong> file within the <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> code on GitHub in which we have some sample code using these operations. Within the file are multiple functions, the first, <strong class="source-inline">func createFiles() error</strong>, handles the creation of three files to play <span class="No-Break">around with:</span></p>
			<pre class="source-code">
func createFiles() error {
    filename1 := "file1"
    filename2 := "file2"
    filename3 := "file3"
    f1, err := os.Create(filename1)
    if err != nil {
        return fmt.Errorf("error creating %s: %v\n", filename1, 
          err)
    }
    defer f1.Close()
    f1.WriteString("abc")
    f2, err := os.Create(filename2)
    if err != nil {
        return fmt.Errorf("error creating %s: %v\n", filename2, 
          err)
    }
    defer f2.Close()
    f2.WriteString("123")
    f3, err := os.Create(filename3)
    if err != nil {
        return fmt.Errorf("error creating %s: %v", filename3, 
          err)
    }
    defer f3.Close()
    f3.WriteString("xyz")
    return nil
}</pre>
			<p>The <strong class="source-inline">os.Create</strong> method allows file creation to work seamlessly on different operating systems. The next function, <strong class="source-inline">file()</strong>, utilizes these files to show how to use methods that exist within the <strong class="source-inline">os</strong> package. The <strong class="source-inline">file()</strong> function primarily gets or changes the current working directory<a id="_idIndexMarker474"/> and runs different functions, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">func createExamplesDir() (string, error)</strong>: This creates an <strong class="source-inline">examples</strong> directory in the user’s <span class="No-Break">home directory</span></li>
				<li><strong class="source-inline">func printFiles(dir string) error</strong>: This prints the files/directories under the directory represented by <span class="No-Break"><strong class="source-inline">dir string</strong></span></li>
				<li><strong class="source-inline">func sameFileCheck(f1, f2 string) error</strong>: This checks whether two files, represented by the <strong class="source-inline">f1</strong> and <strong class="source-inline">f2</strong> strings are the <span class="No-Break">same file</span></li>
			</ul>
			<p>Let’s first show the <strong class="source-inline">file()</strong> function to get the overall gist of what is <span class="No-Break">going on:</span></p>
			<pre class="source-code">
originalWorkingDir, err := os.Getwd()
if err != nil {
    fmt.Println("getting working directory: ", err)
}
fmt.Println("working directory: ", originalWorkingDir)
examplesDir, err := createExamplesDir()
if err != nil {
    fmt.Println("creating examples directory: ", err)
}
err = os.Chdir(examplesDir)
if err != nil {
    fmt.Println("changing directory error:", err)
}
fmt.Println("changed working directory: ", examplesDir)
workingDir, err := os.Getwd()
if err != nil {
    fmt.Println("getting working directory: ", err)
}
fmt.Println("working directory: ", workingDir)
createFiles()
err = printFiles(workingDir)
if err != nil {
    fmt.Printf("Error printing files in %s\n", workingDir)
}
err = os.Chdir(originalWorkingDir)
if err != nil {
    fmt.Println("changing directory error: ", err)
}
fmt.Println("working directory: ", workingDir)
symlink := filepath.Join(originalWorkingDir, "examplesLink")
err = os.Symlink(examplesDir, symlink)
if err != nil {
    fmt.Println("error creating symlink: ", err)
}
fmt.Printf("created symlink, %s, to %s\n", symlink, examplesDir)
err = printFiles(symlink)
if err != nil {
    fmt.Printf("Error printing files in %s\n", workingDir)
}
file := filepath.Join(examplesDir, "file1")
linkedFile := filepath.Join(symlink, "file1")
err = sameFileCheck(file, linkedFile)
if err != nil {
    fmt.Println("unable to do same file check: ", err)
}
// cleanup
err = os.Remove(symlink)
if err != nil {
    fmt.Println("removing symlink error: ", err)
}
err = os.RemoveAll(examplesDir)
if err != nil {
    fmt.Println("removing directory error: ", err)
}</pre>
			<p>Let’s walk<a id="_idIndexMarker475"/> through the preceding code. First, we get the current working directory and print it out. Then, we call the <strong class="source-inline">createExamplesDir()</strong> function and change direction <span class="No-Break">into it.</span></p>
			<p>We then get the current working directory after we change it to ensure it’s now the <strong class="source-inline">examplesDir</strong> value. Next, we call the <strong class="source-inline">createFiles()</strong> function to create those three files inside the <strong class="source-inline">examplesDir</strong> folder and call the <strong class="source-inline">printFiles()</strong> function to list the files in the <strong class="source-inline">examplesDir</strong> <span class="No-Break">working directory.</span></p>
			<p>We change the working directory back to the original working directory and create a <strong class="source-inline">symlink</strong> to the <strong class="source-inline">examplesDir</strong> folder under the home directory. We print the files existing under the <strong class="source-inline">symlink</strong> to see that they <span class="No-Break">are equal.</span></p>
			<p>Next, we take <strong class="source-inline">file0</strong> from <strong class="source-inline">examplesDir</strong> and <strong class="source-inline">file0</strong> from <strong class="source-inline">symlink</strong> and compare them within the <strong class="source-inline">sameFileCheck</strong> function to ensure they <span class="No-Break">are equal.</span></p>
			<p>Finally, we run some cleanup functions to remove the <strong class="source-inline">symlink</strong> and <span class="No-Break"><strong class="source-inline">examplesDir </strong></span><span class="No-Break">folders.</span></p>
			<p>The <strong class="source-inline">file</strong> function utilizes many methods available in the <strong class="source-inline">os</strong> package, from getting the working directory <a id="_idIndexMarker476"/>to changing it, creating a <strong class="source-inline">symlink</strong>, and removing files and directories. Showing the separate function call code will give more uses of the <strong class="source-inline">os</strong> package. First, let’s show the code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">createExamplesDir</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func createExamplesDir() (string, error) {
    homeDir, err := os.UserHomeDir()
    if err != nil {
        return "", fmt.Errorf("getting user's home directory: 
          %v\n", err)
    }
    fmt.Println("home directory: ", homeDir)
    examplesDir := filepath.Join(homeDir, "examples")
    err = os.Mkdir(examplesDir, os.FileMode(int(0777)))
    if err != nil {
        return "", fmt.Errorf("making directory error: %v\n", 
          err)
    }
    fmt.Println("created: ", examplesDir)
    return examplesDir, nil
}</pre>
			<p>The preceding code uses the <strong class="source-inline">os</strong> package when getting the user’s home directory with the <strong class="source-inline">os.UserHomeDir</strong> method and then creates a new folder with the <strong class="source-inline">os.Mkdir</strong> method. The next function, <strong class="source-inline">printFiles</strong>, gets the files to print from the <span class="No-Break"><strong class="source-inline">os.ReadDir</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func printFiles(dir string) error {
    files, err := os.ReadDir(dir)
    if err != nil {
        return fmt.Errorf("read directory error: %s\n", err)
    }
    fmt.Printf("files in %s:\n", dir)
    for i, file := range files {
        fmt.Printf(" %v %v\n", i, file.Name())
    }
    return nil
}</pre>
			<p>Lastly, <strong class="source-inline">sameFileCheck</strong> takes two files represented by strings, <strong class="source-inline">f1</strong> and <strong class="source-inline">f2</strong>. To get the file info for each file, the <strong class="source-inline">os.Lstat</strong> method is called on the file string. <strong class="source-inline">os.SameFile</strong> takes <a id="_idIndexMarker477"/>this file info and returns a <strong class="source-inline">boolean</strong> value to symbolize the result – <strong class="source-inline">true</strong> if the files are the same and <strong class="source-inline">false</strong> <span class="No-Break">if not:</span></p>
			<pre class="source-code">
func sameFileCheck(f1, f2 string) error {
    fileInfo0, err := os.Lstat(f1)
    if err != nil {
        return fmt.Errorf("getting fileinfo: %v", err)
    }
    fileInfo0Linked, err := os.Lstat(f2)
    if err != nil {
        return fmt.Errorf("getting fileinfo: %v", err)
    }
    isSameFile := os.SameFile(fileInfo0, fileInfo0Linked)
    if isSameFile {
        fmt.Printf("%s and %s are the same file.\n", fileInfo0.
            Name(), fileInfo0Linked.Name())
    } else {
    fmt.Printf("%s and %s are NOT the same file.\n", fileInfo0.
        Name(), fileInfo0Linked.Name())
    }
    return nil
}</pre>
			<p>This <a id="_idIndexMarker478"/>concludes the code samples utilizing methods from the <strong class="source-inline">os</strong> package related to file operations. Next, we will discuss some operations related to processes running on <span class="No-Break">the machine.</span></p>
			<h3>Process operations</h3>
			<p>When <a id="_idIndexMarker479"/>calling external commands, we can<a id="_idIndexMarker480"/> get a <strong class="bold">process ID</strong> (<strong class="bold">pid</strong>), associated with the process. Within the <strong class="source-inline">os</strong> package, we can perform actions on the process, send the process signals, or wait for the process to complete and then receive a process state with information regarding the process that was completed. In the <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> code, we have a <strong class="source-inline">process()</strong> function, which utilizes some of the following methods for processes and <span class="No-Break">process states:</span></p>
			<ul>
				<li><strong class="source-inline">func Getegid() int</strong>: This returns the effective group ID of the caller. Note, this is not supported in Windows, the concept of group IDs is specific to Unix-like or Linux systems. For example, this will return <strong class="source-inline">–1</strong> <span class="No-Break">on Windows.</span></li>
				<li><strong class="source-inline">func Geteuid() int</strong>: This returns the effective user ID of the caller. Note, this is not supported in Windows, the concept of user IDs is specific to Unix-like or Linux systems. For example, this will return <strong class="source-inline">-1</strong> <span class="No-Break">on Windows.</span></li>
				<li><strong class="source-inline">func Getpid() int</strong>: This gets the process ID of <span class="No-Break">the caller.</span></li>
				<li><strong class="source-inline">func FindProcess(pid int) (*Process, error)</strong>: This returns the process associated with <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">pid</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">func (p *Process) Wait() (*ProcessState, error)</strong>: This returns the process state when the <span class="No-Break">process completes.</span></li>
				<li><strong class="source-inline">func (p *ProcessState) Exited() bool</strong>: This returns <strong class="source-inline">true</strong> if the <span class="No-Break">process exited.</span></li>
				<li><strong class="source-inline">func (p *ProcessState) Success() bool</strong>: This returns <strong class="source-inline">true</strong> if the process <span class="No-Break">exited successfully.</span></li>
				<li><strong class="source-inline">func (p *ProcessState) ExitCode() int</strong>: This returns the exit code of <span class="No-Break">the process.</span></li>
				<li><strong class="source-inline">func (p *ProcessState) String() string</strong>: This returns the process state in <span class="No-Break">string format.</span></li>
			</ul>
			<p>The code is as <a id="_idIndexMarker481"/>follows and starts with several print line statements that return the caller’s effective group, user, and process ID. Next, a <strong class="source-inline">cmd</strong> sleep command is defined. The command is started and from the <strong class="source-inline">cmd</strong> value, and we get <span class="No-Break">the pid:</span></p>
			<pre class="source-code">
func process() {
    fmt.Println("Caller group id:", os.Getegid())
    fmt.Println("Caller user id:", os.Geteuid())
    fmt.Println("Process id of caller", os.Getpid())
    cmd := exec.Command(filepath.Join(os.Getenv("GOPATH"), 
           "bin", "sleep"))
    fmt.Println("running sleep for 1 second...")
    if err := cmd.Start(); err != nil {
        panic(err)
    }
    fmt.Println("Process id of sleep", cmd.Process.Pid)
    this, err := os.FindProcess(cmd.Process.Pid)
    if err != nil {
        fmt.Println("unable to find process with id: ", cmd.
            Process.Pid)
    }
    processState, err := this.Wait()
    if err != nil {
        panic(err)
    }
    if processState.Exited() &amp;&amp; processState.Success() {
        fmt.Println("Sleep process ran successfully with exit 
            code: ", processState.ExitCode())
    } else {
        fmt.Println("Sleep process failed with exit code: ", 
            processState.ExitCode())
    }
    fmt.Println(processState.String())
}</pre>
			<p>From the <a id="_idIndexMarker482"/>process' pid, we then can find the process using the <strong class="source-inline">os.FindProcess</strong> method. We call the <strong class="source-inline">Wait()</strong> method in the process to get <strong class="source-inline">os.ProcessState</strong>. This <strong class="source-inline">Wait()</strong> method, like the <strong class="source-inline">cmd.Wait()</strong> method, waits for the process to complete. Once completed, the process state is returned. We can check whether the process state is exited with the <strong class="source-inline">Exited()</strong> method and whether it was successful with the <strong class="source-inline">Success()</strong> method. If so, we print that the process ran successfully along with the exit code, which we get from the <strong class="source-inline">ExitCode()</strong> method. Finally, the process state can be printed cleanly with the<a id="_idTextAnchor148"/> <span class="No-Break"><strong class="source-inline">String()</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor149"/>The time package</h2>
			<p>Operating systems<a id="_idIndexMarker483"/> provide <a id="_idIndexMarker484"/>access to time via two different types of <span class="No-Break">internal clocks:</span></p>
			<ul>
				<li><strong class="bold">A wall clock</strong>: This <a id="_idIndexMarker485"/>is used for telling the time and is subject to variations due to clock <a id="_idIndexMarker486"/>synchronization with the <strong class="bold">Network Time </strong><span class="No-Break"><strong class="bold">Protocol</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">NTP</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">A monotonic clock</strong>: This is<a id="_idIndexMarker487"/> used for measuring time and is not subject to variations due to <span class="No-Break">clock synchronization</span></li>
			</ul>
			<p>To be <a id="_idIndexMarker488"/>more specific on the variations, if the wall clock notices that it is moving faster or slower than the NTP, it will adjust its clock rate. The monotonic clock will not adjust. When measuring durations, it’s important to use the monotonic clock. Luckily with Go, the <strong class="source-inline">Time</strong> struct contains both the wall and monotonic clocks, and we don’t need to specify <a id="_idIndexMarker489"/>which is used. Within the <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> code, there is a <strong class="source-inline">timer.go</strong> file, which shows how to get the current time and duration, regardless of the <span class="No-Break">operating system:</span></p>
			<pre class="source-code">
func timer() {
    start := time.Now()
    fmt.Println("start time: ", start)
    time.Sleep(1 * time.Second)
    elapsed := time.Until(start)
    fmt.Println("elapsed time: ", elapsed)
}</pre>
			<p>When running the following code, you’ll see a <span class="No-Break">similar output:</span></p>
			<pre class="console">
start time:  2022-09-24 23:47:38.964133 -0700 PDT m=+0.000657043
elapsed time:  -1.002107875s</pre>
			<p>Also, many of you have also seen that there is a <strong class="source-inline">time.Now().Unix()</strong> method. It returns to the epoch time, or time that has elapsed since the Unix epoch, January 1, 1970, UTC. These methods will work similarly regardless of the operating system and archi<a id="_idTextAnchor150"/>tecture they are <span class="No-Break">run on.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor151"/>The path package</h2>
			<p>When <a id="_idIndexMarker490"/>developing a command-line application for different operating systems, you’ll most likely have <a id="_idIndexMarker491"/>to deal with handling file or directory path names. In order to handle these appropriately across different operating systems, you’ll need to use the <strong class="source-inline">path</strong> package. Because this package does not handle Windows paths with drive letters or backslashes, as we used in the previous examples, we’ll use the <span class="No-Break"><strong class="source-inline">path/filepath</strong></span><span class="No-Break"> package.</span></p>
			<p>The <strong class="source-inline">path/filepath</strong> package uses either forward or back slashes depending on the operating system. Just for fun, within the <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> <strong class="source-inline">walking.go</strong> file, I’ve used the <strong class="source-inline">filepath</strong> package to walk through a directory. Let’s look at <span class="No-Break">the code:</span></p>
			<pre class="source-code">
func walking() {
    workingDir, err := os.Getwd()
    if err != nil {
        panic(err)
    }
    dir1 := filepath.Join(workingDir, "dir1")
    filepath.WalkDir(dir1, func(path string, d fs.DirEntry, err 
      error) error {
        if !d.IsDir() {
            contents, err := os.ReadFile(path)
            if err != nil {
                return err
            }
            fmt.Printf("%s -&gt; %s\n", d.Name(), 
                string(contents))
        }
        return nil
    })
}</pre>
			<p>We get the current working directory with <strong class="source-inline">os.Getwd()</strong>. Then create a path for the <strong class="source-inline">dir1</strong> directory<a id="_idIndexMarker492"/> that can be used for any operating system using the <strong class="source-inline">filepath.Join</strong> method. Finally, we walk the directory using <strong class="source-inline">filepath.WalkDir</strong> and print out the<a id="_idTextAnchor152"/> filename and <span class="No-Break">its contents.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor153"/>The runtime package</h2>
			<p>The <a id="_idIndexMarker493"/>final package to discuss within this section is the <strong class="source-inline">runtime</strong> package. It’s mentioned because it’s used to easily <a id="_idIndexMarker494"/>determine the operating system the code is running on and therefore execute blocks of code, but there’s so much information you can get from the <span class="No-Break"><strong class="source-inline">runtime</strong></span><span class="No-Break"> system:</span></p>
			<ul>
				<li><strong class="source-inline">GOOS</strong>: This returns the running application's operating <span class="No-Break">system target</span></li>
				<li><strong class="source-inline">GOARCH:</strong> This returns the running application’s <span class="No-Break">architecture target</span></li>
				<li><strong class="source-inline">func GOROOT() string</strong>: This returns the root of the <span class="No-Break">Go tree</span></li>
				<li><strong class="source-inline">Compiler</strong>: This returns the name of the compiler toolchain that built <span class="No-Break">the binary</span></li>
				<li><strong class="source-inline">func NumCPU() int</strong>: This returns the number of logical CPUs usable by the <span class="No-Break">current process</span></li>
				<li><strong class="source-inline">func NumGoroutine() int</strong>: This returns the number of goroutines that <span class="No-Break">currently exist</span></li>
				<li><strong class="source-inline">func Version() string</strong>: This returns the Go tree’s <span class="No-Break">version string</span></li>
			</ul>
			<p>This package will provide you with enough information to understand the <strong class="source-inline">runtime</strong> environment. Within the <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> code in the <strong class="source-inline">checkRuntime.go</strong> file is the <strong class="source-inline">checkRuntime</strong> function, which puts each of these <span class="No-Break">into practice:</span></p>
			<pre class="source-code">
func checkRuntime() {
    fmt.Println("Operating System:", runtime.GOOS)
    fmt.Println("Architecture:", runtime.GOARCH)
    fmt.Println("Go Root:", runtime.GOROOT())
    fmt.Println("Compiler:", runtime.Compiler)
    fmt.Println("No. of CPU:", runtime.NumCPU())
    fmt.Println("No. of Goroutines:", runtime.NumGoroutine())
    fmt.Println("Version:", runtime.Version())
    debug.PrintStack()
}</pre>
			<p>Running<a id="_idIndexMarker495"/> the <a id="_idIndexMarker496"/>code will provide a similar output to <span class="No-Break">the following:</span></p>
			<pre class="console">
Operating System: darwin
Architecture: amd64
Go Root: /usr/local/go
Compiler: gc
No. of CPU: 10
No. of Goroutines: 1
Version: go1.19
goroutine 1 [running]:
runtime/debug.Stack()
        /usr/local/go/src/runtime/debug/stack.go:24 +0x65
runtime/debug.PrintStack()
        /usr/local/go/src/runtime/debug/stack.go:16 +0x19
main.checkRuntime()
        /Users/mmontagnino/Code/src/github.com/marianina8/Chapter-7/checkRuntime.go:17 +0x372
main.main()
        /Users/mmontagnino/Code/src/github.com/marianina8/Chapter-7/main.go:9 +0x34</pre>
			<p>Now<a id="_idIndexMarker497"/> that we have learned about some of the packages required for building a command-line application<a id="_idIndexMarker498"/> that runs across multiple operating systems and architectures, in the next section, we’ll return to the <strong class="source-inline">audiofile</strong> CLI from previous chapters and implement a few new functions and show how the methods and functions we’ve learned in this section can come <span class="No-Break">into play.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor154"/>Implementing independent or platform-specific code</h1>
			<p>The best way to learn is to put what has been learned into practice. In this section, we’ll revisit the <strong class="source-inline">audiofile</strong> CLI to implement a few new commands. In the code for the new features we’ll implement, the focus will be on the use of the <strong class="source-inline">os</strong> and <span class="No-Break"><strong class="source-inline">path</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">filepath</strong></span><span class="No-Break"> packages.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor155"/>Platform-independent code</h2>
			<p>Let’s now<a id="_idIndexMarker499"/> implement a few new features for the <strong class="source-inline">audiofile</strong> CLI that will run independently of the <span class="No-Break">operating system:</span></p>
			<ul>
				<li><strong class="source-inline">Delete</strong>: This deletes stored metadata <span class="No-Break">by ID</span></li>
				<li><strong class="source-inline">Search</strong>: This searches stored metadata for a specific <span class="No-Break">search string</span></li>
			</ul>
			<p>The creation of each of these new feature commands was initiated with the cobra-CLI; however, the platform-specific code is isolated in the <strong class="source-inline">storage/flatfile.go</strong> file, which is the flat file storage for the <span class="No-Break">storage interface.</span></p>
			<p>First, let’s show the <span class="No-Break"><strong class="source-inline">Delete</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func (f FlatFile) Delete(id string) error {
    dirname, err := os.UserHomeDir()
    if err != nil {
        return err
    }
    audioIDFilePath := filepath.Join(dirname, "audiofile", id)
    err = os.RemoveAll(audioIDFilePath)
    if err != nil {
        return err
    }
    return nil
}</pre>
			<p>The<a id="_idIndexMarker500"/> flat file storage is stored under the user’s home directory under the <strong class="source-inline">audiofile</strong> directory. Then, as each new audio file and matching metadata is added, it is stored within its unique identifier ID. From the <strong class="source-inline">os</strong> package, we use <strong class="source-inline">os.UserHomeDir()</strong> to get the user’s home directory and then use the <strong class="source-inline">filepath.Join</strong> method to create the required path to delete all the metadata and files associated with the ID independent of the operating system. Make sure you have some audiofiles stored locally in the flat file storage. If not, add a few files. For example, use the <strong class="source-inline">audio/beatdoctor.mp3</strong> file and upload using the <span class="No-Break">following command:</span></p>
			<pre class="console">
./bin/audiofile upload --filename audio/beatdoctor.mp3</pre>
			<p>The ID is returned after a <span class="No-Break">successful upload:</span></p>
			<pre class="console">
Uploading audio/beatdoctor.mp3 ...
Audiofile ID:  a5d9ab11-6f5f-4da0-9307-a3b609b0a6ba</pre>
			<p>You can ensure that the data has been added by running the <span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
./bin/audiofile list</pre>
			<p>The <strong class="source-inline">audiofile</strong> metadata is returned, so we have double-checked its existence <span class="No-Break">in storage:</span></p>
			<pre class="console">
    {
        "Id": "a5d9ab11-6f5f-4da0-9307-a3b609b0a6ba",
        "Path": "/Users/mmontagnino/audiofile/a5d9ab11-6f5f-4da0-9307-a3b609b0a6ba/beatdoctor.mp3",
        "Metadata": {
            "tags": {
                "title": "Shot In The Dark",
                "album": "Best Bytes Volume 4",
                "artist": "Beat Doctor",
                "album_artist": "Toucan Music (Various Artists)",
                "composer": "",
                "genre": "Electro House",
                "year": 0,
                "lyrics": "",
                "comment": "URL: http://freemusicarchive.org/music/Beat_Doctor/Best_Bytes_Volume_4/09_beat_doctor_shot_in_the_dark\r\nComments: http://freemusicarchive.org/\r\nCurator: Toucan Music\r\nCopyright: Attribution-NonCommercial 3.0 International: http://creativecommons.org/licenses/by-nc/3.0/"
            },
            "transcript": ""
        },
        "Status": "Complete",
        "Error": null
    },</pre>
			<p>Now, we <a id="_idIndexMarker501"/>can <span class="No-Break">delete it:</span></p>
			<pre class="console">
./bin/audiofile delete --id a5d9ab11-6f5f-4da0-9307-a3b609b0a6ba
success</pre>
			<p>Then confirm that it’s been deleted by trying to get the audio <span class="No-Break">by ID:</span></p>
			<pre class="console">
./bin/audiofile get --id a5d9ab11-6f5f-4da0-9307-a3b609b0a6ba
Error: unexpected response: 500 Internal Server Error
Usage:
  audiofile get [flags]
Flags:
  -h, --help        help for get
      --id string   audiofile id
unexpected response: 500 Internal Server Error%</pre>
			<p>Looks<a id="_idIndexMarker502"/> like an unexpected error has occurred, and we haven’t properly implemented how to handle this when searching for metadata for a file that has been deleted. We’ll need to modify the <strong class="source-inline">services/metadata/handler_getbyid.go</strong> file. At line 20, where we call the <strong class="source-inline">GetById</strong> method and handle the error, let’s return <strong class="source-inline">200</strong> instead of <strong class="source-inline">500</strong> after confirming the error is related to a folder not being found. It’s not necessarily an error that the user is searching for an ID that does <span class="No-Break">not exist:</span></p>
			<pre class="source-code">
audio, err := m.Storage.GetByID(id)
if err != nil {
    if strings.Contains(err.Error(), "not found") ||     strings.Contains(err.Error(), "no such file or directory") {
        io.WriteString(res, "id not found")
        res.WriteHeader(200)
        return
    }
    res.WriteHeader(500)
    return
}</pre>
			<p>Let’s try <span class="No-Break">it again:</span></p>
			<pre class="console">
./bin/audiofile get --id a5d9ab11-6f5f-4da0-9307-a3b609b0a6ba
id not found</pre>
			<p>That’s much better! Now let’s implement the search functionality. The implementation again is<a id="_idIndexMarker503"/> isolated to the <strong class="source-inline">storage/flatfile.go</strong> file where you will find the <span class="No-Break"><strong class="source-inline">Search</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func (f FlatFile) Search(searchFor string) ([]*models.Audio, error) {
    dirname, err := os.UserHomeDir()
    if err != nil {
        return nil, err
    }
    audioFilePath := filepath.Join(dirname, "audiofile")
    matchingAudio := []*models.Audio{}
    err = filepath.WalkDir(audioFilePath, func(path string, 
          d fs.DirEntry, err error) error {
        if d.Name() == "metadata.json" {
            contents, err := os.ReadFile(path)
            if err != nil {
                return err
            }
            if strings.Contains(strings.
               ToLower(string(contents)), strings.
               ToLower(searchFor)) {
                data := models.Audio{}
                err = json.Unmarshal(contents, &amp;data)
                if err != nil {
                    return err
                }
                matchingAudio = append(matchingAudio, &amp;data)
            }
        }
        return nil
    })
    return matchingAudio, err
}</pre>
			<p>Like most<a id="_idIndexMarker504"/> of the methods existing in the storage, we start by getting the user’s home directory with the <strong class="source-inline">os.UserHomeDir()</strong> method and then, again, use <strong class="source-inline">filepath.Join</strong> to get the root <strong class="source-inline">audiofile</strong> path directory, which we will be walking. The <strong class="source-inline">filepath.WalkDir</strong> method is called starting at <strong class="source-inline">audioFilePath</strong>. We check each of the <strong class="source-inline">metadata.json</strong> files to see whether the <strong class="source-inline">searchFor</strong> string exists within the contents. The method returns a slice of <strong class="source-inline">*models.Audio</strong> and if the <strong class="source-inline">searchFor</strong> string is found within the contents, the audio is appended onto the slice that will be <span class="No-Break">returned later.</span></p>
			<p>Let’s give this a try with the following command and see that the expected metadata <span class="No-Break">is returned:</span></p>
			<pre class="console">
./bin/audiofile search --value "Beat Doctor"</pre>
			<p>Now that we’ve created a few new commands to show how the <strong class="source-inline">os</strong> package and <strong class="source-inline">path/filepath</strong> packages can be used in a real-life example, let’s try to write some code that can run specifically on one operating system <span class="No-Break">or another.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor156"/>Platform-specific code</h2>
			<p>Suppose <a id="_idIndexMarker505"/>your command-line application requires an external application that exists on the operating system, but the application required differs between operating systems. For the <strong class="source-inline">audiofile</strong> command-line application, suppose we want to create a command to play the audio file via the command line. Each operating system will need to use a different command to play the audio, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>macOS: <span class="No-Break"><strong class="source-inline">afplay &lt;filepath&gt;</strong></span></li>
				<li>Windows: <span class="No-Break"><strong class="source-inline">start &lt;filepath&gt;</strong></span></li>
				<li>Linux: <span class="No-Break"><strong class="source-inline">aplay &lt;filepath&gt;</strong></span></li>
			</ul>
			<p>Again, we use the Cobra-CLI to create the new <strong class="source-inline">play</strong> command. Let’s look at each different function that would need to be called for each operating system to play the audio file. First is the code <span class="No-Break">for macOS:</span></p>
			<pre class="source-code">
func darwinPlay(audiofilePath string) {
    cmd := exec.Command("afplay", audiofilePath)
    if err := cmd.Start(); err != nil {
       panic(err)
    }
    fmt.Println("enjoy the music!")
    err := cmd.Wait()
    if err != nil {
       panic(err)
    }
}</pre>
			<p>We create a command to use the <strong class="source-inline">afplay</strong> executable and pass in the <strong class="source-inline">audiofilePath</strong>. Next is the code <span class="No-Break">for Windows:</span></p>
			<pre class="source-code">
func windowsPlay(audiofilePath string) {
    cmd := exec.Command("cmd", "/C", "start", audiofilePath)
    if err := cmd.Start(); err != nil {
        return err
    }
    fmt.Println("enjoy the music!")
    err := cmd.Wait()
    if err != nil {
        return err
    }
}</pre>
			<p>This is a <a id="_idIndexMarker506"/>very similar function, except it uses the <strong class="source-inline">start</strong> executable in Windows to play the audio. Last is the code <span class="No-Break">for Linux:</span></p>
			<pre class="source-code">
func linuxPlay(audiofilePath string) {
    cmd := exec.Command("aplay", audiofilePath)
    if err := cmd.Start(); err != nil {
        panic(err)
    }
    fmt.Println("enjoy the music!")
    err := cmd.Wait()
    if err != nil {
        panic(err)
    }
}</pre>
			<p>Again, the code is practically identical except for the application which is called to play the audio. In another case, this code could be more specific for the operating system, require different <a id="_idIndexMarker507"/>arguments, and even require a full path specific to the operating system. Regardless, we are ready to use these functions within the <strong class="source-inline">play</strong> command’s <strong class="source-inline">RunE</strong> field. The full <strong class="source-inline">play</strong> command is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var playCmd = &amp;cobra.Command{
    Use: "play",
    Short: "Play audio file by id",
    RunE: func(cmd *cobra.Command, args []string) error {
        b, err := getAudioByID(cmd)
        if err != nil {
            return err
        }
        audio := models.Audio{}
        err = json.Unmarshal(b, &amp;audio)
        if err != nil {
            return err
        }
        switch runtime.GOOS {
        case "darwin":
            darwinPlay(audio.Path)
            return nil
        case "windows":
            windowsPlay(audio.Path)
            return nil
        case "linux":
            linuxPlay(audio.Path)
            return nil
        default:
            fmt.Println(`Your operating system isn't supported 
                for playing music yet.
                Feel free to implement your additional use 
                case!`)
        }
        return nil
    },
}</pre>
			<p>The important part <a id="_idIndexMarker508"/>of this code is that we have created a switch case for the <strong class="source-inline">runtime.GOOS</strong> value, which tells us what operating system the application is running on. Depending on the operating system, a different method is called to start a process to play the audio file. Let’s recompile and try the play method with one of the stored audio <span class="No-Break">file IDs:</span></p>
			<pre class="console">
./bin/audiofile play --id bf22c5c4-9761-4b47-aab0-47e93d1114c8
enjoy the music!</pre>
			<p>The final section of this chapter will show us how to implement this differently, if we’d like to, using <span class="No-Break">build tags.</span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor157"/>Build tags for targeted platforms</h1>
			<p>Built tags, or <a id="_idIndexMarker509"/>build constraints, can be used for many purposes, but in this section, we will be discussing how to use build tags to identify which files should be included in a package when building for specific operating systems. Build tags are given in a comment at the top of <span class="No-Break">a file:</span></p>
			<pre class="source-code">
//go:build</pre>
			<p>Build tags are passed in as flags when running <strong class="source-inline">go build</strong>. There could be more than one tag on a file, and they follow on from the comment with the <span class="No-Break">following syntax:</span></p>
			<pre class="source-code">
//go:build [tags]</pre>
			<p>Each tag is<a id="_idIndexMarker510"/> separated by a space. Suppose we want to indicate that this file will only be included in a build for the Darwin operating system, then we would add this to the top of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
//go:build darwin</pre>
			<p>Then when building the application, we would use something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
go build –tags darwin</pre>
			<p>This is just a super quick overview of how build tags can be used to constrain files specific to operating systems. Before we go into an implementation of this, let’s discuss the <strong class="source-inline">build</strong> package in a bit <span class="No-Break">more detail.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor158"/>The build package</h2>
			<p>The <strong class="source-inline">build</strong> package<a id="_idIndexMarker511"/> gathers information about Go packages. In the <em class="italic">Chapter07</em> code repository, there is a <strong class="source-inline">buildChecks.go</strong> file, which uses the <strong class="source-inline">build</strong> package to get information about the current package. Let’s see what information this code can <span class="No-Break">give us:</span></p>
			<pre class="source-code">
func buildChecks() {
    ctx := build.Context{}
    p1, err := ctx.Import(".", ".", build.AllowBinary)
    if err != nil {
        fmt.Println("err: ", err)
    }
    fmt.Println("Dir:", p1.Dir)
    fmt.Println("Package name: ", p1.Name)
    fmt.Println("AllTags: ", p1.AllTags)
    fmt.Println("GoFiles: ", p1.GoFiles)
    fmt.Println("Imports: ", p1.Imports)
    fmt.Println("isCommand: ", p1.IsCommand())
    fmt.Println("IsLocalImport: ", build.IsLocalImport("."))
    fmt.Println(ctx)
}</pre>
			<p>We first<a id="_idIndexMarker512"/> create the <strong class="source-inline">context</strong> variable and then call the <strong class="source-inline">Import</strong> method. The <strong class="source-inline">Import</strong> method is defined in the documentation <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="source-inline">func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error)</strong></pre>
			<p>It returns the details about the Go package named by the <strong class="source-inline">path</strong> and <strong class="source-inline">srcDir</strong> source directory parameters. In this case, the <strong class="source-inline">main</strong> package is returned from the package, then we can check all the variables and methods that exist to get more information on the package. Running this method locally will return something <span class="No-Break">like this:</span></p>
			<pre class="console">
Dir: .
Package name:  main
AllTags:  [buildChecks]
GoFiles:  [checkRuntime.go environment.go file.go main.go process.go timer.go walking.go]
Imports:  [fmt io/fs os os/exec path/filepath runtime runtime/debug strings time]
isCommand/main package:  true
IsLocalImport:  true</pre>
			<p>Most of the values we are checking are self-explanatory.  <strong class="source-inline">AllTags</strong> returns all tags that exist within the <strong class="source-inline">main</strong> package. <strong class="source-inline">GoFiles</strong> returns all the files included in the <strong class="source-inline">main</strong> package. <strong class="source-inline">Imports</strong> are all the unique imports that exist within the package. <strong class="source-inline">IsCommand()</strong> returns <strong class="source-inline">true</strong> if the package is considered a command to be installed, or if it is the main package. Finally, the <strong class="source-inline">IsLocalImport</strong> method checks whether an import file is local. This is a fun extra detail to interest you more about what the <strong class="source-inline">build</strong> package could potentially <span class="No-Break">offer you.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor159"/>Build tags</h2>
			<p>Now<a id="_idIndexMarker513"/> that we have learned a little bit more about the <strong class="source-inline">build</strong> package, let’s use it for the main purpose of this chapter, building packages for specific operating systems. Build tags should be named intentionally, and since we are using them for a specific purpose, we can name each build tag by an <span class="No-Break">operating system:</span></p>
			<pre class="source-code">
//go:build darwin
//go:build linux
//go:build windows</pre>
			<p>Let’s revisit the audio file code. Remember how in the <strong class="source-inline">play</strong> command, we check the <strong class="source-inline">runtime</strong> operating system and then call a specific method. Let’s rewrite this code using <span class="No-Break">build tags.</span></p>
			<h3>Example in the audio file</h3>
			<p>Let’s <a id="_idIndexMarker514"/>first simplify the command’s code to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var playCmd = &amp;cobra.Command{
    Use: "play",
    Short: "Play audio file by id",
    Long: `Play audio file by id`,
    RunE: func(cmd *cobra.Command, args []string) error {
        b, err := getAudioByID(cmd)
        if err != nil {
            return err
        }
        audio := models.Audio{}
        err = json.Unmarshal(b, &amp;audio)
        if err != nil {
            return err
        }
        return play(audio.Path)
    },
}</pre>
			<p>Basically, we’ve <a id="_idIndexMarker515"/>simplified the code greatly by removing the operating system switch statement and the three functions that implement the play feature for each operating system. Instead, we’ve taken the code and created three new files:  <strong class="source-inline">play_darwin.go</strong>, <strong class="source-inline">play_windows.go</strong>, and <strong class="source-inline">play_linux.go</strong>. Within each of these files is a build tag for each operating system. Let’s take the Darwin file, <strong class="source-inline">play_darwin.go</strong>, <span class="No-Break">for example:</span></p>
			<pre class="source-code">
//go:build darwin
package cmd
import (
    "fmt"
    "os/exec"
)
func play(audiofilePath string) error {
    cmd := exec.Command("afplay", audiofilePath)
    if err := cmd.Start(); err != nil {
        return err
    }
    fmt.Println("enjoy the music!")
    err := cmd.Wait()
    if err != nil {
        return err
    }
    return nil
}</pre>
			<p>Notice that the <strong class="source-inline">play</strong> function has been renamed to match the function called in the <strong class="source-inline">play</strong> command in <strong class="source-inline">play.go</strong>. Since only one of the files gets included in the build, there’s no confusion as to which <strong class="source-inline">play</strong> function is called. We ensure that only one gets called within the <strong class="source-inline">make</strong> file, which is how we are currently running the application. In <strong class="source-inline">Makefile</strong>, I’ve designated a command to build specifically <span class="No-Break">for Darwin:</span></p>
			<pre class="source-code">
build-darwin:
    go build -tags darwin -o bin/audiofile main.go
    chmod +x bin/audiofile</pre>
			<p>A Go file <a id="_idIndexMarker516"/>containing the <strong class="source-inline">play</strong> function is created for Windows and Linux. The specific tags for each operating system will similarly need to be passed into the <strong class="source-inline">-tags</strong> flag when building your application. In later chapters, we will discuss cross-compiling, which is the next step. But before we do, let’s leave this chapter by reviewing a list of OS-level differences to keep in mind while developing for <span class="No-Break">multiple platforms.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor160"/>OS-level differences</h2>
			<p>Since you’ll be<a id="_idIndexMarker517"/> building your application for the main operating systems, it’s important to know the differences between them and know what to look out for. Let’s dive in with the <span class="No-Break">following list:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Filesystem</strong></span><span class="No-Break">:</span><ul><li>Windows<a id="_idIndexMarker518"/> uses a different filesystem than Linux and Unix, so be mindful of the file paths when accessing files in your <span class="No-Break">Go code.</span></li><li>File paths in Windows use backslashes, (<strong class="source-inline">\</strong>), as directory separators, while Linux and Unix use forward <span class="No-Break">slashes (</span><span class="No-Break"><strong class="source-inline">/</strong></span><span class="No-Break">).</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Permissions</strong></span><span class="No-Break">:</span><ul><li>Unix-like <a id="_idIndexMarker519"/>systems use file modes to manage permissions, where permissions are assigned to files <span class="No-Break">and directories.</span></li><li>Windows uses an <strong class="bold">access control list</strong> (<strong class="bold">ACL</strong>) to manage permissions, where permissions are assigned to specific users or groups for a file or directory in a more flexible and <span class="No-Break">granular manner.</span></li><li>In general, it’s a good practice to carefully consider user and group permissions when developing any command-line application, regardless of the operating system it will be <span class="No-Break">running on.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Executing commands</strong></span><span class="No-Break">:</span><ul><li>The <strong class="source-inline">exec</strong> package<a id="_idIndexMarker520"/> in Go provides a convenient way to run commands in the same manner as in the terminal. However, it’s important to note that the command and its arguments must be passed in the correct format for each <span class="No-Break">operating system.</span></li><li>On Windows, you need to specify the file extension (for example, <strong class="source-inline">.exe</strong>, <strong class="source-inline">.bat</strong>, etc.) to run an <span class="No-Break">executable file.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Environmental variables</strong></span><span class="No-Break">:</span><ul><li>Environmental <a id="_idIndexMarker521"/>variables can be used to configure your application, but their names and values may be different between Windows <span class="No-Break">and Linux/Unix.</span></li><li>On Windows, environmental variable names are case-insensitive, while on Linux/Unix, they <span class="No-Break">are case-sensitive.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Line endings</strong></span><span class="No-Break">:</span><ul><li>Windows <a id="_idIndexMarker522"/>uses a different line ending character than Linux/Unix, so be careful when reading or writing files in your Go code. Windows uses a carriage return (<strong class="source-inline">\r</strong>) followed by a line feed (<strong class="source-inline">\n</strong>), while Linux/Unix uses only a line <span class="No-Break">feed (</span><span class="No-Break"><strong class="source-inline">\n</strong></span><span class="No-Break">).</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Signal handling</strong></span><span class="No-Break">:</span><ul><li>In Unix <a id="_idIndexMarker523"/>systems, the <strong class="source-inline">os/signal</strong> package provides a way to handle signals sent to your application. However, this package is not supported <span class="No-Break">on Windows.</span></li><li>To handle signals in a cross-platform way, you can use the <strong class="source-inline">os/exec</strong> <span class="No-Break">package instead.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">User input</strong></span><span class="No-Break">:</span><ul><li>The way <a id="_idIndexMarker524"/>user input is read may also be different between Windows and Linux/Unix. On Windows, you may need to use the <strong class="source-inline">os.Stdin</strong> property, while on Linux/Unix you can use <strong class="source-inline">os.Stdin</strong> or the <strong class="source-inline">bufio</strong><strong class="bold"> </strong>package to read <span class="No-Break">user input.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Console colors</strong></span><span class="No-Break">:</span><ul><li>On Windows, the<a id="_idIndexMarker525"/> console does not support ANSI escape codes for changing text color, so you will need to use a different approach for coloring text in <span class="No-Break">the console.</span></li><li>There are libraries available in Go, such as <strong class="source-inline">go-colorable</strong>, that provide a platform-independent way to handle <span class="No-Break">console colors.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Standard streams</strong></span><span class="No-Break">:</span><ul><li>Standard <a id="_idIndexMarker526"/>streams, such as <strong class="source-inline">os.Stdin</strong>, <strong class="source-inline">os.Stdout</strong>, and <strong class="source-inline">os.Stderr</strong> may behave differently between Windows and Linux/Unix. It’s important to test your code on both platforms to make sure it works <span class="No-Break">as expected.</span></li></ul></li>
			</ul>
			<p>These are some of the differences to be aware of when developing a command-line application in Go for different operating systems. It’s important to thoroughly test your application on each platform to ensure it behaves <span class="No-Break">as expected.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor161"/>Summary</h1>
			<p>The more operating systems your application supports, the more complicated it will get. Hopefully armed with the knowledge of some supportive packages for developing independently of the platform, you’ll feel confident that your application will run similarly across different operating systems. Also, by checking the <strong class="source-inline">runtime</strong> operating system and even separating code into separate operating system-specific files with build tags, you have at least a couple of options for defining how to organize your code. This chapter goes more in-depth than may be necessary, but hopefully, it <span class="No-Break">inspires you.</span></p>
			<p>Building for multiple operating systems will expand the usage of your command-line application. Not only can you reach Linux or Unix users but also Darwin and Windows users as well. If you want to grow your user base, then building an application to support more operating systems is an easy way to <span class="No-Break">do so.</span></p>
			<p>In the next chapter, <a href="B18883_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Building for Humans Versus Machines</em>, we’ll learn how to build a CLI that outputs according to who is receiving it: a machine or human. We’ll also learn how to structure the language for clarity and name commands for consistency with the rest of the CLIs in <span class="No-Break">the community.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor162"/>Questions</h1>
			<ol>
				<li>What are the two different clocks that exist within an operating system? And does the <strong class="source-inline">time.Time</strong> struct in Go store one or the other clock, or both? Which should be used for <span class="No-Break">calculating duration?</span></li>
				<li>Which package constant can be used to determine the <strong class="source-inline">runtime</strong> <span class="No-Break">operating system?</span></li>
				<li>Where is the build tag comment set within a Go file – at the top, bottom, or above the <span class="No-Break">defined function?</span></li>
			</ol>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor163"/>Answers</h1>
			<ol>
				<li value="1">The wall clock and monotonic clock. The <strong class="source-inline">time.Time</strong> struct stores both time values. The monotonic clock value should be used when <span class="No-Break">calculating duration.</span></li>
				<li><span class="No-Break"><strong class="source-inline">runtime.GOOS</strong></span></li>
				<li>At the top first line of the <span class="No-Break">Go file.</span></li>
			</ol>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor164"/>Further reading</h1>
			<ul>
				<li>Visit the online documentation for the packages discussed <span class="No-Break">at </span><a href="https://pkg.go.dev/"><span class="No-Break">https://pkg.go.dev/</span></a><span class="No-Break">.</span></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer047" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer048" class="Content">
			<h1 id="_idParaDest-161"><a id="_idTextAnchor165"/>Part 3: Interactivity and Empathic Driven Design</h1>
			<p>This part is about how to develop a more user-friendly command-line interface (CLI) by considering the end user’s perspective. It covers topics such as building for humans versus machines, using ASCII art to improve information density, and ensuring consistency in flag names and arguments. The section also emphasizes the importance of empathy in CLI development, including rewriting errors in a user-friendly way, providing detailed logging, and creating man pages and usage examples. Additionally, the benefits of interactivity through prompts and terminal dashboards are discussed, with examples of how to build user prompts and dashboards using the <span class="No-Break">Termdash library.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18883_08.xhtml#_idTextAnchor166"><em class="italic">Chapter 8</em></a>, <em class="italic">Building for Humans Versus Machines</em></li>
				<li><a href="B18883_09.xhtml#_idTextAnchor190"><em class="italic">Chapter 9</em></a>, <em class="italic">The Empathic Side of Development</em></li>
				<li><a href="B18883_10.xhtml#_idTextAnchor225"><em class="italic">Chapter 10</em></a>, <em class="italic">Interactivity with Prompts and Terminal Dashboards</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer049">
			</div>
		</div>
	</body></html>