- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing for Different Platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main reasons Go is such a powerful language for building a command-line
    application is how easy it is to develop an application that can be run on multiple
    machines. Go provides several packages that allow developers to write code that
    interacts with the computer independent of the specific operating system. These
    packages include `os`, `time`, `path`, and `runtime`. In the first section, we
    will discuss some commonly used functions in each of these packages and then provide
    some simple examples to pair with the explanations.
  prefs: []
  type: TYPE_NORMAL
- en: To further drill down the importance of these files, we will revisit the `audiofile`
    code and implement a couple of new features that utilize some of the methods that
    exist in these packages. After all, the best way to learn is by implementing new
    features with the new functions and methods you’ve learned about.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then learn how to use the `runtime` library to check the operating
    system the application is running on and then use that to switch between codes.
    By learning about build tags, what they are, and how to use them, we will learn
    about a cleaner way to switch between code blocks to implement a new feature that
    can be run on three different operating systems: Darwin, Windows, and Linux. By
    the end of the chapter, you’ll feel more confident when building your application,
    knowing that the code you are writing will work seamlessly, independent of the
    platform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Packages for platform-independent functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing independent or platform-specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build tags for targeted platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter are available here: [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages for platform-independent functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are building a `os`, `time`, and `path`. Another useful package is
    the `runtime` package, which helps when detecting the operating system the application
    is running on, among other things. We will review each of these packages with
    some simple examples to show how to apply some of the available methods.
  prefs: []
  type: TYPE_NORMAL
- en: The os package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `os` package is your go-to package. We discussed calling external commands
    in the previous chapter; now we will discuss this at a higher level and focus
    on the commands in certain groups: environmental, file, and process operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Environmental operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, the `os` package contains functions that give us information
    about the environment in which the application is running, as well as change the
    environment for future method calls. These common operations are for the following
    working directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func Chdir(dir string) error`: This changes the current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Getwd() (dir string, err error)`: This gets the current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also operations for the environment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func Environ() []string`: This lists environment keys and values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Getenv(key string) string`: This gets environment variables by key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Setenv(key, value string) error`: This sets environment variables by
    key and value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Unsetenv(key string) error`: This unsets an environment variable by key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Clearenv()`: This clears environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func ExpandEnv(s string) string`: This expands values of environment variable
    keys in strings to their values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) code exists on GitHub in
    the `environment.go` file, where we have provided some sample code demonstrating
    using these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To briefly describe the preceding code, we first get the working directory,
    then set it to the `WORKING_DIR` environment variable. To show the change, we
    utilize `os.ExpandEnv` to print the key-value pair. We then unset the `WORKING_DIR`
    environment variable. Again, we show it is unset by using `os.ExpandEnv` to print
    out the key-value pair. The `os.ExpandEnv` variable will print an empty string
    if the environment variable is unset. Finally, we print out the count of the environment
    variables and then range through all to print them. Running the preceding code
    will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code on your machine rather than Linux, Unix, or Windows, the
    resulting output will be similar. Try for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Notes on running the following examples
  prefs: []
  type: TYPE_NORMAL
- en: To run the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) examples, you’ll
    first need to run the install command to install the sleep command to your GOPATH.
    On Unix-like systems, run the `make install` command followed by the `make run`
    command. On Linux systems, run the `./build-linux.sh` script followed by the `./run-linux.sh`
    script. On Windows, run `.\build-windows.ps1` followed by the `.\run-windows.ps1`
    Powershell script.
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `os` package also offers a wide variety of file operations that can be
    applied universally across different operating systems. Many functions and methods
    can be applied to files, so rather than going over each by name, I will group
    the functionality and name a few of each:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following can be used to change file, directory, and link permissions and
    owners:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Chmod(name string, mode` `FileMode) error`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Chown(name string uid, gid` `int) error`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Lchown(name string uid, gid` `int) error`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following can be used to create pipes, files, directories, and links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Pipe() (r *File, w *File,` `err error)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Create(name string) (*``File, error)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Mkdir(name string, perm` `FileMode) error`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Link(oldname, newname` `string) error`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are used to read from files, directories, and links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func ReadFile(name string) ([]``byte, error)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func ReadDir(name string) ([]``DirEntry, error)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Readlink(name string) (``string, error)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following retrieve user-specific data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func UserCacheDir() (``string, error)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func UserConfigDir() (``string, error)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: func UserHomeDir() (string, error)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are used to write to files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: func (f *File) Write(b []byte) (n int, err error)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: func (f *File) WriteString(s string) (n int, err error)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func WriteFile(name string, data []byte, perm` `FileMode) error`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are used for file comparison:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func SameFile(fi1, fi2` `FileInfo) bool`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a `file.go` file within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143)
    code on GitHub in which we have some sample code using these operations. Within
    the file are multiple functions, the first, `func createFiles() error`, handles
    the creation of three files to play around with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os.Create` method allows file creation to work seamlessly on different
    operating systems. The next function, `file()`, utilizes these files to show how
    to use methods that exist within the `os` package. The `file()` function primarily
    gets or changes the current working directory and runs different functions, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func createExamplesDir() (string, error)`: This creates an `examples` directory
    in the user’s home directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func printFiles(dir string) error`: This prints the files/directories under
    the directory represented by `dir string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func sameFileCheck(f1, f2 string) error`: This checks whether two files, represented
    by the `f1` and `f2` strings are the same file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first show the `file()` function to get the overall gist of what is going
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the preceding code. First, we get the current working directory
    and print it out. Then, we call the `createExamplesDir()` function and change
    direction into it.
  prefs: []
  type: TYPE_NORMAL
- en: We then get the current working directory after we change it to ensure it’s
    now the `examplesDir` value. Next, we call the `createFiles()` function to create
    those three files inside the `examplesDir` folder and call the `printFiles()`
    function to list the files in the `examplesDir` working directory.
  prefs: []
  type: TYPE_NORMAL
- en: We change the working directory back to the original working directory and create
    a `symlink` to the `examplesDir` folder under the home directory. We print the
    files existing under the `symlink` to see that they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take `file0` from `examplesDir` and `file0` from `symlink` and compare
    them within the `sameFileCheck` function to ensure they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we run some cleanup functions to remove the `symlink` and `examplesDir`
    folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `file` function utilizes many methods available in the `os` package, from
    getting the working directory to changing it, creating a `symlink`, and removing
    files and directories. Showing the separate function call code will give more
    uses of the `os` package. First, let’s show the code for `createExamplesDir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the `os` package when getting the user’s home directory
    with the `os.UserHomeDir` method and then creates a new folder with the `os.Mkdir`
    method. The next function, `printFiles`, gets the files to print from the `os.ReadDir`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, `sameFileCheck` takes two files represented by strings, `f1` and `f2`.
    To get the file info for each file, the `os.Lstat` method is called on the file
    string. `os.SameFile` takes this file info and returns a `boolean` value to symbolize
    the result – `true` if the files are the same and `false` if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the code samples utilizing methods from the `os` package related
    to file operations. Next, we will discuss some operations related to processes
    running on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Process operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When calling external commands, we can get a `os` package, we can perform actions
    on the process, send the process signals, or wait for the process to complete
    and then receive a process state with information regarding the process that was
    completed. In the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) code, we have
    a `process()` function, which utilizes some of the following methods for processes
    and process states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func Getegid() int`: This returns the effective group ID of the caller. Note,
    this is not supported in Windows, the concept of group IDs is specific to Unix-like
    or Linux systems. For example, this will return `–1` on Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Geteuid() int`: This returns the effective user ID of the caller. Note,
    this is not supported in Windows, the concept of user IDs is specific to Unix-like
    or Linux systems. For example, this will return `-1` on Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Getpid() int`: This gets the process ID of the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func FindProcess(pid int) (*Process, error)`: This returns the process associated
    with the `pid`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func (p *Process) Wait() (*ProcessState, error)`: This returns the process
    state when the process completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func (p *ProcessState) Exited() bool`: This returns `true` if the process
    exited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func (p *ProcessState) Success() bool`: This returns `true` if the process
    exited successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func (p *ProcessState) ExitCode() int`: This returns the exit code of the
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func (p *ProcessState) String() string`: This returns the process state in
    string format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is as follows and starts with several print line statements that return
    the caller’s effective group, user, and process ID. Next, a `cmd` sleep command
    is defined. The command is started and from the `cmd` value, and we get the pid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From the process' pid, we then can find the process using the `os.FindProcess`
    method. We call the `Wait()` method in the process to get `os.ProcessState`. This
    `Wait()` method, like the `cmd.Wait()` method, waits for the process to complete.
    Once completed, the process state is returned. We can check whether the process
    state is exited with the `Exited()` method and whether it was successful with
    the `Success()` method. If so, we print that the process ran successfully along
    with the exit code, which we get from the `ExitCode()` method. Finally, the process
    state can be printed cleanly with the `String()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The time package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operating systems provide access to time via two different types of internal
    clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A wall clock**: This is used for telling the time and is subject to variations
    due to clock synchronization with the **Network Time** **Protocol** (**NTP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A monotonic clock**: This is used for measuring time and is not subject to
    variations due to clock synchronization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To be more specific on the variations, if the wall clock notices that it is
    moving faster or slower than the NTP, it will adjust its clock rate. The monotonic
    clock will not adjust. When measuring durations, it’s important to use the monotonic
    clock. Luckily with Go, the `Time` struct contains both the wall and monotonic
    clocks, and we don’t need to specify which is used. Within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143)
    code, there is a `timer.go` file, which shows how to get the current time and
    duration, regardless of the operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the following code, you’ll see a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also, many of you have also seen that there is a `time.Now().Unix()` method.
    It returns to the epoch time, or time that has elapsed since the Unix epoch, January
    1, 1970, UTC. These methods will work similarly regardless of the operating system
    and architecture they are run on.
  prefs: []
  type: TYPE_NORMAL
- en: The path package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing a command-line application for different operating systems,
    you’ll most likely have to deal with handling file or directory path names. In
    order to handle these appropriately across different operating systems, you’ll
    need to use the `path` package. Because this package does not handle Windows paths
    with drive letters or backslashes, as we used in the previous examples, we’ll
    use the `path/filepath` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `path/filepath` package uses either forward or back slashes depending on
    the operating system. Just for fun, within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143)
    `walking.go` file, I’ve used the `filepath` package to walk through a directory.
    Let’s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We get the current working directory with `os.Getwd()`. Then create a path for
    the `dir1` directory that can be used for any operating system using the `filepath.Join`
    method. Finally, we walk the directory using `filepath.WalkDir` and print out
    the filename and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final package to discuss within this section is the `runtime` package.
    It’s mentioned because it’s used to easily determine the operating system the
    code is running on and therefore execute blocks of code, but there’s so much information
    you can get from the `runtime` system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GOOS`: This returns the running application''s operating system target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOARCH:` This returns the running application’s architecture target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func GOROOT() string`: This returns the root of the Go tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler`: This returns the name of the compiler toolchain that built the
    binary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func NumCPU() int`: This returns the number of logical CPUs usable by the
    current process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func NumGoroutine() int`: This returns the number of goroutines that currently
    exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Version() string`: This returns the Go tree’s version string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This package will provide you with enough information to understand the `runtime`
    environment. Within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) code in
    the `checkRuntime.go` file is the `checkRuntime` function, which puts each of
    these into practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code will provide a similar output to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned about some of the packages required for building a
    command-line application that runs across multiple operating systems and architectures,
    in the next section, we’ll return to the `audiofile` CLI from previous chapters
    and implement a few new functions and show how the methods and functions we’ve
    learned in this section can come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing independent or platform-specific code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to learn is to put what has been learned into practice. In this
    section, we’ll revisit the `audiofile` CLI to implement a few new commands. In
    the code for the new features we’ll implement, the focus will be on the use of
    the `os` and `path`/`filepath` packages.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-independent code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now implement a few new features for the `audiofile` CLI that will run
    independently of the operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Delete`: This deletes stored metadata by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Search`: This searches stored metadata for a specific search string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation of each of these new feature commands was initiated with the cobra-CLI;
    however, the platform-specific code is isolated in the `storage/flatfile.go` file,
    which is the flat file storage for the storage interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s show the `Delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The flat file storage is stored under the user’s home directory under the `audiofile`
    directory. Then, as each new audio file and matching metadata is added, it is
    stored within its unique identifier ID. From the `os` package, we use `os.UserHomeDir()`
    to get the user’s home directory and then use the `filepath.Join` method to create
    the required path to delete all the metadata and files associated with the ID
    independent of the operating system. Make sure you have some audiofiles stored
    locally in the flat file storage. If not, add a few files. For example, use the
    `audio/beatdoctor.mp3` file and upload using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The ID is returned after a successful upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can ensure that the data has been added by running the `list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `audiofile` metadata is returned, so we have double-checked its existence
    in storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then confirm that it’s been deleted by trying to get the audio by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like an unexpected error has occurred, and we haven’t properly implemented
    how to handle this when searching for metadata for a file that has been deleted.
    We’ll need to modify the `services/metadata/handler_getbyid.go` file. At line
    20, where we call the `GetById` method and handle the error, let’s return `200`
    instead of `500` after confirming the error is related to a folder not being found.
    It’s not necessarily an error that the user is searching for an ID that does not
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s much better! Now let’s implement the search functionality. The implementation
    again is isolated to the `storage/flatfile.go` file where you will find the `Search`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Like most of the methods existing in the storage, we start by getting the user’s
    home directory with the `os.UserHomeDir()` method and then, again, use `filepath.Join`
    to get the root `audiofile` path directory, which we will be walking. The `filepath.WalkDir`
    method is called starting at `audioFilePath`. We check each of the `metadata.json`
    files to see whether the `searchFor` string exists within the contents. The method
    returns a slice of `*models.Audio` and if the `searchFor` string is found within
    the contents, the audio is appended onto the slice that will be returned later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give this a try with the following command and see that the expected
    metadata is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve created a few new commands to show how the `os` package and `path/filepath`
    packages can be used in a real-life example, let’s try to write some code that
    can run specifically on one operating system or another.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose your command-line application requires an external application that
    exists on the operating system, but the application required differs between operating
    systems. For the `audiofile` command-line application, suppose we want to create
    a command to play the audio file via the command line. Each operating system will
    need to use a different command to play the audio, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS: `afplay <filepath>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: `start <filepath>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: `aplay <filepath>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, we use the Cobra-CLI to create the new `play` command. Let’s look at
    each different function that would need to be called for each operating system
    to play the audio file. First is the code for macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a command to use the `afplay` executable and pass in the `audiofilePath`.
    Next is the code for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very similar function, except it uses the `start` executable in Windows
    to play the audio. Last is the code for Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the code is practically identical except for the application which is
    called to play the audio. In another case, this code could be more specific for
    the operating system, require different arguments, and even require a full path
    specific to the operating system. Regardless, we are ready to use these functions
    within the `play` command’s `RunE` field. The full `play` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The important part of this code is that we have created a switch case for the
    `runtime.GOOS` value, which tells us what operating system the application is
    running on. Depending on the operating system, a different method is called to
    start a process to play the audio file. Let’s recompile and try the play method
    with one of the stored audio file IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The final section of this chapter will show us how to implement this differently,
    if we’d like to, using build tags.
  prefs: []
  type: TYPE_NORMAL
- en: Build tags for targeted platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Built tags, or build constraints, can be used for many purposes, but in this
    section, we will be discussing how to use build tags to identify which files should
    be included in a package when building for specific operating systems. Build tags
    are given in a comment at the top of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Build tags are passed in as flags when running `go build`. There could be more
    than one tag on a file, and they follow on from the comment with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Each tag is separated by a space. Suppose we want to indicate that this file
    will only be included in a build for the Darwin operating system, then we would
    add this to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then when building the application, we would use something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is just a super quick overview of how build tags can be used to constrain
    files specific to operating systems. Before we go into an implementation of this,
    let’s discuss the `build` package in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The build package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `build` package gathers information about Go packages. In the *Chapter07*
    code repository, there is a `buildChecks.go` file, which uses the `build` package
    to get information about the current package. Let’s see what information this
    code can give us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create the `context` variable and then call the `Import` method. The
    `Import` method is defined in the documentation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the details about the Go package named by the `path` and `srcDir`
    source directory parameters. In this case, the `main` package is returned from
    the package, then we can check all the variables and methods that exist to get
    more information on the package. Running this method locally will return something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Most of the values we are checking are self-explanatory. `AllTags` returns all
    tags that exist within the `main` package. `GoFiles` returns all the files included
    in the `main` package. `Imports` are all the unique imports that exist within
    the package. `IsCommand()` returns `true` if the package is considered a command
    to be installed, or if it is the main package. Finally, the `IsLocalImport` method
    checks whether an import file is local. This is a fun extra detail to interest
    you more about what the `build` package could potentially offer you.
  prefs: []
  type: TYPE_NORMAL
- en: Build tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have learned a little bit more about the `build` package, let’s
    use it for the main purpose of this chapter, building packages for specific operating
    systems. Build tags should be named intentionally, and since we are using them
    for a specific purpose, we can name each build tag by an operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let’s revisit the audio file code. Remember how in the `play` command, we check
    the `runtime` operating system and then call a specific method. Let’s rewrite
    this code using build tags.
  prefs: []
  type: TYPE_NORMAL
- en: Example in the audio file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s first simplify the command’s code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we’ve simplified the code greatly by removing the operating system
    switch statement and the three functions that implement the play feature for each
    operating system. Instead, we’ve taken the code and created three new files: `play_darwin.go`,
    `play_windows.go`, and `play_linux.go`. Within each of these files is a build
    tag for each operating system. Let’s take the Darwin file, `play_darwin.go`, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `play` function has been renamed to match the function called
    in the `play` command in `play.go`. Since only one of the files gets included
    in the build, there’s no confusion as to which `play` function is called. We ensure
    that only one gets called within the `make` file, which is how we are currently
    running the application. In `Makefile`, I’ve designated a command to build specifically
    for Darwin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A Go file containing the `play` function is created for Windows and Linux. The
    specific tags for each operating system will similarly need to be passed into
    the `-tags` flag when building your application. In later chapters, we will discuss
    cross-compiling, which is the next step. But before we do, let’s leave this chapter
    by reviewing a list of OS-level differences to keep in mind while developing for
    multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: OS-level differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since you’ll be building your application for the main operating systems, it’s
    important to know the differences between them and know what to look out for.
    Let’s dive in with the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\`), as directory separators, while Linux and Unix use forward slashes (`/`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix-like systems use file modes to manage permissions, where permissions are
    assigned to files and directories.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows uses an **access control list** (**ACL**) to manage permissions, where
    permissions are assigned to specific users or groups for a file or directory in
    a more flexible and granular manner.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, it’s a good practice to carefully consider user and group permissions
    when developing any command-line application, regardless of the operating system
    it will be running on.*   `exec` package in Go provides a convenient way to run
    commands in the same manner as in the terminal. However, it’s important to note
    that the command and its arguments must be passed in the correct format for each
    operating system.*   On Windows, you need to specify the file extension (for example,
    `.exe`, `.bat`, etc.) to run an executable file.*   **Environmental variables**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Environmental variables can be used to configure your application, but their
    names and values may be different between Windows and Linux/Unix.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, environmental variable names are case-insensitive, while on Linux/Unix,
    they are case-sensitive.*   `\r`) followed by a line feed (`\n`), while Linux/Unix
    uses only a line feed (`\n`).*   `os/signal` package provides a way to handle
    signals sent to your application. However, this package is not supported on Windows.*   To
    handle signals in a cross-platform way, you can use the `os/exec` package instead.*   `os.Stdin`
    property, while on Linux/Unix you can use `os.Stdin` or the `bufio`package to
    read user input.*   `go-colorable`, that provide a platform-independent way to
    handle console colors.*   `os.Stdin`, `os.Stdout`, and `os.Stderr` may behave
    differently between Windows and Linux/Unix. It’s important to test your code on
    both platforms to make sure it works as expected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the differences to be aware of when developing a command-line
    application in Go for different operating systems. It’s important to thoroughly
    test your application on each platform to ensure it behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more operating systems your application supports, the more complicated it
    will get. Hopefully armed with the knowledge of some supportive packages for developing
    independently of the platform, you’ll feel confident that your application will
    run similarly across different operating systems. Also, by checking the `runtime`
    operating system and even separating code into separate operating system-specific
    files with build tags, you have at least a couple of options for defining how
    to organize your code. This chapter goes more in-depth than may be necessary,
    but hopefully, it inspires you.
  prefs: []
  type: TYPE_NORMAL
- en: Building for multiple operating systems will expand the usage of your command-line
    application. Not only can you reach Linux or Unix users but also Darwin and Windows
    users as well. If you want to grow your user base, then building an application
    to support more operating systems is an easy way to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, [*Chapter 8*](B18883_08.xhtml#_idTextAnchor166), *Building
    for Humans Versus Machines*, we’ll learn how to build a CLI that outputs according
    to who is receiving it: a machine or human. We’ll also learn how to structure
    the language for clarity and name commands for consistency with the rest of the
    CLIs in the community.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two different clocks that exist within an operating system? And
    does the `time.Time` struct in Go store one or the other clock, or both? Which
    should be used for calculating duration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package constant can be used to determine the `runtime` operating system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the build tag comment set within a Go file – at the top, bottom, or
    above the defined function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wall clock and monotonic clock. The `time.Time` struct stores both time
    values. The monotonic clock value should be used when calculating duration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`runtime.GOOS`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top first line of the Go file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visit the online documentation for the packages discussed at [https://pkg.go.dev/](https://pkg.go.dev/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Interactivity and Empathic Driven Design'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part is about how to develop a more user-friendly command-line interface
    (CLI) by considering the end user’s perspective. It covers topics such as building
    for humans versus machines, using ASCII art to improve information density, and
    ensuring consistency in flag names and arguments. The section also emphasizes
    the importance of empathy in CLI development, including rewriting errors in a
    user-friendly way, providing detailed logging, and creating man pages and usage
    examples. Additionally, the benefits of interactivity through prompts and terminal
    dashboards are discussed, with examples of how to build user prompts and dashboards
    using the Termdash library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18883_08.xhtml#_idTextAnchor166), *Building for Humans Versus
    Machines*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18883_09.xhtml#_idTextAnchor190), *The Empathic Side of Development*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18883_10.xhtml#_idTextAnchor225), *Interactivity with Prompts
    and Terminal Dashboards*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
