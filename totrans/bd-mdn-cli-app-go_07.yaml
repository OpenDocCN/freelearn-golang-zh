- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Developing for Different Platforms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同平台开发
- en: One of the main reasons Go is such a powerful language for building a command-line
    application is how easy it is to develop an application that can be run on multiple
    machines. Go provides several packages that allow developers to write code that
    interacts with the computer independent of the specific operating system. These
    packages include `os`, `time`, `path`, and `runtime`. In the first section, we
    will discuss some commonly used functions in each of these packages and then provide
    some simple examples to pair with the explanations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言之所以成为构建命令行应用程序的强大语言之一，主要原因是它很容易开发出可以在多台机器上运行的应用程序。Go提供了几个包，允许开发者编写与计算机交互的代码，而无需考虑特定的操作系统。这些包包括
    `os`、`time`、`path` 和 `runtime`。在第一部分，我们将讨论这些包中的一些常用函数，并提供一些简单的示例与解释相匹配。
- en: To further drill down the importance of these files, we will revisit the `audiofile`
    code and implement a couple of new features that utilize some of the methods that
    exist in these packages. After all, the best way to learn is by implementing new
    features with the new functions and methods you’ve learned about.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步强调这些文件的重要性，我们将重新审视 `audiofile` 代码，并实现一些利用这些包中存在的一些方法的新功能。毕竟，通过使用新学到的函数和方法实现新功能，是学习最好的方式。
- en: 'We will then learn how to use the `runtime` library to check the operating
    system the application is running on and then use that to switch between codes.
    By learning about build tags, what they are, and how to use them, we will learn
    about a cleaner way to switch between code blocks to implement a new feature that
    can be run on three different operating systems: Darwin, Windows, and Linux. By
    the end of the chapter, you’ll feel more confident when building your application,
    knowing that the code you are writing will work seamlessly, independent of the
    platform.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将学习如何使用 `runtime` 库来检查应用程序正在运行的操作系统，然后使用该信息在代码之间切换。通过了解构建标签、它们是什么以及如何使用它们，我们将学习一种更干净的方法来在代码块之间切换，以实现一个可以在三个不同的操作系统上运行的新功能：Darwin、Windows
    和 Linux。到本章结束时，当你构建应用程序时，你会更有信心，知道你编写的代码将无缝运行，不受平台限制。
- en: 'In this chapter, we will cover the following key topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: Packages for platform-independent functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于平台无关功能的包
- en: Implementing independent or platform-specific code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现独立或平台特定代码
- en: Build tags for targeted platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对特定平台的构建标签
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter are available here: [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码文件可在以下链接获取：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter07).
- en: Packages for platform-independent functionality
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于平台无关功能的包
- en: When you are building a `os`, `time`, and `path`. Another useful package is
    the `runtime` package, which helps when detecting the operating system the application
    is running on, among other things. We will review each of these packages with
    some simple examples to show how to apply some of the available methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建 `os`、`time` 和 `path` 时。另一个有用的包是 `runtime` 包，它有助于检测应用程序正在运行的操作系统，以及其他事情。我们将通过一些简单的示例来回顾这些包，以展示如何应用一些可用的方法。
- en: The os package
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`os` 包'
- en: 'The `os` package is your go-to package. We discussed calling external commands
    in the previous chapter; now we will discuss this at a higher level and focus
    on the commands in certain groups: environmental, file, and process operations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 包是你的首选包。我们在上一章讨论了调用外部命令；现在我们将从更高层次讨论这个问题，并专注于某些组中的命令：环境、文件和进程操作。'
- en: Environmental operations
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境操作
- en: 'As the name suggests, the `os` package contains functions that give us information
    about the environment in which the application is running, as well as change the
    environment for future method calls. These common operations are for the following
    working directories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`os` 包包含提供关于应用程序运行环境信息的函数，以及为未来的方法调用更改环境。以下是一些常见操作的工作目录：
- en: '`func Chdir(dir string) error`: This changes the current working directory'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Chdir(dir string) error`: 这将更改当前工作目录'
- en: '`func Getwd() (dir string, err error)`: This gets the current working directory'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Getwd() (dir string, err error)`: 这将获取当前工作目录'
- en: 'There are also operations for the environment, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 环境操作也有以下内容：
- en: '`func Environ() []string`: This lists environment keys and values'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Environ() []string`: 列出环境键和值'
- en: '`func Getenv(key string) string`: This gets environment variables by key'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Getenv(key string) string`: 通过键获取环境变量'
- en: '`func Setenv(key, value string) error`: This sets environment variables by
    key and value'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Setenv(key, value string) error`: 通过键和值设置环境变量'
- en: '`func Unsetenv(key string) error`: This unsets an environment variable by key'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Unsetenv(key string) error`: 通过键取消设置环境变量'
- en: '`func Clearenv()`: This clears environment variables'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Clearenv()`: 清除环境变量'
- en: '`func ExpandEnv(s string) string`: This expands values of environment variable
    keys in strings to their values'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func ExpandEnv(s string) string`: 将字符串中环境变量键的值展开为其值'
- en: 'The [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) code exists on GitHub in
    the `environment.go` file, where we have provided some sample code demonstrating
    using these operations:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码[*第7章*](B18883_07.xhtml#_idTextAnchor143)位于GitHub的`environment.go`文件中，我们在这里提供了一些示例代码，展示了如何使用这些操作：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To briefly describe the preceding code, we first get the working directory,
    then set it to the `WORKING_DIR` environment variable. To show the change, we
    utilize `os.ExpandEnv` to print the key-value pair. We then unset the `WORKING_DIR`
    environment variable. Again, we show it is unset by using `os.ExpandEnv` to print
    out the key-value pair. The `os.ExpandEnv` variable will print an empty string
    if the environment variable is unset. Finally, we print out the count of the environment
    variables and then range through all to print them. Running the preceding code
    will produce the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 简要描述前面的代码，我们首先获取工作目录，然后将其设置为`WORKING_DIR`环境变量。为了显示变化，我们使用`os.ExpandEnv`来打印键值对。然后我们取消设置`WORKING_DIR`环境变量。同样，我们再次使用`os.ExpandEnv`来打印键值对。如果环境变量未设置，`os.ExpandEnv`变量将打印空字符串。最后，我们打印出环境变量的数量，然后遍历所有变量来打印它们。运行前面的代码将产生以下输出：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you run this code on your machine rather than Linux, Unix, or Windows, the
    resulting output will be similar. Try for yourself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的机器上运行此代码而不是Linux、Unix或Windows，结果输出将相似。自己试试看。
- en: Notes on running the following examples
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于运行以下示例的说明
- en: To run the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) examples, you’ll
    first need to run the install command to install the sleep command to your GOPATH.
    On Unix-like systems, run the `make install` command followed by the `make run`
    command. On Linux systems, run the `./build-linux.sh` script followed by the `./run-linux.sh`
    script. On Windows, run `.\build-windows.ps1` followed by the `.\run-windows.ps1`
    Powershell script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行[*第7章*](B18883_07.xhtml#_idTextAnchor143)的示例，你首先需要运行安装命令将sleep命令安装到你的GOPATH。在类Unix系统中，运行`make
    install`命令后跟`make run`命令。在Linux系统中，运行`./build-linux.sh`脚本后跟`./run-linux.sh`脚本。在Windows上，运行`.\build-windows.ps1`后跟`.\run-windows.ps1`PowerShell脚本。
- en: File operations
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件操作
- en: 'The `os` package also offers a wide variety of file operations that can be
    applied universally across different operating systems. Many functions and methods
    can be applied to files, so rather than going over each by name, I will group
    the functionality and name a few of each:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包还提供了适用于不同操作系统的广泛文件操作，这些操作可以通用。许多函数和方法可以应用于文件，所以我不一一列举名称，而是将功能分组，并列举一些：'
- en: 'The following can be used to change file, directory, and link permissions and
    owners:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下可用于更改文件、目录和链接的权限和所有者：
- en: '`func Chmod(name string, mode` `FileMode) error`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Chmod(name string, mode FileMode) error`'
- en: '`func Chown(name string uid, gid` `int) error`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Chown(name string uid, gid int) error`'
- en: '`func Lchown(name string uid, gid` `int) error`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Lchown(name string uid, gid int) error`'
- en: 'The following can be used to create pipes, files, directories, and links:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下可用于创建管道、文件、目录和链接：
- en: '`func Pipe() (r *File, w *File,` `err error)`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Pipe() (r *File, w *File, err error)`'
- en: '`func Create(name string) (*``File, error)`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Create(name string) (*File, error)`'
- en: '`func Mkdir(name string, perm` `FileMode) error`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Mkdir(name string, perm FileMode) error`'
- en: '`func Link(oldname, newname` `string) error`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Link(oldname, newname string) error`'
- en: 'The following are used to read from files, directories, and links:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下用于从文件、目录和链接中读取：
- en: '`func ReadFile(name string) ([]``byte, error)`'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func ReadFile(name string) ([]byte, error)`'
- en: '`func ReadDir(name string) ([]``DirEntry, error)`'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func ReadDir(name string) ([]DirEntry, error)`'
- en: '`func Readlink(name string) (``string, error)`'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Readlink(name string) (string, error)`'
- en: 'The following retrieve user-specific data:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下操作用于检索特定用户的数据：
- en: '`func UserCacheDir() (``string, error)`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func UserCacheDir() (string, error)`'
- en: '`func UserConfigDir() (``string, error)`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func UserConfigDir() (string, error)`'
- en: func UserHomeDir() (string, error)
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func UserHomeDir() (string, error)`'
- en: 'The following are used to write to files:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下用于写入文件：
- en: func (f *File) Write(b []byte) (n int, err error)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (f *File) Write(b []byte) (n int, err error)`'
- en: func (f *File) WriteString(s string) (n int, err error)
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (f *File) WriteString(s string) (n int, err error)`'
- en: '`func WriteFile(name string, data []byte, perm` `FileMode) error`'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func WriteFile(name string, data []byte, perm FileMode) error`'
- en: 'The following are used for file comparison:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下用于文件比较：
- en: '`func SameFile(fi1, fi2` `FileInfo) bool`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func SameFile(fi1, fi2 FileInfo) bool`'
- en: 'There is a `file.go` file within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143)
    code on GitHub in which we have some sample code using these operations. Within
    the file are multiple functions, the first, `func createFiles() error`, handles
    the creation of three files to play around with:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上[*第7章*](B18883_07.xhtml#_idTextAnchor143)的代码中有一个`file.go`文件，其中包含一些使用这些操作的示例代码。在该文件中，有多个函数，第一个是`func
    createFiles() error`，它处理创建三个文件以供操作：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `os.Create` method allows file creation to work seamlessly on different
    operating systems. The next function, `file()`, utilizes these files to show how
    to use methods that exist within the `os` package. The `file()` function primarily
    gets or changes the current working directory and runs different functions, including
    the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Create`方法允许在不同的操作系统上无缝地创建文件。下一个函数`file()`利用这些文件来展示如何使用存在于`os`包中的方法。`file()`函数主要获取或更改当前工作目录，并运行不同的函数，包括以下内容：'
- en: '`func createExamplesDir() (string, error)`: This creates an `examples` directory
    in the user’s home directory'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func createExamplesDir() (string, error)`: 这个函数在用户主目录中创建一个`examples`目录'
- en: '`func printFiles(dir string) error`: This prints the files/directories under
    the directory represented by `dir string`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func printFiles(dir string) error`: 这个函数打印出由`dir string`表示的目录下的文件/目录'
- en: '`func sameFileCheck(f1, f2 string) error`: This checks whether two files, represented
    by the `f1` and `f2` strings are the same file'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func sameFileCheck(f1, f2 string) error`: 这个函数检查由`f1`和`f2`字符串表示的两个文件是否是同一个文件'
- en: 'Let’s first show the `file()` function to get the overall gist of what is going
    on:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先展示`file()`函数，以了解整体情况：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s walk through the preceding code. First, we get the current working directory
    and print it out. Then, we call the `createExamplesDir()` function and change
    direction into it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码。首先，我们获取当前工作目录并打印出来。然后，我们调用`createExamplesDir()`函数并进入该目录。
- en: We then get the current working directory after we change it to ensure it’s
    now the `examplesDir` value. Next, we call the `createFiles()` function to create
    those three files inside the `examplesDir` folder and call the `printFiles()`
    function to list the files in the `examplesDir` working directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在更改工作目录后获取当前工作目录，以确保它现在是`examplesDir`值。接下来，我们调用`createFiles()`函数在`examplesDir`文件夹内创建这三个文件，并调用`printFiles()`函数列出`examplesDir`工作目录中的文件。
- en: We change the working directory back to the original working directory and create
    a `symlink` to the `examplesDir` folder under the home directory. We print the
    files existing under the `symlink` to see that they are equal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将工作目录改回原始工作目录，并在主目录下创建一个指向`examplesDir`文件夹的`symlink`。我们打印出`symlink`下的文件，以确认它们是相同的。
- en: Next, we take `file0` from `examplesDir` and `file0` from `symlink` and compare
    them within the `sameFileCheck` function to ensure they are equal.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`examplesDir`中取出`file0`和从`symlink`中取出的`file0`，在`sameFileCheck`函数中进行比较，以确保它们相等。
- en: Finally, we run some cleanup functions to remove the `symlink` and `examplesDir`
    folders.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们运行一些清理函数来删除`symlink`和`examplesDir`文件夹。
- en: 'The `file` function utilizes many methods available in the `os` package, from
    getting the working directory to changing it, creating a `symlink`, and removing
    files and directories. Showing the separate function call code will give more
    uses of the `os` package. First, let’s show the code for `createExamplesDir`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`file()`函数利用了`os`包中许多可用的方法，从获取工作目录到更改它，创建`symlink`，以及删除文件和目录。展示单独的函数调用代码将展示`os`包的更多用途。首先，让我们展示`createExamplesDir`的代码：'
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code uses the `os` package when getting the user’s home directory
    with the `os.UserHomeDir` method and then creates a new folder with the `os.Mkdir`
    method. The next function, `printFiles`, gets the files to print from the `os.ReadDir`
    method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在获取用户主目录时使用了`os.UserHomeDir`方法，然后使用`os.Mkdir`方法创建了一个新文件夹。下一个函数`printFiles`从`os.ReadDir`方法获取要打印的文件：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, `sameFileCheck` takes two files represented by strings, `f1` and `f2`.
    To get the file info for each file, the `os.Lstat` method is called on the file
    string. `os.SameFile` takes this file info and returns a `boolean` value to symbolize
    the result – `true` if the files are the same and `false` if not:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`sameFileCheck`接受两个由字符串表示的文件，`f1`和`f2`。要获取每个文件的文件信息，我们将在文件字符串上调用`os.Lstat`方法。`os.SameFile`接受此文件信息并返回一个`boolean`值来表示结果——如果文件相同则返回`true`，否则返回`false`：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This concludes the code samples utilizing methods from the `os` package related
    to file operations. Next, we will discuss some operations related to processes
    running on the machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了使用`os`包中与文件操作相关的方法的代码示例。接下来，我们将讨论一些与机器上运行的进程相关的操作。
- en: Process operations
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程操作
- en: 'When calling external commands, we can get a `os` package, we can perform actions
    on the process, send the process signals, or wait for the process to complete
    and then receive a process state with information regarding the process that was
    completed. In the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) code, we have
    a `process()` function, which utilizes some of the following methods for processes
    and process states:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用外部命令时，我们可以使用`os`包，我们可以对进程执行操作，发送进程信号，或等待进程完成，然后接收一个包含有关已完成的进程信息的进程状态。在[*第7章*](B18883_07.xhtml#_idTextAnchor143)代码中，我们有一个`process()`函数，它利用以下方法对进程和进程状态进行操作：
- en: '`func Getegid() int`: This returns the effective group ID of the caller. Note,
    this is not supported in Windows, the concept of group IDs is specific to Unix-like
    or Linux systems. For example, this will return `–1` on Windows.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Getegid() int`: 这返回调用者的有效组ID。注意，Windows不支持此功能，组ID的概念仅适用于Unix-like或Linux系统。例如，在Windows上这将返回`-1`。'
- en: '`func Geteuid() int`: This returns the effective user ID of the caller. Note,
    this is not supported in Windows, the concept of user IDs is specific to Unix-like
    or Linux systems. For example, this will return `-1` on Windows.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Geteuid() int`: 这返回调用者的有效用户ID。注意，Windows不支持此功能，用户ID的概念仅适用于Unix-like或Linux系统。例如，在Windows上这将返回`-1`。'
- en: '`func Getpid() int`: This gets the process ID of the caller.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Getpid() int`: 这获取调用者的进程ID。'
- en: '`func FindProcess(pid int) (*Process, error)`: This returns the process associated
    with the `pid`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func FindProcess(pid int) (*Process, error)`: 这返回与`pid`关联的进程。'
- en: '`func (p *Process) Wait() (*ProcessState, error)`: This returns the process
    state when the process completes.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (p *Process) Wait() (*ProcessState, error)`: 当进程完成时返回进程状态。'
- en: '`func (p *ProcessState) Exited() bool`: This returns `true` if the process
    exited.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (p *ProcessState) Exited() bool`: 如果进程已退出，则返回`true`。'
- en: '`func (p *ProcessState) Success() bool`: This returns `true` if the process
    exited successfully.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (p *ProcessState) Success() bool`: 如果进程成功退出，则返回`true`。'
- en: '`func (p *ProcessState) ExitCode() int`: This returns the exit code of the
    process.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (p *ProcessState) ExitCode() int`: 这返回进程的退出代码。'
- en: '`func (p *ProcessState) String() string`: This returns the process state in
    string format.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (p *ProcessState) String() string`: 这以字符串格式返回进程状态。'
- en: 'The code is as follows and starts with several print line statements that return
    the caller’s effective group, user, and process ID. Next, a `cmd` sleep command
    is defined. The command is started and from the `cmd` value, and we get the pid:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码如下，并开始于几个打印行语句，这些语句返回调用者的有效组、用户和进程ID。接下来，定义了一个`cmd`睡眠命令。启动命令，并从`cmd`值中，我们得到pid：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the process' pid, we then can find the process using the `os.FindProcess`
    method. We call the `Wait()` method in the process to get `os.ProcessState`. This
    `Wait()` method, like the `cmd.Wait()` method, waits for the process to complete.
    Once completed, the process state is returned. We can check whether the process
    state is exited with the `Exited()` method and whether it was successful with
    the `Success()` method. If so, we print that the process ran successfully along
    with the exit code, which we get from the `ExitCode()` method. Finally, the process
    state can be printed cleanly with the `String()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从进程的pid，然后我们可以使用`os.FindProcess`方法找到进程。我们调用进程的`Wait()`方法以获取`os.ProcessState`。这个`Wait()`方法，就像`cmd.Wait()`方法一样，等待进程完成。一旦完成，就返回进程状态。我们可以使用`Exited()`方法检查进程状态是否已退出，以及是否成功使用`Success()`方法。如果是这样，我们将打印进程运行成功，以及我们从`ExitCode()`方法获取的退出代码。最后，我们可以使用`String()`方法干净地打印进程状态。
- en: The time package
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间包
- en: 'Operating systems provide access to time via two different types of internal
    clocks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通过两种不同类型的内部时钟提供对时间的访问：
- en: '**A wall clock**: This is used for telling the time and is subject to variations
    due to clock synchronization with the **Network Time** **Protocol** (**NTP**)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**墙钟**：这用于告知时间，并且由于与 **网络时间协议**（**NTP**）的时钟同步，可能会出现变化'
- en: '**A monotonic clock**: This is used for measuring time and is not subject to
    variations due to clock synchronization'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单调时钟**：这用于测量时间，并且不受时钟同步变化的影响'
- en: 'To be more specific on the variations, if the wall clock notices that it is
    moving faster or slower than the NTP, it will adjust its clock rate. The monotonic
    clock will not adjust. When measuring durations, it’s important to use the monotonic
    clock. Luckily with Go, the `Time` struct contains both the wall and monotonic
    clocks, and we don’t need to specify which is used. Within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143)
    code, there is a `timer.go` file, which shows how to get the current time and
    duration, regardless of the operating system:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要更具体地说明这些变化，如果墙钟注意到它比 NTP 移动得更快或更慢，它将调整其时钟速率。单调时钟不会调整。在测量持续时间时，使用单调时钟非常重要。幸运的是，在
    Go 中，`Time` 结构体包含墙钟和单调时钟，我们不需要指定使用哪一个。在 [*第 7 章*](B18883_07.xhtml#_idTextAnchor143)
    的代码中，有一个 `timer.go` 文件，展示了如何获取当前时间和持续时间，无论操作系统如何：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When running the following code, you’ll see a similar output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行以下代码时，你们将看到类似的输出：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Also, many of you have also seen that there is a `time.Now().Unix()` method.
    It returns to the epoch time, or time that has elapsed since the Unix epoch, January
    1, 1970, UTC. These methods will work similarly regardless of the operating system
    and architecture they are run on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你们中的许多人也看到过有一个 `time.Now().Unix()` 方法。它返回自 Unix 纪元（即自 1970 年 1 月 1 日 UTC
    以来经过的时间）的纪元时间。这些方法在它们运行的操作系统和架构上都将以类似的方式工作。
- en: The path package
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径包
- en: When developing a command-line application for different operating systems,
    you’ll most likely have to deal with handling file or directory path names. In
    order to handle these appropriately across different operating systems, you’ll
    need to use the `path` package. Because this package does not handle Windows paths
    with drive letters or backslashes, as we used in the previous examples, we’ll
    use the `path/filepath` package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当为不同的操作系统开发命令行应用程序时，你们很可能会不得不处理文件或目录路径名。为了在不同操作系统中适当地处理这些路径，你们需要使用 `path` 包。因为这个包不处理像我们在前面的例子中使用的那样带有驱动器字母或反斜杠的
    Windows 路径，我们将使用 `path/filepath` 包。
- en: 'The `path/filepath` package uses either forward or back slashes depending on
    the operating system. Just for fun, within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143)
    `walking.go` file, I’ve used the `filepath` package to walk through a directory.
    Let’s look at the code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`path/filepath` 包根据操作系统使用正斜杠或反斜杠。为了好玩，在 [*第 7 章*](B18883_07.xhtml#_idTextAnchor143)
    的 `walking.go` 文件中，我使用了 `filepath` 包来遍历一个目录。让我们看看代码：'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We get the current working directory with `os.Getwd()`. Then create a path for
    the `dir1` directory that can be used for any operating system using the `filepath.Join`
    method. Finally, we walk the directory using `filepath.WalkDir` and print out
    the filename and its contents.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `os.Getwd()` 获取当前工作目录。然后使用 `filepath.Join` 方法为 `dir1` 目录创建一个可用于任何操作系统的路径。最后，我们使用
    `filepath.WalkDir` 遍历目录，并打印出文件名及其内容。
- en: The runtime package
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时包
- en: 'The final package to discuss within this section is the `runtime` package.
    It’s mentioned because it’s used to easily determine the operating system the
    code is running on and therefore execute blocks of code, but there’s so much information
    you can get from the `runtime` system:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中要讨论的最后一个包是 `runtime` 包。它之所以被提及，是因为它被用来轻松确定代码运行的操作系统，并因此执行代码块，但你可以从 `runtime`
    系统中获得大量信息：
- en: '`GOOS`: This returns the running application''s operating system target'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOOS`: 这返回运行应用程序的目标操作系统'
- en: '`GOARCH:` This returns the running application’s architecture target'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOARCH:` 这返回运行应用程序的目标架构'
- en: '`func GOROOT() string`: This returns the root of the Go tree'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func GOROOT() string`: 这返回 Go 树的根目录'
- en: '`Compiler`: This returns the name of the compiler toolchain that built the
    binary'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler`: 这返回构建二进制的编译器工具链的名称'
- en: '`func NumCPU() int`: This returns the number of logical CPUs usable by the
    current process'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func NumCPU() int`: 这返回当前进程可用的逻辑 CPU 数量'
- en: '`func NumGoroutine() int`: This returns the number of goroutines that currently
    exist'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func NumGoroutine() int`: 这返回当前存在的 goroutine 数量'
- en: '`func Version() string`: This returns the Go tree’s version string'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Version() string`: 这返回 Go 树的版本字符串'
- en: 'This package will provide you with enough information to understand the `runtime`
    environment. Within the [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143) code in
    the `checkRuntime.go` file is the `checkRuntime` function, which puts each of
    these into practice:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此包将为您提供足够的信息来理解`runtime`环境。在`checkRuntime.go`文件中的[*第7章*](B18883_07.xhtml#_idTextAnchor143)代码中是`checkRuntime`函数，它将这些方法付诸实践：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the code will provide a similar output to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将提供类似于以下输出的结果：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have learned about some of the packages required for building a
    command-line application that runs across multiple operating systems and architectures,
    in the next section, we’ll return to the `audiofile` CLI from previous chapters
    and implement a few new functions and show how the methods and functions we’ve
    learned in this section can come into play.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了构建跨多个操作系统和架构的命令行应用程序所需的一些包，在下一节中，我们将回到之前章节中的`audiofile` CLI，并实现一些新的功能，展示我们在这部分学到的方法和函数如何发挥作用。
- en: Implementing independent or platform-specific code
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现独立或平台特定代码
- en: The best way to learn is to put what has been learned into practice. In this
    section, we’ll revisit the `audiofile` CLI to implement a few new commands. In
    the code for the new features we’ll implement, the focus will be on the use of
    the `os` and `path`/`filepath` packages.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 学习的最佳方式是将所学知识付诸实践。在本节中，我们将重新审视`audiofile` CLI以实现一些新的命令。在我们将要实现的新功能代码中，重点将放在`os`和`path`/`filepath`包的使用上。
- en: Platform-independent code
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台无关代码
- en: 'Let’s now implement a few new features for the `audiofile` CLI that will run
    independently of the operating system:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为`audiofile` CLI实现一些新的功能，这些功能将独立于操作系统运行：
- en: '`Delete`: This deletes stored metadata by ID'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delete`：通过ID删除存储的元数据'
- en: '`Search`: This searches stored metadata for a specific search string'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Search`：在存储的元数据中搜索特定的搜索字符串'
- en: The creation of each of these new feature commands was initiated with the cobra-CLI;
    however, the platform-specific code is isolated in the `storage/flatfile.go` file,
    which is the flat file storage for the storage interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新功能命令的创建是从cobra-CLI开始的；然而，特定平台的代码被隔离在`storage/flatfile.go`文件中，这是存储接口的平面文件存储。
- en: 'First, let’s show the `Delete` method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们展示`Delete`方法：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The flat file storage is stored under the user’s home directory under the `audiofile`
    directory. Then, as each new audio file and matching metadata is added, it is
    stored within its unique identifier ID. From the `os` package, we use `os.UserHomeDir()`
    to get the user’s home directory and then use the `filepath.Join` method to create
    the required path to delete all the metadata and files associated with the ID
    independent of the operating system. Make sure you have some audiofiles stored
    locally in the flat file storage. If not, add a few files. For example, use the
    `audio/beatdoctor.mp3` file and upload using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 平面文件存储存储在用户主目录下的`audiofile`目录中。然后，随着每个新的音频文件和匹配的元数据的添加，它们被存储在其唯一的标识符ID中。从`os`包中，我们使用`os.UserHomeDir()`来获取用户的主目录，然后使用`filepath.Join`方法创建删除与ID相关的所有元数据和文件的所需路径，这些路径独立于操作系统。确保您在平面文件存储中存储了一些音频文件。如果没有，添加一些文件。例如，使用`audio/beatdoctor.mp3`文件，并使用以下命令上传：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The ID is returned after a successful upload:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 成功上传后返回ID：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can ensure that the data has been added by running the `list` command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`list`命令来确保数据已被添加：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `audiofile` metadata is returned, so we have double-checked its existence
    in storage:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 返回了`audiofile`元数据，因此我们已经检查了它在存储中的存在：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can delete it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除它：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then confirm that it’s been deleted by trying to get the audio by ID:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过尝试通过ID获取音频来确认它已被删除：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Looks like an unexpected error has occurred, and we haven’t properly implemented
    how to handle this when searching for metadata for a file that has been deleted.
    We’ll need to modify the `services/metadata/handler_getbyid.go` file. At line
    20, where we call the `GetById` method and handle the error, let’s return `200`
    instead of `500` after confirming the error is related to a folder not being found.
    It’s not necessarily an error that the user is searching for an ID that does not
    exist:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来发生了一个意外的错误，我们没有正确实现当搜索已删除文件的元数据时如何处理这种情况。我们需要修改`services/metadata/handler_getbyid.go`文件。在第20行，当我们调用`GetById`方法并处理错误时，在确认错误与找不到文件夹有关后，让我们返回`200`而不是`500`。这并不一定是用户正在搜索一个不存在的ID的错误：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s try it again:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That’s much better! Now let’s implement the search functionality. The implementation
    again is isolated to the `storage/flatfile.go` file where you will find the `Search`
    method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了！现在让我们实现搜索功能。实现再次被隔离到`storage/flatfile.go`文件中，你将在其中找到`Search`方法：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like most of the methods existing in the storage, we start by getting the user’s
    home directory with the `os.UserHomeDir()` method and then, again, use `filepath.Join`
    to get the root `audiofile` path directory, which we will be walking. The `filepath.WalkDir`
    method is called starting at `audioFilePath`. We check each of the `metadata.json`
    files to see whether the `searchFor` string exists within the contents. The method
    returns a slice of `*models.Audio` and if the `searchFor` string is found within
    the contents, the audio is appended onto the slice that will be returned later.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如同存储中大多数方法一样，我们首先使用`os.UserHomeDir()`方法获取用户的家目录，然后再次使用`filepath.Join`来获取根`audiofile`路径目录，我们将从这里开始遍历。调用`filepath.WalkDir`方法从`audioFilePath`开始。我们检查每个`metadata.json`文件，看`searchFor`字符串是否存在于内容中。该方法返回一个`*models.Audio`切片，如果`searchFor`字符串在内容中找到，音频将被追加到稍后返回的切片中。
- en: 'Let’s give this a try with the following command and see that the expected
    metadata is returned:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下命令尝试一下，看看是否返回了预期的元数据：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we’ve created a few new commands to show how the `os` package and `path/filepath`
    packages can be used in a real-life example, let’s try to write some code that
    can run specifically on one operating system or another.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些新的命令来展示如何在实际例子中使用`os`包和`path/filepath`包，让我们尝试编写一些可以在特定操作系统上运行的代码。
- en: Platform-specific code
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台特定代码
- en: 'Suppose your command-line application requires an external application that
    exists on the operating system, but the application required differs between operating
    systems. For the `audiofile` command-line application, suppose we want to create
    a command to play the audio file via the command line. Each operating system will
    need to use a different command to play the audio, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的命令行应用程序需要操作系统上存在的外部应用程序，但所需的应用程序在不同操作系统之间可能不同。对于`audiofile`命令行应用程序，假设我们想要创建一个命令来通过命令行播放音频文件。每个操作系统都需要使用不同的命令来播放音频，如下所示：
- en: 'macOS: `afplay <filepath>`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `afplay <filepath>`'
- en: 'Windows: `start <filepath>`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `start <filepath>`'
- en: 'Linux: `aplay <filepath>`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `aplay <filepath>`'
- en: 'Again, we use the Cobra-CLI to create the new `play` command. Let’s look at
    each different function that would need to be called for each operating system
    to play the audio file. First is the code for macOS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用Cobra-CLI来创建新的`play`命令。让我们看看每个操作系统播放音频文件需要调用的不同函数。首先是macOS的代码：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We create a command to use the `afplay` executable and pass in the `audiofilePath`.
    Next is the code for Windows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个命令来使用`afplay`可执行文件并传入`audiofilePath`。接下来是Windows的代码：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a very similar function, except it uses the `start` executable in Windows
    to play the audio. Last is the code for Linux:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常类似的功能，除了它使用Windows中的`start`可执行文件来播放音频。接下来是Linux的代码：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Again, the code is practically identical except for the application which is
    called to play the audio. In another case, this code could be more specific for
    the operating system, require different arguments, and even require a full path
    specific to the operating system. Regardless, we are ready to use these functions
    within the `play` command’s `RunE` field. The full `play` command is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代码几乎完全相同，只是调用播放音频的应用程序不同。在另一种情况下，此代码可能需要针对操作系统更具体，需要不同的参数，甚至需要操作系统特定的完整路径。无论如何，我们已准备好在`play`命令的`RunE`字段中使用这些函数。完整的`play`命令如下：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The important part of this code is that we have created a switch case for the
    `runtime.GOOS` value, which tells us what operating system the application is
    running on. Depending on the operating system, a different method is called to
    start a process to play the audio file. Let’s recompile and try the play method
    with one of the stored audio file IDs:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的重要部分是我们为`runtime.GOOS`值创建了一个switch case，它告诉我们应用程序正在运行在哪个操作系统上。根据操作系统，会调用不同的方法来启动一个进程来播放音频文件。让我们重新编译并尝试使用存储的音频文件ID之一来测试播放方法：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The final section of this chapter will show us how to implement this differently,
    if we’d like to, using build tags.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分将向我们展示如果我们想的话，如何使用构建标签来实现这一点。
- en: Build tags for targeted platforms
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对平台的构建标签
- en: 'Built tags, or build constraints, can be used for many purposes, but in this
    section, we will be discussing how to use build tags to identify which files should
    be included in a package when building for specific operating systems. Build tags
    are given in a comment at the top of a file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 构建标签，或构建约束，可用于许多目的，但在这个部分，我们将讨论如何使用构建标签来识别在为特定操作系统构建时应该包含哪些文件。构建标签位于文件顶部的注释中：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build tags are passed in as flags when running `go build`. There could be more
    than one tag on a file, and they follow on from the comment with the following
    syntax:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `go build` 时，构建标签作为标志传入。一个文件上可能有多个标签，并且它们遵循以下注释语法：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Each tag is separated by a space. Suppose we want to indicate that this file
    will only be included in a build for the Darwin operating system, then we would
    add this to the top of the file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签之间由一个空格分隔。假设我们想表明这个文件只会在 Darwin 操作系统的构建中包含，那么我们就可以将其添加到文件的顶部：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then when building the application, we would use something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在构建应用程序时，我们会使用类似以下的内容：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is just a super quick overview of how build tags can be used to constrain
    files specific to operating systems. Before we go into an implementation of this,
    let’s discuss the `build` package in a bit more detail.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于如何使用构建标签来限制特定于操作系统的文件的快速概述。在我们进入实现之前，让我们更详细地讨论一下 `build` 包。
- en: The build package
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建包
- en: 'The `build` package gathers information about Go packages. In the *Chapter07*
    code repository, there is a `buildChecks.go` file, which uses the `build` package
    to get information about the current package. Let’s see what information this
    code can give us:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 包收集有关 Go 包的信息。在 *第07章* 代码仓库中，有一个 `buildChecks.go` 文件，该文件使用 `build`
    包来获取当前包的信息。让我们看看这段代码能提供哪些信息：'
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We first create the `context` variable and then call the `Import` method. The
    `Import` method is defined in the documentation as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建 `context` 变量，然后调用 `Import` 方法。`Import` 方法在文档中的定义如下：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It returns the details about the Go package named by the `path` and `srcDir`
    source directory parameters. In this case, the `main` package is returned from
    the package, then we can check all the variables and methods that exist to get
    more information on the package. Running this method locally will return something
    like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回由 `path` 和 `srcDir` 源目录参数命名的 Go 包的详细信息。在这种情况下，`main` 包从包中返回，然后我们可以检查所有变量和方法，以获取有关包的更多信息。在本地运行此方法将返回类似以下内容：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Most of the values we are checking are self-explanatory. `AllTags` returns all
    tags that exist within the `main` package. `GoFiles` returns all the files included
    in the `main` package. `Imports` are all the unique imports that exist within
    the package. `IsCommand()` returns `true` if the package is considered a command
    to be installed, or if it is the main package. Finally, the `IsLocalImport` method
    checks whether an import file is local. This is a fun extra detail to interest
    you more about what the `build` package could potentially offer you.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查的大多数值都是不言自明的。`AllTags` 返回存在于 `main` 包中的所有标签。`GoFiles` 返回包含在 `main` 包中的所有文件。`Imports`
    包含包中存在的所有唯一导入。`IsCommand()` 如果包被视为要安装的命令，或者它是主包，则返回 `true`。最后，`IsLocalImport`
    方法检查导入文件是否为本地文件。这是一个有趣的小细节，可以让你对 `build` 包可能提供的功能更加感兴趣。
- en: Build tags
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建标签
- en: 'Now that we have learned a little bit more about the `build` package, let’s
    use it for the main purpose of this chapter, building packages for specific operating
    systems. Build tags should be named intentionally, and since we are using them
    for a specific purpose, we can name each build tag by an operating system:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 `build` 包有了更多了解，让我们用它来完成本章的主要目的，为特定操作系统构建包。构建标签应该有意命名，因为我们使用它们来完成特定目的，所以我们可以按操作系统命名每个构建标签：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let’s revisit the audio file code. Remember how in the `play` command, we check
    the `runtime` operating system and then call a specific method. Let’s rewrite
    this code using build tags.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下音频文件代码。记得在 `play` 命令中，我们检查 `runtime` 操作系统，然后调用一个特定方法。让我们使用构建标签重写这段代码。
- en: Example in the audio file
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频文件中的示例
- en: 'Let’s first simplify the command’s code to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简化命令的代码如下：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Basically, we’ve simplified the code greatly by removing the operating system
    switch statement and the three functions that implement the play feature for each
    operating system. Instead, we’ve taken the code and created three new files: `play_darwin.go`,
    `play_windows.go`, and `play_linux.go`. Within each of these files is a build
    tag for each operating system. Let’s take the Darwin file, `play_darwin.go`, for
    example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice that the `play` function has been renamed to match the function called
    in the `play` command in `play.go`. Since only one of the files gets included
    in the build, there’s no confusion as to which `play` function is called. We ensure
    that only one gets called within the `make` file, which is how we are currently
    running the application. In `Makefile`, I’ve designated a command to build specifically
    for Darwin:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A Go file containing the `play` function is created for Windows and Linux. The
    specific tags for each operating system will similarly need to be passed into
    the `-tags` flag when building your application. In later chapters, we will discuss
    cross-compiling, which is the next step. But before we do, let’s leave this chapter
    by reviewing a list of OS-level differences to keep in mind while developing for
    multiple platforms.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: OS-level differences
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since you’ll be building your application for the main operating systems, it’s
    important to know the differences between them and know what to look out for.
    Let’s dive in with the following list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`\`), as directory separators, while Linux and Unix use forward slashes (`/`).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissions**:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix-like systems use file modes to manage permissions, where permissions are
    assigned to files and directories.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows uses an **access control list** (**ACL**) to manage permissions, where
    permissions are assigned to specific users or groups for a file or directory in
    a more flexible and granular manner.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, it’s a good practice to carefully consider user and group permissions
    when developing any command-line application, regardless of the operating system
    it will be running on.*   `exec` package in Go provides a convenient way to run
    commands in the same manner as in the terminal. However, it’s important to note
    that the command and its arguments must be passed in the correct format for each
    operating system.*   On Windows, you need to specify the file extension (for example,
    `.exe`, `.bat`, etc.) to run an executable file.*   **Environmental variables**:'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Environmental variables can be used to configure your application, but their
    names and values may be different between Windows and Linux/Unix.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, environmental variable names are case-insensitive, while on Linux/Unix,
    they are case-sensitive.*   `\r`) followed by a line feed (`\n`), while Linux/Unix
    uses only a line feed (`\n`).*   `os/signal` package provides a way to handle
    signals sent to your application. However, this package is not supported on Windows.*   To
    handle signals in a cross-platform way, you can use the `os/exec` package instead.*   `os.Stdin`
    property, while on Linux/Unix you can use `os.Stdin` or the `bufio`package to
    read user input.*   `go-colorable`, that provide a platform-independent way to
    handle console colors.*   `os.Stdin`, `os.Stdout`, and `os.Stderr` may behave
    differently between Windows and Linux/Unix. It’s important to test your code on
    both platforms to make sure it works as expected.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the differences to be aware of when developing a command-line
    application in Go for different operating systems. It’s important to thoroughly
    test your application on each platform to ensure it behaves as expected.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more operating systems your application supports, the more complicated it
    will get. Hopefully armed with the knowledge of some supportive packages for developing
    independently of the platform, you’ll feel confident that your application will
    run similarly across different operating systems. Also, by checking the `runtime`
    operating system and even separating code into separate operating system-specific
    files with build tags, you have at least a couple of options for defining how
    to organize your code. This chapter goes more in-depth than may be necessary,
    but hopefully, it inspires you.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Building for multiple operating systems will expand the usage of your command-line
    application. Not only can you reach Linux or Unix users but also Darwin and Windows
    users as well. If you want to grow your user base, then building an application
    to support more operating systems is an easy way to do so.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, [*Chapter 8*](B18883_08.xhtml#_idTextAnchor166), *Building
    for Humans Versus Machines*, we’ll learn how to build a CLI that outputs according
    to who is receiving it: a machine or human. We’ll also learn how to structure
    the language for clarity and name commands for consistency with the rest of the
    CLIs in the community.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two different clocks that exist within an operating system? And
    does the `time.Time` struct in Go store one or the other clock, or both? Which
    should be used for calculating duration?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package constant can be used to determine the `runtime` operating system?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the build tag comment set within a Go file – at the top, bottom, or
    above the defined function?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wall clock and monotonic clock. The `time.Time` struct stores both time
    values. The monotonic clock value should be used when calculating duration.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`runtime.GOOS`'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top first line of the Go file.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visit the online documentation for the packages discussed at [https://pkg.go.dev/](https://pkg.go.dev/).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问在线文档，了解在[https://pkg.go.dev/](https://pkg.go.dev/)中讨论的包。
- en: 'Part 3: Interactivity and Empathic Driven Design'
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：交互性和同理心驱动的设计
- en: This part is about how to develop a more user-friendly command-line interface
    (CLI) by considering the end user’s perspective. It covers topics such as building
    for humans versus machines, using ASCII art to improve information density, and
    ensuring consistency in flag names and arguments. The section also emphasizes
    the importance of empathy in CLI development, including rewriting errors in a
    user-friendly way, providing detailed logging, and creating man pages and usage
    examples. Additionally, the benefits of interactivity through prompts and terminal
    dashboards are discussed, with examples of how to build user prompts and dashboards
    using the Termdash library.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分主要介绍如何从最终用户的角度出发，开发一个更用户友好的命令行界面（CLI）。它涵盖了诸如为人类而非机器构建、使用ASCII艺术提高信息密度、确保标志名称和参数的一致性等主题。本节还强调了同理心在CLI开发中的重要性，包括以用户友好的方式重写错误、提供详细的日志记录、创建手册页和用法示例。此外，还讨论了通过提示和终端仪表板进行交互的好处，并提供了如何使用Termdash库构建用户提示和仪表板的示例。
- en: 'This part has the following chapters:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B18883_08.xhtml#_idTextAnchor166), *Building for Humans Versus
    Machines*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18883_08.xhtml#_idTextAnchor166)，*为人类而非机器构建*'
- en: '[*Chapter 9*](B18883_09.xhtml#_idTextAnchor190), *The Empathic Side of Development*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18883_09.xhtml#_idTextAnchor190)，*开发的同理心方面*'
- en: '[*Chapter 10*](B18883_10.xhtml#_idTextAnchor225), *Interactivity with Prompts
    and Terminal Dashboards*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18883_10.xhtml#_idTextAnchor225)，*使用提示和终端仪表板进行交互*'
