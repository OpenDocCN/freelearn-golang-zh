- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building for Humans versus Machines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为人类与机器构建
- en: Thinking about your end user while you develop your command-line application
    will make you a more empathic developer. Consider not just how you feel about
    the way certain **command-line interfaces** (**CLIs**) behave but also how you
    could improve the experience for yourself and others. Much goes into usability
    and it’s not possible to cram it all into a single chapter, so we suggest following
    up with the suggested article and book in the *Further* *reading* section.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发你的命令行应用程序时考虑你的最终用户会使你成为一个更有同理心的开发者。不仅要考虑你对某些**命令行界面**（**CLIs**）行为的感受，还要考虑你如何改进自己和他人体验。可用性方面有很多内容，不可能全部压缩在一个章节中，所以我们建议你阅读*进一步*阅读部分中建议的文章和书籍。
- en: One of the first points to consider when building your command-line interface
    is that while it will be primarily used by humans, it can also be called within
    scripts, and the output from your program could be used as input into another
    application, such as **grep** or **awk**. Within this chapter, we’ll go over how
    to build for both and how to tell when you’re outputting to one versus the other.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建命令行界面时，首先要考虑的是，尽管它将主要用于人类，但它也可以在脚本中调用，你的程序输出可以被用作其他应用程序的输入，例如**grep**或**awk**。在本章中，我们将介绍如何为两者构建以及如何判断你是在输出给一个还是另一个。
- en: The second point is the use of ASCII art to increase information density. Whether
    you’re outputting data as a table, or adding color or emojis, the idea is to make
    information jump out of the terminal in a way that the end user can quickly understand
    the data presented to them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是使用ASCII艺术来增加信息密度。无论你是以表格形式输出数据，还是添加颜色或表情符号，目的都是让信息以终端用户能够快速理解的方式从终端中跳出来。
- en: 'Finally, consistency also increases clarity for your users. When your CLI uses
    consistency within flag names and positional arguments across different commands
    and subcommands, your user can feel more confident in the steps they need to take
    when navigating your CLI. By the end of the chapter, you’ll hopefully have more
    to consider when building your CLI and be prompted to make usability improvements.
    Within this chapter, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一致性也增加了用户界面的清晰度。当你的CLI在不同命令和子命令的标志名称和位置参数中使用一致性时，用户在导航CLI时可以更有信心。到本章结束时，你可能会在构建CLI时有更多的考虑，并会被提示进行可用性改进。在本章中，我们将涵盖以下主题：
- en: Building for humans versus machines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为人类与机器构建
- en: Increasing information density with ASCII art
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ASCII艺术增加信息密度
- en: Being consistent across CLIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持命令行界面的一致性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You’ll need a Unix operating system to understand and run the examples shared
    in the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要有一个Unix操作系统来理解并运行本章中分享的示例。
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter08](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到代码示例：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter08](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter08)。
- en: Building for humans versus machines
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为人类与机器构建
- en: CLIs have a long history where their interactions were tailored for other programs
    and machines. Their design was more similar to functions within a program than
    a graphical interface. Because of this, many Unix programs today still operate
    under the assumption that they will be interacting with another program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CLI有着悠久的历史，它们的交互是为其他程序和机器量身定制的。它们的设计更类似于程序内的函数，而不是图形界面。正因为如此，许多Unix程序今天仍然基于它们将与另一个程序交互的假设运行。
- en: Today, however, CLIs are more often used by humans than other machines while
    still carrying an outdated interaction design. It’s time that we built CLIs for
    their primary user—the human.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，CLI更多地被人类使用，而不是其他机器，尽管它们仍然携带过时的交互设计。是我们为它们的主要用户——人类构建CLI的时候了。
- en: In this section, we will compare the machine-first design to the human-first
    design and learn how to check whether you are outputting to the TTY. As we can
    recall from [*Chapter 1*](B18883_01.xhtml#_idTextAnchor014), *Understanding CLI
    Standards*, **TTY** is short for **TeleTYpewriter**, which evolved into the input
    and output device to interact with large mainframes. In today’s world, desktop
    environments for operating systems, or **OSs** for short, provide a terminal window.
    This terminal window is a virtual teletypewriter. They are often called **pseudo-teletypes**,
    or **PSY** for short. It’s also an indication that a human is on the other end,
    versus a program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较以机器为先的设计与以人为先的设计，并学习如何检查你是否正在向 TTY 输出。正如我们可以从 [*第 1 章*](B18883_01.xhtml#_idTextAnchor014)
    中回忆起的，*理解 CLI 标准*，**TTY** 是 **TeleTYpewriter** 的缩写，它演变成了与大型主机交互的输入和输出设备。在当今世界，操作系统的桌面环境，或简称为
    **OSs**，提供了一个终端窗口。这个终端窗口是一个虚拟的电传打字机。它们通常被称为 **伪电传打字机**，或简称为 **PSY**。这也表明另一端是一个人类，而不是一个程序。
- en: Is it a TTY?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是 TTY 吗？
- en: First, let’s understand devices. **Devices** can be anything from hard drives,
    RAM disks, DVD players, keyboards, mouses, printers, tape drivers, to TTYs. A
    **device driver** provides the interface between the operating system and the
    device; it provides an API that the operating system understands and accepts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解设备。**设备**可以是硬盘、RAM 磁盘、DVD 播放器、键盘、鼠标、打印机、磁带驱动器，到 TTY 等。**设备驱动程序**提供了操作系统和设备之间的接口；它提供了一个操作系统理解和接受的
    API。
- en: '![Figure 8.1 – Figure showing communication from OS to the TTY device via a
    device driver](img/Figure_8.1._B18883.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 显示通过设备驱动程序从操作系统到 TTY 设备的通信的图](img/Figure_8.1._B18883.jpg)'
- en: Figure 8.1 – Figure showing communication from OS to the TTY device via a device
    driver
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 显示通过设备驱动程序从操作系统到 TTY 设备的通信的图
- en: 'On Unix-based OSs, there are two major device drivers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Unix 的操作系统上，有两个主要的设备驱动程序：
- en: '**Block** – interfaces for devices such as hard drives, RAM disks, and DVD
    players'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块** – 硬盘、RAM 磁盘和 DVD 播放器等设备的接口'
- en: '**Character** – interfaces for the keyboard, mouse, printers, tape drivers,
    TTYs, and so on'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符** – 键盘、鼠标、打印机、磁带驱动器、TTY 等的接口'
- en: If you check that the standard input, **stdin**, or standard output, **stdout**,
    is a **character** device, then you can assume that you are receiving input from
    or sending output to a human.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查标准输入、**stdin** 或标准输出、**stdout** 是一个 **字符** 设备，那么你可以假设你正在从人类接收输入或将输出发送给人类。
- en: Is it a TTY on a Unix or Linux operating system?
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Unix 或 Linux 操作系统中它是 TTY 吗？
- en: In a terminal, if you type the `tty` command, it will output the file name connected
    to **stdin**. Effectively, it is the number of the terminal window.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，如果你输入 `tty` 命令，它将输出连接到 **stdin** 的文件名。实际上，这是终端窗口的编号。
- en: 'Let’s run the command in our Unix terminal window and see what the result is:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Unix 终端窗口中运行这个命令，看看结果是什么：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is a shorthand silent, `-s`, flag that can be used to suppress output.
    However, the application still returns an exit code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简短的静默，`-s`，标志可以用来抑制输出。然而，应用程序仍然返回一个退出码：
- en: Exit code 0 – standard input is coming from a TTY
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出码 0 – 标准输入来自 TTY
- en: Exit code 1 – standard input is not coming from a TTY
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出码 1 – 标准输入不是来自 TTY
- en: Exit code 2 – syntax error from invalid parameters
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出码 2 – 无效参数的语法错误
- en: Exit code 3 – a write error
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出码 3 – 写入错误
- en: 'In Unix, typing `&&` after a command means that the second command will only
    execute if the first command runs successfully, with exit code 0\. So, let’s try
    this code to see if we’re running in a TTY:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 中，在命令后跟 `&&` 表示第二个命令只有在第一个命令成功运行，退出码为 0 时才会执行。所以，让我们尝试这段代码来看看我们是否在 TTY
    中运行：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we ran those commands in a terminal, the result is `this is` `a tty`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在终端中运行了这些命令，结果是 `this is` `a tty`。
- en: Programmatically check on a Unix or Linux operating system
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Unix 或 Linux 操作系统中程序化检查
- en: 'There are a few ways to do this programmatically. We can use the code located
    in the `Chapter-8/isatty.go` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以编程地做到这一点。我们可以使用位于 `Chapter-8/isatty.go` 文件中的代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code grabs the file info from the standard output, **stdout**,
    file with the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用以下代码从标准输出，**stdout**，文件中获取文件信息：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, we check the result of a bitwise operation, `&`, between `fileInfo.Mode()`
    and `os.ModeCharDevice`. The bitwise operator, `&`, copies a bit to the result
    if it exists in both operands.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查 `fileInfo.Mode()` 和 `os.ModeCharDevice` 之间的位运算，`&` 的结果。位运算符 `&` 如果两个操作数中都有该位，则将其复制到结果中。
- en: 'Let’s take a quite simple example: `7&6` within a truth table. `7` values are
    represented by binary `111` and `6` values are represented by `110`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个非常简单的例子：在真值表中 `7&6`。`7` 的值用二进制 `111` 表示，`6` 的值用 `110` 表示。
- en: '![Figure 8.2 – Truth table to show the & operation calculation](img/Figure_8.2._B18883.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 显示 & 操作计算的真值表](img/Figure_8.2._B18883.jpg)'
- en: Figure 8.2 – Truth table to show the & operation calculation
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 显示 & 操作计算的真值表
- en: The `&` operation checks each bit and whether they are the same, and if so,
    carry a bit over, or 1\. If the bits differ, no bit is carried over, or 0\. The
    resulting value is `110`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 操作检查每个位，并判断它们是否相同，如果是，则进位一个位，或 1。如果位不同，则不进位，或 0。结果值是 `110`。'
- en: 'Now, in our more complicated example, the following code, `fileInfo.Mode()
    & os.ModeCharDevice`, performs a bitwise operation between `fileInfo.Mode()` and
    `os.ModeCharDevice`. Let’s look at what this operation looks like when the code
    standard output is connected to a terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的更复杂的例子中，以下代码 `fileInfo.Mode() & os.ModeCharDevice` 在 `fileInfo.Mode()`
    和 `os.ModeCharDevice` 之间执行位运算。让我们看看当代码的标准输出连接到终端时，这个操作看起来像什么：
- en: '| **Is** **a TTY** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **是** **一个 TTY** |'
- en: '| Code | Value |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 值 |'
- en: '| `fileInfo.Mode()` | `Dcrw--w----` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `fileInfo.Mode()` | `Dcrw--w----` |'
- en: '| `os.ModeCharDevice` | `c---------` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `os.ModeCharDevice` | `c---------` |'
- en: '| `fileInfo.Mode()` `&` `os.ModeCharDevice` | `c---------` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `fileInfo.Mode()` `&` `os.ModeCharDevice` | `c---------` |'
- en: '| (`fileInfo.Mode()` `&` `os.ModeCharDevice)` `!= 0` | `TRUE` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| (`fileInfo.Mode()` `&` `os.ModeCharDevice`) `!= 0` | `TRUE` |'
- en: Figure 8.3 – The code next to its value when standard output is connected to
    a TTY
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 当标准输出连接到 TTY 时，代码与其值的相邻
- en: In *Figure 8**.3*, the file mode of the standard output is defined by the `fileInfo.Mode()`
    method call; its value is `os.ModeDevice`, `os.ModeCharDevice`, `stdin` against
    `os.ModCharDevice`, we see that the same bits are carried over and the result
    does not equal zero, hence `(fileInfo.Mode() & os.ModeCharDevice) != 0` is **true**,
    and the device is a TTY.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8**.3 中，标准输出的文件模式由 `fileInfo.Mode()` 方法调用定义；其值是 `os.ModeDevice`，`os.ModeCharDevice`，`stdin`
    对 `os.ModCharDevice`，我们看到相同的位被进位，结果不等于零，因此 `(fileInfo.Mode() & os.ModeCharDevice)
    != 0` 是 **true**，设备是一个 TTY。
- en: 'What would this code look like if the output were piped into another process?
    Let’s look:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出被管道传输到另一个进程，这段代码会是什么样子？让我们看看：
- en: '| **Is not** **a TTY** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **不是** **一个 TTY** |'
- en: '| Code | Value |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 值 |'
- en: '| `fileInfo.Mode()` | `prw-rw----` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `fileInfo.Mode()` | `prw-rw----` |'
- en: '| `os.ModeCharDevice` | `c---------` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `os.ModeCharDevice` | `c---------` |'
- en: '| `fileInfo.Mode()` `&` `os.ModeCharDevice` | `----------` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `fileInfo.Mode()` `&` `os.ModeCharDevice` | `----------` |'
- en: '| (`fileInfo.Mode()` `&` `os.ModeCharDevice)` `!= 0` | `FALSE` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| (`fileInfo.Mode()` `&` `os.ModeCharDevice`) `!= 0` | `FALSE` |'
- en: Figure 8.4 – The code next to its value when standard output is not connected
    to a TTY
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 当标准输出未连接到 TTY 时，代码与其值的相邻
- en: Now the standard output’s value is `os.ModeNamedPipe`, `os.ModeCharDevice`,
    we see that no bits are copied over, hence `(fileInfo.Mode() & os.ModeCharDevice)
    != 0` is **false**, and the device is not a TTY.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在标准输出的值是 `os.ModeNamedPipe`，`os.ModeCharDevice`，我们看到没有位被复制，因此 `(fileInfo.Mode()
    & os.ModeCharDevice) != 0` 是 **false**，设备不是一个 TTY。
- en: Programmatically check on any operating system
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在任何操作系统上编程检查
- en: 'We suggest using a package that has already gone through the trouble of determining
    the code for a larger set of operating systems to check whether standard output
    is sent to a TTY. The most popular package we found was [github.com/mattn/go-isatty](https://github.com/mattn/go-isatty),
    which we used in the `Chapter-8/utils/isatty.go` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用一个已经为检查更大集合的操作系统确定代码的包，以检查标准输出是否发送到 TTY。我们发现最受欢迎的包是 [github.com/mattn/go-isatty](https://github.com/mattn/go-isatty)，我们在
    `Chapter-8/utils/isatty.go` 文件中使用了它：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we know whether we are outputting to a TTY, which indicates that there
    is a human on the other end, versus not a TTY, we can tailor our output accordingly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们是输出到一个 TTY，这表明另一端有一个人，而不是 TTY，我们可以相应地调整我们的输出。
- en: Designing for a machine
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为机器设计
- en: As aforementioned, CLIs were originally designed for machines first. It is important
    to understand what it exactly means to design another program. Although we would
    want to tailor our applications toward a human-first design, there will be times
    when we would need to output in a way that can easily be passed as input to the
    `grep` or `awk` command, because other applications will expect streams of either
    plain or JSON text.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CLI最初是为机器设计的。了解设计另一个程序的确切含义很重要。虽然我们希望将我们的应用程序调整为以人为中心的设计，但有时我们需要以可以轻松传递给`grep`或`awk`命令的方式输出，因为其他应用程序会期望接收纯文本或JSON文本的流。
- en: Users will be using your CLI in many unexpected ways. Some of those ways are
    often within a bash script that pipes the output of your command as input into
    another application. If your application, as it should, outputs in the human-readable
    format first, it needs to also output in machine-readable format when the standard
    input is not connected to a TTY terminal. In the latter case, make sure any color
    and ASCII art, in the form of progress bars, for example, are disabled. The text
    should also be single-lined tabular data that can easily be integrated with the
    `grep` and `awk` tools.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能会以许多意想不到的方式使用您的CLI。其中一些方式通常是在bash脚本中，将您的命令的输出作为输入传递给另一个应用程序。如果您的应用程序，正如它应该做的那样，首先以人类可读的格式输出，那么当标准输入未连接到TTY终端时，它也需要以机器可读的格式输出。在后一种情况下，请确保任何颜色和ASCII艺术，例如进度条，都被禁用。文本应该是单行表格数据，可以轻松地与`grep`和`awk`工具集成。
- en: 'Also, it is important that you offer several persistent flags for your users
    to output in machine-readable output when necessary:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当需要时，为用户提供几个持久标志，以便以机器可读的输出格式输出也很重要：
- en: '`--plain`, for outputting plain text with one record of data per line'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--plain`，用于输出每行一个数据记录的纯文本'
- en: '`--json`, for outputting JSON text that can be piped to and from the curl command'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--json`，用于输出可以传递到curl命令的JSON文本'
- en: '`--quiet`, `-q`, or `--silent`, `-s`, for suppressing nonessential output'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--quiet`、`-q`或`--silent`、`-s`，用于抑制非必要输出'
- en: Provide plain text when it does not impact usability. In other cases, offer
    the optional previous flags to give the user the ability to pipe its output easily
    into the input of another.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当不影响可用性时，提供纯文本。在其他情况下，提供可选的前置标志，使用户能够轻松地将输出传递到另一个应用程序的输入。
- en: Designing for a human
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为人类设计
- en: 'The modern command-line application is designed for its primary consumer—the
    human. This may seemingly complicate the interface because there’s a bit more
    to consider. The way data is output and how quickly the data is returned can affect
    how a user perceives the quality and robustness of your CLI. We’ll go over some
    key areas of design:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的命令行应用程序是为其主要消费者——人类设计的。这可能会看似使界面复杂化，因为需要考虑的因素更多。数据的输出方式和数据返回的速度可能会影响用户对您的CLI的质量和鲁棒性的感知。我们将讨论一些关键的设计领域：
- en: Conversation as the norm
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话成为常态
- en: Empathy
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同理心
- en: Personalization
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性化
- en: Visual language
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉语言
- en: Let’s go into each in more detail so we can fully understand how this impacts
    a human-centred design.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨每一个方面，以便我们能够完全理解这对以人为中心的设计有何影响。
- en: Conversation as the norm
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对话成为常态
- en: Since your CLI will be responding to a human and not another program, interaction
    should flow like a conversation. As an application leans toward a conversational
    language, the user will feel more at ease. Consider your application as the guide,
    as well, toward usage of the CLI.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的CLI将响应人类而不是另一个程序，因此交互应该像对话一样流畅。将您的应用程序视为CLI使用的指南，也会让用户感到更加自在。
- en: When a user runs a command and is missing important flags or arguments, then
    your application can prompt for these values. Prompts, or surveys, are a way to
    include a conversational back-and-forth flow of asking questions and receiving
    answers from the user. However, prompts should not be a requirement as flags and
    arguments should be available options for your commands. We will be going over
    prompts in more detail in [*Chapter 10*](B18883_10.xhtml#_idTextAnchor225), *Interactivity
    with Prompts and* *Terminal Dashboards*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户运行命令而缺少重要的标志或参数时，则您的应用程序可以提示这些值。提示或调查是包括提问和从用户那里接收答案的对话式来回流程的方式。然而，提示不应成为必需的，因为标志和参数应该是命令的可选选项。我们将在[*第10章*](B18883_10.xhtml#_idTextAnchor225)“使用提示和终端仪表板进行交互”中更详细地讨论提示。
- en: If your application contains a state, then communicate the current state similar
    to how `git` provides a `status` command and notifies the user when any commands
    change the state. Similarly, if your application provides workflows, typically
    defined by a chain of commands, then you can suggest commands to run next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序包含状态，则类似于`git`提供的`status`命令并通知用户任何命令更改状态的方式，传达当前状态。同样，如果您的应用程序提供工作流程，通常由一系列命令定义，那么您可以建议运行下一个命令。
- en: Being succinct is important when communicating with your user. Just like in
    conversation, if we muddle our words with too much extraneous information, people
    can become confused about the point we are trying to make. By communicating what’s
    important, but keeping it brief, our users will get the most important information
    quickly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在与用户沟通时，简洁很重要。就像在对话中一样，如果我们用过多的无关信息混淆我们的语言，人们可能会对我们的意图感到困惑。通过传达重要信息，但保持简短，我们的用户将快速获得最重要的信息。
- en: Context is important. If you are communicating with an end user versus a developer,
    that makes a difference. In that case, unless you are in verbose mode, there’s
    no reason to output anything only a developer would understand.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文很重要。如果您在与最终用户而不是开发者沟通，这会有所不同。在这种情况下，除非您处于详细模式，否则没有必要输出只有开发者才能理解的内容。
- en: 'If the user is doing anything dangerous, ask for confirmation and match the
    level of confirmation with the level of danger that can be invoked by the command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户正在执行任何危险的操作，请请求确认，并将确认级别与命令可能引发的危险级别相匹配：
- en: '`delete` command, you don’t need to confirm'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`命令，不需要确认'
- en: If not a `delete` command, prompt for confirmation
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是`delete`命令，则提示确认
- en: '**Moderate**:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适度**：'
- en: 'Example: deleting a directory, remote resource, or bulk modification that cannot
    easily be reverted'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：删除目录、远程资源或无法轻易撤销的大批量修改
- en: 'Confirmation:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认：
- en: Prompt for confirmation.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示确认。
- en: Provide a **dry run** operation. A **dry run** operation is used to see the
    results of the operation without actually making any modifications to the data.*   `–confirm="name-of-resource"`
    so it is still scriptable
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个**dry run**操作。**dry run**操作用于查看操作的结果，而实际上不对数据进行任何修改。*   `–confirm="name-of-resource"`使其仍然可脚本化
- en: In general, we want to make it increasingly more difficult for the user to do
    something more difficult. It is a way of guiding the user away from any accidents.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望让用户越来越难以执行更难的事情。这是一种引导用户避免任何意外的方法。
- en: Any user input should always be validated early on to prevent anything unnecessarily
    bad from happening. Make the error returned understandable to the user who passed
    in bad data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户输入都应该尽早进行验证，以防止发生不必要的坏事情。确保返回的错误对传递了坏数据的用户是可理解的。
- en: In a conversation, any confidential information must be secured. Make sure that
    any passwords are protected and provide secure methods for users to submit their
    credentials. For example, consider only accepting sensitive data via files only.
    You can offer a `–password-file` flag that allows the user to pass in a file or
    data via standard input. This method provides a discreet method for passing in
    secret data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话中，必须确保任何机密信息得到保护。确保任何密码都得到保护，并为用户提供安全的方法提交他们的凭证。例如，仅考虑通过文件接受敏感数据。您可以提供一个`–password-file`标志，允许用户通过标准输入传递文件或数据。这种方法为传递秘密数据提供了一种隐蔽的方法。
- en: Be transparent in conversation. Any actions that cross the boundaries of the
    program should be stated explicitly. This includes reading or writing files that
    the user did not pass in as arguments unless these files are storing an internal
    state within a cache. This may also include any actions when talking to a remote
    server.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话中保持透明。任何超出程序边界的操作都应明确说明。这包括读取或写入用户未作为参数传递的文件，除非这些文件在缓存中存储内部状态。这还可能包括与远程服务器通信时的任何操作。
- en: Finally, response time is more important than speed. Print something to the
    user in under 100 milliseconds. If you are making a network request, print out
    something before the request is made so it doesn’t look like the application is
    hanging or appearing broken. This will make your application appear more robust
    to its end user.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应时间比速度更重要。在100毫秒内向用户打印一些内容。如果您正在发起网络请求，请在请求之前打印一些内容，这样就不会看起来像应用程序挂起或出现故障。这将使您的应用程序对最终用户看起来更健壮。
- en: Let’s revisit our audio metadata CLI project. Under [*Chapter 8*](B18883_08.xhtml#_idTextAnchor166)’s
    `audiofile` repo, we’ll make some changes to create a conversational flow where
    it might be missing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾我们的音频元数据CLI项目。在[*第8章*](B18883_08.xhtml#_idTextAnchor166)的`audiofile`仓库中，我们将进行一些更改以创建可能缺失的对话流程。
- en: 'Example 1: Prompt for information when a flag is missing'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 1：当标志缺失时提示信息
- en: 'Using the Cobra CLI, if a flag is required, it would automatically return an
    error if the flag were missing when the command is called. Based on some of the
    guidelines mentioned in this section, rather than just returning an error, let’s
    prompt for missing data instead. In the `audiofile` code for [*Chapter 8*](B18883_08.xhtml#_idTextAnchor166),
    in the `utils/ask.go` file, we create two functions using the survey package [github.com/AlecAivazis/survey/v2](https://github.com/AlecAivazis/survey/v2)
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cobra CLI，如果需要标志，当命令调用时如果标志缺失，它会自动返回错误。根据本节中提到的某些指南，而不是仅仅返回错误，让我们提示缺失的数据。在[*第8章*](B18883_08.xhtml#_idTextAnchor166)的`audiofile`代码中，在`utils/ask.go`文件中，我们使用调查包[github.com/AlecAivazis/survey/v2](https://github.com/AlecAivazis/survey/v2)创建了两个函数，如下所示：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These two functions can now be called when checking the flags that are passed
    and whether the values are still empty. For example, in the `cmd/get.go` file,
    we check for the `id` flag value and if it’s still empty, prompt the user for
    the `id`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查传递的标志和值是否仍然为空时，现在可以调用这两个函数。例如，在`cmd/get.go`文件中，我们检查`id`标志的值，如果它仍然为空，则提示用户输入`id`：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this gives the user the following experience:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会给用户以下体验：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, in the `cmd/upload.go` file, we check for the filename flag value
    and if it’s still empty, prompt the user for the filename. Because the prompt
    allows the user to drill down suggested files, we now get the following experience:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在`cmd/upload.go`文件中，我们检查文件名标志的值，如果它仍然为空，则提示用户输入文件名。因为提示允许用户深入查看建议的文件，所以我们现在得到了以下体验：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, press the Tab key for suggestions to reveal a drill-down menu:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按Tab键以显示建议并揭示下拉菜单：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Providing a prompt helps to guide the user and for them to understand how to
    run the command works.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 提供提示有助于引导用户并让他们了解如何运行命令。
- en: 'Example 2: Confirm deletion'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 2：确认删除
- en: 'Another way we can help to guide users toward safely using the CLI and protecting
    them from making any mistakes is to ask the user for confirmation when doing something
    dangerous. Although it is not necessary to do so during an explicit delete operation,
    we created a confirmation function that can be used with a configurable message
    in any type of dangerous situation. The function exists under the `utils/confirm.go`
    file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种帮助用户安全使用CLI并防止他们犯错误的方法是在进行危险操作时请求用户确认。尽管在明确的删除操作中这样做不是必需的，但我们创建了一个可以在任何类型的危险情况下使用、带有可配置信息的确认函数。该函数位于`utils/confirm.go`文件中：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Example 3: Notify users when making a network request'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 3：在网络请求时通知用户
- en: 'Before any HTTP request is made, notifying the user helps them to understand
    what’s going on, especially if the request hangs or becomes unresponsive. We’ve
    added a message prior to each network request in each command. The `get` command
    now has the following line prior to the client running the `Do` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出任何HTTP请求之前，通知用户有助于他们了解正在发生的事情，特别是如果请求挂起或变得无响应。我们在每个命令的网络请求之前添加了一条消息。`get`命令现在在客户端运行`Do`方法之前有以下一行：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Empathy
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同理心
- en: 'There are some simple modifications you can make to your command-line application
    to empathize with your users:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对命令行应用程序进行一些简单的修改，以体现对用户的同理心：
- en: 'Be helpful:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助：
- en: Provide help text and documentation
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供帮助文本和文档
- en: Suggest commands
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议命令
- en: Rewrite errors in an understandable way
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以可理解的方式重写错误
- en: Invite user feedback and bug submission
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邀请用户反馈和错误提交
- en: In [*Chapter 9*](B18883_09.xhtml#_idTextAnchor190), *The Empathic Side of Development*,
    we will go through the ways in which you can help guide your users toward success
    using help text, documentation, widespread support, and providing an effortless
    way for users to provide feedback and submit bugs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18883_09.xhtml#_idTextAnchor190)《开发的同理心一面》中，我们将探讨您可以通过帮助文本、文档、广泛的支持以及为用户提供轻松提供反馈和提交错误的方式，帮助用户走向成功的方法。
- en: 'Example 1: Offering command suggestions'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 1：提供命令建议
- en: 'The Cobra CLI offers some empathy when a user mistypes a command. Let’s look
    at the following example where the user mistypes `upload` as `upolad`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户误输入命令时，Cobra CLI 会提供一些同情。让我们看看以下示例，其中用户将 `upload` 错误地输入为 `upolad`：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 2 – Offer an effortless way to submit bugs
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 2 – 提供一种轻松提交错误报告的方式
- en: 'In [*Chapter 9*](B18883_09.xhtml#_idTextAnchor190)*, The Empathic Side of Development,*
    we define a bug command that will launch the default browser and navigate to the
    GitHub repository''s new issue page to file a bug report:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B18883_09.xhtml#_idTextAnchor190)“开发的同理心方面”，我们定义了一个错误命令，该命令将启动默认浏览器并导航到
    GitHub 仓库的新问题页面以提交错误报告：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Example 3: Print usage command is used incorrectly'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 3：使用错误的打印用法命令
- en: 'Suppose a user does not input a value to search for when running the search
    command. The CLI application will prompt for a value to search for. If a value
    is not passed in by the user, the CLI will output the proper usage of the command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户在运行搜索命令时没有输入要搜索的值。CLI应用程序将提示用户输入要搜索的值。如果用户没有传入值，CLI将输出命令的正确用法：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Personalization
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 个性化
- en: In general, make the default the right thing for most users, but also allow
    users to personalize their experience with your CLI. The configuration gives the
    users a chance to personalize their experience with your CLI and make it more
    their own.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使默认设置对大多数用户来说都是正确的，但同时也允许用户通过 CLI 个性化他们的体验。配置给用户一个机会来个性化他们的 CLI 体验，使其更加符合他们的需求。
- en: 'Example 1: Technical configuration with Viper'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 1：使用 Viper 的技术配置
- en: 'Using `audiofile` as an example, let’s create a simple configuration setup
    with Viper to offer the user the ability to change any defaults to their liking.
    The configurations that we’ve created are for the API and CLI applications. For
    the API, we’ve defined the `configs/api.json` file, which contains the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `audiofile` 为例，让我们使用 Viper 创建一个简单的配置设置，使用户能够根据他们的喜好更改任何默认设置。我们创建的配置是为 API
    和 CLI 应用程序。对于 API，我们定义了 `configs/api.json` 文件，其中包含以下内容：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The API will always execute locally to where it’s being executed. Then, for
    the CLI, we’ve defined a similar simple file, `configs/cli.json`, containing the
    following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: API 将始终在执行的地方本地执行。然后，对于 CLI，我们定义了一个类似的简单文件，`configs/cli.json`，包含以下内容：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the API is running on an external host with a different port, then these
    values can be modified within the configuration. For the CLI to point to the new
    hostname, we’ll need to update any references within the CLI commands to use the
    value in the configuration. For example, in the `cmd/get.go` file, the path is
    defined as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 在具有不同端口号的外部主机上运行，则可以在配置中修改这些值。为了使 CLI 指向新的主机名，我们需要更新 CLI 命令中的任何引用以使用配置中的值。例如，在
    `cmd/get.go` 文件中，路径被定义为：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To initialize these values and provide defaults if any required values are
    missing from the configuration, we run a `Configure` function defined in `cmd/root.go`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化这些值并在配置中缺少任何必需的值时提供默认值，我们运行定义在 `cmd/root.go` 中的 `Configure` 函数：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A similar code exists within the `cmd/api.go` file to gather some of the same
    information. Now that this is set up, if there are any changes the user wants
    to make to the hostname, log level, or port, there is only one configuration file
    to modify.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cmd/api.go` 文件中存在类似的代码，用于收集一些相同的信息。现在，如果用户想要更改主机名、日志级别或端口号，只需修改一个配置文件。
- en: 'Example 2: Environment variable configuration'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 2：环境变量配置
- en: 'Suppose there is an environment variable specific to the application that allows
    users to define the foreground and background color to use. This environment variable
    could be named `AUDIOFILE_COLOR_MODE`. Using the Viper configuration again, values
    for the foreground and background texts may be used to overwrite default settings.
    While this is not implemented within our CLI, the Viper configuration may look
    like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个特定于应用程序的环境变量，允许用户定义要使用的前景色和背景色。这个环境变量可以命名为 `AUDIOFILE_COLOR_MODE`。再次使用
    Viper 配置，可以使用前景色和背景色文本来覆盖默认设置。虽然这在我们 CLI 中没有实现，但 Viper 配置可能看起来如下：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Example 3: Storage location'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 3：存储位置
- en: 'Sometimes users want the location of certain output, logging, for example,
    to be stored in a particular area. Providing details within Viper can allow defaults
    to be overwritten. Again, this is not currently implemented within our CLI, but
    if we were to provide this option within our configuration, it may look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用户希望某些输出，例如日志，存储在特定区域。在Viper中提供详细信息可以允许覆盖默认值。再次强调，这目前还没有在我们的CLI中实现，但如果我们在配置中提供此选项，它可能看起来像这样：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Any other new configuration values can be added with a similar approach. Providing
    the ability to configure your application is the start for personalization. Think
    of the many ways you can configure your CLI: color settings, disabling prompts
    or ASCII art, default formatting, and more.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他新的配置值都可以用类似的方法添加。提供配置应用程序的能力是个性化的起点。想想你有多少种方式可以配置你的CLI：颜色设置、禁用提示或ASCII艺术、默认格式化等等。
- en: Pagination
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分页
- en: Use a pager when you are outputting a lot of text, but be careful because sometimes
    the implementation can be error-prone.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输出大量文本时，请使用分页器，但要注意，有时实现可能会出错。
- en: Pagination for Unix or Linux
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unix或Linux的分页
- en: 'On a Unix or Linux machine, you may use the `less` command for pagination.
    Calling the `less` command with a sensible set of options, such as `less -FIRX`,
    pagination does not occur if the contents fit on a single screen, case is ignored
    when searching, color and formatting are enabled, and the content is kept on the
    screen when `less` quits. We will use this as an example within the next section
    when outputting table data, and in preparation, within the `utils` package, we
    add the following files: `pager_darwin.go` and `pager_linux.go`, with a `Pager`
    function. In our case, though, we use the `–r` flag only because we want to continue
    displaying colors in the table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix或Linux机器上，你可以使用`less`命令进行分页。使用合理的选项集调用`less`命令，如`less -FIRX`，如果内容适合单屏，则不会发生分页，搜索时忽略大小写，启用颜色和格式，当`less`退出时内容保持在屏幕上。我们将在下一节输出表格数据时使用这个例子，作为准备，在`utils`包中，我们添加以下文件：`pager_darwin.go`和`pager_linux.go`，包含一个`Pager`函数。然而，在我们的情况下，我们只使用`-r`标志，因为我们想继续在表格中显示颜色：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pagination for Windows
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows的分页
- en: 'On a Windows machine, we use the `more` command instead. Within the `utils`
    package, we add the `pager_windows.go` file following with a `Pager` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上，我们使用`more`命令。在`utils`包中，我们添加了`pager_windows.go`文件，并跟随一个`Pager`函数：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you know how to handle the pagination of output on the three major operating
    systems. This will also help users when you are outputting a large amount of data
    to scroll through the output easily.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何在三个主要操作系统上处理输出分页。当你输出大量数据以便用户轻松滚动时，这也会帮助用户。
- en: Visual language
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视觉语言
- en: Depending on the data, it might be easier for the users to see it in plain text,
    table format, or in JSON format. Remember to provide the user with options to
    return data in the format they prefer with the `–plain` or `–``json` flag.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据，用户可能更容易以纯文本、表格格式或JSON格式查看它。请记住，使用`-plain`或`-json`标志为用户提供选项，以他们喜欢的格式返回数据。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, for all of the data to appear within a user’s window, some lines
    may be wrapped within a cell. This will break scripts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了使所有数据都显示在用户的窗口中，某些行可能被包裹在单元格中。这将破坏脚本。
- en: There are many visual cues that can be displayed to the user to increase information
    density. For example, if something is going to take a long time, use a progress
    bar and provide an estimate of the time remaining. If there is a success or failure,
    utilize color codes to provide an additional level of information for the user
    to consume.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多视觉提示可以显示给用户，以增加信息密度。例如，如果某件事情需要很长时间，可以使用进度条并提供剩余时间的估计。如果成功或失败，利用颜色代码为用户提供额外的信息层次。
- en: We now know how to determine whether we are outputting to a human via a terminal
    or to another application, so knowing the difference allows us to output data
    appropriately. Let’s continue to the next section to discuss fun examples to provide
    data with ASCII visualizations to improve information density.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何确定我们是通过终端输出给人类还是输出给另一个应用程序，因此了解这些差异使我们能够适当地输出数据。让我们继续到下一节，讨论一些有趣的例子，通过ASCII可视化提供数据以增加信息密度。
- en: Increasing information density with ASCII art
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASCII艺术增加信息密度
- en: As the title of this section states, you can increase information density using
    ASCII art. For example, running the `ls` command shows file permissions in a way
    a user can easily scan with their eyes and understand with pattern recognition.
    Also, using a highlighter pen when studying in a textbook to literally highlight
    a sentence or group of words makes certain phrases jump out as more important.
    In this section, we’ll talk about some common uses for ASCII art to increase the
    understanding of the importance of shared information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节标题所述，您可以使用ASCII艺术来增加信息密度。例如，运行`ls`命令会以用户易于用眼睛扫描和理解的方式显示文件权限。同样，在教科书学习时使用荧光笔实际突出显示一句话或一组单词，可以使某些短语显得更加重要。在本节中，我们将讨论一些ASCII艺术的常见用途，以增加共享信息重要性的理解。
- en: Displaying information with tables
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表格显示信息
- en: Probably the clearest way that data can be displayed to users is in a table
    format. Just like the `ls` format, patterns can jump out more easily in a table
    format. Sometimes records can contain data that is longer than the width of the
    screen and lines become wrapped. This can break scripts that might be relying
    on one record per line.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示数据最清晰的方式可能是以表格格式。就像`ls`格式一样，在表格格式中，模式更容易跳出来。有时记录可能包含比屏幕宽度更长的数据，行会自动换行。这可能会破坏依赖于每行一个记录的脚本。
- en: Let’s take our audiofile as an example and instead of returning the JSON output,
    use the package to return the data cleanly in a table. We can keep the ability
    to return JSON output for when the user decides to require it using the `–``json`
    flag.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的音频文件为例，而不是返回JSON输出，而是使用该包以整洁的方式返回数据，以表格形式。我们可以保留返回JSON输出的能力，以便当用户决定使用`–json`标志要求它时使用。
- en: 'The simplest way of outputting data as a table with the `pterm` package is
    using the default table. Next to the models, there currently exists a `JSON()`
    method that will take the struct and then output it in JSON format. Similarly,
    we add a `Table()` method on the pointer to the struct. In the `models/audio.go`
    file, we add the following bit of code for the header table:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pterm`包以表格形式输出数据的最简单方法是使用默认表格。在模型旁边，目前存在一个`JSON()`方法，它将接受结构并将其以JSON格式输出。同样，我们在结构指针上添加了一个`Table()`方法。在`models/audio.go`文件中，我们添加以下代码用于表头：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This defines the header for the audio table. We then add some code to transform
    an `audio` struct into a row:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了音频表的表头。然后我们添加一些代码将`audio`结构体转换为行：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we use the `pterm` package to create the table from the header row and
    function to convert an audio item into a row, each of type `[]string`. The `Table()`
    method for `Audio` and `AudioList` structs are defined below:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`pterm`包从表头行和将音频项转换为行的函数创建表格。`Audio`和`AudioList`结构体的`Table()`方法定义如下：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All the data in this example is output one record per line. If you decide on
    a different implementation and this is not the case for your code, make sure you
    add the `–plain` flag as an optional flag where once it is called, it will print
    one record per line. Doing this will ensure that scripts do not break on the output
    of the command. Regardless, depending on the size of the data and terminal, you
    may notice that the data wraps around and might be hard to read. If you are running
    Unix, run the `tput rmam` command to remove line wrapping from `terminal.app`
    and then `tput smam` to add line wrapping back in. On Windows, there will be a
    setting under your console properties. Either way, this should make viewing the
    table data a bit easier!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的所有数据都是按每行一个记录输出的。如果您决定使用不同的实现方式，并且您的代码不是这种情况，请确保添加`–plain`标志作为可选标志，一旦调用，它将按行打印一个记录。这样做将确保脚本不会在命令输出时中断。无论如何，根据数据的大小和终端的大小，您可能会注意到数据会自动换行，这可能难以阅读。如果您正在运行Unix，请运行`tput
    rmam`命令从`terminal.app`中删除行换行，然后运行`tput smam`将行换行添加回来。在Windows上，您可以在控制台属性下找到设置。无论如何，这应该会使查看表格数据变得更容易！
- en: 'If a lot of data is returned within the table, then it’s important to add paging
    for increased usability. As mentioned in the last section, we’ve added a `Pager`
    function to the `utils` package. Let’s modify the code so that it checks whether
    the data is being output to a terminal, and if so, page the data using the `Pager`
    function. In the `utils/print.go` file, within the `Print` function, we paginate
    the JSON formatted data, for example, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表格中返回了大量的数据，那么添加分页对于提高可用性很重要。如上一节所述，我们在 `utils` 包中添加了一个 `Pager` 函数。让我们修改代码，使其检查数据是否被输出到终端，如果是，则使用
    `Pager` 函数分页数据。在 `utils/print.go` 文件中的 `Print` 函数内，对 JSON 格式的数据进行分页，例如如下所示：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the output is returned to a terminal, then we paginate, otherwise we return
    the bytes with an error that informs the calling function it is not a terminal.
    For example, the `cmd/list.go` file calls the preceding `Print` function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出返回到终端，那么我们进行分页，否则我们返回带有错误的字节数，通知调用函数它不是一个终端。例如，`cmd/list.go` 文件调用了前面的 `Print`
    函数：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When it receives the error, then it just prints the string value to standard
    output.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当它收到错误时，它就只将字符串值打印到标准输出。
- en: Clarifying with emojis
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表情符号进行澄清
- en: A picture is worth a thousand words. So much information can be shared just
    by adding an emoji. For example, think of the simple green checkbox, ![](img/02.png),
    that is so often used on Slack or in GitHub to signal approval. Then, there is
    the opposite case with a red x, ![](img/03.png), to symbolize that something went
    wrong.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一图胜千言。只需添加一个表情符号，就能分享如此多的信息。例如，想想那个简单的绿色勾选框，![](img/02.png)，它在 Slack 或 GitHub
    上经常被用来表示批准。然后，还有相反的情况，一个红色的叉号，![](img/03.png)，用来表示出了问题。
- en: Emojis are letters that exist within the UTF-8 (Unicode) character set, which
    covers almost all the characters and symbols of the world. There are websites
    that will share this Unicode emoji mapping. Visit `https://unicode.org/emoji/charts/full-emoji-list.html`
    to view the full character list.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表情符号是存在于 UTF-8（Unicode）字符集中的字母，它涵盖了世界上几乎所有的字符和符号。有一些网站会分享这个 Unicode 表情符号映射。访问
    `https://unicode.org/emoji/charts/full-emoji-list.html` 来查看完整的字符列表。
- en: Example 1 – Green checkmark for successful operations
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1 – 成功操作的绿色勾选标记
- en: 'In our audiofile, we add the emoji to the output to the `upload` command. At
    the top of the file, we add the emoji constant with a UTF-8 character code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的音频文件中，我们将表情符号添加到 `upload` 命令的输出中。在文件顶部，我们添加了表情符号常量及其 UTF-8 字符代码：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we use it in the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在以下输出中使用它：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running the upload command after a new recompile and run shows the emoji next
    to the output, indicating a successful upload. The green checkmark assures the
    user that everything ran as expected and that there were no errors:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新编译和运行之后运行上传命令，可以看到表情符号紧邻输出，表示上传成功。绿色的勾选标记确保用户一切按预期运行，没有错误：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Example 2 – Magnifying glass for search operations
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2 – 搜索操作中的放大镜
- en: 'We’ve also added a magnifying glass, ![](img/013.png), in a similar way when
    the user runs the search command without the `--value` flag. The new prompt looks
    like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在没有 `--value` 标志的情况下运行搜索命令时，我们也以类似的方式添加了一个放大镜，![](img/013.png)。新的提示符看起来像这样：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 3 – Red for error messages
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3 – 错误信息的红色
- en: 'If there is an invalid operation or an error message, you could also add a
    red x to symbolize when something goes wrong:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有无效操作或错误信息，你还可以添加一个红色的叉号来表示出了问题：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Emojis not only add a fun element to your CLI but also a very valuable one.
    The little emoji is another way to increase information density and get important
    points across to the user.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表情符号不仅为你的 CLI 增加了趣味性，而且非常有价值。这个小表情符号是另一种增加信息密度并将重要观点传达给用户的方式。
- en: Using color with intention
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有意使用颜色
- en: Adding color highlights important information for the end user. Don’t overdo
    it, though; if you end up with multiple different colors frequently used throughout,
    it’s hard for anything to jump out as important. So use it sparingly, but also
    intentionally.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 添加颜色可以突出显示对最终用户重要信息。不过，不要过度使用；如果你经常使用多种不同的颜色，那么任何东西都很难显得重要。所以，要适量使用，但也要有目的性。
- en: An obvious color choice for errors is red, and success is green. Some packages
    make adding color to your CLI easy. One such package we will use in our examples
    is `https://github.com/fatih/color`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误来说，一个明显的颜色选择是红色，而对于成功则是绿色。一些软件包使向 CLI 添加颜色变得容易。在我们的示例中，我们将使用的一个这样的软件包是 `https://github.com/fatih/color`。
- en: 'Within the audiofile, we look at a few examples where we could integrate colors.
    For example, the ID for the table that we just listed out. We import the library
    and then use it to change the color of the `ID` field:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在audiofile中，我们查看了一些可以集成颜色的示例。例如，我们刚刚列出的表格的ID。我们导入库，然后使用它来改变`ID`字段的颜色：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `utils/ask.go` file, we define an `error` function that can be used
    within the three ask prompts:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils/ask.go`文件中，我们定义了一个`error`函数，该函数可以在三个询问提示中使用。
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `fmt.Errorf` function receives the `errorColor` function, which is defined
    within a new `utils/errors.go` file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Errorf`函数接收`errorColor`函数，该函数定义在新的`utils/errors.go`文件中：'
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Together, we recompile code and try to run it again, purposely omitting required
    flags from commands. We see that the command errors out and prints the error with
    a red background and white foreground, defined by the `color.BgRed` and `color.FgWhite`
    values. There are many ways to add color. In the `color` package we’re using,
    the prefix `Fg` stands for foreground and the prefix `Bg` stands for background.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，我们重新编译代码并尝试再次运行它，故意省略命令中所需的标志。我们看到命令出错，并以红色背景和白色前景打印错误，这些由`color.BgRed`和`color.FgWhite`值定义。有许多添加颜色的方法。在我们使用的`color`包中，前缀`Fg`代表前景，前缀`Bg`代表背景。
- en: Use colors intentionally, and you will visually transfer the most important
    information easily to the end user.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有意使用颜色，您将能够轻松地将最重要的信息视觉上传递给最终用户。
- en: Spinners and progress bars
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转器和进度条
- en: Spinners and progress bars signify that the command is still processing; the
    only difference is that progress bars visually display progress. Since it is common
    to build concurrency into applications, you can also show multiple progress bars
    running simultaneously. Think about how the Docker CLI often shows multiple files
    being downloaded simultaneously. This helps the user understand that there’s something
    happening, progress is made, and nothing is stalling.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转器和进度条表示命令仍在处理中；唯一的区别是进度条可以直观地显示进度。由于在应用程序中构建并发是常见的，您也可以同时显示多个进度条。想想Docker
    CLI经常同时显示多个文件下载的情况。这有助于用户理解正在发生某些事情，进度正在取得，没有停滞不前。
- en: Example 1 – Spinner while playing music
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例1 – 播放音乐时的旋转器
- en: 'There are different ways that you can add spinners to your Golang project.
    In the audiofile project, we’ll show a quick way to add a spinner using the `github.com/pterm/pterm`
    package. In the audiofile project, for each play command distinct for each operating
    system, we add some code to start and stop the spinner. Let’s look at `play_darwin.go`,
    for example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将旋转器添加到Golang项目的不同方式。在audiofile项目中，我们将展示使用`github.com/pterm/pterm`包快速添加旋转器的方法。在audiofile项目中，对于每个操作系统的特定播放命令，我们添加一些代码来启动和停止旋转器。以`play_darwin.go`为例：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running the `play` command for any audio file shows the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何音频文件运行`play`命令将显示以下输出：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It’s hard to capture the spinner in the previous line, but the black box spins
    around in a circle while the music plays.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中很难捕捉到旋转器，但黑色盒子在音乐播放时在圆形中旋转。
- en: Example 2 – Progress bar when uploading a file
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例2 – 上传文件时的进度条
- en: 'Next, within the `upload` command, we can show code to display the progress
    of uploading a file. Since the API only uses local flat file storage, the upload
    goes so quickly it’s hard to see the change in the progress bar, but you can add
    some `time.Sleep` calls in between each increment to see the progress appear more
    gradually. Within the `cmd/upload.go` file, we’ve added several statements to
    create the progress bar and then increment the progress along with title updates:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`upload`命令中，我们可以展示代码来显示上传文件的进度。由于API仅使用本地平面文件存储，上传速度非常快，以至于很难看到进度条的变化，但您可以在每次增加之间添加一些`time.Sleep`调用，以便更逐渐地显示进度。在`cmd/upload.go`文件中，我们添加了几个语句来创建进度条，并随着标题更新来增加进度：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This first line initiates the progress bar, and then to update the progress
    bar, the following lines are used:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一行初始化进度条，然后要更新进度条，以下行被使用：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that when we first define the progress bar, we call the `WithTotal`
    method, which takes the total number of steps. This means that for each step where
    `p.Increment()` is called, the progress bar progresses by 25 percent or 100 divided
    by the total number of steps. When running a spinner, it’s great to add the visualizer
    to let the user know that the application is currently running a command that
    might take a while:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们首次定义进度条时，我们调用了 `WithTotal` 方法，它接受总步数。这意味着对于每次调用 `p.Increment()` 的步骤，进度条会前进
    25% 或总步数的 100 分之 1。当运行旋转器时，添加可视化器以让用户知道应用程序目前正在运行可能需要一些时间的命令是很好的：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The progress bar gives the user a quick visual of how quickly the command is
    progressing. It’s a great visual indicator for any command that will take a long
    time and can be clearly split into multiple steps for progression. Again, spinners
    and progress bars should not be displayed unless the output is being displayed
    to the terminal or TTY. Make sure you add a check for TTY before outputting the
    progress bar or spinner.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条为用户提供了一个快速的可视化，显示了命令的执行进度。对于任何需要很长时间执行且可以明显分为多个步骤的命令来说，这是一个很好的视觉指示器。再次强调，除非输出被显示在终端或
    TTY 上，否则不应显示旋转器或进度条。确保在输出进度条或旋转器之前添加对 TTY 的检查。
- en: Disabling colors
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用颜色
- en: 'There are different reasons why color may be disabled for a CLI. A few of these
    things include:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种原因可能导致 CLI 中禁用颜色。其中一些原因包括：
- en: The standard out or standard error pipe is not connected to a TTY or interactive
    terminal. There is one exception to this. If the CLI is running within a CI environment,
    such as Jenkins, then color is usually supported, and it is recommended to keep
    color on.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输出或标准错误管道未连接到 TTY 或交互式终端。有一个例外。如果 CLI 在 CI 环境中运行，例如 Jenkins，那么通常支持颜色，建议保持颜色开启。
- en: The `NO_COLOR` or `MYAPP_NO_COLOR` environment variable is set to true. This
    can be defined and set to disable color for all programs that check it or specifically
    for your program.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_COLOR` 或 `MYAPP_NO_COLOR` 环境变量被设置为 true。这可以定义并设置为禁用检查它的所有程序的颜色，或者专门为您的程序禁用颜色。'
- en: The `TERM` environment variable is set to dumb.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERM` 环境变量被设置为 dumb。'
- en: The user passes in the `–``no-color` flag.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户传递了 `–no-color` 标志。
- en: Some percentage of your users may be colorblind. Allowing your users to swap
    out one color for another is a nice way to consider this specific part of your
    user base. This could be done within the configuration file or application. Allowing
    them to specify a color and then overwrite it with a preferred color will again
    allow the user to customize the CLI. This customization will provide users with
    an improved experience.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您的用户中可能有一部分是色盲。允许用户交换一种颜色为另一种颜色是考虑您用户基础中这一特定部分的一个好方法。这可以在配置文件或应用程序中完成。允许他们指定一种颜色，然后用首选颜色覆盖它，这再次允许用户自定义
    CLI。这种自定义将为用户提供更好的体验。
- en: Including ASCII art within your application increases information density—a
    visual indicator that easily helps users to understand some important information.
    It adds clarity and conciseness. Now let’s discuss a way to make your CLI more
    intuitive through consistency.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中包含 ASCII 艺术可以增加信息密度——这是一个易于帮助用户理解一些重要信息的视觉指示器。它增加了清晰度和简洁性。现在让我们讨论一种通过一致性使您的
    CLI 更直观的方法。
- en: Being consistent across CLIs
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CLI 之间保持一致性
- en: Learning about command-line syntax, flags, and environment variables requires
    an upfront cost that pays off in the long run with efficiency if programs are
    consistent across the board. For example, terminal conventions are ingrained into
    our fingertips. Reusing these conventions by following preexisting patterns helps
    to make a CLI more intuitive and guessable. This is what makes users efficient.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 了解命令行语法、标志和环境变量需要 upfront 成本，但如果程序在各方面保持一致，则长期来看会带来效率上的回报。例如，终端约定已经深深地印在我们的指尖上。通过遵循现有的模式来重用这些约定，有助于使
    CLI 更直观和可预测。这正是使用户高效的原因。
- en: There are times when preexisting patterns break usability. As mentioned earlier,
    a lot of Unix commands don’t return any output by default, which can cause confusion
    for people who are new to using the terminal or CLI. In this case, it’s fine to
    break the pattern for the benefit of increased usability.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，现有的模式会破坏可用性。如前所述，许多 Unix 命令默认不返回任何输出，这可能会让新接触终端或 CLI 的人感到困惑。在这种情况下，为了提高可用性，打破这种模式是可以接受的。
- en: 'There are specific topics to consider when maintaining consistency with the
    larger community of CLIs, but also within the application itself:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护与更大社区中的CLIs的一致性时，需要考虑一些特定主题，但也要在应用程序内部保持一致：
- en: Naming
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名
- en: Positional versus flag arguments
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数与标志参数
- en: Flag naming
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志命名
- en: Usage
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法
- en: Naming
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名
- en: 'Use consistent command, subcommand, and flag names to help users intuit your
    command-line application. Some modern command-line applications, such as the AWS
    command-line application, will use Unix commands to stay consistent. For example,
    look at this AWS command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一致的命令、子命令和标志名称，以帮助用户直观地了解你的命令行应用程序。一些现代命令行应用程序，如AWS命令行应用程序，将使用Unix命令以保持一致性。例如，看看这个AWS命令：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The previous command uses the `ls` command to list `S3` objects in the `S3`
    bucket. It’s important to use common, and non-ambiguous, command names outside
    of reusing shell commands in your CLI. Take the following as examples that can
    be logically grouped by type:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令使用`ls`命令列出`S3`存储桶中的`S3`对象。在CLI中重用shell命令之外，使用常见且非模糊的命令名称很重要。以下是一些可以按类型逻辑分组的例子：
- en: '![](img/Table_8.1_B18883.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 表8.1_B18883](img/Table_8.1_B18883.jpg)'
- en: Table 8.1 – Example grouping commands by type
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – 按类型分组命令示例
- en: 'These are common names across CLIs. You can also consider integrating some
    common Unix commands:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是CLIs中的常见名称。你也可以考虑集成一些常见的Unix命令：
- en: '`cp` (copy)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`（复制）'
- en: '`ls` (list)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls`（列出）'
- en: '`mv` (move)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv`（移动）'
- en: 'These common command names remove confusion from a long list of ambiguous or
    unique names. One common confusion is the difference between the update and upgrade
    commands. It’s best to use one or the other as keeping both will only confuse
    your users. Also, for the command names that are used often, follow the standard
    shorthand for these popular commands as well. For example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常见的命令名称从一系列模糊或独特的名称中消除了混淆。一个常见的混淆是更新和升级命令之间的区别。最好使用其中一个，因为保留两个只会让用户感到困惑。此外，对于经常使用的命令名称，也要遵循这些流行命令的标准缩写。例如：
- en: '`-``v`, `--version`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`, `--version`'
- en: '`-``h`, `--help`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`, `--help`'
- en: '`-``a`, `--all`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`, `--all`'
- en: '`-``p`, `--port`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`, `--port`'
- en: Rather than listing all examples, just consider some of the most common command-line
    applications you use. Think about which command names make sense for consistency
    across the board. This will benefit not only your application but the community
    of command-line applications as a whole as further standards are solidified.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是列出所有示例，只需考虑一些你常用的最常见命令行应用程序。想想哪些命令名称在整体上具有一致性。这将不仅有利于你的应用程序，而且有利于整个命令行应用程序社区，因为随着进一步标准的巩固。
- en: Positional versus flag arguments
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置参数与标志参数
- en: 'It’s important to stay consistent with arguments and their position. For example,
    in the AWS CLI, the `s3` argument is consistently next to its arguments:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 保持参数及其位置的一致性很重要。例如，在AWS CLI中，`s3`参数始终紧随其后：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The consistent position of specific arguments will build a clear pattern that
    users will follow intuitively.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 特定参数的一致位置将建立一个用户会直观遵循的清晰模式。
- en: 'If flags, that we had mentioned before, are available with one command, they
    can be available for another command where they make sense. Rather than changing
    the flag name for each command, stay consistent between commands. Do the same
    with subcommands. Let’s look at some examples from the GitHub CLI:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标志（我们之前提到的），在一个命令中可用，它们也可以在另一个命令中使用，前提是它们是有意义的。而不是为每个命令更改标志名称，保持命令之间的连贯性。对子命令也做同样的事情。让我们看看GitHub
    CLI的一些例子：
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The GitHub CLI keeps the list subcommand consistent across different commands
    and reuses the `–json` flag, which has the same behavior across the application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub CLI在不同命令中保持列表子命令的一致性，并重用具有相同行为的`–json`标志。
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Required arguments are usually better as positional rather than flags.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 必要参数通常作为位置参数而不是标志参数更好。
- en: Flag naming
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志命名
- en: Not only is it important to stay consistent on the position of arguments and
    the flag names across different commands, but it’s also important to be consistent
    within the naming. For example, there are flags that can be defined in camel case,
    `–camelCase`, snake case, `--SnakeCase`, or with dashes, `--flag-with-dashes`.
    Staying consistent with the way you are naming your flags in your application
    is also important!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅在不同命令中保持参数位置和标志名称的一致性很重要，而且在命名上也要保持一致。例如，有一些标志可以用驼峰式命名，`–camelCase`，蛇形命名，`--SnakeCase`，或者用连字符，`--flag-with-dashes`。在应用程序中保持标志命名的连贯性也很重要！
- en: Usage
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'In previous chapters, we discussed the grammar of a command and how applications
    can be defined with a consistent structure: **noun-verb** or **verb-noun**. Staying
    consistent with the structure also lends to a more intuitive design.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了命令的语法以及如何通过一致的架构定义应用程序：**名词-动词**或**动词-名词**。保持结构的一致性也有助于设计出更加直观。
- en: When building your command-line application, if you think about how to stay
    consistent across other programs and internal to your application, you will create
    a more intuitive and easier to learn command-line application where your users
    feel naturally supported.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建你的命令行应用程序时，如果你考虑如何在不同程序和应用程序内部保持一致性，你将创建一个更加直观且易于学习的命令行应用程序，让你的用户感到自然地得到支持。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned some specific points to consider when building
    for a machine versus a human. Machines like simple text and have certain expectations
    of the data that is returned from other applications. Machine output can sometimes
    break usability. Designing for humans first, we talked about how we can easily
    switch to machine-friendly output when needed with the use of some popular flags:
    `--json`, `--plain`, and `--silence`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了一些在为机器或人类构建时需要考虑的具体要点。机器喜欢简单的文本，并对从其他应用程序返回的数据有一定的期望。机器的输出有时会破坏可用性。首先为人类设计，我们讨论了如何使用一些流行的标志（如`--json`，`--plain`和`--silence`）在需要时轻松切换到机器友好的输出。
- en: 'Much goes into a usable design, and we went over some of the ways you can increase
    the usability of your CLI—from using color with intention, outputting data in
    tables, paging through long text, and being consistent. All of the aforementioned
    elements will help the user feel more comfortable and guided when using your CLI,
    which is one of the main goals we want to achieve. We can summarize with a quick
    table what a good CLI design looks like versus a bad CLI design:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可用的设计需要很多工作，我们讨论了一些你可以提高你的命令行界面（CLI）可用性的方法——从有目的地使用颜色，以表格形式输出数据，分页浏览长文本，以及保持一致性。上述所有元素都将帮助用户在使用你的CLI时感到更加舒适和有指导性，这是我们想要实现的主要目标之一。我们可以用一个简短的表格来总结一个好的CLI设计与一个不好的CLI设计之间的区别：
- en: '![Figure 8.5 – Good versus bad CLI design](img/Figure_8.5._B18883.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 好的与不好的CLI设计](img/Figure_8.5._B18883.jpg)'
- en: Figure 8.5 – Good versus bad CLI design
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 好的与不好的CLI设计
- en: In the next chapter, [*Chapter 9*](B18883_09.xhtml#_idTextAnchor190), *Empathic
    Side of Development*, we will continue discussing how to develop for humans by
    incorporating more empathy.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（*第9章*[*Chapter 9*](B18883_09.xhtml#_idTextAnchor190)），*开发的同理心方面*，我们将继续讨论如何通过增加同理心来为人类开发。
- en: Questions
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What common flags in scripts can be used with a command-line application to
    keep the output stable?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中，哪些常见的标志可以与命令行应用程序一起使用，以保持输出稳定？
- en: What flag should you check to see if the end user does not want color set within
    the terminal? And what common flag can be used to disable color from the output?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该检查哪个标志来查看最终用户是否不想在终端中设置颜色？以及可以使用哪个常见的标志来禁用输出中的颜色？
- en: Think about how there could be two commands with similar names and how this
    adds ambiguity. What ambiguous commands have you come across in your experience
    of CLIs?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到可能会有两个具有相似名称的命令，以及这如何增加歧义。你在CLI的使用经验中遇到过哪些歧义的命令？
- en: Further reading
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Anti-Mac* *Interface*: [https://www.nngroup.com/articles/anti-mac-interface/](https://www.nngroup.com/articles/anti-mac-interface/)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《反Mac界面》*[*The Anti-Mac* *Interface*:](https://www.nngroup.com/articles/anti-mac-interface/)[https://www.nngroup.com/articles/anti-mac-interface/](https://www.nngroup.com/articles/anti-mac-interface/)'
- en: '*The Humane Interface: New Directions for Designing Interactive Systems* by
    Jef Raskin'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《人性化的界面：设计交互式系统的新方向》* by Jef Raskin'
- en: Answers
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`--json` and `--plain` flags keep data consistent and reduce the risk of breaking
    scripts.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--json`和`--plain`标志保持数据一致性并降低破坏脚本的风险。'
- en: Either the `TERM=dumb`, `NO_COLOR`, or `MYAPP_NO_COLOR` environment variables.
    The most common flag for disabling color is the `–``no-color` flag.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么是`TERM=dumb`，`NO_COLOR`，要么是`MYAPP_NO_COLOR`环境变量。禁用颜色的最常见标志是`–no-color`标志。
- en: Update versus upgrade are commonly confused, as well as name and host.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新与升级常常被混淆，以及名称和主机。
