<html><head></head><body>
		<div id="_idContainer067">
			<h1 id="_idParaDest-184" class="chapter-number"><a id="_idTextAnchor190"/>9</h1>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor191"/>The Empathic Side of Development</h1>
			<p><a id="_idTextAnchor192"/>Empathy has been a hot topic lately, and its relation to software is no exception. This chapter will discuss how to use empathy to develop a better CLI. Empathy-driven CLI development is done with consideration of the output and errors that are written and the clarity and reassurance it may give the user. Written documentation that takes an empathetic approach also provides users with an effortless way to get started, while help and support are readily available for users when they <span class="No-Break">need it.</span></p>
			<p><a id="_idTextAnchor193"/>This chapter will give examples of how to rewrite errors in a way that users may easily understand, not just by being clearer that an error occurred but also how and where (with debug and traceback information), which can be provided with a <strong class="source-inline">--verbose</strong> flag and detailed logging. It is very important to provide logs for users, and this implementation will be described when discussing debug and traceback information. Users can also feel more reassured with the help of man pages, usage examples of each command, empathically written documentation, and a quick and easy way to submit bugs that are encountered within <span class="No-Break">the application.</span></p>
			<p>Taking an empathetic approach into many different areas of your application, as well as in your life, is a form of not only self-care but care for others as well. Hopefully, these tips will help to create a CLI that meets the user at their perspective and provides them with a feeling of reassurance. Specifically, this chapter will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Rewriting errors to <span class="No-Break">be human-readable</span></li>
				<li>Providing debug and <span class="No-Break">traceback information</span></li>
				<li>Effortless <span class="No-Break">bug submission</span></li>
				<li>Help, documentation, <span class="No-Break">and support</span></li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor194"/>Technical requirements</h1>
			<p>These are the requirements for <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>A Unix operating system to understand and run the examples shared in <span class="No-Break">the chapter</span></li>
				<li>You can also find the code examples on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter09</span></a></li>
			</ul>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor195"/>Rewriting errors to be human-readable</h1>
			<p>Errors can be a big <a id="_idIndexMarker591"/>point of frustration for users as they can set users off their original plans. Users will be grateful, though, if you can make the process as painless as possible. In this section, we will discuss some ways to ease users when an error occurs and provide some guidelines for creating better error messages and avoiding some common mistakes. Creating clear and helpful error messages is often overlooked, yet they are very impactful toward an <span class="No-Break">optimal UX.</span></p>
			<p>Think of some of your subjective experiences while working with CLIs and some of the errors you have encountered. This is an opportunity to think about how experiences can be improved for yourself when working with your own CLI, but also <span class="No-Break">for others.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor196"/>Guidelines for writing error messages</h2>
			<p>Here are<a id="_idIndexMarker592"/> some useful guidelines when writing <span class="No-Break">error messages:</span></p>
			<ul>
				<li><strong class="bold">Be specific</strong>: Customize messages toward the actual task that has occurred. This error message is critical if the task required inputting credentials or a final command to complete a workflow. The best experience would include specifying the exact problem and then providing a way toward correcting the issue. Specific guidance helps the users stay engaged and willing to <span class="No-Break">make corrections.</span></li>
				<li><strong class="bold">Remind the user that there’s a human on the other end</strong>: A generic error message can sound very technical and intimidating to most users. By rewriting the error message, you can make them more useful and less intimidating. Empathize with your users and make sure that you don’t place blame on the user, which can be particularly discouraging. It’s important to encourage the user by being understanding, friendly, and speaking the same language, both literally and figuratively! How do the words you use sound <span class="No-Break">in conversation?</span></li>
				<li><strong class="bold">Keep it light-hearted</strong>: Keeping a light-hearted tone can help ease any tension when an<a id="_idIndexMarker593"/> error occurs, but be careful! In certain situations, it might make the situation a bit worse—especially if it’s a critical task. Users do not want to feel mocked. Regardless, with humor or not, the error message should still be informational, clear, <span class="No-Break">and polite.</span></li>
				<li><strong class="bold">Make it easy</strong>: This will require you to do a bit more of the heavy lifting, but it will certainly be worth it in the end. Provide clear next steps, or commands to run, to resolve the issue and to help the user get back on track to what they had originally intended on doing. With helpful suggestions, the user will at least see the path through the trees and know what to <span class="No-Break">do next.</span></li>
				<li><strong class="bold">Consider the best placement</strong>: When outputting error messages, it’s best to place them in an area where users will look first. In the case of the CLI, it’s most likely at the end of <span class="No-Break">the output.</span></li>
				<li><strong class="bold">Consolidate errors</strong>: If there are multiple error messages, especially similar ones, group them together. It will look much better than repeating the same error message over <span class="No-Break">and again.</span></li>
				<li><strong class="bold">Optimize your error message with icons and text</strong>: Usually, important information is placed at the end of the output, but if there’s any red text on the screen, that is often where the user’s eyes will be drawn to. Given the power of color, use it sparingly and <span class="No-Break">with intention.</span></li>
				<li><strong class="bold">Consider capitalization and punctuation</strong>: Don’t write in all caps or with multiple exclamation points. Consider consistency as well—do your errors start with capitalization? If they are output to a log, errors may start all in <span class="No-Break">lowercase letters.</span></li>
			</ul>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor197"/>Decorating errors</h2>
			<p>Wrapping <a id="_idIndexMarker594"/>errors with additional information and context is a very important step. What is the specific task that failed and why? This helps the user understand what happened. Providing actions to take toward resolution will also help the user feel more supported and willing to <span class="No-Break">move forward.</span></p>
			<p>First, there are a few ways to decorate your errors with additional information. You can use the <span class="No-Break"><strong class="source-inline">fmt.Errorf</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func Errorf(format string, a ...interface{}) error</pre>
			<p>With this function, you can print out the error as a string with any additional context. Here’s an example within the <strong class="source-inline">errors/errors.go</strong> file in the <span class="No-Break"><strong class="source-inline">Chapter-9</strong></span><span class="No-Break"> repo:</span></p>
			<pre class="source-code">
birthYear := -1981
err := fmt.Errorf("%d is negative\nYear can't be negative", birthYear)
if birthYear &lt; 0 {
    fmt.Println(err)
} else {
    fmt.Printf("Birth year: %d\n", birthYear)
}</pre>
			<p>The next way to decorate your errors is by using the <strong class="source-inline">errors.Wrap</strong> method. This method is fully defined <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func Wrap(err error, message string) error</pre>
			<p>It returns an error annotating <strong class="source-inline">err</strong> with a message and a stack trace at the point the method is called. If <strong class="source-inline">err</strong> is <strong class="source-inline">nil</strong>, then the <strong class="source-inline">Wrap</strong> function also <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">nil</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">wrapping()</strong> function, we <span class="No-Break">demonstrate this:</span></p>
			<pre class="source-code">
func wrapping() error {
    err := errors.New("error")
    err1 := operation1()
    if err1 != nil {
        err1 = errors.Wrap(err, "operation1")
    }
    err2 := operation2()
    if err != nil {
        err2 = errors.Wrap(err1, "operation2")
    }
    err3 := operation3()
    if err != nil {
        err3 = errors.Wrap(err2, "operation3")
    }
    return err3
}</pre>
			<p>Notice<a id="_idIndexMarker595"/> that the previous error gets wrapped into the next error and so on until the final error is returned. The output of the error returned from the <strong class="source-inline">wrapping()</strong> function is shown here. I’ve removed the longer path <span class="No-Break">for clarity:</span></p>
			<pre class="console">
error
.../errors.wrapping
        .../errors/errors.go:73
.../errors.Examples
        .../errors/errors.go:39
main.main
        .../main.go:6
runtime.main
        /usr/local/go/src/runtime/proc.go:250
runtime.goexit
        /usr/local/go/src/runtime/asm_amd64.s:1594
operation1
.../errors.wrapping
        .../errors/errors.go:76
.../errors.Examples
        .../errors/errors.go:39
main.main
        .../main.go:6
runtime.main
        /usr/local/go/src/runtime/proc.go:250
runtime.goexit
        /usr/local/go/src/runtime/asm_amd64.s:1594
operation2
.../errors.wrapping
        .../errors/errors.go:80
.../errors.Examples
        .../errors/errors.go:39
main.main
        .../main.go:6
runtime.main
        /usr/local/go/src/runtime/proc.go:250
runtime.goexit
        /usr/local/go/src/runtime/asm_amd64.s:1594
operation3
.../errors.wrapping
        .../errors/errors.go:84
.../errors.Examples
        .../errors/errors.go:39
main.main
        .../main.go:6
runtime.main
        /usr/local/go/src/runtime/proc.go:250
runtime.goexit
        /usr/local/go/src/runtime/asm_amd64.s:1594</pre>
			<p>Notice that the<a id="_idIndexMarker596"/> errors from <strong class="source-inline">operation1</strong>, <strong class="source-inline">operation2</strong>, and <strong class="source-inline">operation3</strong> are wrapped under the original <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> instance.</span></p>
			<p>Because wrapping annotates the error with the stack trace and message, the line that calls the <strong class="source-inline">wrapping()</strong> function prints the error message followed by the stack trace at the call of the <strong class="source-inline">New()</strong> or <span class="No-Break"><strong class="source-inline">Wrap()</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor198"/>Customizing errors</h2>
			<p>Creating <a id="_idIndexMarker597"/>custom errors allows you to store whatever information you think is valuable to your users with the error so that when it’s time to print out, all the information is available within a single struct. First, you need to think about the <span class="No-Break">error structure:</span></p>
			<pre class="source-code">
type error interface {
    Error() string
}</pre>
			<p>Simply create any type that implements the <strong class="source-inline">Error() string</strong> method. Think about the data you’d want stored on the custom error structure that might be useful for your users, or even for yourself as the developer, for debugging purposes. This could include the method name where the error occurred, the severity of the error, or the kind of error. In the <strong class="source-inline">Chapter-9</strong> repo, in the <strong class="source-inline">errors.go</strong> file, I provide some examples. To keep things simple, only one additional field, <strong class="source-inline">Task</strong>, is added to the <span class="No-Break"><strong class="source-inline">customError</strong></span><span class="No-Break"> structure:</span></p>
			<pre class="source-code">
type customError struct {
    Task string
    Err error
}</pre>
			<p>The <strong class="source-inline">Error()</strong> method <a id="_idIndexMarker598"/>that satisfies the previous interface is defined here. For fun, we use the <strong class="source-inline">github.com/fatih/color</strong> color page used in the previous chapter and an emoji (a red cross mark) alongside the <span class="No-Break">error message:</span></p>
			<pre class="source-code">
func (e *customError) Error() string {
    var errorColor = color.New(color.BgRed,
        color.FgWhite).SprintFunc()
    return fmt.Sprintf("%s: %s %s", errorColor(e.Task),
        crossMark, e.Err)
}</pre>
			<p>Now, we can demonstrate how this custom error can be used within the <span class="No-Break"><strong class="source-inline">eligibleToVote</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func eligibleToVote(age int) error {
    fmt.Printf("%s Attempting to vote at %d years
        old...\n", votingBallot, age)
    minimumAge := 18
    err := &amp;customError{
        Task: " eligibleToVote",
    }
    if age &lt; minimumAge &amp;&amp; age &gt; 0 {
        years := minimumAge - age
        err.Err = fmt.Errorf("too young to vote, at %d,
            wait %d more years", age, years)
        return err
    }
    if age &lt; 0 {
        err.Err = fmt.Errorf("age cannot be negative: %d",
            age)
        return err
    }
    fmt.Println("Voted.", checkMark)
    return nil
}</pre>
			<p>Notice there<a id="_idIndexMarker599"/> are multiple errors, and the error is initially defined at the top of the function, setting only the <strong class="source-inline">Task</strong> field. For each error that occurs, the <strong class="source-inline">Err</strong> field is then set and returned. Within the <strong class="source-inline">Examples</strong> method, we call the function with the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
birthYear = 2010
currentYear := 2022
age := currentYear - birthYear
err = eligibleToVote(age)
if err != nil {
    fmt.Println("error occurred: ", err)
}</pre>
			<p>The following error is output when the preceding <span class="No-Break">code runs:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_9.1._B18883.jpg" alt="Figure 9.1 – Screenshot of voting error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Screenshot of voting error</p>
			<p>There are <a id="_idIndexMarker600"/>plenty of other ways to create custom errors, but here are a few things to consider adding to your <span class="No-Break">custom errors:</span></p>
			<ul>
				<li>The severity of the error for <span class="No-Break">logging purposes</span></li>
				<li>Any data that may be valuable <span class="No-Break">for metrics</span></li>
				<li>The kind of error so that you may easily filter out any unexpected errors when <span class="No-Break">they occur</span></li>
			</ul>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor199"/>Writing better error messages</h2>
			<p>Now that we <a id="_idIndexMarker601"/>know how to add more detail to error messages, let’s revisit the <strong class="source-inline">audiofile</strong> CLI and rewrite our error messages to be more human-friendly using the guidelines mentioned earlier in this section. In the repo, for this particular branch, I’ve decorated the errors with extra information so that the user or developer can better understand where the error occurred <span class="No-Break">and why.</span></p>
			<p>Since the <strong class="source-inline">audiofile</strong> CLI interacts with the <strong class="source-inline">audiofile</strong> API, there are HTTP responses that can be handled and rewritten. A <strong class="source-inline">CheckResponse</strong> function exists in the <strong class="source-inline">utils/http.go</strong> file and <span class="No-Break">does this:</span></p>
			<pre class="source-code">
func CheckResponse(resp *http.Response) error {
    if resp != nil {
        if resp.StatusCode != http.StatusOK {
            switch resp.StatusCode {
            case http.StatusInternalServerError:
                return fmt.Errorf(errorColor("retry the command 
                  later"))
            case http.StatusNotFound:
                return fmt.Errorf(errorColor("the id cannot be 
                  found"))
            default:
                return fmt.Errorf(errorColor(fmt.
                  Sprintf("unexpected response: %v", resp.
                  Status)))
            }
        }
        return nil
    } else {
        return fmt.Errorf(errorColor("response body is nil"))
    }
}</pre>
			<p>Consider expanding<a id="_idIndexMarker602"/> on this within your own CLI, which might also interact with a REST API. You may check as many responses as you like and rewrite them as errors to be returned by <span class="No-Break">the command.</span></p>
			<p>In previous versions of the <strong class="source-inline">audiofile</strong> CLI, if an <strong class="source-inline">id</strong> parameter was passed into the <strong class="source-inline">get</strong> or <strong class="source-inline">delete</strong> command, nothing would be returned if the ID was not found. However by passing back the <strong class="source-inline">http.StatusNotFound</strong> response and adding additional error decorations, the command that would previously error silently and return no data can now return some <span class="No-Break">useful information:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro audiofile % ./bin/audiofile get --id 1234
Sending request: GET http://localhost:8000/request?id=1234 ...
Error:
  checking response: the id cannot be found
Usage:
  audiofile get [flags]
Flags:
  -h, --help        help for get
      --id string   audiofile id
      --json        return json format</pre>
			<p>We can even level up by additionally suggesting how to find an ID. Potentially, ask the user to run the <strong class="source-inline">list</strong> command to confirm the ID. Another thing that can be done, similarly to how we<a id="_idIndexMarker603"/> handled the status codes from an HTTP API request, is to check the errors coming back from a local command being called. Whether the command is not found or the command is missing executable permissions, you can similarly use a switch to handle potential errors that can occur when a command is started or run. These potential errors can be rewritten similarly using more <span class="No-Break">user-friendly language.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor200"/>Providing debug and traceback information</h1>
			<p>Debug and traceback information<a id="_idIndexMarker604"/> is mostly useful for you or other developers, but it can also help your end users share valuable information with you to help debug a potential issue found in your code. There are several diverse ways to provide this information. Debug and traceback information is primarily output to a log file, and often, the addition of a <strong class="source-inline">verbose</strong> flag will print this output, which is <span class="No-Break">usually hidden.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor201"/>Logging data</h2>
			<p>Since debug data is <a id="_idIndexMarker605"/>usually found in log files, let us discuss how to include logging in your command-line application and determine the levels associated with logging—<strong class="source-inline">info</strong>, <strong class="source-inline">error</strong>, and <strong class="source-inline">debug</strong> levels of severity. In this example, let us use a simple log package to demonstrate this example. There are several different popular structured log packages, including <span class="No-Break">the following:</span></p>
			<ul>
				<li>Zap (<a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a>)—Fast structured logger developed <span class="No-Break">by Uber</span></li>
				<li>ZeroLog (<a href="https://github.com/rs/zerolog">https://github.com/rs/zerolog</a>)—Fast and simple logger dedicated to <span class="No-Break">JSON format</span></li>
				<li>Logrus (<a href="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a>)—Structured logger for Go with the option for JSON-formatted output (currently in <span class="No-Break">maintenance mode)</span></li>
			</ul>
			<p>Although <strong class="source-inline">logrus</strong> is an<a id="_idIndexMarker606"/> extremely popular logger, it has not been updated in a while, so let us choose to use <strong class="source-inline">zap</strong> instead. In general, it’s a promising idea to choose an open source project that is <span class="No-Break">actively maintained.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor202"/>Initiating a logger</h2>
			<p>Back to<a id="_idIndexMarker607"/> the <strong class="source-inline">audiofile</strong> project, let us add logging for debugging purposes. The very first thing we run under our <strong class="source-inline">audiofile</strong> repo <span class="No-Break">is this:</span></p>
			<pre class="console">
go get -u go.uber.org/zap</pre>
			<p>It will get the updated Zap logger dependencies. After that, we can start referencing the import within the project’s Go files. Under the <strong class="source-inline">utils</strong> directory, we add a <strong class="source-inline">utils/logger.go</strong> file to define some code to initiate the Zap logger, which is called within the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
package utils
import (
    "go.uber.org/zap"
)
var Logger *zap.Logger
var Verbose *zap.Logger
func InitCLILogger() {
    var err error
    var cfg zap.Config
    config := viper.GetStringMap("cli.logging")
    configBytes, _ := json.Marshal(config)
    if err := json.Unmarshal(configBytes, &amp;cfg); err != nil {
        panic(err)
    }
    cfg.EncoderConfig = encoderConfig()
    err = createFilesIfNotExists(cfg.OutputPaths)
    if err != nil {
        panic(err)
    }
    cfg.Encoding = "json"
    cfg.Level = zap.NewAtomicLevel()
    Logger, err = cfg.Build()
    if err != nil {
        panic(err)
    }
    cfg.OutputPaths = append(cfg.OutputPaths, "stdout")
    Verbose, err = cfg.Build()
    if err != nil {
        panic(err)
    }
    defer Logger.Sync()
}</pre>
			<p>It isn’t necessary, but <a id="_idIndexMarker608"/>we define two loggers here. One is a logger, <strong class="source-inline">Logger</strong>, which outputs to an output path defined within the config file, and the other is the verbose logger, <strong class="source-inline">Verbose</strong>, which outputs to standard output and the previously defined output path. Both use the <strong class="source-inline">*zap.Logger</strong> type, which is used when type safety and performance are critical. Zap also provides a sugared logger, which is used when performance is nice to have but not critical. <strong class="source-inline">SugarLogger</strong> also allows for structured logging, but in addition, supports <span class="No-Break"><strong class="source-inline">printf</strong></span><span class="No-Break">-style APIs.</span></p>
			<p>Within the <strong class="source-inline">Chapter-9</strong> branch version of this repo, we replace some of the general <strong class="source-inline">fmt.Println</strong> or <strong class="source-inline">fmt.Printf</strong> output with the logs that can be shown in <strong class="source-inline">verbose</strong> mode. Also, we differentiate when printing out information with the <strong class="source-inline">Info</strong> level versus the <span class="No-Break"><strong class="source-inline">Error</strong></span><span class="No-Break"> level.</span></p>
			<p>The following code uses Viper to read from the configuration file, which has been modified to hold a few extra configurations for <span class="No-Break">the logger:</span></p>
			<pre class="source-code">
{
    "cli": {
        "hostname": "localhost",
        "port": 8000,
        "logging": {
            "level": "debug",
            "encoding": "json",
            "outputPaths": [
                "/tmp/log/audiofile.json"
            ]
        }
    }
}</pre>
			<p>In the preceding configuration, we set the <strong class="source-inline">level</strong> and <strong class="source-inline">encoding</strong> fields. We choose the <strong class="source-inline">debug</strong> level so that debug and error statements are output to the log file. For the <strong class="source-inline">encoding</strong> value, we chose <strong class="source-inline">json</strong> because it provides a standard structure that can make it easier to <a id="_idIndexMarker609"/>understand the error message as each field is labeled. The encoder config is also defined within the same <span class="No-Break"><strong class="source-inline">utils/logger.go</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
func encoderConfig() zapcore.EncoderConfig {
    return zapcore.EncoderConfig{
        MessageKey: "message",
        LevelKey: "level",
        TimeKey: "time",
        NameKey: "name",
        CallerKey: "file",
        StacktraceKey: "stacktrace",
        EncodeName: zapcore.FullNameEncoder,
        EncodeTime: timeEncoder,
        EncodeLevel: zapcore.LowercaseLevelEncoder,
        EncodeDuration: zapcore.SecondsDurationEncoder,
        EncodeCaller: zapcore.ShortCallerEncoder,
    }
}</pre>
			<p>Since the <strong class="source-inline">InitCLILogger()</strong> function is called within the <strong class="source-inline">main</strong> function, the two <strong class="source-inline">Logger</strong> and <strong class="source-inline">Verbose</strong> loggers will be available within any of the commands <span class="No-Break">for use.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor203"/>Implementing a logger</h2>
			<p>Let us<a id="_idIndexMarker610"/> look at how we can start using this logger in an effective way. First, we know that we are going to log all the data and output to the user when in verbose mode. We define the <strong class="source-inline">verbose</strong> flag as a persistent flag in the <strong class="source-inline">cmd/root.go</strong> file. This means that the <strong class="source-inline">verbose</strong> flag will be available not only at the root level but also for every subcommand added to it. In that file’s <strong class="source-inline">init()</strong> function, we add <span class="No-Break">this line:</span></p>
			<pre class="source-code">
rootCmd.PersistentFlags().BoolP("verbose", "v", false, "verbose")</pre>
			<p>Now, rather<a id="_idIndexMarker611"/> than checking for every error if the <strong class="source-inline">verbose</strong> flag is called and printing out the error before it is returned, we create a simple function that can be repeated for checking but also returning the error value. Within the <strong class="source-inline">utils/errors.go</strong> file, we define the following function <span class="No-Break">for reuse:</span></p>
			<pre class="source-code">
func Error(errString string, err error, verbose bool) error {
    errString = cleanup(errString, err)
    if err != nil {
        if verbose {
            // prints to stdout also
            Verbose.Error(errString)
        } else {
            Logger.Error(errString)
        }
        return fmt.Errorf(errString)
    }
    return nil
}</pre>
			<p>Let’s take one command as an example, the <strong class="source-inline">delete</strong> command, which shows how this function <span class="No-Break">is called:</span></p>
			<pre class="source-code">
var deleteCmd = &amp;cobra.Command{
    Use: "delete",
    Short: "Delete audiofile by id",
    Long: `Delete audiofile by id. This command removes the
        entire folder containing a<a id="_idTextAnchor204"/>ll stored metadata`,</pre>
			<p>The bulk of<a id="_idIndexMarker612"/> the code for the command is usually found within the <strong class="source-inline">Run</strong> or <strong class="source-inline">RunE</strong> method, which receives the <strong class="source-inline">cmd</strong> variable, a  <strong class="source-inline">*cobra.Command</strong> instance, and the <strong class="source-inline">args</strong> variable, which holds arguments within a slice of <strong class="source-inline">strings</strong>. Very early on, in each method, we create the client and extract any flags we might need—in this case, the <strong class="source-inline">verbose</strong>, <strong class="source-inline">silence</strong>, and <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> flags:</span></p>
			<pre class="source-code">
    RunE: func(cmd *cobra.Command, args []string) error {
        client := &amp;http.Client{
            Timeout: 15 * time.Second,
        }
        var err error
          silence, _ := cmd.Flags().GetBool("silence")
        verbose, _ := cmd.Flags().GetBool("verbose")
        id, _ := cmd.Flags().GetString("id")
        if id == "" {
            id, err = utils.AskForID()
            if err != nil {
                return utils.Error("\n %v\n try again and
                    enter an id", err, verbose)
            }
        }</pre>
			<p>Next, we construct the request we are sending to the <strong class="source-inline">HTTP</strong> client, which uses the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
        params := "id=" + url.QueryEscape(id)
        path := fmt.Sprintf("http://%s:%d/delete?%s",
            viper.Get("cli.hostname"),
            viper.GetInt("cli.port"), params)
        payload := &amp;bytes.Buffer{}
        req, err := http.NewRequest(http.MethodGet,
            path, payload)
        if err != nil {
            return utils.Error("\n %v\n check configuration
                to ensure properly configured hostname and
                port", err<a id="_idTextAnchor205"/>, verbose)
        }</pre>
			<p>We check<a id="_idIndexMarker613"/> whether there’s any error when creating the request, which is most likely a result of a configuration error. Next, we log the request so that we are aware of any communication to <span class="No-Break">external servers:</span></p>
			<pre class="source-code">
        utils.LogRequest(verbose, http.MethodGet, path,
            payload.String())</pre>
			<p>We’ll execute the request through the client’s <strong class="source-inline">Do</strong> method and return an error if the request <span class="No-Break">was unsuccessful:</span></p>
			<pre class="source-code">
        resp, err := client.Do(req)
        if err != nil {
            return utils.Error("\n %v\n check configuration
                to ensure properly configured hostname and
                port\n or check that api is running", err,
                verbose)
        }
        defer resp.Body.Close()</pre>
			<p>Following the request, we check the response and read the <strong class="source-inline">resp.Body</strong> , or the body of the response, if the response was successful. If not, an error message will be returned <span class="No-Break">and logged:</span></p>
			<pre class="source-code">
        err = utils.CheckResponse(resp)
        if err != nil {
            return utils.Error("\n checking response: %v",
            err, verbose)
        }
        b, err := ioutil.ReadAll(resp.Body)
        if err != nil {
            return utils.Error("\n reading response: %v
                \n ", err, verbose)
        }
        utils.LogHTTPRespo<a id="_idTextAnchor206"/>nse(verbose, resp, b)</pre>
			<p>Finally, we <a id="_idIndexMarker614"/>check whether the response returns the <strong class="source-inline">success</strong> string, which shows a successful deletion. The result is then printed out to <span class="No-Break">the user:</span></p>
			<pre class="source-code">
        if strings.Contains(string(b), "success") &amp;&amp; !silence {
            fmt.Printf("\U00002705 Successfully deleted
                audiofile (%s)!\n", id)
        } else {
            fmt.Printf("\U0000274C Unsuccessful delete of
                audiofile (%s): %s\n", id, string(b))
        }
    <a id="_idTextAnchor207"/>    return nil
    },
}</pre>
			<p>You’ll see that the <strong class="source-inline">utils.Error</strong> function is called every time an error is encountered. You’ll also see a few other logging functions: <strong class="source-inline">utils.LogRequest</strong> and <strong class="source-inline">utils.LogHTTPResponse</strong>. The first, <strong class="source-inline">utils.LogRequest</strong>, is defined to log the request to either standard output, the log file, <span class="No-Break">or both:</span></p>
			<pre class="source-code">
func LogRequest(verbose bool, method, path, payload string) {
    if verbose {
        Verbose.Info(fmt.Sprintf("sending request: %s %s
            %s...\n", method, path, payload))
    } else {
        Logger.Info(fmt.Sprintf("sending request: %s %s
            %s...\n", path, path, payload))
    }
}</pre>
			<p>The <a id="_idIndexMarker615"/>second, <strong class="source-inline">utils.LogHTTPResponse</strong>, similarly logs the response from the previous request to either standard output, the log file, <span class="No-Break">or both:</span></p>
			<pre class="source-code">
func LogHTTPResponse(verbose bool, resp *http.Response, body []byte) {
    if verbose &amp;&amp; resp != nil {
        Verbose.Info(fmt.Sprintf("response status: %s,
            body: %s", resp.Status, string(body)))
    } else if resp != nil {
        Logger.Info(fmt.Sprintf("response status: %s, body:
            %s", resp.Status, string(body)))
    }
}</pre>
			<p>Now that this logger has been implemented for all the <strong class="source-inline">audiofile</strong> commands, let’s give it a try and see what the output looks like now that the command has a <strong class="source-inline">verbose</strong> flag to output debug data <span class="No-Break">when necessary.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor208"/>Trying out verbose mode to view stack traces</h2>
			<p>After recompiling<a id="_idIndexMarker616"/> the project, we run the <strong class="source-inline">delete</strong> command with an invalid ID and pass the <span class="No-Break"><strong class="source-inline">verbose</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
./bin/audiofile delete --id invalidID --verbose
{"level":"info","time":"2022-11-06 21:21:44","file":"utils/logger.go:112","message":"sending request: GET http://localhost:8000/delete?id=invalidID ...\n"}
{"level":"error","time":"2022-11-06 21:21:44","file":"utils/errors.go:17","message":"checking response: \u001b[41;37mthe id cannot be found\u001b[0m","stacktrace":"github.com/marianina8/audiofile/utils.Error\n\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/utils/errors.go:17\ngithub.com/marianina8/audiofile/cmd.glob..func2\n\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/cmd/delete.go:54\ngithub.com/spf13/cobra.(*Command).execute\n\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/vendor/github.com/spf13/cobra/command.go:872\ngithub.com/spf13/cobra.(*Command).ExecuteC\n\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/vendor/github.com/spf13/cobra/command.go:990\ngithub.com/spf13/cobra.(*Command).Execute\n\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/vendor/github.com/spf13/cobra/command.go:918\ngithub.com/marianina8/audiofile/cmd.Execute\n\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/cmd/root.go:21\nmain.main\n\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/main.go:11\nruntime.main\n\t/usr/local/go/src/runtime/proc.go:250"}
Error: checking response: the id cannot be found
Usage:
  audiofile delete [flags]
Flags:
  -h, --help        help for delete
      --id string   audiofile id
Global Flags:
  -v, --verbose   verbose</pre>
			<p>Using the <strong class="source-inline">verbose</strong> flag, the debug statements are printed out, and when an error occurs, the <a id="_idIndexMarker617"/>stack trace is also output. This is important data for the user to share with the developer to debug what went wrong. Now, let us learn how to give the option to the user to submit <span class="No-Break">a bug.</span></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor209"/>Effortless bug submission</h1>
			<p>Let us create <a id="_idIndexMarker618"/>a <strong class="source-inline">bug</strong> command using the Cobra generator for users to submit issues to the developers of the <span class="No-Break"><strong class="source-inline">audiofile</strong></span><span class="No-Break"> CLI:</span></p>
			<pre class="console">
cobra-cli add bug
bug created at /Users/mmontagnino/Code/src/githu<a id="_idTextAnchor210"/>b.com/marianina8/audiofile</pre>
			<p>Now that we have the <strong class="source-inline">bug</strong> command created, the <strong class="source-inline">Run</strong> field is changed to extract details of the application and launch a web browser with the data already added and ready for the user to just finish off the submission with some <span class="No-Break">extra details:</span></p>
			<pre class="source-code">
var bugCmd = &amp;cobra.Command{
    Use: "bug",
    Short: "Submit a bug",
    Long: "Bug opens the default browser to start a bug
        report which will include useful system
        information.",
    RunE: func(cmd *cobra.Command, args []string) error {
        if len(args) &gt; 0 {
            return fmt.Errorf("too many arguments")
        }
        var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf("**Audiofile
            version**\n%s\n\n", utils.Version()))
        buf.WriteString(description)
        buf.WriteString(toReproduce)
        buf.WriteString(expectedBehavior)
        buf.WriteString(additionalDetails)
        body := buf.String()
        url := "https://github.com/marianina8/audiofile/issues/new?title=Bug Report&amp;body=" + url.QueryEscape(body)
        // we print if the browser fails to open
        if !openBrowser(url) {
            fmt.Print("Please file a new issue at https://github.com/marianina8/audiofile/issues/new using this template:\n\n")
        fmt.Print(body)
        }
        return nil
    },
}</pre>
			<p>The strings <a id="_idIndexMarker619"/>passed into the <strong class="source-inline">buf.WriteString</strong> method are defined outside the command within the same file, <strong class="source-inline">cmd/bug.go</strong>, but once the command is run, the complete template body is defined <span class="No-Break">as follows:</span></p>
			<pre class="console">
**Audiofile version**
1.0.0
**Description**
A clear description of the bug encountered.
**To reproduce**
Steps to reproduce the bug.
**Expected behavior**
Expected behavior.
**Additional details**
Any other useful data to share.</pre>
			<p>Calling <a id="_idIndexMarker620"/>the <strong class="source-inline">./bin/audiofile bug</strong> command launches the browser to open a new issue on the <span class="No-Break">GitHub repo:</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_9.2._B18883.jpg" alt="Figure 9.2 – Screenshot of ﻿browser open to a new issue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Screenshot of <a id="_idTextAnchor211"/>browser open to a new issue</p>
			<p>From the<a id="_idIndexMarker621"/> browser window, open the new issue page; the version of the CLI is populated, and then the user can replace the default text for the description, reproduction steps, expected behavior, and other steps with <span class="No-Break">their own.</span></p>
			<h1 id="_idParaDest-198">Help<a id="_idTextAnchor212"/>, documentation, and support</h1>
			<p>Part of creating a CLI that empathizes with its users is to supply sufficient help and documentation, as well as support users of all kinds. Luckily, the Cobra CLI framework supports the generation of help from the short and long fields of the Cobra command and the generation of man pages as well. However, bringing empathy into the extended documentation <a id="_idIndexMarker622"/>of your CLI may require <span class="No-Break">several tec<a id="_idTextAnchor213"/>hniques.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor214"/>Generating help text</h2>
			<p>By now, there<a id="_idIndexMarker623"/> have been many examples of creating commands, but just to reiterate, the command structure and the fields that show up in help are fields within the Cobra commands. Let’s go over a <span class="No-Break">good example:</span></p>
			<pre class="source-code">
var playCmd = &amp;cobra.Command{
    Use: "play",
    Short: "Play audio file by id",
    Long: `Play audio file by id using the default audio
        player for your current system`,
    Example: `./bin/audiofile play –id
        45705eba-9342-4952-8cd4-baa2acc25188`,
    RunE: func(cmd *cobra.Command, args []string) e<a id="_idTextAnchor215"/>rror {
        // code
    },
}</pre>
			<p>Making sure you simply supply a short and long description of the command and one or several examples, you are supplying some help text that can at least get users started using the command. Running this will show the <span class="No-Break">following output:</span></p>
			<pre class="console">
audiofile % ./bin/audiofile play --help
Play audio file by id using the default audio player for your current system
Usage:
  audiofile play [flags]
Examples:
  ./bin/audiofile play –id 45705eba-9342-4952-8cd4-baa2acc25188
Flags:
  -h, --help        help for play
      --id string   audiofile id
Global Fl<a id="_idTextAnchor216"/>ags:
  -v, --verbose   verbose</pre>
			<p>A simple<a id="_idIndexMarker624"/> command doesn’t need a ton of explanation, so this is enough to help guide the user <span class="No-Break">with usage.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor217"/>Generating man pages</h2>
			<p>In the <strong class="source-inline">audiofile</strong> repo, we’ve <a id="_idIndexMarker625"/>added some additional code to generate the man pages for the existing commands and commands in the <strong class="source-inline">Makefile</strong> to run to quickly run the code to do so. There exists a new program within the repo defined <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">documentation/main.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import (
    "log"
    "github.com/marianina8/audiofile/cmd"
    "github.com/spf13/cobra/doc"
)
func main() {
    header := &amp;doc.GenManHeader{
        Title: "Audiofile",
        Source: "Auto generated by marianina8",
    }
    err := doc.GenManTree(cmd.RootCMD(), header, "./pages")
    if err != nil <a id="_idTextAnchor218"/>{
        log.Fatal(err)
    }
}</pre>
			<p>We pass in the <strong class="source-inline">root</strong> command and generate the pages in the <strong class="source-inline">./pages</strong> directory. The addition<a id="_idIndexMarker626"/> of the <strong class="source-inline">make pages</strong> command within the <strong class="source-inline">Makefile</strong> creates the man pages <span class="No-Break">when called:</span></p>
			<pre class="source-code">
manpages:
    mkdir -p pages<a id="_idTextAnchor219"/>
    go run documentation/main.go</pre>
			<p>Within the terminal, if you run <strong class="source-inline">make manpages</strong> and then check to see whether the new pages exist by running <strong class="source-inline">man pages/audiofile.1</strong>, you will see the generated man page for the <span class="No-Break"><strong class="source-inline">audiofile</strong></span><span class="No-Break"> CLI:</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_9.3_B18883.jpg" alt="Figure 9.3 – Screenshot of audiofile man pages in the terminal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Screenshot of audiofile man pages in the terminal</p>
			<p>You can also see that within the <strong class="source-inline">pages</strong> directory, there’s an individual man page created for all the commands that have been added to the <span class="No-Break"><strong class="source-inline">root</strong></span><span class="No-Break"> command.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor220"/>Embedding empathy into your documentation</h2>
			<p>By the <a id="_idIndexMarker627"/>time a user reaches your documentation, it is likely that they may already have encountered an issue and are frustrated or confused. It’s important that your documentation takes in that perspective and portrays an understanding of the <span class="No-Break">user’s situation.</span></p>
			<p>Although it may feel like documentation takes a lot of time and energy from other areas of development, it is essential for the future of your <span class="No-Break">command-line application.</span></p>
			<p>Within the last few years, there’s been a recent term, <em class="italic">empathy advocacy</em>, that has come up <a id="_idIndexMarker628"/>in regard to technical documentation. It was coined by Ryan Macklin, a technical and UX writer, as well as an empathy advocate. The term is used to describe a subfield of technical communication centered on empathy and realistic respect for human emotion. It can be considered a framework for the way you communicate with your users. Because many people come to your documentation, we know that there’s a varied assortment of brain chemistry, life experience, and recent events playing in mind. Empathy advocacy is one solution to this <span class="No-Break">beautiful challenge.</span></p>
			<p>Macklin has proposed seven philosophical documentation techniques rooted in empathy advocacy. These principles have been informed by disciplines such as UX, trauma psychotherapy, neurobiology, gameplay design, and cultural and language differences. Let’s discuss each of <a id="_idIndexMarker629"/>these tenets and why <span class="No-Break">they work:</span></p>
			<ul>
				<li><strong class="bold">Employ visual storytelling</strong>—The human brain easily grabs onto stories, and sighted users can benefit from visuals. However, this forces developers to think about different types<a id="_idIndexMarker630"/> of accessibility: visual, cognitive, motor, and so on. Telling a story forces the writer to think about structure. On the other hand, dense and long-winded text is <strong class="bold">accessibility-hostile</strong>. As a note, this idea doesn’t work <span class="No-Break">for everyone.</span></li>
				<li><strong class="bold">Use synopses</strong>—Using a <strong class="bold">tl;dr</strong> (short for <strong class="bold">too long, don’t read</strong>), a summary line, or a banner provides a shortened explanation for tired and stressed-out readers who benefit from a lower cognitive cost option. Cognitive glue is required for running a collection of cognitive tasks to complete a high level of intelligence. Cognitive glue requires energy, so providing a synopsis will provide a low-cost option for users who are already running <span class="No-Break">on low.</span></li>
				<li><strong class="bold">Give time frames</strong>—In general, uncertainty creates <strong class="bold">vicious voids</strong>, and dwelling within the unknown time frame can create heightened emotional responses. Providing time frames can help stabilize the void. Time frames can be given if there’s an outage on the server side, an upload to the server, or just a general time to complete a <span class="No-Break">certain task.</span></li>
				<li><strong class="bold">Include short videos</strong>—This is a great alternative for some users who struggle with reading comprehension. Typically, younger audiences are used to video, and when you split videos up into a single topic at max, the shorter playtime can be reassuring. Reassurance is a powerful way to regulate emotion. However, there are some pitfalls to video—mainly, that video costs more time and energy <span class="No-Break">to create.</span></li>
				<li><strong class="bold">Reduce screenshots</strong>—Providing<a id="_idIndexMarker631"/> screenshots can be helpful, but only when the UI can be confusing. Also, providing just enough for <a id="_idIndexMarker632"/>the user to figure some things out themselves helps to foster cognitive glue. Otherwise, being bombarded by visuals <span class="No-Break">hurts everyone.</span></li>
				<li><strong class="bold">Rethink FAQs</strong>—Instead of a traditional question and answer, break up documentation into single-scoped documents. Provide specific titles and <span class="No-Break">avoid over-promising.</span></li>
				<li><strong class="bold">Pick your battles</strong>—It’s difficult to fight every fight; do the best you can, and choose your battles. Not everything you do will work for everyone—learn along the way. After all, advocating for empathy is another means <span class="No-Break">of self-care.</span></li>
			</ul>
			<p>Hopefully, these<a id="_idIndexMarker633"/> tenets that describe the philosophy of empathy advocacy help you to think twice about the words you use in your documentation. A few things to consider when you are writing your documentation include how your words may come across to someone who is in a panicked or frustrated state. Also, consider how you can help those about to give up or lacking the energy to complete their task to <span class="No-Break">be successful.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor221"/>Summary</h1>
			<p>In this chapter, you have learned specific steps to make your command-line application more empathetic. From error handling, debug and traceback information, effortless bug submission, and empathic advocacy in technical communication, you have learned the technical and empathic skills to apply within <span class="No-Break">your application.</span></p>
			<p>Errors can now be rewritten in color to jump out of the screen and decorated with additional information that provides the user information on exactly where an error has occurred and potentially what they may need to do to reach a resolution. When an error seems unresolvable, the user can then run the same command using the <strong class="source-inline">--verbose</strong> flag and view the detail logs, which might contain server requests and responses necessary to trace more specifically where an error may be happening, down to the line <span class="No-Break">of code.</span></p>
			<p>If a bug is encountered, the addition of a new <strong class="source-inline">bug</strong> command allows the user to spawn a new browser straight from their terminal, opening straight to a new template in GitHub’s new issue <span class="No-Break">submission form.</span></p>
			<p>Finally, bridging the gap between technical documentation and the user’s perspective is done by taking an empathetic approach. Several philosophical tenets when using an empathic framework when writing your documentation <span class="No-Break">were discussed.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor222"/>Questions</h1>
			<ol>
				<li>Which two common methods can you use for decorating <span class="No-Break">your errors?</span></li>
				<li>Between Zap and Logrus loggers, why would you <span class="No-Break">choose Zap?</span></li>
				<li>What is <span class="No-Break">empathy advocacy?</span></li>
			</ol>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor223"/>Further reading</h1>
			<ul>
				<li><em class="italic">Empathy </em><span class="No-Break"><em class="italic">Advocacy</em></span><span class="No-Break">: </span><a href="https://empathyadvocacy.org"><span class="No-Break">https://empathyadvocacy.org</span></a></li>
				<li><em class="italic">Write the </em><span class="No-Break"><em class="italic">Docs</em></span><span class="No-Break">: </span><a href="https://www.writethedocs.org"><span class="No-Break">https://www.writethedocs.org</span></a></li>
			</ul>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor224"/>Answers</h1>
			<ol>
				<li value="1"><strong class="source-inline">fmt.Errorf(format string, a ...any) error or errors.Wrap(err error, message </strong><span class="No-Break"><strong class="source-inline">string) error</strong></span><span class="No-Break">.</span></li>
				<li>Zap is faster and is <span class="No-Break">actively maintained.</span></li>
				<li>Empathy advocacy is a sub-field of technical communication centered on empathy and realistic respect for human emotion. It can be considered a framework for the way you write your technical documentation and a solution for writing for many types of people with varied backgrounds <span class="No-Break">and accessibilities.</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer068" class="IMG---Figure">
			</div>
		</div>
	</body></html>