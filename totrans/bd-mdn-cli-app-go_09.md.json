["```go\nfunc Errorf(format string, a ...interface{}) error\n```", "```go\nbirthYear := -1981\nerr := fmt.Errorf(\"%d is negative\\nYear can't be negative\", birthYear)\nif birthYear < 0 {\n    fmt.Println(err)\n} else {\n    fmt.Printf(\"Birth year: %d\\n\", birthYear)\n}\n```", "```go\nfunc Wrap(err error, message string) error\n```", "```go\nfunc wrapping() error {\n    err := errors.New(\"error\")\n    err1 := operation1()\n    if err1 != nil {\n        err1 = errors.Wrap(err, \"operation1\")\n    }\n    err2 := operation2()\n    if err != nil {\n        err2 = errors.Wrap(err1, \"operation2\")\n    }\n    err3 := operation3()\n    if err != nil {\n        err3 = errors.Wrap(err2, \"operation3\")\n    }\n    return err3\n}\n```", "```go\nerror\n.../errors.wrapping\n        .../errors/errors.go:73\n.../errors.Examples\n        .../errors/errors.go:39\nmain.main\n        .../main.go:6\nruntime.main\n        /usr/local/go/src/runtime/proc.go:250\nruntime.goexit\n        /usr/local/go/src/runtime/asm_amd64.s:1594\noperation1\n.../errors.wrapping\n        .../errors/errors.go:76\n.../errors.Examples\n        .../errors/errors.go:39\nmain.main\n        .../main.go:6\nruntime.main\n        /usr/local/go/src/runtime/proc.go:250\nruntime.goexit\n        /usr/local/go/src/runtime/asm_amd64.s:1594\noperation2\n.../errors.wrapping\n        .../errors/errors.go:80\n.../errors.Examples\n        .../errors/errors.go:39\nmain.main\n        .../main.go:6\nruntime.main\n        /usr/local/go/src/runtime/proc.go:250\nruntime.goexit\n        /usr/local/go/src/runtime/asm_amd64.s:1594\noperation3\n.../errors.wrapping\n        .../errors/errors.go:84\n.../errors.Examples\n        .../errors/errors.go:39\nmain.main\n        .../main.go:6\nruntime.main\n        /usr/local/go/src/runtime/proc.go:250\nruntime.goexit\n        /usr/local/go/src/runtime/asm_amd64.s:1594\n```", "```go\ntype error interface {\n    Error() string\n}\n```", "```go\ntype customError struct {\n    Task string\n    Err error\n}\n```", "```go\nfunc (e *customError) Error() string {\n    var errorColor = color.New(color.BgRed,\n        color.FgWhite).SprintFunc()\n    return fmt.Sprintf(\"%s: %s %s\", errorColor(e.Task),\n        crossMark, e.Err)\n}\n```", "```go\nfunc eligibleToVote(age int) error {\n    fmt.Printf(\"%s Attempting to vote at %d years\n        old...\\n\", votingBallot, age)\n    minimumAge := 18\n    err := &customError{\n        Task: \" eligibleToVote\",\n    }\n    if age < minimumAge && age > 0 {\n        years := minimumAge - age\n        err.Err = fmt.Errorf(\"too young to vote, at %d,\n            wait %d more years\", age, years)\n        return err\n    }\n    if age < 0 {\n        err.Err = fmt.Errorf(\"age cannot be negative: %d\",\n            age)\n        return err\n    }\n    fmt.Println(\"Voted.\", checkMark)\n    return nil\n}\n```", "```go\nbirthYear = 2010\ncurrentYear := 2022\nage := currentYear - birthYear\nerr = eligibleToVote(age)\nif err != nil {\n    fmt.Println(\"error occurred: \", err)\n}\n```", "```go\nfunc CheckResponse(resp *http.Response) error {\n    if resp != nil {\n        if resp.StatusCode != http.StatusOK {\n            switch resp.StatusCode {\n            case http.StatusInternalServerError:\n                return fmt.Errorf(errorColor(\"retry the command \n                  later\"))\n            case http.StatusNotFound:\n                return fmt.Errorf(errorColor(\"the id cannot be \n                  found\"))\n            default:\n                return fmt.Errorf(errorColor(fmt.\n                  Sprintf(\"unexpected response: %v\", resp.\n                  Status)))\n            }\n        }\n        return nil\n    } else {\n        return fmt.Errorf(errorColor(\"response body is nil\"))\n    }\n}\n```", "```go\nmmontagnino@Marians-MacBook-Pro audiofile % ./bin/audiofile get --id 1234\nSending request: GET http://localhost:8000/request?id=1234 ...\nError:\n  checking response: the id cannot be found\nUsage:\n  audiofile get [flags]\nFlags:\n  -h, --help        help for get\n      --id string   audiofile id\n      --json        return json format\n```", "```go\ngo get -u go.uber.org/zap\n```", "```go\npackage utils\nimport (\n    \"go.uber.org/zap\"\n)\nvar Logger *zap.Logger\nvar Verbose *zap.Logger\nfunc InitCLILogger() {\n    var err error\n    var cfg zap.Config\n    config := viper.GetStringMap(\"cli.logging\")\n    configBytes, _ := json.Marshal(config)\n    if err := json.Unmarshal(configBytes, &cfg); err != nil {\n        panic(err)\n    }\n    cfg.EncoderConfig = encoderConfig()\n    err = createFilesIfNotExists(cfg.OutputPaths)\n    if err != nil {\n        panic(err)\n    }\n    cfg.Encoding = \"json\"\n    cfg.Level = zap.NewAtomicLevel()\n    Logger, err = cfg.Build()\n    if err != nil {\n        panic(err)\n    }\n    cfg.OutputPaths = append(cfg.OutputPaths, \"stdout\")\n    Verbose, err = cfg.Build()\n    if err != nil {\n        panic(err)\n    }\n    defer Logger.Sync()\n}\n```", "```go\n{\n    \"cli\": {\n        \"hostname\": \"localhost\",\n        \"port\": 8000,\n        \"logging\": {\n            \"level\": \"debug\",\n            \"encoding\": \"json\",\n            \"outputPaths\": [\n                \"/tmp/log/audiofile.json\"\n            ]\n        }\n    }\n}\n```", "```go\nfunc encoderConfig() zapcore.EncoderConfig {\n    return zapcore.EncoderConfig{\n        MessageKey: \"message\",\n        LevelKey: \"level\",\n        TimeKey: \"time\",\n        NameKey: \"name\",\n        CallerKey: \"file\",\n        StacktraceKey: \"stacktrace\",\n        EncodeName: zapcore.FullNameEncoder,\n        EncodeTime: timeEncoder,\n        EncodeLevel: zapcore.LowercaseLevelEncoder,\n        EncodeDuration: zapcore.SecondsDurationEncoder,\n        EncodeCaller: zapcore.ShortCallerEncoder,\n    }\n}\n```", "```go\nrootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose\")\n```", "```go\nfunc Error(errString string, err error, verbose bool) error {\n    errString = cleanup(errString, err)\n    if err != nil {\n        if verbose {\n            // prints to stdout also\n            Verbose.Error(errString)\n        } else {\n            Logger.Error(errString)\n        }\n        return fmt.Errorf(errString)\n    }\n    return nil\n}\n```", "```go\nvar deleteCmd = &cobra.Command{\n    Use: \"delete\",\n    Short: \"Delete audiofile by id\",\n    Long: `Delete audiofile by id. This command removes the\n        entire folder containing all stored metadata`,\n```", "```go\n    RunE: func(cmd *cobra.Command, args []string) error {\n        client := &http.Client{\n            Timeout: 15 * time.Second,\n        }\n        var err error\n          silence, _ := cmd.Flags().GetBool(\"silence\")\n        verbose, _ := cmd.Flags().GetBool(\"verbose\")\n        id, _ := cmd.Flags().GetString(\"id\")\n        if id == \"\" {\n            id, err = utils.AskForID()\n            if err != nil {\n                return utils.Error(\"\\n %v\\n try again and\n                    enter an id\", err, verbose)\n            }\n        }\n```", "```go\n        params := \"id=\" + url.QueryEscape(id)\n        path := fmt.Sprintf(\"http://%s:%d/delete?%s\",\n            viper.Get(\"cli.hostname\"),\n            viper.GetInt(\"cli.port\"), params)\n        payload := &bytes.Buffer{}\n        req, err := http.NewRequest(http.MethodGet,\n            path, payload)\n        if err != nil {\n            return utils.Error(\"\\n %v\\n check configuration\n                to ensure properly configured hostname and\n                port\", err, verbose)\n        }\n```", "```go\n        utils.LogRequest(verbose, http.MethodGet, path,\n            payload.String())\n```", "```go\n        resp, err := client.Do(req)\n        if err != nil {\n            return utils.Error(\"\\n %v\\n check configuration\n                to ensure properly configured hostname and\n                port\\n or check that api is running\", err,\n                verbose)\n        }\n        defer resp.Body.Close()\n```", "```go\n        err = utils.CheckResponse(resp)\n        if err != nil {\n            return utils.Error(\"\\n checking response: %v\",\n            err, verbose)\n        }\n        b, err := ioutil.ReadAll(resp.Body)\n        if err != nil {\n            return utils.Error(\"\\n reading response: %v\n                \\n \", err, verbose)\n        }\n        utils.LogHTTPResponse(verbose, resp, b)\n```", "```go\n        if strings.Contains(string(b), \"success\") && !silence {\n            fmt.Printf(\"\\U00002705 Successfully deleted\n                audiofile (%s)!\\n\", id)\n        } else {\n            fmt.Printf(\"\\U0000274C Unsuccessful delete of\n                audiofile (%s): %s\\n\", id, string(b))\n        }\n        return nil\n    },\n}\n```", "```go\nfunc LogRequest(verbose bool, method, path, payload string) {\n    if verbose {\n        Verbose.Info(fmt.Sprintf(\"sending request: %s %s\n            %s...\\n\", method, path, payload))\n    } else {\n        Logger.Info(fmt.Sprintf(\"sending request: %s %s\n            %s...\\n\", path, path, payload))\n    }\n}\n```", "```go\nfunc LogHTTPResponse(verbose bool, resp *http.Response, body []byte) {\n    if verbose && resp != nil {\n        Verbose.Info(fmt.Sprintf(\"response status: %s,\n            body: %s\", resp.Status, string(body)))\n    } else if resp != nil {\n        Logger.Info(fmt.Sprintf(\"response status: %s, body:\n            %s\", resp.Status, string(body)))\n    }\n}\n```", "```go\n./bin/audiofile delete --id invalidID --verbose\n{\"level\":\"info\",\"time\":\"2022-11-06 21:21:44\",\"file\":\"utils/logger.go:112\",\"message\":\"sending request: GET http://localhost:8000/delete?id=invalidID ...\\n\"}\n{\"level\":\"error\",\"time\":\"2022-11-06 21:21:44\",\"file\":\"utils/errors.go:17\",\"message\":\"checking response: \\u001b[41;37mthe id cannot be found\\u001b[0m\",\"stacktrace\":\"github.com/marianina8/audiofile/utils.Error\\n\\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/utils/errors.go:17\\ngithub.com/marianina8/audiofile/cmd.glob..func2\\n\\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/cmd/delete.go:54\\ngithub.com/spf13/cobra.(*Command).execute\\n\\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/vendor/github.com/spf13/cobra/command.go:872\\ngithub.com/spf13/cobra.(*Command).ExecuteC\\n\\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/vendor/github.com/spf13/cobra/command.go:990\\ngithub.com/spf13/cobra.(*Command).Execute\\n\\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/vendor/github.com/spf13/cobra/command.go:918\\ngithub.com/marianina8/audiofile/cmd.Execute\\n\\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/cmd/root.go:21\\nmain.main\\n\\t/Users/mmontagnino/Code/src/github.com/marianina8/audiofile/main.go:11\\nruntime.main\\n\\t/usr/local/go/src/runtime/proc.go:250\"}\nError: checking response: the id cannot be found\nUsage:\n  audiofile delete [flags]\nFlags:\n  -h, --help        help for delete\n      --id string   audiofile id\nGlobal Flags:\n  -v, --verbose   verbose\n```", "```go\ncobra-cli add bug\nbug created at /Users/mmontagnino/Code/src/github.com/marianina8/audiofile\n```", "```go\nvar bugCmd = &cobra.Command{\n    Use: \"bug\",\n    Short: \"Submit a bug\",\n    Long: \"Bug opens the default browser to start a bug\n        report which will include useful system\n        information.\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        if len(args) > 0 {\n            return fmt.Errorf(\"too many arguments\")\n        }\n        var buf bytes.Buffer\n        buf.WriteString(fmt.Sprintf(\"**Audiofile\n            version**\\n%s\\n\\n\", utils.Version()))\n        buf.WriteString(description)\n        buf.WriteString(toReproduce)\n        buf.WriteString(expectedBehavior)\n        buf.WriteString(additionalDetails)\n        body := buf.String()\n        url := \"https://github.com/marianina8/audiofile/issues/new?title=Bug Report&body=\" + url.QueryEscape(body)\n        // we print if the browser fails to open\n        if !openBrowser(url) {\n            fmt.Print(\"Please file a new issue at https://github.com/marianina8/audiofile/issues/new using this template:\\n\\n\")\n        fmt.Print(body)\n        }\n        return nil\n    },\n}\n```", "```go\n**Audiofile version**\n1.0.0\n**Description**\nA clear description of the bug encountered.\n**To reproduce**\nSteps to reproduce the bug.\n**Expected behavior**\nExpected behavior.\n**Additional details**\nAny other useful data to share.\n```", "```go\nvar playCmd = &cobra.Command{\n    Use: \"play\",\n    Short: \"Play audio file by id\",\n    Long: `Play audio file by id using the default audio\n        player for your current system`,\n    Example: `./bin/audiofile play –id\n        45705eba-9342-4952-8cd4-baa2acc25188`,\n    RunE: func(cmd *cobra.Command, args []string) error {\n        // code\n    },\n}\n```", "```go\naudiofile % ./bin/audiofile play --help\nPlay audio file by id using the default audio player for your current system\nUsage:\n  audiofile play [flags]\nExamples:\n  ./bin/audiofile play –id 45705eba-9342-4952-8cd4-baa2acc25188\nFlags:\n  -h, --help        help for play\n      --id string   audiofile id\nGlobal Flags:\n  -v, --verbose   verbose\n```", "```go\nimport (\n    \"log\"\n    \"github.com/marianina8/audiofile/cmd\"\n    \"github.com/spf13/cobra/doc\"\n)\nfunc main() {\n    header := &doc.GenManHeader{\n        Title: \"Audiofile\",\n        Source: \"Auto generated by marianina8\",\n    }\n    err := doc.GenManTree(cmd.RootCMD(), header, \"./pages\")\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n```", "```go\nmanpages:\n    mkdir -p pages\n    go run documentation/main.go\n```"]