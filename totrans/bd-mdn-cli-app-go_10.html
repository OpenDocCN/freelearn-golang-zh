<html><head></head><body>
		<div id="_idContainer087">
			<h1 id="_idParaDest-206" class="chapter-number"><a id="_idTextAnchor225"/>10</h1>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor226"/>Interactivity with Prompts and Terminal Dashboards</h1>
			<p>One powerful way to increase usability for users is to integrate interactivity with either prompts or terminal dashboards. Prompts are useful because they create a conversational approach while requesting input. Dashboards are useful because they allow developers to create a graphical interface from ASCII characters. That graphical interface, via a dashboard, can create powerful visual cues to allow users to navigate through <span class="No-Break">different commands.</span></p>
			<p>This chapter will give you examples of how to build user surveys from a series of prompts, and a terminal dashboard – whether learning about the Termdash library, designing the mockup, or implementing it for the audio <span class="No-Break">file CLI.</span></p>
			<p>Interactivity is fun. It’s the more human and empathetic approach to a command-line interface. However, remember to disable interactivity if you are not outputting to a terminal. This chapter will cover the basics of surveys and dive deep into the terminal dashboard. By the end of this chapter, you’ll have everything you need to create your own survey or dashboard. We will cover <span class="No-Break">the following:</span></p>
			<ul>
				<li>Guiding users <span class="No-Break">with prompts</span></li>
				<li>Designing a useful <span class="No-Break">terminal dashboard</span></li>
				<li>Implementing a <span class="No-Break">terminal dashboard</span></li>
			</ul>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor227"/>Technical requirements</h1>
			<ul>
				<li>You’ll need a Unix operating system to understand and run the examples shared in <span class="No-Break">the chapter</span></li>
				<li>Get the <strong class="source-inline">termdash</strong> package <span class="No-Break">at </span><a href="https://github.com/mum4k/termdash"><span class="No-Break">https://github.com/mum4k/termdash</span></a><a href="https://github.com/mum4k/termdash&#13;"/></li>
				<li>Get the survey package <span class="No-Break">at </span><a href="https://github.com/go-survey/survey"><span class="No-Break">https://github.com/go-survey/survey</span></a><a href="https://github.com/go-survey/survey&#13;"/></li>
				<li>You can also find the code examples on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10</span></a><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter-10&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor228"/>Guiding users with prompts</h1>
			<p>There <a id="_idIndexMarker634"/>are<a id="_idTextAnchor229"/> many ways to simply prompt the user, but if you want to create a whole survey that<a id="_idTextAnchor230"/> can retrieve information using a variety of different prompts – text input, multi-select, single-select, multi-line text, password, and more – it might be useful to use a preexisting library to handle this for you. Let’s create a generic customer survey using the <span class="No-Break"><strong class="source-inline">survey</strong></span><span class="No-Break"> package.</span></p>
			<p>To show you how to use this package, I’ll create a survey that can prompt the user for different types <span class="No-Break">of input:</span></p>
			<ul>
				<li><strong class="bold">Text input</strong> – for example, an <span class="No-Break">email address</span></li>
				<li><strong class="bold">Select</strong> – for example, a user’s experience with <span class="No-Break">the CLI</span></li>
				<li><strong class="bold">Multiselect</strong> – for example, any <span class="No-Break">issues encountered</span></li>
				<li><strong class="bold">Multiline</strong> – for example, <span class="No-Break">open-ended feedback</span></li>
			</ul>
			<p>In the <strong class="source-inline">Chapter-10</strong> repository, a survey has been written to handle these four prompts. The questions, stored in the <strong class="source-inline">qs</strong> variable, are defined as a slice <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">*survey.Question</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
questions := []*survey.Question{
    {
        Name: "email",
        Prompt: &amp;survey.Input{
          Message: "What is your email address?"
   },
        Validate: survey.Required,
        Transform: survey.Title,
    },
    {
        Name: "rating",
        Prompt: &amp;survey.Select{
            Message: "How would you rate your experience with 
                     the CLI?",
            Options: []string{"Hated it", "Disliked", "Decent", 
                             "Great", "Loved it"},
       },
    },
    {
        Name: "issues",
            Prompt: &amp;survey.MultiSelect{
            Message: "Have you encountered any of these 
                     issues?",
            Options: []string{"audio player issues", "upload 
                             issues", "search issues", "other 
                             technical issues"},
        },
    },
    {
        Name: "suggestions",
        Prompt: &amp;survey.Multiline{
            Message: "Please provide any other feedback or 
                     suggestions you may have.",
        },
    },
}</pre>
			<p>We’ll need<a id="_idTextAnchor231"/> an<a id="_idTextAnchor232"/> <strong class="source-inline">answers</strong> struct to store all the results from <span class="No-Break">the prompts:</span></p>
			<pre class="source-code">
results := struct {
    Email string
    Rating string
    Issues []string
    Suggestions string
}{}</pre>
			<p>And finally, the <a id="_idIndexMarker635"/>method that asks the questions and stores <span class="No-Break">the results:</span></p>
			<pre class="source-code">
err := survey.Ask(questions, &amp;results)
if err != nil {
    fmt.Println(err.Error())
    return
}</pre>
			<p>Now that we’ve created th<a id="_idTextAnchor233"/>e survey, we can try <span class="No-Break">it out:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro Chapter-10 % go run main.go
? What is your email? mmontagnino@gmail.com
? How would you rate your experience with the CLI? Great
? Have you encountered any of these issues? audio player issues, search issues
? Please provide any other feedback or suggestions you may have. [Enter 2 empty lines to finish]I want this customer survey embedded into the CLI and email myself the results!</pre>
			<p>Prompting the user is an easy way to integrate interactivity into your command-line application<a id="_idTextAnchor234"/>. However, there are even more colorful and fun ways to interact with your users. In the next section, we’ll discuss the terminal dashboard, the <strong class="source-inline">termdash</strong> package in detail, and how t<a id="_idTextAnchor235"/>o mock up and implement a <span class="No-Break">terminal dashboard.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor236"/>Designing a useful terminal dashboard</h1>
			<p>Command-line interfaces <a id="_idIndexMarker636"/>don’t have to be limited to text. With <strong class="bold">termdash</strong>, a popular Golang library, you can build a terminal dashboard providing users with a user interface to visually see progress, alerts, text, and more. Colorful widgets placed within a clean dashboard that’s been neatly laid out can increase information density and present a lot of information to the user in a very user-friendly manner. In this section, we’ll learn about the library and the different layout choices and widget options. At the end of the chapter, we’ll design a terminal dashboard that we can implement in<a id="_idIndexMarker637"/> our <strong class="bold">audio file </strong><span class="No-Break">command-line interface.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor237"/>Learning about Termdash</h2>
			<p>Termdash is a<a id="_idIndexMarker638"/> Golang library that provides a customizable and cross-platform, terminal-based dashboard. On the project’s GitHub page, a fun and colorful demo provides an example of all possible widgets demonstrated within a dynamic layout. From the demo, you can see that you can go all out on a fancy dashbo<a id="_idTextAnchor238"/>ard. To do so, you’ll need to understand how to lay out a dashboard, interact with keyboard and mouse events, add widgets, and fine-tune the appearance with alignment and color. Within this section, we will break down the layers of a Termdash interface and the widgets that can be organized <span class="No-Break">within it.</span></p>
			<p>A Termdash dashboard consists of four <span class="No-Break">main layers:</span></p>
			<ul>
				<li>The <span class="No-Break">terminal layer</span></li>
				<li>The <span class="No-Break">infrastructure layer</span></li>
				<li>The <span class="No-Break">container layer</span></li>
				<li>The <span class="No-Break">widgets layer</span></li>
			</ul>
			<p>Let’s take a deep dive into each <span class="No-Break">of them.</span></p>
			<h3>The terminal layer</h3>
			<p>Think<a id="_idIndexMarker639"/> of the <a id="_idIndexMarker640"/>terminal layer of a dashboard as a 2D grid of cells that exist within a buffer. Each cell contains either an ASCII or Unicode character with the option to customize the foreground color, the color of text, the background color, or the color of the non-character space within the cell. Interactions with the mouse and keyboard happen on this layer <span class="No-Break">as well.</span></p>
			<p>Two terminal libraries can be used to interact at the cell level of <span class="No-Break">a terminal:</span></p>
			<ul>
				<li><strong class="bold">tcell</strong>: Inspired <a id="_idIndexMarker641"/>by <strong class="bold">termbox</strong> and has many <span class="No-Break">new improvements</span></li>
				<li><strong class="bold">termbox</strong>: No<a id="_idIndexMarker642"/> longer supported, although it is still <span class="No-Break">an option</span></li>
			</ul>
			<p>The<a id="_idIndexMarker643"/> following <a id="_idIndexMarker644"/>examples will utilize the <strong class="source-inline">tcell</strong> package to interact with the terminal. To start, create a new <strong class="source-inline">tcell</strong> instance to interact via the <span class="No-Break">terminal API:</span></p>
			<pre class="source-code">
terminalLayer, err := tcell.New()
if err != nil {
   return err
}
defer terminalLayer.Close()</pre>
			<p>Notice that in this example, <strong class="source-inline">tcell</strong> has two methods: <strong class="source-inline">New</strong> and <strong class="source-inline">Close</strong>.  <strong class="source-inline">New</strong> creates a new <strong class="source-inline">tcell</strong> instance in order to interact with the terminal and <strong class="source-inline">Close</strong> closes the terminal. It’s a good practice to defer closing access to <strong class="source-inline">tcell</strong> right after creation. Although there are no options passed into the <strong class="source-inline">New</strong> method, there are a few optional methods that can <span class="No-Break">be called:</span></p>
			<ul>
				<li><strong class="source-inline">ColorMode</strong> sets the color mode when initializing <span class="No-Break">a terminal</span></li>
				<li><strong class="source-inline">ClearStyle</strong> sets the foreground and background color when a terminal <span class="No-Break">is cleared</span></li>
			</ul>
			<p>An example of initializing a cell in <strong class="source-inline">ColorMode</strong> to access all 256 available terminal colors would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
terminalLayer, err := tcell.New(tcell.ColorMode(terminalapi.ColorMode256))
if err != nil {
   return err
}
defer terminalLayer.Close()</pre>
			<p><strong class="source-inline">ClearStyle</strong>, by default, will use <strong class="source-inline">ColorDefault</strong> if no specific <strong class="source-inline">ClearStyle</strong> is set. This <strong class="source-inline">ColorDefault</strong> is usually the default foreground and background colors of the terminal emulator, which are typically black and white. To set a terminal to use a yellow foreground <a id="_idIndexMarker645"/>and navy<a id="_idIndexMarker646"/> background style when the terminal is cleared, the <strong class="source-inline">New</strong> method, which accepts a slice of options, would be modified in the <span class="No-Break">following way:</span></p>
			<pre class="source-code">
terminalLayer, err := tcell.New(tcell.ColorMode(terminalapi.ColorMode256), tcell.ClearStyle(cell.ColorYellow, cell.ColorNavy))
if err != nil {
   return err
}
defer terminalLayer.Close()</pre>
			<p>Now that we’ve created a new <strong class="source-inline">tcell</strong> that gives us access to the Terminal API, let’s discuss the next layer – <span class="No-Break">infrastructure.</span></p>
			<h3>The infrastructure layer</h3>
			<p>The <a id="_idIndexMarker647"/>infrastructure<a id="_idIndexMarker648"/> of a terminal dashboard provides the organization of the structure.  The three main elements of the infrastructure layer include alignment, line style, <span class="No-Break">and Termdash.</span></p>
			<h4>Alignment</h4>
			<p>Alignment<a id="_idIndexMarker649"/> is provided by the <strong class="source-inline">align</strong> package, which provides two alignment options – <strong class="source-inline">align.Horizonal</strong>, which includes predefined values of <strong class="source-inline">left</strong>, <strong class="source-inline">center</strong>, and <strong class="source-inline">right</strong> and <strong class="source-inline">align.Vertical</strong> with predefined values of <strong class="source-inline">top</strong>, <strong class="source-inline">middle</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">bottom</strong></span><span class="No-Break">.</span></p>
			<h4>Line style</h4>
			<p>The line style<a id="_idIndexMarker650"/> defines the style of the line drawn on the terminal either when drawing boxes <span class="No-Break">or borders.</span></p>
			<p>The package exposes the options available via <strong class="source-inline">LineStyle</strong>. The <strong class="source-inline">LineStyle</strong> type represents a style<a id="_idIndexMarker651"/> that follows the <span class="No-Break">Unicode options.</span></p>
			<h4>Termdash</h4>
			<p>Termdash <a id="_idIndexMarker652"/>provides the developer with the main entry point. Its most important purpose is to start and stop the dashboard application, control screen refreshing, process any runtime errors, and subscribe and listen for keyboard and mouse events. The <strong class="source-inline">termdash.Run</strong> method is the simplest way to start a Termdash application. The terminal may run until the context expires, a keyboard shortcut is called, or it times out. The simplest way to get started with the dashboard is with the following minimal code example, which creates a new <strong class="source-inline">tcell</strong> for the terminal layer, and a new <strong class="bold">container</strong> for the container layer. A container is another module within the <strong class="source-inline">termdash</strong> package, which we will dive into in the next section. We create context with a 2-minute timeout and then call the <strong class="source-inline">Run</strong> method of the <span class="No-Break"><strong class="source-inline">termdash</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
if terminalLayer, err := tcell.New()
if err != nil {
   return err
}
defer terminalLayer.Close()
containerLayer, err := container.New(terminalLayer)
if err != nil {
   return err
}
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel()
if err := termdash.Run(ctx, terminalLayer, containerLayer); err != nil {
   return err
}</pre>
			<p>In the preceding code example, the dashboard will run until the context expires, in <span class="No-Break">60 seconds.</span></p>
			<p>Screen <a id="_idIndexMarker653"/>redrawing, or refreshing, for your Terminal dashboard can be done in a few ways: periodic, time-based redraws or manually triggered redraws. Only one method may be used, as using one means the other method is ignored. Besides that, the screen will refresh each time an input event occurs. The <strong class="source-inline">termdash.RedrawInterval</strong> method is an option that can be passed into the <strong class="source-inline">Run</strong> method to tell the dashboard application to redraw, or refresh, the screen at a particular interval. The <strong class="source-inline">Run</strong> method can be modified with the option to refresh every <span class="No-Break">5 seconds:</span></p>
			<pre class="source-code">
termdash.Run(ctx, terminalLayer, containerLayer, termdash.RedrawInterval(5*time.Second))</pre>
			<p>The dashboard may also be redrawn using a controller, which can be triggered manually. This option means that the dashboard is drawn only once and unlike the <strong class="source-inline">Run</strong> method, the user maintains control of the main goroutine. An example of this code, using the previously defined <strong class="source-inline">tcell</strong> and <strong class="source-inline">container</strong> variables defined earlier, can be passed into a new controller to be <span class="No-Break">drawn manually:</span></p>
			<pre class="source-code">
termController, err := termdash.NewController(terminalLayer, containerLayer)
if err != nil {
    return err
}
defer termController.Close()
if err := termController.Redraw(); err != nil {
    return fmt.Errorf("error redrawing dashboard: %v", err)
}</pre>
			<p>The Termdash API provides a <strong class="source-inline">termdash.ErrorHandler</strong> option, which tells the dashboard how to handle errors gracefully. Without providing an implementation for this error handler, the dashboard will panic on all runtime errors. Errors can occur when processing or retrieving events, subscribing to an event, or when a container fails to <span class="No-Break">draw itself.</span></p>
			<p>An error<a id="_idIndexMarker654"/> handler is a callback method that receives an error and handles the error appropriately. It can be defined as a variable and, in the simplest case, just prints the <span class="No-Break">runtime error:</span></p>
			<pre class="source-code">
errHandler := func(err error) {
   fmt.Printf("runtime error: %v", err)
}</pre>
			<p>When starting a Termdash application using the <strong class="source-inline">Run</strong> or <strong class="source-inline">NewController</strong> method, the error handler may be passed in as an option using the <strong class="source-inline">termdash.ErrorHandler</strong> method. For example, the <strong class="source-inline">Run</strong> method can be modified with a <span class="No-Break">new option:</span></p>
			<pre class="source-code">
termdash.Run(ctx, terminalLayer, containerLayer, termdash.ErrorHandler(errHandler))</pre>
			<p>While the <strong class="source-inline">NewController</strong> method can be <span class="No-Break">modified similarly:</span></p>
			<pre class="source-code">
termdash.NewController(terminalLayer, containerLayer, termdash.ErrorHandler(errHandler))</pre>
			<p>Through the <strong class="source-inline">termdash</strong> package, you can also subscribe to keyboard and mouse events. Typically, the container and certain widgets subscribe to keyboard and mouse events. Developers can also subscribe to certain mouse and keyboard events to take global action. For example, a developer may want the terminal to run a specific function when a specific key is set. <strong class="source-inline">termdash.KeyboardSubscriber</strong> is used to implement this functionality. With the following code, the user subscribes to the letters <strong class="source-inline">q</strong> and <strong class="source-inline">Q</strong> and responds to the keyboard events by running code to quit <span class="No-Break">the dashboard:</span></p>
			<pre class="source-code">
keyboardSubscriber := func(k *terminalapi.Keyboard) {
    switch k.Key {
      case 'q':
      case 'Q':
          cancel()
    }
}
if err := termdash.Run(ctx, terminalLayer, containerLayer, termdash.KeyboardSubscriber(keyboardSubscriber)); err != nil {
return fmt.Errorf("error running termdash with keyboard subscriber: %v", err)
}</pre>
			<p>Another <a id="_idIndexMarker655"/>option is to call the <strong class="source-inline">Run</strong> method with the option to listen to mouse events using <strong class="source-inline">termdash.MouseSubscriber</strong>. Similarly, the following code can be called to do something random when the mouse button is clicked within <span class="No-Break">the dashboard:</span></p>
			<pre class="source-code">
mouseClick := func(m *terminalapi.Mouse) {
    switch m.Button {
        case mouse.ButtonRight:
        // when the left mouse button is clicked - cancel
        cancel()
        case mouse.ButtonLeft:
        // when the left mouse button is clicked
        case mouse.ButtonMiddle:
        // when the middle mouse button is clicked
    }
}
if err := termdash.Run(ctx, terminalLayer, containerLayer, termdash.MouseSubscriber(mouseClick)); err != nil {
    return fmt.Errorf("error running termdash with mouse subscriber: %v", err)
}</pre>
			<h3>The container layer</h3>
			<p>The <a id="_idIndexMarker656"/>container<a id="_idIndexMarker657"/> layer provides options for dashboard layouts, container styles, keyboard focus, and margin and padding. It also provides a method for placing a widget within <span class="No-Break">a container.</span></p>
			<p>From the previous examples, we see that a new container is called using the <strong class="source-inline">container.New</strong> function. We’ll provide some new examples of how to organize your container and set it up with <span class="No-Break">different layouts.</span></p>
			<p>There are two main <span class="No-Break">layout options:</span></p>
			<ul>
				<li><span class="No-Break">Binary tree</span></li>
				<li><span class="No-Break">Grid layouts</span></li>
			</ul>
			<p>The <strong class="bold">binary tree layout</strong> organizes<a id="_idIndexMarker658"/> containers in a binary tree structure where each container is a node in a tree, which, unless empty, may contain either two sub-containers or a widget. Sub-containers can be split further with the same rules. There are two kinds <span class="No-Break">of splits:</span></p>
			<ul>
				<li><strong class="bold">Horizontal splits</strong>, created <a id="_idIndexMarker659"/>with the <strong class="source-inline">container.SplitHorizontal</strong> method, will create top and bottom sub-containers specified by <strong class="source-inline">container.Top</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">container.Bottom</strong></span></li>
				<li><strong class="bold">Vertical splits</strong>, created <a id="_idIndexMarker660"/>with the <strong class="source-inline">container.SplitVertical</strong> method, will create left and right sub-containers, specified by <strong class="source-inline">container.Left</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">container.Right</strong></span></li>
			</ul>
			<p>The <strong class="source-inline">container.SplitPercent</strong> option specifies the percentage of container split to use when spitting either vertically or horizontally. When the split percentage is not specified, a default of 50% is used. The following is a simple example of a binary tree layout using all the <span class="No-Break">methods described:</span></p>
			<pre class="source-code">
    terminalLayer, err := tcell.New(tcell.ColorMode(terminalapi.ColorMode256),
        tcell.ClearStyle(cell.ColorYellow, cell.ColorNavy))
    if err != nil {
        return fmt.Errorf("tcell.New =&gt; %v", err)
    }
    defer terminalLayer.Close()
leftContainer := container.Left(
container.Border(linestyle.Light),
)
rightContainer :=
container.Right(
container.SplitHorizontal(
container.Top(
container.Border(linestyle.Light),
),
container.Bottom(
container.SplitVertical(
     container.Left(
     container.Border(linestyle.Light),
     ),
     container.Right(
     container.Border(linestyle.Light),
     ),
     ),
      ),
    )
)
containerLayer, err := container.New(
terminalLayer,
container.SplitVertical(
leftContainer,
rightContainer,
container.SplitPercent(60),
),
)</pre>
			<p>Notice<a id="_idIndexMarker661"/> how we drill down when splitting up th<a id="_idTextAnchor239"/>e terminal into containers. First, we split vertically to divide the terminal into left and right portions. Then, we split the right portion horizontally. The bottom-right horizontally split portion is split vertically. Running this code will present the <span class="No-Break">following dashboard:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_10.1_B18883.jpg" alt="Figure 10.1 – Dashboard showing a container split using the binary layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Dashboard showing a container split using the binary layout</p>
			<p>Notice that the<a id="_idIndexMarker662"/> container to the left takes up about 60% percent of the full width. The other splits do not define a percentage and take up 50% of <span class="No-Break">the container.</span></p>
			<p>The other option for a dashboard is to <a id="_idIndexMarker663"/>use a <strong class="bold">grid layout</strong>, which organizes the layout into rows and columns. Unlike the binary tree layout, the grid layout requires a grid builder object. Rows, columns, or widgets are then added to the grid <span class="No-Break">builder object.</span></p>
			<p>Columns are defined using either the <strong class="source-inline">grid.ColWidhPerc</strong> function, which defines a column with a specified width percentage of the parent’s width, or <strong class="source-inline">grid.ColWidthPercWithOpts</strong>, which is an alternative that allows developers to additionally specify options when representing <span class="No-Break">the column.</span></p>
			<p>Rows are defined using either the <strong class="source-inline">grid.RowHeightPerc</strong> function, which defines a row with a specified height percentage of the parent’s height, or <strong class="source-inline">grid.RowHeightPercWithOpts</strong>, which is an alternative that allows developers to additionally specify options when representing <span class="No-Break">the row.</span></p>
			<p>To add a widget within the grid layout, utilize the <strong class="source-inline">grid.Widget</strong> method. The following is a simple example<a id="_idIndexMarker664"/> of a layout implemented by the <strong class="source-inline">grid</strong> package. The code uses all th<a id="_idTextAnchor240"/>e related methods<a id="_idIndexMarker665"/> and adds an ellipses text widget within <span class="No-Break">each cell:</span></p>
			<pre class="source-code">
    t, err := tcell.New()
    if err != nil {
        return fmt.Errorf("error creating tcell: %v", err)
    }
    rollingText, err := text.New(text.RollContent())
    if err != nil {
        return fmt.Errorf("error creating rolling text: %v", 
          err)
    }
    err = rollingText.Write("...")
    if err != nil {
        return fmt.Errorf("error writing text: %v", err)
    }
    builder := grid.New()
    builder.Add(
        grid.ColWidthPerc(60,
            grid.Widget(rollingText,
                container.Border(linestyle.Light),
            ),
        ),
    )
    builder.Add(
        grid.RowHeightPerc(50,
            grid.Widget(rollingText,
                container.Border(linestyle.Light),
            ),
        ),
    )
    builder.Add(
        grid.ColWidthPerc(20,
            grid.Widget(rollingText,
                container.Border(linestyle.Light),
            ),
        ),
    )
    builder.Add(
        grid.ColWidthPerc(20,
            grid.Widget(rollingText,
                container.Border(linestyle.Light),
            ),
        ),
    )
    gridOpts, err := builder.Build()
    if err != nil {
        return fmt.Errorf("error creating builder: %v", err)
    }
    c, err := container.New(t, gridOpts...)</pre>
			<p>Running the code generates the <span class="No-Break">following dashboard:</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_10.2_B18883.jpg" alt="Figure 10.2 – Dashboard showing the container created using the grid layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Dashboard showing the container created using the grid layout</p>
			<p>Notice <a id="_idIndexMarker666"/>that the <a id="_idIndexMarker667"/>column width percentage equals 100%; anything more would cause a <span class="No-Break">compilation error.</span></p>
			<p>There is also the option of a dynamic layout that allows you to switch between different layouts on the dashboard. Using the <strong class="source-inline">container.ID</strong> option, you can identify a container with some text, which can be referenced later so there’s a way to identify which container will be dynamically updated using the <span class="No-Break"><strong class="source-inline">container.Update</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
    t, err := tcell.New()
    if err != nil {
        return fmt.Errorf("error creating tcell: %v", err)
    }
    defer t.Close()
    b1, err := button.New("button1", func() error {
        return nil
    })
    if err != nil {
        return fmt.Errorf("error creating button: %v", err)
    }
    b2, err := button.New("button2", func() error {
        return nil
    })
    if err != nil {
        return fmt.Errorf("error creating button: %v", err)
    }
    c, err := container.New(
        t,
        container.PlaceWidget(b1),
        container.ID("123"),
    )
    if err != nil {
        return fmt.Errorf("error creating container: %v", err)
    }
    update := func(k *terminalapi.Keyboard) {
        if k.Key == 'u' || k.Key == 'U' {
            c.Update(
                "123",
                container.SplitVertical(
                    container.Left(
                        container.PlaceWidget(b1),
                    ),
                    container.Right(
                        container.PlaceWidget(b2),
                    ),
                ),
            )
        }
    }
    ctx, cancel := context.WithTimeout(context.Background(), 
      5*time.Second)
    defer cancel()
    if err := termdash.Run(ctx, t, c, termdash.
       KeyboardSubscriber(update)); err != nil {
        return fmt.Errorf("error running termdash: %v", err)
    }</pre>
			<p>In this code, the<a id="_idIndexMarker668"/> container ID is se<a id="_idTextAnchor241"/>t to <strong class="source-inline">123</strong>. Originally, the widget contained <a id="_idIndexMarker669"/>just one button. The <strong class="source-inline">update</strong> method replaces the single button with a container split vertically, with one button on the left and another on the right. When running this code, pressing the <em class="italic">u</em> key runs the update on <span class="No-Break">the layout.</span></p>
			<p>The original layout shows a <span class="No-Break">single button:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_10.3_B18883.jpg" alt="Figure 10.3 – Layout showing a single button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Layout showing a single button</p>
			<p>After pressing the <em class="italic">u</em> or <em class="italic">U</em> key, the <span class="No-Break">layout updates:</span><a id="_idTextAnchor242"/></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_10.4_B18883.jpg" alt="Figure 10.4 – Layout showing two buttons after pressing the u key again"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Layout showing two buttons after pressing the u key again</p>
			<p>The container layer can be further configured using margin and padding settings. The <a id="_idIndexMarker670"/>margin is the space outside of the container’s border while the padding is the space between the inside of the container’s border and its content. The following image provides the best visual representation of margins <span class="No-Break">and padding:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_10.5_B18883.jpg" alt="Figure 10.5 – Margin and padding"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Margin and padding</p>
			<p>The margin and padding can be set with either absolute or relative values. An<a id="_idIndexMarker671"/> absolute margin can be set with the <span class="No-Break">following options:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">container.MarginTop</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.MarginRight</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.MarginBottom</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.MarginLeft</strong></span></li>
			</ul>
			<p>Absolute padding can be set with the <span class="No-Break">following options:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingTop</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingRight</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingBottom</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingLeft</strong></span></li>
			</ul>
			<p>Relative values for the margin and padding are set with percentages. The margin and padding’s top and bottom percentage<a id="_idIndexMarker672"/> values are relative to the <span class="No-Break">container’s height:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">container.MarginTopPercent</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.MarginBottomPercent</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingTopPercent</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingBottomPercent</strong></span></li>
			</ul>
			<p>The margin and padding’s right and left percentage values are relative to the <span class="No-Break">container’s width:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">container.MarginRightPercent</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.MarginLeftPercent</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingRightPercent</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PaddingLeftPercent</strong></span></li>
			</ul>
			<p>Another form of placement within containers is alignment. The following methods are available from the align API to align content within <span class="No-Break">the container:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">container.AlignHorizontal</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.AlignVertical</strong></span></li>
			</ul>
			<p>Let’s put it all together in a simple example that extends upon the binary tree <span class="No-Break">code example:</span></p>
			<pre class="source-code">
b, err := button.New("click me", func() error {
    return nil
})
if err != nil {
    return err
}
leftContainer :=
container.Left(
     container.Border(linestyle.Light),
           container.PlaceWidget(b),
           container.AlignHorizontal(align.HorizontalLeft),
     )
rightContainer :=
         container.Right(
             container.SplitHorizontal(
                 container.Top(
                    container.Border(linestyle.Light),
                    container.PlaceWidget(b),
                    container.AlignVertical(align.VerticalTop),
                 ),
                 container.Bottom(
                   container.SplitVertical(
                        container.Left(
                          container.Border(linestyle.Light),
                               container.PlaceWidget(b),
                               container.PaddingTop(3),
                               container.PaddingBottom(3),
                               container.PaddingRight(3),
                               container.PaddingLeft(3),
                         ),
                         container.Right(
                           container.Border(linestyle.Light),
                             container.PlaceWidget(b),
                             container.MarginTop(3),
                             container.MarginBottom(3),
                             container.MarginRight(3),
                             container.MarginLeft(3),
                        ),
                    ),
                ),
           ),
                )
containerLayer, err := container.New(
        terminalLayer,
        container.SplitVertical(
            leftContainer,
            rightContainer,
            container.SplitPercent(60),
        ),
    )</pre>
			<p>The resulting layout appears <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_10.6_B18883.jpg" alt="Figure 10.6 – Container showing different alignments for a button, with different margins and padding"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Container showing different alignments for a button, with different margins and padding</p>
			<p>You can<a id="_idIndexMarker673"/> also define a key to change the focus to the next or previous container using the <strong class="source-inline">container.KeyFocusNext</strong> and <span class="No-Break"><strong class="source-inline">container.KeyFocusPrevious</strong></span><span class="No-Break"> options.</span></p>
			<h3>The widget layer</h3>
			<p>In <a id="_idIndexMarker674"/>several of<a id="_idIndexMarker675"/> the previous examples, we showed code that placed a widget in either a grid or binary tree container layout and also customized the alignment, margin, and padding. However, besides a simple button or text, there are different widget options, and the demo on the GitHub page shows an example <span class="No-Break">of each:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_10.7_B18883.jpg" alt="Figure 10.7 – Termdash sample screenshot showing all the widgets in a dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Termdash sample screenshot showing all the widgets in a dashboard</p>
			<p>Let’s do<a id="_idIndexMarker676"/> a quick example of each with a snippet of code to understand how each widget is created. To add each widget to a container, just use the <strong class="source-inline">container.PlaceWidget</strong> method that was used earlier for the simple text and button examples. Let’s go over a few other examples: a bar chart, donut, and gauge. For a detailed code of the other widgets, visit the very well-documented termdash wiki and check out the <span class="No-Break">demo pages.</span></p>
			<h4>A bar chart</h4>
			<p>Here is<a id="_idIndexMarker677"/> some example code for creating a bar chart widget with individual values displayed relative to a <span class="No-Break"><strong class="source-inline">max</strong></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
    barChart, err := barchart.New()
    if err != nil {
        return err
    }
    values := []int{20, 40, 60, 80, 100}
    max := 100
    if err := barChart.Values(values, max); err != nil {
        return err
    }</pre>
			<p>The preceding code creates a new <strong class="source-inline">barchart</strong> instance and adds the values, a slice of <strong class="source-inline">int</strong>, plus the maximum <strong class="source-inline">int</strong> value. The resulting terminal dashboard looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_10.8_B18883.jpg" alt="Figure 10.8 – Bar chart example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Bar chart example</p>
			<p>Change the <a id="_idIndexMarker678"/>values of the <strong class="source-inline">values</strong> and <strong class="source-inline">max</strong> variables to see the chart change. The color of the bars can also be modified based <span class="No-Break">on preference.</span></p>
			<h4>A donut</h4>
			<p>A donut, or<a id="_idIndexMarker679"/> progress circle chart, represents the completion of progress. Here is some example code for creating a donut chart to <span class="No-Break">show percentages:</span></p>
			<pre class="source-code">
    greenDonut, err := donut.New(
        donut.CellOpts(cell.FgColor(cell.ColorGreen)),
        donut.Label("Green", cell.FgColor(cell.ColorGreen)),
    )
    if err != nil {
        return err
    }
    greenDonut.Percent(75)</pre>
			<p>The preceding<a id="_idIndexMarker680"/> code creates a new <strong class="source-inline">donut</strong> instance with options for the label and foreground color set to green. The resulting terminal dashboard looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_10.9_B18883.jpg" alt="Figure 10.9 – Green donut at 75%"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Green donut at 75%</p>
			<p>Again, the color can be modified based on preference, and remember, since Termdash provides dynamic refreshing, the data can be automatically updated and redrawn, making it quite nice for <span class="No-Break">showing progress.</span></p>
			<h4>A gauge</h4>
			<p>A gauge, or <a id="_idIndexMarker681"/>progress bar, is another way to measure the amount completed. The following is some sample code for showing how to create a <span class="No-Break">progress gauge:</span></p>
			<pre class="source-code">
    progressGauge, err := gauge.New(
        gauge.Height(1),
        gauge.Border(linestyle.Light),
        gauge.BorderTitle("Percentage progress"),
    )
    if err != nil {
        return err
    }
    progressGauge.Percent(75)</pre>
			<p>This code creates <a id="_idIndexMarker682"/>a new instance of a gauge with options for a light border, a title, <strong class="bold">Percentage progress</strong>, and a slim height of <strong class="source-inline">1</strong>. The percentage, as with the donut, is 75%. The resulting terminal dashboard looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_10.10_B18883.jpg" alt="Figure 10.10 – Gauge at 75% percent progress"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Gauge at 75% percent progress</p>
			<p>As mentioned before, because of dynamic redrawing, this is another great option for showing <span class="No-Break">progress updates.</span></p>
			<p>Now that we’ve shown examples of different widgets to include within a terminal dashboard, let’s sketch out a design using these widgets that we can later implement in our audio file command-line interface. Suppose we wanted to build a music player in a terminal dashboard. Here is a <span class="No-Break">sample layout:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_10.11_B18883.jpg" alt="Figure 10.11 – Terminal dashboard layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Terminal dashboard layout</p>
			<p>This<a id="_idIndexMarker683"/> layout can be created easily with the binary layout. The music library list section can be generated from a list of songs with number identifiers, which can be used in the text input section, where a song can be selected by ID. Any error messages associated with the input ID will be displayed right below. If the input is good, the selected song section will show rolling ASCII text with the song title, and the metadata section will display the text metadata of the selected song. Hitting the play button will start playing the selected song, and the stop button will stop it. Proceed to the next section where we’ll make this terminal dashboard <span class="No-Break">a reality.</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor243"/>Implementing a terminal dashboard</h1>
			<p>When <a id="_idIndexMarker684"/>creating a terminal dashboard, you can create it as a separate standalone application or as a command that is called from the command-line application. In our specific example for the player terminal dashboard, we a<a id="_idTextAnchor244"/>re going to call the dashboard when the <strong class="source-inline">./bin/audiofile player</strong> command <span class="No-Break">is called.</span></p>
			<p>First, from the audio file’s root repository, we’ll need to use <strong class="source-inline">cobra-cli</strong> to create <span class="No-Break">the command:</span></p>
			<pre class="console">
cobra-cli add player
Player created at /Users/mmontagnino/Code/src/github.com/marianina8/audiofile</pre>
			<p>Now, we can create the code to generate the terminal dashboard, called within the <strong class="source-inline">Run</strong> field of the <strong class="source-inline">player</strong> command. Remember <a id="_idIndexMarker685"/>that the terminal dashboard consists of four main layers: the terminal, infrastructure, container, and widgets. Like a painting, we’ll start with the base layer: <span class="No-Break">the terminal.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor245"/>Creating the terminal layer</h2>
			<p>The first <a id="_idIndexMarker686"/>thing you need to do is to create a terminal that provides access to any input and output. Termdash has a <strong class="source-inline">tcell</strong> package for creating a new <strong class="source-inline">tcell</strong>-based terminal. Many terminals by default only support 16 colors, but other more modern terminals can support up to 256 colors. The following code specifically creates a new terminal with a <span class="No-Break">265-color mode.</span></p>
			<pre class="source-code">
t, err := tcell.New(tcell.ColorMode(terminalapi.ColorMode256))</pre>
			<p>After creating a terminal layer, we then create the <span class="No-Break">infrastructure layer.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor246"/>Creating the infrastructure layer</h2>
			<p>The<a id="_idIndexMarker687"/> infrastructure layer handles the terminal setup, mouse and keyboard events, and containers. In our terminal dashboard player, we want to handle a <span class="No-Break">few tasks:</span></p>
			<ul>
				<li>Keyboard event to <span class="No-Break">signal quitting</span></li>
				<li>Running the terminal dashboard, which subscribes to this <span class="No-Break">keyboard event</span></li>
			</ul>
			<p>Let’s write the code to handle these two features required of the <span class="No-Break">terminal dashboard.</span></p>
			<h3>Subscribing to keyboard events</h3>
			<p>If we <a id="_idIndexMarker688"/>want to listen for key events, we create a keyboard subscriber to specify the keys to <span class="No-Break">listen to:</span></p>
			<pre class="source-code">
quitter := func(k *terminalapi.Keyboard) {
    if k.Key == 'q' || k.Key == 'Q' {
        ...
    }
}</pre>
			<p>Now that we have <a id="_idIndexMarker689"/>defined a keyboard subscriber, we can use this as an input parameter to termdash’s <span class="No-Break"><strong class="source-inline">Run</strong></span><span class="No-Break"> method.</span></p>
			<h3>Running the terminal</h3>
			<p>When <a id="_idIndexMarker690"/>running the terminal, you’ll need the terminal variable, container, and keyboard and mouse subscribers, as well as the timed redrawing interval and other options. The following code runs the <strong class="source-inline">tcell</strong>-based terminal we created and the <strong class="source-inline">quitter</strong> keyboard subscriber, which listens for <em class="italic">q</em> or <em class="italic">Q</em> key events to quit <span class="No-Break">the application:</span></p>
			<pre class="source-code">
if err := termdash.Run(ctx, t, c, termdash.KeyboardSubscriber(quitter), termdash.RedrawInterval(100*time.Millisecond)); err != nil {
    panic(err)
}</pre>
			<p>The <strong class="source-inline">c</strong> variable that’s passed into the <strong class="source-inline">termdash.Run</strong> method as the third parameter is the container. Let’s define the <span class="No-Break">container now.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor247"/>Creating the container layer</h2>
			<p>When <a id="_idIndexMarker691"/>creating the container, it helps to look at the bigger picture of the layout and then narrow it down as you go. For example, when you first look at the planned layout, you’ll see the largest sections are made from left and right <span class="No-Break">vertical splits.</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_10.12_B18883.jpg" alt="Figure 10.12 – Initial vertical split"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Initial vertical split</p>
			<p>As we <a id="_idIndexMarker692"/>begin to define the container, we’ll slowly drill down with more specifics, but we begin with <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Vertical Split (Left)</strong> – The <span class="No-Break">music library</span></li>
				<li><strong class="bold">Vertical Split (Right)</strong> – All <span class="No-Break">other widget</span></li>
			</ul>
			<p>The final code reflects this drill-down process. Since we keep the left vertical split as the music library, we drill down with containers on the left, always starting with the larger containers and adding smaller <span class="No-Break">ones within.</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_10.13_B18883.jpg" alt="Figure 10.13 – Horizontal split of right vertical space"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Horizontal split of right vertical space</p>
			<p>The next is a <a id="_idIndexMarker693"/>horizontal split that separates the left vertical split into <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Horizontal Split (Top) 30%</strong> – Text input, error messages, and the rolling song <span class="No-Break">title text</span></li>
				<li><strong class="bold">Horizontal Split (Bottom) 70%</strong> – Metadata and <span class="No-Break">play/stop buttons</span></li>
			</ul>
			<p>Let’s take the top horizontal split and split it, <span class="No-Break">again, horizontally:</span></p>
			<ul>
				<li><strong class="bold">Horizontal Split (Top) 30%</strong> – Text input and <span class="No-Break">error message</span></li>
				<li><strong class="bold">Horizontal Split (Bottom) 70%</strong> – The rolling song <span class="No-Break">title text</span></li>
			</ul>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_10.14_B18883.jpg" alt="Figure 10.14 – Horizont﻿al split of ﻿top horizontal space"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Horizont<a id="_idTextAnchor248"/>al split of <a id="_idTextAnchor249"/>top horizontal space</p>
			<p>We split the <a id="_idIndexMarker694"/>earlier top part horizontally into the separated text input and <span class="No-Break">error messages:</span></p>
			<ul>
				<li><strong class="bold">Horizontal <a id="_idTextAnchor250"/>Split (Top) 60%</strong> – <span class="No-Break">Text input</span></li>
				<li><strong class="bold">Horizontal Split (Bottom) 40%</strong> – <span class="No-Break">Error messages</span></li>
			</ul>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_10.15_B18883.jpg" alt="Figure 10.15 – Horizontal split of top horizontal space"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Horizontal split of top horizontal space</p>
			<p>Now, let’s drill down into the bottom 70% of the initial horizontal split of the right vertical container. Let’s split it up into two <span class="No-Break">horizontal sections:</span></p>
			<ul>
				<li><strong class="bold">Horizontal Split (Top) 80%</strong> – The <span class="No-Break">metadata section</span></li>
				<li><strong class="bold">Horizontal Split (Bottom) 20%</strong> – The button <span class="No-Break">section (play/stop)</span></li>
			</ul>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_10.16_B18883.jpg" alt="Figure 10.16 – Horizontal split of bottom horizontal space"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Horizontal split of bottom horizontal space</p>
			<p>Finally, the last <a id="_idIndexMarker695"/>part to drill down to is the bottom horizontal split, which we will <span class="No-Break">split vertically:</span></p>
			<ul>
				<li><strong class="bold">Vertical Split (Left) 50%</strong> – The <span class="No-Break">play button</span></li>
				<li><strong class="bold">Vertical Split (Right) 50%</strong> – The <span class="No-Break">stop button</span></li>
			</ul>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_10.17_B18883.jpg" alt="Figure 10.17 – Vertical split of bottom horizontal space"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Vertical split of bottom horizontal space</p>
			<p>The entire<a id="_idIndexMarker696"/> layout broken down with the container code shows this drill-down process – I’ve added comments for where the widgets will be placed <span class="No-Break">for reference:</span></p>
			<pre class="source-code">
c, err := container.New(
    t,
    container.SplitVertical(
        container.Left(), // music library
        container.Right(
            container.SplitHorizontal(
                container.Top(
                    container.SplitHorizontal(
                        container.Top(
                            container.SplitHorizontal(
                                container.Top(), // text input
                                container.Bottom(), // error 
                                                    msgs
                                container.SplitPercent(60),
                            ),
                        ),
                        container.Bottom(), // rolling song 
                                            title
                        container.SplitPercent(30),
                    ),
                ),
                container.Bottom(
                    container.SplitHorizontal(
                        container.Top(), // metadata
                        container.Bottom(
                            container.SplitVertical(
                                container.Left(), // play 
                                                  button
                                container.Right(), // stop 
                                                   button
                            )
                        ),
                        container.SplitPercent(80),
                    ),
                ),
                container.SplitPercent(30),
            ),
        ),
    ),
)</pre>
			<p>Next, let’s <a id="_idIndexMarker697"/>create the widgets and place them within the appropriate containers to finalize the <span class="No-Break">terminal dashboard.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor251"/>Creating the widgets layer</h2>
			<p>Going<a id="_idIndexMarker698"/> back to the original layout, all the different <a id="_idIndexMarker699"/>widgets we’ll need to implement are clear <span class="No-Break">to see:</span></p>
			<ul>
				<li>The music <span class="No-Break">library list</span></li>
				<li><span class="No-Break">Input text</span></li>
				<li><span class="No-Break">Error messages</span></li>
				<li>Rolling text – selected song (title <span class="No-Break">by artist)</span></li>
				<li><span class="No-Break">Metadata</span></li>
				<li>The <span class="No-Break">play button</span></li>
				<li>The <span class="No-Break">stop button</span></li>
			</ul>
			<p>At this point, I am aware of which widget to use for each item on the list. However, if you have not yet decided, now is the time to determine the best Termdash widget to use for <span class="No-Break">each item:</span></p>
			<ul>
				<li><span class="No-Break">Text:</span><ul><li>Music <span class="No-Break">library list</span></li><li><span class="No-Break">Error messages</span></li><li>Rolling text – selected song (title by <span class="No-Break">artist), metadata</span></li></ul></li>
				<li><span class="No-Break">Text input:</span><ul><li><span class="No-Break">Input field</span></li></ul></li>
				<li><span class="No-Break">Button:</span><ul><li>The <span class="No-Break">play button</span></li><li>The <span class="No-Break">stop button</span></li></ul></li>
			</ul>
			<p>Let’s create at least <a id="_idIndexMarker700"/>one of each type as an example. The full code is available in the <strong class="source-inline">Chapter10</strong> <span class="No-Break">GitHub repository.</span></p>
			<h3>Creating a text widget for the music library list</h3>
			<p>The <a id="_idIndexMarker701"/>music library list will take in the audio list and print the text in a section that will list the index of the song next to the title and artist. We define this widget with the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func newLibraryContent(audioList *models.AudioList) (*text.Text, error) {
    libraryContent, err := text.New(text.RollContent(), text.
      WrapAtWords())
    if err != nil {
        panic(err)
    }
    for i, audiofile := range *audioList {
        libraryContent.Write(fmt.Sprintf("[id=%d] %s by %s\n", 
          i, audiofile.Metadata.Tags.Title, audiofile.Metadata.
          Tags.Artist))
    }
    return libraryContent, nil
}</pre>
			<p>The function is called in the <strong class="source-inline">Run</strong> function field <span class="No-Break">like so:</span></p>
			<pre class="source-code">
libraryContent, err := newLibraryContent(audioList)</pre>
			<p><a id="_idTextAnchor252"/>The error message and metadata items are also text widgets, so we’ll omit those code examples. Next, we’ll create the <span class="No-Break">input text.</span></p>
			<h3>Creating an input text widget for setting the current ID of a song</h3>
			<p>The<a id="_idIndexMarker702"/> input text section is where a user inputs the ID of the song displayed in the music library section. The input text is defined within the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func newTextInput(audioList *models.AudioList, updatedID chan&lt;- int, updateText, errorText chan&lt;- string) *textinput.TextInput {
    input, _ := textinput.New(
        textinput.Label("Enter id of song: ", cell.
          FgColor(cell.ColorNumber(33))),
        textinput.MaxWidthCells(20),
        textinput.OnSubmit(func(text string) error {
            // set the id
            // set any error text
        return nil
    }),
    textinput.ClearOnSubmit(),
    )
    return input
}</pre>
			<h3>Creating a button to start playing the song associated with the input ID</h3>
			<p>The last type of <a id="_idIndexMarker703"/>widget is a button. There are two different buttons we need, but the following code is for the <span class="No-Break">play button:</span></p>
			<pre class="source-code">
func newPlayButton(audioList *models.AudioList, playID &lt;-chan int) (*button.Button, error) {
    playButton, err := button.New("Play", func() error {
        stopTheMusic()
        }
        go func() {
        if audiofileID &lt;= len(*audioList)-1 &amp;&amp; audiofileID &gt;= 0 {
        pID, _ = play((*audioList)[audiofileID].Path, false, 
                     true)
        }}()
        return nil
    },
    button.FillColor(cell.ColorNumber(220)),
    button.GlobalKey('p'),
    )
    if err != nil {
        return playButton, fmt.Errorf("%v", err)
    }
    return playButton, nil
}</pre>
			<ul>
				<li>The function<a id="_idIndexMarker704"/> is called in the <strong class="source-inline">Run</strong> <span class="No-Break">function field:</span></li>
			</ul>
			<pre class="source-code">
playButton, err := newPlayButton(audioList, playID)</pre>
			<ul>
				<li>Once all the widgets have been created, they are placed within the container in the appropriate places with the following line <span class="No-Break">of code:</span></li>
			</ul>
			<pre class="source-code">
container.PlaceWidget(widget)</pre>
			<ul>
				<li>Once the widgets have been placed within the container, we can run the terminal dashboard with the <span class="No-Break">following command:</span></li>
			</ul>
			<pre class="source-code">
./bin/audiofile player</pre>
			<ul>
				<li>Magically, the<a id="_idIndexMarker705"/> player terminal dashboards appear and we can select an ID to enter and play <span class="No-Break">a song:</span></li>
			</ul>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_10.18_B18883.jpg" alt="Figure 10.18 – Audio file player terminal dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Audio file player terminal dashboard</p>
			<ul>
				<li>Voila! We’ve created a <a id="_idIndexMarker706"/>terminal dashboard to play the music in our audio file library. While you can view the metadata through the command-line application’s <strong class="source-inline">get</strong> and <strong class="source-inline">list</strong> commands and play music with the <strong class="source-inline">play</strong> command, the new player terminal dashboard allows you to view what exists in the audio file library in a more <span class="No-Break">user-friendly fashion.</span></li>
			</ul>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor253"/>Summary</h1>
			<p>In this chapter, you learned how to create a survey with different interactive prompts and a terminal dashboard containing a variety of widgets. These are just examples that can hopefully inspire you in terms of interactivity within your own <span class="No-Break">command-line application.</span></p>
			<p>The survey example showed you how to use a variety of different types of prompts; you can prompt the user for their user experience, but as you’ve seen within the audio file CLI, you can also just prompt for missing information. These prompts can be input throughout your code in places where prompts may come in handy, or they can be strung along a list of other questions and you can create a more thorough survey for <span class="No-Break">your users.</span></p>
			<p>The player terminal dashboard gives you an example of how to create a terminal dashboard for a command-line interface. Consider the kind of data your users will be sending or retrieving from your command-line interface and let that guide you in your design of a more <span class="No-Break">visual approach.</span></p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor254"/>Questions</h1>
			<ol>
				<li>What method is used to create the <span class="No-Break">terminal layer?</span></li>
				<li>What method is used to place a widget inside <span class="No-Break">a container?</span></li>
				<li>What’s the difference between the binary layout and the <span class="No-Break">grid layout?</span></li>
			</ol>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor255"/>Answers</h1>
			<ol>
				<li value="1"><span class="No-Break"><strong class="source-inline">tcell.New()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">container.PlaceWidget(widget)</strong></span></li>
				<li>The grid layout allows you to split the container into horizontal rows and vertical columns. The binary layout allows you to split sub-containers horizontally <span class="No-Break">or vertically.</span></li>
			</ol>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor256"/>Further reading</h1>
			<ul>
				<li><em class="italic">The Big Book of Dashboards: Visualizing Your Data Using Real-World Business Scenarios</em> by Wexler, Shaffer, <span class="No-Break">and Cotgreave</span></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer088" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer089" class="Content">
			<h1 id="_idParaDest-221"><a id="_idTextAnchor257"/>Part 4: Building and Distributing for Different Platforms</h1>
			<p>This part of the book is all about building, testing, and distributing your CLI application using Docker and GoReleaser. It starts by explaining the importance of building and testing, and how build tags with Boolean logic can be used to create targeted builds and testing to further stabilize your project with each new feature. The part also covers cross-compilation, a powerful feature of Go, which enables you to compile your application for different operating systems and architectures. The benefits of containerization are also explored, with a focus on Docker containers for testing and distributing your apps. Finally, we end with a discussion using GoReleaser and GitHub Actions in tandem to automate the release of a CLI application as a Homebrew formula, which makes it easy for MacOS users to find and install your software with just <span class="No-Break">one command.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18883_11.xhtml#_idTextAnchor258"><em class="italic">Chapter 11</em></a>, <em class="italic">Custom Builds and Testing CLI Commands</em></li>
				<li><a href="B18883_12.xhtml#_idTextAnchor291"><em class="italic">Chapter 12</em></a>, <em class="italic">Cross Compilation Across Different Platforms</em></li>
				<li><a href="B18883_13.xhtml#_idTextAnchor331"><em class="italic">Chapter 13</em></a>, <em class="italic">Using Containers for Distribution</em></li>
				<li><a href="B18883_14.xhtml#_idTextAnchor359"><em class="italic">Chapter 14</em></a>, <em class="italic">Publishing your Go binary as a Homebrew Formula with GoReleaser</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer090">
			</div>
		</div>
	</body></html>