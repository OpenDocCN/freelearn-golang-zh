- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interactivity with Prompts and Terminal Dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One powerful way to increase usability for users is to integrate interactivity
    with either prompts or terminal dashboards. Prompts are useful because they create
    a conversational approach while requesting input. Dashboards are useful because
    they allow developers to create a graphical interface from ASCII characters. That
    graphical interface, via a dashboard, can create powerful visual cues to allow
    users to navigate through different commands.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you examples of how to build user surveys from a series
    of prompts, and a terminal dashboard – whether learning about the Termdash library,
    designing the mockup, or implementing it for the audio file CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interactivity is fun. It’s the more human and empathetic approach to a command-line
    interface. However, remember to disable interactivity if you are not outputting
    to a terminal. This chapter will cover the basics of surveys and dive deep into
    the terminal dashboard. By the end of this chapter, you’ll have everything you
    need to create your own survey or dashboard. We will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Guiding users with prompts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a useful terminal dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a terminal dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll need a Unix operating system to understand and run the examples shared
    in the chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the `termdash` package at [https://github.com/mum4k/termdash](https://github.com/mum4k/termdash)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the survey package at [https://github.com/go-survey/survey](https://github.com/go-survey/survey)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guiding users with prompts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to simply prompt the user, but if you want to create a whole
    survey that can retrieve information using a variety of different prompts – text
    input, multi-select, single-select, multi-line text, password, and more – it might
    be useful to use a preexisting library to handle this for you. Let’s create a
    generic customer survey using the `survey` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show you how to use this package, I’ll create a survey that can prompt the
    user for different types of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text input** – for example, an email address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select** – for example, a user’s experience with the CLI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiselect** – for example, any issues encountered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiline** – for example, open-ended feedback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Chapter-10` repository, a survey has been written to handle these four
    prompts. The questions, stored in the `qs` variable, are defined as a slice of
    `*survey.Question`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll need an `answers` struct to store all the results from the prompts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the method that asks the questions and stores the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve created the survey, we can try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Prompting the user is an easy way to integrate interactivity into your command-line
    application. However, there are even more colorful and fun ways to interact with
    your users. In the next section, we’ll discuss the terminal dashboard, the `termdash`
    package in detail, and how to mock up and implement a terminal dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a useful terminal dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-line interfaces don’t have to be limited to text. With **termdash**,
    a popular Golang library, you can build a terminal dashboard providing users with
    a user interface to visually see progress, alerts, text, and more. Colorful widgets
    placed within a clean dashboard that’s been neatly laid out can increase information
    density and present a lot of information to the user in a very user-friendly manner.
    In this section, we’ll learn about the library and the different layout choices
    and widget options. At the end of the chapter, we’ll design a terminal dashboard
    that we can implement in our **audio file** command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Termdash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Termdash is a Golang library that provides a customizable and cross-platform,
    terminal-based dashboard. On the project’s GitHub page, a fun and colorful demo
    provides an example of all possible widgets demonstrated within a dynamic layout.
    From the demo, you can see that you can go all out on a fancy dashboard. To do
    so, you’ll need to understand how to lay out a dashboard, interact with keyboard
    and mouse events, add widgets, and fine-tune the appearance with alignment and
    color. Within this section, we will break down the layers of a Termdash interface
    and the widgets that can be organized within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Termdash dashboard consists of four main layers:'
  prefs: []
  type: TYPE_NORMAL
- en: The terminal layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The infrastructure layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The widgets layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a deep dive into each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The terminal layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think of the terminal layer of a dashboard as a 2D grid of cells that exist
    within a buffer. Each cell contains either an ASCII or Unicode character with
    the option to customize the foreground color, the color of text, the background
    color, or the color of the non-character space within the cell. Interactions with
    the mouse and keyboard happen on this layer as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two terminal libraries can be used to interact at the cell level of a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tcell**: Inspired by **termbox** and has many new improvements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**termbox**: No longer supported, although it is still an option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following examples will utilize the `tcell` package to interact with the
    terminal. To start, create a new `tcell` instance to interact via the terminal
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in this example, `tcell` has two methods: `New` and `Close`. `New`
    creates a new `tcell` instance in order to interact with the terminal and `Close`
    closes the terminal. It’s a good practice to defer closing access to `tcell` right
    after creation. Although there are no options passed into the `New` method, there
    are a few optional methods that can be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ColorMode` sets the color mode when initializing a terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClearStyle` sets the foreground and background color when a terminal is cleared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of initializing a cell in `ColorMode` to access all 256 available
    terminal colors would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`ClearStyle`, by default, will use `ColorDefault` if no specific `ClearStyle`
    is set. This `ColorDefault` is usually the default foreground and background colors
    of the terminal emulator, which are typically black and white. To set a terminal
    to use a yellow foreground and navy background style when the terminal is cleared,
    the `New` method, which accepts a slice of options, would be modified in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve created a new `tcell` that gives us access to the Terminal API,
    let’s discuss the next layer – infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The infrastructure of a terminal dashboard provides the organization of the
    structure. The three main elements of the infrastructure layer include alignment,
    line style, and Termdash.
  prefs: []
  type: TYPE_NORMAL
- en: Alignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Alignment is provided by the `align` package, which provides two alignment options
    – `align.Horizonal`, which includes predefined values of `left`, `center`, and
    `right` and `align.Vertical` with predefined values of `top`, `middle`, and `bottom`.
  prefs: []
  type: TYPE_NORMAL
- en: Line style
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The line style defines the style of the line drawn on the terminal either when
    drawing boxes or borders.
  prefs: []
  type: TYPE_NORMAL
- en: The package exposes the options available via `LineStyle`. The `LineStyle` type
    represents a style that follows the Unicode options.
  prefs: []
  type: TYPE_NORMAL
- en: Termdash
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Termdash provides the developer with the main entry point. Its most important
    purpose is to start and stop the dashboard application, control screen refreshing,
    process any runtime errors, and subscribe and listen for keyboard and mouse events.
    The `termdash.Run` method is the simplest way to start a Termdash application.
    The terminal may run until the context expires, a keyboard shortcut is called,
    or it times out. The simplest way to get started with the dashboard is with the
    following minimal code example, which creates a new `tcell` for the terminal layer,
    and a new `termdash` package, which we will dive into in the next section. We
    create context with a 2-minute timeout and then call the `Run` method of the `termdash`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, the dashboard will run until the context expires,
    in 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Screen redrawing, or refreshing, for your Terminal dashboard can be done in
    a few ways: periodic, time-based redraws or manually triggered redraws. Only one
    method may be used, as using one means the other method is ignored. Besides that,
    the screen will refresh each time an input event occurs. The `termdash.RedrawInterval`
    method is an option that can be passed into the `Run` method to tell the dashboard
    application to redraw, or refresh, the screen at a particular interval. The `Run`
    method can be modified with the option to refresh every 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The dashboard may also be redrawn using a controller, which can be triggered
    manually. This option means that the dashboard is drawn only once and unlike the
    `Run` method, the user maintains control of the main goroutine. An example of
    this code, using the previously defined `tcell` and `container` variables defined
    earlier, can be passed into a new controller to be drawn manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Termdash API provides a `termdash.ErrorHandler` option, which tells the
    dashboard how to handle errors gracefully. Without providing an implementation
    for this error handler, the dashboard will panic on all runtime errors. Errors
    can occur when processing or retrieving events, subscribing to an event, or when
    a container fails to draw itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'An error handler is a callback method that receives an error and handles the
    error appropriately. It can be defined as a variable and, in the simplest case,
    just prints the runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When starting a Termdash application using the `Run` or `NewController` method,
    the error handler may be passed in as an option using the `termdash.ErrorHandler`
    method. For example, the `Run` method can be modified with a new option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `NewController` method can be modified similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Through the `termdash` package, you can also subscribe to keyboard and mouse
    events. Typically, the container and certain widgets subscribe to keyboard and
    mouse events. Developers can also subscribe to certain mouse and keyboard events
    to take global action. For example, a developer may want the terminal to run a
    specific function when a specific key is set. `termdash.KeyboardSubscriber` is
    used to implement this functionality. With the following code, the user subscribes
    to the letters `q` and `Q` and responds to the keyboard events by running code
    to quit the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to call the `Run` method with the option to listen to mouse
    events using `termdash.MouseSubscriber`. Similarly, the following code can be
    called to do something random when the mouse button is clicked within the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The container layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The container layer provides options for dashboard layouts, container styles,
    keyboard focus, and margin and padding. It also provides a method for placing
    a widget within a container.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous examples, we see that a new container is called using the
    `container.New` function. We’ll provide some new examples of how to organize your
    container and set it up with different layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main layout options:'
  prefs: []
  type: TYPE_NORMAL
- en: Binary tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grid layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **binary tree layout** organizes containers in a binary tree structure
    where each container is a node in a tree, which, unless empty, may contain either
    two sub-containers or a widget. Sub-containers can be split further with the same
    rules. There are two kinds of splits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.SplitHorizontal` method, will create top and bottom sub-containers
    specified by `container.Top` and `container.Bottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.SplitVertical` method, will create left and right sub-containers,
    specified by `container.Left` and `container.Right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `container.SplitPercent` option specifies the percentage of container split
    to use when spitting either vertically or horizontally. When the split percentage
    is not specified, a default of 50% is used. The following is a simple example
    of a binary tree layout using all the methods described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we drill down when splitting up the terminal into containers. First,
    we split vertically to divide the terminal into left and right portions. Then,
    we split the right portion horizontally. The bottom-right horizontally split portion
    is split vertically. Running this code will present the following dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Dashboard showing a container split using the binary layout](img/Figure_10.1_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Dashboard showing a container split using the binary layout
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the container to the left takes up about 60% percent of the full
    width. The other splits do not define a percentage and take up 50% of the container.
  prefs: []
  type: TYPE_NORMAL
- en: The other option for a dashboard is to use a **grid layout**, which organizes
    the layout into rows and columns. Unlike the binary tree layout, the grid layout
    requires a grid builder object. Rows, columns, or widgets are then added to the
    grid builder object.
  prefs: []
  type: TYPE_NORMAL
- en: Columns are defined using either the `grid.ColWidhPerc` function, which defines
    a column with a specified width percentage of the parent’s width, or `grid.ColWidthPercWithOpts`,
    which is an alternative that allows developers to additionally specify options
    when representing the column.
  prefs: []
  type: TYPE_NORMAL
- en: Rows are defined using either the `grid.RowHeightPerc` function, which defines
    a row with a specified height percentage of the parent’s height, or `grid.RowHeightPercWithOpts`,
    which is an alternative that allows developers to additionally specify options
    when representing the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a widget within the grid layout, utilize the `grid.Widget` method. The
    following is a simple example of a layout implemented by the `grid` package. The
    code uses all the related methods and adds an ellipses text widget within each
    cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code generates the following dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Dashboard showing the container created using the grid layout](img/Figure_10.2_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Dashboard showing the container created using the grid layout
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the column width percentage equals 100%; anything more would cause
    a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also the option of a dynamic layout that allows you to switch between
    different layouts on the dashboard. Using the `container.ID` option, you can identify
    a container with some text, which can be referenced later so there’s a way to
    identify which container will be dynamically updated using the `container.Update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the container ID is set to `123`. Originally, the widget contained
    just one button. The `update` method replaces the single button with a container
    split vertically, with one button on the left and another on the right. When running
    this code, pressing the *u* key runs the update on the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original layout shows a single button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Layout showing a single button](img/Figure_10.3_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Layout showing a single button
  prefs: []
  type: TYPE_NORMAL
- en: 'After pressing the *u* or *U* key, the layout updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Layout showing two buttons after pressing the u key again](img/Figure_10.4_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Layout showing two buttons after pressing the u key again
  prefs: []
  type: TYPE_NORMAL
- en: 'The container layer can be further configured using margin and padding settings.
    The margin is the space outside of the container’s border while the padding is
    the space between the inside of the container’s border and its content. The following
    image provides the best visual representation of margins and padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Margin and padding](img/Figure_10.5_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Margin and padding
  prefs: []
  type: TYPE_NORMAL
- en: 'The margin and padding can be set with either absolute or relative values.
    An absolute margin can be set with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.MarginTop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.MarginRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.MarginBottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.MarginLeft`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Absolute padding can be set with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.PaddingTop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.PaddingRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.PaddingBottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.PaddingLeft`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relative values for the margin and padding are set with percentages. The margin
    and padding’s top and bottom percentage values are relative to the container’s
    height:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.MarginTopPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.MarginBottomPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.PaddingTopPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.PaddingBottomPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The margin and padding’s right and left percentage values are relative to the
    container’s width:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.MarginRightPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.MarginLeftPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.PaddingRightPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.PaddingLeftPercent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another form of placement within containers is alignment. The following methods
    are available from the align API to align content within the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.AlignHorizontal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.AlignVertical`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s put it all together in a simple example that extends upon the binary
    tree code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting layout appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Container showing different alignments for a button, with different
    margins and padding](img/Figure_10.6_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Container showing different alignments for a button, with different
    margins and padding
  prefs: []
  type: TYPE_NORMAL
- en: You can also define a key to change the focus to the next or previous container
    using the `container.KeyFocusNext` and `container.KeyFocusPrevious` options.
  prefs: []
  type: TYPE_NORMAL
- en: The widget layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In several of the previous examples, we showed code that placed a widget in
    either a grid or binary tree container layout and also customized the alignment,
    margin, and padding. However, besides a simple button or text, there are different
    widget options, and the demo on the GitHub page shows an example of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Termdash sample screenshot showing all the widgets in a dashboard](img/Figure_10.7_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Termdash sample screenshot showing all the widgets in a dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do a quick example of each with a snippet of code to understand how each
    widget is created. To add each widget to a container, just use the `container.PlaceWidget`
    method that was used earlier for the simple text and button examples. Let’s go
    over a few other examples: a bar chart, donut, and gauge. For a detailed code
    of the other widgets, visit the very well-documented termdash wiki and check out
    the demo pages.'
  prefs: []
  type: TYPE_NORMAL
- en: A bar chart
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is some example code for creating a bar chart widget with individual values
    displayed relative to a `max` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a new `barchart` instance and adds the values, a
    slice of `int`, plus the maximum `int` value. The resulting terminal dashboard
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Bar chart example](img/Figure_10.8_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Bar chart example
  prefs: []
  type: TYPE_NORMAL
- en: Change the values of the `values` and `max` variables to see the chart change.
    The color of the bars can also be modified based on preference.
  prefs: []
  type: TYPE_NORMAL
- en: A donut
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A donut, or progress circle chart, represents the completion of progress. Here
    is some example code for creating a donut chart to show percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a new `donut` instance with options for the label
    and foreground color set to green. The resulting terminal dashboard looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Green donut at 75%](img/Figure_10.9_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Green donut at 75%
  prefs: []
  type: TYPE_NORMAL
- en: Again, the color can be modified based on preference, and remember, since Termdash
    provides dynamic refreshing, the data can be automatically updated and redrawn,
    making it quite nice for showing progress.
  prefs: []
  type: TYPE_NORMAL
- en: A gauge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A gauge, or progress bar, is another way to measure the amount completed. The
    following is some sample code for showing how to create a progress gauge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a new instance of a gauge with options for a light border,
    a title, `1`. The percentage, as with the donut, is 75%. The resulting terminal
    dashboard looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Gauge at 75% percent progress](img/Figure_10.10_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Gauge at 75% percent progress
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, because of dynamic redrawing, this is another great option
    for showing progress updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve shown examples of different widgets to include within a terminal
    dashboard, let’s sketch out a design using these widgets that we can later implement
    in our audio file command-line interface. Suppose we wanted to build a music player
    in a terminal dashboard. Here is a sample layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Terminal dashboard layout](img/Figure_10.11_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Terminal dashboard layout
  prefs: []
  type: TYPE_NORMAL
- en: This layout can be created easily with the binary layout. The music library
    list section can be generated from a list of songs with number identifiers, which
    can be used in the text input section, where a song can be selected by ID. Any
    error messages associated with the input ID will be displayed right below. If
    the input is good, the selected song section will show rolling ASCII text with
    the song title, and the metadata section will display the text metadata of the
    selected song. Hitting the play button will start playing the selected song, and
    the stop button will stop it. Proceed to the next section where we’ll make this
    terminal dashboard a reality.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a terminal dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a terminal dashboard, you can create it as a separate standalone
    application or as a command that is called from the command-line application.
    In our specific example for the player terminal dashboard, we are going to call
    the dashboard when the `./bin/audiofile player` command is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, from the audio file’s root repository, we’ll need to use `cobra-cli`
    to create the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create the code to generate the terminal dashboard, called within
    the `Run` field of the `player` command. Remember that the terminal dashboard
    consists of four main layers: the terminal, infrastructure, container, and widgets.
    Like a painting, we’ll start with the base layer: the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the terminal layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you need to do is to create a terminal that provides access
    to any input and output. Termdash has a `tcell` package for creating a new `tcell`-based
    terminal. Many terminals by default only support 16 colors, but other more modern
    terminals can support up to 256 colors. The following code specifically creates
    a new terminal with a 265-color mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After creating a terminal layer, we then create the infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the infrastructure layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The infrastructure layer handles the terminal setup, mouse and keyboard events,
    and containers. In our terminal dashboard player, we want to handle a few tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard event to signal quitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the terminal dashboard, which subscribes to this keyboard event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s write the code to handle these two features required of the terminal dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to keyboard events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to listen for key events, we create a keyboard subscriber to specify
    the keys to listen to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined a keyboard subscriber, we can use this as an input
    parameter to termdash’s `Run` method.
  prefs: []
  type: TYPE_NORMAL
- en: Running the terminal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When running the terminal, you’ll need the terminal variable, container, and
    keyboard and mouse subscribers, as well as the timed redrawing interval and other
    options. The following code runs the `tcell`-based terminal we created and the
    `quitter` keyboard subscriber, which listens for *q* or *Q* key events to quit
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `c` variable that’s passed into the `termdash.Run` method as the third parameter
    is the container. Let’s define the container now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the container layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating the container, it helps to look at the bigger picture of the layout
    and then narrow it down as you go. For example, when you first look at the planned
    layout, you’ll see the largest sections are made from left and right vertical
    splits.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Initial vertical split](img/Figure_10.12_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Initial vertical split
  prefs: []
  type: TYPE_NORMAL
- en: 'As we begin to define the container, we’ll slowly drill down with more specifics,
    but we begin with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical Split (Left)** – The music library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertical Split (Right)** – All other widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final code reflects this drill-down process. Since we keep the left vertical
    split as the music library, we drill down with containers on the left, always
    starting with the larger containers and adding smaller ones within.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Horizontal split of right vertical space](img/Figure_10.13_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Horizontal split of right vertical space
  prefs: []
  type: TYPE_NORMAL
- en: 'The next is a horizontal split that separates the left vertical split into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal Split (Top) 30%** – Text input, error messages, and the rolling
    song title text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal Split (Bottom) 70%** – Metadata and play/stop buttons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take the top horizontal split and split it, again, horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal Split (Top) 30%** – Text input and error message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal Split (Bottom) 70%** – The rolling song title text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "![Figure 10.14 – Horizont\uFEFFal split of \uFEFFtop horizontal space](img/Figure_10.14_B18883.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Horizontal split of top horizontal space
  prefs: []
  type: TYPE_NORMAL
- en: 'We split the earlier top part horizontally into the separated text input and
    error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal Split (Top) 60%** – Text input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal Split (Bottom) 40%** – Error messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Horizontal split of top horizontal space](img/Figure_10.15_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Horizontal split of top horizontal space
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s drill down into the bottom 70% of the initial horizontal split of
    the right vertical container. Let’s split it up into two horizontal sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal Split (Top) 80%** – The metadata section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal Split (Bottom) 20%** – The button section (play/stop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Horizontal split of bottom horizontal space](img/Figure_10.16_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Horizontal split of bottom horizontal space
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last part to drill down to is the bottom horizontal split, which
    we will split vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical Split (Left) 50%** – The play button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertical Split (Right) 50%** – The stop button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Vertical split of bottom horizontal space](img/Figure_10.17_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Vertical split of bottom horizontal space
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire layout broken down with the container code shows this drill-down
    process – I’ve added comments for where the widgets will be placed for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s create the widgets and place them within the appropriate containers
    to finalize the terminal dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the widgets layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going back to the original layout, all the different widgets we’ll need to
    implement are clear to see:'
  prefs: []
  type: TYPE_NORMAL
- en: The music library list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling text – selected song (title by artist)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The play button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stop button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, I am aware of which widget to use for each item on the list.
    However, if you have not yet decided, now is the time to determine the best Termdash
    widget to use for each item:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Music library list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Error messages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling text – selected song (title by artist), metadata
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Text input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input field
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The play button
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The stop button
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s create at least one of each type as an example. The full code is available
    in the `Chapter10` GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a text widget for the music library list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The music library list will take in the audio list and print the text in a
    section that will list the index of the song next to the title and artist. We
    define this widget with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is called in the `Run` function field like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The error message and metadata items are also text widgets, so we’ll omit those
    code examples. Next, we’ll create the input text.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an input text widget for setting the current ID of a song
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The input text section is where a user inputs the ID of the song displayed
    in the music library section. The input text is defined within the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Creating a button to start playing the song associated with the input ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last type of widget is a button. There are two different buttons we need,
    but the following code is for the play button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is called in the `Run` function field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the widgets have been created, they are placed within the container
    in the appropriate places with the following line of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the widgets have been placed within the container, we can run the terminal
    dashboard with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Magically, the player terminal dashboards appear and we can select an ID to
    enter and play a song:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Audio file player terminal dashboard](img/Figure_10.18_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Audio file player terminal dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Voila! We’ve created a terminal dashboard to play the music in our audio file
    library. While you can view the metadata through the command-line application’s
    `get` and `list` commands and play music with the `play` command, the new player
    terminal dashboard allows you to view what exists in the audio file library in
    a more user-friendly fashion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a survey with different interactive
    prompts and a terminal dashboard containing a variety of widgets. These are just
    examples that can hopefully inspire you in terms of interactivity within your
    own command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: The survey example showed you how to use a variety of different types of prompts;
    you can prompt the user for their user experience, but as you’ve seen within the
    audio file CLI, you can also just prompt for missing information. These prompts
    can be input throughout your code in places where prompts may come in handy, or
    they can be strung along a list of other questions and you can create a more thorough
    survey for your users.
  prefs: []
  type: TYPE_NORMAL
- en: The player terminal dashboard gives you an example of how to create a terminal
    dashboard for a command-line interface. Consider the kind of data your users will
    be sending or retrieving from your command-line interface and let that guide you
    in your design of a more visual approach.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What method is used to create the terminal layer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method is used to place a widget inside a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between the binary layout and the grid layout?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tcell.New()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`container.PlaceWidget(widget)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The grid layout allows you to split the container into horizontal rows and vertical
    columns. The binary layout allows you to split sub-containers horizontally or
    vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Big Book of Dashboards: Visualizing Your Data Using Real-World Business
    Scenarios* by Wexler, Shaffer, and Cotgreave'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Building and Distributing for Different Platforms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the book is all about building, testing, and distributing your
    CLI application using Docker and GoReleaser. It starts by explaining the importance
    of building and testing, and how build tags with Boolean logic can be used to
    create targeted builds and testing to further stabilize your project with each
    new feature. The part also covers cross-compilation, a powerful feature of Go,
    which enables you to compile your application for different operating systems
    and architectures. The benefits of containerization are also explored, with a
    focus on Docker containers for testing and distributing your apps. Finally, we
    end with a discussion using GoReleaser and GitHub Actions in tandem to automate
    the release of a CLI application as a Homebrew formula, which makes it easy for
    MacOS users to find and install your software with just one command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18883_11.xhtml#_idTextAnchor258), *Custom Builds and Testing
    CLI Commands*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18883_12.xhtml#_idTextAnchor291), *Cross Compilation Across
    Different Platforms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18883_13.xhtml#_idTextAnchor331), *Using Containers for Distribution*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18883_14.xhtml#_idTextAnchor359), *Publishing your Go binary
    as a Homebrew Formula with GoReleaser*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
