- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Interactivity with Prompts and Terminal Dashboards
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和终端仪表板的交互性
- en: One powerful way to increase usability for users is to integrate interactivity
    with either prompts or terminal dashboards. Prompts are useful because they create
    a conversational approach while requesting input. Dashboards are useful because
    they allow developers to create a graphical interface from ASCII characters. That
    graphical interface, via a dashboard, can create powerful visual cues to allow
    users to navigate through different commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 提高用户体验的一种强大方式是将交互性与提示或终端仪表板集成。提示很有用，因为它们在请求输入的同时创建了一种对话式的方法。仪表板很有用，因为它们允许开发者从ASCII字符创建图形界面。通过仪表板创建的图形界面可以产生强大的视觉提示，使用户能够导航不同的命令。
- en: This chapter will give you examples of how to build user surveys from a series
    of prompts, and a terminal dashboard – whether learning about the Termdash library,
    designing the mockup, or implementing it for the audio file CLI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将给出如何从一系列提示中构建用户调查问卷以及终端仪表板的示例 – 不论是学习Termdash库、设计原型还是将其应用于音频文件命令行界面。
- en: 'Interactivity is fun. It’s the more human and empathetic approach to a command-line
    interface. However, remember to disable interactivity if you are not outputting
    to a terminal. This chapter will cover the basics of surveys and dive deep into
    the terminal dashboard. By the end of this chapter, you’ll have everything you
    need to create your own survey or dashboard. We will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 交互性很有趣。它是一种更人性化和富有同理心的命令行界面方法。然而，如果你不是输出到终端，请记住禁用交互性。本章将涵盖调查问卷的基础知识，并深入探讨终端仪表板。到本章结束时，你将拥有创建自己的调查问卷或仪表板所需的一切。我们将涵盖以下内容：
- en: Guiding users with prompts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提示引导用户
- en: Designing a useful terminal dashboard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个有用的终端仪表板
- en: Implementing a terminal dashboard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现终端仪表板
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You’ll need a Unix operating system to understand and run the examples shared
    in the chapter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要Unix操作系统来理解并运行本章中共享的示例
- en: Get the `termdash` package at [https://github.com/mum4k/termdash](https://github.com/mum4k/termdash)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/mum4k/termdash](https://github.com/mum4k/termdash)获取`termdash`包
- en: Get the survey package at [https://github.com/go-survey/survey](https://github.com/go-survey/survey)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/go-survey/survey](https://github.com/go-survey/survey)获取调查问卷包
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到代码示例[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter10)
- en: Guiding users with prompts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用提示引导用户
- en: There are many ways to simply prompt the user, but if you want to create a whole
    survey that can retrieve information using a variety of different prompts – text
    input, multi-select, single-select, multi-line text, password, and more – it might
    be useful to use a preexisting library to handle this for you. Let’s create a
    generic customer survey using the `survey` package.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多简单提示用户的方法，但如果你想要创建一个可以检索信息的完整调查问卷，使用各种不同的提示 – 文本输入、多选、单选、多行文本、密码等 – 使用现有的库来处理这些可能很有用。让我们使用`survey`包创建一个通用的客户调查问卷。
- en: 'To show you how to use this package, I’ll create a survey that can prompt the
    user for different types of input:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用这个包，我将创建一个可以提示用户不同类型输入的调查问卷：
- en: '**Text input** – for example, an email address'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本输入** – 例如，电子邮件地址'
- en: '**Select** – for example, a user’s experience with the CLI'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择** – 例如，用户对命令行界面的体验'
- en: '**Multiselect** – for example, any issues encountered'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多选** – 例如，遇到的任何问题'
- en: '**Multiline** – for example, open-ended feedback'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多行** – 例如，开放式的反馈'
- en: 'In the `Chapter-10` repository, a survey has been written to handle these four
    prompts. The questions, stored in the `qs` variable, are defined as a slice of
    `*survey.Question`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter-10`仓库中，已经编写了一个调查问卷来处理这四个提示。问题存储在`qs`变量中，定义为`*survey.Question`的切片：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’ll need an `answers` struct to store all the results from the prompts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`answers`结构体来存储所有来自提示的结果：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And finally, the method that asks the questions and stores the results:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，询问问题和存储结果的方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we’ve created the survey, we can try it out:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了调查问卷，我们可以尝试一下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Prompting the user is an easy way to integrate interactivity into your command-line
    application. However, there are even more colorful and fun ways to interact with
    your users. In the next section, we’ll discuss the terminal dashboard, the `termdash`
    package in detail, and how to mock up and implement a terminal dashboard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 提示用户是集成交互到您的命令行应用程序的一种简单方法。然而，还有更多丰富多彩和有趣的方式来与您的用户交互。在下一节中，我们将详细讨论终端仪表板，`termdash`包，以及如何模拟和实现终端仪表板。
- en: Designing a useful terminal dashboard
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个有用的终端仪表板
- en: Command-line interfaces don’t have to be limited to text. With **termdash**,
    a popular Golang library, you can build a terminal dashboard providing users with
    a user interface to visually see progress, alerts, text, and more. Colorful widgets
    placed within a clean dashboard that’s been neatly laid out can increase information
    density and present a lot of information to the user in a very user-friendly manner.
    In this section, we’ll learn about the library and the different layout choices
    and widget options. At the end of the chapter, we’ll design a terminal dashboard
    that we can implement in our **audio file** command-line interface.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面不必局限于文本。使用**termdash**，一个流行的Golang库，你可以构建一个终端仪表板，为用户提供一个用户界面，以直观地查看进度、警报、文本等。在整洁布局的仪表板中放置色彩丰富的组件可以增加信息密度，并以非常用户友好的方式向用户展示大量信息。在本节中，我们将了解这个库以及不同的布局选择和组件选项。在本章末尾，我们将设计一个可以在我们的**音频文件**命令行界面中实现的终端仪表板。
- en: Learning about Termdash
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Termdash
- en: Termdash is a Golang library that provides a customizable and cross-platform,
    terminal-based dashboard. On the project’s GitHub page, a fun and colorful demo
    provides an example of all possible widgets demonstrated within a dynamic layout.
    From the demo, you can see that you can go all out on a fancy dashboard. To do
    so, you’ll need to understand how to lay out a dashboard, interact with keyboard
    and mouse events, add widgets, and fine-tune the appearance with alignment and
    color. Within this section, we will break down the layers of a Termdash interface
    and the widgets that can be organized within it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Termdash是一个Golang库，它提供了一个可定制的、跨平台的基于终端的仪表板。在项目的GitHub页面上，一个有趣且多彩的演示展示了在动态布局中演示的所有可能的组件。从演示中，你可以看到你可以打造一个豪华的仪表板。要做到这一点，你需要了解如何布局仪表板，如何与键盘和鼠标事件交互，添加组件，以及如何通过对齐和颜色进行微调来调整外观。在本节中，我们将分解Termdash界面的层以及可以组织其中的组件。
- en: 'A Termdash dashboard consists of four main layers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Termdash仪表板由四个主要层组成：
- en: The terminal layer
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端层
- en: The infrastructure layer
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施层
- en: The container layer
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器层
- en: The widgets layer
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件层
- en: Let’s take a deep dive into each of them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每一个。
- en: The terminal layer
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终端层
- en: Think of the terminal layer of a dashboard as a 2D grid of cells that exist
    within a buffer. Each cell contains either an ASCII or Unicode character with
    the option to customize the foreground color, the color of text, the background
    color, or the color of the non-character space within the cell. Interactions with
    the mouse and keyboard happen on this layer as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将仪表板的终端层想象成一个存在于缓冲区内的2D单元格网格。每个单元格包含一个ASCII或Unicode字符，可以选择自定义前景色、文本颜色、背景色或单元格内非字符空间的颜色。鼠标和键盘的交互也发生在这一层。
- en: 'Two terminal libraries can be used to interact at the cell level of a terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两个终端库在终端的单元格级别进行交互：
- en: '**tcell**: Inspired by **termbox** and has many new improvements'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tcell**：受**termbox**启发，并有许多新的改进'
- en: '**termbox**: No longer supported, although it is still an option'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**termbox**：不再受支持，尽管它仍然是一个选项'
- en: 'The following examples will utilize the `tcell` package to interact with the
    terminal. To start, create a new `tcell` instance to interact via the terminal
    API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用`tcell`包与终端进行交互。首先，创建一个新的`tcell`实例以通过终端API进行交互：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that in this example, `tcell` has two methods: `New` and `Close`. `New`
    creates a new `tcell` instance in order to interact with the terminal and `Close`
    closes the terminal. It’s a good practice to defer closing access to `tcell` right
    after creation. Although there are no options passed into the `New` method, there
    are a few optional methods that can be called:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，`tcell`有两个方法：`New`和`Close`。`New`用于创建一个新的`tcell`实例以与终端交互，而`Close`用于关闭终端。在创建后立即延迟关闭对`tcell`的访问是一个好的实践。尽管没有将选项传递给`New`方法，但还有一些可选的方法可以调用：
- en: '`ColorMode` sets the color mode when initializing a terminal'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorMode` 在初始化终端时设置颜色模式'
- en: '`ClearStyle` sets the foreground and background color when a terminal is cleared'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClearStyle` 在清除终端时设置前景色和背景色'
- en: 'An example of initializing a cell in `ColorMode` to access all 256 available
    terminal colors would look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化单元格到 `ColorMode` 以访问所有256种可用的终端颜色的示例可能如下所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`ClearStyle`, by default, will use `ColorDefault` if no specific `ClearStyle`
    is set. This `ColorDefault` is usually the default foreground and background colors
    of the terminal emulator, which are typically black and white. To set a terminal
    to use a yellow foreground and navy background style when the terminal is cleared,
    the `New` method, which accepts a slice of options, would be modified in the following
    way:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ClearStyle` 如果未设置特定的 `ClearStyle`，将使用 `ColorDefault`。这个 `ColorDefault`
    通常是指终端模拟器的默认前景色和背景色，通常是黑色和白色。要将终端设置为在清除时使用黄色前景色和海军蓝背景色，可以通过以下方式修改接受选项切片的 `New`
    方法：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we’ve created a new `tcell` that gives us access to the Terminal API,
    let’s discuss the next layer – infrastructure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个新的 `tcell`，它使我们能够访问终端 API，让我们讨论下一层——基础设施。
- en: The infrastructure layer
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施层
- en: The infrastructure of a terminal dashboard provides the organization of the
    structure. The three main elements of the infrastructure layer include alignment,
    line style, and Termdash.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 终端仪表板的基础设施提供了结构的组织。基础设施层的主要元素包括对齐、线型和 Termdash。
- en: Alignment
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对齐
- en: Alignment is provided by the `align` package, which provides two alignment options
    – `align.Horizonal`, which includes predefined values of `left`, `center`, and
    `right` and `align.Vertical` with predefined values of `top`, `middle`, and `bottom`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐由 `align` 包提供，该包提供两种对齐选项——`align.Horizontal`，它包括预定义的 `left`、`center` 和 `right`
    值，以及 `align.Vertical`，它具有预定义的 `top`、`middle` 和 `bottom` 值。
- en: Line style
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线型
- en: The line style defines the style of the line drawn on the terminal either when
    drawing boxes or borders.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 线型定义了在终端上绘制框或边框时线条的样式。
- en: The package exposes the options available via `LineStyle`. The `LineStyle` type
    represents a style that follows the Unicode options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该包通过 `LineStyle` 暴露了可用的选项。`LineStyle` 类型代表遵循 Unicode 选项的样式。
- en: Termdash
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Termdash
- en: 'Termdash provides the developer with the main entry point. Its most important
    purpose is to start and stop the dashboard application, control screen refreshing,
    process any runtime errors, and subscribe and listen for keyboard and mouse events.
    The `termdash.Run` method is the simplest way to start a Termdash application.
    The terminal may run until the context expires, a keyboard shortcut is called,
    or it times out. The simplest way to get started with the dashboard is with the
    following minimal code example, which creates a new `tcell` for the terminal layer,
    and a new `termdash` package, which we will dive into in the next section. We
    create context with a 2-minute timeout and then call the `Run` method of the `termdash`
    package:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Termdash 为开发者提供了主要入口点。其最重要的目的是启动和停止仪表板应用程序，控制屏幕刷新，处理任何运行时错误，并订阅和监听键盘和鼠标事件。`termdash.Run`
    方法是启动 Termdash 应用程序的最简单方式。终端可能运行直到上下文过期，键盘快捷键被调用或超时。开始使用仪表板的最简单方法是以下最小代码示例，它为终端层创建了一个新的
    `tcell`，并创建了一个新的 `termdash` 包，我们将在下一节中深入了解。我们使用2分钟的过期时间创建上下文，然后调用 `termdash` 包的
    `Run` 方法：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code example, the dashboard will run until the context expires,
    in 60 seconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，仪表板将运行直到上下文过期，即60秒。
- en: 'Screen redrawing, or refreshing, for your Terminal dashboard can be done in
    a few ways: periodic, time-based redraws or manually triggered redraws. Only one
    method may be used, as using one means the other method is ignored. Besides that,
    the screen will refresh each time an input event occurs. The `termdash.RedrawInterval`
    method is an option that can be passed into the `Run` method to tell the dashboard
    application to redraw, or refresh, the screen at a particular interval. The `Run`
    method can be modified with the option to refresh every 5 seconds:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的终端仪表板进行屏幕重绘或刷新可以通过几种方式完成：基于周期的、基于时间的重绘或手动触发的重绘。只能使用一种方法，因为使用一种方法意味着忽略另一种方法。除此之外，每次发生输入事件时，屏幕都会刷新。`termdash.RedrawInterval`
    方法是一个选项，可以传递给 `Run` 方法，告诉仪表板应用程序在特定间隔内重绘或刷新屏幕。`Run` 方法可以通过每5秒刷新一次的选项进行修改：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The dashboard may also be redrawn using a controller, which can be triggered
    manually. This option means that the dashboard is drawn only once and unlike the
    `Run` method, the user maintains control of the main goroutine. An example of
    this code, using the previously defined `tcell` and `container` variables defined
    earlier, can be passed into a new controller to be drawn manually:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板也可以通过控制器重新绘制，这可以通过手动触发。此选项意味着仪表板只绘制一次，与 `Run` 方法不同，用户保持对主goroutine的控制。以下是一个示例代码，使用之前定义的
    `tcell` 和 `container` 变量，可以传递给一个新的控制器以手动绘制：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Termdash API provides a `termdash.ErrorHandler` option, which tells the
    dashboard how to handle errors gracefully. Without providing an implementation
    for this error handler, the dashboard will panic on all runtime errors. Errors
    can occur when processing or retrieving events, subscribing to an event, or when
    a container fails to draw itself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Termdash API 提供了一个 `termdash.ErrorHandler` 选项，它告诉仪表板如何优雅地处理错误。如果没有为错误处理器提供实现，仪表板将在所有运行时错误上崩溃。错误可能发生在处理或检索事件、订阅事件或容器无法绘制自身时。
- en: 'An error handler is a callback method that receives an error and handles the
    error appropriately. It can be defined as a variable and, in the simplest case,
    just prints the runtime error:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理器是一个回调方法，它接收一个错误并适当地处理该错误。它可以定义为变量，在最简单的情况下，只是打印运行时错误：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When starting a Termdash application using the `Run` or `NewController` method,
    the error handler may be passed in as an option using the `termdash.ErrorHandler`
    method. For example, the `Run` method can be modified with a new option:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Run` 或 `NewController` 方法启动 Termdash 应用程序时，错误处理器可以作为选项通过 `termdash.ErrorHandler`
    方法传递。例如，可以使用新选项修改 `Run` 方法：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While the `NewController` method can be modified similarly:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `NewController` 方法可以类似地进行修改：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Through the `termdash` package, you can also subscribe to keyboard and mouse
    events. Typically, the container and certain widgets subscribe to keyboard and
    mouse events. Developers can also subscribe to certain mouse and keyboard events
    to take global action. For example, a developer may want the terminal to run a
    specific function when a specific key is set. `termdash.KeyboardSubscriber` is
    used to implement this functionality. With the following code, the user subscribes
    to the letters `q` and `Q` and responds to the keyboard events by running code
    to quit the dashboard:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `termdash` 包，您还可以订阅键盘和鼠标事件。通常，容器和某些小部件会订阅键盘和鼠标事件。开发者也可以订阅某些鼠标和键盘事件以执行全局操作。例如，开发者可能希望在按下特定键时终端运行特定函数。`termdash.KeyboardSubscriber`
    用于实现此功能。以下代码中，用户订阅了字母 `q` 和 `Q`，并通过运行代码来响应用户的键盘事件以退出仪表板：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another option is to call the `Run` method with the option to listen to mouse
    events using `termdash.MouseSubscriber`. Similarly, the following code can be
    called to do something random when the mouse button is clicked within the dashboard:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 `termdash.MouseSubscriber` 调用 `Run` 方法以监听鼠标事件。同样，以下代码可以在仪表板内点击鼠标按钮时执行随机操作：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The container layer
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器层
- en: The container layer provides options for dashboard layouts, container styles,
    keyboard focus, and margin and padding. It also provides a method for placing
    a widget within a container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 容器层提供了仪表板布局、容器样式、键盘焦点以及边距和填充的选项。它还提供了一个在容器内放置小部件的方法。
- en: From the previous examples, we see that a new container is called using the
    `container.New` function. We’ll provide some new examples of how to organize your
    container and set it up with different layouts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的示例中，我们看到使用 `container.New` 函数调用一个新的容器。我们将提供一些如何组织容器以及使用不同布局设置容器的示例。
- en: 'There are two main layout options:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的布局选项：
- en: Binary tree
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树
- en: Grid layouts
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格布局
- en: 'The **binary tree layout** organizes containers in a binary tree structure
    where each container is a node in a tree, which, unless empty, may contain either
    two sub-containers or a widget. Sub-containers can be split further with the same
    rules. There are two kinds of splits:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉树布局**将容器组织成一个二叉树结构，其中每个容器是树中的一个节点，除非为空，否则可能包含两个子容器或一个小部件。子容器可以进一步按照相同的规则分割。有两种分割方式：'
- en: '`container.SplitHorizontal` method, will create top and bottom sub-containers
    specified by `container.Top` and `container.Bottom`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.SplitHorizontal` 方法，将创建由 `container.Top` 和 `container.Bottom` 指定的顶部和底部子容器'
- en: '`container.SplitVertical` method, will create left and right sub-containers,
    specified by `container.Left` and `container.Right`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.SplitVertical`方法将创建由`container.Left`和`container.Right`指定的左右子容器'
- en: 'The `container.SplitPercent` option specifies the percentage of container split
    to use when spitting either vertically or horizontally. When the split percentage
    is not specified, a default of 50% is used. The following is a simple example
    of a binary tree layout using all the methods described:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`container.SplitPercent`选项指定了在垂直或水平分割容器时使用的容器分割百分比。当未指定分割百分比时，默认使用50%。以下是一个使用所有描述的方法的简单二叉树布局示例：'
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice how we drill down when splitting up the terminal into containers. First,
    we split vertically to divide the terminal into left and right portions. Then,
    we split the right portion horizontally. The bottom-right horizontally split portion
    is split vertically. Running this code will present the following dashboard:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何在分割终端为容器时进行钻取的。首先，我们垂直分割终端，将其分为左右两部分。然后，我们将右侧部分水平分割。右下角的水平分割部分再次垂直分割。运行此代码将呈现以下仪表板：
- en: '![Figure 10.1 – Dashboard showing a container split using the binary layout](img/Figure_10.1_B18883.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 显示使用二叉布局分割容器的仪表板](img/Figure_10.1_B18883.jpg)'
- en: Figure 10.1 – Dashboard showing a container split using the binary layout
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 显示使用二叉布局分割容器的仪表板
- en: Notice that the container to the left takes up about 60% percent of the full
    width. The other splits do not define a percentage and take up 50% of the container.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到左侧的容器占据了整个宽度的约60%。其他分割没有定义百分比，占据了容器的一半。
- en: The other option for a dashboard is to use a **grid layout**, which organizes
    the layout into rows and columns. Unlike the binary tree layout, the grid layout
    requires a grid builder object. Rows, columns, or widgets are then added to the
    grid builder object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板的另一种选项是使用**网格布局**，它将布局组织成行和列。与二叉树布局不同，网格布局需要一个网格构建器对象。然后，将行、列或小部件添加到网格构建器对象中。
- en: Columns are defined using either the `grid.ColWidhPerc` function, which defines
    a column with a specified width percentage of the parent’s width, or `grid.ColWidthPercWithOpts`,
    which is an alternative that allows developers to additionally specify options
    when representing the column.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列是通过`grid.ColWidthPerc`函数定义的，该函数定义了一个具有父宽度指定百分比的列，或者通过`grid.ColWidthPercWithOpts`定义，这是一个允许开发者在表示列时额外指定选项的替代方案。
- en: Rows are defined using either the `grid.RowHeightPerc` function, which defines
    a row with a specified height percentage of the parent’s height, or `grid.RowHeightPercWithOpts`,
    which is an alternative that allows developers to additionally specify options
    when representing the row.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 行是通过`grid.RowHeightPerc`函数定义的，该函数定义了一个具有父高度指定百分比的行，或者通过`grid.RowHeightPercWithOpts`定义，这是一个允许开发者在表示行时额外指定选项的替代方案。
- en: 'To add a widget within the grid layout, utilize the `grid.Widget` method. The
    following is a simple example of a layout implemented by the `grid` package. The
    code uses all the related methods and adds an ellipses text widget within each
    cell:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要在网格布局中添加小部件，请使用`grid.Widget`方法。以下是一个使用`grid`包实现的布局的简单示例。代码使用了所有相关方法，并在每个单元格中添加了一个省略号文本小部件：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running the code generates the following dashboard:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会生成以下仪表板：
- en: '![Figure 10.2 – Dashboard showing the container created using the grid layout](img/Figure_10.2_B18883.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 显示使用网格布局创建的容器的仪表板](img/Figure_10.2_B18883.jpg)'
- en: Figure 10.2 – Dashboard showing the container created using the grid layout
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 显示使用网格布局创建的容器的仪表板
- en: Notice that the column width percentage equals 100%; anything more would cause
    a compilation error.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到列宽百分比等于100%；任何超过这个值都会导致编译错误。
- en: 'There is also the option of a dynamic layout that allows you to switch between
    different layouts on the dashboard. Using the `container.ID` option, you can identify
    a container with some text, which can be referenced later so there’s a way to
    identify which container will be dynamically updated using the `container.Update`
    method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个动态布局的选项，允许你在仪表板上切换不同的布局。使用`container.ID`选项，你可以通过一些文本标识一个容器，这可以在以后被引用，以便使用`container.Update`方法动态更新哪个容器：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code, the container ID is set to `123`. Originally, the widget contained
    just one button. The `update` method replaces the single button with a container
    split vertically, with one button on the left and another on the right. When running
    this code, pressing the *u* key runs the update on the layout.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，容器ID设置为`123`。最初，小部件只包含一个按钮。`update`方法将单个按钮替换为垂直分割的容器，左侧有一个按钮，右侧有另一个按钮。运行此代码时，按下
    *u* 键将在布局上运行`update`。
- en: 'The original layout shows a single button:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 原始布局显示单个按钮：
- en: '![Figure 10.3 – Layout showing a single button](img/Figure_10.3_B18883.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 显示单个按钮的布局](img/Figure_10.3_B18883.jpg)'
- en: Figure 10.3 – Layout showing a single button
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 显示单个按钮的布局
- en: 'After pressing the *u* or *U* key, the layout updates:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *u* 或 *U* 键后，布局会更新：
- en: '![Figure 10.4 – Layout showing two buttons after pressing the u key again](img/Figure_10.4_B18883.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 再次按下u键后的两个按钮布局](img/Figure_10.4_B18883.jpg)'
- en: Figure 10.4 – Layout showing two buttons after pressing the u key again
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 再次按下u键后的两个按钮布局
- en: 'The container layer can be further configured using margin and padding settings.
    The margin is the space outside of the container’s border while the padding is
    the space between the inside of the container’s border and its content. The following
    image provides the best visual representation of margins and padding:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 容器层可以通过使用外边距和填充设置进一步配置。外边距是容器边框外的空间，而填充是容器边框内侧与其内容之间的空间。以下图像提供了外边距和填充的最佳视觉表示：
- en: '![Figure 10.5 – Margin and padding](img/Figure_10.5_B18883.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 外边距和填充](img/Figure_10.5_B18883.jpg)'
- en: Figure 10.5 – Margin and padding
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 外边距和填充
- en: 'The margin and padding can be set with either absolute or relative values.
    An absolute margin can be set with the following options:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 外边距和填充可以使用绝对值或相对值设置。绝对外边距可以使用以下选项设置：
- en: '`container.MarginTop`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginTop`'
- en: '`container.MarginRight`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginRight`'
- en: '`container.MarginBottom`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginBottom`'
- en: '`container.MarginLeft`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginLeft`'
- en: 'Absolute padding can be set with the following options:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对填充可以使用以下选项设置：
- en: '`container.PaddingTop`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingTop`'
- en: '`container.PaddingRight`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingRight`'
- en: '`container.PaddingBottom`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingBottom`'
- en: '`container.PaddingLeft`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingLeft`'
- en: 'Relative values for the margin and padding are set with percentages. The margin
    and padding’s top and bottom percentage values are relative to the container’s
    height:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 外边距和填充的相对值以百分比设置。外边距和填充的顶部和底部百分比值相对于容器的高度：
- en: '`container.MarginTopPercent`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginTopPercent`'
- en: '`container.MarginBottomPercent`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginBottomPercent`'
- en: '`container.PaddingTopPercent`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingTopPercent`'
- en: '`container.PaddingBottomPercent`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingBottomPercent`'
- en: 'The margin and padding’s right and left percentage values are relative to the
    container’s width:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 外边距和填充的右侧和左侧百分比值相对于容器的宽度：
- en: '`container.MarginRightPercent`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginRightPercent`'
- en: '`container.MarginLeftPercent`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.MarginLeftPercent`'
- en: '`container.PaddingRightPercent`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingRightPercent`'
- en: '`container.PaddingLeftPercent`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.PaddingLeftPercent`'
- en: 'Another form of placement within containers is alignment. The following methods
    are available from the align API to align content within the container:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内的另一种定位形式是对齐。以下是从对齐API中可用的方法，用于在容器内对齐内容：
- en: '`container.AlignHorizontal`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.AlignHorizontal`'
- en: '`container.AlignVertical`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.AlignVertical`'
- en: 'Let’s put it all together in a simple example that extends upon the binary
    tree code example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个简单的例子中将所有这些放在一起，这个例子扩展了二叉树代码示例：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The resulting layout appears as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果布局如下所示：
- en: '![Figure 10.6 – Container showing different alignments for a button, with different
    margins and padding](img/Figure_10.6_B18883.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 显示按钮不同对齐方式、不同外边距和填充的容器](img/Figure_10.6_B18883.jpg)'
- en: Figure 10.6 – Container showing different alignments for a button, with different
    margins and padding
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 显示按钮不同对齐方式、不同外边距和填充的容器
- en: You can also define a key to change the focus to the next or previous container
    using the `container.KeyFocusNext` and `container.KeyFocusPrevious` options.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以定义一个键来使用`container.KeyFocusNext`和`container.KeyFocusPrevious`选项将焦点切换到下一个或上一个容器。
- en: The widget layer
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小部件层
- en: 'In several of the previous examples, we showed code that placed a widget in
    either a grid or binary tree container layout and also customized the alignment,
    margin, and padding. However, besides a simple button or text, there are different
    widget options, and the demo on the GitHub page shows an example of each:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的几个例子中，我们展示了将小部件放置在网格或二叉树容器布局中的代码，并且还自定义了对齐、边距和填充。然而，除了简单的按钮或文本之外，还有不同的小部件选项，GitHub页面上的演示展示了每个选项的示例：
- en: '![Figure 10.7 – Termdash sample screenshot showing all the widgets in a dashboard](img/Figure_10.7_B18883.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 显示仪表板中所有小部件的Termdash示例截图](img/Figure_10.7_B18883.jpg)'
- en: Figure 10.7 – Termdash sample screenshot showing all the widgets in a dashboard
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 显示仪表板中所有小部件的Termdash示例截图
- en: 'Let’s do a quick example of each with a snippet of code to understand how each
    widget is created. To add each widget to a container, just use the `container.PlaceWidget`
    method that was used earlier for the simple text and button examples. Let’s go
    over a few other examples: a bar chart, donut, and gauge. For a detailed code
    of the other widgets, visit the very well-documented termdash wiki and check out
    the demo pages.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一段代码片段快速演示每个小部件的创建方法。要将每个小部件添加到容器中，只需使用之前用于简单文本和按钮示例的`container.PlaceWidget`方法。让我们来看几个其他示例：柱状图、饼图和仪表。有关其他小部件的详细代码，请访问非常详细的termdash维基百科并查看演示页面。
- en: A bar chart
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 柱状图
- en: 'Here is some example code for creating a bar chart widget with individual values
    displayed relative to a `max` value:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些创建带有相对于`max`值的单个值的柱状图小部件的示例代码：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code creates a new `barchart` instance and adds the values, a
    slice of `int`, plus the maximum `int` value. The resulting terminal dashboard
    looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个新的`barchart`实例，并添加了值，一个`int`的切片，以及最大`int`值。生成的终端仪表板看起来如下：
- en: '![Figure 10.8 – Bar chart example](img/Figure_10.8_B18883.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 柱状图示例](img/Figure_10.8_B18883.jpg)'
- en: Figure 10.8 – Bar chart example
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 柱状图示例
- en: Change the values of the `values` and `max` variables to see the chart change.
    The color of the bars can also be modified based on preference.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`values`和`max`变量的值以查看图表的变化。条的颜色也可以根据个人喜好进行修改。
- en: A donut
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 饼图
- en: 'A donut, or progress circle chart, represents the completion of progress. Here
    is some example code for creating a donut chart to show percentages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图，或进度圆图表，表示进度的完成。以下是一些创建饼图以显示百分比的示例代码：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code creates a new `donut` instance with options for the label
    and foreground color set to green. The resulting terminal dashboard looks like
    this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个带有标签和前景色设置为绿色的`donut`新实例。生成的终端仪表板看起来如下：
- en: '![Figure 10.9 – Green donut at 75%](img/Figure_10.9_B18883.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 75%的绿色饼图](img/Figure_10.9_B18883.jpg)'
- en: Figure 10.9 – Green donut at 75%
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 75%的绿色饼图
- en: Again, the color can be modified based on preference, and remember, since Termdash
    provides dynamic refreshing, the data can be automatically updated and redrawn,
    making it quite nice for showing progress.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，颜色可以根据个人喜好进行修改，并且请记住，由于Termdash提供动态刷新，数据可以自动更新并重绘，这使得它非常适合显示进度。
- en: A gauge
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仪表
- en: 'A gauge, or progress bar, is another way to measure the amount completed. The
    following is some sample code for showing how to create a progress gauge:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表，或进度条，是衡量完成量的另一种方式。以下是一些展示如何创建进度仪表的示例代码：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code creates a new instance of a gauge with options for a light border,
    a title, `1`. The percentage, as with the donut, is 75%. The resulting terminal
    dashboard looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个带有轻边框、标题和`1`选项的仪表的新实例。百分比，就像饼图一样，是75%。生成的终端仪表板看起来如下：
- en: '![Figure 10.10 – Gauge at 75% percent progress](img/Figure_10.10_B18883.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 75%进度的仪表](img/Figure_10.10_B18883.jpg)'
- en: Figure 10.10 – Gauge at 75% percent progress
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 75%进度的仪表
- en: As mentioned before, because of dynamic redrawing, this is another great option
    for showing progress updates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，由于动态重绘，这是显示进度更新的另一个绝佳选择。
- en: 'Now that we’ve shown examples of different widgets to include within a terminal
    dashboard, let’s sketch out a design using these widgets that we can later implement
    in our audio file command-line interface. Suppose we wanted to build a music player
    in a terminal dashboard. Here is a sample layout:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了如何在终端仪表板中包含不同的小部件的示例，让我们使用这些小部件草拟一个设计，我们可以在稍后将其实现到我们的音频文件命令行界面中。假设我们想在终端仪表板中构建一个音乐播放器。以下是一个示例布局：
- en: '![Figure 10.11 – Terminal dashboard layout](img/Figure_10.11_B18883.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 终端仪表板布局](img/Figure_10.11_B18883.jpg)'
- en: Figure 10.11 – Terminal dashboard layout
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 终端仪表板布局
- en: This layout can be created easily with the binary layout. The music library
    list section can be generated from a list of songs with number identifiers, which
    can be used in the text input section, where a song can be selected by ID. Any
    error messages associated with the input ID will be displayed right below. If
    the input is good, the selected song section will show rolling ASCII text with
    the song title, and the metadata section will display the text metadata of the
    selected song. Hitting the play button will start playing the selected song, and
    the stop button will stop it. Proceed to the next section where we’ll make this
    terminal dashboard a reality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局可以通过二进制布局轻松创建。音乐库列表部分可以从带有编号标识符的歌曲列表生成，这些标识符可以在文本输入部分使用，通过ID选择歌曲。与输入ID相关的任何错误信息将直接显示在其下方。如果输入正确，所选歌曲部分将显示带有歌曲标题的滚动ASCII文本，并且元数据部分将显示所选歌曲的文本元数据。点击播放按钮将开始播放所选歌曲，而停止按钮将停止播放。接下来，我们将进入下一个部分，我们将使这个终端仪表板成为现实。
- en: Implementing a terminal dashboard
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现终端仪表板
- en: When creating a terminal dashboard, you can create it as a separate standalone
    application or as a command that is called from the command-line application.
    In our specific example for the player terminal dashboard, we are going to call
    the dashboard when the `./bin/audiofile player` command is called.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建终端仪表板时，你可以将其创建为一个独立的独立应用程序，或者作为一个从命令行应用程序调用的命令。在我们的特定示例中，对于播放器终端仪表板，我们将调用仪表板，当调用`./bin/audiofile
    player`命令时。
- en: 'First, from the audio file’s root repository, we’ll need to use `cobra-cli`
    to create the command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从音频文件的根存储库中，我们需要使用`cobra-cli`创建命令：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can create the code to generate the terminal dashboard, called within
    the `Run` field of the `player` command. Remember that the terminal dashboard
    consists of four main layers: the terminal, infrastructure, container, and widgets.
    Like a painting, we’ll start with the base layer: the terminal.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建代码来生成终端仪表板，该代码在`player`命令的`Run`字段中调用。记住，终端仪表板由四个主要层组成：终端、基础设施、容器和小部件。就像一幅画一样，我们将从基础层开始：终端。
- en: Creating the terminal layer
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建终端层
- en: The first thing you need to do is to create a terminal that provides access
    to any input and output. Termdash has a `tcell` package for creating a new `tcell`-based
    terminal. Many terminals by default only support 16 colors, but other more modern
    terminals can support up to 256 colors. The following code specifically creates
    a new terminal with a 265-color mode.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是创建一个提供对任何输入和输出的访问的终端。Termdash有一个`tcell`包用于创建基于`tcell`的新终端。许多终端默认只支持16种颜色，但其他更现代的终端可以支持多达256种颜色。以下代码特别创建了一个具有265色模式的新的终端。
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After creating a terminal layer, we then create the infrastructure layer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建终端层之后，我们接着创建基础设施层。
- en: Creating the infrastructure layer
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基础层
- en: 'The infrastructure layer handles the terminal setup, mouse and keyboard events,
    and containers. In our terminal dashboard player, we want to handle a few tasks:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 基础层处理终端设置、鼠标和键盘事件以及容器。在我们的终端仪表板播放器中，我们想要处理几个任务：
- en: Keyboard event to signal quitting
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出信号的键盘事件
- en: Running the terminal dashboard, which subscribes to this keyboard event
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行终端仪表板，该仪表板订阅了此键盘事件
- en: Let’s write the code to handle these two features required of the terminal dashboard.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码来处理终端仪表板所需的这两个功能。
- en: Subscribing to keyboard events
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅键盘事件
- en: 'If we want to listen for key events, we create a keyboard subscriber to specify
    the keys to listen to:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想监听键事件，我们创建一个键盘订阅者来指定要监听的键：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have defined a keyboard subscriber, we can use this as an input
    parameter to termdash’s `Run` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个键盘订阅者，我们可以将其用作termdash的`Run`方法的输入参数。
- en: Running the terminal
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行终端
- en: 'When running the terminal, you’ll need the terminal variable, container, and
    keyboard and mouse subscribers, as well as the timed redrawing interval and other
    options. The following code runs the `tcell`-based terminal we created and the
    `quitter` keyboard subscriber, which listens for *q* or *Q* key events to quit
    the application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行终端时，你需要终端变量、容器以及键盘和鼠标订阅者，以及定时重绘间隔和其他选项。以下代码运行了我们创建的基于`tcell`的终端和`quitter`键盘订阅者，该订阅者监听*q*或*Q*键事件以退出应用程序：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `c` variable that’s passed into the `termdash.Run` method as the third parameter
    is the container. Let’s define the container now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为第三个参数传递给 `termdash.Run` 方法的 `c` 变量是容器。现在让我们定义容器。
- en: Creating the container layer
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建容器层
- en: When creating the container, it helps to look at the bigger picture of the layout
    and then narrow it down as you go. For example, when you first look at the planned
    layout, you’ll see the largest sections are made from left and right vertical
    splits.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建容器时，查看布局的更大图景然后逐步缩小范围是有帮助的。例如，当你第一次查看计划布局时，你会看到最大的部分是由左右垂直分割组成的。
- en: '![Figure 10.12 – Initial vertical split](img/Figure_10.12_B18883.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 初始垂直分割](img/Figure_10.12_B18883.jpg)'
- en: Figure 10.12 – Initial vertical split
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 初始垂直分割
- en: 'As we begin to define the container, we’ll slowly drill down with more specifics,
    but we begin with the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始定义容器时，我们会逐渐通过更具体的信息进行钻取，但我们将从以下内容开始：
- en: '**Vertical Split (Left)** – The music library'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直分割（左侧）** – 音乐库'
- en: '**Vertical Split (Right)** – All other widget'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直分割（右侧）** – 所有其他小部件'
- en: The final code reflects this drill-down process. Since we keep the left vertical
    split as the music library, we drill down with containers on the left, always
    starting with the larger containers and adding smaller ones within.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码反映了这一钻取过程。由于我们保持左侧垂直分割作为音乐库，我们通过左侧的容器进行钻取，始终从较大的容器开始，并在其中添加较小的容器。
- en: '![Figure 10.13 – Horizontal split of right vertical space](img/Figure_10.13_B18883.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 右侧垂直空间的水平分割](img/Figure_10.13_B18883.jpg)'
- en: Figure 10.13 – Horizontal split of right vertical space
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 右侧垂直空间的水平分割
- en: 'The next is a horizontal split that separates the left vertical split into
    the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个水平分割，它将左侧垂直分割分为以下几部分：
- en: '**Horizontal Split (Top) 30%** – Text input, error messages, and the rolling
    song title text'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（顶部）30%** – 文本输入、错误信息和滚动歌曲标题文本'
- en: '**Horizontal Split (Bottom) 70%** – Metadata and play/stop buttons'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（底部）70%** – 元数据和播放/停止按钮'
- en: 'Let’s take the top horizontal split and split it, again, horizontally:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将顶部水平分割再次水平分割：
- en: '**Horizontal Split (Top) 30%** – Text input and error message'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（顶部）30%** – 文本输入和错误信息'
- en: '**Horizontal Split (Bottom) 70%** – The rolling song title text'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（底部）70%** – 滚动歌曲标题文本'
- en: "![Figure 10.14 – Horizont\uFEFFal split of \uFEFFtop horizontal space](img/Figure_10.14_B18883.jpg)"
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 顶部水平空间的水平分割](img/Figure_10.14_B18883.jpg)'
- en: Figure 10.14 – Horizontal split of top horizontal space
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 顶部水平空间的水平分割
- en: 'We split the earlier top part horizontally into the separated text input and
    error messages:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前顶部部分水平分割成分离的文本输入和错误信息：
- en: '**Horizontal Split (Top) 60%** – Text input'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（顶部）60%** – 文本输入'
- en: '**Horizontal Split (Bottom) 40%** – Error messages'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（底部）40%** – 错误信息'
- en: '![Figure 10.15 – Horizontal split of top horizontal space](img/Figure_10.15_B18883.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 顶部水平空间的水平分割](img/Figure_10.15_B18883.jpg)'
- en: Figure 10.15 – Horizontal split of top horizontal space
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 顶部水平空间的水平分割
- en: 'Now, let’s drill down into the bottom 70% of the initial horizontal split of
    the right vertical container. Let’s split it up into two horizontal sections:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们钻入右侧垂直容器初始水平分割的底部 70%。让我们将其分割成两个水平部分：
- en: '**Horizontal Split (Top) 80%** – The metadata section'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（顶部）80%** – 元数据部分'
- en: '**Horizontal Split (Bottom) 20%** – The button section (play/stop)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割（底部）20%** – 按钮部分（播放/停止）'
- en: '![Figure 10.16 – Horizontal split of bottom horizontal space](img/Figure_10.16_B18883.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 底部水平空间的水平分割](img/Figure_10.16_B18883.jpg)'
- en: Figure 10.16 – Horizontal split of bottom horizontal space
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 底部水平空间的水平分割
- en: 'Finally, the last part to drill down to is the bottom horizontal split, which
    we will split vertically:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要钻取到的是底部水平分割，我们将将其垂直分割：
- en: '**Vertical Split (Left) 50%** – The play button'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直分割（左侧）50%** – 播放按钮'
- en: '**Vertical Split (Right) 50%** – The stop button'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直分割（右侧）50%** – 停止按钮'
- en: '![Figure 10.17 – Vertical split of bottom horizontal space](img/Figure_10.17_B18883.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – 底部水平空间的垂直分割](img/Figure_10.17_B18883.jpg)'
- en: Figure 10.17 – Vertical split of bottom horizontal space
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – 底部水平空间的垂直分割
- en: 'The entire layout broken down with the container code shows this drill-down
    process – I’ve added comments for where the widgets will be placed for reference:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 整个布局通过容器代码分解显示了这一钻取过程 – 我已经添加了注释，以供参考小部件将被放置的位置：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, let’s create the widgets and place them within the appropriate containers
    to finalize the terminal dashboard.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建小部件并将它们放置在适当的容器中，以最终完成终端仪表板。
- en: Creating the widgets layer
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建小部件层
- en: 'Going back to the original layout, all the different widgets we’ll need to
    implement are clear to see:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 回到原始布局，所有我们需要实现的不同小部件都一目了然：
- en: The music library list
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐库列表
- en: Input text
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入文本
- en: Error messages
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息
- en: Rolling text – selected song (title by artist)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动文本 – 选中歌曲（艺术家名称下的标题）
- en: Metadata
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据
- en: The play button
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放按钮
- en: The stop button
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止按钮
- en: 'At this point, I am aware of which widget to use for each item on the list.
    However, if you have not yet decided, now is the time to determine the best Termdash
    widget to use for each item:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经知道列表中每个项目应该使用哪个小部件。然而，如果你还没有决定，现在是时候确定每个项目最适合使用的Termdash小部件了：
- en: 'Text:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本：
- en: Music library list
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐库列表
- en: Error messages
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息
- en: Rolling text – selected song (title by artist), metadata
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动文本 – 选中歌曲（艺术家名称下的标题），元数据
- en: 'Text input:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本输入：
- en: Input field
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段
- en: 'Button:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮：
- en: The play button
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放按钮
- en: The stop button
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止按钮
- en: Let’s create at least one of each type as an example. The full code is available
    in the `Chapter10` GitHub repository.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们至少创建每种类型的一个作为例子。完整的代码可在`Chapter10` GitHub仓库中找到。
- en: Creating a text widget for the music library list
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为音乐库列表创建文本小部件
- en: 'The music library list will take in the audio list and print the text in a
    section that will list the index of the song next to the title and artist. We
    define this widget with the following function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐库列表将接受音频列表并在一个将列出歌曲索引（旁边是标题和艺术家）的区域内打印文本。我们使用以下函数定义此小部件：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The function is called in the `Run` function field like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在`Run`函数字段中调用，如下所示：
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The error message and metadata items are also text widgets, so we’ll omit those
    code examples. Next, we’ll create the input text.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息和元数据项也是文本小部件，所以我们将省略这些代码示例。接下来，我们将创建输入文本。
- en: Creating an input text widget for setting the current ID of a song
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个用于设置当前歌曲ID的输入文本小部件
- en: 'The input text section is where a user inputs the ID of the song displayed
    in the music library section. The input text is defined within the following function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本部分是用户输入音乐库部分显示的歌曲ID的地方。输入文本在以下函数中定义：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Creating a button to start playing the song associated with the input ID
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个按钮以开始播放与输入ID关联的歌曲
- en: 'The last type of widget is a button. There are two different buttons we need,
    but the following code is for the play button:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种小部件是按钮。我们需要两种不同的按钮，但以下代码是为播放按钮编写的：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The function is called in the `Run` function field:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数在`Run`函数字段中调用：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once all the widgets have been created, they are placed within the container
    in the appropriate places with the following line of code:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦所有小部件都创建好了，它们将按照以下代码行放置在容器中的适当位置：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once the widgets have been placed within the container, we can run the terminal
    dashboard with the following command:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦小部件被放置在容器中，我们可以使用以下命令运行终端仪表板：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Magically, the player terminal dashboards appear and we can select an ID to
    enter and play a song:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神奇的是，玩家终端仪表板出现了，我们可以选择一个ID进入并播放一首歌：
- en: '![Figure 10.18 – Audio file player terminal dashboard](img/Figure_10.18_B18883.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 音频文件播放终端仪表板](img/Figure_10.18_B18883.jpg)'
- en: Figure 10.18 – Audio file player terminal dashboard
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 音频文件播放终端仪表板
- en: Voila! We’ve created a terminal dashboard to play the music in our audio file
    library. While you can view the metadata through the command-line application’s
    `get` and `list` commands and play music with the `play` command, the new player
    terminal dashboard allows you to view what exists in the audio file library in
    a more user-friendly fashion.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哇！我们已经创建了一个终端仪表板，可以在我们的音频文件库中播放音乐。虽然你可以通过命令行应用程序的`get`和`list`命令查看元数据，并通过`play`命令播放音乐，但新的播放终端仪表板允许你以更用户友好的方式查看音频文件库中的内容。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a survey with different interactive
    prompts and a terminal dashboard containing a variety of widgets. These are just
    examples that can hopefully inspire you in terms of interactivity within your
    own command-line application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建一个包含不同交互提示和包含各种小部件的终端仪表板的调查。这些只是可以激发你自己在命令行应用程序中交互性的例子。
- en: The survey example showed you how to use a variety of different types of prompts;
    you can prompt the user for their user experience, but as you’ve seen within the
    audio file CLI, you can also just prompt for missing information. These prompts
    can be input throughout your code in places where prompts may come in handy, or
    they can be strung along a list of other questions and you can create a more thorough
    survey for your users.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 调查示例向您展示了如何使用各种不同类型的提示；您可以提示用户他们的用户体验，但如您在音频文件CLI中看到的，您也可以仅提示缺失信息。这些提示可以在代码中需要提示的地方输入，或者将它们串联在一系列其他问题中，从而为您的用户提供更全面的调查。
- en: The player terminal dashboard gives you an example of how to create a terminal
    dashboard for a command-line interface. Consider the kind of data your users will
    be sending or retrieving from your command-line interface and let that guide you
    in your design of a more visual approach.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家终端仪表板为您提供了一个如何为命令行界面创建终端仪表板的示例。考虑您的用户将通过命令行界面发送或检索的数据类型，并让这些数据类型引导您设计更直观的界面。
- en: Questions
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What method is used to create the terminal layer?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建终端层使用什么方法？
- en: What method is used to place a widget inside a container?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内放置小部件使用什么方法？
- en: What’s the difference between the binary layout and the grid layout?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制布局和网格布局之间的区别是什么？
- en: Answers
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`tcell.New()`'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tcell.New()`'
- en: '`container.PlaceWidget(widget)`'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`container.PlaceWidget(widget)`'
- en: The grid layout allows you to split the container into horizontal rows and vertical
    columns. The binary layout allows you to split sub-containers horizontally or
    vertically.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格布局允许您将容器分割成水平行和垂直列。二进制布局允许您水平或垂直分割子容器。
- en: Further reading
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Big Book of Dashboards: Visualizing Your Data Using Real-World Business
    Scenarios* by Wexler, Shaffer, and Cotgreave'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《大数据仪表板宝典：使用真实世界商业场景可视化您的数据》由Wexler、Shaffer和Cotgreave著
- en: 'Part 4: Building and Distributing for Different Platforms'
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：为不同平台构建和分发
- en: This part of the book is all about building, testing, and distributing your
    CLI application using Docker and GoReleaser. It starts by explaining the importance
    of building and testing, and how build tags with Boolean logic can be used to
    create targeted builds and testing to further stabilize your project with each
    new feature. The part also covers cross-compilation, a powerful feature of Go,
    which enables you to compile your application for different operating systems
    and architectures. The benefits of containerization are also explored, with a
    focus on Docker containers for testing and distributing your apps. Finally, we
    end with a discussion using GoReleaser and GitHub Actions in tandem to automate
    the release of a CLI application as a Homebrew formula, which makes it easy for
    MacOS users to find and install your software with just one command.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本部分主要介绍如何使用Docker和GoReleaser构建、测试和分发您的CLI应用程序。它首先解释了构建和测试的重要性，以及如何使用布尔逻辑的构建标签创建有针对性的构建和测试，以在每个新功能中进一步稳定您的项目。本部分还涵盖了Go的强大功能——交叉编译，它允许您为不同的操作系统和架构编译应用程序。容器化的好处也得到了探讨，重点是Docker容器用于测试和分发应用程序。最后，我们讨论了如何结合使用GoReleaser和GitHub
    Actions来自动化CLI应用程序作为Homebrew公式的发布，这使得MacOS用户只需一个命令就可以轻松找到并安装您的软件。
- en: 'This part has the following chapters:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B18883_11.xhtml#_idTextAnchor258), *Custom Builds and Testing
    CLI Commands*'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18883_11.xhtml#_idTextAnchor258)，*自定义构建和测试CLI命令*'
- en: '[*Chapter 12*](B18883_12.xhtml#_idTextAnchor291), *Cross Compilation Across
    Different Platforms*'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18883_12.xhtml#_idTextAnchor291)，*跨平台交叉编译*'
- en: '[*Chapter 13*](B18883_13.xhtml#_idTextAnchor331), *Using Containers for Distribution*'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18883_13.xhtml#_idTextAnchor331)，*使用容器进行分发*'
- en: '[*Chapter 14*](B18883_14.xhtml#_idTextAnchor359), *Publishing your Go binary
    as a Homebrew Formula with GoReleaser*'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18883_14.xhtml#_idTextAnchor359)，*使用GoReleaser将Go二进制文件发布为Homebrew公式*'
