["```go\n//go:build [tag]\n```", "```go\ngo help buildconstraint\n```", "```go\n//go:build (linux  || openbsd) && amd64 && !cgo\n```", "```go\n//go:build darwin\n```", "```go\n//go:build dev\n```", "```go\n//go:build !free && pro\n```", "```go\n//go:build darwin\n```", "```go\nif profile {\n    mux.HandleFunc(\"/debug/pprof/\", pprof.Index)\n    mux.HandleFunc(\"/debug/pprof/{action}\", pprof.Index)\n    mux.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n}\n```", "```go\nvar (\n    profile = false\n)\n```", "```go\n//go:build profile && (free || pro)\npackage metadata\nfunc init() {\n    profile = true\n}\n```", "```go\nbuild-darwin:\n    go build -tags darwin -o bin/audiofile main.go\n    chmod +x bin/audiofile\n```", "```go\nbuild-darwin-free:\n    go build -tags \"darwin free\" -o bin/audiofile main.go\n    chmod +x bin/audiofile\n```", "```go\n//go:build darwin\n```", "```go\nbuild-darwin-pro:\n    go build -tags \"darwin pro\" -o bin/audiofile main.go\n    chmod +x bin/audiofile\n```", "```go\nbuild-darwin-pro-profile:\n    go build -tags \"darwin pro profile\" -o bin/audiofile main.go\n    chmod +x bin/audiofile\n```", "```go\n//go:build profile\n```", "```go\ntype AudiofileClient interface {\n    Do(req *http.Request) (*http.Response, error)\n}\nvar (\n    getClient = GetHTTPClient()\n)\nfunc GetHTTPClient() AudiofileClient {\n    return &http.Client{\n        Timeout: 15 * time.Second,\n    }\n}\n```", "```go\nresp, err := getClient.Do(req)\n```", "```go\ntype ClientMock struct {\n}\n```", "```go\nfunc (c *ClientMock) Do(req *http.Request) (*http.Response, error) {\n```", "```go\nlistBytes, err := os.ReadFile(\"./testfiles/list.json\")\nif err != nil {\n    return nil, fmt.Errorf(\"unable to read testfile/list.json\")\n}\ngetBytes, err := os.ReadFile(\"./testfiles/get.json\")\nif err != nil {\n    return nil, fmt.Errorf(\"unable to read testfile/get.json\")\n}\nsearchBytes, err := os.ReadFile(\"./testfiles/search.json\")\nif err != nil {\n    return nil, fmt.Errorf(\"unable to read testfile/search.json\")\n}\n```", "```go\n    switch req.URL.Path {\n         case \"/request\":\n             return &http.Response{\n                 Status:  \"OK\",\n                 StatusCode: http.StatusOK,\n                 Body: ioutil.NopCloser(bytes.NewBufferString(string(getBytes))),\n      ContentLength: int64(len(getBytes)),\n      Request: req,\n      Header: make(http.Header, 0),\n  }, nil\n```", "```go\n         case \"/upload\":\n             return &http.Response{\n                 Status:  \"OK\",\n                 StatusCode: http.StatusOK,\n      Body: ioutil.NopCloser(bytes.NewBufferString(\"123\")),\n      ContentLength: int64(len(\"123\")),\n      Request: req,\n      Header: make(http.Header, 0),\n   }, nil\n```", "```go\n        case \"/list\":\n            return &http.Response{\n                Status:  \"OK\",\n                StatusCode: http.StatusOK,\n                Body: ioutil.NopCloser(bytes.\n                      NewBufferString(string(listBytes))),\n                      ContentLength: int64(len(listBytes)),\n                      Request: req,\n                      Header: make(http.Header, 0),\n }, nil\n```", "```go\n        case \"/delete\":\n            return &http.Response{\n                Status:  \"OK\",\n                StatusCode: http.StatusOK,\n                Body: ioutil.NopCloser(bytes.\n                      NewBufferString(\"successfully deleted \n                        audio with id: 456\")),\n                      ContentLength: int64(len(\"successfully \n                                     deleted audio with id: \n                                     456\")),\n                      Request: req,\n                      Header: make(http.Header, 0),\n}, nil\n```", "```go\n        case \"/search\":\n            return &http.Response{\n                Status:  \"OK\",\n                StatusCode: http.StatusOK,\n                Body: ioutil.NopCloser(bytes.\n                NewBufferString(string(searchBytes))),\n                ContentLength: int64(len(list searchBytes \n                Bytes)),\n                Request: req,\n                Header: make(http.Header, 0),\n}, nil\n}\nreturn &http.Response{}, nil\n}\n```", "```go\nvar Logger *zap.Logger\nvar Verbose *zap.Logger\nfunc ConfigureTest() {\n    getClient = &ClientMock{}\n    viper.SetDefault(\"cli.hostname\", \"testHostname\")\n    viper.SetDefault(\"cli.port\", 8000)\n    utils.InitCLILogger()\n}\n```", "```go\nConfigureTest()\n```", "```go\nfunc TestXxx(*testing.T)\n```", "```go\nfunc TestBug(t *testing.T) {\n    ConfigureTest()\n    b := bytes.NewBufferString(\"\")\n    rootCmd.SetOut(b)\n    rootCmd.SetArgs([]string{\"bug\", \"unexpected\"})\n    err := rootCmd.Execute()\n    if err != nil {\n        fmt.Println(\"err: \", err)\n    }\n    actualBytes, err := ioutil.ReadAll(b)\n    if err != nil {\n        t.Fatal(err)\n    }\n    expectedBytes, err := os.ReadFile(\"./testfiles/bug.txt\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    if strings.TrimSpace(string(actualBytes)) != strings.\n       TrimSpace(string(expectedBytes)) {\n        t.Fatal(string(actualBytes), \"!=\", \n          string(expectedBytes))\n    }\n}\n```", "```go\nfunc TestGet(t *testing.T) {\n    ConfigureTest()\n    b := bytes.NewBufferString(\"\")\n    rootCmd.SetOut(b)\n```", "```go\n    rootCmd.SetArgs([]string{\"get\", \"--id\", \"123\", \"--json\"})\n```", "```go\n    err := rootCmd.Execute()\n    if err != nil {\n        fmt.Println(\"err: \", err)\n    }\n```", "```go\n    actualBytes, err := ioutil.ReadAll(b)\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```go\n    expectedBytes, err := os.ReadFile(\"./testfiles/get.json\")\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```go\n    var audio1, audio2 models.Audio\n    json.Unmarshal(actualBytes, &audio1)\n    json.Unmarshal(expectedBytes, &audio2)\n    if !(audio1.Id == audio2.Id &&\n    audio1.Metadata.Tags.Album == audio2.Metadata.Tags.Album &&\n    audio1.Metadata.Tags.AlbumArtist == audio2.Metadata.Tags.AlbumArtist &&\n    audio1.Metadata.Tags.Artist == audio2.Metadata.Tags.Artist &&\n    audio1.Metadata.Tags.Comment == audio2.Metadata.Tags.Comment &&\n    audio1.Metadata.Tags.Composer == audio2.Metadata.Tags.Composer &&\n    audio1.Metadata.Tags.Genre == audio2.Metadata.Tags.Genre &&\n    audio1.Metadata.Tags.Lyrics == audio2.Metadata.Tags.Lyrics &&\n    audio1.Metadata.Tags.Year == audio2.Metadata.Tags.Year) {\n        t.Fatalf(\"expected %q got %q\", string(expectedBytes), string(actualBytes))\n    }\n}\n```", "```go\nfunc TestUpload(t *testing.T) {\n    ConfigureTest()\n    b := bytes.NewBufferString(\"\")\n    rootCmd.SetOut(b)\n    rootCmd.SetArgs([]string{\"upload\", \"--filename\", \"list.\n                   go\"})\n    err := rootCmd.Execute()\n    if err != nil {\n        fmt.Println(\"err: \", err)\n    }\n    expected := \"123\"\n    actualBytes, err := ioutil.ReadAll(b)\n    if err != nil {\n        t.Fatal(err)\n    }\n    actual := string(actualBytes)\n    if !(actual == expected) {\n        t.Fatalf(\"expected \\\"%s\\\" got \\\"%s\\\"\", expected, \n                actual)\n    }\n}\n```", "```go\naudiofile upload –filename list.go\n```", "```go\ntest:\n  go test ./... -tags pro\ntest-verbose:\n  go test –v ./... -tags pro\n```", "```go\nmake test\n```", "```go\ngo test ./cmd -tags pro\nok      github.com/marianina8/audiofile/cmd\n```"]