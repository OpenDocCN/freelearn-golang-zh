- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Custom Builds and Testing CLI Commands
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义构建和测试CLI命令
- en: With any Golang application, you’ll need to build and test. However, it is increasingly
    important as the project and its user base grow. Build tags with Boolean logic
    give you the ability to create targeted builds and testing and further stabilize
    your project with each new feature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Golang应用程序，您都需要构建和测试。然而，随着项目和用户基础的扩大，这变得越来越重要。使用布尔逻辑的构建标签使您能够创建有针对性的构建和测试，并随着每个新功能的推出进一步稳定您的项目。
- en: Given a deeper understanding of build tags and how to use them, we will use
    a real-world example, the audio file CLI, to integrate levels (free and pro) and
    enable a profiling feature.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在对构建标签及其使用方法有更深入的理解之后，我们将使用一个真实世界的示例，即音频文件CLI，来集成（免费和专业）级别并启用分析功能。
- en: 'Build tags are not only used as input when building but also when testing.
    We will spend the latter half of this chapter on testing. We will learn specifically
    how to mock an HTTP client that our CLI is using, configure tests locally, write
    tests for individual commands, and run them. In this chapter, we will cover the
    following topics in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 构建标签不仅在构建时用作输入，在测试时也用作输入。我们将在本章的后半部分专注于测试。我们将具体学习如何模拟CLI使用的HTTP客户端，在本地配置测试，为单个命令编写测试，并运行它们。在本章中，我们将详细介绍以下主题：
- en: What are build tags and how can you use them?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建标签是什么？您如何使用它们？
- en: Building with tags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签进行构建
- en: Testing CLI commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试CLI命令
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You’ll need a Unix operating system to understand and run the examples shared
    in the chapter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了理解并运行本章中分享的示例，您需要一个 Unix 操作系统。
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter11/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter11/audiofile)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以在GitHub上找到代码示例：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter11/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter11/audiofile)
- en: What are build tags and how can you use them?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建标签是什么？您如何使用它们？
- en: '**Build tags** are indicators of when a code file should be included within
    the build process. In Go, they are defined by a single line at the top, or near
    the top, of any source file, not just a Go file. They must precede the package
    clause and be followed by a blank line. They have the following syntax:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建标签**是代码文件在构建过程中应包含的指示符。在Go中，它们由任何源文件顶部或接近顶部的单行定义，而不仅仅是Go文件。它们必须位于包声明之前，并后跟一个空白行。它们具有以下语法：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line can only be defined once in a file. More than one definition would
    generate an error. However, when more than one tag is used, they interact using
    Boolean logic. In [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143), *Developing
    for Different Platforms*, we briefly touched on tags and their logic. The other
    method for handling the development of different platforms uses a series of `if-else`
    statements that check the operating system at runtime. Another method is to include
    the operating system in the filename. For example, if there’s a filename ending
    in `_windows.go`, we indicate to the compiler to only include this file when building
    for `windows`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行只能在文件中定义一次。如果有多个定义，将会生成错误。然而，当使用多个标签时，它们会通过布尔逻辑进行交互。在[*第7章*](B18883_07.xhtml#_idTextAnchor143)“为不同平台开发”中，我们简要介绍了标签及其逻辑。处理不同平台开发的另一种方法是使用一系列的`if-else`语句来检查运行时的操作系统。另一种方法是将在文件名中包含操作系统。例如，如果文件名以`_windows.go`结尾，我们指示编译器在构建`windows`时仅包含此文件。
- en: 'Tags can help separate code to include when compiling for different operating
    systems using `$GOOS` and `$GOARCH`. Valid combinations of operating systems and
    the architecture can be found here: [https://go.dev/doc/install/source#environment](https://go.dev/doc/install/source#environment).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以帮助在编译不同操作系统时分离代码，使用`$GOOS`和`$GOARCH`。操作系统和架构的有效组合可以在以下位置找到：[https://go.dev/doc/install/source#environment](https://go.dev/doc/install/source#environment)。
- en: Besides targeting platforms, build tags can be customized to separate featured
    code or integration tests. Often, integration tags receive a specific tag, as
    they often take a longer time to run. Separating unit tests from integration tests
    adds a level of control when testing your application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了针对平台外，构建标签还可以定制以分离功能代码或集成测试。通常，集成标签会收到一个特定的标签，因为它们通常需要更长的时间来运行。将单元测试与集成测试分离，在测试您的应用程序时增加了控制级别。
- en: 'These build constraints, when used together, can powerfully compile different
    versions of your code. As mentioned, they are evaluated together using Boolean
    logic. Expressions contain build tags combined using the `||`, `&&`, and `!` operators
    and parentheses. To learn more about build constraints, run the following command
    in your terminal:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构建约束组合使用时，可以强大地编译您代码的不同版本。如前所述，它们使用布尔逻辑一起评估。表达式包含使用 `||`、`&&` 和 `!` 运算符以及括号组合的构建标签。要了解更多关于构建约束的信息，请在您的终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As an example, the following build tags constrain a file to build when the
    `linux` or `openbsd` tags are satisfied and when `amd64` is satisfied and `cgo`
    is not:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下构建标签将文件约束为在满足 `linux` 或 `openbsd` 标签、满足 `amd64` 且 `cgo` 不满足时构建：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run `go` `env` in your terminal to see which tags are satisfied automatically
    when building your application. You’ll see the target operating system (`$GOOS`)
    and architecture (`$GOARCH`) and `unix` if the operating system is Unix or Unix-like.
    The `cgo` field is determined by the `CGO_ENABLED` environment variable, the term
    for each Go major release, and any additional tags given by the `–``tags` flag.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中运行 `go env` 命令，以查看在构建应用程序时哪些标签会自动满足。您将看到目标操作系统（`$GOOS`）、架构（`$GOARCH`）以及如果操作系统是
    Unix 或 Unix-like，则会显示 `unix`。`cgo` 字段由 `CGO_ENABLED` 环境变量、每个 Go 主要版本的术语以及通过 `–tags`
    标志提供的任何附加标签决定。
- en: As mentioned earlier, you can create your own pro and free versions based on
    tags placed at the top of code files, `//go:build pro` or `//go:build free`. Integration
    test files can be tagged with `//go:build int`, for example. However you want
    to customize your builds, you can do so with the power of tags and Boolean logic.
    Now, in the next section, let’s use tags in our code to do just that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以根据代码文件顶部的标签创建自己的专业版和免费版，例如 `//go:build pro` 或 `//go:build free`。集成测试文件可以标记为
    `//go:build int`。无论您如何想要自定义构建，都可以利用标签和布尔逻辑来实现。现在，在下一节中，让我们在我们的代码中使用标签来完成这项工作。
- en: How to utilize build tags
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何利用构建标签
- en: 'As mentioned, we can use build tags to separate builds based on the operating
    system and architecture. Within the audio file repository, we’re already doing
    so with the following files associated with the `play` and `bug` commands. For
    the `bug` command, we have the following files:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用构建标签根据操作系统和架构来分离构建。在音频文件存储库中，我们已经在以下文件中这样做，这些文件与 `play` 和 `bug` 命令相关联。对于
    `bug` 命令，我们有以下文件：
- en: '`bug_darwin.go //` only builds on Darwin systems'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bug_darwin.go //` 仅在 Darwin 系统上构建'
- en: '`bug_linux.go //` only builds on Linux systems'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bug_linux.go //` 仅在 Linux 系统上构建'
- en: '`bug_windows.go //` only builds on Windows platforms'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bug_windows.go //` 仅在 Windows 平台上构建'
- en: 'Each of those files contains a function that is specifically coded for the
    targeted platform. The file suffixes have similar functionality to the build tags.
    You can choose a file suffix that matches the exact platform and architecture.
    However, build tags are preferred when you want to target more than one platform
    and architecture. Inside the files is the matching build tag, used as an example,
    but duplicates functionality. Inside `bug_darwin.go`, for example, at the top
    of the file is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的每一个都包含一个针对目标平台专门编写的函数。文件后缀具有与构建标签类似的功能。您可以选择与确切平台和架构匹配的文件后缀。然而，当您想要针对多个平台和架构时，更倾向于使用构建标签。在文件内部，是匹配的构建标签，例如，在
    `bug_darwin.go` 文件中，文件顶部如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we already have these build tags set up throughout the repo to target
    platforms where needed, let’s explore a few other ways to utilize build tags.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在整个存储库中设置了这些构建标签，以针对需要的目标平台，让我们探索一些其他利用构建标签的方法。
- en: Creating a pro, free, and dev version
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建专业版、免费版和开发版
- en: Suppose the command-line interface utilized build tags to create different levels
    of access to the application’s features. This could be for admin or basic level
    users or restricted by the level of permissions, but it could also be, especially
    if the CLI was for external customers, a pro and free level version of your application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设命令行界面利用构建标签来创建对应用程序功能的不同访问级别。这可能适用于管理员或基本级别用户，或者根据权限级别进行限制，但如果是针对外部客户的 CLI，则可能是您应用程序的专业版和免费版。
- en: 'First, it’s important to decide which commands will be available for each version.
    Let’s give this a try with the audio file application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是决定每个版本将有哪些命令可用。让我们以音频文件应用程序为例来尝试一下：
- en: '![Table 11.1 – List of commands included in the free or pro level](img/Table_11.1_B18883.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![表11.1 – 包含在免费或专业级别的命令列表](img/Table_11.1_B18883.jpg)'
- en: Table 11.1 – List of commands included in the free or pro level
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 – 包含在免费或专业级别的命令列表
- en: Let’s also include a dev version; this simply allows the API to be run locally.
    In a real-world scenario, the application would be configured to call a public
    API, and storage could be done in a database. This gives us another build tag
    to create.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也包括一个开发版本；这仅仅允许API在本地运行。在实际场景中，应用程序将被配置为调用公共API，并且存储可以在数据库中完成。这为我们提供了另一个创建构建标签的理由。
- en: 'Now, let’s use build tags to distinguish the free, pro, and dev versions. The
    dev version build tag is placed at the top of the `cmd/api.go` file, making the
    API command only available when the `dev` tag is specified:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用构建标签来区分免费、专业和开发版本。开发版本构建标签放置在`cmd/api.go`文件的顶部，使得只有指定了`dev`标签时API命令才可用：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, the tag to distinguish the pro version is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，区分专业版本的标签如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a few files, as previously mentioned, that already have build tags
    to target platforms. This build tag means that the file will be available in the
    free, pro, and dev versions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有几个文件已经具有构建标签以针对平台。此构建标签意味着该文件将在免费、专业和开发版本中可用：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding build tags utilize Boolean logic to state that the file should
    be included in the build process when both the `darwin` and `free` tags are defined.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的构建标签利用布尔逻辑声明，当定义了`darwin`和`free`标签时，该文件应包含在构建过程中。
- en: 'Let’s break down the tags here with the Boolean logic syntax examples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用布尔逻辑语法示例来分解这里的标签：
- en: '![Table 11.2 – Boolean logic examples'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![表11.2 – 布尔逻辑示例](img/Table_11.2_B18883.jpg)'
- en: '](img/Table_11.2_B18883.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Table_11.2_B18883.jpg](img/Table_11.2_B18883.jpg)'
- en: Table 11.2 – Boolean logic examples
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 – 布尔逻辑示例
- en: This Boolean logic included within the build tag will allow developers to build
    for any combination of platforms and versions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构建标签内包含的布尔逻辑将允许开发者为任何平台和版本的组合进行构建。
- en: Adding build tags to enable pprof
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加构建标签以启用pprof
- en: Another way to utilize build tags is to enable profiling on your API service.
    `pprof` is a tool for visualizing and analyzing profile data. The tool reads a
    collection of samples in `proto`, or protocol buffer, format and then creates
    reports that help visualize and analyze the data. This tool can generate text
    and graphical reports.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 利用构建标签的另一种方法是启用API服务的分析。`pprof`是一个用于可视化和分析分析数据的工具。该工具读取`proto`或协议缓冲区格式的样本集合，然后创建有助于可视化和分析数据的报告。此工具可以生成文本和图形报告。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about how to use this tool, visit [https://pkg.go.dev/net/http/pprof](https://pkg.go.dev/net/http/pprof).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于如何使用此工具的信息，请访问[https://pkg.go.dev/net/http/pprof](https://pkg.go.dev/net/http/pprof)。
- en: 'For this case, we’ll define a build tag called `pprof` to appropriately match
    its usage. Within the `services/metadata/metadata.go` file, we define the metadata
    service used to extract information from the audio files uploaded via the command-line
    interface. The `CreateMetadataService` function creates the metadata service and
    defines all the endpoints with matching handlers. To enable profiling, we will
    add this new block of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例，我们将定义一个名为`pprof`的构建标签，以适当地匹配其使用。在`services/metadata/metadata.go`文件中，我们定义了用于从通过命令行界面上传的音频文件中提取信息的元数据服务。`CreateMetadataService`函数创建元数据服务并定义所有与匹配处理程序匹配的端点。为了启用分析，我们将添加以下新的代码块：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the top of the file, after the inputs, we’ll define the variable that it’s
    dependent on:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，输入之后，我们将定义它所依赖的变量：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, we need some way to set the `profile` variable to `true`. To do so,
    we create a new file: `services/metadata/pprof.go`. This file contains the following
    content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要某种方法来将`profile`变量设置为`true`。为此，我们创建了一个新文件：`services/metadata/pprof.go`。此文件包含以下内容：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, whether building the `free`, `pro`, or `dev` version, if the
    `profile` build tag is added as tag input, then the `init` function will be called
    to set the `profile` variable to `true`. Now, we have another idea of how to use
    build tags – to set Boolean variables that act as feature flags. Now that we’ve
    changed the necessary files to include the build tags, let’s use these as inputs
    to the build commands.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，无论构建`free`、`pro`还是`dev`版本，如果将`profile`构建标签作为标签输入添加，则`init`函数将被调用以将`profile`变量设置为`true`。现在，我们有了另一种使用构建标签的方法——设置作为功能标志的布尔变量。现在我们已经更改了必要的文件以包含构建标签，让我们将这些作为构建命令的输入。
- en: Building with tags
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带标签的构建
- en: 'By now, we have built our applications using `Makefile`, which contains the
    following command specific to building a Darwin application:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`Makefile`构建了我们的应用程序，其中包含以下特定于构建Darwin应用程序的命令：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For the Darwin build, we can additionally build a version for a free and pro
    version and also a profile version to enable `pprof`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Darwin构建，我们还可以构建一个免费版和专业版以及配置文件版以启用`pprof`。
- en: Building a free version
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建免费版
- en: 'To build a `free` version for the Darwin operating system, we need to modify
    the preceding `make` command and create a new one:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Darwin操作系统构建一个`free`版本，我们需要修改前面的`make`命令并创建一个新的命令：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `build-darwin-free` command, we pass in the two build tags: `darwin`
    and `free`. This will include files such as `bug_darwin.go` and `play_darwin.go`,
    which contain the following line at the top of the Go file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build-darwin-free`命令中，我们传递了两个构建标签：`darwin`和`free`。这将包括如`bug_darwin.go`和`play_darwin.go`等文件，这些文件在Go文件顶部包含以下行：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similarly, the files will be included in the build when we build the `pro` version.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当构建`pro`版本时，文件也会被包含在构建中。
- en: Building a pro version
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建专业版
- en: 'To build a `pro` version for the Darwin operating system, we need to add a
    new `build` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Darwin操作系统构建一个`pro`版本，我们需要添加一个新的`build`命令：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `build-darwin-pro` command, we pass in the two build tags: `darwin`
    and `pro`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build-darwin-pro`命令中，我们传递了两个构建标签：`darwin`和`pro`。
- en: Building to enable pprof on the pro version
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在专业版上启用pprof的构建
- en: 'To build a `pro` version that has `pprof` enabled, we add the following `build`
    command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个启用了`pprof`的`pro`版本，我们需要添加以下`build`命令：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `build-darwin-pro-profile` command, we pass three build tags: `darwin`,
    `pro`, and `profile`. This will include the `services/metadata/pprof.go` file,
    which includes the line at the top of the file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build-darwin-pro-profile`命令中，我们传递了三个构建标签：`darwin`、`pro`和`profile`。这将包括`services/metadata/pprof.go`文件，该文件包含文件顶部的以下行：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similarly, the files will be included in the build when we build for the free
    version.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当为免费版构建时，文件也会被包含在构建中。
- en: At this point, we’ve learned what build tags are, the different ways to use
    build tags within your code, and, finally, how to build applications targeted
    to specific uses using build tags. Specifically, while build tags can be used
    to define different levels of features available (free versus pro), you can also
    enable profiling or any other debug tooling using build tags. Now that we have
    understood how to build our command-line application for different targets, let’s
    learn how to test our CLI commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了构建标签是什么，如何在代码中使用构建标签的不同方式，以及最后如何使用构建标签构建针对特定用途的应用程序。具体来说，虽然构建标签可以用来定义不同级别的功能（免费版与专业版），但你也可以使用构建标签启用性能分析或其他调试工具。现在我们已经了解了如何为不同的目标构建我们的命令行应用程序，接下来让我们学习如何测试我们的CLI命令。
- en: Testing CLI commands
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试CLI命令
- en: 'While building your command-line application, it’s important to also build
    testing around it so you can ensure that the application works as expected. There
    are a few things that typically need to be done, including the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建你的命令行应用程序时，围绕它构建测试也很重要，这样你可以确保应用程序按预期工作。通常需要做一些事情，包括以下内容：
- en: Mock the HTTP client
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟HTTP客户端
- en: Handle test configuration
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理测试配置
- en: Create a test for each command
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个命令创建测试
- en: We’ll go over the code for each of these steps that exist in the audio file
    repository for [*Chapter 11*](B18883_11.xhtml#_idTextAnchor258).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾音频文件仓库中[*第11章*](B18883_11.xhtml#_idTextAnchor258)中存在的每个步骤的代码。
- en: Mocking the HTTP client
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟HTTP客户端
- en: To mock the HTTP client, we’ll need to create an interface to mimic the client’s
    `Do` method, as well as a function that returns this interface, which is both
    satisfied by the real and mocked client.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟HTTP客户端，我们需要创建一个接口来模拟客户端的`Do`方法，以及一个返回此接口的函数，这个接口既满足真实客户端也满足模拟客户端。
- en: 'In the `cmd/client.go` file, we’ve written some code to handle all of this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cmd/client.go`文件中，我们编写了一些代码来处理所有这些：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now easily create a mock client by replacing the `getClient` variable
    with a function that returns a mocked client. If you look at each command’s code,
    it uses the `getClient` variable. For example, the `upload.go` file calls the
    `Do` method with the following line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地通过将`getClient`变量替换为一个返回模拟客户端的函数来创建一个模拟客户端。如果你查看每个命令的代码，它会使用`getClient`变量。例如，`upload.go`文件使用以下行调用`Do`方法：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the application runs, this returns the actual HTTP client with a 15-second
    timeout. However, in each test, we’ll set the `getClient` variable to a mocked
    HTTP client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，这返回具有 15 秒超时的实际 HTTP 客户端。然而，在每次测试中，我们将 `getClient` 变量设置为模拟的 HTTP 客户端。
- en: 'The mocked HTTP client is set in the `cmd/client_test.go` file. First, we define
    the type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 被模拟的 HTTP 客户端设置在 `cmd/client_test.go` 文件中。首先，我们定义类型：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, to satisfy the `AudiofileClient` interface previously defined, we implement
    the `Do` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了满足之前定义的 `AudiofileClient` 接口，我们实现了 `Do` 方法：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some of the requests, including `list`, `get`, and `search` endpoints, will
    return data that is stored in JSON files under the `cmd/testfiles` folder. We
    read these files and store them in the corresponding byte slices: `listBytes`,
    `getBytes`, and `searchBytes`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些请求，包括 `list`、`get` 和 `search` 端点，将返回存储在 `cmd/testfiles` 文件夹下 JSON 文件中的数据。我们读取这些文件并将它们存储在相应的字节切片中：`listBytes`、`getBytes`
    和 `searchBytes`：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The data read from these files is used within the response. Since the `Do`
    method receives the request, we can create a switch case for each request endpoint
    and then handle the response individually. You can create more detailed cases
    to handle errors, but in this case, we are only returning the successful case.
    For the first case, the `/request` endpoint, we return `200 OK`, but the body
    of the response also contains the string value from `getBytes`. You can see the
    actual data in the `./``testfiles/get.json` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些文件中读取的数据用于响应中。由于 `Do` 方法接收请求，我们可以为每个请求端点创建一个 switch case，然后单独处理响应。你可以创建更详细的
    case 来处理错误，但在这个例子中，我们只返回成功的 case。对于第一个 case，即 `/request` 端点，我们返回 `200 OK`，但响应体中也包含从
    `getBytes` 获取的字符串值。你可以在 `./testfiles/get.json` 文件中看到实际数据：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the `/upload` endpoint, we return `200 OK`, but the body of the response
    also contains the `"123"` string value:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `/upload` 端点，我们返回 `200 OK`，但响应体中也包含 `"123"` 字符串值：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `/list` endpoint, we return `200 OK`, but the body of the response
    also contains the string value from `listBytes`. You can see the actual data in
    the `./``testfiles/list.json` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `/list` 端点，我们返回 `200 OK`，但响应体中也包含从 `listBytes` 获取的字符串值。你可以在 `./testfiles/list.json`
    文件中看到实际数据：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the `/delete` endpoint, we return `200 OK`, but the body of the response
    also contains `"successfully deleted audio with` `id: 456"`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 `/delete` 端点，我们返回 `200 OK`，但响应体中也包含 `"成功删除音频，id: 456"`：'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For the `/search` endpoint, we return `200 OK`, but the body of the response
    also contains the string value from `searchBytes`. You can see the actual data
    in the `./``testfiles/search.json` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `/search` 端点，我们返回 `200 OK`，但响应体中也包含从 `searchBytes` 获取的字符串值。你可以在 `./testfiles/search.json`
    文件中看到实际数据：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, if the request path doesn’t match any of the endpoints in the `switch`
    statement, then an empty response is returned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果请求路径与 `switch` 语句中的任何端点都不匹配，则返回空响应。
- en: Handling test configuration
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理测试配置
- en: 'We handle the test configuration in the `cmd/root_test.go` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `cmd/root_test.go` 文件中处理测试配置：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Within the `ConfigureTest` function, we set the `getClient` variable to a pointer
    to the `ClientMock` type. Because the `viper` configuration values are checked
    when the command is called, we set some default values for the CLI’s hostname
    and port to random test values. Finally, in this file, the regular logger, `Logger`,
    and verbose logger, `Verbose`, are both defined and then later initialized by
    the `utils.InitCLILogger()` method call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ConfigureTest` 函数中，我们将 `getClient` 变量设置为 `ClientMock` 类型的指针。因为当调用命令时检查 `viper`
    配置值，所以我们为 CLI 的主机名和端口设置了随机测试值作为默认值。最后，在这个文件中，常规日志记录器 `Logger` 和详细日志记录器 `Verbose`
    都被定义，然后通过 `utils.InitCLILogger()` 方法调用进行初始化。
- en: Creating a test for a command
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为命令创建测试
- en: 'Now that we have the mocked client, configuration, and loggers set up, let’s
    create a test for the commands. Before I dive into the code for each, it’s important
    to mention the line of code that’s reused at the start of each test:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了模拟客户端、配置和日志记录器，让我们为命令创建一个测试。在我深入到每个测试的代码之前，重要的是要提到每个测试开始时重复使用的代码行：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding section discusses the details of this function, but it prepares
    each state with a mocked client, default configuration values, and initialized
    loggers. In our examples, we use the `testing` package, which provides support
    for automated tests in Go. It is designed to be used in concert with the `go test`
    command, which executes any function in your code defined with the following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节讨论了这个函数的细节，但它为每个状态准备了一个模拟客户端、默认配置值和初始化的日志记录器。在我们的示例中，我们使用了`testing`包，它为Go中的自动化测试提供支持。它被设计为与`go
    test`命令一起使用，该命令执行代码中定义的任何函数，格式如下：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Xxx` can be replaced with anything else, but the first character needs to
    be capital. The name itself is used to identify the type of test that is being
    executed. I won’t go into each individual test, just three as examples. To view
    the entirety of tests, visit the audio file repository for this chapter.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xxx`可以用任何其他东西替换，但第一个字符需要是大写。这个名字本身用来识别正在执行的测试类型。我不会逐一介绍每个测试，只举三个作为例子。要查看所有测试，请访问本章的音频文件仓库。'
- en: Testing the bug command
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试bug命令
- en: 'The function for testing the `bug` command is defined here. It takes a single
    parameter, which is a pointer to the `testing.T` type, and fits the function format
    defined in the last section. Let’s break down the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`bug`命令的函数定义在这里。它接受一个参数，即指向`testing.T`类型的指针，并符合上一节中定义的函数格式。让我们分析一下代码：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this function, we first define the output buffer, `b`, which we can later
    read for comparison to the expected output. We set the arguments using the `SetArgs`
    method and pass in an unexpected argument. The command is executed with the `rootCmd.Execute()`
    method and the actual result is read from the buffer and saved in the `actualBytes`
    variable. The expected output is stored within the `./testfiles/bug.txt` file
    and is read into the `expectedBytes` variable. We compare these values to ensure
    that they are equal. Since we passed in an unexpected argument, the command usage
    is printed out. This test is designed to pass; however, if the trimmed strings
    are not equal, the test fails.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先定义输出缓冲区`b`，稍后我们可以从中读取以与预期输出进行比较。我们使用`SetArgs`方法设置参数并传递一个意外的参数。命令通过`rootCmd.Execute()`方法执行，实际结果从缓冲区中读取并保存到`actualBytes`变量中。预期的输出存储在`./testfiles/bug.txt`文件中，并读取到`expectedBytes`变量中。我们比较这些值以确保它们相等。由于我们传递了一个意外的参数，因此打印出命令用法。这个测试被设计为通过；然而，如果修剪后的字符串不相等，则测试失败。
- en: Testing the get command
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试获取命令
- en: 'The function for testing the `get` command is defined here. Similarly, the
    function definition fits the format to be picked up in the `go test` command.
    Remember the mocked client and that the `get` command calls the `/request` endpoint.
    The response body contains the value found in the `./testfiles/get.json` file.
    Let’s break down the code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`get`命令的函数定义在这里。同样，函数定义符合`go test`命令可以识别的格式。记住模拟客户端和`get`命令调用`/request`端点。响应体包含在`./testfiles/get.json`文件中找到的值。让我们分析一下代码：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We pass in the following arguments to mimic the `audiofile get –id 123 –``json`
    call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递以下参数来模拟`audiofile get –id 123 –``json`调用：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We execute the root command with the preceding arguments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的参数执行root命令：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We read the actual data output from `rootCmd`’s execution and store it in the
    `actualBytes` variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`rootCmd`的执行中读取实际的数据输出并将其存储在`actualBytes`变量中：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We read the expected data output from the `./``testfiles/get.json` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`./``testfiles/get.json`文件中读取预期的数据输出：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, the data of both `actualBytes` and `expectedBytes` is unmarshalled into
    the `models.Audio` struct and then compared:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`actualBytes`和`expectedBytes`的数据反序列化到`models.Audio`结构体中，然后进行比较：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This test was designed to succeed, but if the data is not as expected, then
    the test fails.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试被设计为成功，但如果数据不符合预期，则测试失败。
- en: Testing the upload command
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试上传命令
- en: 'The function for testing the `upload` command is defined here. Again, the function
    definition fits the format to be picked up in the `go test` command. Remember
    the mocked client and that the `upload` command calls the `/upload` endpoint with
    a mocked response body containing the `"123"` value. Let’s break down the code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`upload`命令的函数定义在这里。同样，函数定义符合`go test`命令可以识别的格式。记住模拟客户端和`upload`命令调用`/upload`端点，带有包含`"123"`值的模拟响应体。让我们分析一下代码：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`rootCmd`’s arguments are set to mimic the following command call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`rootCmd`的参数被设置为模拟以下命令调用：'
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The file type and data are not validated because that happens on the API side,
    which is mocked. However, since we know the body of the response contains the
    `123` value, we set the expected variable to `123`. The `actual` value, which
    contains the output of the command execution, is then later compared to the expected
    one. The test is designed for success, but if the values are not equal, then the
    test fails.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型和数据没有经过验证，因为那是在 API 端进行的，这里进行了模拟。然而，由于我们知道响应体包含 `123` 值，我们将期望变量设置为 `123`。然后，包含命令执行输出的
    `actual` 值随后与期望值进行比较。测试被设计为成功，但如果值不相等，则测试失败。
- en: We’ve now gone over several examples of how to test a CLI Cobra command. You
    can now create your own tests for your CLI, by mocking your own HTTP client and
    creating tests for each individual command. We haven’t done so in this chapter,
    but it’s good to know that build tags can also be used to separate different kinds
    of tests – for example, integration tests and unit tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何测试 CLI Cobra 命令的几个示例。现在，你可以通过模拟自己的 HTTP 客户端并为每个单独的命令创建测试来为你的 CLI 创建自己的测试。我们在这个章节中没有这样做，但了解构建标签也可以用来区分不同类型的测试是很有用的——例如，集成测试和单元测试。
- en: Running the tests
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'To test your commands, you can run `go test` and pass in a few additional flags:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的命令，你可以运行 `go test` 并传递一些额外的标志：
- en: '`-v` for verbose mode'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 用于详细模式'
- en: '`-tags` for any files you want to specifically target'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-tags` 用于指定你想要特别针对的任何文件'
- en: 'In our test, we want to target just the `pro` build tag because that will cover
    all commands. We add two additional `Makefile` commands, one to run tests in verbose
    mode and one that doesn’t:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们只想针对 `pro` 构建标签，因为这将涵盖所有命令。我们添加了两个额外的 `Makefile` 命令，一个用于以详细模式运行测试，另一个则不是：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After saving the `Makefile` from the terminal, you can execute the command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在从终端保存 `Makefile` 之后，你可以执行以下命令：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following output is expected:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We now know how to run the tests utilizing build tags as well. This should be
    all the tools needed to run your own CLI testing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何利用构建标签来运行测试。这应该是运行你自己的 CLI 测试所需的所有工具。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what build tags are and how to use them for different
    purposes. Build tags can be used for generating builds of different levels, separating
    our specific tests, or adding debug features. You also learned how to generate
    builds with the build tags that you added to the top of your files and how to
    utilize the Boolean logic of tags to quickly determine whether files will or won’t
    be included.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了构建标签是什么以及如何用于不同的目的。构建标签可以用来生成不同级别的构建，分离我们的特定测试，或者添加调试功能。你还学习了如何生成带有你添加到文件顶部的构建标签的构建，以及如何利用标签的布尔逻辑来快速确定文件是否会被包含。
- en: 'You also learned how to test your Cobra CLI commands with Golang’s default
    `testing` package. Some necessary tools were also included, such as learning how
    to mock an HTTP client. Together with the build tags, you can now not only build
    targeted applications with tags but also run tests with the same tags to target
    specific tests. In the next chapter, [*Chapter 12*](B18883_12.xhtml#_idTextAnchor291),
    *Cross-Compilation Across Different Platforms*, we will learn how to use these
    tags and compile for the different major operating systems: `darwin`, `linux`,
    and `windows`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何使用 Golang 的默认 `testing` 包来测试你的 Cobra CLI 命令。一些必要的工具也被包括在内，比如学习如何模拟 HTTP
    客户端。结合构建标签，你现在不仅可以使用标签构建目标应用程序，还可以使用相同的标签运行测试以针对特定的测试。在下一章，[*第 12 章*](B18883_12.xhtml#_idTextAnchor291)，*跨平台交叉编译*，我们将学习如何使用这些标签并为不同的主要操作系统编译：`darwin`、`linux`
    和 `windows`。
- en: Questions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Where does the build tag go in a Golang file and what is the syntax?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建标签在 Golang 文件中的位置在哪里，语法是什么？
- en: What flag is used for both `go build` and `go test` to pass in the build tags?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于 `go build` 和 `go test` 的哪个标志用于传递构建标签？
- en: What build tag could you place on an integration test Golang file and how would
    you run `go test` with the tag?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在集成测试的 Golang 文件上放置哪个构建标签，以及如何使用该标签运行 `go test`？
- en: Answers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'It’s placed at the top of the file, before the package declaration, followed
    by a single empty line. The syntax is: `//``go:build [tag]`.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它位于文件顶部，在包声明之前，后面跟着一个单独的空行。语法是：`//``go:build [tag]`。
- en: The `–tags` flag is used to pass in build tags for both the `go build` and `go`
    `test` methods.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`–tags` 标志用于传递 `go build` 和 `go test` 方法中的构建标签。'
- en: 'You could add the `//go:build int` build tag at the top of any integration
    test file, and then modify the test file to run this command: `go test ./cmd -tags
    "``pro int"`.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在任何集成测试文件顶部添加`//go:build int`构建标签，然后修改测试文件以运行此命令：`go test ./cmd -tags "pro
    int"`。
- en: Further reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Read more about the `build` package at [https://pkg.go.dev/go/build](https://pkg.go.dev/go/build),
    and read more about the `testing` package at [https://pkg.go.dev/testing](https://pkg.go.dev/testing)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://pkg.go.dev/go/build](https://pkg.go.dev/go/build)了解更多关于`build`包的信息，在[https://pkg.go.dev/testing](https://pkg.go.dev/testing)了解更多关于`testing`包的信息。
