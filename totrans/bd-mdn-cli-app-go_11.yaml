- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Builds and Testing CLI Commands
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any Golang application, you’ll need to build and test. However, it is increasingly
    important as the project and its user base grow. Build tags with Boolean logic
    give you the ability to create targeted builds and testing and further stabilize
    your project with each new feature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Given a deeper understanding of build tags and how to use them, we will use
    a real-world example, the audio file CLI, to integrate levels (free and pro) and
    enable a profiling feature.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Build tags are not only used as input when building but also when testing.
    We will spend the latter half of this chapter on testing. We will learn specifically
    how to mock an HTTP client that our CLI is using, configure tests locally, write
    tests for individual commands, and run them. In this chapter, we will cover the
    following topics in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What are build tags and how can you use them?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building with tags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing CLI commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll need a Unix operating system to understand and run the examples shared
    in the chapter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter11/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter11/audiofile)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are build tags and how can you use them?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Build tags** are indicators of when a code file should be included within
    the build process. In Go, they are defined by a single line at the top, or near
    the top, of any source file, not just a Go file. They must precede the package
    clause and be followed by a blank line. They have the following syntax:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line can only be defined once in a file. More than one definition would
    generate an error. However, when more than one tag is used, they interact using
    Boolean logic. In [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143), *Developing
    for Different Platforms*, we briefly touched on tags and their logic. The other
    method for handling the development of different platforms uses a series of `if-else`
    statements that check the operating system at runtime. Another method is to include
    the operating system in the filename. For example, if there’s a filename ending
    in `_windows.go`, we indicate to the compiler to only include this file when building
    for `windows`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Tags can help separate code to include when compiling for different operating
    systems using `$GOOS` and `$GOARCH`. Valid combinations of operating systems and
    the architecture can be found here: [https://go.dev/doc/install/source#environment](https://go.dev/doc/install/source#environment).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Besides targeting platforms, build tags can be customized to separate featured
    code or integration tests. Often, integration tags receive a specific tag, as
    they often take a longer time to run. Separating unit tests from integration tests
    adds a level of control when testing your application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'These build constraints, when used together, can powerfully compile different
    versions of your code. As mentioned, they are evaluated together using Boolean
    logic. Expressions contain build tags combined using the `||`, `&&`, and `!` operators
    and parentheses. To learn more about build constraints, run the following command
    in your terminal:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As an example, the following build tags constrain a file to build when the
    `linux` or `openbsd` tags are satisfied and when `amd64` is satisfied and `cgo`
    is not:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run `go` `env` in your terminal to see which tags are satisfied automatically
    when building your application. You’ll see the target operating system (`$GOOS`)
    and architecture (`$GOARCH`) and `unix` if the operating system is Unix or Unix-like.
    The `cgo` field is determined by the `CGO_ENABLED` environment variable, the term
    for each Go major release, and any additional tags given by the `–``tags` flag.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, you can create your own pro and free versions based on
    tags placed at the top of code files, `//go:build pro` or `//go:build free`. Integration
    test files can be tagged with `//go:build int`, for example. However you want
    to customize your builds, you can do so with the power of tags and Boolean logic.
    Now, in the next section, let’s use tags in our code to do just that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How to utilize build tags
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned, we can use build tags to separate builds based on the operating
    system and architecture. Within the audio file repository, we’re already doing
    so with the following files associated with the `play` and `bug` commands. For
    the `bug` command, we have the following files:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`bug_darwin.go //` only builds on Darwin systems'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bug_linux.go //` only builds on Linux systems'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bug_windows.go //` only builds on Windows platforms'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of those files contains a function that is specifically coded for the
    targeted platform. The file suffixes have similar functionality to the build tags.
    You can choose a file suffix that matches the exact platform and architecture.
    However, build tags are preferred when you want to target more than one platform
    and architecture. Inside the files is the matching build tag, used as an example,
    but duplicates functionality. Inside `bug_darwin.go`, for example, at the top
    of the file is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we already have these build tags set up throughout the repo to target
    platforms where needed, let’s explore a few other ways to utilize build tags.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pro, free, and dev version
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose the command-line interface utilized build tags to create different levels
    of access to the application’s features. This could be for admin or basic level
    users or restricted by the level of permissions, but it could also be, especially
    if the CLI was for external customers, a pro and free level version of your application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it’s important to decide which commands will be available for each version.
    Let’s give this a try with the audio file application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 11.1 – List of commands included in the free or pro level](img/Table_11.1_B18883.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Table 11.1 – List of commands included in the free or pro level
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also include a dev version; this simply allows the API to be run locally.
    In a real-world scenario, the application would be configured to call a public
    API, and storage could be done in a database. This gives us another build tag
    to create.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use build tags to distinguish the free, pro, and dev versions. The
    dev version build tag is placed at the top of the `cmd/api.go` file, making the
    API command only available when the `dev` tag is specified:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, the tag to distinguish the pro version is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a few files, as previously mentioned, that already have build tags
    to target platforms. This build tag means that the file will be available in the
    free, pro, and dev versions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding build tags utilize Boolean logic to state that the file should
    be included in the build process when both the `darwin` and `free` tags are defined.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the tags here with the Boolean logic syntax examples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 11.2 – Boolean logic examples'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_11.2_B18883.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.2 – Boolean logic examples
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: This Boolean logic included within the build tag will allow developers to build
    for any combination of platforms and versions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Adding build tags to enable pprof
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to utilize build tags is to enable profiling on your API service.
    `pprof` is a tool for visualizing and analyzing profile data. The tool reads a
    collection of samples in `proto`, or protocol buffer, format and then creates
    reports that help visualize and analyze the data. This tool can generate text
    and graphical reports.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about how to use this tool, visit [https://pkg.go.dev/net/http/pprof](https://pkg.go.dev/net/http/pprof).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'For this case, we’ll define a build tag called `pprof` to appropriately match
    its usage. Within the `services/metadata/metadata.go` file, we define the metadata
    service used to extract information from the audio files uploaded via the command-line
    interface. The `CreateMetadataService` function creates the metadata service and
    defines all the endpoints with matching handlers. To enable profiling, we will
    add this new block of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the top of the file, after the inputs, we’ll define the variable that it’s
    dependent on:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, we need some way to set the `profile` variable to `true`. To do so,
    we create a new file: `services/metadata/pprof.go`. This file contains the following
    content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, whether building the `free`, `pro`, or `dev` version, if the
    `profile` build tag is added as tag input, then the `init` function will be called
    to set the `profile` variable to `true`. Now, we have another idea of how to use
    build tags – to set Boolean variables that act as feature flags. Now that we’ve
    changed the necessary files to include the build tags, let’s use these as inputs
    to the build commands.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Building with tags
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we have built our applications using `Makefile`, which contains the
    following command specific to building a Darwin application:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For the Darwin build, we can additionally build a version for a free and pro
    version and also a profile version to enable `pprof`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Building a free version
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a `free` version for the Darwin operating system, we need to modify
    the preceding `make` command and create a new one:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `build-darwin-free` command, we pass in the two build tags: `darwin`
    and `free`. This will include files such as `bug_darwin.go` and `play_darwin.go`,
    which contain the following line at the top of the Go file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similarly, the files will be included in the build when we build the `pro` version.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Building a pro version
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a `pro` version for the Darwin operating system, we need to add a
    new `build` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `build-darwin-pro` command, we pass in the two build tags: `darwin`
    and `pro`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Building to enable pprof on the pro version
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a `pro` version that has `pprof` enabled, we add the following `build`
    command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `build-darwin-pro-profile` command, we pass three build tags: `darwin`,
    `pro`, and `profile`. This will include the `services/metadata/pprof.go` file,
    which includes the line at the top of the file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similarly, the files will be included in the build when we build for the free
    version.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve learned what build tags are, the different ways to use
    build tags within your code, and, finally, how to build applications targeted
    to specific uses using build tags. Specifically, while build tags can be used
    to define different levels of features available (free versus pro), you can also
    enable profiling or any other debug tooling using build tags. Now that we have
    understood how to build our command-line application for different targets, let’s
    learn how to test our CLI commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Testing CLI commands
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building your command-line application, it’s important to also build
    testing around it so you can ensure that the application works as expected. There
    are a few things that typically need to be done, including the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Mock the HTTP client
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle test configuration
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test for each command
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll go over the code for each of these steps that exist in the audio file
    repository for [*Chapter 11*](B18883_11.xhtml#_idTextAnchor258).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the HTTP client
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To mock the HTTP client, we’ll need to create an interface to mimic the client’s
    `Do` method, as well as a function that returns this interface, which is both
    satisfied by the real and mocked client.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `cmd/client.go` file, we’ve written some code to handle all of this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now easily create a mock client by replacing the `getClient` variable
    with a function that returns a mocked client. If you look at each command’s code,
    it uses the `getClient` variable. For example, the `upload.go` file calls the
    `Do` method with the following line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the application runs, this returns the actual HTTP client with a 15-second
    timeout. However, in each test, we’ll set the `getClient` variable to a mocked
    HTTP client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The mocked HTTP client is set in the `cmd/client_test.go` file. First, we define
    the type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, to satisfy the `AudiofileClient` interface previously defined, we implement
    the `Do` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some of the requests, including `list`, `get`, and `search` endpoints, will
    return data that is stored in JSON files under the `cmd/testfiles` folder. We
    read these files and store them in the corresponding byte slices: `listBytes`,
    `getBytes`, and `searchBytes`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The data read from these files is used within the response. Since the `Do`
    method receives the request, we can create a switch case for each request endpoint
    and then handle the response individually. You can create more detailed cases
    to handle errors, but in this case, we are only returning the successful case.
    For the first case, the `/request` endpoint, we return `200 OK`, but the body
    of the response also contains the string value from `getBytes`. You can see the
    actual data in the `./``testfiles/get.json` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the `/upload` endpoint, we return `200 OK`, but the body of the response
    also contains the `"123"` string value:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `/list` endpoint, we return `200 OK`, but the body of the response
    also contains the string value from `listBytes`. You can see the actual data in
    the `./``testfiles/list.json` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the `/delete` endpoint, we return `200 OK`, but the body of the response
    also contains `"successfully deleted audio with` `id: 456"`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For the `/search` endpoint, we return `200 OK`, but the body of the response
    also contains the string value from `searchBytes`. You can see the actual data
    in the `./``testfiles/search.json` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, if the request path doesn’t match any of the endpoints in the `switch`
    statement, then an empty response is returned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Handling test configuration
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We handle the test configuration in the `cmd/root_test.go` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Within the `ConfigureTest` function, we set the `getClient` variable to a pointer
    to the `ClientMock` type. Because the `viper` configuration values are checked
    when the command is called, we set some default values for the CLI’s hostname
    and port to random test values. Finally, in this file, the regular logger, `Logger`,
    and verbose logger, `Verbose`, are both defined and then later initialized by
    the `utils.InitCLILogger()` method call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test for a command
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the mocked client, configuration, and loggers set up, let’s
    create a test for the commands. Before I dive into the code for each, it’s important
    to mention the line of code that’s reused at the start of each test:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding section discusses the details of this function, but it prepares
    each state with a mocked client, default configuration values, and initialized
    loggers. In our examples, we use the `testing` package, which provides support
    for automated tests in Go. It is designed to be used in concert with the `go test`
    command, which executes any function in your code defined with the following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Xxx` can be replaced with anything else, but the first character needs to
    be capital. The name itself is used to identify the type of test that is being
    executed. I won’t go into each individual test, just three as examples. To view
    the entirety of tests, visit the audio file repository for this chapter.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Testing the bug command
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function for testing the `bug` command is defined here. It takes a single
    parameter, which is a pointer to the `testing.T` type, and fits the function format
    defined in the last section. Let’s break down the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this function, we first define the output buffer, `b`, which we can later
    read for comparison to the expected output. We set the arguments using the `SetArgs`
    method and pass in an unexpected argument. The command is executed with the `rootCmd.Execute()`
    method and the actual result is read from the buffer and saved in the `actualBytes`
    variable. The expected output is stored within the `./testfiles/bug.txt` file
    and is read into the `expectedBytes` variable. We compare these values to ensure
    that they are equal. Since we passed in an unexpected argument, the command usage
    is printed out. This test is designed to pass; however, if the trimmed strings
    are not equal, the test fails.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Testing the get command
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function for testing the `get` command is defined here. Similarly, the
    function definition fits the format to be picked up in the `go test` command.
    Remember the mocked client and that the `get` command calls the `/request` endpoint.
    The response body contains the value found in the `./testfiles/get.json` file.
    Let’s break down the code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We pass in the following arguments to mimic the `audiofile get –id 123 –``json`
    call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We execute the root command with the preceding arguments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We read the actual data output from `rootCmd`’s execution and store it in the
    `actualBytes` variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We read the expected data output from the `./``testfiles/get.json` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, the data of both `actualBytes` and `expectedBytes` is unmarshalled into
    the `models.Audio` struct and then compared:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This test was designed to succeed, but if the data is not as expected, then
    the test fails.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Testing the upload command
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function for testing the `upload` command is defined here. Again, the function
    definition fits the format to be picked up in the `go test` command. Remember
    the mocked client and that the `upload` command calls the `/upload` endpoint with
    a mocked response body containing the `"123"` value. Let’s break down the code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`rootCmd`’s arguments are set to mimic the following command call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The file type and data are not validated because that happens on the API side,
    which is mocked. However, since we know the body of the response contains the
    `123` value, we set the expected variable to `123`. The `actual` value, which
    contains the output of the command execution, is then later compared to the expected
    one. The test is designed for success, but if the values are not equal, then the
    test fails.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now gone over several examples of how to test a CLI Cobra command. You
    can now create your own tests for your CLI, by mocking your own HTTP client and
    creating tests for each individual command. We haven’t done so in this chapter,
    but it’s good to know that build tags can also be used to separate different kinds
    of tests – for example, integration tests and unit tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test your commands, you can run `go test` and pass in a few additional flags:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` for verbose mode'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-tags` for any files you want to specifically target'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our test, we want to target just the `pro` build tag because that will cover
    all commands. We add two additional `Makefile` commands, one to run tests in verbose
    mode and one that doesn’t:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After saving the `Makefile` from the terminal, you can execute the command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following output is expected:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We now know how to run the tests utilizing build tags as well. This should be
    all the tools needed to run your own CLI testing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what build tags are and how to use them for different
    purposes. Build tags can be used for generating builds of different levels, separating
    our specific tests, or adding debug features. You also learned how to generate
    builds with the build tags that you added to the top of your files and how to
    utilize the Boolean logic of tags to quickly determine whether files will or won’t
    be included.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'You also learned how to test your Cobra CLI commands with Golang’s default
    `testing` package. Some necessary tools were also included, such as learning how
    to mock an HTTP client. Together with the build tags, you can now not only build
    targeted applications with tags but also run tests with the same tags to target
    specific tests. In the next chapter, [*Chapter 12*](B18883_12.xhtml#_idTextAnchor291),
    *Cross-Compilation Across Different Platforms*, we will learn how to use these
    tags and compile for the different major operating systems: `darwin`, `linux`,
    and `windows`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where does the build tag go in a Golang file and what is the syntax?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What flag is used for both `go build` and `go test` to pass in the build tags?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What build tag could you place on an integration test Golang file and how would
    you run `go test` with the tag?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s placed at the top of the file, before the package declaration, followed
    by a single empty line. The syntax is: `//``go:build [tag]`.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `–tags` flag is used to pass in build tags for both the `go build` and `go`
    `test` methods.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could add the `//go:build int` build tag at the top of any integration
    test file, and then modify the test file to run this command: `go test ./cmd -tags
    "``pro int"`.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在任何集成测试文件顶部添加`//go:build int`构建标签，然后修改测试文件以运行此命令：`go test ./cmd -tags "pro
    int"`。
- en: Further reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Read more about the `build` package at [https://pkg.go.dev/go/build](https://pkg.go.dev/go/build),
    and read more about the `testing` package at [https://pkg.go.dev/testing](https://pkg.go.dev/testing)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://pkg.go.dev/go/build](https://pkg.go.dev/go/build)了解更多关于`build`包的信息，在[https://pkg.go.dev/testing](https://pkg.go.dev/testing)了解更多关于`testing`包的信息。
