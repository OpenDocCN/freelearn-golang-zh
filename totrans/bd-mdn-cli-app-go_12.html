<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-242" class="chapter-number"><a id="_idTextAnchor291"/>12</h1>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor292"/>Cross-Compilation across Different Platforms</h1>
			<p>This chapter introduces the user to cross-compilation, a powerful feature of Go, across different platforms. While build automation tools exist, understanding how to cross-compile provides essential knowledge for debugging and customization when necessary. This chapter will explain the different operating systems and architectures that Go can compile and how to determine which is needed. After Go is installed in your environment, there is a command, <strong class="source-inline">go env</strong>, with which you can see all the Go-related environment variables. We will discuss the two major ones used for building: <strong class="source-inline">GOOS</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">GOARCH</strong></span><span class="No-Break">.</span></p>
			<p>We will give examples of how to build or install an application for each major operating system: Linux, macOS, and Windows. You will learn how to determine the Go operating system and architecture settings based on your environment and the available architectures for each major <span class="No-Break">operating system.</span></p>
			<p>This chapter ends with an example script to automate cross-compilation across the major operating systems and architectures. A script to run on the Darwin, Linux, or Windows environments is provided. In this chapter, we will cover the following topics <span class="No-Break">in detail:</span></p>
			<ul>
				<li>Manual compilation versus <a id="_idTextAnchor293"/>build <span class="No-Break">automation tools</span></li>
				<li>Using <strong class="source-inline">GOOS</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">GOARCH</strong></span></li>
				<li>Compiling for Linux, macOS, <span class="No-Break">and Windows</span></li>
				<li>Scripting to compile for <span class="No-Break">multiple platforms</span></li>
			</ul>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor294"/>Technical requirements</h1>
			<ul>
				<li>You can also find the code examples on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile</span></a></li>
			</ul>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor295"/>Manual compilation versus build automation tools</h1>
			<p>In <a href="B18883_14.xhtml#_idTextAnchor359"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Publishing Your Go Binary as a Homebrew Formula with GoReleaser</em>, we will delve into a fantastic<a id="_idIndexMarker747"/> open source tool, <strong class="bold">GoReleaser</strong>, which automates the<a id="_idIndexMarker748"/> process of building and releasing Go binaries. Despite its power and usefulness, it’s crucial to know how to manually compile your Go code. You see, not all projects can be built and released with GoReleaser. For instance, if your application requires unique build flags or dependencies, manual compilation may be necessary. Moreover, understanding how to manually compile your code is essential for addressing issues that may crop up during the build process. In essence, tools such as GoReleaser can make the process a lot smoother, but having a good grasp of the manual compile process is vital to ensure that<a id="_idIndexMarker749"/> your <strong class="bold">command-line interface (CLI)</strong> applications can be built and released in <span class="No-Break">various scenarios.</span></p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor296"/>Using GOOS and GOARCH</h1>
			<p>When developing your <a id="_idIndexMarker750"/>command-line application, it is important to maximize the audience by developing for as many platforms as possible. However, you may also want to target just a particular set of operating systems and architectures. In the past, it was much <a id="_idIndexMarker751"/>more difficult to deploy to platforms that differed from the one you were developing on. In fact, developing on a macOS platform and deploying it on a Windows machine involved setting up a Windows build machine to build the binary. The tooling would have to be synchronized, and there would be other deliberations that made collaborative testing and <span class="No-Break">distribution cumbersome.</span></p>
			<p>Luckily, Golang has solved this by building support for multiple platforms directly into the language’s toolchain. As discussed in <a href="B18883_07.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Developing for Different Platforms</em>, and <a href="B18883_11.xhtml#_idTextAnchor258"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Custom Builds and Testing CLI Commands</em>, we learned how to write platform-independent code and use the <strong class="source-inline">go build</strong> command and build tags to target specific operating systems and architectures. You may also use environment variables to target the operating system and architecture <span class="No-Break">as well.</span></p>
			<p>First, it’s good to know which operating systems and architectures are available for distribut<a id="_idTextAnchor297"/>ion. To find out, within your terminal, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
go tool dist list</pre>
			<p>The list is <a id="_idIndexMarker752"/>output i<a id="_idTextAnchor298"/>n the following format: <strong class="source-inline">GOOS</strong>/<strong class="source-inline">GOARCH</strong>. <strong class="source-inline">GOOS</strong> is a <a id="_idIndexMarker753"/>local environment variable that defines the operating system to compile for and stands for <strong class="bold">Go Operating System</strong>. <strong class="source-inline">GOARCH</strong>, pronounced “gore-ch,” is a local environment variable that defines the architecture to compile for and stands for <span class="No-Break"><strong class="bold">Go Architecture</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_12.1_B18883.jpg" alt="Figure 12.1 – List of supported operating systems and architectures"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – List of supported operating systems and architectures</p>
			<p>You can also call the preceding command with the <strong class="source-inline">–json</strong> flag to<a id="_idTextAnchor299"/> view more details. For example, for <strong class="source-inline">linux/arm64</strong>, you can see that it’s supported by <strong class="source-inline">Cgo</strong> from the <strong class="source-inline">"CgoSupported"</strong> field, but also that it<a id="_idTextAnchor300"/> is a first-class <strong class="bold">port</strong>, another word for a <strong class="source-inline">GOOS/GOARCH</strong> pair, indicated by the <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">FirstClass"</strong></span><span class="No-Break"> field:</span></p>
			<pre class="console">
{
"GOOS": "linux",
"GOARCH": "arm64",
"CgoSupported": true,
"FirstClass": true<a id="_idTextAnchor301"/>
},</pre>
			<p>A first-class<a id="_idTextAnchor302"/> port has the <span class="No-Break">following properties:</span></p>
			<ul>
				<li>Releases are blocked by <span class="No-Break">broken builds</span></li>
				<li>Official binaries <span class="No-Break">are provided</span></li>
				<li>Installation <span class="No-Break">is documented</span></li>
			</ul>
			<p>Next, determine <a id="_idIndexMarker754"/>your local operating system and architecture settings by running the following command within <span class="No-Break">your terminal:</span></p>
			<pre class="source-code">
go env GOOS GOARCH</pre>
			<p>Currently, running this command on my macOS machine with an AMD64 architecture gives the <span class="No-Break">following output:</span></p>
			<pre class="console">
darwin
amd64</pre>
			<p>The first environment<a id="_idIndexMarker755"/> variable, <strong class="source-inline">GOOS</strong>, is set to <strong class="source-inline">darwin</strong>, and the second environment variable, <strong class="source-inline">GOARCH</strong>, is set to <strong class="source-inline">amd64</strong>. We now know what <strong class="source-inline">GOOS</strong> and<a id="_idTextAnchor303"/> <strong class="source-inline">GOARCH</strong> are within the Go environment, the possible values, and also what values are set on your machine. Let’s learn how to use these <span class="No-Break">environment variables.</span></p>
			<p>You can use these two environment variables for compiling. Let’s generate a build to target the <strong class="source-inline">darwin/amd64</strong> port. You’ll do so by setting the <strong class="source-inline">GOOS</strong> or <strong class="source-inline">GOARCH</strong> environment variables and then running the <strong class="source-inline">go build</strong> command, or more specifically along with the <span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
GOOS=darwin GOARCH=amd64 go build</pre>
			<p>Let’s try this out with the aud<a id="_idTextAnchor304"/>io file CLI and learn all the ways to compile for the three main operating systems: Linux, macOS, <span class="No-Break">and Windows.</span></p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor305"/>Compiling for Linux, macOS, and Windows</h1>
			<p>There are several different ways to compile our command-line application for different operating systems and we’ll go over examples of each of these. First, you can compile by building or installing <span class="No-Break">your application:</span></p>
			<ul>
				<li><strong class="bold">Building</strong> – Compiles<a id="_idIndexMarker756"/> the executable file and then moves it to the current folder or the filename indicated by the <strong class="source-inline">–o</strong> (<span class="No-Break">output) flag</span></li>
				<li><strong class="bold">Installing</strong> – Compiles<a id="_idIndexMarker757"/> the executable file and then installs it to the <strong class="source-inline">$GOPATH/bin</strong> folder or <strong class="source-inline">$GOBIN</strong> if it is set and caches all non-main packages, which are imported to the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">GOPATH/pkg</strong></span><span class="No-Break"> folder</span></li>
			</ul>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor306"/>Building using tags</h2>
			<p>In our previous <a id="_idIndexMarker758"/>chapter, <a href="B18883_11.xhtml#_idTextAnchor258"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Custom Builds and Testing CLI Commands</em>, we learned to build specifically for the macOS or Darwin operating system. To better understand how to use the <strong class="source-inline">build</strong> command, we run <strong class="source-inline">go build –help</strong> to see <span class="No-Break">the usage:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro audiofile % go build -help
usage: go build [-o output] [build flags] [packages]
Run 'go help build' for details</pre>
			<p>Running <strong class="source-inline">go help build</strong> will reveal the build flags available. However, in these examples, we only use the <strong class="source-inline">tags</strong> flag. Within the <strong class="source-inline">Makefile</strong>, we already have the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
build-darwin-free:
    go build -tags "darwin free" -o bin/audiofile main.go
    chmod +x bin/audiofile
build-darwin-pro:
    go build -tags "darwin pro" -o bin/audiofile main.go
    chmod +x bin/audiofile
build-darwin-pro-profile:
    go build -tags "darwin pro profile" -o bin/audiofile main.go
    chmod +x bin/audiofile</pre>
			<p>In <a id="_idIndexMarker759"/>these commands, we compile the application and output it to the <strong class="source-inline">bin/audiofile </strong>filename. To specify the Darwin operating system, we pass in the Darwin build tag to specify the files associated with the Darwin operating system. We’ll need to modify the output files to a folder that specifies Darwin, but also for other specifics such as the free versus the pro version since we’ll be building for other operating systems and levels. Let’s <span class="No-Break">modify these.</span></p>
			<h3>Building applications for a Darwin operating system using tags</h3>
			<p>The <a id="_idIndexMarker760"/>new <strong class="source-inline">Makefile</strong> commands to compile the application for the Darwin operating system are now <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
build-darwin-free:
    go build -tags "darwin free" -o builds/free/darwin/audiofile main.go
    chmod +x builds/free/darwin/audiofile
build-darwin-pro:
    go build -tags "darwin pro" -o builds/pro/darwin/audiofile main.go
    chmod +x builds/pro/darwin/audiofile
build-darwin-pro-profile:
    go build -tags "darwin pro profile" -o builds/profile/darwin/audiofile main.go
    chmod +x builds/profile/darwin/audiofile</pre>
			<p>We’ve <a id="_idIndexMarker761"/>swapped out the <strong class="source-inline">bin/audiofile</strong> output to something more specific. The free version for Darwin now outputs to <strong class="source-inline">builds/free/darwin/audiofile</strong>, the pro version outputs to <strong class="source-inline">builds/pro/darwin/audiofile</strong>, and the profile version outputs to <strong class="source-inline">builds/profile/darwin/audiofile</strong>. Let’s continue with the next operating <span class="No-Break">s<a id="_idTextAnchor307"/>ystem, Linux.</span></p>
			<p>We can do the same for Linux and Windows, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
build-linux-free:
    go build -tags "linux free" -o builds/free/linux/audiofile main.go
    chmod +x builds/free/linux/audiofile
build-linux-pro:
   go build -tags "linux pro" -o builds/pro/linux/audiofile main.go
   chmod +x builds/pro/linux/audiofile
build-linux-pro-profile:
   go build -tags "linux pro profile" -o builds/profile/linux/audiofile main.go
   chmod +x builds/profile/linux/audiofile
build-windows-free:
    go build -tags "windows free" -o builds/free/windows/ audiofile.exe main.go
build-windows-pro:
    go build -tags "windows pro" -o builds/pro/windows/audiofile.exe main.go
build-windows-pro-profile:
    go build -tags "windows pro profile" -o builds/profile/windows/audiofile.exe main.go</pre>
			<p>The <a id="_idIndexMarker762"/>free Windows version is output to <strong class="source-inline">builds/free/windows/audiofile.exe</strong>, the pro Windows version is output to <strong class="source-inline">builds/pro/windows/audiofile.exe</strong>, and the Windows profile version is output to <strong class="source-inline">builds/profile/windows/audiofile.exe</strong>. Now, suppose we don’t want to run each of the individual commands one by one, as there are so many to run! We can write a command to build all versions <span class="No-Break">using tags.</span></p>
			<h3>Building applications for all operating systems using tags</h3>
			<p>Let’s add a<a id="_idIndexMarker763"/> new <strong class="source-inline">Makefile</strong> command to build all the operating systems. Basically, we write one command that calls all <span class="No-Break">other commands:</span></p>
			<pre class="source-code">
build-all: build-darwin-free build-darwin-pro build-darwin-pro-profile build-linux-free build-linux-pro build-linux-pro-profile build-windows-free build-windows-pro build-windows-pro-profile</pre>
			<p>Let’s try running this command via <span class="No-Break">the terminal:</span></p>
			<pre class="console">
make build-all</pre>
			<p>If you’re running on Darwin, you’ll see the <span class="No-Break">following output:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro audiofile % make build-all
go build -tags "darwin free" -o builds/free/darwin/audiofile main.go
chmod +x builds/free/darwin/audiofile
go build -tags "darwin pro" -o builds/pro/darwin/audiofile main.go
chmod +x builds/pro/darwin/audiofile
go build -tags "darwin pro profile" -o builds/profile/darwin/audiofile main.go
chmod +x builds/profile/darwin/audiofile
go build -tags "linux free" -o builds/free/linux/audiofile main.go
# internal/goos
/usr/local/go/src/internal/goos/zgoos_linux.go:7:7: GOOS redeclared in this block
        /usr/local/go/src/internal/goos/zgoos_darwin.go:7:7: other declaration of GOOS
/usr/local/go/src/internal/goos/zgoos_linux.go:9:7: IsAix redeclared in this block
        /usr/local/go/src/internal/goos/zgoos_darwin.go:9:7: other declaration of IsAix
/usr/local/go/src/internal/goos/zgoos_linux.go:10:7: IsAndroid redeclared in this block
...
/usr/local/go/src/internal/goos/zgoos_linux.go:17:7: too many errors
make: *** [build-linux-free] Error 2</pre>
			<p>I’ve<a id="_idIndexMarker764"/> removed p<a id="_idTextAnchor308"/>art of the error message; however, the most important message is <strong class="source-inline">GOOS redeclared in this block</strong>. This error message comes up when the operating system is set but conflicts with the <strong class="source-inline">GOOS</strong> environment variable. For example, the command that failed used the operating build tag to specify a <span class="No-Break">Linux build:</span></p>
			<pre class="console">
go build -tags "linux free" -o builds/free/linux/audiofile main.go</pre>
			<p>However, running <strong class="source-inline">go env | grep GOOS</strong> in my macOS terminal shows the value of the <strong class="source-inline">GOOS</strong> <span class="No-Break">environment</span><span class="No-Break"><a id="_idIndexMarker765"/></span><span class="No-Break"> variable:</span></p>
			<pre class="console">
GOOS="darwin"</pre>
			<p>Let’s modify the build commands to set the <strong class="source-inline">GOOS</strong> environment variable so it matches the output type based on the <span class="No-Break">build tag.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor309"/>Building using the GOOS environment variable</h2>
			<p>The<a id="_idIndexMarker766"/> Linux builds have been modified to set the <strong class="source-inline">GOOS</strong> environment variable to Linux by prepending <strong class="source-inline">GOOS=linux</strong> before the <span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
build-linux-free:
    GOOS=linux go build -tags "linux free" -o builds/free/linux/audiofile main.go
    chmod +x builds/free/linux/audiofile
build-linux-pro:
    GOOS=linux go build -tags "linux pro" -o builds/pro/linux/audiofile main.go
    chmod +x builds/pro/linux/audiofile
build-linux-pro-profile:
    GOOS=linux go build -tags "linux pro profile" -o builds/profile/linux/audiofile main.go
    chmod +x builds/profile/linux/audiofile</pre>
			<p>The Windows builds have been modified to set the <strong class="source-inline">GOOS</strong> environment variable to Windows by prepending <strong class="source-inline">GOOS=windows</strong> before the <span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
build-windows-free:
    GOOS=windows go build -tags "windows free" -o builds/free/windows/audiofile.exe main.go
build-windows-pro:
    GOOS=windows go build -tags "windows pro" -o builds/pro/windows/audiofile.exe main.go
build-windows-pro-profile:
    GOOS=windows go build -tags "windows pro profile" -o builds/profile/windows/audiofile.exe main.go</pre>
			<p>Now, let’s try the <strong class="source-inline">build-all</strong> command again. It runs successfully and we can see all the files <a id="_idIndexMarker767"/>generated by the <strong class="source-inline">build</strong> command by running <strong class="source-inline">find –type –f ./builds</strong> in <span class="No-Break">the repo:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro audiofile % find ./builds -type f
./builds/pro/linux/audiofile
./builds/pro/darwin/audiofile
./builds/pro/windows/audiofile.exe
./builds/free/linux/audiofile
./builds/free/darwin/audiofile
./builds/free/windows/audiofile.exe
./builds/profile/linux/audiofile
./builds/profile/darwin/audiofile
./builds/profile/windows/audiofile.exe</pre>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor310"/>Building using the GOARCH environment variable</h2>
			<p>Many<a id="_idIndexMarker768"/> different possible architecture values can be associated with a single operating system. Rather than creating a command for each, we’ll start with just <span class="No-Break">one example:</span></p>
			<pre class="source-code">
build-darwin-amd64-free:
    GOOS=darwin GOARCH=amd64 go build -tags "darwin free" -o builds/free/darwin/audiofile main.go
    chmod +x builds/free/darwin/audiofile</pre>
			<p>This example specifies the operating system, the <strong class="source-inline">GOOS</strong> environment variable, as <strong class="source-inline">darwin</strong>, and then the architecture, the <strong class="source-inline">GOARCH</strong> environment variable, <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">amd64</strong></span><span class="No-Break">.</span></p>
			<p>There’d be too many commands to create if we were to create a <strong class="source-inline">bu<a id="_idTextAnchor311"/>ild</strong> command for each architecture of each m<a id="_idTextAnchor312"/>ajor operating system. We’ll save this for a script within the last section of <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor313"/>Installing using tags and GOOS env va</h2>
			<ul>
				<li>As <a id="_idIndexMarker769"/>mentioned earlier, another way to compile your command-line application is by installing it. The <strong class="source-inline">install</strong> command comp<a id="_idTextAnchor314"/>iles the application, like the <strong class="source-inline">go build</strong> command, but also with the additional step of moving the compiled application to the <strong class="source-inline">$GOPATH/bin</strong> folder or <strong class="source-inline">$GOBIN</strong> value. To learn more about the <strong class="source-inline">install</strong> command, we run the following <strong class="source-inline">go install –</strong><span class="No-Break"><strong class="source-inline">help</strong></span><span class="No-Break"> command:</span></li>
			</ul>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro audiofile % go install -help
usage: go install [build flags] [packages]
Run 'go help install' for details</pre>
			<ul>
				<li>The same flags for building are available for installing. Again, we will use the <strong class="source-inline">tags</strong> flag only. Let’s first run the <strong class="source-inline">install</strong> command on the <span class="No-Break">macOS system:</span></li>
			</ul>
			<pre class="console">
go install -tags "darwin pro" github.com/marianina8/audiofile</pre>
			<p>However, running <strong class="source-inline">go env | grep GOPATH</strong> in my macOS terminal shows the value of the <strong class="source-inline">GOOS</strong> <span class="No-Break">environment variable:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro audiofile % go env | grep GOPATH
GOPATH="/Users/mmontagnino/Code"</pre>
			<p>Confirm that the audio file CLI executable exists in the <strong class="source-inline">$GOPATH/bin</strong> or <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">Users/mmontagnino/Code/bin</strong></span><span class="No-Break"> folder.</span></p>
			<p>As <a id="_idIndexMarker770"/>mentioned, we can use build tags to separate builds based on the operating system and architecture. Within the audio file repository, we’re already doing so with the following files associated with the <strong class="source-inline">play</strong> and <strong class="source-inline">bug</strong> commands. For the <strong class="source-inline">bug</strong> command, we have the following files. Now, let’s add some <strong class="source-inline">install</strong> commands within the <strong class="source-inline">Makefile</strong> now that we understand how to use the build tags and <strong class="source-inline">GOOS</strong> <span class="No-Break">environment variables.</span></p>
			<h3>install commands for the Darwin operating system</h3>
			<p>The <strong class="source-inline">install</strong> commands <a id="_idIndexMarker771"/>for the Darwin operating system include passing in the specific tags, including <strong class="source-inline">darwin</strong>, and the levels, defined by tags, <span class="No-Break">to install:</span></p>
			<pre class="source-code">
install-darwin-free:
    go install -tags "darwin free" github.com/marianina8/audiofile
install-darwin-pro:
    go install -tags "darwin pro" github.com/marianina8/audiofile
install-darwin-pro-profile:
    go install -tags "darwin pro profile" github.com/marianina8/audiofile</pre>
			<h3>install commands for the Linux operating system</h3>
			<p>The <strong class="source-inline">install</strong> commands <a id="_idIndexMarker772"/>for the Linux operating system include passing in the specific tags, including <strong class="source-inline">linux</strong>, and the package to install. To ensure the commands do not error out with conflicting <strong class="source-inline">GOOS</strong> settings, we set the matching environment variable, <strong class="source-inline">GOOS</strong>, <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">linux</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
install-linux-free:
    GOOS=linux go install -tags "linux free" github.com/marianina8/audiofile
install-linux-pro:
    GOOS=linux go install -tags "linux pro" github.com/marianina8/audiofile
install-linux-pro-profile:
    GOOS=linux go install -tags "linux pro profile" github.com/marianina8/audiofile</pre>
			<h3>install commands for the Windows operating system</h3>
			<p>The <strong class="source-inline">install</strong> commands<a id="_idIndexMarker773"/> <a id="_idTextAnchor315"/>for the Windows operating system include passing in the specific tags, including <strong class="source-inline">windows</strong>, and the package to install. To ensure the commands do not error out with conflicting <strong class="source-inline">GOOS</strong> settings, we set the matching environment variable, <strong class="source-inline">GOOS</strong>, <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">windows</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
install-windows-free:
    GOOS=windows go install -tags "windows free" github.com/marianina8/audiofile
install-windows-pro:
    GOOS=windows go install -tags "windows pro" github.com/marianina8/audiofile
install-windows-pro-profile:
    GOOS=windows go install -tags "windows pro profile" github.com/marianina8/audiofile</pre>
			<p>Remember<a id="_idIndexMarker774"/> that for your <strong class="source-inline">Makefile</strong>, you’ll need to change the location of the package if you have forked the repo under your own account. Run the <strong class="source-inline">make</strong> command for the operating system you need and confirm that the application is installed by checking the <strong class="source-inline">$GOPATH/bin</strong> or <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">GOBIN</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor316"/>Installing using tags and GOARCH env var</h2>
			<p>While <a id="_idIndexMarker775"/>many different possible architecture values can be associated with a single operating system, let’s start with just one example of installing with <strong class="source-inline">GOARCH </strong><span class="No-Break"><strong class="source-inline">env var</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
install-linux-amd64-free:
    GOOS=linux GOARCH=amd64 go install -tags "linux free" github.com/marianina8/audiofile</pre>
			<p>This example specifies the operating system, the <strong class="source-inline">GOOS</strong> environment variable, as <strong class="source-inline">linux</strong>, and then the architecture, the <strong class="source-inline">GOARCH</strong> environment variable, as <strong class="source-inline">amd64</strong>. Rather than creating a command for each pair of operating systems and architectures, again, we’ll save this for a script within the last section of <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor317"/>Scripting to compile for multiple platforms</h1>
			<p>We’ve learned several different ways to compile for operating systems using the <strong class="source-inline">GOOS</strong> and <strong class="source-inline">G<a id="_idTextAnchor318"/>OARCH</strong> environment variables and using build tags. The <strong class="source-inline">Makefile</strong> can fill up rather quickly with all the different combinations of <strong class="source-inline">GOOS</strong>/<strong class="source-inline">GOARCH</strong> pairs and scripting may provide a better solution if you want to generate builds for many more <span class="No-Break">specific architectures.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor319"/>Creating a bash script to compile in Darwin or Linux</h2>
			<p>Let’s <a id="_idIndexMarker776"/>start by creating a bash scr<a id="_idTextAnchor320"/>ipt. Let’s name it <strong class="source-inline">build.sh</strong>. To create the file, I simply type <span class="No-Break">the following:</span></p>
			<pre class="console">
touch build.sh</pre>
			<p>The preceding command creates the file when it does not exist. The file extension is <strong class="source-inline">.sh</strong>, which, while unnecessary to add, clearly indicates that the<a id="_idTextAnchor321"/> file is a bash script type. Next, we want to edit it. If using <strong class="source-inline">vi</strong>, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
vi build.sh</pre>
			<p>Otherwise, edit the file using the editor of <span class="No-Break">your choice.</span></p>
			<h3>Adding the shebang</h3>
			<p>The<a id="_idIndexMarker777"/> first line of a bash script is called the <strong class="bold">shebang</strong>. It is a <a id="_idIndexMarker778"/>character sequence that indicates the program loader’s first instruction. It defines which interpreter to run when reading, or interpreting, the script. The first line to indicate to use the bash interpreter is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
#!/bin/bash</pre>
			<p>The shebang consists of a couple <span class="No-Break">of elements:</span></p>
			<ul>
				<li><strong class="source-inline">#!</strong> instructs the program loader to load an interpreter for <span class="No-Break">the code</span></li>
				<li><strong class="source-inline">/bin/bash</strong> indicates the bash or <span class="No-Break">interpreter’s location</span></li>
			</ul>
			<p>These are some typical shebangs for <span class="No-Break">different interpreters:</span></p>
			<table id="table001-3" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Interpreter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Shebang</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Bash</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">#!/</strong><span class="No-Break"><strong class="source-inline">bin/bash</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Bourne shell</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">#!/</strong><span class="No-Break"><strong class="source-inline">bin/sh</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Powershell</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">#!/</strong><span class="No-Break"><strong class="source-inline">user/bin/pwsh</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Other <span class="No-Break">scripting languages</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">#!/</strong><span class="No-Break"><strong class="source-inline">user/bin/env &lt;interpreter&gt;</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – Shebang lines for different interpreters</p>
			<h3>Adding comments</h3>
			<p>To add <a id="_idIndexMarker779"/>comments to your bash script, simply start the comment with the <strong class="source-inline">#</strong> symbol and the pound sign, followed by comment text. This text can be used by you and other developers to document information that might not be easily understood from the code alone. It could also just add some details on the usage of the script, who the author is, and <span class="No-Break">so on.</span></p>
			<h3>Adding print lines</h3>
			<p>In a <a id="_idTextAnchor322"/><a id="_idIndexMarker780"/>bash file, to print lines out, simply use the <strong class="source-inline">echo</strong> command. These print lines will help you to understand exactly where<a id="_idTextAnchor323"/> your application is within its running process. Use these lines with intention and they will give you and your users some useful insight that can even make <span class="No-Break">debugging easier.</span></p>
			<h3>Adding code</h3>
			<p>Within<a id="_idIndexMarker781"/> the bash script, w<a id="_idTextAnchor324"/>e’ll generate builds for all the differing build tags for each operating system and architecture pair. Let’s first start to see which architecture values are available <span class="No-Break">for Darwin:</span></p>
			<pre class="console">
go tool dist list | grep darwin</pre>
			<p>The values returned are <span class="No-Break">as follows:</span></p>
			<pre class="console">
darwin/amd64
darwin/arm64</pre>
			<p>Let’s generate the different Darwin builds – free, pro, and profile versions – for all architectures with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
# Generate darwin builds
darwin_archs=(amd64 arm64)
for darwin_arch in ${darwin_archs[@]}
do
    echo "building for darwin/${darwin_arch} free version..."
    env GOOS=darwin GOARCH=${darwin_arch} go build -tags free -o builds/free/darwin/${darwin_arch}/audiofile main.go
    echo "building for darwin/${darwin_arch} pro version..."
    env GOOS=darwin GOARCH=${darwin_arch} go build -tags pro -o builds/pro/darwin/${darwin_arch}/audiofile main.go
    echo "building for darwin/${darwin_arch} profile version..."
    env GOOS=darwin GOARCH=${darwin_arch} go build -tags profile -o builds/profile/darwin/${darwin_arch}/audiofile main.go
done</pre>
			<p>Next, let’s<a id="_idIndexMarker782"/> do the same with Linux, first grabbing the architecture <span class="No-Break">values available:</span></p>
			<pre class="console">
go tool dist list | grep linux</pre>
			<p>The values returned are <span class="No-Break">as follows:</span></p>
			<pre class="console">
linux/386        linux/mips64le
linux/amd64    linux/mipsle
linux/arm        linux/ppc64
linux/arm64    linux/ppc64le
linux/loong64    linux/riscv64
linux/mips        linux/s390x
linux/mips64</pre>
			<p>Let’s generate the different Linux builds – the free, pro, and profile versions – for all architectures with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
# Generate linux builds
linux_archs=(386 amd64 arm arm64 loong64 mips mips64 mips64le mipsle ppc64 ppc64le riscv64 s390x)
for linux_arch in ${linux_archs[@]}
do
    echo "building for linux/${linux_arch} free version..."
    env GOOS=linux GOARCH=${linux_arch} go build -tags free -o builds/free/linux/${linux_arch}/audiofile main.go
    echo "building for linux/${linux_arch} pro version..."
    env GOOS=linux GOARCH=${linux_arch} go build -tags pro -o builds/pro/linux/${linux_arch}/audiofile main.go
    echo "building for linux/${linux_arch} profile version..."
    env GOOS=linux GOARCH=${linux_arch} go build -tags profile -o builds/profile/linux/${linux_arch}/audiofile main.go
done</pre>
			<p>Next, let’s do<a id="_idIndexMarker783"/> the same with Windows, first grabbing the architecture <span class="No-Break">values available:</span></p>
			<pre class="console">
go tool dist list | grep windows</pre>
			<p>The values returned are <span class="No-Break">as follows:</span></p>
			<pre class="console">
windows/386
windows/amd64
windows/arm
windows/arm64</pre>
			<p>Finally, let’s generate the different Windows builds – the free, pro, and profile versions – for all architectures <a id="_idIndexMarker784"/>with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
# Generate windows builds
windows_archs=(386 amd64 arm arm64)
for windows_arch in ${windows_archs[@]}
do
    echo "building for windows/${windows_arch} free version..."
    env GOOS=windows GOARCH=${windows_arch} go build -tags free -o builds/free/windows/${windows_arch}/audiofile.exe main.go
    echo "building for windows/${windows_arch} pro version..."
    env GOOS=windows GOARCH=${windows_arch} go build -tags pro -o builds/pro/windows/${windows_arch}/audiofile.exe main.go
    echo "building for windows/${windows_arch} profile version..."
    env GOOS=windows GOARCH=${windows_arch} go build -tags profile -o builds/profile/windows/${windows_arch}/audiofile.exe main.go
done</pre>
			<p>Here’s the code when run from the Darwin/macOS or <span class="No-Break">Linux terminal:</span></p>
			<pre class="console">
./build.sh</pre>
			<p>We can check that the executable files have bee<a id="_idTextAnchor325"/>n generated. The full list is quite long, and they have been organized within the following nested <span class="No-Break">folder structure:</span></p>
			<pre class="console">
/builds/{level}/{operating-system}/{architecture}/{audiofile-executable}</pre>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/Figure_12.2_B18883.jpg" alt="Figure 12.2 – Screenshot of generated folders from the build bash script"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Screenshot of generated folders from the build bash script</p>
			<p>A script to <a id="_idIndexMarker785"/>generate these builds will need to be different if run on Windows, for example. If you are running your application on Darwin or Linux, try running the build script and see the generated builds populate. You can now share these builds with other users running on a different platform. Next, we’ll create a PowerShell script to generate the same builds to run <span class="No-Break">in Windows.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor326"/>Creating a PowerShell script in Windows</h2>
			<p>Let’s <a id="_idIndexMarker786"/>start by creating a PowerShell script. Let’s name it <strong class="source-inline">build.ps1</strong>. Create the file by typing the following command <span class="No-Break">within PowerShell:</span></p>
			<pre class="console">
notepad build.ps1</pre>
			<p>The preceding command asks to create the file when it does not exist. The file extension is <strong class="source-inline">.ps1</strong>, which indicates that the file is a PowerShell script type. Next, we want to edit it. You may use Notepad or another editor of <span class="No-Break">your choice.</span></p>
			<p>Unlike a bash script, a PowerShell script does not require a shebang. To learn more about how to write a PowerShell script, you can review the documentation <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/powershell/"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/</span></a><span class="No-Break">.</span></p>
			<h3>Adding comments</h3>
			<p>To add <a id="_idIndexMarker787"/>comments to your PowerShell script, simply start the comment with a <strong class="source-inline">#</strong> symbol and a pound sign, followed by <span class="No-Break">comment text.</span></p>
			<h3>Adding print lines</h3>
			<p>In a <a id="_idIndexMarker788"/>PowerShell file, to print lines out, simply use the <span class="No-Break"><strong class="source-inline">Write-Output</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
Write-Output "building for windows/amd64..."</pre>
			<p>Writing output will help you to understand exactly where your application is within its running process, make it easier to debug, and give the user a sense that something is running. Having no output at all is not only boring but also communicates nothing to <span class="No-Break">the user.</span></p>
			<h3>Adding code</h3>
			<p>Within<a id="_idIndexMarker789"/> the PowerShell script, we’ll generate builds for all the differing build tags for each operating system and architecture pair. Let’s start by seeing which architecture values are available for Darwin via a <span class="No-Break">Windows command:</span></p>
			<pre class="console">
PS C:\Users\mmontagnino\Code\src\github.com\marianina8\audiofile&gt; go tool dist list | Select-String darwin</pre>
			<p>Using the <strong class="source-inline">Select-String</strong> command, we can return only the values that contain <strong class="source-inline">darwin</strong>. These values <span class="No-Break">are returned:</span></p>
			<pre class="console">
darwin/amd64
darwin/arm64</pre>
			<p>We can <a id="_idIndexMarker790"/>run a similar command <span class="No-Break">for Linux:</span></p>
			<pre class="console">
PS C:\Users\mmontagnino\Code\src\github.com\marianina8\audiofile&gt; go tool dist list | Select-String linux</pre>
			<p>And a command <span class="No-Break">for Windows:</span></p>
			<pre class="console">
PS C:\Users\mmontagnino\Code\src\github.com\marianina8\audiofile&gt; go tool dist list | Select-String windows</pre>
			<p>The same values are returned within the previous sections, so I won’t print them out. However, now that we know how to get the architecture for each operating system, we can add the code to generate the builds for all <span class="No-Break">of them.</span></p>
			<p>The code to generate Darwin builds is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
# Generate darwin builds
$darwin_archs="amd64","arm64"
foreach ($darwin_arch in $darwin_archs)
{
    Write-Output "building for darwin/$($darwin_arch) free version..."
    $env:GOOS="darwin";$env:GOARCH=$darwin_arch; go build -tags free -o .\builds\free\darwin\$darwin_arch\audiofile main.go
    Write-Output "building for darwin/$($darwin_arch) pro version..."
    $env:GOOS="darwin";$env:GOARCH=$darwin_arch; go build -tags pro -o .\builds\pro\darwin\$darwin_arch\audiofile main.go
    Write-Output "building for darwin/$($darwin_arch) profile version..."
    $env:GOOS="darwin";$env:GOARCH=$darwin_arch; go build -tags profile -o .\builds\profile\darwin\$darwin_arch\audiofile main.go
}</pre>
			<p>The code<a id="_idIndexMarker791"/> to generate Linux builds is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
# Generate linux builds
$linux_archs="386","amd64","arm","arm64","loong64","mips","mips64","mips64le","mipsle","ppc64","ppc64le","riscv64","s390x"
foreach ($linux_arch in $linux_archs)
{
    Write-Output "building for linux/$($linux_arch) free version..."
    $env:GOOS="linux";$env:GOARCH=$linux_arch; go build -tags free -o .\builds\free\linux\$linux_arch\audiofile main.go
    Write-Output "building for linux/$($linux_arch) pro version..."
    $env:GOOS="linux";$env:GOARCH=$linux_arch; go build -tags pro -o .\builds\pro\linux\$linux_arch\audiofile main.go
    Write-Output "building for linux/$($linux_arch) profile version..."
    $env:GOOS="linux";$env:GOARCH=$linux_arch; go build -tags profile -o .\builds\profile\linux\$linux_arch\audiofile main.go
}</pre>
			<p>Finally, the<a id="_idIndexMarker792"/> code to generate Windows builds is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
# Generate windows builds
$windows_archs="386","amd64","arm","arm64"
foreach ($windows_arch in $windows_archs)
{
    Write-Output "building for windows/$($windows_arch) free version..."
    $env:GOOS="windows";$env:GOARCH=$windows_arch; go build -tags free -o .\builds\free\windows\$windows_arch\audiofile.exe main.go
    Write-Output "building for windows/$($windows_arch) pro version..."
    $env:GOOS="windows";$env:GOARCH=$windows_arch; go build -tags pro -o .\builds\pro\windows\$windows_arch\audiofile.exe main.go
    Write-Output "building for windows/$($windows_arch) profile version..."
    $env:GOOS="windows";$env:GOARCH=$windows_arch; go build -tags profile -o .\builds\profile\windows\$windows_arch\audiofile.exe main.go
}</pre>
			<p>Each section generates a build for one of the three major operating systems and all the available architectures. To run the script from PowerShell, just run the <span class="No-Break">following script:</span></p>
			<pre class="console">
./build.ps1</pre>
			<p>The following will be the output for <span class="No-Break">each port:</span></p>
			<pre class="console">
building for $GOOS/$GOARCH [free/pro/profile] version...</pre>
			<p>Check<a id="_idIndexMarker793"/> the <strong class="source-inline">builds</strong> folder to see all the ports generated successfully. The full list is quite long, and they have been organized within the following nested <span class="No-Break">folder structure:</span></p>
			<pre class="console">
/builds/{level}/{operating-system}/{architecture}/{audiofile-executable}</pre>
			<p>Now, we can generate builds for all operating systems and architectures from a PowerShell script, which can be run on Windows. If you run any of the major operating systems – Darwin, Linux, or Windows – you can now generate a build for your own platform or anyone else who would like to use <span class="No-Break">your application.</span></p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor327"/>Summary</h1>
			<p>In this chapter, you learned what the <strong class="source-inline">GOOS</strong> and <strong class="source-inline">GOARCH</strong> environment variables are and how you can use them, as well as build tags, to customize builds based on the operating system, architecture, and levels. These environment variables help you to learn more about the environment you’re building in and possibly understand why a build may have trouble executing on <span class="No-Break">another platform.</span></p>
			<p>There are also two ways to compile an application – building or installing. In this chapter, we discussed how to build or install the application and what the difference is. The same flags are available for each command, but we discussed how to build or install on each of the major operating systems using the <strong class="source-inline">Makefile</strong>. However, this also showed how large the <strong class="source-inline">Makefile</strong> <span class="No-Break">can become!</span></p>
			<p>Finally, we learned how to create a simple script to run in Darwin, Linux, or Windows to generate all the builds needed for all the major operating systems. You learned how to write both a bash and PowerShell script to generate builds. In the next chapter, <a href="B18883_13.xhtml#_idTextAnchor331"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Using Containers for Distribution</em>, we will learn how to run these compiled applications on containers made from different operating system images. Finally, in <a href="B18883_14.xhtml#_idTextAnchor359"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Publishing Your Go Binary as a Homebrew Formula with GoReleaser</em>, you’ll explore the tools required to automate the process of building and releasing your Go binaries across a range of operating systems and architectures. By learning how to use GoReleaser, you can significantly accelerate the process of releasing and deploying your application. This way, you can concentrate on developing new features and addressing bugs instead of getting bogged down with the build and compile process. Ultimately, using GoReleaser can save you valuable time and energy that you can use to make your application <span class="No-Break">even better.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor328"/>Questions</h1>
			<ol>
				<li>What Go environment variables define the operating system and <span class="No-Break">the architecture?</span></li>
				<li>What additional security do you get from building with a <span class="No-Break">first-class port?</span></li>
				<li>What command would you run on Linux to find the port values for the Darwin <span class="No-Break">operating system?</span></li>
			</ol>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor329"/>Answers</h1>
			<ol>
				<li value="1"><strong class="source-inline">GOOS</strong> is the Golang operating system, and <strong class="source-inline">GOARCH</strong> is the Golang <span class="No-Break">architecture value.</span></li>
				<li>There are several reasons why a first-class port is more secure: releases are blocked by broken builds, official binaries are provided, and installation <span class="No-Break">is documented.</span></li>
				<li><strong class="source-inline">go tool dist list | </strong><span class="No-Break"><strong class="source-inline">grep darwin</strong></span><span class="No-Break">.</span></li>
			</ol>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor330"/>Further reading</h1>
			<ul>
				<li>Read more about compiling <span class="No-Break">at </span><a href="https://go.dev/doc/tutorial/compile-install"><span class="No-Break">https://go.dev/doc/tutorial/compile-install</span></a><a href="https://go.dev/doc/tutorial/compile-install&#13;"/></li>
				<li>Read more about Go environment variables <span class="No-Break">at </span><a href="https://pkg.go.dev/cmd/go"><span class="No-Break">https://pkg.go.dev/cmd/go</span></a><a href="https://pkg.go.dev/cmd/go&#13;"/></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer098" class="IMG---Figure">
			</div>
		</div>
	</body></html>