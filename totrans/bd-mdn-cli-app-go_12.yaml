- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-Compilation across Different Platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces the user to cross-compilation, a powerful feature of
    Go, across different platforms. While build automation tools exist, understanding
    how to cross-compile provides essential knowledge for debugging and customization
    when necessary. This chapter will explain the different operating systems and
    architectures that Go can compile and how to determine which is needed. After
    Go is installed in your environment, there is a command, `go env`, with which
    you can see all the Go-related environment variables. We will discuss the two
    major ones used for building: `GOOS` and `GOARCH`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will give examples of how to build or install an application for each major
    operating system: Linux, macOS, and Windows. You will learn how to determine the
    Go operating system and architecture settings based on your environment and the
    available architectures for each major operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter ends with an example script to automate cross-compilation across
    the major operating systems and architectures. A script to run on the Darwin,
    Linux, or Windows environments is provided. In this chapter, we will cover the
    following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Manual compilation versus build automation tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `GOOS` and `GOARCH`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling for Linux, macOS, and Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting to compile for multiple platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual compilation versus build automation tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 14*](B18883_14.xhtml#_idTextAnchor359), *Publishing Your Go Binary
    as a Homebrew Formula with GoReleaser*, we will delve into a fantastic open source
    tool, **GoReleaser**, which automates the process of building and releasing Go
    binaries. Despite its power and usefulness, it’s crucial to know how to manually
    compile your Go code. You see, not all projects can be built and released with
    GoReleaser. For instance, if your application requires unique build flags or dependencies,
    manual compilation may be necessary. Moreover, understanding how to manually compile
    your code is essential for addressing issues that may crop up during the build
    process. In essence, tools such as GoReleaser can make the process a lot smoother,
    but having a good grasp of the manual compile process is vital to ensure that
    your **command-line interface (CLI)** applications can be built and released in
    various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using GOOS and GOARCH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing your command-line application, it is important to maximize the
    audience by developing for as many platforms as possible. However, you may also
    want to target just a particular set of operating systems and architectures. In
    the past, it was much more difficult to deploy to platforms that differed from
    the one you were developing on. In fact, developing on a macOS platform and deploying
    it on a Windows machine involved setting up a Windows build machine to build the
    binary. The tooling would have to be synchronized, and there would be other deliberations
    that made collaborative testing and distribution cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Golang has solved this by building support for multiple platforms directly
    into the language’s toolchain. As discussed in [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143),
    *Developing for Different Platforms*, and [*Chapter 11*](B18883_11.xhtml#_idTextAnchor258),
    *Custom Builds and Testing CLI Commands*, we learned how to write platform-independent
    code and use the `go build` command and build tags to target specific operating
    systems and architectures. You may also use environment variables to target the
    operating system and architecture as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it’s good to know which operating systems and architectures are available
    for distribution. To find out, within your terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The list is output in the following format: `GOOS`/`GOARCH`. `GOOS` is a local
    environment variable that defines the operating system to compile for and stands
    for `GOARCH`, pronounced “gore-ch,” is a local environment variable that defines
    the architecture to compile for and stands for **Go Architecture**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – List of supported operating systems and architectures](img/Figure_12.1_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – List of supported operating systems and architectures
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also call the preceding command with the `–json` flag to view more
    details. For example, for `linux/arm64`, you can see that it’s supported by `Cgo`
    from the `"CgoSupported"` field, but also that it is a first-class `GOOS/GOARCH`
    pair, indicated by the `"``FirstClass"` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A first-class port has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Releases are blocked by broken builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official binaries are provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation is documented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, determine your local operating system and architecture settings by running
    the following command within your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, running this command on my macOS machine with an AMD64 architecture
    gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first environment variable, `GOOS`, is set to `darwin`, and the second environment
    variable, `GOARCH`, is set to `amd64`. We now know what `GOOS` and `GOARCH` are
    within the Go environment, the possible values, and also what values are set on
    your machine. Let’s learn how to use these environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these two environment variables for compiling. Let’s generate a
    build to target the `darwin/amd64` port. You’ll do so by setting the `GOOS` or
    `GOARCH` environment variables and then running the `go build` command, or more
    specifically along with the `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try this out with the audio file CLI and learn all the ways to compile
    for the three main operating systems: Linux, macOS, and Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling for Linux, macOS, and Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several different ways to compile our command-line application for
    different operating systems and we’ll go over examples of each of these. First,
    you can compile by building or installing your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`–o` (output) flag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$GOPATH/bin` folder or `$GOBIN` if it is set and caches all non-main packages,
    which are imported to the `$``GOPATH/pkg` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building using tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous chapter, [*Chapter 11*](B18883_11.xhtml#_idTextAnchor258),
    *Custom Builds and Testing CLI Commands*, we learned to build specifically for
    the macOS or Darwin operating system. To better understand how to use the `build`
    command, we run `go build –help` to see the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `go help build` will reveal the build flags available. However, in
    these examples, we only use the `tags` flag. Within the `Makefile`, we already
    have the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In these commands, we compile the application and output it to the `bin/audiofile`
    filename. To specify the Darwin operating system, we pass in the Darwin build
    tag to specify the files associated with the Darwin operating system. We’ll need
    to modify the output files to a folder that specifies Darwin, but also for other
    specifics such as the free versus the pro version since we’ll be building for
    other operating systems and levels. Let’s modify these.
  prefs: []
  type: TYPE_NORMAL
- en: Building applications for a Darwin operating system using tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new `Makefile` commands to compile the application for the Darwin operating
    system are now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’ve swapped out the `bin/audiofile` output to something more specific. The
    free version for Darwin now outputs to `builds/free/darwin/audiofile`, the pro
    version outputs to `builds/pro/darwin/audiofile`, and the profile version outputs
    to `builds/profile/darwin/audiofile`. Let’s continue with the next operating system,
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same for Linux and Windows, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The free Windows version is output to `builds/free/windows/audiofile.exe`, the
    pro Windows version is output to `builds/pro/windows/audiofile.exe`, and the Windows
    profile version is output to `builds/profile/windows/audiofile.exe`. Now, suppose
    we don’t want to run each of the individual commands one by one, as there are
    so many to run! We can write a command to build all versions using tags.
  prefs: []
  type: TYPE_NORMAL
- en: Building applications for all operating systems using tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a new `Makefile` command to build all the operating systems. Basically,
    we write one command that calls all other commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try running this command via the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re running on Darwin, you’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve removed part of the error message; however, the most important message
    is `GOOS redeclared in this block`. This error message comes up when the operating
    system is set but conflicts with the `GOOS` environment variable. For example,
    the command that failed used the operating build tag to specify a Linux build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, running `go env | grep GOOS` in my macOS terminal shows the value
    of the `GOOS` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let’s modify the build commands to set the `GOOS` environment variable so it
    matches the output type based on the build tag.
  prefs: []
  type: TYPE_NORMAL
- en: Building using the GOOS environment variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Linux builds have been modified to set the `GOOS` environment variable
    to Linux by prepending `GOOS=linux` before the `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows builds have been modified to set the `GOOS` environment variable
    to Windows by prepending `GOOS=windows` before the `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try the `build-all` command again. It runs successfully and we can
    see all the files generated by the `build` command by running `find –type –f ./builds`
    in the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Building using the GOARCH environment variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many different possible architecture values can be associated with a single
    operating system. Rather than creating a command for each, we’ll start with just
    one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This example specifies the operating system, the `GOOS` environment variable,
    as `darwin`, and then the architecture, the `GOARCH` environment variable, as
    `amd64`.
  prefs: []
  type: TYPE_NORMAL
- en: There’d be too many commands to create if we were to create a `build` command
    for each architecture of each major operating system. We’ll save this for a script
    within the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing using tags and GOOS env va
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, another way to compile your command-line application
    is by installing it. The `install` command compiles the application, like the
    `go build` command, but also with the additional step of moving the compiled application
    to the `$GOPATH/bin` folder or `$GOBIN` value. To learn more about the `install`
    command, we run the following `go install –``help` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The same flags for building are available for installing. Again, we will use
    the `tags` flag only. Let’s first run the `install` command on the macOS system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, running `go env | grep GOPATH` in my macOS terminal shows the value
    of the `GOOS` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Confirm that the audio file CLI executable exists in the `$GOPATH/bin` or `/``Users/mmontagnino/Code/bin`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, we can use build tags to separate builds based on the operating
    system and architecture. Within the audio file repository, we’re already doing
    so with the following files associated with the `play` and `bug` commands. For
    the `bug` command, we have the following files. Now, let’s add some `install`
    commands within the `Makefile` now that we understand how to use the build tags
    and `GOOS` environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: install commands for the Darwin operating system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `install` commands for the Darwin operating system include passing in the
    specific tags, including `darwin`, and the levels, defined by tags, to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: install commands for the Linux operating system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `install` commands for the Linux operating system include passing in the
    specific tags, including `linux`, and the package to install. To ensure the commands
    do not error out with conflicting `GOOS` settings, we set the matching environment
    variable, `GOOS`, to `linux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: install commands for the Windows operating system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `install` commands for the Windows operating system include passing in
    the specific tags, including `windows`, and the package to install. To ensure
    the commands do not error out with conflicting `GOOS` settings, we set the matching
    environment variable, `GOOS`, to `windows`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Remember that for your `Makefile`, you’ll need to change the location of the
    package if you have forked the repo under your own account. Run the `make` command
    for the operating system you need and confirm that the application is installed
    by checking the `$GOPATH/bin` or `$``GOBIN` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Installing using tags and GOARCH env var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While many different possible architecture values can be associated with a
    single operating system, let’s start with just one example of installing with
    `GOARCH` `env var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This example specifies the operating system, the `GOOS` environment variable,
    as `linux`, and then the architecture, the `GOARCH` environment variable, as `amd64`.
    Rather than creating a command for each pair of operating systems and architectures,
    again, we’ll save this for a script within the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting to compile for multiple platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve learned several different ways to compile for operating systems using
    the `GOOS` and `GOARCH` environment variables and using build tags. The `Makefile`
    can fill up rather quickly with all the different combinations of `GOOS`/`GOARCH`
    pairs and scripting may provide a better solution if you want to generate builds
    for many more specific architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bash script to compile in Darwin or Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a bash script. Let’s name it `build.sh`. To create
    the file, I simply type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates the file when it does not exist. The file extension
    is `.sh`, which, while unnecessary to add, clearly indicates that the file is
    a bash script type. Next, we want to edit it. If using `vi`, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, edit the file using the editor of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the shebang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first line of a bash script is called the **shebang**. It is a character
    sequence that indicates the program loader’s first instruction. It defines which
    interpreter to run when reading, or interpreting, the script. The first line to
    indicate to use the bash interpreter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The shebang consists of a couple of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#!` instructs the program loader to load an interpreter for the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin/bash` indicates the bash or interpreter’s location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some typical shebangs for different interpreters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interpreter** | **Shebang** |'
  prefs: []
  type: TYPE_TB
- en: '| Bash | `#!/``bin/bash` |'
  prefs: []
  type: TYPE_TB
- en: '| Bourne shell | `#!/``bin/sh` |'
  prefs: []
  type: TYPE_TB
- en: '| Powershell | `#!/``user/bin/pwsh` |'
  prefs: []
  type: TYPE_TB
- en: '| Other scripting languages | `#!/``user/bin/env <interpreter>` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Shebang lines for different interpreters
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add comments to your bash script, simply start the comment with the `#` symbol
    and the pound sign, followed by comment text. This text can be used by you and
    other developers to document information that might not be easily understood from
    the code alone. It could also just add some details on the usage of the script,
    who the author is, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Adding print lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a bash file, to print lines out, simply use the `echo` command. These print
    lines will help you to understand exactly where your application is within its
    running process. Use these lines with intention and they will give you and your
    users some useful insight that can even make debugging easier.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within the bash script, we’ll generate builds for all the differing build tags
    for each operating system and architecture pair. Let’s first start to see which
    architecture values are available for Darwin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The values returned are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s generate the different Darwin builds – free, pro, and profile versions
    – for all architectures with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s do the same with Linux, first grabbing the architecture values
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The values returned are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s generate the different Linux builds – the free, pro, and profile versions
    – for all architectures with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s do the same with Windows, first grabbing the architecture values
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The values returned are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s generate the different Windows builds – the free, pro, and profile
    versions – for all architectures with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code when run from the Darwin/macOS or Linux terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that the executable files have been generated. The full list is
    quite long, and they have been organized within the following nested folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 12.2 – Screenshot of generated folders from the build bash script](img/Figure_12.2_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Screenshot of generated folders from the build bash script
  prefs: []
  type: TYPE_NORMAL
- en: A script to generate these builds will need to be different if run on Windows,
    for example. If you are running your application on Darwin or Linux, try running
    the build script and see the generated builds populate. You can now share these
    builds with other users running on a different platform. Next, we’ll create a
    PowerShell script to generate the same builds to run in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PowerShell script in Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a PowerShell script. Let’s name it `build.ps1`. Create
    the file by typing the following command within PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command asks to create the file when it does not exist. The file
    extension is `.ps1`, which indicates that the file is a PowerShell script type.
    Next, we want to edit it. You may use Notepad or another editor of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a bash script, a PowerShell script does not require a shebang. To learn
    more about how to write a PowerShell script, you can review the documentation
    here: [https://learn.microsoft.com/en-us/powershell/](https://learn.microsoft.com/en-us/powershell/).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add comments to your PowerShell script, simply start the comment with a `#`
    symbol and a pound sign, followed by comment text.
  prefs: []
  type: TYPE_NORMAL
- en: Adding print lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a PowerShell file, to print lines out, simply use the `Write-Output` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Writing output will help you to understand exactly where your application is
    within its running process, make it easier to debug, and give the user a sense
    that something is running. Having no output at all is not only boring but also
    communicates nothing to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within the PowerShell script, we’ll generate builds for all the differing build
    tags for each operating system and architecture pair. Let’s start by seeing which
    architecture values are available for Darwin via a Windows command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Select-String` command, we can return only the values that contain
    `darwin`. These values are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run a similar command for Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And a command for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The same values are returned within the previous sections, so I won’t print
    them out. However, now that we know how to get the architecture for each operating
    system, we can add the code to generate the builds for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to generate Darwin builds is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to generate Linux builds is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the code to generate Windows builds is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Each section generates a build for one of the three major operating systems
    and all the available architectures. To run the script from PowerShell, just run
    the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output for each port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `builds` folder to see all the ports generated successfully. The
    full list is quite long, and they have been organized within the following nested
    folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can generate builds for all operating systems and architectures from
    a PowerShell script, which can be run on Windows. If you run any of the major
    operating systems – Darwin, Linux, or Windows – you can now generate a build for
    your own platform or anyone else who would like to use your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what the `GOOS` and `GOARCH` environment variables
    are and how you can use them, as well as build tags, to customize builds based
    on the operating system, architecture, and levels. These environment variables
    help you to learn more about the environment you’re building in and possibly understand
    why a build may have trouble executing on another platform.
  prefs: []
  type: TYPE_NORMAL
- en: There are also two ways to compile an application – building or installing.
    In this chapter, we discussed how to build or install the application and what
    the difference is. The same flags are available for each command, but we discussed
    how to build or install on each of the major operating systems using the `Makefile`.
    However, this also showed how large the `Makefile` can become!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to create a simple script to run in Darwin, Linux, or
    Windows to generate all the builds needed for all the major operating systems.
    You learned how to write both a bash and PowerShell script to generate builds.
    In the next chapter, [*Chapter 13*](B18883_13.xhtml#_idTextAnchor331), *Using
    Containers for Distribution*, we will learn how to run these compiled applications
    on containers made from different operating system images. Finally, in [*Chapter
    14*](B18883_14.xhtml#_idTextAnchor359), *Publishing Your Go Binary as a Homebrew
    Formula with GoReleaser*, you’ll explore the tools required to automate the process
    of building and releasing your Go binaries across a range of operating systems
    and architectures. By learning how to use GoReleaser, you can significantly accelerate
    the process of releasing and deploying your application. This way, you can concentrate
    on developing new features and addressing bugs instead of getting bogged down
    with the build and compile process. Ultimately, using GoReleaser can save you
    valuable time and energy that you can use to make your application even better.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Go environment variables define the operating system and the architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What additional security do you get from building with a first-class port?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command would you run on Linux to find the port values for the Darwin operating
    system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GOOS` is the Golang operating system, and `GOARCH` is the Golang architecture
    value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several reasons why a first-class port is more secure: releases are
    blocked by broken builds, official binaries are provided, and installation is
    documented.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`go tool dist list |` `grep darwin`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read more about compiling at [https://go.dev/doc/tutorial/compile-install](https://go.dev/doc/tutorial/compile-install)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about Go environment variables at [https://pkg.go.dev/cmd/go](https://pkg.go.dev/cmd/go)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
