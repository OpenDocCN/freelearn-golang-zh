- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Cross-Compilation across Different Platforms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨不同平台的交叉编译
- en: 'This chapter introduces the user to cross-compilation, a powerful feature of
    Go, across different platforms. While build automation tools exist, understanding
    how to cross-compile provides essential knowledge for debugging and customization
    when necessary. This chapter will explain the different operating systems and
    architectures that Go can compile and how to determine which is needed. After
    Go is installed in your environment, there is a command, `go env`, with which
    you can see all the Go-related environment variables. We will discuss the two
    major ones used for building: `GOOS` and `GOARCH`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向用户介绍了 Go 在不同平台之间的交叉编译，这是 Go 的一个强大功能。尽管存在构建自动化工具，但了解如何进行交叉编译在必要时进行调试和定制时提供了基本知识。本章将解释
    Go 可以编译的不同操作系统和架构，以及如何确定需要哪些。在您的环境中安装 Go 之后，有一个命令 `go env`，您可以通过它查看所有与 Go 相关的环境变量。我们将讨论用于构建的两个主要变量：`GOOS`
    和 `GOARCH`。
- en: 'We will give examples of how to build or install an application for each major
    operating system: Linux, macOS, and Windows. You will learn how to determine the
    Go operating system and architecture settings based on your environment and the
    available architectures for each major operating system.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给出如何为每个主要操作系统（Linux、macOS 和 Windows）构建或安装应用程序的示例。您将学习如何根据您的环境和每个主要操作系统的可用架构确定
    Go 的操作系统和架构设置。
- en: 'This chapter ends with an example script to automate cross-compilation across
    the major operating systems and architectures. A script to run on the Darwin,
    Linux, or Windows environments is provided. In this chapter, we will cover the
    following topics in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以一个示例脚本结束，用于自动化跨不同操作系统和架构的交叉编译。提供了一个在 Darwin、Linux 或 Windows 环境上运行的脚本。在本章中，我们将详细介绍以下主题：
- en: Manual compilation versus build automation tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动编译与构建自动化工具
- en: Using `GOOS` and `GOARCH`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GOOS` 和 `GOARCH`
- en: Compiling for Linux, macOS, and Windows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Linux、macOS 和 Windows 编译
- en: Scripting to compile for multiple platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写脚本以编译多个平台
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以在 GitHub 上找到代码示例：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter12/audiofile)
- en: Manual compilation versus build automation tools
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动编译与构建自动化工具
- en: In [*Chapter 14*](B18883_14.xhtml#_idTextAnchor359), *Publishing Your Go Binary
    as a Homebrew Formula with GoReleaser*, we will delve into a fantastic open source
    tool, **GoReleaser**, which automates the process of building and releasing Go
    binaries. Despite its power and usefulness, it’s crucial to know how to manually
    compile your Go code. You see, not all projects can be built and released with
    GoReleaser. For instance, if your application requires unique build flags or dependencies,
    manual compilation may be necessary. Moreover, understanding how to manually compile
    your code is essential for addressing issues that may crop up during the build
    process. In essence, tools such as GoReleaser can make the process a lot smoother,
    but having a good grasp of the manual compile process is vital to ensure that
    your **command-line interface (CLI)** applications can be built and released in
    various scenarios.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 14 章*](B18883_14.xhtml#_idTextAnchor359) *使用 GoReleaser 将您的 Go 二进制文件作为
    Homebrew 公式发布* 中，我们将深入了解一个出色的开源工具 **GoReleaser**，它可以自动化构建和发布 Go 二进制文件的过程。尽管它功能强大且有用，但了解如何手动编译您的
    Go 代码至关重要。您会看到，并非所有项目都可以使用 GoReleaser 进行构建和发布。例如，如果您的应用程序需要独特的构建标志或依赖项，手动编译可能是必要的。此外，了解如何手动编译您的代码对于在构建过程中可能出现的任何问题至关重要。本质上，像
    GoReleaser 这样的工具可以使过程更加顺畅，但掌握手动编译过程对于确保您的 **命令行界面 (CLI) 应用程序可以在各种场景下构建和发布**至关重要。
- en: Using GOOS and GOARCH
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GOOS 和 GOARCH
- en: When developing your command-line application, it is important to maximize the
    audience by developing for as many platforms as possible. However, you may also
    want to target just a particular set of operating systems and architectures. In
    the past, it was much more difficult to deploy to platforms that differed from
    the one you were developing on. In fact, developing on a macOS platform and deploying
    it on a Windows machine involved setting up a Windows build machine to build the
    binary. The tooling would have to be synchronized, and there would be other deliberations
    that made collaborative testing and distribution cumbersome.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发你的命令行应用程序时，通过尽可能地为多个平台开发来最大化受众是很重要的。然而，你也可能只想针对特定的操作系统和架构。在过去，将应用程序部署到与开发平台不同的平台上要困难得多。实际上，在
    macOS 平台上开发并在 Windows 机器上部署涉及到设置一个 Windows 构建机器来构建二进制文件。工具需要同步，还有其他需要考虑的因素，使得协作测试和分发变得繁琐。
- en: Luckily, Golang has solved this by building support for multiple platforms directly
    into the language’s toolchain. As discussed in [*Chapter 7*](B18883_07.xhtml#_idTextAnchor143),
    *Developing for Different Platforms*, and [*Chapter 11*](B18883_11.xhtml#_idTextAnchor258),
    *Custom Builds and Testing CLI Commands*, we learned how to write platform-independent
    code and use the `go build` command and build tags to target specific operating
    systems and architectures. You may also use environment variables to target the
    operating system and architecture as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Golang 通过直接将支持多个平台的功能构建到语言的工具链中解决了这个问题。如在第 [*7章*](B18883_07.xhtml#_idTextAnchor143)
    和 [*第11章*](B18883_11.xhtml#_idTextAnchor258) 中讨论的，*为不同的平台开发* 和 *自定义构建和测试 CLI 命令*，我们学习了如何编写平台无关的代码，并使用
    `go build` 命令和构建标签来针对特定的操作系统和架构。你也可以使用环境变量来针对操作系统和架构。
- en: 'First, it’s good to know which operating systems and architectures are available
    for distribution. To find out, within your terminal, run the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解哪些操作系统和架构可用于分发是很好的。为了找出这些信息，在你的终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The list is output in the following format: `GOOS`/`GOARCH`. `GOOS` is a local
    environment variable that defines the operating system to compile for and stands
    for `GOARCH`, pronounced “gore-ch,” is a local environment variable that defines
    the architecture to compile for and stands for **Go Architecture**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表以以下格式输出：`GOOS`/`GOARCH`。`GOOS` 是一个本地环境变量，用于定义要编译的操作系统，代表 `GOARCH`，发音为“戈-arch”，是一个本地环境变量，用于定义要编译的架构，代表**Go
    架构**。
- en: '![Figure 12.1 – List of supported operating systems and architectures](img/Figure_12.1_B18883.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 支持的操作系统和架构列表](img/Figure_12.1_B18883.jpg)'
- en: Figure 12.1 – List of supported operating systems and architectures
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 支持的操作系统和架构列表
- en: 'You can also call the preceding command with the `–json` flag to view more
    details. For example, for `linux/arm64`, you can see that it’s supported by `Cgo`
    from the `"CgoSupported"` field, but also that it is a first-class `GOOS/GOARCH`
    pair, indicated by the `"``FirstClass"` field:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `–json` 标志调用前面的命令来查看更多详细信息。例如，对于 `linux/arm64`，你可以从 `"CgoSupported"`
    字段中看到它由 `Cgo` 支持，但也可以看到它是一个一级的 `GOOS/GOARCH` 对，由 `"FirstClass"` 字段指示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A first-class port has the following properties:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一级端口具有以下属性：
- en: Releases are blocked by broken builds
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布被损坏的构建所阻塞
- en: Official binaries are provided
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供官方的二进制文件
- en: Installation is documented
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装有文档说明
- en: 'Next, determine your local operating system and architecture settings by running
    the following command within your terminal:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在你的终端中运行以下命令来确定你的本地操作系统和架构设置：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Currently, running this command on my macOS machine with an AMD64 architecture
    gives the following output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在我的 macOS 机器上运行此命令，具有 AMD64 架构，得到以下输出：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first environment variable, `GOOS`, is set to `darwin`, and the second environment
    variable, `GOARCH`, is set to `amd64`. We now know what `GOOS` and `GOARCH` are
    within the Go environment, the possible values, and also what values are set on
    your machine. Let’s learn how to use these environment variables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个环境变量 `GOOS` 被设置为 `darwin`，第二个环境变量 `GOARCH` 被设置为 `amd64`。我们现在知道了在 Go 环境中 `GOOS`
    和 `GOARCH` 是什么，可能的值，以及你的机器上设置了哪些值。让我们学习如何使用这些环境变量。
- en: 'You can use these two environment variables for compiling. Let’s generate a
    build to target the `darwin/amd64` port. You’ll do so by setting the `GOOS` or
    `GOARCH` environment variables and then running the `go build` command, or more
    specifically along with the `build` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这两个环境变量进行编译。让我们生成一个构建来针对 `darwin/amd64` 端口。你可以通过设置 `GOOS` 或 `GOARCH` 环境变量，然后运行
    `go build` 命令，或者更具体地说，与 `build` 命令一起运行：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s try this out with the audio file CLI and learn all the ways to compile
    for the three main operating systems: Linux, macOS, and Windows.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用音频文件 CLI 来尝试这个命令，并学习如何为三个主要操作系统：Linux、macOS 和 Windows 编译。
- en: Compiling for Linux, macOS, and Windows
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Linux、macOS 和 Windows
- en: 'There are several different ways to compile our command-line application for
    different operating systems and we’ll go over examples of each of these. First,
    you can compile by building or installing your application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方式来编译我们的命令行应用程序以适应不同的操作系统，我们将逐一介绍这些示例。首先，你可以通过构建或安装你的应用程序来编译：
- en: '`–o` (output) flag'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–o`（输出）标志'
- en: '`$GOPATH/bin` folder or `$GOBIN` if it is set and caches all non-main packages,
    which are imported to the `$``GOPATH/pkg` folder'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$GOPATH/bin` 文件夹或 `$GOBIN` 如果已设置，将缓存所有非主包，这些包被导入到 `$GOPATH/pkg` 文件夹'
- en: Building using tags
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签构建
- en: 'In our previous chapter, [*Chapter 11*](B18883_11.xhtml#_idTextAnchor258),
    *Custom Builds and Testing CLI Commands*, we learned to build specifically for
    the macOS or Darwin operating system. To better understand how to use the `build`
    command, we run `go build –help` to see the usage:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节 [*第 11 章*](B18883_11.xhtml#_idTextAnchor258)，*自定义构建和测试 CLI 命令*，我们学习了如何专门为
    macOS 或 Darwin 操作系统构建。为了更好地理解如何使用 `build` 命令，我们运行 `go build –help` 来查看用法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running `go help build` will reveal the build flags available. However, in
    these examples, we only use the `tags` flag. Within the `Makefile`, we already
    have the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `go help build` 将会显示可用的构建标志。然而，在这些示例中，我们只使用了 `tags` 标志。在 `Makefile` 中，我们已经有以下命令：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In these commands, we compile the application and output it to the `bin/audiofile`
    filename. To specify the Darwin operating system, we pass in the Darwin build
    tag to specify the files associated with the Darwin operating system. We’ll need
    to modify the output files to a folder that specifies Darwin, but also for other
    specifics such as the free versus the pro version since we’ll be building for
    other operating systems and levels. Let’s modify these.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些命令中，我们编译应用程序并将其输出到 `bin/audiofile` 文件名。为了指定 Darwin 操作系统，我们传递 Darwin 构建标签来指定与
    Darwin 操作系统相关的文件。我们需要修改输出文件到一个指定 Darwin 的文件夹，但也要为其他具体细节，比如免费版与专业版，因为我们将为其他操作系统和级别构建。让我们修改这些。
- en: Building applications for a Darwin operating system using tags
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标签构建 Darwin 操作系统应用程序
- en: 'The new `Makefile` commands to compile the application for the Darwin operating
    system are now as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 Darwin 操作系统应用程序的新 `Makefile` 命令现在如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve swapped out the `bin/audiofile` output to something more specific. The
    free version for Darwin now outputs to `builds/free/darwin/audiofile`, the pro
    version outputs to `builds/pro/darwin/audiofile`, and the profile version outputs
    to `builds/profile/darwin/audiofile`. Let’s continue with the next operating system,
    Linux.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `bin/audiofile` 输出替换为更具体的内容。Darwin 的免费版现在输出到 `builds/free/darwin/audiofile`，专业版输出到
    `builds/pro/darwin/audiofile`，配置文件版输出到 `builds/profile/darwin/audiofile`。让我们继续下一个操作系统，Linux。
- en: 'We can do the same for Linux and Windows, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 Linux 和 Windows 做同样的事情，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The free Windows version is output to `builds/free/windows/audiofile.exe`, the
    pro Windows version is output to `builds/pro/windows/audiofile.exe`, and the Windows
    profile version is output to `builds/profile/windows/audiofile.exe`. Now, suppose
    we don’t want to run each of the individual commands one by one, as there are
    so many to run! We can write a command to build all versions using tags.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 免费版的 Windows 版本输出到 `builds/free/windows/audiofile.exe`，专业版的 Windows 版本输出到 `builds/pro/windows/audiofile.exe`，而
    Windows 配置文件版本输出到 `builds/profile/windows/audiofile.exe`。现在，假设我们不想逐个运行这些命令，因为有很多命令需要运行！我们可以编写一个命令来使用标签构建所有版本。
- en: Building applications for all operating systems using tags
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标签构建适用于所有操作系统的应用程序
- en: 'Let’s add a new `Makefile` command to build all the operating systems. Basically,
    we write one command that calls all other commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新的 `Makefile` 命令来构建所有操作系统。基本上，我们写一个命令来调用所有其他命令：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s try running this command via the terminal:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过终端运行这个命令：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you’re running on Darwin, you’ll see the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行 Darwin，您将看到以下输出：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I’ve removed part of the error message; however, the most important message
    is `GOOS redeclared in this block`. This error message comes up when the operating
    system is set but conflicts with the `GOOS` environment variable. For example,
    the command that failed used the operating build tag to specify a Linux build:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经删除了部分错误信息；然而，最重要的信息是 `GOOS redeclared in this block`。当操作系统被设置但与 `GOOS` 环境变量冲突时，会出现此错误信息。例如，失败的命令使用了操作构建标签来指定
    Linux 构建：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, running `go env | grep GOOS` in my macOS terminal shows the value
    of the `GOOS` environment variable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我的 macOS 终端中运行 `go env | grep GOOS` 显示了 `GOOS` 环境变量的值：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s modify the build commands to set the `GOOS` environment variable so it
    matches the output type based on the build tag.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改构建命令，以设置 `GOOS` 环境变量，使其与基于构建标签的输出类型相匹配。
- en: Building using the GOOS environment variable
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GOOS 环境变量进行构建
- en: 'The Linux builds have been modified to set the `GOOS` environment variable
    to Linux by prepending `GOOS=linux` before the `build` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 构建已被修改，通过在 `build` 命令之前添加 `GOOS=linux` 来设置 `GOOS` 环境变量：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Windows builds have been modified to set the `GOOS` environment variable
    to Windows by prepending `GOOS=windows` before the `build` command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 构建已被修改，通过在 `build` 命令之前添加 `GOOS=windows` 来设置 `GOOS` 环境变量：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s try the `build-all` command again. It runs successfully and we can
    see all the files generated by the `build` command by running `find –type –f ./builds`
    in the repo:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试 `build-all` 命令。它运行成功，并且我们可以通过在 repo 中运行 `find –type –f ./builds`
    来查看 `build` 命令生成的所有文件：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Building using the GOARCH environment variable
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GOARCH 环境变量进行构建
- en: 'Many different possible architecture values can be associated with a single
    operating system. Rather than creating a command for each, we’ll start with just
    one example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单个操作系统可以关联许多不同的架构值。我们不会为每个架构创建一个命令，而是从仅一个示例开始：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example specifies the operating system, the `GOOS` environment variable,
    as `darwin`, and then the architecture, the `GOARCH` environment variable, as
    `amd64`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例指定了操作系统，`GOOS` 环境变量为 `darwin`，然后是架构，`GOARCH` 环境变量为 `amd64`。
- en: There’d be too many commands to create if we were to create a `build` command
    for each architecture of each major operating system. We’ll save this for a script
    within the last section of this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为每个主要操作系统的每个架构创建一个 `build` 命令，将会产生太多的命令。我们将把这个留到本章最后部分的脚本中。
- en: Installing using tags and GOOS env va
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签和 GOOS 环境变量进行安装
- en: 'As mentioned earlier, another way to compile your command-line application
    is by installing it. The `install` command compiles the application, like the
    `go build` command, but also with the additional step of moving the compiled application
    to the `$GOPATH/bin` folder or `$GOBIN` value. To learn more about the `install`
    command, we run the following `go install –``help` command:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，另一种编译您的命令行应用程序的方法是通过安装它。`install` 命令编译应用程序，就像 `go build` 命令一样，但还额外包含将编译后的应用程序移动到
    `$GOPATH/bin` 文件夹或 `$GOBIN` 值的步骤。要了解更多关于 `install` 命令的信息，我们运行以下 `go install –help`
    命令：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The same flags for building are available for installing. Again, we will use
    the `tags` flag only. Let’s first run the `install` command on the macOS system:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建时使用的标志对于安装也是可用的。再次强调，我们只会使用 `tags` 标志。让我们首先在 macOS 系统上运行 `install` 命令：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, running `go env | grep GOPATH` in my macOS terminal shows the value
    of the `GOOS` environment variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我的 macOS 终端中运行 `go env | grep GOPATH` 显示了 `GOOS` 环境变量的值：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Confirm that the audio file CLI executable exists in the `$GOPATH/bin` or `/``Users/mmontagnino/Code/bin`
    folder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 确认音频文件 CLI 可执行文件存在于 `$GOPATH/bin` 或 `/Users/mmontagnino/Code/bin` 文件夹中。
- en: As mentioned, we can use build tags to separate builds based on the operating
    system and architecture. Within the audio file repository, we’re already doing
    so with the following files associated with the `play` and `bug` commands. For
    the `bug` command, we have the following files. Now, let’s add some `install`
    commands within the `Makefile` now that we understand how to use the build tags
    and `GOOS` environment variables.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用构建标签根据操作系统和架构来分离构建。在音频文件仓库中，我们已经在以下文件中这样做，这些文件与 `play` 和 `bug` 命令相关联。对于
    `bug` 命令，我们有以下文件。现在，既然我们已经了解了如何使用构建标签和 `GOOS` 环境变量，让我们在 `Makefile` 中添加一些 `install`
    命令。
- en: install commands for the Darwin operating system
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Darwin 操作系统的 install 命令
- en: 'The `install` commands for the Darwin operating system include passing in the
    specific tags, including `darwin`, and the levels, defined by tags, to install:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Darwin 操作系统的 `install` 命令包括传递特定的标记，包括 `darwin`，以及由标记定义的级别，以安装：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: install commands for the Linux operating system
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 操作系统的安装命令
- en: 'The `install` commands for the Linux operating system include passing in the
    specific tags, including `linux`, and the package to install. To ensure the commands
    do not error out with conflicting `GOOS` settings, we set the matching environment
    variable, `GOOS`, to `linux`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 操作系统的 `install` 命令包括传递特定的标记，包括 `linux`，以及要安装的软件包。为了确保命令不会因为冲突的 `GOOS`
    设置而出错，我们将匹配的环境变量 `GOOS` 设置为 `linux`：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: install commands for the Windows operating system
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 操作系统的安装命令
- en: 'The `install` commands for the Windows operating system include passing in
    the specific tags, including `windows`, and the package to install. To ensure
    the commands do not error out with conflicting `GOOS` settings, we set the matching
    environment variable, `GOOS`, to `windows`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统的 `install` 命令包括传递特定的标记，包括 `windows`，以及要安装的软件包。为了确保命令不会因为冲突的 `GOOS`
    设置而出错，我们将匹配的环境变量 `GOOS` 设置为 `windows`：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember that for your `Makefile`, you’ll need to change the location of the
    package if you have forked the repo under your own account. Run the `make` command
    for the operating system you need and confirm that the application is installed
    by checking the `$GOPATH/bin` or `$``GOBIN` folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于您的 `Makefile`，如果您在自己的账户下分叉了仓库，您需要更改软件包的位置。运行您需要的操作系统的 `make` 命令，并通过检查
    `$GOPATH/bin` 或 `$GOBIN` 文件夹来确认应用程序已安装。
- en: Installing using tags and GOARCH env var
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标记和 GOARCH 环境变量进行安装
- en: 'While many different possible architecture values can be associated with a
    single operating system, let’s start with just one example of installing with
    `GOARCH` `env var`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多不同的架构值可以与单个操作系统相关联，但让我们从一个使用 `GOARCH` 环境变量的安装示例开始：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example specifies the operating system, the `GOOS` environment variable,
    as `linux`, and then the architecture, the `GOARCH` environment variable, as `amd64`.
    Rather than creating a command for each pair of operating systems and architectures,
    again, we’ll save this for a script within the last section of this chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例指定了操作系统，`GOOS` 环境变量为 `linux`，然后是架构，`GOARCH` 环境变量为 `amd64`。我们不会为每一对操作系统和架构创建命令，再次，我们将此保存为本章最后部分的脚本中。
- en: Scripting to compile for multiple platforms
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译多个平台的脚本
- en: We’ve learned several different ways to compile for operating systems using
    the `GOOS` and `GOARCH` environment variables and using build tags. The `Makefile`
    can fill up rather quickly with all the different combinations of `GOOS`/`GOARCH`
    pairs and scripting may provide a better solution if you want to generate builds
    for many more specific architectures.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用 `GOOS` 和 `GOARCH` 环境变量以及使用构建标记编译操作系统的几种不同方法。`Makefile` 可能会很快填满所有不同的
    `GOOS`/`GOARCH` 对组合，如果您想要为更多特定的架构生成构建，脚本可能提供更好的解决方案。
- en: Creating a bash script to compile in Darwin or Linux
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于在 Darwin 或 Linux 中编译的 bash 脚本
- en: 'Let’s start by creating a bash script. Let’s name it `build.sh`. To create
    the file, I simply type the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个 bash 脚本。让我们称它为 `build.sh`。要创建文件，我只需输入以下内容：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding command creates the file when it does not exist. The file extension
    is `.sh`, which, while unnecessary to add, clearly indicates that the file is
    a bash script type. Next, we want to edit it. If using `vi`, use the following
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令在文件不存在时创建文件。文件扩展名是 `.sh`，虽然添加它不是必需的，但它清楚地表明该文件是 bash 脚本类型。接下来，我们想要编辑它。如果使用
    `vi`，请使用以下命令：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Otherwise, edit the file using the editor of your choice.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，使用您选择的编辑器编辑文件。
- en: Adding the shebang
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 shebang
- en: 'The first line of a bash script is called the **shebang**. It is a character
    sequence that indicates the program loader’s first instruction. It defines which
    interpreter to run when reading, or interpreting, the script. The first line to
    indicate to use the bash interpreter is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: bash 脚本的第一行被称为 **shebang**。它是一个字符序列，指示程序加载器的第一条指令。它定义了在读取或解释脚本时要运行的解释器。以下是要使用
    bash 解释器的第一行指示：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The shebang consists of a couple of elements:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: shebang 由几个元素组成：
- en: '`#!` instructs the program loader to load an interpreter for the code'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!` 指示程序加载器加载代码的解释器'
- en: '`/bin/bash` indicates the bash or interpreter’s location'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin/bash` 表示 bash 或解释器的位置'
- en: 'These are some typical shebangs for different interpreters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是不同解释器的典型 shebang：
- en: '| **Interpreter** | **Shebang** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **解释器** | **Shebang** |'
- en: '| Bash | `#!/``bin/bash` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| Bash | `#!/``bin/bash` |'
- en: '| Bourne shell | `#!/``bin/sh` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Bourne shell | `#!/``bin/sh` |'
- en: '| Powershell | `#!/``user/bin/pwsh` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Powershell | `#!/``user/bin/pwsh` |'
- en: '| Other scripting languages | `#!/``user/bin/env <interpreter>` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 其他脚本语言 | `#!/``user/bin/env <解释器>` |'
- en: Table 12.1 – Shebang lines for different interpreters
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1 – 不同解释器的 shebang 行
- en: Adding comments
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加注释
- en: To add comments to your bash script, simply start the comment with the `#` symbol
    and the pound sign, followed by comment text. This text can be used by you and
    other developers to document information that might not be easily understood from
    the code alone. It could also just add some details on the usage of the script,
    who the author is, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要向您的 bash 脚本添加注释，只需用 `#` 符号和井号开始注释，然后是注释文本。这些文本可以由您和其他开发者使用，以记录可能仅从代码本身难以理解的信息。它也可以只是添加一些有关脚本使用、作者等信息。
- en: Adding print lines
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加打印行
- en: In a bash file, to print lines out, simply use the `echo` command. These print
    lines will help you to understand exactly where your application is within its
    running process. Use these lines with intention and they will give you and your
    users some useful insight that can even make debugging easier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bash 文件中，要打印行，只需使用 `echo` 命令。这些打印行将帮助您了解应用程序在其运行过程中的确切位置。有目的地使用这些行，它们将为您和您的用户提供一些有用的见解，甚至可以使调试更容易。
- en: Adding code
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码
- en: 'Within the bash script, we’ll generate builds for all the differing build tags
    for each operating system and architecture pair. Let’s first start to see which
    architecture values are available for Darwin:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bash 脚本中，我们将为每个操作系统和架构对生成所有不同的构建标签的构建。让我们首先看看 Darwin 可用的架构值：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The values returned are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s generate the different Darwin builds – free, pro, and profile versions
    – for all architectures with the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码生成所有架构的不同 Darwin 构建 – 免费版、专业版和配置文件版：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let’s do the same with Linux, first grabbing the architecture values
    available:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用 Linux 做同样的事情，首先获取可用的架构值：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The values returned are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值如下：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s generate the different Linux builds – the free, pro, and profile versions
    – for all architectures with the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码生成所有架构的不同 Linux 构建 – 免费版、专业版和配置文件版：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, let’s do the same with Windows, first grabbing the architecture values
    available:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用 Windows 做同样的事情，首先获取可用的架构值：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The values returned are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值如下：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, let’s generate the different Windows builds – the free, pro, and profile
    versions – for all architectures with the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下代码生成所有架构的不同 Windows 构建 – 免费版、专业版和配置文件版：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s the code when run from the Darwin/macOS or Linux terminal:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自 Darwin/macOS 或 Linux 终端的运行代码：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can check that the executable files have been generated. The full list is
    quite long, and they have been organized within the following nested folder structure:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查是否已生成可执行文件。完整的列表相当长，并且它们已被组织在以下嵌套文件夹结构中：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Figure 12.2 – Screenshot of generated folders from the build bash script](img/Figure_12.2_B18883.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 从构建 bash 脚本生成的文件夹截图](img/Figure_12.2_B18883.jpg)'
- en: Figure 12.2 – Screenshot of generated folders from the build bash script
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 从构建 bash 脚本生成的文件夹截图
- en: A script to generate these builds will need to be different if run on Windows,
    for example. If you are running your application on Darwin or Linux, try running
    the build script and see the generated builds populate. You can now share these
    builds with other users running on a different platform. Next, we’ll create a
    PowerShell script to generate the same builds to run in Windows.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Windows 上运行，例如，生成这些构建的脚本可能需要不同。如果您在 Darwin 或 Linux 上运行应用程序，请尝试运行构建脚本并查看生成的构建。您现在可以与其他在平台不同的用户共享这些构建。接下来，我们将创建一个
    PowerShell 脚本来生成在 Windows 上运行的相同构建。
- en: Creating a PowerShell script in Windows
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 中创建 PowerShell 脚本
- en: 'Let’s start by creating a PowerShell script. Let’s name it `build.ps1`. Create
    the file by typing the following command within PowerShell:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个 PowerShell 脚本开始。让我们将其命名为 `build.ps1`。在 PowerShell 中输入以下命令以创建文件：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding command asks to create the file when it does not exist. The file
    extension is `.ps1`, which indicates that the file is a PowerShell script type.
    Next, we want to edit it. You may use Notepad or another editor of your choice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令会在文件不存在时创建文件。文件扩展名是 `.ps1`，这表示文件是 PowerShell 脚本类型。接下来，我们想要编辑它。你可以使用记事本或其他你选择的编辑器。
- en: 'Unlike a bash script, a PowerShell script does not require a shebang. To learn
    more about how to write a PowerShell script, you can review the documentation
    here: [https://learn.microsoft.com/en-us/powershell/](https://learn.microsoft.com/en-us/powershell/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与 bash 脚本不同，PowerShell 脚本不需要 shebang。要了解更多关于如何编写 PowerShell 脚本的信息，你可以在此处查看文档：[https://learn.microsoft.com/en-us/powershell/](https://learn.microsoft.com/en-us/powershell/)。
- en: Adding comments
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加注释
- en: To add comments to your PowerShell script, simply start the comment with a `#`
    symbol and a pound sign, followed by comment text.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的 PowerShell 脚本添加注释，只需在注释文本前加上一个 `#` 符号和货币符号。
- en: Adding print lines
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加打印行
- en: 'In a PowerShell file, to print lines out, simply use the `Write-Output` command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 文件中，要打印行，只需使用 `Write-Output` 命令：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Writing output will help you to understand exactly where your application is
    within its running process, make it easier to debug, and give the user a sense
    that something is running. Having no output at all is not only boring but also
    communicates nothing to the user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出写作将帮助你确切了解你的应用程序在其运行过程中的位置，使调试更容易，并给用户一种正在运行的感觉。完全没有输出不仅无聊，而且对用户没有任何沟通。
- en: Adding code
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码
- en: 'Within the PowerShell script, we’ll generate builds for all the differing build
    tags for each operating system and architecture pair. Let’s start by seeing which
    architecture values are available for Darwin via a Windows command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 脚本中，我们将为每个操作系统和架构对生成所有不同的构建标签。让我们先通过 Windows 命令查看 Darwin 可用的架构值：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using the `Select-String` command, we can return only the values that contain
    `darwin`. These values are returned:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Select-String` 命令，我们可以只返回包含 `darwin` 的值。这些值被返回：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can run a similar command for Linux:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 Linux 运行一个类似的命令：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And a command for Windows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个 Windows 的命令：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The same values are returned within the previous sections, so I won’t print
    them out. However, now that we know how to get the architecture for each operating
    system, we can add the code to generate the builds for all of them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中返回了相同的值，所以我不需要打印它们。然而，既然我们已经知道如何为每个操作系统获取架构，我们就可以添加代码来生成所有操作系统的构建。
- en: 'The code to generate Darwin builds is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 Darwin 构建的代码如下：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The code to generate Linux builds is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 Linux 构建的代码如下：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, the code to generate Windows builds is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成 Windows 构建的代码如下：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Each section generates a build for one of the three major operating systems
    and all the available architectures. To run the script from PowerShell, just run
    the following script:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分为三个主要操作系统之一和所有可用的架构生成一个构建。要从 PowerShell 运行脚本，只需运行以下脚本：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following will be the output for each port:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每个端口的输出如下：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Check the `builds` folder to see all the ports generated successfully. The
    full list is quite long, and they have been organized within the following nested
    folder structure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `builds` 文件夹以查看所有成功生成的端口。完整的列表相当长，并且它们已经被组织在以下嵌套文件夹结构中：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we can generate builds for all operating systems and architectures from
    a PowerShell script, which can be run on Windows. If you run any of the major
    operating systems – Darwin, Linux, or Windows – you can now generate a build for
    your own platform or anyone else who would like to use your application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从 PowerShell 脚本中生成所有操作系统和架构的构建，该脚本可以在 Windows 上运行。如果你运行任何主要操作系统——Darwin、Linux
    或 Windows——你现在可以为你的平台或任何希望使用你的应用程序的其他人生成构建。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what the `GOOS` and `GOARCH` environment variables
    are and how you can use them, as well as build tags, to customize builds based
    on the operating system, architecture, and levels. These environment variables
    help you to learn more about the environment you’re building in and possibly understand
    why a build may have trouble executing on another platform.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 `GOOS` 和 `GOARCH` 环境变量是什么，以及如何使用它们，以及如何使用构建标签来根据操作系统、架构和级别自定义构建。这些环境变量帮助你了解你正在构建的环境，并可能理解为什么构建可能在其他平台上执行时遇到问题。
- en: There are also two ways to compile an application – building or installing.
    In this chapter, we discussed how to build or install the application and what
    the difference is. The same flags are available for each command, but we discussed
    how to build or install on each of the major operating systems using the `Makefile`.
    However, this also showed how large the `Makefile` can become!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 编译应用程序有两种方式——构建或安装。在本章中，我们讨论了如何构建或安装应用程序以及它们之间的区别。每个命令都提供了相同的标志，但我们讨论了如何使用`Makefile`在各个主要操作系统上构建或安装。然而，这也显示了`Makefile`可以变得多么庞大！
- en: Finally, we learned how to create a simple script to run in Darwin, Linux, or
    Windows to generate all the builds needed for all the major operating systems.
    You learned how to write both a bash and PowerShell script to generate builds.
    In the next chapter, [*Chapter 13*](B18883_13.xhtml#_idTextAnchor331), *Using
    Containers for Distribution*, we will learn how to run these compiled applications
    on containers made from different operating system images. Finally, in [*Chapter
    14*](B18883_14.xhtml#_idTextAnchor359), *Publishing Your Go Binary as a Homebrew
    Formula with GoReleaser*, you’ll explore the tools required to automate the process
    of building and releasing your Go binaries across a range of operating systems
    and architectures. By learning how to use GoReleaser, you can significantly accelerate
    the process of releasing and deploying your application. This way, you can concentrate
    on developing new features and addressing bugs instead of getting bogged down
    with the build and compile process. Ultimately, using GoReleaser can save you
    valuable time and energy that you can use to make your application even better.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何创建一个简单的脚本，在Darwin、Linux或Windows上运行，以生成所有主要操作系统的所有构建。你学习了如何编写bash和PowerShell脚本以生成构建。在下一章[第13章](B18883_13.xhtml#_idTextAnchor331)《使用容器进行分发》中，我们将学习如何在由不同操作系统镜像创建的容器上运行这些编译后的应用程序。最后，在第14章[第14章](B18883_14.xhtml#_idTextAnchor359)《使用GoReleaser将Go二进制文件作为Homebrew公式发布》中，你将探索自动化构建和发布Go二进制文件到各种操作系统和架构所需的工具。通过学习如何使用GoReleaser，你可以显著加快发布和部署应用程序的过程。这样，你可以专注于开发新功能和处理错误，而不是陷入构建和编译过程。最终，使用GoReleaser可以节省你宝贵的时间和精力，你可以将这些时间用于使你的应用程序更加出色。
- en: Questions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What Go environment variables define the operating system and the architecture?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些Go环境变量定义了操作系统和架构？
- en: What additional security do you get from building with a first-class port?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一流端口构建可以获得哪些额外的安全性？
- en: What command would you run on Linux to find the port values for the Darwin operating
    system?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux上，你会运行什么命令来找到Darwin操作系统的端口号？
- en: Answers
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`GOOS` is the Golang operating system, and `GOARCH` is the Golang architecture
    value.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GOOS`是Golang操作系统，而`GOARCH`是Golang架构值。'
- en: 'There are several reasons why a first-class port is more secure: releases are
    blocked by broken builds, official binaries are provided, and installation is
    documented.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么一流端口更安全有几个原因：发布被损坏的构建阻止，提供官方的二进制文件，以及安装有文档说明。
- en: '`go tool dist list |` `grep darwin`.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go tool dist list |` `grep darwin`.'
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Read more about compiling at [https://go.dev/doc/tutorial/compile-install](https://go.dev/doc/tutorial/compile-install)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://go.dev/doc/tutorial/compile-install](https://go.dev/doc/tutorial/compile-install)了解更多关于编译的信息
- en: Read more about Go environment variables at [https://pkg.go.dev/cmd/go](https://pkg.go.dev/cmd/go)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://pkg.go.dev/cmd/go](https://pkg.go.dev/cmd/go)了解更多关于Go环境变量的信息
