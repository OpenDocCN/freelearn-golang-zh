<html><head></head><body>
		<div id="_idContainer107">
			<h1 id="_idParaDest-260" class="chapter-number"><a id="_idTextAnchor331"/>13</h1>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor332"/>Using Containers for Distribution</h1>
			<p>In this chapter, we’ll explore the world of containerization and examine the many reasons why you should use Docker containers for testing and distributing your applications. The term <em class="italic">containerization</em> refers<a id="_idIndexMarker794"/> to a style of software packaging that makes it simple to deploy and run in any setting. First, we’ll go over the basics of Docker, covered by a simple application that can be built into an image and run as a container. Then, we return to our audiofile application, for a more advanced example, to learn how to create multiple Docker containers that can be composed and run together. These examples give you not only an understanding of the basic flags used for running containers but also some advanced flags that show you how to run containers with mapped network stacks, volumes, <span class="No-Break">and ports.</span></p>
			<p>We also explain how to use Docker containers for integration testing, which increases your confidence, because, let’s face it, mocking API responses can cover only so much. A good mix of unit and integration tests gives you not just the coverage but also confidence that the overall <span class="No-Break">system works.</span></p>
			<p>Finally, we will discuss some of the disadvantages of adopting Docker. Consider the increased complexity of administering containerized applications, as well as the additional overhead of operating several containers on a single host. Docker as an external dependency may be a disadvantage in itself. This chapter will help you determine when to use, and not to use, containers for <span class="No-Break">your application.</span></p>
			<p>By the end of this chapter, you will have a strong grasp of how to utilize Docker containers and how they might assist your development, testing, and deployment workflow. You will be able to containerize your application, test it with Docker, and release it with Docker Hub. Specifically, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Why <span class="No-Break">use containers?</span></li>
				<li>Testing <span class="No-Break">with containers</span></li>
				<li>Distributing <span class="No-Break">with containers</span></li>
			</ul>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor333"/>Technical requirement</h1>
			<p>For this chapter, you will need to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Download and install Docker Desktop <span class="No-Break">at </span><a href="https://www.docker.com/products/docker-desktop/"><span class="No-Break">https://www.docker.com/products/docker-desktop/</span></a><a href="https://www.docker.com/products/docker-desktop/&#13;"/></li>
				<li>Install the Docker <span class="No-Break">Compose plugin</span></li>
			</ul>
			<p>You can also find the code examples on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter13</span></a></p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor334"/>Why use containers?</h1>
			<p>First, let’s talk <a id="_idIndexMarker795"/>about what a container is. A <strong class="bold">container</strong> is a standardized software unit that allows the transport of a program from one computing environment quickly and reliably to another by bundling the application’s code and all its dependencies into a single encapsulation. Simply put, containers let you package all your dependencies into a single container so that it can run on any machine. Containers are isolated from one another and bundle their own system libraries and settings, so they don’t conflict with other containers or the host system. This makes them a lightweight and portable <a id="_idIndexMarker796"/>alternative to <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>). Popular<a id="_idIndexMarker797"/> containerization tools<a id="_idIndexMarker798"/> include <strong class="bold">Docker</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Kubernetes</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor335"/>Benefiting from containers</h2>
			<p>Let’s break down<a id="_idIndexMarker799"/> some of the benefits of using containers in your <span class="No-Break">Go project:</span></p>
			<ul>
				<li><strong class="bold">Portability</strong>: Containers make it possible to support consistency of behavior across various environments, lowering the possibility of errors <span class="No-Break">and incompatibilities.</span></li>
				<li><strong class="bold">Isolation</strong>: They offer a degree of isolation from the host system and other containers, which increases their level of security and reduces their propensity <span class="No-Break">for conflicts.</span></li>
				<li><strong class="bold">Lightweight</strong>: Compared to VMs, containers are smaller and start up faster, which increases their <span class="No-Break">operating efficiency.</span></li>
				<li><strong class="bold">Scalability</strong>: They<a id="_idIndexMarker800"/> can be easily scaled up or down, enabling effective resource use. For example, if you utilize containers for your application, then you can create multiple identical containers running your application deployed across <span class="No-Break">multiple servers.</span></li>
				<li><strong class="bold">Versioning</strong>: Containers can be versioned, making it simple to revert to earlier iterations <span class="No-Break">as needed.</span></li>
				<li><strong class="bold">Modularity</strong>: Because containers can be created and managed separately, they are simple to upda<a id="_idTextAnchor336"/>te <span class="No-Break">and maintain.</span></li>
				<li><strong class="bold">Cost-effective</strong>: By lowering the number of systems you need to run your applications, containers can help you save money on infrastructure <span class="No-Break">and maintenance.</span></li>
			</ul>
			<p>Creating and running command-line applications is made simple and reliable by containers. Regardless of the host machine’s configuration, this means that the application will always be built and run in the same manner. Application development and deployment across different operating systems are made significantly simpler by including all necessary dependencies and runtime environments within the container image. Finally, containers make it simple to duplicate development environments, enabling multiple developers or teams to work together in the same area while guaranteeing that the application is developed and executed uniformly across <span class="No-Break">various environments.</span></p>
			<p>Additionally, using containers makes it simpler to integrate applications with <strong class="bold">continuous integration and continuous deployment </strong>(<strong class="bold">CI/CD</strong>) pipelines. Since all the necessary dependencies exist <a id="_idIndexMarker801"/>within the container’s image, the pipeline can more reliably and easily build and run the application, eliminating the need to configure the pipeline’s host machine’s <span class="No-Break">development environment.</span></p>
			<p>Finally, the consistency of an isolated environment with containers is another benefit that makes it easier to distribute your command-line application while guaranteeing that it will operate exactly as expected. Users no longer need to configure their environment for the application, making containers, while also lightweight, a great way to distribute across various environments <span class="No-Break">and platforms.</span></p>
			<p>As you can clearly see, there are a variety of situations where containers can prove useful, including command-line application development and testing! Now, let’s discuss when you may not want to <span class="No-Break">use containers.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor337"/>Deciding not to use containers</h2>
			<p>While containers<a id="_idIndexMarker802"/> are often helpful, there are some circumstances in which they might not be the <span class="No-Break">best option:</span></p>
			<ul>
				<li><strong class="bold">High-performance computing</strong>: High-performance computing and other tasks that need direct access to the host system’s resources might not be good candidates for containers because of the additional overhead <span class="No-Break">they cause.</span></li>
				<li><strong class="bold">Requiring high levels of security</strong>: Containers share the host’s kernel and might not offer as much isolation as a VM. VMs may be a better option if your workload demands a high level <span class="No-Break">of security.</span></li>
				<li><strong class="bold">Neglecting container-native features</strong>: You may not see the benefit of using containers if you do not plan on using any of the native features included for scaling, rolling updates, service discovery, and <span class="No-Break">load balancing.</span></li>
				<li><strong class="bold">Inflexible applications</strong>: If an application requires a very specific operating environment in order to function properly, it might not even be possible to containerize it, as there are limited operating systems and platforms that <span class="No-Break">are supported.</span></li>
				<li><strong class="bold">Team inertia</strong>: If you or your team are unwilling to learn about containers and container orchestration, then it will be difficult to incorporate a <span class="No-Break">new tool.</span></li>
			</ul>
			<p>Nevertheless, it’s important to note that these situations are not always the case and that there are some solutions available, including the use of VMs, particular security features of container <a id="_idIndexMarker803"/>orchestration<a id="_idIndexMarker804"/> platforms, specialized container runtimes such as <strong class="bold">gVisor</strong> or <strong class="bold">Firecracker</strong>, <span class="No-Break">and others.</span></p>
			<p>In the following examples and within the next sections, we will be using Docker to show how easy it can be to start using Docker and use it to create a consistent environment for testing <span class="No-Break">and distribution.</span></p>
			<p>In the <strong class="source-inline">Chapter-13</strong> GitHub repository, we go over a very simple example for building an image and <a id="_idIndexMarker805"/>running a container. The <strong class="source-inline">main.go</strong> file <span class="No-Break">is simple:</span></p>
			<pre class="source-code">
func main() {
    var helloFlag bool
    flag.BoolVar(&amp;helloFlag, "hello", false, "Print 'Hello,
      World!'")
    flag.Parse()
    if helloFlag {
        fmt.Println("Hello, World!")
    }
}</pre>
			<p>Passing in the <strong class="source-inline">hello</strong> flag to the built application will print out <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Hello, World!"</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor338"/>Building a simple Docker image</h2>
			<p>To start, software<a id="_idIndexMarker806"/> can be packaged as an <strong class="bold">image</strong>, a small, self-contained executable that contains the program’s source code, libraries, configuration files, runtime, and environment variables. Images are the building blocks of containers and are used to create and <span class="No-Break">run them.</span></p>
			<p>Let’s build a Docker image for this very simple application. To do so, we’ll need to create a <strong class="bold">Dockerfile</strong>. You<a id="_idIndexMarker807"/> can create a file named <strong class="source-inline">Dockerfile</strong> that will automatically be recognized when you run the command-line Docker commands, or create a file with the <strong class="source-inline">.dockerfile</strong> extension, which will require the <strong class="source-inline">–f</strong> or <strong class="source-inline">--file</strong> flag for passing in <span class="No-Break">the filename.</span></p>
			<p>A Dockerfile contains instructions for building a Docker image, as depicted in the following diagram. Each instruction creates a new layer within the image. The layers are combined to create the final image. There are many different kinds of instructions you can put in the Dockerfile. For example, you can tell Docker to copy files into the base image, set environment variables, run commands, and specify the executables to run when a container <span class="No-Break">is initialized:</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/Figure_13.1_B18883.jpg" alt="Figure 13.1 – Visual of a Dockerfile transformed into an image with layers by the build command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Visual of a Dockerfile transformed into an image with layers by the build command</p>
			<p>For our base <a id="_idIndexMarker808"/>image, let’s visit Docker Hub’s website at <a href="https://hub.docker.com">https://hub.docker.com</a> and search for the official Golang Docker base image for Go <strong class="source-inline">v1.19</strong>. We see that we can use the <strong class="source-inline">golang</strong> image with tag <strong class="source-inline">1.19</strong>. The <strong class="source-inline">FROM</strong> instruction is the first line of the Dockerfile and it sets the base image <span class="No-Break">to use:</span></p>
			<pre class="source-code">
<strong class="source-inline">FROM golang:1.19</strong></pre>
			<p>Then, copy all <span class="No-Break">the files:</span></p>
			<pre class="source-code">
<strong class="source-inline">COPY . .</strong></pre>
			<p>Build the <strong class="source-inline">hello </strong><span class="No-Break"><strong class="source-inline">world</strong></span><span class="No-Break"> application:</span></p>
			<pre class="source-code">
<strong class="source-inline">RUN go build main.go</strong></pre>
			<p>Finally, run the application while passing the <span class="No-Break"><strong class="source-inline">hello</strong></span><span class="No-Break"> flag:</span></p>
			<pre class="source-code">
<strong class="source-inline">CMD ["./main", "--hello"]</strong></pre>
			<p>Altogether, the Dockerfile contains the preceding instructions with some descriptive comments indicated by <strong class="source-inline">#</strong> as the first character <span class="No-Break">in line.</span></p>
			<p>To build a Docker image from a Dockerfile, we call the <strong class="source-inline">docker build</strong> command. The command takes the <span class="No-Break">following syntax:</span></p>
			<pre class="source-code">
<strong class="source-inline">docker build [options] path| url | -</strong></pre>
			<p>When run, the<a id="_idIndexMarker809"/> command does <span class="No-Break">the following:</span></p>
			<ul>
				<li>Reads the instructions specified within the Dockerfile and performs them <span class="No-Break">in order</span></li>
				<li>Each instruction creates a new layer in the image, and the final image combines <span class="No-Break">them all</span></li>
				<li>Tags the new image with the specified or generated name, and—optionally—a tag in the <span class="No-Break"><strong class="source-inline">name:tag</strong></span><span class="No-Break"> format</span></li>
			</ul>
			<p>The <strong class="source-inline">options</strong> parameter can be used to pass in different options to the command, which can include build-time variables, targets, and more. The <strong class="source-inline">path | url | -</strong> argument specifies the location of <span class="No-Break">the Dockerfile.</span></p>
			<p>Let’s try building this image from the Dockerfile we created for our hello world application. Within the root of the repository, run the <span class="No-Break">following command:</span></p>
			<p><strong class="source-inline">docker build --</strong><span class="No-Break"><strong class="source-inline">tag hello-world:latest</strong></span></p>
			<p>After running the command, you should see similar output <span class="No-Break">to this:</span></p>
			<pre class="console">
[+] Building 2.4s (8/8) FINISHED
=&gt; [internal] load build definition from Dockerfile          0.0s
=&gt; =&gt; transferring dockerfile: 238B                          0.0s
=&gt; [internal] load .dockerignore                             0.0s
=&gt; =&gt; transferring context: 2B                               0.0s
=&gt; [internal] load metadata for docker.io/library/golang:1.19 1.2s
=&gt; [internal] load build context                             0.0s
=&gt; =&gt; transferring context: 2.25kB                           0.0s
=&gt; CACHED [1/4] FROM docker.io/library/golang:1.19@sha256:bb9811fad43a7d6fd217324 0.0s
=&gt; [2/4] COPY . .                                            0.0s
=&gt; [3/4] RUN go build main.go                                1.0s
=&gt; exporting to image                                        0.1s
=&gt; =&gt; exporting layers                                       0.0s
=&gt; =&gt; writing image sha256:91f97dc0109218173ccae884981f700c83848aaf524266de20f950   0.0s
=&gt; =&gt; naming to docker.io/library/hello-world:latest         0.0s</pre>
			<p>From about<a id="_idIndexMarker810"/> midway through the output, you’ll see that the layers of the image are built, concluding with the final image tagged <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">hello-world:latest</strong></span><span class="No-Break">.</span></p>
			<p>You can view the images that exist, by running the following command in <span class="No-Break">your terminal:</span></p>
			<pre class="console">
% docker images
REPOSITORY         TAG        IMAGE ID        CREATED        SIZE
hello-world    latest    91f97dc01092    18 minutes ago  846MB</pre>
			<p>Now that we’ve successfully built our Docker image for this simple hello world application, let’s follow up by running it within <span class="No-Break">a container.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor339"/>Running a simple Docker container</h2>
			<p>When<a id="_idIndexMarker811"/> you run a Docker container, Docker Engine takes an existing image and creates a new running instance of it. This container exists within an isolated environment that has its own filesystem, network interfaces, and process space. However, the image is a necessary starting point for creating—or <span class="No-Break">running—the container.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">When a container is running, it can make changes to the filesystem, such as creating or modifying files. However, these changes are not saved in the image and will be lost when the container is stopped. If you want to save the changes, you can create a new image of the container using the <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">commit</strong></span><span class="No-Break"> command.</span></p>
			<p>To create and run a Docker container from an image, we call the <strong class="source-inline">docker run</strong> command. The command takes the <span class="No-Break">following syntax:</span></p>
			<p><strong class="source-inline">docker run [options] image[:tag] [</strong><span class="No-Break"><strong class="source-inline">command] [arg...]</strong></span></p>
			<p>The <strong class="source-inline">docker run</strong> command checks if the image exists locally; if not, then it will pull it from Docker Hub. Docker Engine then creates a new container from this image, with all layers or instructions applied. We’ll break this <span class="No-Break">down here:</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/Figure_13.2_B18883.jpg" alt="Figure 13.2 – Visual of an image used to create a container with the run command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Visual of an image used to create a container with the run command</p>
			<p>As <a id="_idIndexMarker812"/>mentioned, when <strong class="source-inline">docker run</strong> is called, the following <span class="No-Break">steps occur:</span></p>
			<ol>
				<li>Docker checks if the requested image exists locally; if not, it retrieves it from a registry, such as <span class="No-Break">Docker Hub.</span></li>
				<li>From the image, it creates a <span class="No-Break">new container.</span></li>
				<li>It starts the container and executes the commands specified within the instructions of <span class="No-Break">the Dockerfile.</span></li>
				<li>It attaches the terminal to the container’s process in order to display any output from <span class="No-Break">the commands.</span></li>
			</ol>
			<p>The <strong class="source-inline">options</strong> parameter can be used to pass in different options to the command, which can include mapping ports, setting environment variables, and more. The <strong class="source-inline">image[:tag]</strong> argument specifies the image to use for creating the container. Finally, the <strong class="source-inline">command</strong> and <strong class="source-inline">[arg...]</strong> arguments are used to specify any commands to run within <span class="No-Break">the container.</span></p>
			<p>In each example that we call the <strong class="source-inline">docker run</strong> command, we pass in the <strong class="source-inline">--rm</strong> flag, which tells Docker to automatically remove the container when it exits. This will save you from accidentally ending up with many gigabytes of stopped containers sitting in <span class="No-Break">the background.</span></p>
			<p>Try to run<a id="_idIndexMarker813"/> an image from the <strong class="source-inline">hello-world:latest</strong> image that we created for our hello world application. Within the root of the repository, run the following command and see the <span class="No-Break">text output:</span></p>
			<pre class="console">
% docker run --rm hello-world:latest
Hello, World!</pre>
			<p>We did it! A simple Dockerfile for a simple hello world application. Within the next two sections, we’ll return to the audiofile command-line application example and use this new skill of building images and running containers for testing <span class="No-Break">and distribution.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor340"/>Testing with containers</h1>
			<p>So far, within <a id="_idIndexMarker814"/>our command-line application journey, we’ve built tests and mocked the service output. The benefit of using containers, besides having a consistent and isolated environment for tests to run on any host machine, is that you can use them for running integration tests that provide more reliable test coverage for <span class="No-Break">your application.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor341"/>Creating the integration test file</h2>
			<p>We<a id="_idIndexMarker815"/> created a new <strong class="source-inline">integration_test.go</strong> file to handle the configuration and execution of integration tests, but we don’t want it to run with all the other tests. To specify its uniqueness, let’s tag it with <strong class="source-inline">int</strong>, short for integration. At the top of the file, we add the following <span class="No-Break">build tag:</span></p>
			<pre class="source-code">
//go:build int &amp;&amp; pro</pre>
			<p>We include the <strong class="source-inline">pro</strong> build tag because we are testing all the <span class="No-Break">available features.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor342"/>Writing the integration tests</h2>
			<p>First, let’s<a id="_idIndexMarker816"/> write the <strong class="source-inline">ConfigureTest()</strong> function to prepare for our <span class="No-Break">integration tests:</span></p>
			<pre class="source-code">
func ConfigureTest() {
    getClient = &amp;http.Client{
        Timeout: 15 * time.Second,
    }
    viper.SetDefault("cli.hostname", "localhost")
    viper.SetDefault("cli.port", 8000)
    utils.InitCLILogger()
}</pre>
			<p>In the <a id="_idIndexMarker817"/>preceding code, you can see that we use an actual client, not the mocked client that is currently used within unit tests. We use <strong class="source-inline">viper</strong> to set the hostname and port for the API we connect as localhost on port <strong class="source-inline">8000</strong>. Finally, we initialize the logger files so that we don’t run into any panics <span class="No-Break">while logging.</span></p>
			<p>For the integration test, let’s use a <a id="_idIndexMarker818"/><span class="No-Break">specific workflow:</span></p>
			<ol>
				<li><strong class="bold">Upload audio</strong>: First, we want to make sure an audio file exists within the <span class="No-Break">local storage.</span></li>
				<li><strong class="bold">Get audio by id</strong>: From the previous step, we can retrieve the audiofile ID returned and use this to retrieve the audio metadata <span class="No-Break">from storage.</span></li>
				<li><strong class="bold">List all audio</strong>: We list all the audio metadata and confirm that the previously uploaded audio exists within <span class="No-Break">the list.</span></li>
				<li><strong class="bold">Search audio by value</strong>: Search for that uploaded audio based on metadata we know exists within <span class="No-Break">the description.</span></li>
				<li><strong class="bold">Delete audio by id</strong>: Finally, delete the initial audio file we uploaded by the ID we retrieved from <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></li>
			</ol>
			<p>The order is specific as the latter steps within the workflow depend on <span class="No-Break">the first.</span></p>
			<p>The inte<a id="_idTextAnchor343"/>gration tests are like the unit tests, but paths to real files are passed in, and the actual API is called. Within the <strong class="source-inline">integration_tests.go</strong> file exists a <strong class="source-inline">TestWorkflow</strong> function that calls the commands in the order listed previou<a id="_idTextAnchor344"/>sly. Since the code is similar to the unit tests, let’s just go over the first two command calls, and then move straight into using Docker to execute the <span class="No-Break">integration tests!</span></p>
			<p>Before any methods <a id="_idIndexMarker819"/>are tested, the integration test is configured by calling the <span class="No-Break"><strong class="source-inline">ConfigureTest</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
ConfigureTest()
fmt.Println("*** Testing upload ***")
b := bytes.NewBufferString("")
rootCmd.SetOut(b)
rootCmd.SetArgs([]string{"upload", "--filename",
  "../audio/algorithms.mp3"})
err := rootCmd.Execute()
if err != nil {
    fmt.Println("err: ", err)
}
uploadResponse, err := ioutil.ReadAll(b)
if err != nil {
    t.Fatal(err)
}
id := string(uploadResponse)
if id == "" {
    t.Fatalf("expected id returned")
}</pre>
			<p>In the preceding code, we then use <strong class="source-inline">rootCmd</strong> to call the <strong class="source-inline">upload</strong> command with the filename set to <strong class="source-inline">../audio/algorithms.mp3</strong>. We execute the command and read the response back as a byte slice that is then converted to a string and stored in the <strong class="source-inline">id</strong> variable. This <strong class="source-inline">id</strong> variable is then used for the following tests. We run the <strong class="source-inline">get</strong> command and pass in the same <strong class="source-inline">id</strong> variable to retrieve the audiofile metadata for the previously <a id="_idIndexMarker820"/><span class="No-Break">uploaded audio:</span></p>
			<pre class="source-code">
fmt.Println("*** Testing get ***")
rootCmd.SetArgs([]string{"get", "--id", id, "--json"})
err = rootCmd.Execute()
if err != nil {
    fmt.Println("err: ", err)
}
getResponse, err := ioutil.ReadAll(b)
if err != nil {
    t.Fatal(err)
}
var audio models.Audio
json.Unmarshal(getResponse, &amp;audio)
if audio.Id != id {
    t.Fatalf("expected matching audiofile returned")
}</pre>
			<p>We continue testing the <strong class="source-inline">list</strong>, <strong class="source-inline">search</strong>, and <strong class="source-inline">delete</strong> commands similarly and ensure that the specific metadata with a matching <strong class="source-inline">id</strong> variable is returned each time. When the tests are done, we try to run the integration test. Without the API running locally, running the following command <span class="No-Break">fails miserably:</span></p>
			<pre class="console">
go test ./cmd -tags "int pro"</pre>
			<p>Before we try again, let’s build a Dockerfile to run the API within a <span class="No-Break">contained environment.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor345"/>Writing the Dockerfiles</h2>
			<p>In the<a id="_idIndexMarker821"/> real world, our API might be hosted on some external website. However, we are currently running on <strong class="source-inline">localhost</strong>, and running it within a container will allow users to easily run it no matter which machine they use. In this section, we will<a id="_idIndexMarker822"/> create two Dockerfiles: one for the CLI and another for <span class="No-Break">the API.</span></p>
			<h3>Writing the API Dockerfile</h3>
			<p>First, we’ll <a id="_idIndexMarker823"/>create an <strong class="source-inline">api.Dockerfile</strong> file to hold all the instructions to build the image and run the container for the <span class="No-Break">audiofile API:</span></p>
			<pre class="source-code">
FROM golang:1.19
# Set the working directory
WORKDIR /audiofile
# Copy the source code
COPY . .
# Download the dependencies
RUN go mod download
# Expose port 8000
EXPOSE 8000
# Build the audiofile application with the pro tag so all
# features are available
RUN go build -tags "pro" -o audiofile main.go
RUN chmod +x audiofile
# Start the audiofile API
CMD ["./audiofile", "api"]</pre>
			<p>Let’s<a id="_idIndexMarker824"/> build this image. The <strong class="source-inline">–f</strong> flag allows you to specify the <strong class="source-inline">api.Dockerfile</strong> file to use, and the <strong class="source-inline">–t</strong> flag allows you to name and tag <span class="No-Break">the image:</span></p>
			<pre class="console">
% docker build -f api.Dockerfile -t audiofile:api .</pre>
			<p>After the command executes, you can run the <strong class="source-inline">docker images</strong> command to confirm <span class="No-Break">its creation:</span></p>
			<pre class="console">
% docker images
REPOSITORY        TAG        IMAGE ID        CREATED        SIZE
audiofile      api         12afba7f3fb7        9 minutes ago  1.75GB</pre>
			<p>Now that we see that the image has been built successfully, let’s run the container and test <span class="No-Break">it out!</span></p>
			<p>Run the following command to run <span class="No-Break">the container:</span></p>
			<pre class="console">
% docker run -p 8000:8000 --rm audiofile:api
Starting API at http://localhost:8000
Press Ctrl-C to stop.</pre>
			<p>You’ll see the preceding output if the API is started successfully. We have the audiofile API running in a container within your host. Remember that any commands will check against the flat file storage, pointing to the <strong class="source-inline">audiofile</strong> directory created under the <strong class="source-inline">home</strong> directory. Any audio files uploaded, processed, and with metadata stored within the container will not be saved unless we commit the changes. Since we are just running integration tests, this won’t <span class="No-Break">be necessary.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">–p</strong> flag within the <strong class="source-inline">docker run</strong> command allows you to specify the port mapping between the host and container. The syntax is <strong class="source-inline">-p host_port:container_port</strong>.  This maps the host’s port to the <span class="No-Break">container’s port.</span></p>
			<p>Within a separate terminal, let’s run the integration tests again and see <span class="No-Break">them pass:</span></p>
			<pre class="console">
% go test ./cmd -tags "int pro"
ok      github.com/marianina8/audiofile/cmd     0.909s</pre>
			<p>Success! We’ve <a id="_idIndexMarker825"/>now run integration tests connecting to the audiofile API within <span class="No-Break">a container.</span></p>
			<h3>Writing the CLI Dockerfile</h3>
			<p>Now, for<a id="_idIndexMarker826"/> running the CLI integration tests within a container, we’ll create a <strong class="source-inline">cli.Dockerfile</strong> file. It will hold all the instructions to build the image and run the container for the <span class="No-Break">integration tests:</span></p>
			<pre class="source-code">
FROM golang:1.19
# Set the working directory
WORKDIR /audiofile
# Copy the source code
COPY . .
# Download the dependencies
RUN go mod download
# Execute `go test -v ./cmd -tags int pro` when the
# container is running
CMD ["go", "test", "-v", "./cmd", "-tags", "int pro"]</pre>
			<p>The preceding comments clarify each instruction, but let’s break down the <span class="No-Break">Docker instructions:</span></p>
			<ol>
				<li>Specify and pull from the base image <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">golang:1.19</strong></span><span class="No-Break">.</span></li>
				<li>Set the working directory <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/audiofile</strong></span><span class="No-Break">.</span></li>
				<li>Copy over all the source code to the <span class="No-Break">working directory.</span></li>
				<li>Download all the <span class="No-Break">Go dependencies.</span></li>
				<li>Execute <strong class="source-inline">go test –v ./cmd -tags </strong><span class="No-Break"><strong class="source-inline">int pro</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Let’s build<a id="_idIndexMarker827"/> <span class="No-Break">this image:</span></p>
			<pre class="console">
% docker build -f cli.Dockerfile -t audiofile:cli .</pre>
			<p>Then, while ensuring the <strong class="source-inline">audiofile:api</strong> container is already running, run the <span class="No-Break"><strong class="source-inline">audiofile:cli</strong></span><span class="No-Break"> container:</span></p>
			<pre class="console">
% docker run --rm --network host audiofile:cli</pre>
			<p>You’ll see that the integration tests <span class="No-Break">run successfully.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">--network host</strong> flag within the <strong class="source-inline">docker run</strong> command is used to connect a container to the host’s network stack. It means that the container will have access to the host’s network interfaces, IP address, and ports. Be careful with security if the container runs <span class="No-Break">any service.</span></p>
			<p>Now, we’ve created two containers for the API and CLI, but rather than having to run each separately within two separate terminals, it’d be easier to use <strong class="bold">Docker Compose</strong>. Docker Compose <a id="_idIndexMarker828"/>is a plugin for Docker Engine that allows you to define and run multiple Docker applications all with a single file, <strong class="source-inline">docker-compose.yml</strong>, starting and stopping the entire application with a single <span class="No-Break"><strong class="source-inline">stop/start</strong></span><span class="No-Break"> command.</span></p>
			<h3>Writing the Docker Compose file</h3>
			<p>Inside <a id="_idIndexMarker829"/>the <strong class="source-inline">docker-compose.yml</strong> Docker Compose file, we define both containers that need to be run, while specifying any parameters we’ve previously set via flags for the <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
version: '3'
services:
  cli:
    build:
      context: .
      dockerfile: cli.Dockerfile
    image: audiofile:cli
    network_mode: host
    depends_on:
      - api
  api:
    build:
      context: .
      dockerfile: api.Dockerfile
    image: audiofile:api
    ports:
    - "8000:8000"</pre>
			<p>Let’s explain<a id="_idIndexMarker830"/> the preceding file. First, there are two services defined: <strong class="source-inline">cli</strong> and <strong class="source-inline">api</strong>. Beneath each service are a set of <span class="No-Break">similar keys:</span></p>
			<ul>
				<li>The <strong class="source-inline">build</strong> key, which is used to specify the context and location of <span class="No-Break">the Dockerfile.</span></li>
				<li>The <strong class="source-inline">context</strong> key is used to specify where to look for the Dockerfile. Both are set to <strong class="source-inline">.</strong>, which tells the Docker Compose service to look in the <span class="No-Break">current directory.</span></li>
				<li>The <strong class="source-inline">dockerfile</strong> key allows us to specify the name of the Dockerfile—in this case, <strong class="source-inline">cli.Dockerfile</strong> for the <strong class="source-inline">cli</strong> service and <strong class="source-inline">api.Dockerfile</strong> for the <span class="No-Break"><strong class="source-inline">api</strong></span><span class="No-Break"> service.</span></li>
				<li>The <strong class="source-inline">image</strong> key allows us to give a name and tag <span class="No-Break">the image.</span></li>
			</ul>
			<p>For the <strong class="source-inline">cli</strong> service, we’ve added some <span class="No-Break">further keys:</span></p>
			<ul>
				<li>The <strong class="source-inline">network_mode</strong> key is used to specify the networking mode for a service. When it is set to <strong class="source-inline">host</strong>, like it is for the <strong class="source-inline">cli</strong> service, it means to use the host machine’s network stack (like the <strong class="source-inline">–network host</strong> flag used when calling <strong class="source-inline">docker run</strong> for <span class="No-Break">the CLI).</span></li>
				<li>The <strong class="source-inline">depends_on</strong> key allows us to specify the order of which services should be running first. In this case, the <strong class="source-inline">api</strong> service must be <span class="No-Break">running first</span></li>
				<li>For the <strong class="source-inline">api</strong> service, there’s <a id="_idIndexMarker831"/>an <span class="No-Break">additional key:</span></li>
				<li>The <strong class="source-inline">ports</strong> key is used to specify port mappings between the host machine and the container. Its syntax is <strong class="source-inline">`host_port:container_port`</strong> and is like the <strong class="source-inline">–p</strong> or <strong class="source-inline">--publish</strong> flag when calling the <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command.</span></li>
			</ul>
			<p>Now that we’ve got the Docker Compose file completed, we just have one simple command, <strong class="source-inline">docker-compose up</strong>, to run the integration tests within a <span class="No-Break">containerized environment:</span></p>
			<pre class="console">
% docker-compose up
[+] Running 3/2
<img src="image/014.png" alt=""/> Network audiofile_default  Created                        0.1s
<img src="image/014.png" alt=""/> Container audiofile-api-1  Created                        0.0s
<img src="image/014.png" alt=""/> Container audiofile-cli-1  Created                        0.0s
Attaching to audiofile-api-1, audiofile-cli-1
audiofile-api-1  | Starting API at http://localhost:8000
audiofile-api-1  | Press Ctrl-C to stop.
audiofile-cli-1  | === RUN   TestWorkflow
audiofile-cli-1  | --- PASS: TestWorkflow (1.14s)
…
audiofile-cli-1  | ok   github.com/marianina8/audiofile/cmd     1.163s</pre>
			<p>Now, no <a id="_idIndexMarker832"/>matter which platform you’re running the containers on, the results will be consistent while running the tests within a container. Integration testing provides more comprehensive testing as it will catch bugs that might exist within<a id="_idIndexMarker833"/> the <strong class="bold">end-to-end</strong> (<strong class="bold">E2E</strong>) flow from the command to the API to the filesystem and back. We can therefore increase our confidence with tests that can ensure our CLI and API are more stable and reliable as a whole. In the next section, we’ll discuss how to distribute your CLI application <span class="No-Break">with containers.</span></p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor346"/>Distributing with containers</h1>
			<p>There are<a id="_idIndexMarker834"/> various advantages to running a CLI inside a container as opposed to directly on the host. Utilizing a container makes the setup and installation of the program easier. This can be helpful if the application needs numerous dependencies or libraries that are challenging to install. Additionally, regardless of the language or tools used to construct the program, adopting a container enables a more dependable and uniform method of distribution. Using a container as a distribution method can be a flexible solution for the majority of applications that can operate in a Linux environment, even though there may be language-specific alternatives. Finally, distributing through containers will be useful for developers unfamiliar with the Go language but who already have the Docker toolbox installed on <span class="No-Break">their machines.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor347"/>Building a new image to run as an executable</h2>
			<p>To<a id="_idIndexMarker835"/> build an image that can run as an executable, we must create an <strong class="source-inline">ENTRYPOINT</strong> instruction on the image to specify the main executable. Let’s create a new Dockerfile, <strong class="source-inline">dist.Dockerfile</strong>, which contains the <span class="No-Break">following instructions:</span></p>
			<pre class="source-code">
FROM golang:1.19
# Set the working directory
WORKDIR /audiofile
# Copy the source code
COPY . .
# Download the dependencies
RUN go mod download
# Expose port 8000
EXPOSE 8000
# Build the audiofile application with the pro tag so all
# features are available
RUN go build -tags "pro" -o audiofile main.go
# Start the audiofile API
ENTRYPOINT ["./audiofil<a id="_idTextAnchor348"/>e"]</pre>
			<p>Since these <a id="_idIndexMarker836"/>instructions are mostly similar to the other Dockerfiles explained in the previous sections, we won’t go into a detailed explanation. The only instruction to n<a id="_idTextAnchor349"/>ote is the <strong class="source-inline">ENTRYPOINT</strong> instruction, which specifies <strong class="source-inline">./audiofile</strong> as the <span class="No-Break">main executable.</span></p>
			<p>We can build this image with the <span class="No-Break">following command:</span></p>
			<pre class="console">
% docker build -f dist.Dockerfile -t audiofile:dist .</pre>
			<p>After confirming that the image is successfully built, we are now ready to run the container and interact with it as <span class="No-Break">an executable.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor350"/>Interacting with your container as an executable</h2>
			<p>To interact <a id="_idIndexMarker837"/>with your container as an executable, you can configure your container to use an interactive TTY (terminal) with the <strong class="source-inline">ENTRYPOINT</strong> command in Docker. The <strong class="source-inline">-i</strong> and <strong class="source-inline">–t</strong> options stand for <em class="italic">interactive</em> and <em class="italic">TTY</em> respectively, and when the two flags work together, you can interact with the <strong class="source-inline">ENTRYPOINT</strong> command in a terminal-like environment. Remember to have the API running first. Now, let’s show how it’ll look when we run the container for the <span class="No-Break"><strong class="source-inline">audiofile:dist</strong></span><span class="No-Break"> image:</span></p>
			<pre class="console">
% docker run --rm --network host -ti audiofile:dist help
A command line interface allows you to interact with the Audiofile service.
Basic commands include: get, list, and upload.
Usage:
  audiofile [command]
Available Commands:
...
Use "audiofile [command] --help" for more information about a command.</pre>
			<p>Just by typing <strong class="source-inline">help</strong> at the end of the <strong class="source-inline">docker run</strong> command passes in <strong class="source-inline">help</strong> as input to the main executable, or <strong class="source-inline">ENTRYPOINT</strong>: <strong class="source-inline">./audiofile</strong>. As expected, the help text <span class="No-Break">is output.</span></p>
			<p>The <strong class="source-inline">docker run</strong> command uses a few additional commands; the <strong class="source-inline">–network host</strong> flag uses the host’s network stack for the container, and the <strong class="source-inline">–rm</strong> command tells Docker to automatically remove the container when <span class="No-Break">it exits.</span></p>
			<p>You can run any of the commands by just replacing the word <strong class="source-inline">help</strong> with the name of the other command. To run <strong class="source-inline">upload</strong>, for example, run <span class="No-Break">this command:</span></p>
			<pre class="console">
% docker run --rm --network host -ti audiofile:dist upload –filename audio/algorithms.mp3</pre>
			<p>You can <a id="_idIndexMarker838"/>now interact with your command-line application through a container passing in commands and not have to worry if it will respond any differently based on the host machine. As previously mentioned, any filesystem changes, or files uploaded, as in preceding the file, are not saved when the container exists. There is a way to run the API so that local file storage maps to a <span class="No-Break">container path.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor351"/>Mapping host machine to container file paths</h2>
			<p>As mentioned, you <a id="_idIndexMarker839"/>can map a host machine path to a Docker container file path so that files on the host computer may be accessed from inside the container. This can be helpful for things such as giving the container access to data volumes or application <span class="No-Break">configuration files.</span></p>
			<p>The <strong class="source-inline">-v</strong> or <strong class="source-inline">—volume</strong> option can be used to translate a host machine path to a container path when executing a container. This flag’s syntax is <strong class="source-inline">host path:container path</strong>. For instance, the <strong class="source-inline">docker run -v /app/config:/etc/config imageName:tag</strong> command would be used to map the host machine’s <strong class="source-inline">/app/config</strong> directory to the container’s <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">etc/config</strong></span><span class="No-Break"> directory.</span></p>
			<p>It’s crucial to remember that both the host path and container path need to be present in the container image before the container can be executed. You must construct the container path before starting the container if it does not already exist in the <span class="No-Break">container image.</span></p>
			<p>If you dig into the audiofile API that is running on your local host, you’ll see that the flat file storage is mapped to the <strong class="source-inline">/audiofile</strong> folder existing under the host’s <strong class="source-inline">home</strong> directory. On my macOS instance, if I wanted to run the audiofile API within a Docker container but be able to read from and access or upload data to the flat file storage, then I would need to map the <strong class="source-inline">audiofile</strong> directory under my <strong class="source-inline">HOME</strong> directory to an appropriate location. This <strong class="source-inline">docker run</strong> command would <span class="No-Break">do it:</span></p>
			<pre class="console">
docker run -p 8000:8000 --rm -v $HOME/audiofile:/root/audiofile  audiofile:api</pre>
			<p>Run the preceding command first and then run the CLI container, or modify the<strong class="source-inline"> docker-compose.yml</strong> file’s API service to include <span class="No-Break">the following:</span></p>
			<pre class="source-code">
    volumes:
      - "${HOME}/audiofile:/root/audiofile"</pre>
			<p>Either way, when <a id="_idIndexMarker840"/>you run the container for integration tests or as an executable, you’ll be interacting with your local storage mapped to the <strong class="source-inline">/root/audiofile</strong> directory within the container. If you’ve been playing around with the audiofile CLI and uploading directory, then when you start the container up and run the <strong class="source-inline">list</strong> command, you’ll see preexisting metadata instead of an empty <span class="No-Break">list returned.</span></p>
			<p>Mapping a path from your host to a container is an option that you can share with your users when instructing them how to use the <span class="No-Break">audiofile application.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor352"/>Reducing image size by using multi-stage builds</h2>
			<p>By<a id="_idIndexMarker841"/> running the <strong class="source-inline">docker images</strong> command, you’ll see that some of the images built are quite large. To reduce the size of these images, you may need to rewrite your Dockerfile to use multi-stage builds. A <strong class="bold">multi-stage build</strong> is a <a id="_idIndexMarker842"/>process of dividing up the build into multiple stages, in which it is possible to remove unnecessary dependencies, artifacts, and configurations from the final image. This is especially useful when building images for large applications where you can save on deployment time as well as <span class="No-Break">infrastructure costs.</span></p>
			<p>A way that<a id="_idIndexMarker843"/> single-stage and multi-stage builds differ is that multi-stage builds allow you to use multiple <strong class="source-inline">FROM</strong> statements, each defining a new stage of the build process. You can selectively copy artifacts, or builds, from one stage or another, allowing you to take what you need and discard the rest, essentially allowing you to remove anything unnecessary and clean <span class="No-Break">up space.</span></p>
			<p>Let’s consider the <strong class="source-inline">dist.Dockerfile</strong> file and rewrite it. In our multi-stage build process, let’s define <span class="No-Break">our stages:</span></p>
			<ul>
				<li><strong class="bold">Stage 1</strong>: Build <span class="No-Break">our application</span></li>
				<li><strong class="bold">Stage 2</strong>: Copy the executable, expose the port, and create an <span class="No-Break">entry point</span></li>
			</ul>
			<p>First, we create a new file, <strong class="source-inline">dist-multistage.Dockerfile</strong>, with the <span class="No-Break">following instructions:</span></p>
			<pre class="source-code">
# Stage 1
FROM golang:1.19 AS build
WORKDIR /audiofile
COPY . .
RUN go mod download
RUN go build -tags "pro" -o audiofile main.go
# Stage 2
FROM alpine:latest
COPY --from=build /audiofile/audiofile .
EXPOSE 8000
ENTRYPOINT ["./audiofile"]</pre>
			<p>In <em class="italic">Stage 1</em>, we <a id="_idIndexMarker844"/>copy all the code files, download all dependencies, then build the application—basically, all as in the original instructions within <strong class="source-inline">dist.Dockerfile</strong>, but <a id="_idIndexMarker845"/>without the <strong class="source-inline">EXPOSE</strong> and <strong class="source-inline">ENTRYPOINT</strong> instructions. One thing to note is that we’ve named the stage <strong class="source-inline">build</strong>, with the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
FROM golang:1.19 AS build</pre>
			<p>In <em class="italic">Stage 2</em>, we copy over just the compiled binary from the <strong class="source-inline">build</strong> stage and nothing else. To do this, we run the <span class="No-Break">following instruction:</span></p>
			<pre class="source-code">
COPY --from=build /audiofile/audiofile .</pre>
			<p>The command allows us to copy a file or directory from a previous stage, <strong class="source-inline">build</strong>, to the current stage. The <strong class="source-inline">--from=build</strong> option specifies the stage name to copy the file from. <strong class="source-inline">/audiofile/audiofile</strong> is the path of the file in the <strong class="source-inline">build</strong> stage, and <strong class="source-inline">.</strong> at the end of the command specifies the destination directory, the root directory, of the <span class="No-Break">current stage.</span></p>
			<p>Let’s try building it and comparing the new size against the <span class="No-Break">original size:</span></p>
			<pre class="console">
REPOSITORY TAG            IMAGE ID        CREATED        SIZE
audiofile    dist            1361cbc7be3e    2 minutes ago    1.78GB
audiofile     dist-multistage    ab5640f99ef2    5 minutes ago    24MB</pre>
			<p>That’s a <a id="_idIndexMarker846"/>big difference! Using <a id="_idIndexMarker847"/>multi-stage builds will help you to save on deployment time and infrastructure costs, so it’s definitely worth the time writing your Dockerfiles using <span class="No-Break">this process.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor353"/>Distributing your Docker image</h2>
			<p>There are <a id="_idIndexMarker848"/>many methods for making your Docker images accessible to others. <strong class="bold">Docker Hub</strong>, a public registry where you can post your <a id="_idIndexMarker849"/>images and make them readily available to others, is a popular alternative. Another alternative is to <a id="_idIndexMarker850"/>use <strong class="bold">GitHub Packages</strong> to store and distribute your Docker images alongside other sorts of packages. There are other <a id="_idIndexMarker851"/>cloud-based registries such as <strong class="bold">Amazon Elastic Container Registry</strong> (<strong class="bold">ECR</strong>), <strong class="bold">Google Container Registry</strong> (<strong class="bold">GCR</strong>), and <strong class="bold">Azure Container Registry</strong> (<strong class="bold">ACR</strong>) that <a id="_idIndexMarker852"/>provide extra services such as <a id="_idIndexMarker853"/>image scanning (for OS vulnerabilities, for example) <span class="No-Break">and signing.</span></p>
			<p>It’s a good idea to give instructions on how to utilize your image and run a container in the README file of the repository where the image is located. People who are interested in utilizing your image will be able to readily access instructions on how to retrieve the image, run a container using the image, and any other <span class="No-Break">pertinent facts.</span></p>
			<p>There are several advantages to publishing a Docker image, including simple distribution, versioning, deployment, collaboration, and scalability. Your image may be rapidly and readily distributed to others, making it simple for others to utilize and operate your application. Versioning helps you to maintain track of several versions of your image so that you may revert to an earlier version if necessary. Easy deployment allows you to deploy your application to several environments with little modifications. Sharing images via a registry facilitates collaboration with other developers on a project. And scalability is simple to accomplish by using the same image to create as many containers as you need, making it simple to grow <span class="No-Break">your application.</span></p>
			<p>In this chapter, we’ll publish to Docker Hub as an example for our audiofile <span class="No-Break">CLI project.</span></p>
			<h3>Publishing your Docker image</h3>
			<p>To <a id="_idIndexMarker854"/>publish an image to Docker Hub, you’ll first need to create an account on the website. Once you have an account, you can sign in and create a new repository to store your image. After that, you can use the Docker command-line tool to log in to your Docker Hub account, tag your image with the repository name, and push the image to the repository. Here is an example of the commands you would use to <span class="No-Break">do this:</span></p>
			<pre class="console">
docker login --username=your_username
docker tag your_image your_username/your_repository:your_tag
docker push your_username/your_repository:your_tag</pre>
			<ol>
				<li>Let’s try this with our audiofile API and CLI images. First, I will log in with my username <span class="No-Break">and password:</span><pre class="source-code">
<strong class="bold">% docker login --username=marianmontagnino</strong>

<strong class="bold">Password:</strong>

<strong class="bold">Login Succeeded</strong>

<strong class="bold">Logging in with your password grants your terminal complete access to your account.</strong>

<strong class="bold">For better security, log in with a limited-privilege personal access token. Learn more at https://docs.docker.com/go/access-tokens/</strong></pre></li>
				<li>Next, I tag my <span class="No-Break">CLI image:</span><pre class="source-code">
<strong class="bold"> % docker tag audiofile:dist  marianmontagnino/audiofile:latest</strong></pre></li>
				<li>Finally, I publish the image to <span class="No-Break">Docker Hub:</span><pre class="source-code">
<strong class="bold">% docker push marianmontagnino/audiofile:latest</strong>

<strong class="bold">The push refers to repository [docker.io/marianmontagnino/audiofile]</strong>

<strong class="bold">c0f557e70e4f: Pushed</strong>

<strong class="bold">98f8be277d74: Pushed</strong>

<strong class="bold">6c199763ccbe: Pushed</strong>

<strong class="bold">8f2f7ffa843f: Pushed</strong>

<strong class="bold">10bb928a2e24: Pushed</strong>

<strong class="bold">f1ce3f3654c3: Mounted from library/golang</strong>

<strong class="bold">3685241d2bbb: Mounted from library/golang</strong>

<strong class="bold">dddbac67c6fa: Mounted from library/golang</strong>

<strong class="bold">85f9ebffaf4d: Mounted from library/golang</strong>

<strong class="bold">72235aad06ad: Mounted from library/golang</strong>

<strong class="bold">5d37ad02a8e2: Mounted from library/golang</strong>

<strong class="bold">ea8ab45f064e: Mounted from library/golang</strong>

<strong class="bold">latest: digest: sha256:b7b3f58da01d360fc1a3f2e2bd617a44d3f7be d6b6625464c9d787b8a71ead2e size: 2851</strong></pre></li>
			</ol>
			<p>Let’s confirm<a id="_idIndexMarker855"/> in Docker Hub to make sure that the <span class="No-Break">container exists:</span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/Figure_13.3_B18883.jpg" alt="Figure 13.3 – Screenshot of the Docker Hub website showing the audiofile image tagged with latest"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Screenshot of the Docker Hub website showing the audiofile image tagged with latest</p>
			<p>It’s a great<a id="_idIndexMarker856"/> idea to include instructions for running a container using the image within a README file of the repository where the image is stored. This makes it easy for people who want to use the image to learn how to pull the image and run the container properly. As an example, here are sample instructions for our previously uploaded audiofile <span class="No-Break">CLI image:</span></p>
			<p>To run the audiofile CLI container, ensure that the audiofile API container is running first. Next, run the <span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
% docker run --rm --network host -ti marianmontagnino/audiofile:latest help</pre>
			<p>You’ll see that the help text is output. Let’s update the instructions on the Docker <span class="No-Break">Hub repository.</span></p>
			<h3>Updating the README</h3>
			<p>From the <a id="_idIndexMarker857"/>Docker Hub repository, where our image is stored (in this example, the audiofile repository), we can scroll down to the bottom of the page to see a <span class="No-Break"><strong class="bold">README</strong></span><span class="No-Break"> section:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/Figure_13.4_B18883.jpg" alt="Figure 13.4 – Screenshot of the README section in the repository on Docker Hub"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Screenshot of the README section in the repository on Docker Hub</p>
			<p>Click <strong class="bold">here</strong> to edit the repository description. Add the instructions we discussed previously, then click the <span class="No-Break"><strong class="bold">Update</strong></span><span class="No-Break"> button:</span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/Figure_13.5_B18883.jpg" alt="Figure 13.5 – Screenshot of the updated README section"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Screenshot of the updated README section</p>
			<p>Follow these instructions to similarly publish the audiofile API image to your Docker Hub repository. Now that the images exist in a public repository on Docker Hub, they are available to share and distribute to <span class="No-Break">other users.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor354"/>Depending on Docker</h2>
			<p>The<a id="_idIndexMarker858"/> fact that users must have Docker installed on their computers is one of the key disadvantages of utilizing Docker to deploy a CLI. However, if your program has complicated dependencies or is designed to operate on various platforms, this Docker dependency may be easier to handle. Using Docker may assist in avoiding difficulties with many libraries and unexpected interactions with various <span class="No-Break">system setups.</span></p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor355"/>Summary</h1>
			<p>We’ve gone into the realm of containerization and examined the numerous advantages of utilizing Docker containers for your applications in this chapter. The fundamentals of creating and running a simple Docker image and container are explained, as well as some more sophisticated instances using our audiofile application, which requires the construction of multiple containers that can be composed and <span class="No-Break">run together.</span></p>
			<p>Clearly, utilizing Docker for integration testing boosts your trust in the whole system, and we discussed how to run integration tests using <span class="No-Break">Docker Compose.</span></p>
			<p>At the same time, we’ve acknowledged some of Docker’s drawbacks, such as the increased complexity of maintaining containerized applications, the additional burden of operating several containers on a single host, and the external dependency of <span class="No-Break">Docker itself.</span></p>
			<p>Overall, this chapter has given you a strong knowledge of when to utilize Docker containers for command-line applications—for testing and distribution. Now, you can ensure that the application runs consistently across any host machine. It is up to you, though, to decide if the upsides outweigh the downsides of having an external dependency and some level <span class="No-Break">of complexity.</span></p>
			<p>In the next chapter, <a href="B18883_14.xhtml#_idTextAnchor359"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Publishing your Go Binary as a Homebrew Formula with GoReleaser</em>, we’ll take distribution to a next level. We will get your application available on the official Homebrew repository to further increase the distribution of <span class="No-Break">your application.</span></p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor356"/>Questions</h1>
			<ol>
				<li>Which command is used to create and run a container from <span class="No-Break">an image?</span></li>
				<li>Which <strong class="source-inline">docker run</strong> flag is used to attach a host machine path to a <span class="No-Break">container path?</span></li>
				<li>Which Docker command is used to see all <span class="No-Break">created containers?</span></li>
			</ol>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor357"/>Further reading</h1>
			<ul>
				<li><em class="italic">Docker: Up and Running: Shipping Reliable Containers in Production</em> by <em class="italic">Sean P. Kane</em> and <span class="No-Break"><em class="italic">Karl Matthias</em></span></li>
				<li><em class="italic">Continuous Delivery with Docker and Jenkins: Delivering software at scale</em> by <span class="No-Break"><em class="italic">Rafal Leszko</em></span></li>
				<li><em class="italic">Docker in Action</em> by <em class="italic">Jeff Nickoloff </em>and<em class="italic"> </em><span class="No-Break"><em class="italic">Stephen Kuenzli</em></span></li>
			</ul>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor358"/>Answers</h1>
			<ol>
				<li value="1">The <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command.</span></li>
				<li>The <strong class="source-inline">-v</strong>, or <strong class="source-inline">--volume</strong>, flag is used to attach a host machine path to a container path <span class="No-Break">during execution.</span></li>
				<li><strong class="source-inline">docker ps</strong> or <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">container ls</strong></span><span class="No-Break">.</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer108" class="IMG---Figure">
			</div>
		</div>
	</body></html>