- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Using Containers for Distribution
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器进行分发
- en: In this chapter, we’ll explore the world of containerization and examine the
    many reasons why you should use Docker containers for testing and distributing
    your applications. The term *containerization* refers to a style of software packaging
    that makes it simple to deploy and run in any setting. First, we’ll go over the
    basics of Docker, covered by a simple application that can be built into an image
    and run as a container. Then, we return to our audiofile application, for a more
    advanced example, to learn how to create multiple Docker containers that can be
    composed and run together. These examples give you not only an understanding of
    the basic flags used for running containers but also some advanced flags that
    show you how to run containers with mapped network stacks, volumes, and ports.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨容器化的世界，并检查为什么你应该使用Docker容器来测试和分发你的应用程序的许多原因。术语*容器化*指的是一种软件打包风格，它使得在任何环境中部署和运行变得简单。首先，我们将通过一个可以构建成镜像并作为容器运行的应用程序来介绍Docker的基础知识。然后，我们将回到我们的audiofile应用程序，作为一个更高级的例子，学习如何创建多个可以组合和一起运行的Docker容器。这些例子不仅让你理解了用于运行容器的基本标志，还展示了如何使用映射的网络堆栈、卷和端口来运行容器。
- en: We also explain how to use Docker containers for integration testing, which
    increases your confidence, because, let’s face it, mocking API responses can cover
    only so much. A good mix of unit and integration tests gives you not just the
    coverage but also confidence that the overall system works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还解释了如何使用Docker容器进行集成测试，这增加了你的信心，因为坦白说，模拟API响应只能覆盖这么多。单元测试和集成测试的良好组合不仅提供了覆盖率，还提供了整体系统工作的信心。
- en: Finally, we will discuss some of the disadvantages of adopting Docker. Consider
    the increased complexity of administering containerized applications, as well
    as the additional overhead of operating several containers on a single host. Docker
    as an external dependency may be a disadvantage in itself. This chapter will help
    you determine when to use, and not to use, containers for your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论采用Docker的一些不利因素。考虑管理容器化应用程序的复杂性增加，以及在单个主机上运行多个容器的额外开销。Docker作为一个外部依赖项本身可能就是一个不利因素。本章将帮助你确定何时以及何时不使用容器来处理你的应用程序。
- en: 'By the end of this chapter, you will have a strong grasp of how to utilize
    Docker containers and how they might assist your development, testing, and deployment
    workflow. You will be able to containerize your application, test it with Docker,
    and release it with Docker Hub. Specifically, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深刻理解如何利用Docker容器以及它们如何可能帮助你开发、测试和部署工作流程。你将能够将你的应用程序容器化，使用Docker进行测试，并通过Docker
    Hub发布。具体来说，我们将涵盖以下主题：
- en: Why use containers?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用容器？
- en: Testing with containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器进行测试
- en: Distributing with containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器进行分发
- en: Technical requirement
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要做以下事情：
- en: Download and install Docker Desktop at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)下载并安装Docker
    Desktop
- en: Install the Docker Compose plugin
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Docker Compose插件
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter13](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter13)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到代码示例：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter13](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter13)
- en: Why use containers?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用容器？
- en: First, let’s talk about what a container is. A **container** is a standardized
    software unit that allows the transport of a program from one computing environment
    quickly and reliably to another by bundling the application’s code and all its
    dependencies into a single encapsulation. Simply put, containers let you package
    all your dependencies into a single container so that it can run on any machine.
    Containers are isolated from one another and bundle their own system libraries
    and settings, so they don’t conflict with other containers or the host system.
    This makes them a lightweight and portable alternative to **virtual machines**
    (**VMs**). Popular containerization tools include **Docker** and **Kubernetes**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈什么是容器。**容器**是一个标准化的软件单元，它通过将应用程序的代码及其所有依赖项打包成一个单一的封装，允许程序从一个计算环境快速且可靠地传输到另一个环境。简单来说，容器允许您将所有依赖项打包到一个容器中，以便它可以在任何机器上运行。容器彼此隔离，并捆绑自己的系统库和设置，因此它们不会与其他容器或宿主系统冲突。这使得它们成为**虚拟机**（**VMs**）的轻量级和便携式替代品。流行的容器化工具包括**Docker**和**Kubernetes**。
- en: Benefiting from containers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从容器中获益
- en: 'Let’s break down some of the benefits of using containers in your Go project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下在Go项目中使用容器的部分好处：
- en: '**Portability**: Containers make it possible to support consistency of behavior
    across various environments, lowering the possibility of errors and incompatibilities.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性**：容器使得在不同环境中保持行为一致性成为可能，降低了错误和不兼容的可能性。'
- en: '**Isolation**: They offer a degree of isolation from the host system and other
    containers, which increases their level of security and reduces their propensity
    for conflicts.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：它们提供了一定程度的与宿主系统和其他容器的隔离，这提高了它们的安全性并减少了冲突的可能性。'
- en: '**Lightweight**: Compared to VMs, containers are smaller and start up faster,
    which increases their operating efficiency.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**：与虚拟机相比，容器更小，启动速度更快，这提高了它们的运行效率。'
- en: '**Scalability**: They can be easily scaled up or down, enabling effective resource
    use. For example, if you utilize containers for your application, then you can
    create multiple identical containers running your application deployed across
    multiple servers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：它们可以轻松地进行扩展或缩减，从而实现有效的资源利用。例如，如果您为应用程序使用容器，那么您可以在多个服务器上部署运行应用程序的多个相同容器。'
- en: '**Versioning**: Containers can be versioned, making it simple to revert to
    earlier iterations as needed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：容器可以进行版本控制，这使得在需要时简单地回滚到早期迭代变得简单。'
- en: '**Modularity**: Because containers can be created and managed separately, they
    are simple to update and maintain.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：由于容器可以单独创建和管理，因此它们易于更新和维护。'
- en: '**Cost-effective**: By lowering the number of systems you need to run your
    applications, containers can help you save money on infrastructure and maintenance.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经济高效**：通过减少运行应用程序所需的系统数量，容器可以帮助您在基础设施和维护方面节省资金。'
- en: Creating and running command-line applications is made simple and reliable by
    containers. Regardless of the host machine’s configuration, this means that the
    application will always be built and run in the same manner. Application development
    and deployment across different operating systems are made significantly simpler
    by including all necessary dependencies and runtime environments within the container
    image. Finally, containers make it simple to duplicate development environments,
    enabling multiple developers or teams to work together in the same area while
    guaranteeing that the application is developed and executed uniformly across various
    environments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使得创建和运行命令行应用程序变得简单且可靠。无论宿主机的配置如何，这意味着应用程序始终以相同的方式进行构建和运行。通过在容器镜像中包含所有必要的依赖项和运行时环境，容器显著简化了跨不同操作系统的应用程序开发和部署。最后，容器使得复制开发环境变得简单，使得多个开发人员或团队能够在同一领域内协作，同时确保应用程序在各种环境中统一开发和执行。
- en: Additionally, using containers makes it simpler to integrate applications with
    **continuous integration and continuous deployment** (**CI/CD**) pipelines. Since
    all the necessary dependencies exist within the container’s image, the pipeline
    can more reliably and easily build and run the application, eliminating the need
    to configure the pipeline’s host machine’s development environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用容器使得将应用程序与**持续集成和持续部署**（**CI/CD**）管道集成变得更加简单。由于所有必要的依赖项都存在于容器镜像中，因此管道可以更可靠、更轻松地构建和运行应用程序，从而消除了配置管道宿主机开发环境的需要。
- en: Finally, the consistency of an isolated environment with containers is another
    benefit that makes it easier to distribute your command-line application while
    guaranteeing that it will operate exactly as expected. Users no longer need to
    configure their environment for the application, making containers, while also
    lightweight, a great way to distribute across various environments and platforms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用容器实现的隔离环境的稳定性是另一个好处，这使得在保证应用程序按预期运行的同时，更容易分发您的命令行应用程序。用户不再需要为应用程序配置环境，这使得容器，虽然轻量级，成为在各种环境和平台间分发的好方法。
- en: As you can clearly see, there are a variety of situations where containers can
    prove useful, including command-line application development and testing! Now,
    let’s discuss when you may not want to use containers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所清晰看到的，有许多情况下容器可以证明是有用的，包括命令行应用程序开发和测试！现在，让我们讨论一下您可能不想使用容器的情况。
- en: Deciding not to use containers
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用容器的决定
- en: 'While containers are often helpful, there are some circumstances in which they
    might not be the best option:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器通常很有帮助，但在某些情况下，它们可能不是最佳选择：
- en: '**High-performance computing**: High-performance computing and other tasks
    that need direct access to the host system’s resources might not be good candidates
    for containers because of the additional overhead they cause.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能计算**：由于它们造成的额外开销，高性能计算和其他需要直接访问宿主机系统资源的任务可能不适合容器。'
- en: '**Requiring high levels of security**: Containers share the host’s kernel and
    might not offer as much isolation as a VM. VMs may be a better option if your
    workload demands a high level of security.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要高安全级别**：容器共享宿主机的内核，可能不会提供与虚拟机（VM）一样多的隔离。如果您的负载需要高安全级别，VM可能是一个更好的选择。'
- en: '**Neglecting container-native features**: You may not see the benefit of using
    containers if you do not plan on using any of the native features included for
    scaling, rolling updates, service discovery, and load balancing.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽视容器原生特性**：如果您不打算使用任何用于扩展、滚动更新、服务发现和负载均衡的内置特性，您可能看不到使用容器的优势。'
- en: '**Inflexible applications**: If an application requires a very specific operating
    environment in order to function properly, it might not even be possible to containerize
    it, as there are limited operating systems and platforms that are supported.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不灵活的应用程序**：如果一个应用程序需要非常特定的操作系统环境才能正常运行，那么它可能甚至无法容器化，因为支持的操作系统和平台有限。'
- en: '**Team inertia**: If you or your team are unwilling to learn about containers
    and container orchestration, then it will be difficult to incorporate a new tool.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队惯性**：如果您或您的团队不愿意学习容器和容器编排，那么将难以引入新的工具。'
- en: Nevertheless, it’s important to note that these situations are not always the
    case and that there are some solutions available, including the use of VMs, particular
    security features of container orchestration platforms, specialized container
    runtimes such as **gVisor** or **Firecracker**, and others.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，这些情况并不总是如此，并且有一些解决方案可用，包括使用虚拟机（VM）、容器编排平台特定的安全特性、专门的容器运行时如**gVisor**或**Firecracker**，以及其他。
- en: In the following examples and within the next sections, we will be using Docker
    to show how easy it can be to start using Docker and use it to create a consistent
    environment for testing and distribution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例和接下来的章节中，我们将使用Docker来展示开始使用Docker以及如何用它来创建一个用于测试和分发的一致性环境是多么容易。
- en: 'In the `Chapter-13` GitHub repository, we go over a very simple example for
    building an image and running a container. The `main.go` file is simple:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter-13` GitHub仓库中，我们介绍了一个构建镜像和运行容器的非常简单的示例。`main.go`文件很简单：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Passing in the `hello` flag to the built application will print out `"``Hello,
    World!"`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向构建的应用程序传递`hello`标志将会打印出`"Hello, World!"`。
- en: Building a simple Docker image
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建简单的Docker镜像
- en: To start, software can be packaged as an **image**, a small, self-contained
    executable that contains the program’s source code, libraries, configuration files,
    runtime, and environment variables. Images are the building blocks of containers
    and are used to create and run them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，软件可以被打包成一个**镜像**，这是一个小型、自包含的可执行文件，包含程序的源代码、库、配置文件、运行时和环境变量。镜像是容器的基本构建块，用于创建和运行它们。
- en: Let’s build a Docker image for this very simple application. To do so, we’ll
    need to create a `Dockerfile` that will automatically be recognized when you run
    the command-line Docker commands, or create a file with the `.dockerfile` extension,
    which will require the `–f` or `--file` flag for passing in the filename.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个非常简单的应用程序构建一个Docker镜像。为此，我们需要创建一个`Dockerfile`，当您运行命令行Docker命令时，它将自动被识别，或者创建一个具有`.dockerfile`扩展名的文件，这将需要`–f`或`--file`标志来传递文件名。
- en: 'A Dockerfile contains instructions for building a Docker image, as depicted
    in the following diagram. Each instruction creates a new layer within the image.
    The layers are combined to create the final image. There are many different kinds
    of instructions you can put in the Dockerfile. For example, you can tell Docker
    to copy files into the base image, set environment variables, run commands, and
    specify the executables to run when a container is initialized:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile包含构建Docker镜像的指令，如下所示图所示。每个指令在镜像中创建一个新的层。这些层被组合起来创建最终的镜像。您可以在Dockerfile中放置许多不同类型的指令。例如，您可以告诉Docker将文件复制到基镜像中，设置环境变量，运行命令，并指定在容器初始化时要运行的可执行文件：
- en: '![Figure 13.1 – Visual of a Dockerfile transformed into an image with layers
    by the build command](img/Figure_13.1_B18883.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – Dockerfile通过构建命令转换为具有层的图像的视觉表示](img/Figure_13.1_B18883.jpg)'
- en: Figure 13.1 – Visual of a Dockerfile transformed into an image with layers by
    the build command
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – Dockerfile通过构建命令转换为具有层的图像的视觉表示
- en: 'For our base image, let’s visit Docker Hub’s website at [https://hub.docker.com](https://hub.docker.com)
    and search for the official Golang Docker base image for Go `v1.19`. We see that
    we can use the `golang` image with tag `1.19`. The `FROM` instruction is the first
    line of the Dockerfile and it sets the base image to use:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的基础镜像，让我们访问Docker Hub网站[https://hub.docker.com](https://hub.docker.com)，并搜索Go
    `v1.19`的官方Golang Docker基础镜像。我们看到我们可以使用带有标签`1.19`的`golang`镜像。`FROM`指令是Dockerfile的第一行，它设置要使用的基镜像：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, copy all the files:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，复制所有文件：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Build the `hello` `world` application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`hello` `world`应用程序：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, run the application while passing the `hello` flag:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行应用程序时传递`hello`标志：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Altogether, the Dockerfile contains the preceding instructions with some descriptive
    comments indicated by `#` as the first character in line.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Dockerfile包含了前面的指令和一些用`#`作为行首字符的描述性注释。
- en: 'To build a Docker image from a Dockerfile, we call the `docker build` command.
    The command takes the following syntax:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Dockerfile构建Docker镜像，我们调用`docker build`命令。该命令采用以下语法：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When run, the command does the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，该命令执行以下操作：
- en: Reads the instructions specified within the Dockerfile and performs them in
    order
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取Dockerfile中指定的指令并按顺序执行
- en: Each instruction creates a new layer in the image, and the final image combines
    them all
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个指令在镜像中创建一个新的层，最终的镜像将它们全部组合起来
- en: Tags the new image with the specified or generated name, and—optionally—a tag
    in the `name:tag` format
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指定的或生成的名称标记新镜像，并且可选地使用`name:tag`格式标记
- en: The `options` parameter can be used to pass in different options to the command,
    which can include build-time variables, targets, and more. The `path | url | -`
    argument specifies the location of the Dockerfile.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`参数可以用来向命令传递不同的选项，这可以包括构建时变量、目标等。`path | url | -`参数指定Dockerfile的位置。'
- en: 'Let’s try building this image from the Dockerfile we created for our hello
    world application. Within the root of the repository, run the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从为我们的hello world应用程序创建的Dockerfile构建这个镜像。在存储库的根目录下运行以下命令：
- en: '`docker build --``tag hello-world:latest`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build --``tag hello-world:latest`'
- en: 'After running the command, you should see similar output to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，你应该看到类似以下输出：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From about midway through the output, you’ll see that the layers of the image
    are built, concluding with the final image tagged as `hello-world:latest`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出大约一半的位置开始，您会看到镜像的层被构建，最后以标记为`hello-world:latest`的最终镜像结束。
- en: 'You can view the images that exist, by running the following command in your
    terminal:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端运行以下命令来查看现有的镜像：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we’ve successfully built our Docker image for this simple hello world
    application, let’s follow up by running it within a container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功构建了这个简单hello world应用程序的Docker镜像，让我们继续在容器中运行它。
- en: Running a simple Docker container
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一个简单的Docker容器
- en: When you run a Docker container, Docker Engine takes an existing image and creates
    a new running instance of it. This container exists within an isolated environment
    that has its own filesystem, network interfaces, and process space. However, the
    image is a necessary starting point for creating—or running—the container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Docker容器时，Docker Engine会从一个现有的镜像创建一个新的运行实例。这个容器存在于一个具有自己的文件系统、网络接口和进程空间的隔离环境中。然而，镜像是创建或运行容器的一个必要起点。
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When a container is running, it can make changes to the filesystem, such as
    creating or modifying files. However, these changes are not saved in the image
    and will be lost when the container is stopped. If you want to save the changes,
    you can create a new image of the container using the `docker` `commit` command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器运行时，它可以对文件系统进行更改，例如创建或修改文件。然而，这些更改不会保存在镜像中，当容器停止时将会丢失。如果您想保存这些更改，可以使用`docker
    commit`命令为容器创建一个新的镜像。
- en: 'To create and run a Docker container from an image, we call the `docker run`
    command. The command takes the following syntax:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要从镜像创建和运行Docker容器，我们调用`docker run`命令。该命令采用以下语法：
- en: '`docker run [options] image[:tag] [``command] [arg...]`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run [options] image[:tag] [command] [arg...]`'
- en: 'The `docker run` command checks if the image exists locally; if not, then it
    will pull it from Docker Hub. Docker Engine then creates a new container from
    this image, with all layers or instructions applied. We’ll break this down here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令检查镜像是否本地存在；如果不存在，则从Docker Hub拉取。然后Docker Engine从这个镜像创建一个新的容器，应用所有层或指令。我们在这里将其分解：'
- en: '![Figure 13.2 – Visual of an image used to create a container with the run
    command](img/Figure_13.2_B18883.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 使用run命令创建容器的图像可视化](img/Figure_13.2_B18883.jpg)'
- en: Figure 13.2 – Visual of an image used to create a container with the run command
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 使用run命令创建容器的图像可视化
- en: 'As mentioned, when `docker run` is called, the following steps occur:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当调用`docker run`时，以下步骤会发生：
- en: Docker checks if the requested image exists locally; if not, it retrieves it
    from a registry, such as Docker Hub.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker检查请求的镜像是否本地存在；如果不存在，则从注册表，如Docker Hub检索它。
- en: From the image, it creates a new container.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从镜像中，它创建了一个新的容器。
- en: It starts the container and executes the commands specified within the instructions
    of the Dockerfile.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它启动容器并执行Dockerfile指令中指定的命令。
- en: It attaches the terminal to the container’s process in order to display any
    output from the commands.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将终端连接到容器的进程，以便显示命令的任何输出。
- en: The `options` parameter can be used to pass in different options to the command,
    which can include mapping ports, setting environment variables, and more. The
    `image[:tag]` argument specifies the image to use for creating the container.
    Finally, the `command` and `[arg...]` arguments are used to specify any commands
    to run within the container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`参数可以用来向命令传递不同的选项，这可以包括端口映射、设置环境变量等。`image[:tag]`参数指定用于创建容器的镜像。最后，`command`和`[arg...]`参数用于指定在容器内运行的任何命令。'
- en: In each example that we call the `docker run` command, we pass in the `--rm`
    flag, which tells Docker to automatically remove the container when it exits.
    This will save you from accidentally ending up with many gigabytes of stopped
    containers sitting in the background.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`docker run`命令的每个示例中，我们传递`--rm`标志，这告诉Docker在退出时自动删除容器。这将避免您意外地留下许多停止的容器在后台占用大量空间。
- en: 'Try to run an image from the `hello-world:latest` image that we created for
    our hello world application. Within the root of the repository, run the following
    command and see the text output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从我们为hello world应用程序创建的`hello-world:latest`镜像运行一个镜像。在存储库的根目录下运行以下命令，并查看文本输出：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We did it! A simple Dockerfile for a simple hello world application. Within
    the next two sections, we’ll return to the audiofile command-line application
    example and use this new skill of building images and running containers for testing
    and distribution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！一个简单的Dockerfile用于简单的hello world应用程序。在接下来的两个部分中，我们将回到audiofile命令行应用程序示例，并使用构建镜像和运行容器的新技能进行测试和分发。
- en: Testing with containers
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器进行测试
- en: So far, within our command-line application journey, we’ve built tests and mocked
    the service output. The benefit of using containers, besides having a consistent
    and isolated environment for tests to run on any host machine, is that you can
    use them for running integration tests that provide more reliable test coverage
    for your application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的命令行应用程序之旅中，我们已经构建了测试并模拟了服务输出。除了在任意主机机器上运行测试的一致性和隔离环境之外，使用容器的好处是你可以使用它们来运行集成测试，这为你的应用程序提供了更可靠的测试覆盖率。
- en: Creating the integration test file
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建集成测试文件
- en: 'We created a new `integration_test.go` file to handle the configuration and
    execution of integration tests, but we don’t want it to run with all the other
    tests. To specify its uniqueness, let’s tag it with `int`, short for integration.
    At the top of the file, we add the following build tag:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`integration_test.go`文件来处理集成测试的配置和执行，但我们不希望它与所有其他测试一起运行。为了指定其独特性，让我们用`int`标签标记它，代表集成。在文件的顶部，我们添加以下构建标签：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We include the `pro` build tag because we are testing all the available features.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含`pro`构建标签，因为我们正在测试所有可用的功能。
- en: Writing the integration tests
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: 'First, let’s write the `ConfigureTest()` function to prepare for our integration
    tests:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写`ConfigureTest()`函数来为我们的集成测试做准备：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, you can see that we use an actual client, not the mocked
    client that is currently used within unit tests. We use `viper` to set the hostname
    and port for the API we connect as localhost on port `8000`. Finally, we initialize
    the logger files so that we don’t run into any panics while logging.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到我们使用的是实际客户端，而不是当前在单元测试中使用的模拟客户端。我们使用`viper`来设置API的hostname和port，将其连接到本地的`8000`端口。最后，我们初始化日志文件，以避免在日志记录时出现任何恐慌。
- en: 'For the integration test, let’s use a specific workflow:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集成测试，让我们使用一个特定的工作流程：
- en: '**Upload audio**: First, we want to make sure an audio file exists within the
    local storage.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**上传音频**：首先，我们想要确保在本地存储中存在一个音频文件。'
- en: '**Get audio by id**: From the previous step, we can retrieve the audiofile
    ID returned and use this to retrieve the audio metadata from storage.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过ID获取音频**：从上一步，我们可以检索返回的音频文件ID，并使用它从存储中检索音频元数据。'
- en: '**List all audio**: We list all the audio metadata and confirm that the previously
    uploaded audio exists within the list.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列出所有音频**：我们列出所有音频元数据，并确认之前上传的音频存在于列表中。'
- en: '**Search audio by value**: Search for that uploaded audio based on metadata
    we know exists within the description.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过值搜索音频**：根据我们知道的描述中存在的元数据搜索已上传的音频。'
- en: '**Delete audio by id**: Finally, delete the initial audio file we uploaded
    by the ID we retrieved from *step 1*.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过ID删除音频**：最后，通过从*步骤1*中检索到的ID删除我们最初上传的音频文件。'
- en: The order is specific as the latter steps within the workflow depend on the
    first.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序是特定的，因为工作流程中的后续步骤依赖于第一步。
- en: The integration tests are like the unit tests, but paths to real files are passed
    in, and the actual API is called. Within the `integration_tests.go` file exists
    a `TestWorkflow` function that calls the commands in the order listed previously.
    Since the code is similar to the unit tests, let’s just go over the first two
    command calls, and then move straight into using Docker to execute the integration
    tests!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试类似于单元测试，但传递给实际文件的路径，并调用实际的API。在`integration_tests.go`文件中存在一个`TestWorkflow`函数，它按照之前列出的顺序调用命令。由于代码与单元测试相似，让我们只概述前两个命令调用，然后直接进入使用Docker执行集成测试！
- en: 'Before any methods are tested, the integration test is configured by calling
    the `ConfigureTest` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试任何方法之前，通过调用`ConfigureTest`函数来配置集成测试：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we then use `rootCmd` to call the `upload` command with
    the filename set to `../audio/algorithms.mp3`. We execute the command and read
    the response back as a byte slice that is then converted to a string and stored
    in the `id` variable. This `id` variable is then used for the following tests.
    We run the `get` command and pass in the same `id` variable to retrieve the audiofile
    metadata for the previously uploaded audio:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们随后使用`rootCmd`调用`upload`命令，并将文件名设置为`../audio/algorithms.mp3`。我们执行命令，并将响应作为字节切片读取回来，然后将其转换为字符串并存储在`id`变量中。这个`id`变量随后用于后续的测试。我们运行`get`命令，并传入相同的`id`变量来检索之前上传的音频文件的元数据：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We continue testing the `list`, `search`, and `delete` commands similarly and
    ensure that the specific metadata with a matching `id` variable is returned each
    time. When the tests are done, we try to run the integration test. Without the
    API running locally, running the following command fails miserably:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续以类似的方式测试 `list`、`search` 和 `delete` 命令，并确保每次都返回具有匹配 `id` 变量的特定元数据。当测试完成后，我们尝试运行集成测试。如果没有本地运行的
    API，运行以下命令将失败得非常惨烈：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before we try again, let’s build a Dockerfile to run the API within a contained
    environment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次尝试之前，让我们构建一个 Dockerfile 来在容器环境中运行 API。
- en: Writing the Dockerfiles
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Dockerfile
- en: 'In the real world, our API might be hosted on some external website. However,
    we are currently running on `localhost`, and running it within a container will
    allow users to easily run it no matter which machine they use. In this section,
    we will create two Dockerfiles: one for the CLI and another for the API.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们的 API 可能托管在一些外部网站上。然而，我们目前运行在 `localhost`，在容器中运行它将使用户能够轻松地在任何机器上运行它。在本节中，我们将创建两个
    Dockerfile：一个用于 CLI，另一个用于 API。
- en: Writing the API Dockerfile
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 API Dockerfile
- en: 'First, we’ll create an `api.Dockerfile` file to hold all the instructions to
    build the image and run the container for the audiofile API:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `api.Dockerfile` 文件来包含构建镜像和运行容器以运行 audiofile API 的所有指令：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s build this image. The `–f` flag allows you to specify the `api.Dockerfile`
    file to use, and the `–t` flag allows you to name and tag the image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建这个镜像。`–f` 标志允许你指定要使用的 `api.Dockerfile` 文件，而 `–t` 标志允许你命名和标记镜像：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After the command executes, you can run the `docker images` command to confirm
    its creation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行后，你可以运行 `docker images` 命令来确认其创建：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we see that the image has been built successfully, let’s run the container
    and test it out!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到镜像已成功构建，让我们运行容器并测试它！
- en: 'Run the following command to run the container:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来运行容器：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You’ll see the preceding output if the API is started successfully. We have
    the audiofile API running in a container within your host. Remember that any commands
    will check against the flat file storage, pointing to the `audiofile` directory
    created under the `home` directory. Any audio files uploaded, processed, and with
    metadata stored within the container will not be saved unless we commit the changes.
    Since we are just running integration tests, this won’t be necessary.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 启动成功，你会看到前面的输出。我们在主机内的容器中运行了 audiofile API。记住，任何命令都会检查指向在 `home` 目录下创建的
    `audiofile` 目录的平面文件存储。除非我们提交更改，否则上传、处理并存储在容器内的任何音频文件都不会被保存。由于我们只是在运行集成测试，所以这不会是必要的。
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `–p` flag within the `docker run` command allows you to specify the port
    mapping between the host and container. The syntax is `-p host_port:container_port`.
    This maps the host’s port to the container’s port.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令中的 `–p` 标志允许你指定主机和容器之间的端口映射。语法是 `-p host_port:container_port`。这会将主机的端口映射到容器的端口。'
- en: 'Within a separate terminal, let’s run the integration tests again and see them
    pass:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，让我们再次运行集成测试并查看它们通过：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Success! We’ve now run integration tests connecting to the audiofile API within
    a container.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们现在已经运行了连接到容器内 audiofile API 的集成测试。
- en: Writing the CLI Dockerfile
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 CLI Dockerfile
- en: 'Now, for running the CLI integration tests within a container, we’ll create
    a `cli.Dockerfile` file. It will hold all the instructions to build the image
    and run the container for the integration tests:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在容器中运行 CLI 集成测试，我们将创建一个 `cli.Dockerfile` 文件。它将包含构建镜像和运行容器以进行集成测试的所有指令：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding comments clarify each instruction, but let’s break down the Docker
    instructions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的注释解释了每条指令，但让我们分解 Docker 指令：
- en: Specify and pull from the base image as `golang:1.19`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基础镜像指定为 `golang:1.19` 并从中拉取。
- en: Set the working directory to `/audiofile`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作目录设置为 `/audiofile`。
- en: Copy over all the source code to the working directory.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有源代码复制到工作目录中。
- en: Download all the Go dependencies.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载所有 Go 依赖项。
- en: Execute `go test –v ./cmd -tags` `int pro`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `go test –v ./cmd -tags` `int pro`。
- en: 'Let’s build this image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建这个镜像：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, while ensuring the `audiofile:api` container is already running, run
    the `audiofile:cli` container:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在确保 `audiofile:api` 容器已经运行的情况下，运行 `audiofile:cli` 容器：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You’ll see that the integration tests run successfully.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到集成测试运行成功。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `--network host` flag within the `docker run` command is used to connect
    a container to the host’s network stack. It means that the container will have
    access to the host’s network interfaces, IP address, and ports. Be careful with
    security if the container runs any service.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令中的 `--network host` 标志用于将容器连接到主机的网络堆栈。这意味着容器将能够访问主机的网络接口、IP
    地址和端口。如果容器运行任何服务，请小心安全。'
- en: Now, we’ve created two containers for the API and CLI, but rather than having
    to run each separately within two separate terminals, it’d be easier to use `docker-compose.yml`,
    starting and stopping the entire application with a single `stop/start` command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为 API 和 CLI 创建了两个容器，但与其在两个独立的终端中分别单独运行每个容器，不如使用 `docker-compose.yml`
    文件，通过单个 `stop/start` 命令启动和停止整个应用程序。
- en: Writing the Docker Compose file
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 Docker Compose 文件
- en: 'Inside the `docker-compose.yml` Docker Compose file, we define both containers
    that need to be run, while specifying any parameters we’ve previously set via
    flags for the `docker` `run` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker-compose.yml` Docker Compose 文件中，我们定义了需要运行的容器，同时指定了我们之前通过 `docker run`
    命令的标志设置的任何参数：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s explain the preceding file. First, there are two services defined: `cli`
    and `api`. Beneath each service are a set of similar keys:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释前面的文件。首先，定义了两个服务：`cli` 和 `api`。在每个服务下面是一组类似的键：
- en: The `build` key, which is used to specify the context and location of the Dockerfile.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build` 键用于指定 Dockerfile 的上下文和位置。'
- en: The `context` key is used to specify where to look for the Dockerfile. Both
    are set to `.`, which tells the Docker Compose service to look in the current
    directory.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context` 键用于指定查找 Dockerfile 的位置。两者都设置为 `.`，这告诉 Docker Compose 服务在当前目录中查找。'
- en: The `dockerfile` key allows us to specify the name of the Dockerfile—in this
    case, `cli.Dockerfile` for the `cli` service and `api.Dockerfile` for the `api`
    service.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerfile` 键允许我们指定 Dockerfile 的名称——在本例中，为 `cli` 服务指定 `cli.Dockerfile`，为 `api`
    服务指定 `api.Dockerfile`。'
- en: The `image` key allows us to give a name and tag the image.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image` 键允许我们给镜像命名和打标签。'
- en: 'For the `cli` service, we’ve added some further keys:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `cli` 服务，我们添加了一些额外的键：
- en: The `network_mode` key is used to specify the networking mode for a service.
    When it is set to `host`, like it is for the `cli` service, it means to use the
    host machine’s network stack (like the `–network host` flag used when calling
    `docker run` for the CLI).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network_mode` 键用于指定服务的网络模式。当它设置为 `host` 时，就像 `cli` 服务一样，这意味着使用主机机器的网络堆栈（就像调用
    `docker run` 时使用的 `–network host` 标志）。'
- en: The `depends_on` key allows us to specify the order of which services should
    be running first. In this case, the `api` service must be running first
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on` 键允许我们指定服务的运行顺序。在这种情况下，`api` 服务必须首先运行'
- en: 'For the `api` service, there’s an additional key:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `api` 服务，还有一个额外的键：
- en: The `ports` key is used to specify port mappings between the host machine and
    the container. Its syntax is `` `host_port:container_port` `` and is like the
    `–p` or `--publish` flag when calling the `docker` `run` command.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports` 键用于指定主机机器和容器之间的端口映射。其语法是 `host_port:container_port`，类似于调用 `docker run`
    命令时使用的 `–p` 或 `--publish` 标志。'
- en: 'Now that we’ve got the Docker Compose file completed, we just have one simple
    command, `docker-compose up`, to run the integration tests within a containerized
    environment:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 Docker Compose 文件，我们只需一个简单的命令 `docker-compose up` 就可以在容器化环境中运行集成测试：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, no matter which platform you’re running the containers on, the results
    will be consistent while running the tests within a container. Integration testing
    provides more comprehensive testing as it will catch bugs that might exist within
    the **end-to-end** (**E2E**) flow from the command to the API to the filesystem
    and back. We can therefore increase our confidence with tests that can ensure
    our CLI and API are more stable and reliable as a whole. In the next section,
    we’ll discuss how to distribute your CLI application with containers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论你在哪个平台上运行容器，在容器内运行测试的结果都将保持一致。集成测试提供了更全面的测试，因为它将捕获从命令到 API 到文件系统再到命令的端到端流程中可能存在的错误。因此，我们可以通过确保我们的
    CLI 和 API 作为整体更加稳定和可靠来提高我们的信心。在下一节中，我们将讨论如何使用容器分发 CLI 应用程序。
- en: Distributing with containers
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器进行分发
- en: There are various advantages to running a CLI inside a container as opposed
    to directly on the host. Utilizing a container makes the setup and installation
    of the program easier. This can be helpful if the application needs numerous dependencies
    or libraries that are challenging to install. Additionally, regardless of the
    language or tools used to construct the program, adopting a container enables
    a more dependable and uniform method of distribution. Using a container as a distribution
    method can be a flexible solution for the majority of applications that can operate
    in a Linux environment, even though there may be language-specific alternatives.
    Finally, distributing through containers will be useful for developers unfamiliar
    with the Go language but who already have the Docker toolbox installed on their
    machines.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行CLI而不是直接在主机上运行有许多优势。利用容器使得程序的设置和安装更加容易。如果应用程序需要大量难以安装的依赖项或库，这可能很有帮助。此外，无论用于构建程序的编程语言或工具是什么，采用容器可以提供更可靠和统一的方法进行分发。使用容器作为分发方法可以成为大多数可以在Linux环境中运行的应用程序的灵活解决方案，尽管可能存在特定语言的替代方案。最后，对于不熟悉Go语言但已在机器上安装了Docker工具箱的开发者来说，通过容器进行分发将非常有用。
- en: Building a new image to run as an executable
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建作为可执行程序运行的镜像
- en: 'To build an image that can run as an executable, we must create an `ENTRYPOINT`
    instruction on the image to specify the main executable. Let’s create a new Dockerfile,
    `dist.Dockerfile`, which contains the following instructions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个可以作为可执行程序运行的镜像，我们必须在镜像上创建一个`ENTRYPOINT`指令来指定主可执行程序。让我们创建一个新的Dockerfile，名为`dist.Dockerfile`，其中包含以下指令：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since these instructions are mostly similar to the other Dockerfiles explained
    in the previous sections, we won’t go into a detailed explanation. The only instruction
    to note is the `ENTRYPOINT` instruction, which specifies `./audiofile` as the
    main executable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些说明与前面章节中解释的其他Dockerfile大致相同，我们不会进行详细说明。需要注意的是`ENTRYPOINT`指令，它指定`./audiofile`作为主可执行程序。
- en: 'We can build this image with the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令构建此镜像：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After confirming that the image is successfully built, we are now ready to run
    the container and interact with it as an executable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认镜像成功构建后，我们现在可以运行容器并将其作为可执行程序进行交互。
- en: Interacting with your container as an executable
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器作为可执行程序进行交互
- en: 'To interact with your container as an executable, you can configure your container
    to use an interactive TTY (terminal) with the `ENTRYPOINT` command in Docker.
    The `-i` and `–t` options stand for *interactive* and *TTY* respectively, and
    when the two flags work together, you can interact with the `ENTRYPOINT` command
    in a terminal-like environment. Remember to have the API running first. Now, let’s
    show how it’ll look when we run the container for the `audiofile:dist` image:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要将容器作为可执行程序进行交互，您可以通过在Docker中使用`ENTRYPOINT`命令配置容器以使用交互式TTY（终端）。`-i`和`–t`选项分别代表*交互式*和*TTY*，当这两个标志一起使用时，您可以在类似终端的环境中与`ENTRYPOINT`命令进行交互。请记住首先启动API。现在，让我们看看当我们运行`audiofile:dist`镜像的容器时它将如何显示：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just by typing `help` at the end of the `docker run` command passes in `help`
    as input to the main executable, or `ENTRYPOINT`: `./audiofile`. As expected,
    the help text is output.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在`docker run`命令的末尾键入`help`，就会将`help`作为输入传递给主可执行程序或`ENTRYPOINT`：`./audiofile`。正如预期的那样，帮助文本被输出。
- en: The `docker run` command uses a few additional commands; the `–network host`
    flag uses the host’s network stack for the container, and the `–rm` command tells
    Docker to automatically remove the container when it exits.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令使用了一些额外的命令；`–network host`标志使用主机的网络堆栈为容器，而`–rm`命令告诉Docker在容器退出时自动删除它。'
- en: 'You can run any of the commands by just replacing the word `help` with the
    name of the other command. To run `upload`, for example, run this command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`help`一词替换为其他命令的名称来运行任何命令。例如，要运行`upload`，请运行以下命令：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can now interact with your command-line application through a container
    passing in commands and not have to worry if it will respond any differently based
    on the host machine. As previously mentioned, any filesystem changes, or files
    uploaded, as in preceding the file, are not saved when the container exists. There
    is a way to run the API so that local file storage maps to a container path.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过容器与命令行应用程序交互，传递命令，而无需担心它是否会根据主机机器有所不同。如前所述，任何文件系统更改或上传的文件，如前所述的文件，在容器退出时都不会保存。有一种方法可以运行API，使得本地文件存储映射到容器路径。
- en: Mapping host machine to container file paths
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将主机机器映射到容器文件路径
- en: As mentioned, you can map a host machine path to a Docker container file path
    so that files on the host computer may be accessed from inside the container.
    This can be helpful for things such as giving the container access to data volumes
    or application configuration files.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以将主机机器路径映射到Docker容器文件路径，以便从容器内部访问主机计算机上的文件。这有助于诸如给容器访问数据卷或应用程序配置文件等情况。
- en: The `-v` or `—volume` option can be used to translate a host machine path to
    a container path when executing a container. This flag’s syntax is `host path:container
    path`. For instance, the `docker run -v /app/config:/etc/config imageName:tag`
    command would be used to map the host machine’s `/app/config` directory to the
    container’s `/``etc/config` directory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`或`—volume`选项可以在执行容器时将主机机器路径转换为容器路径。此标志的语法是`host path:container path`。例如，`docker
    run -v /app/config:/etc/config imageName:tag`命令将用于将主机机器的`/app/config`目录映射到容器的`/etc/config`目录。'
- en: It’s crucial to remember that both the host path and container path need to
    be present in the container image before the container can be executed. You must
    construct the container path before starting the container if it does not already
    exist in the container image.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点至关重要，即主机路径和容器路径都必须在容器执行之前存在于容器镜像中。如果它不在容器镜像中，你必须在使用容器之前构建容器路径。
- en: 'If you dig into the audiofile API that is running on your local host, you’ll
    see that the flat file storage is mapped to the `/audiofile` folder existing under
    the host’s `home` directory. On my macOS instance, if I wanted to run the audiofile
    API within a Docker container but be able to read from and access or upload data
    to the flat file storage, then I would need to map the `audiofile` directory under
    my `HOME` directory to an appropriate location. This `docker run` command would
    do it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入研究运行在本地主机上的audiofile API，你会看到平面文件存储被映射到主机`home`目录下的`/audiofile`文件夹。在我的macOS实例中，如果我想在Docker容器中运行audiofile
    API，但又能从容器内部读取、访问或上传数据到平面文件存储，那么我需要将`HOME`目录下的`audiofile`目录映射到适当的位置。这个`docker
    run`命令就可以做到：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the preceding command first and then run the CLI container, or modify the
    `docker-compose.yml` file’s API service to include the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行前面的命令，然后运行CLI容器，或者修改`docker-compose.yml`文件的API服务以包含以下内容：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Either way, when you run the container for integration tests or as an executable,
    you’ll be interacting with your local storage mapped to the `/root/audiofile`
    directory within the container. If you’ve been playing around with the audiofile
    CLI and uploading directory, then when you start the container up and run the
    `list` command, you’ll see preexisting metadata instead of an empty list returned.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，当你运行用于集成测试或作为可执行文件的容器时，你将与容器内映射到`/root/audiofile`目录的本地存储进行交互。如果你一直在尝试使用audiofile
    CLI上传目录，那么当你启动容器并运行`list`命令时，你会看到现有的元数据而不是返回一个空列表。
- en: Mapping a path from your host to a container is an option that you can share
    with your users when instructing them how to use the audiofile application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将主机路径映射到容器是你在指导用户如何使用audiofile应用程序时可以与他们分享的选项。
- en: Reducing image size by using multi-stage builds
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过多阶段构建减少图像大小
- en: By running the `docker images` command, you’ll see that some of the images built
    are quite large. To reduce the size of these images, you may need to rewrite your
    Dockerfile to use multi-stage builds. A **multi-stage build** is a process of
    dividing up the build into multiple stages, in which it is possible to remove
    unnecessary dependencies, artifacts, and configurations from the final image.
    This is especially useful when building images for large applications where you
    can save on deployment time as well as infrastructure costs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`docker images`命令，您会看到构建的一些镜像相当大。为了减小这些镜像的大小，您可能需要重写您的Dockerfile以使用多阶段构建。**多阶段构建**是一个将构建过程分割成多个阶段的过程，在这个过程中可以从最终镜像中删除不必要的依赖项、工件和配置。这对于构建大型应用程序的镜像特别有用，因为您可以在部署时间和基础设施成本上节省。
- en: A way that single-stage and multi-stage builds differ is that multi-stage builds
    allow you to use multiple `FROM` statements, each defining a new stage of the
    build process. You can selectively copy artifacts, or builds, from one stage or
    another, allowing you to take what you need and discard the rest, essentially
    allowing you to remove anything unnecessary and clean up space.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 单阶段和多阶段构建之间的一个区别是多阶段构建允许您使用多个`FROM`语句，每个语句定义构建过程的新阶段。您可以选择性地复制来自一个阶段或另一个阶段的工件或构建，允许您取所需并丢弃其余部分，本质上允许您删除任何不必要的部分并清理空间。
- en: 'Let’s consider the `dist.Dockerfile` file and rewrite it. In our multi-stage
    build process, let’s define our stages:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`dist.Dockerfile`文件并重写它。在我们的多阶段构建过程中，让我们定义我们的阶段：
- en: '**Stage 1**: Build our application'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段 1**：构建我们的应用程序'
- en: '**Stage 2**: Copy the executable, expose the port, and create an entry point'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段 2**：复制可执行文件，暴露端口，并创建入口点'
- en: 'First, we create a new file, `dist-multistage.Dockerfile`, with the following
    instructions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的文件，`dist-multistage.Dockerfile`，包含以下指令：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In *Stage 1*, we copy all the code files, download all dependencies, then build
    the application—basically, all as in the original instructions within `dist.Dockerfile`,
    but without the `EXPOSE` and `ENTRYPOINT` instructions. One thing to note is that
    we’ve named the stage `build`, with the following line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在*阶段 1*中，我们复制所有代码文件，下载所有依赖项，然后构建应用程序——基本上与`dist.Dockerfile`中的原始指令相同，但没有`EXPOSE`和`ENTRYPOINT`指令。需要注意的是，我们已将阶段命名为`build`，如下行所示：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In *Stage 2*, we copy over just the compiled binary from the `build` stage
    and nothing else. To do this, we run the following instruction:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在*阶段 2*中，我们仅从`build`阶段复制编译的二进制文件，不复制其他任何内容。为此，我们运行以下指令：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The command allows us to copy a file or directory from a previous stage, `build`,
    to the current stage. The `--from=build` option specifies the stage name to copy
    the file from. `/audiofile/audiofile` is the path of the file in the `build` stage,
    and `.` at the end of the command specifies the destination directory, the root
    directory, of the current stage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令允许我们从上一个阶段，即`build`阶段，将文件或目录复制到当前阶段。`--from=build`选项指定了要复制文件的阶段名称。`/audiofile/audiofile`是`build`阶段中文件的路径，命令末尾的`.`指定了目标目录，即当前阶段的根目录。
- en: 'Let’s try building it and comparing the new size against the original size:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建它，并将新大小与原始大小进行比较：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That’s a big difference! Using multi-stage builds will help you to save on deployment
    time and infrastructure costs, so it’s definitely worth the time writing your
    Dockerfiles using this process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个很大的差异！使用多阶段构建可以帮助您节省部署时间和基础设施成本，所以花时间使用此过程编写Dockerfile绝对是值得的。
- en: Distributing your Docker image
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发您的Docker镜像
- en: There are many methods for making your Docker images accessible to others. **Docker
    Hub**, a public registry where you can post your images and make them readily
    available to others, is a popular alternative. Another alternative is to use **GitHub
    Packages** to store and distribute your Docker images alongside other sorts of
    packages. There are other cloud-based registries such as **Amazon Elastic Container
    Registry** (**ECR**), **Google Container Registry** (**GCR**), and **Azure Container
    Registry** (**ACR**) that provide extra services such as image scanning (for OS
    vulnerabilities, for example) and signing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以使您的Docker镜像对他人可用。**Docker Hub**，一个公共注册表，您可以在此处发布您的镜像并使其对他人易于访问，是一个流行的替代方案。另一种替代方案是使用**GitHub
    Packages**来存储和分发您的Docker镜像以及其他类型的包。还有其他基于云的注册表，如**Amazon Elastic Container Registry**（**ECR**）、**Google
    Container Registry**（**GCR**）和**Azure Container Registry**（**ACR**），它们提供额外的服务，例如图像扫描（例如，用于操作系统漏洞）和签名。
- en: It’s a good idea to give instructions on how to utilize your image and run a
    container in the README file of the repository where the image is located. People
    who are interested in utilizing your image will be able to readily access instructions
    on how to retrieve the image, run a container using the image, and any other pertinent
    facts.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储镜像的仓库的 README 文件中提供如何使用你的镜像和运行容器的说明是一个好主意。对使用你的镜像感兴趣的人将能够轻松地获取有关如何检索镜像、使用镜像运行容器以及其他相关信息的说明。
- en: There are several advantages to publishing a Docker image, including simple
    distribution, versioning, deployment, collaboration, and scalability. Your image
    may be rapidly and readily distributed to others, making it simple for others
    to utilize and operate your application. Versioning helps you to maintain track
    of several versions of your image so that you may revert to an earlier version
    if necessary. Easy deployment allows you to deploy your application to several
    environments with little modifications. Sharing images via a registry facilitates
    collaboration with other developers on a project. And scalability is simple to
    accomplish by using the same image to create as many containers as you need, making
    it simple to grow your application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 发布 Docker 镜像有多个优点，包括简单分发、版本控制、部署、协作和可扩展性。你的镜像可以迅速且方便地分发给其他人，使得其他人能够轻松地使用和操作你的应用程序。版本控制帮助你跟踪多个版本的镜像，以便在必要时可以回滚到早期版本。易于部署允许你在几乎不需要修改的情况下将应用程序部署到多个环境。通过注册表共享镜像有助于与其他开发者进行项目协作。通过使用相同的镜像创建所需数量的容器，可扩展性变得简单，这使得扩展你的应用程序变得容易。
- en: In this chapter, we’ll publish to Docker Hub as an example for our audiofile
    CLI project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以我们的 audiofile CLI 项目为例，将镜像发布到 Docker Hub。
- en: Publishing your Docker image
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布你的 Docker 镜像
- en: 'To publish an image to Docker Hub, you’ll first need to create an account on
    the website. Once you have an account, you can sign in and create a new repository
    to store your image. After that, you can use the Docker command-line tool to log
    in to your Docker Hub account, tag your image with the repository name, and push
    the image to the repository. Here is an example of the commands you would use
    to do this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要将镜像发布到 Docker Hub，你首先需要在网站上创建一个账户。一旦你有了账户，你可以登录并创建一个新的仓库来存储你的镜像。之后，你可以使用 Docker
    命令行工具登录到你的 Docker Hub 账户，用仓库名称标记你的镜像，并将镜像推送到仓库。以下是你将使用的命令示例：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s try this with our audiofile API and CLI images. First, I will log in
    with my username and password:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用我们的 audiofile API 和 CLI 镜像试一试。首先，我将使用我的用户名和密码登录：
- en: '[PRE35]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, I tag my CLI image:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我将标记我的 CLI 镜像：
- en: '[PRE36]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, I publish the image to Docker Hub:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我将镜像发布到 Docker Hub：
- en: '[PRE37]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s confirm in Docker Hub to make sure that the container exists:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Docker Hub 上确认以确保容器存在：
- en: '![Figure 13.3 – Screenshot of the Docker Hub website showing the audiofile
    image tagged with latest](img/Figure_13.3_B18883.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – Docker Hub 网站截图，显示带有最新标记的 audiofile 镜像](img/Figure_13.3_B18883.jpg)'
- en: Figure 13.3 – Screenshot of the Docker Hub website showing the audiofile image
    tagged with latest
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – Docker Hub 网站截图，显示带有最新标记的 audiofile 镜像
- en: 'It’s a great idea to include instructions for running a container using the
    image within a README file of the repository where the image is stored. This makes
    it easy for people who want to use the image to learn how to pull the image and
    run the container properly. As an example, here are sample instructions for our
    previously uploaded audiofile CLI image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储镜像的仓库的 README 文件中包含运行容器的说明是一个好主意。这使得想要使用该镜像的人能够轻松地学习如何拉取镜像并正确运行容器。以下是我们之前上传的
    audiofile CLI 镜像的示例说明：
- en: 'To run the audiofile CLI container, ensure that the audiofile API container
    is running first. Next, run the `docker` command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 audiofile CLI 容器，请确保 audiofile API 容器首先运行。然后，运行 `docker` 命令：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You’ll see that the help text is output. Let’s update the instructions on the
    Docker Hub repository.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到输出帮助文本。让我们更新 Docker Hub 仓库上的说明。
- en: Updating the README
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 README 文件
- en: 'From the Docker Hub repository, where our image is stored (in this example,
    the audiofile repository), we can scroll down to the bottom of the page to see
    a **README** section:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储我们镜像的 Docker Hub 仓库（在这个例子中，是 audiofile 仓库），我们可以滚动到页面底部查看一个 **README** 部分：
- en: '![Figure 13.4 – Screenshot of the README section in the repository on Docker
    Hub](img/Figure_13.4_B18883.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – Docker Hub 仓库中 README 部分的截图](img/Figure_13.4_B18883.jpg)'
- en: Figure 13.4 – Screenshot of the README section in the repository on Docker Hub
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – Docker Hub仓库中README部分的截图
- en: 'Click **here** to edit the repository description. Add the instructions we
    discussed previously, then click the **Update** button:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**此处**编辑仓库描述。添加我们之前讨论的说明，然后点击**更新**按钮：
- en: '![Figure 13.5 – Screenshot of the updated README section](img/Figure_13.5_B18883.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 更新后的README部分的截图](img/Figure_13.5_B18883.jpg)'
- en: Figure 13.5 – Screenshot of the updated README section
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 更新后的README部分的截图
- en: Follow these instructions to similarly publish the audiofile API image to your
    Docker Hub repository. Now that the images exist in a public repository on Docker
    Hub, they are available to share and distribute to other users.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些说明，类似地将音频文件API镜像发布到你的Docker Hub仓库。现在，这些镜像已存在于Docker Hub的公共仓库中，可供分享和分发给其他用户。
- en: Depending on Docker
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖于Docker
- en: The fact that users must have Docker installed on their computers is one of
    the key disadvantages of utilizing Docker to deploy a CLI. However, if your program
    has complicated dependencies or is designed to operate on various platforms, this
    Docker dependency may be easier to handle. Using Docker may assist in avoiding
    difficulties with many libraries and unexpected interactions with various system
    setups.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须在他们的计算机上安装Docker，这是利用Docker部署CLI的一个主要缺点。然而，如果你的程序有复杂的依赖项或设计用于在多个平台上运行，这个Docker依赖项可能更容易处理。使用Docker可以帮助避免许多库的问题以及与各种系统设置的意外交互。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve gone into the realm of containerization and examined the numerous advantages
    of utilizing Docker containers for your applications in this chapter. The fundamentals
    of creating and running a simple Docker image and container are explained, as
    well as some more sophisticated instances using our audiofile application, which
    requires the construction of multiple containers that can be composed and run
    together.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经进入了容器化的领域，并探讨了利用Docker容器为你的应用程序提供众多优势。解释了创建和运行简单Docker镜像和容器的基础知识，以及使用我们的audiofile应用程序的一些更复杂的实例，该应用程序需要构建多个可以一起组合和运行的容器。
- en: Clearly, utilizing Docker for integration testing boosts your trust in the whole
    system, and we discussed how to run integration tests using Docker Compose.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，利用Docker进行集成测试可以提高你对整个系统的信任度，我们讨论了如何使用Docker Compose运行集成测试。
- en: At the same time, we’ve acknowledged some of Docker’s drawbacks, such as the
    increased complexity of maintaining containerized applications, the additional
    burden of operating several containers on a single host, and the external dependency
    of Docker itself.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们也承认了Docker的一些缺点，例如维护容器化应用程序的复杂性增加，单个主机上运行多个容器的额外负担，以及Docker本身的依赖性。
- en: Overall, this chapter has given you a strong knowledge of when to utilize Docker
    containers for command-line applications—for testing and distribution. Now, you
    can ensure that the application runs consistently across any host machine. It
    is up to you, though, to decide if the upsides outweigh the downsides of having
    an external dependency and some level of complexity.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章已经为你提供了强大的知识，了解何时为命令行应用程序利用Docker容器进行测试和分发。现在，你可以确保应用程序在任何主机机器上都能一致运行。然而，是否决定外部依赖和一定程度的复杂性带来的好处超过弊端，这取决于你。
- en: In the next chapter, [*Chapter 14*](B18883_14.xhtml#_idTextAnchor359), *Publishing
    your Go Binary as a Homebrew Formula with GoReleaser*, we’ll take distribution
    to a next level. We will get your application available on the official Homebrew
    repository to further increase the distribution of your application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第14章*](B18883_14.xhtml#_idTextAnchor359)，*使用GoReleaser将Go二进制文件作为Homebrew公式发布*，我们将把分发提升到新的水平。我们将使你的应用程序在官方Homebrew仓库中可用，以进一步增加你应用程序的分发。
- en: Questions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which command is used to create and run a container from an image?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于从镜像创建并运行一个容器？
- en: Which `docker run` flag is used to attach a host machine path to a container
    path?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个`docker run`标志用于将主机机器路径附加到容器路径？
- en: Which Docker command is used to see all created containers?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Docker命令用于查看所有已创建的容器？
- en: Further reading
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Docker: Up and Running: Shipping Reliable Containers in Production* by *Sean
    P. Kane* and *Karl Matthias*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*肖恩·P·凯恩*和*卡尔·马蒂亚斯*所著的*Docker：运行起来：在生产中可靠地发送容器*
- en: '*Continuous Delivery with Docker and Jenkins: Delivering software at scale*
    by *Rafal Leszko*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*拉法尔·莱斯科*所著的*使用Docker和Jenkins进行持续交付：大规模交付软件*
- en: '*Docker in Action* by *Jeff Nickoloff* and*Stephen Kuenzli*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Docker实战》由*Jeff Nickoloff*和*Stephen Kuenzli*合著
- en: Answers
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `docker` `run` command.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `run`命令。'
- en: The `-v`, or `--volume`, flag is used to attach a host machine path to a container
    path during execution.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-v`或`--volume`标志用于在执行期间将主机机器路径附加到容器路径。'
- en: '`docker ps` or `docker` `container ls`.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker ps`或`docker` `container ls`。'
