<html><head></head><body>
		<div id="_idContainer123">
			<h1 id="_idParaDest-283" class="chapter-number"><a id="_idTextAnchor359"/>14</h1>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor360"/>Publishing Your Go Binary as a Homebrew Formula with GoReleaser</h1>
			<p>In this chapter, we’ll look at GoReleaser and GitHub Actions and how they can be used in tandem to automate the release of a Go binary as a Homebrew formula. First, we’ll look at <strong class="bold">GoReleaser</strong>, a <a id="_idIndexMarker859"/>popular open source tool that streamlines the creation, testing, and distribution of Go binaries. We’ll look at its various configurations and options as well as how it works with <span class="No-Break">GitHub Actions.</span></p>
			<p>Following that, we’ll look at <strong class="bold">GitHub Actions</strong>, a CI/CD platform that lets you automate software development workflows and integrate with other tools such as GoReleaser. We’ll look at how to use it to ensure consistent and reliable builds, tests, <span class="No-Break">and deployments.</span></p>
			<p>After we’ve mastered both tools, we’ll concentrate on triggering releases, creating a Homebrew tap, and integrating with Homebrew for simple installation and testing. <strong class="bold">Homebrew</strong>, a <a id="_idIndexMarker860"/>popular package manager for macOS, can be used for easy installation and management of your CLI application. Releasing your software to Homebrew not only simplifies the installation process for macOS users, but also gives you access to a wider audience. You can reach a sizable community of macOS developers and consumers that prefer using a package manager for program installation, such as Homebrew. Users can quickly find and install your software with just one command, increasing its usability and accessibility. This can help you reach a larger audience than you otherwise would and boost the visibility, usage, and adoption of <span class="No-Break">your program.</span></p>
			<p>By the end of this chapter, you’ll have a firm grasp of how to combine GoReleaser and GitHub Actions to create an automated and efficient release process, and that includes publishing to Homebrew. With this knowledge, you will be able to tailor your own workflow to your specific requirements. The following topics will <span class="No-Break">be covered:</span></p>
			<ul>
				<li><span class="No-Break">GoReleaser workflow</span></li>
				<li><span class="No-Break">Trigger release</span></li>
				<li>Installing with Homebrew <span class="No-Break">and Testing</span></li>
			</ul>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor361"/>Technical requirements</h1>
			<p>For this chapter, you will need to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>You can also find the code examples on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile</span></a></li>
				<li>A <span class="No-Break">GitHub account</span></li>
				<li>Install the GoReleaser tool <span class="No-Break">at </span><a href="https://goreleaser.com/install/"><span class="No-Break">https://goreleaser.com/install/</span></a></li>
			</ul>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor362"/>GoReleaser workflow</h1>
			<p>Releasing <a id="_idIndexMarker861"/>software may be a lengthy and challenging process, particularly for projects with several dependencies and platforms. In addition to saving time, automating the release process lowers the possibility of human error and guarantees reliable and effective releases. GoReleaser is a popular choice for automating the release process for Go developers. However, there are also other choices, such as CircleCI, GitLab CI, and GitHub Actions, each of which has particular advantages and features. In this section, we’ll examine the advantages of automating the release procedure and look in more detail at a few of these choices, specifically GoReleaser and <span class="No-Break">GitHub Actions.</span></p>
			<p>When compared to alternatives, GoReleaser stands out for the <span class="No-Break">following reasons:</span></p>
			<ul>
				<li><strong class="bold">Easy to use</strong>: Setup <a id="_idIndexMarker862"/>is simple and intuitive, making it easy for developers to get started with release automation. Their CLI quickly initializes a repository with a default configuration that can often work out of <span class="No-Break">the box.</span></li>
				<li><strong class="bold">Platform support</strong>: A variety of operating systems, including the major OSs, and cloud services <span class="No-Break">are supported.</span></li>
				<li><strong class="bold">Customization at each step</strong>: Programmers have the ability to customize at every step of the release process including building, testing, and publishing to <span class="No-Break">various platforms.</span></li>
				<li><strong class="bold">Release artifacts</strong>: A wide range of release artifacts may be produced, including Debian packages, Docker images, and <span class="No-Break">binary files.</span></li>
				<li><strong class="bold">Versatile</strong>: Combining with CI/CD pipelines, such as GitHub Actions, enables developers to fully <a id="_idIndexMarker863"/>automate their <span class="No-Break">release procedure.</span></li>
				<li><strong class="bold">Open source</strong>: Programmers may access the source code of the GoReleaser project and alter it to suit their <span class="No-Break">own needs.</span></li>
				<li><strong class="bold">Community support</strong>: GoReleaser offers a sizable and active user base, making it simple for developers to contribute to the project and find answers to <span class="No-Break">their questions.</span></li>
			</ul>
			<p>While there are many benefits to using GoReleaser, there are, however, a few reasons to not use<a id="_idIndexMarker864"/> GoReleaser for your project that you may need <span class="No-Break">to consider:</span></p>
			<ul>
				<li><strong class="bold">Reliance on Github</strong>: This may not be ideal if you prefer to use different tools <span class="No-Break">or workflows.</span></li>
				<li><strong class="bold">Specific platform requirements</strong>: While GoReleaser supports many popular OSs or cloud providers, you may require a platform that is <span class="No-Break">not supported.</span></li>
				<li><strong class="bold">Complex release requirements</strong>: While there is customization allowed in every step, there’s a possibility GoReleaser may not be flexible enough to serve your specific level <span class="No-Break">of complexity.</span></li>
			</ul>
			<p>In conclusion, while there are other options out there, choose a tool that works for your specific use case. We do feel like GoReleaser is a great tool to use for the audiofile CLI use case, so <span class="No-Break">let’s continue.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor363"/>Defining the workflow</h2>
			<p>Having<a id="_idIndexMarker865"/> analyzed the pros and cons of using GoReleaser, let’s dive into its workflow by first sketching the overall process and then delving into each stage in <span class="No-Break">greater detail:</span></p>
			<ol>
				<li>Configure your project to <span class="No-Break">use GoReleaser.</span></li>
				<li>Configure <span class="No-Break">GitHub Actions.</span></li>
				<li>Set up your <span class="No-Break">GitHub repositories.</span></li>
				<li>Set up your GitHub token <span class="No-Break">for Actions.</span></li>
				<li>Tag and push <span class="No-Break">the code.</span></li>
			</ol>
			<p>It might make more sense to view this with a visual, so this is what we are trying <span class="No-Break">to accomplish:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Figure_14.1_B18883.jpg" alt="Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser</p>
			<p>Let’s dive<a id="_idIndexMarker866"/> deeper and gain a more thorough understanding of each step involved in the workflow now that we have a general idea of how it works; we will explore using GoReleaser with GitHub Actions and learn how to automate your <span class="No-Break">own releases.</span></p>
			<h3>Configuring your project to use GoReleaser</h3>
			<p>With the <a id="_idIndexMarker867"/>GoReleaser tool installed, you can now initialize your CLI repository. In this case, we’ll initialize the root of the audiofile CLI project repository by executing the <span class="No-Break">following command:</span></p>
			<pre class="console">
goreleaser init</pre>
			<p>You should notice that a new file has been generated: <strong class="source-inline">goreleaser.yml</strong>. Before even inspecting the file, we can run a local-only release to confirm that there are no issues with the configuration by executing the <span class="No-Break">following command:</span></p>
			<pre class="console">
goreleaser release --snapshot --clean</pre>
			<p>The<a id="_idIndexMarker868"/> output from the command gives you a clear idea of all the steps involved in the release. We will walk through these steps in the next section, <em class="italic">Trigger release</em>. At the very end of the output, you should see a message indicating a successful release, similar <span class="No-Break">to this:</span></p>
			<pre class="console">
  • release succeeded after 10s</pre>
			<p>While the default configuration succeeded, we’ll need to look deeper into the configuration settings and modify and add appropriately to customize our release process. First, let’s look at the default  <strong class="source-inline">.goreleaser.yaml</strong> file together and break <span class="No-Break">it down.</span></p>
			<h4>Global hooks</h4>
			<p>At the very<a id="_idIndexMarker869"/> top of the file, we see some default global hooks. <strong class="bold">Hooks</strong> allow<a id="_idIndexMarker870"/> you to run custom scripts. In GoReleaser, the <strong class="source-inline">before</strong> field allows you to specify which custom scripts to run before the release <span class="No-Break">process begins:</span></p>
			<pre class="source-code">
before:
  hooks:
    - go mod tidy
    - go generate ./...</pre>
			<p>In the preceding example, we configured the automation to run the <strong class="source-inline">go mod tidy</strong> and <strong class="source-inline">go generate ./...</strong>  commands prior to the release process. However, you might run scripts that perform tasks such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Updating the version number in your <span class="No-Break">project’s code</span></li>
				<li>Generating <span class="No-Break">a changelog</span></li>
				<li>Running automated tests to ensure that your code is working <span class="No-Break">as expected</span></li>
				<li>Building your project and creating <span class="No-Break">release artifacts</span></li>
				<li>Pushing changes to your version <span class="No-Break">control system</span></li>
			</ul>
			<p>The scripts<a id="_idIndexMarker871"/> you call from the <strong class="source-inline">before</strong> hooks section in GoReleaser can be written in any language, as long as they can be executed from the command line. For example, you might write scripts in Go, Python, Bash, or any other language that supports <span class="No-Break">shell execution.</span></p>
			<h4>Builds and environment variables</h4>
			<p>Next, we see some <a id="_idIndexMarker872"/>default builds and some environment variables set. The <strong class="source-inline">builds</strong> field allows you to determine the combination of operating systems, defined by the <strong class="source-inline">GOOS</strong> field, architectures defined by the <strong class="source-inline">GOARCH</strong> field, and <a id="_idIndexMarker873"/>architecture mode, defined by the <strong class="source-inline">GOARM</strong> field. It also allows you to add additional fields, such as the <strong class="source-inline">env</strong> field, which allows you to set environment variables for the builds. Additional aspects that can be defined include the binary, flags, hook <span class="No-Break">and more:</span></p>
			<pre class="source-code">
builds:
  - env:
    - CGO_ENABLED=0
  goos:
    - linux
    - windows
    - darwin</pre>
			<p>In the preceding example that exists within the default configuration, we defined the environment variable, <strong class="source-inline">CGO_ENABLED</strong>, to be set to <strong class="source-inline">0</strong>, and then configure the build process to generate binaries for the Linux, Windows, and Darwin <span class="No-Break">operating systems.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">env</strong> field can be set at a global level so that the environment variable is available at all stages of the release process, or it may be specified, such as in the previous case, within the build <span class="No-Break">context alone.</span></p>
			<p>The final configuration ends up having a few more modifications, such as specifying a few additional<a id="_idIndexMarker874"/> architectures, <strong class="source-inline">amd64</strong> and <strong class="source-inline">arm64</strong>, and <a id="_idIndexMarker875"/>removing <strong class="source-inline">go generate ./...</strong> before hook, which is unnecessary. Also, we’ve modified the <strong class="source-inline">builds</strong> field by setting build flags to use the <strong class="source-inline">pro</strong> and <span class="No-Break"><strong class="source-inline">dev</strong></span><span class="No-Break"> flags:</span></p>
			<pre class="source-code">
flags:
  - -tags=pro dev</pre>
			<p>While there are many other options you can set under the <strong class="source-inline">builds</strong> field, we will not cover them in this section. We encourage you to view the full list of customizations available <span class="No-Break">at </span><a href="https://goreleaser.com/customization/builds/"><span class="No-Break">https://goreleaser.com/customization/builds/</span></a><span class="No-Break">.</span></p>
			<h4>Archives</h4>
			<p>Next, we<a id="_idIndexMarker876"/> view some default <strong class="source-inline">archives</strong> settings. In GoReleaser, an <strong class="bold">archive</strong> is a compressed file that contains your application’s binaries, <strong class="source-inline">README</strong>, and <strong class="source-inline">LICENSE</strong> files. The objective is to package your application’s critical components<a id="_idIndexMarker877"/> into a single file, essentially making it easier to distribute and deploy. The default configuration sets the <strong class="source-inline">archives</strong> field to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
archives:
  - format: tar.gz
    name_template: &gt;-
      {{ .ProjectName }}_
      {{- title .Os }}_
      {{- if eq .Arch "amd64" }}x86_64
      {{- else if eq .Arch "386" }}i386
      {{- else }}{{ .Arch }}{{ end }}
      {{- if .Arm }}v{{ .Arm }}{{ end }}
  format_overrides:
  - goos: windows
    format: zip</pre>
			<p>Within the<a id="_idIndexMarker878"/> preceding defaults for the <strong class="source-inline">archives</strong> field, you can see that the default archive format is <strong class="source-inline">tar.gz</strong> for all operating systems except for when <strong class="source-inline">GOOS</strong> is set to Windows. In that case, the archive format is <strong class="source-inline">zip</strong>. The name of the file is defined by a template. To learn more about the GoReleaser naming template, visit <a href="https://goreleaser.com/customization/templates/">https://goreleaser.com/customization/templates/</a> as there are many fields to customize the name of your archive. Let’s at least review the keys used in the <span class="No-Break"><strong class="source-inline">naming_template</strong></span><span class="No-Break"> field:</span></p>
			<ul>
				<li><strong class="source-inline">.ProjectName</strong> – the project name. If not set, GoReleaser will use the name of the directory containing the Go project. In our case, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">audiofile</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">.Os</strong> – <span class="No-Break"><strong class="source-inline">GOOS</strong></span><span class="No-Break"> value.</span></li>
				<li><strong class="source-inline">.Arch</strong> – <span class="No-Break"><strong class="source-inline">GOARCH</strong></span><span class="No-Break"> value.</span></li>
				<li><strong class="source-inline">.Arm</strong> – <span class="No-Break"><strong class="source-inline">GOARM</strong></span><span class="No-Break"> value.</span></li>
			</ul>
			<p>Now that we understand what these template keys refer to, let’s suppose that we generate an archive for our audiofile CLI project, for Linux, with an <strong class="source-inline">amd64</strong> architecture. The resulting name of the archive file would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">audiofile_Linux_x86x64.tar.gz</strong></span><span class="No-Break">.</span></p>
			<h4>Checksum</h4>
			<p>GoReleaser <a id="_idIndexMarker879"/>automatically creates and includes a file called <strong class="source-inline">project 1.0.0 checksums.txt</strong> with the release package. <strong class="bold">Checksums</strong> allow <a id="_idIndexMarker880"/>your users to ensure that the files they’ve downloaded are complete and accurate. Similar to the <strong class="source-inline">archives</strong> field, you can use <strong class="source-inline">naming_template</strong> to generate the name of the <strong class="source-inline">checksum</strong> file. However, within our configuration, the default value for the <strong class="source-inline">checksum</strong> field is <span class="No-Break">simply </span><span class="No-Break"><strong class="source-inline">checksums.txt</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
checksum:
  name_template: 'checksums.txt'</pre>
			<p>Defining a <strong class="source-inline">checksum</strong> file is important since it helps ensure the integrity of the data being distributed. The <strong class="source-inline">checksum</strong> file contains a one-of-a-kind code that can be used to verify that the downloaded files are identical to the original files. If the <strong class="source-inline">checksum</strong> file is not provided, the released files may be modified or corrupted throughout the download <a id="_idIndexMarker881"/>process. This can result in unpredictable behavior in your application and problems for your users. To avoid this, always provide a <strong class="source-inline">checksum</strong> file with your releases so that everyone knows they’re getting the correct version of <span class="No-Break">your product.</span></p>
			<h4>Snapshot</h4>
			<p>The <strong class="source-inline">snapshot</strong> field <a id="_idIndexMarker882"/>in the GoReleaser configuration file specifies whether a release is a “snapshot” or a stable release. A <strong class="bold">snapshot</strong> is a <a id="_idIndexMarker883"/>non-production version of a software project that is made available for testing <span class="No-Break">and feedback.</span></p>
			<p>The generated release artifacts will be marked as snapshots if the <strong class="source-inline">snapshot</strong> field is set to <strong class="source-inline">true</strong>. This means that the version number will be suffixed with <strong class="source-inline">-SNAPSHOT</strong>, and the release will not be published to any remote repository, such as GitHub Releases. If the <strong class="source-inline">snapshot</strong> field is set to <strong class="source-inline">false</strong> or is not supplied, the release is considered stable and is published normally. Like the previous two fields, <strong class="source-inline">archives</strong> and <strong class="source-inline">checksum</strong>, the <strong class="source-inline">snapshot</strong> field also has a <strong class="source-inline">name_template</strong> that can <span class="No-Break">be used:</span></p>
			<pre class="source-code">
snapshot:
  name_template: "{{ incpatch .Version }}-next"</pre>
			<p>If not set, the default version, <strong class="source-inline">0.0.1</strong>, is set. Based on the previous template, the name of the snapshot will be <strong class="source-inline">0.0.1-next</strong>. <strong class="source-inline">incpatch</strong>, according to the GoReleaser documentation, increments the patch of the given reversion, with a side note that it will panic if it’s not a <a id="_idIndexMarker884"/>semantic version. A <strong class="bold">semantic version</strong>, also known as <strong class="bold">SemVer</strong>, is a <a id="_idIndexMarker885"/>version numbering scheme that uses a format of <strong class="source-inline">major.minor.patch</strong> to convey the level of changes in a <span class="No-Break">software release.</span></p>
			<h4>Changelog</h4>
			<p>The <strong class="source-inline">changelog</strong> field<a id="_idIndexMarker886"/> defines the path of your project’s changelog file. A <strong class="bold">changelog </strong>file<a id="_idIndexMarker887"/> contains a list of all the changes, improvements, and bug fixes made to a software project, typically organized <span class="No-Break">by version.</span></p>
			<p>The aim is to record these changes so that users and developers can easily discover what’s new in a specific release. The changelog also aids with debugging and support by documenting the development process. Let’s look at the default configuration for the <span class="No-Break"><strong class="source-inline">changelog</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
changelog:
  sort: asc
  filters:
    exclude:
      - '^docs:'
      - '^test:'</pre>
			<p>In the preceding block of the configuration, we defined the behavior of the changelog generation process. Using the <strong class="source-inline">sort</strong> field, we specify the order in which the entries of the changelog should be displayed, in this case, <strong class="source-inline">asc</strong>, for ascending. The <strong class="source-inline">filters</strong> field specifies, with the <strong class="source-inline">exclude</strong> subfield, a list of regular expressions matched against commits to be excluded. To view all the options available for the <strong class="source-inline">changelog</strong> field, <span class="No-Break">visit </span><span class="No-Break"><strong class="source-inline">https://goreleaser.com/customization/changelog/</strong></span><span class="No-Break">.</span></p>
			<p>So, now that we’ve finished analyzing the default GoReleaser configuration, let’s determine what we’d want to <span class="No-Break">consider adding.</span></p>
			<h4>Release</h4>
			<p>The following<a id="_idIndexMarker888"/> code block in the GoReleaser configuration dictates that if there are any changes present within a Git repository, it automatically generates a pre-release. The pre-released version will have a version number that includes a pre-release suffix, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">1.0.0-beta.1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
release:
  prerelease: auto</pre>
			<p>This automated process provides a convenient way for developers to create early versions <a id="_idIndexMarker889"/>of their software for testing purposes. By utilizing pre-releases, they can quickly and effortlessly gather feedback on the latest changes and make any necessary modifications before releasing a final version to <span class="No-Break">the public.</span></p>
			<h4>Universal binaries</h4>
			<p>Imagine <a id="_idIndexMarker890"/>having just one file that can work on multiple architectures of an operating system, such as an install that works on a macOS machine with either an M1 or Intel chip. That’s what<a id="_idIndexMarker891"/> a <strong class="bold">universal binary</strong> is, also known <a id="_idIndexMarker892"/>as <strong class="bold">fat binaries</strong>. Instead of having separate binaries for different architectures, you’d have just one universal binary that can work on both. This makes it a lot more convenient for developers to spread their software across different platforms, and for users to just download a single file and run it on their system without having to worry about <span class="No-Break">compatibility issues:</span></p>
			<pre class="source-code">
universal_binaries:
  - replace: true</pre>
			<p>We tell GoReleaser to use universal binaries by adding the <strong class="source-inline">universal_binaries</strong> field and setting the <strong class="source-inline">replace</strong> value <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<h4>Brews</h4>
			<p>The <strong class="source-inline">brews</strong> field<a id="_idIndexMarker893"/> allows developers to specify the details for creating and publishing Homebrew as part of their release process. Let’s take a look at the following addition to our configuration for the audiofile <span class="No-Break">CLI project:</span></p>
			<pre class="source-code">
brews:
  -
  name: audiofile
  homepage: https://github.com/marianina8
  tap:
    owner: marianina8
    name: homebrew-audiofile
  commit_author:
    name: marianina8</pre>
			<p>Let’s at least define what these fields are defining for the Homebrew creation and publishing <a id="_idIndexMarker894"/>process. A <strong class="bold">tap repository</strong> is a GitHub repository that contains one or more formula files, which define how to install a particular package on Homebrew. Note that the tap repository, although defined in the configuration, will be created in <em class="italic">Step 3</em>,<em class="italic"> Setting up your </em><span class="No-Break"><em class="italic">GitHub repositories</em></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">name</strong> – Defaults to the project <span class="No-Break">name, audiofile.</span></li>
				<li><strong class="source-inline">homepage</strong> – Your CLI application’s homepage. This defaults to empty, but set it to your GitHub <span class="No-Break">repository name.</span></li>
				<li><strong class="source-inline">tap</strong> – Defines the GitHub/GitLab repository to publish the formula to. The <strong class="source-inline">owner</strong> field is the owner of the repository. The <strong class="source-inline">name</strong> field is the name of <span class="No-Break">the repository.</span></li>
				<li><strong class="source-inline">commit_author</strong> – This is the Git author that shows up when committing to the repository. It defaults to <strong class="source-inline">goreleaserbot</strong>, but in our case, we set it to our <span class="No-Break">GitHub handle.</span></li>
			</ul>
			<p>You can view <a id="_idIndexMarker895"/>all the <a id="_idIndexMarker896"/>available customizations available for the <strong class="source-inline">brew</strong> field <span class="No-Break">at </span><a href="https://goreleaser.com/customization/homebrew/"><span class="No-Break">https://goreleaser.com/customization/homebrew/</span></a><span class="No-Break">.</span></p>
			<p>Onto the <span class="No-Break">next step!</span></p>
			<h3>Configuring GitHub Actions</h3>
			<p>Within <a id="_idIndexMarker897"/>this section, we’ll learn about GitHub Actions <a id="_idIndexMarker898"/>and how they can be integrated with the GoReleaser tool. First, <strong class="bold">Github Actions</strong>, as you may recall, is a CI/CD tool, but get ready for this, it also has an incredible feature that allows you to set off an execution of whatever code you like on your repository when a certain event occurs! You may already know this actually, but for those who now know, new doors of opportunity are opening. Let’s discuss the main components of <span class="No-Break">GitHub Actions:</span></p>
			<ul>
				<li><strong class="bold">Events</strong>: Any <a id="_idIndexMarker899"/>GitHub event, such as pushing code, creating a new branch, opening a PR, a pull request, or commenting on an issue. Events <span class="No-Break">trigger workflows.</span></li>
				<li><strong class="bold">Runners</strong>: A <a id="_idIndexMarker900"/>runner is a process that starts executing a workflow when triggered by an event. There is a one-to-one relationship between a runner and <span class="No-Break">a job.</span></li>
				<li><strong class="bold">Workflows</strong>: Workflows <a id="_idIndexMarker901"/>are composed of a series of jobs that can run sequentially or in parallel. They are defined in the .<strong class="source-inline">/.</strong><span class="No-Break"><strong class="source-inline">github/workflows</strong></span><span class="No-Break"> directory.</span></li>
				<li><strong class="bold">Jobs</strong>: A single<a id="_idIndexMarker902"/> job is a series of tasks. A task could be a script or another <span class="No-Break">GitHub action.</span></li>
				<li><strong class="bold">Actions</strong>: An <a id="_idIndexMarker903"/>action is a task. Some tasks may perform complex tasks such as publishing a Go package to Homebrew, or simple tasks, such as setting an <span class="No-Break">environment variable.</span></li>
			</ul>
			<p>The following<a id="_idIndexMarker904"/> diagram may help to indicate the relationship between the four major components of <span class="No-Break">GitHub Actions:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/Figure_14.2_B18883.jpg" alt="Figure 14.2 – Relationship between events, runners, workflows, jobs, and actions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Relationship between events, runners, workflows, jobs, and actions</p>
			<p>Now that we’ve grasped the concept of GitHub Actions, let’s see how we can take events, such as pushing tags, to trigger a GoReleaser job, which performs the complex task of publishing a Go package to Homebrew for us. First, we need to create the configuration file. From the root of the repository, do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Create a folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">.github</strong></span><span class="No-Break">.</span></li>
				<li>Create a subfolder inside of the <strong class="source-inline">.github</strong> folder, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">workflows</strong></span><span class="No-Break">.</span></li>
				<li>Create a <span class="No-Break"><strong class="source-inline">release.yml</strong></span><span class="No-Break"> file.</span></li>
			</ol>
			<p>The <a id="_idIndexMarker905"/>GoReleaser website provides a default configuration for GitHub Actions on their website at <a href="https://goreleaser.com/ci/actions/">https://goreleaser.com/ci/actions/</a>. You <a id="_idIndexMarker906"/>may copy and paste this from their website to give you a good starting point. We’ll make a few modifications, but before we do, let’s walk through the default configuration together. Let’s begin by discussing the fields that exist within the GitHub Actions <span class="No-Break"><strong class="source-inline">release.yml</strong></span><span class="No-Break"> file.</span></p>
			<h4>On</h4>
			<p>The <strong class="source-inline">on</strong> field<a id="_idIndexMarker907"/> within the Github Actions repository specifies the events that trigger the workflow. It could be a single event or multiple. Let’s go through some of <span class="No-Break">the events:</span></p>
			<ul>
				<li><strong class="source-inline">Push</strong>: The <strong class="source-inline">push</strong> field is used to tell the action to trigger a push. For example, this can be customized to specify pushing to a branch or tag. The syntax for this field is defined <span class="No-Break">as follows:</span></li>
			</ul>
			<p><span class="No-Break"><strong class="source-inline">on.push.&lt;branches|tags|branches-ignore|tags-ignore&gt;.&lt;paths|paths-ignore&gt;</strong></span></p>
			<ul>
				<li>Use the <strong class="source-inline">branches</strong> filter to include specific branch names and the <strong class="source-inline">branches-ignore</strong> filter to exclude certain branch names. Remember, don’t use both <strong class="source-inline">branches</strong> and <strong class="source-inline">branches-ignore</strong> in the same <span class="No-Break">workflow event.</span></li>
				<li>Use the <strong class="source-inline">tags</strong> filter for including specific tag names and <strong class="source-inline">tags-ignore</strong> for excluding certain tag names. Again, be careful, don’t use both <strong class="source-inline">tags</strong> and <strong class="source-inline">tags-ignore</strong> in the same workflow! Apparently, the workflow won’t run if that’s <span class="No-Break">the case.</span></li>
				<li>The <strong class="source-inline">paths</strong> and <strong class="source-inline">paths-ignore</strong> fields can be used to specify if code has changed within a particular path. The value of those fields may be set to glob patterns that use the <strong class="source-inline">*</strong> and <strong class="source-inline">**</strong> wildcard characters. The <strong class="source-inline">paths</strong> and <strong class="source-inline">paths-ignore</strong> filters allow you to control what paths are included or excluded from path <span class="No-Break">pattern matching.</span></li>
				<li><strong class="source-inline">Pull request</strong>: The <strong class="source-inline">pull_request</strong> field is used to tell the action to trigger a pull request.  Like the previous field, we can specify the <strong class="source-inline">branches</strong> filter to include specific branch names or the <strong class="source-inline">branches-ignore</strong> filter to exclude branch names. Similarly, the <strong class="source-inline">paths</strong> and <strong class="source-inline">paths-ignore</strong> fields may also be set. The <strong class="source-inline">branches</strong> and <strong class="source-inline">branches-ignore</strong> fields also accept <span class="No-Break">glob patterns.</span></li>
				<li><strong class="source-inline">event_name</strong>: The <strong class="source-inline">event_name</strong> field defines the type of activity that will trigger a workflow to be executed. Within GitHub, there are events that can be triggered from more than one activity. The syntax of the full defined event that includes this field is defined <span class="No-Break">as follows:</span></li>
			</ul>
			<p><span class="No-Break"><strong class="source-inline">on.&lt;event_name&gt;.types</strong></span></p>
			<p>There is quite a long list of available events that can be used, including the two that we covered earlier, <strong class="source-inline">push</strong> and <strong class="source-inline">pull_request</strong>, but also <strong class="source-inline">check_run</strong>, <strong class="source-inline">label</strong>, <strong class="source-inline">release</strong>, and <span class="No-Break">many more.</span></p>
			<p>There’s a lot more that can be done with GitHub Actions, so to see the full list of options to customize the <strong class="source-inline">on</strong> field, <span class="No-Break">visit </span><a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions"><span class="No-Break">https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions</span></a><span class="No-Break">.</span></p>
			<p>Now that we<a id="_idIndexMarker908"/> have a good understanding of GitHub Actions, let’s look at the default configuration and see what it has set for the <span class="No-Break"><strong class="source-inline">on</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
on:
  push:
    # run only against tags
    tags:
    - '*'</pre>
			<p>Perfect! This is pretty much exactly what we need. The preceding block of code specifies running the workflow triggered by tags <span class="No-Break">being pushed.</span></p>
			<h4>Permissions</h4>
			<p>The <strong class="source-inline">permissions</strong> field is <a id="_idIndexMarker909"/>used to define the level of access that the GitHub Actions workflow has to various resources within your GitHub repository. Essentially, it helps you control what your workflow can and can’t do within your repository. Let’s take a look at the default configuration for the <span class="No-Break"><strong class="source-inline">permissions</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
permissions:
  contents: write
  # packages: write
  # issues: write</pre>
			<p>The last two lines are commented out, but we can still discuss them. Within the preceding code, there are three permission types specified: <strong class="source-inline">contents</strong>, <strong class="source-inline">packages</strong>, and <strong class="source-inline">issues</strong>. Since these permissions are all set to <strong class="source-inline">write</strong>, but the latter two are commented out, then we limit the workflow permissions to <strong class="source-inline">contents: write</strong> to the repository. Based on the documentation on GoReleaser, the <strong class="source-inline">contents:write</strong> permission is required in order to upload archives as GitHub releases or to publish <span class="No-Break">to Homebrew.</span></p>
			<p>If you want <a id="_idIndexMarker910"/>to push Docker images to GitHub, you’ll need to enable the <strong class="source-inline">packages: write</strong> permission. If you use milestone closing capacity, you’ll need the <strong class="source-inline">issues: write</strong> <span class="No-Break">permission enabled.</span></p>
			<h4>Jobs</h4>
			<p>The <strong class="source-inline">jobs</strong> field defines <a id="_idIndexMarker911"/>the individual tasks that make up your workflow. It is basically the blueprint of the workflow, defining each job and specifying in which order they will be executed. Let’s take a look at the default value set within our <span class="No-Break">configuration file:</span></p>
			<pre class="source-code">
jobs:
  goreleaser:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - run: git fetch --force --tags
      - uses: actions/setup-go@v3
        with:
          go-version: '&gt;=1.20.0'
          cache: true
      - uses: goreleaser/goreleaser-action@v4
        with:
          distribution: goreleaser
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</pre>
			<p>Now, let’s<a id="_idIndexMarker912"/> clarify the preceding code. There is only one job, named <strong class="source-inline">goreleaser</strong>, defined under the <strong class="source-inline">jobs</strong> field. The <strong class="source-inline">goreleaser</strong> job has the following steps defined <span class="No-Break">in order:</span></p>
			<ol>
				<li><strong class="bold">Checkout code</strong> – the first step uses the <strong class="source-inline">actions/checkout@v3</strong> action to check out the code from your GitHub repository. The <strong class="source-inline">fetch-depth</strong> parameter is set to <strong class="source-inline">0</strong>, which ensures that all branches and tags are fetched from <span class="No-Break">the repository.</span></li>
				<li><strong class="bold">Fetch git tags</strong> – the second step runs the <strong class="source-inline">git fetch --force --tags</strong> command, which fetches all tags from the <span class="No-Break">Git repository.</span></li>
				<li><strong class="bold">Set up Go environment</strong> – the third step uses the <strong class="source-inline">actions/setup-go@v3</strong> action to set up a Go environment. The <strong class="source-inline">go-version</strong> parameter is set to <strong class="source-inline">&gt;=1.20.0</strong>, which specifies the minimum version of Go required for this job. The <strong class="source-inline">cache</strong> parameter is set to <strong class="source-inline">true</strong>, which tells GitHub Actions to cache the Go environment, speeding up subsequent runs of <span class="No-Break">this job.</span></li>
				<li><strong class="bold">Release with GoReleaser</strong> – the final step uses the <strong class="source-inline">goreleaser/goreleaser-action@v4</strong> action to release the code with GoReleaser. The <strong class="source-inline">distribution</strong> parameter is set to <strong class="source-inline">goreleaser</strong>, which specifies the type of distribution to be used. The <strong class="source-inline">version</strong> parameter is set to <strong class="source-inline">latest</strong>, which specifies the latest version of GoReleaser to be used. The <strong class="source-inline">args </strong>parameter is set to <strong class="source-inline">release --clean</strong>, which specifies the command-line arguments to be passed to GoReleaser when the release <span class="No-Break">is performed.</span></li>
			</ol>
			<p>The only <a id="_idIndexMarker913"/>modification that we’ll need to do to the default configuration is to modify the <strong class="source-inline">with.version</strong> field for the <strong class="source-inline">goreleaser/goreleaser-action</strong> step. Currently, the default value is set to <strong class="source-inline">latest</strong>. Let’s replace it with <strong class="source-inline">${{ env.GITHUB_REF_NAME }}</strong>. The environment variable, <strong class="source-inline">env.GITHUB_REF_NAME</strong>, is automatically set by GitHub and represents the branch or tag name for the current <span class="No-Break">Git reference.</span></p>
			<p>Final note, at the bottom of the configuration file, the environment variables are set to be used when <strong class="source-inline">goreleaser</strong> runs. <strong class="source-inline">secrets.GITHUB_TOKEN</strong> must be replaced with <strong class="source-inline">secrets.PUBLISHER_TOKEN</strong>. This token will be used when publishing to our other repository, the Homebrew tap repository. We’ve completed the configuration of our GitHub Actions, so now we can move on to the <span class="No-Break">next step.</span></p>
			<h3>Setting up your GitHub repositories</h3>
			<p>If you’ve <a id="_idIndexMarker914"/>been following along with the audiofile CLI repository, then the repository already exists on GitHub. However, if you are creating your own CLI application in tandem, now is the time to make sure the repository exists <span class="No-Break">on GitHub.</span></p>
			<p>Besides pushing your CLI application’s repository to GitHub, we’ll also need to create the Homebrew tap repository that was defined earlier in the GoReleaser configuration file. A Homebrew <strong class="bold">tap repository</strong> is a <a id="_idIndexMarker915"/>second location, in our case a repository hosted on GitHub, that is separate from the official Homebrew repository, which hosts additional formula for Homebrew to install on macOS. Taps make it easier for users to install new applications, that do not exist in the <strong class="source-inline">homebrew/core</strong> repository, onto <span class="No-Break">their computers.</span></p>
			<p>Let’s<a id="_idIndexMarker916"/> follow the steps to creating a new Homebrew <span class="No-Break">tap repository:</span></p>
			<ol>
				<li>Sign in to <span class="No-Break">GitHub </span><a href="https://github.com"><span class="No-Break">https://github.com</span></a><span class="No-Break">.</span></li>
				<li>Click the <strong class="bold">New repository</strong> button from your <span class="No-Break">GitHub dashboard.</span></li>
				<li>Enter the repository details. In our example, enter the name, homebrew-audiofile, that matches what we set within the GoReleaser configuration. Make sure that the repository is set to <strong class="source-inline">Public</strong> <span class="No-Break">as well.</span></li>
				<li>Create the repository by clicking on the <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">repository</strong></span><span class="No-Break"> button.</span></li>
				<li>Clone the repository to your <span class="No-Break">local machine.</span></li>
			</ol>
			<p>There’s no reason to add any files at this point. The GoReleaser tool, once we run the release process, will push the formula to this repository, but first, we need to create a token <span class="No-Break">to use.</span></p>
			<h3>Setting up your GitHub Token for Actions</h3>
			<p>In order <a id="_idIndexMarker917"/>to make the GoReleaser and GitHub Actions workflow work, we need to create a GitHub token and <span class="No-Break">Actions secret.</span></p>
			<p>To create a GitHub Token, click on your user menu and select the <span class="No-Break"><strong class="bold">Settings</strong></span><span class="No-Break"> option:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/Figure_14.3_B18883.jpg" alt="Figure 14.3 – User menu with the Settings option selected"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – User menu with the Settings option selected</p>
			<p>Once you <a id="_idIndexMarker918"/>are on the <strong class="bold">Settings</strong> page, scroll down the menu to see the last option, <strong class="bold">Developer Settings</strong>. When you select <strong class="bold">Developer Settings</strong>, you should now see the <strong class="bold">Personal access tokens</strong> option in the menu on the <span class="No-Break">left side.</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_14.4_B18883.jpg" alt="Figure 14.4 – The Developer Settings page with Generate new token options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – The Developer Settings page with Generate new token options</p>
			<p>Click on<a id="_idIndexMarker919"/> the <strong class="bold">Generate new token</strong> button. You might need to authenticate again if you have a two-factor authentication setup, but then you should be routed to the <strong class="bold">New personal access token (classic)</strong> page. From this page, take the following steps to create your <span class="No-Break">GitHub token:</span></p>
			<ol>
				<li>Enter a value for the <strong class="bold">Note</strong> field, a description of what the token will be used for. Let’s put in <strong class="source-inline">audiofile</strong> since this will be used for the audiofile <span class="No-Break">CLI project.</span></li>
				<li>In the <strong class="bold">Select scopes</strong> section, select <strong class="bold">repo</strong>. This will give it permission to run actions against your repositories. Then, scroll to the bottom and click the <strong class="bold">Generate </strong><span class="No-Break"><strong class="bold">token</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Figure_14.5_B18883.jpg" alt="Figure 14.5 – The Personal access tokens page once the token has been generated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – The Personal access tokens page once the token has been generated</p>
			<ol>
				<li value="3">Copy <a id="_idIndexMarker920"/>the generated token (which has been blocked out within the <span class="No-Break">preceding screenshot).</span></li>
				<li>Go back to your CLI repository; in our case, we went back to <span class="No-Break">the </span><a href="https://github.com/marianina8/audiofile"><span class="No-Break">https://github.com/marianina8/audiofile</span></a><span class="No-Break">.</span></li>
				<li>Click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">Settings</strong></span><span class="No-Break">.</span></li>
				<li>From the menu on the left side, click on <strong class="bold">Secrets and Variables</strong>, which expands to show more options. Click on the <span class="No-Break"><strong class="bold">Actions</strong></span><span class="No-Break"> option.</span></li>
				<li>Click on <strong class="bold">New repository secret</strong>, which is in the top right corner of <span class="No-Break">the screen.</span></li>
			</ol>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/Figure_14.6_B18883.jpg" alt="Figure 14.6 – Actions secrets and variables page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Actions secrets and variables page</p>
			<ol>
				<li value="8">From<a id="_idIndexMarker921"/> the <strong class="bold">Actions secrets/New secret</strong> page, enter the <strong class="bold">Name</strong> of your secret. This should match what we entered within the GoReleaser configuration. If you recall, the <strong class="source-inline">env.GITHUB_TOKEN</strong> value in the template was set to <strong class="source-inline">secrets.PUBLISHER_TOKEN</strong>. Enter the <strong class="source-inline">PUBLISHER_TOKEN</strong> value into the <span class="No-Break"><strong class="bold">Name</strong></span><span class="No-Break"> field.</span></li>
				<li>Paste the secret you copied in <em class="italic">step 3</em> into the <span class="No-Break"><strong class="bold">Secret</strong></span><span class="No-Break"> field.</span></li>
				<li>Click the <strong class="bold">Add </strong><span class="No-Break"><strong class="bold">secret</strong></span><span class="No-Break"> button.</span></li>
				<li>Confirm that the secret now exists in your <strong class="bold">Actions secrets and </strong><span class="No-Break"><strong class="bold">variables</strong></span><span class="No-Break"> page.</span></li>
			</ol>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/Figure_14.7_B18883.jpg" alt="Figure 14.7 – Repository secrets showing newly created PUBLISHER_TOKEN"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – Repository secrets showing newly created PUBLISHER_TOKEN</p>
			<p>Now that <a id="_idIndexMarker922"/>the publisher token is set, let’s move on to the <span class="No-Break">final step.</span></p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor364"/>Trigger release</h1>
			<p>Now that the <a id="_idIndexMarker923"/>configuration files have been set up for GoReleaser and GitHub Actions, and the publisher tokens to give access to make changes to the repositories are also created and shared, we are ready to trigger a release with the next step of the workflow: tag and push the code. Before we do so, let’s take a step back and discuss what happens when you trigger the <span class="No-Break">goReleaser job:</span></p>
			<ul>
				<li><strong class="bold">Preparation</strong>: GoReleaser checks the configuration files, validates the environment, and sets up the necessary <span class="No-Break">environment variables</span></li>
				<li><strong class="bold">Building</strong>: Builds the Go binary and compiles it for multiple platforms (such as Windows, Linux, <span class="No-Break">and macOS)</span></li>
				<li><strong class="bold">Versioning</strong>: Generates a new version number based on the existing version and the <span class="No-Break">user’s configuration</span></li>
				<li><strong class="bold">Creating the release artifacts</strong>: Generates the release artifacts, such as tarballs, deb/rpm packages, and zip files for <span class="No-Break">each platform</span></li>
				<li><strong class="bold">Creating a Git tag</strong>: Creates a new Git tag for the release, which is used to reference the release in <span class="No-Break">the future</span></li>
				<li><strong class="bold">Uploading the artifacts</strong>: Uploads the generated release artifacts to the specified locations, such as a GitHub release, a file server, or a cloud <span class="No-Break">storage service</span></li>
				<li><strong class="bold">Updating Homebrew formulas</strong>: If you are using Homebrew, it will update the Homebrew formulas to reflect the <span class="No-Break">new release</span></li>
				<li><strong class="bold">Notifying stakeholders</strong>: If set up to do so, GoReleaser can notify stakeholders about the new release through various channels, such as email, Slack, <span class="No-Break">or webhooks</span></li>
			</ul>
			<p>Note that the <a id="_idIndexMarker924"/>previous steps may vary based on the specific configuration and plugins used with GoReleaser. Moving on, let’s trigger it with the push of <span class="No-Break">a tag.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor365"/>Tag and push the code</h2>
			<p>At this<a id="_idIndexMarker925"/> point, make sure all the code changes you have been pushed to the remote repository for your <span class="No-Break">CLI project:</span></p>
			<ol>
				<li>Tag your CLI with the appropriate version. For our CLI project, within the audiofile repository, we run the following <span class="No-Break">Git command:</span><pre class="source-code">
<strong class="bold">git tag -a v0.1 -m "Initial deploy"</strong></pre></li>
				<li>Now push the tag to the repository. This should trigger the GitHub Actions to <span class="No-Break">take place:</span><pre class="source-code">
<strong class="bold">git push origin v0.1</strong></pre></li>
				<li>Visit the CLI repository, and you’ll now notice a yellow dot appear at the top of the <span class="No-Break">file listing:</span></li>
			</ol>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/Figure_14.8_B18883.jpg" alt="Figure 14.8 – Repository showing yellow dot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – Repository showing yellow dot</p>
			<ol>
				<li value="4">Click on the yellow dot, and a popup will appear. To view the details of the GoReleaser process, click on the <span class="No-Break"><strong class="bold">Details</strong></span><span class="No-Break"> link:</span></li>
			</ol>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/Figure_14.9_B18883.jpg" alt="Figure 14.9 – Details popup of goReleaser process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – Details popup of goReleaser process</p>
			<ol>
				<li value="5">Clicking on <a id="_idIndexMarker926"/>the <strong class="bold">Details</strong> link will take you to a page where you can watch the GoReleaser workflow progressing through <span class="No-Break">each task:</span></li>
			</ol>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_14.10_B18883.jpg" alt="Figure 14.10 – List of tasks and their progress within the goreleaser job"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – List of tasks and their progress within the goreleaser job</p>
			<ol>
				<li value="6">Once it successfully completes, from the CLI repository, click on the tag listed under the <strong class="bold">Releases</strong> section on the right-hand side of the page. From there, you’ll see<a id="_idIndexMarker927"/> the changelog and list <span class="No-Break">of </span><span class="No-Break"><strong class="bold">Assets</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_14.11_B18883.jpg" alt="Figure 14.11 – List of assets generated from the goreleaser job"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – List of assets generated from the goreleaser job</p>
			<p>Looks like all the builds were successfully generated and archived and are available as assets on the <strong class="bold">Releases</strong> page. What if it can be installed successfully with Homebrew? For the final confirmation, let’s jump to the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor366"/>Installing with Homebrew and Testing</h1>
			<p>Since the GoReleaser job ran successfully, we should be able to install the CLI application <a id="_idIndexMarker928"/>with Homebrew. Let’s begin by telling Homebrew to tap the repository we’ve created <a id="_idIndexMarker929"/>for <span class="No-Break">the formula:</span></p>
			<pre class="console">
brew tap marianina8/audiofile</pre>
			<p>You should see the following output generated from the <span class="No-Break">previous command:</span></p>
			<pre class="console">
==&gt; Tapping marianina8/audiofile
Cloning into '/opt/homebrew/Library/Taps/marianina8/homebrew-audiofile'...
remote: Enumerating objects: 6, done.
remote: Counting objects: 100% (6/6), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 0), reused 3 (delta 0), pack-reused 0
Receiving objects: 100% (6/6), done.
Tapped 1 formula (13 files, 6.3KB).</pre>
			<p>As we<a id="_idIndexMarker930"/> know, tapping <a id="_idIndexMarker931"/>the repository adds to the list of Homebrew formulas to install. Next, let’s try installing the <span class="No-Break">audiofile CLI:</span></p>
			<pre class="console">
brew install marianina8/audiofile/audiofile</pre>
			<p>You should <a id="_idIndexMarker932"/>see the following output generated for the installation of <span class="No-Break">the application:</span></p>
			<pre class="console">
==&gt; Fetching marianina8/audiofile/audiofile
==&gt; Downloading https://github.com/marianina8/audiofile/releases/download/v0.2/audiofile_Darwin_all.tar.gz
==&gt; Downloading from https://objects.githubusercontent.com/github-production-release-asset-2e65be/483881004/ccc2302f-a4a5-454a
######################################################################## 100.0%
==&gt; Installing audiofile from marianina8/audiofile
<img src="image/015.png" alt=""/>  /opt/homebrew/Cellar/audiofile/0.2: 4 files, 19.2MB, built in 3 seconds
==&gt; Running `brew cleanup audiofile`...
Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.
Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).</pre>
			<p>Now, for the final test, let’s run the <strong class="source-inline">audiofile</strong> command and see <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/Figure_14.12_B18883.jpg" alt="Figure 14.12 – Output of the audiofile command installed by Homebrew"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – Output of the audiofile command installed by Homebrew</p>
			<p>Let’s<a id="_idIndexMarker933"/> now try <a id="_idIndexMarker934"/>some of the commands; first, let’s<a id="_idIndexMarker935"/> start the API in one <span class="No-Break">terminal window:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro audiofile % audiofile api
Starting API at http://localhost:8000
Press Ctrl-C to stop.</pre>
			<p>In another terminal, let’s run the player by calling <span class="No-Break">the following:</span></p>
			<pre class="console">
audiofile player</pre>
			<p>You should see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_14.13_B18883.jpg" alt="Figure 14.13 – The audiofile player"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13 – The audiofile player</p>
			<p>We’ve been<a id="_idIndexMarker936"/> able to install with the Homebrew<a id="_idIndexMarker937"/> package manager and play around with the audiofile to know that it works well. This concludes our chapter on publishing <a id="_idIndexMarker938"/>your Go binary as a Homebrew formula with GoReleaser. While Homebrew is just one package manager, you can follow a similar process<a id="_idIndexMarker939"/> for <strong class="bold">GoFish</strong>, a cross-platform systems package manager that allows users to easily install applications on Linux and Windows. Combined, you’ll be able to expand your user base and make it easy for your users to install and update your <span class="No-Break">CLI application.</span></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor367"/>Summary</h1>
			<p>In this chapter, we took a closer look at how GoReleaser and GitHub Actions can work together to make releasing a CLI application a breeze. First, we got to know GoReleaser, a handy tool that makes building, testing, and deploying Go binary packages a snap. We went over the default configuration file and also talked about some simple tweaks you can make to fit your needs. Then, we explored GitHub Actions and how to integrate them <span class="No-Break">with GoReleaser.</span></p>
			<p>By the end of this chapter, we had a good understanding of how to use these tools to create a seamless and efficient release process, complete with publishing on Homebrew. Releasing through Homebrew opens up the possibility of reaching more users who prefer to use <span class="No-Break">package managers.</span></p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor368"/>Questions</h1>
			<ol>
				<li>When are <strong class="source-inline">before</strong> hooks run? Are there <span class="No-Break"><strong class="source-inline">after</strong></span><span class="No-Break"> hooks?</span></li>
				<li>What is the <strong class="source-inline">PUBLISHER_TOKEN</strong> GitHub token <span class="No-Break">used for?</span></li>
				<li>Can you trigger a GitHub Action workflow on a <span class="No-Break">pull request?</span></li>
			</ol>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor369"/>Further reading</h1>
			<ul>
				<li>GoReleaser documentation can be found <span class="No-Break">at </span><a href="https://goreleaser.com/"><span class="No-Break">https://goreleaser.com/</span></a><a href="https://goreleaser.com/&#13;"/></li>
				<li>GitHub Actions documentation can be found <span class="No-Break">at </span><a href="https://docs.github.com/en/actions"><span class="No-Break">https://docs.github.com/en/actions</span></a><a href="https://docs.github.com/en/actions&#13;"/></li>
				<li>Homebrew documentation can be found <span class="No-Break">at </span><a href="https://docs.brew.sh/"><span class="No-Break">https://docs.brew.sh/</span></a><a href="https://docs.brew.sh/&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor370"/>Answers</h1>
			<ol>
				<li value="1">The <strong class="source-inline">before</strong> hooks field specifies scripts that are run before the release process. Yes, although not discussed in this chapter, there are <strong class="source-inline">after</strong> <span class="No-Break">hooks, too!</span></li>
				<li>The <strong class="source-inline">PUBLISHER_TOKEN</strong> GitHub token is set as an environment variable on the goreleaser job in the <strong class="source-inline">release.yml</strong> file that defines the GitHub Actions release workflow. The token is configured within GitHub to give repository access to GitHub Actions, allowing the <strong class="source-inline">goreleaser</strong> job to publish the Homebrew formula to the <strong class="source-inline">homebrew-audiofile</strong> <span class="No-Break">tap repository.</span></li>
				<li>Yes, among many other triggers described in this chapter, pull requests can also trigger GitHub <span class="No-Break">Action workflows.</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer124" class="IMG---Figure">
			</div>
		</div>
	</body></html>