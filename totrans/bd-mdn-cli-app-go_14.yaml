- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing Your Go Binary as a Homebrew Formula with GoReleaser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at GoReleaser and GitHub Actions and how they can
    be used in tandem to automate the release of a Go binary as a Homebrew formula.
    First, we’ll look at **GoReleaser**, a popular open source tool that streamlines
    the creation, testing, and distribution of Go binaries. We’ll look at its various
    configurations and options as well as how it works with GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we’ll look at **GitHub Actions**, a CI/CD platform that lets
    you automate software development workflows and integrate with other tools such
    as GoReleaser. We’ll look at how to use it to ensure consistent and reliable builds,
    tests, and deployments.
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve mastered both tools, we’ll concentrate on triggering releases, creating
    a Homebrew tap, and integrating with Homebrew for simple installation and testing.
    **Homebrew**, a popular package manager for macOS, can be used for easy installation
    and management of your CLI application. Releasing your software to Homebrew not
    only simplifies the installation process for macOS users, but also gives you access
    to a wider audience. You can reach a sizable community of macOS developers and
    consumers that prefer using a package manager for program installation, such as
    Homebrew. Users can quickly find and install your software with just one command,
    increasing its usability and accessibility. This can help you reach a larger audience
    than you otherwise would and boost the visibility, usage, and adoption of your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you’ll have a firm grasp of how to combine GoReleaser
    and GitHub Actions to create an automated and efficient release process, and that
    includes publishing to Homebrew. With this knowledge, you will be able to tailor
    your own workflow to your specific requirements. The following topics will be
    covered:'
  prefs: []
  type: TYPE_NORMAL
- en: GoReleaser workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing with Homebrew and Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the GoReleaser tool at [https://goreleaser.com/install/](https://goreleaser.com/install/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GoReleaser workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Releasing software may be a lengthy and challenging process, particularly for
    projects with several dependencies and platforms. In addition to saving time,
    automating the release process lowers the possibility of human error and guarantees
    reliable and effective releases. GoReleaser is a popular choice for automating
    the release process for Go developers. However, there are also other choices,
    such as CircleCI, GitLab CI, and GitHub Actions, each of which has particular
    advantages and features. In this section, we’ll examine the advantages of automating
    the release procedure and look in more detail at a few of these choices, specifically
    GoReleaser and GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compared to alternatives, GoReleaser stands out for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to use**: Setup is simple and intuitive, making it easy for developers
    to get started with release automation. Their CLI quickly initializes a repository
    with a default configuration that can often work out of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform support**: A variety of operating systems, including the major OSs,
    and cloud services are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization at each step**: Programmers have the ability to customize at
    every step of the release process including building, testing, and publishing
    to various platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release artifacts**: A wide range of release artifacts may be produced, including
    Debian packages, Docker images, and binary files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versatile**: Combining with CI/CD pipelines, such as GitHub Actions, enables
    developers to fully automate their release procedure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source**: Programmers may access the source code of the GoReleaser project
    and alter it to suit their own needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community support**: GoReleaser offers a sizable and active user base, making
    it simple for developers to contribute to the project and find answers to their
    questions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While there are many benefits to using GoReleaser, there are, however, a few
    reasons to not use GoReleaser for your project that you may need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliance on Github**: This may not be ideal if you prefer to use different
    tools or workflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specific platform requirements**: While GoReleaser supports many popular
    OSs or cloud providers, you may require a platform that is not supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex release requirements**: While there is customization allowed in every
    step, there’s a possibility GoReleaser may not be flexible enough to serve your
    specific level of complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, while there are other options out there, choose a tool that works
    for your specific use case. We do feel like GoReleaser is a great tool to use
    for the audiofile CLI use case, so let’s continue.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having analyzed the pros and cons of using GoReleaser, let’s dive into its
    workflow by first sketching the overall process and then delving into each stage
    in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure your project to use GoReleaser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure GitHub Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up your GitHub repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up your GitHub token for Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag and push the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It might make more sense to view this with a visual, so this is what we are
    trying to accomplish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser](img/Figure_14.1_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive deeper and gain a more thorough understanding of each step involved
    in the workflow now that we have a general idea of how it works; we will explore
    using GoReleaser with GitHub Actions and learn how to automate your own releases.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your project to use GoReleaser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the GoReleaser tool installed, you can now initialize your CLI repository.
    In this case, we’ll initialize the root of the audiofile CLI project repository
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should notice that a new file has been generated: `goreleaser.yml`. Before
    even inspecting the file, we can run a local-only release to confirm that there
    are no issues with the configuration by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the command gives you a clear idea of all the steps involved
    in the release. We will walk through these steps in the next section, *Trigger
    release*. At the very end of the output, you should see a message indicating a
    successful release, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While the default configuration succeeded, we’ll need to look deeper into the
    configuration settings and modify and add appropriately to customize our release
    process. First, let’s look at the default `.goreleaser.yaml` file together and
    break it down.
  prefs: []
  type: TYPE_NORMAL
- en: Global hooks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the very top of the file, we see some default global hooks. `before` field
    allows you to specify which custom scripts to run before the release process begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we configured the automation to run the `go mod tidy`
    and `go generate ./...` commands prior to the release process. However, you might
    run scripts that perform tasks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the version number in your project’s code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a changelog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running automated tests to ensure that your code is working as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your project and creating release artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing changes to your version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scripts you call from the `before` hooks section in GoReleaser can be written
    in any language, as long as they can be executed from the command line. For example,
    you might write scripts in Go, Python, Bash, or any other language that supports
    shell execution.
  prefs: []
  type: TYPE_NORMAL
- en: Builds and environment variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we see some default builds and some environment variables set. The `builds`
    field allows you to determine the combination of operating systems, defined by
    the `GOOS` field, architectures defined by the `GOARCH` field, and architecture
    mode, defined by the `GOARM` field. It also allows you to add additional fields,
    such as the `env` field, which allows you to set environment variables for the
    builds. Additional aspects that can be defined include the binary, flags, hook
    and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example that exists within the default configuration, we defined
    the environment variable, `CGO_ENABLED`, to be set to `0`, and then configure
    the build process to generate binaries for the Linux, Windows, and Darwin operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `env` field can be set at a global level so that the environment variable
    is available at all stages of the release process, or it may be specified, such
    as in the previous case, within the build context alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final configuration ends up having a few more modifications, such as specifying
    a few additional architectures, `amd64` and `arm64`, and removing `go generate
    ./...` before hook, which is unnecessary. Also, we’ve modified the `builds` field
    by setting build flags to use the `pro` and `dev` flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While there are many other options you can set under the `builds` field, we
    will not cover them in this section. We encourage you to view the full list of
    customizations available at [https://goreleaser.com/customization/builds/](https://goreleaser.com/customization/builds/).
  prefs: []
  type: TYPE_NORMAL
- en: Archives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we view some default `archives` settings. In GoReleaser, an `README`,
    and `LICENSE` files. The objective is to package your application’s critical components
    into a single file, essentially making it easier to distribute and deploy. The
    default configuration sets the `archives` field to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the preceding defaults for the `archives` field, you can see that the
    default archive format is `tar.gz` for all operating systems except for when `GOOS`
    is set to Windows. In that case, the archive format is `zip`. The name of the
    file is defined by a template. To learn more about the GoReleaser naming template,
    visit [https://goreleaser.com/customization/templates/](https://goreleaser.com/customization/templates/)
    as there are many fields to customize the name of your archive. Let’s at least
    review the keys used in the `naming_template` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.ProjectName` – the project name. If not set, GoReleaser will use the name
    of the directory containing the Go project. In our case, it is `audiofile`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Os` – `GOOS` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Arch` – `GOARCH` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Arm` – `GOARM` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand what these template keys refer to, let’s suppose that
    we generate an archive for our audiofile CLI project, for Linux, with an `amd64`
    architecture. The resulting name of the archive file would be `audiofile_Linux_x86x64.tar.gz`.
  prefs: []
  type: TYPE_NORMAL
- en: Checksum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GoReleaser automatically creates and includes a file called `project 1.0.0
    checksums.txt` with the release package. `archives` field, you can use `naming_template`
    to generate the name of the `checksum` file. However, within our configuration,
    the default value for the `checksum` field is simply `checksums.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Defining a `checksum` file is important since it helps ensure the integrity
    of the data being distributed. The `checksum` file contains a one-of-a-kind code
    that can be used to verify that the downloaded files are identical to the original
    files. If the `checksum` file is not provided, the released files may be modified
    or corrupted throughout the download process. This can result in unpredictable
    behavior in your application and problems for your users. To avoid this, always
    provide a `checksum` file with your releases so that everyone knows they’re getting
    the correct version of your product.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `snapshot` field in the GoReleaser configuration file specifies whether
    a release is a “snapshot” or a stable release. A **snapshot** is a non-production
    version of a software project that is made available for testing and feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated release artifacts will be marked as snapshots if the `snapshot`
    field is set to `true`. This means that the version number will be suffixed with
    `-SNAPSHOT`, and the release will not be published to any remote repository, such
    as GitHub Releases. If the `snapshot` field is set to `false` or is not supplied,
    the release is considered stable and is published normally. Like the previous
    two fields, `archives` and `checksum`, the `snapshot` field also has a `name_template`
    that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If not set, the default version, `0.0.1`, is set. Based on the previous template,
    the name of the snapshot will be `0.0.1-next`. `incpatch`, according to the GoReleaser
    documentation, increments the patch of the given reversion, with a side note that
    it will panic if it’s not a semantic version. A `major.minor.patch` to convey
    the level of changes in a software release.
  prefs: []
  type: TYPE_NORMAL
- en: Changelog
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `changelog` field defines the path of your project’s changelog file. A **changelog**
    file contains a list of all the changes, improvements, and bug fixes made to a
    software project, typically organized by version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim is to record these changes so that users and developers can easily
    discover what’s new in a specific release. The changelog also aids with debugging
    and support by documenting the development process. Let’s look at the default
    configuration for the `changelog` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding block of the configuration, we defined the behavior of the
    changelog generation process. Using the `sort` field, we specify the order in
    which the entries of the changelog should be displayed, in this case, `asc`, for
    ascending. The `filters` field specifies, with the `exclude` subfield, a list
    of regular expressions matched against commits to be excluded. To view all the
    options available for the `changelog` field, visit `https://goreleaser.com/customization/changelog/`.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we’ve finished analyzing the default GoReleaser configuration,
    let’s determine what we’d want to consider adding.
  prefs: []
  type: TYPE_NORMAL
- en: Release
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code block in the GoReleaser configuration dictates that if there
    are any changes present within a Git repository, it automatically generates a
    pre-release. The pre-released version will have a version number that includes
    a pre-release suffix, such as `1.0.0-beta.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This automated process provides a convenient way for developers to create early
    versions of their software for testing purposes. By utilizing pre-releases, they
    can quickly and effortlessly gather feedback on the latest changes and make any
    necessary modifications before releasing a final version to the public.
  prefs: []
  type: TYPE_NORMAL
- en: Universal binaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine having just one file that can work on multiple architectures of an
    operating system, such as an install that works on a macOS machine with either
    an M1 or Intel chip. That’s what a **universal binary** is, also known as **fat
    binaries**. Instead of having separate binaries for different architectures, you’d
    have just one universal binary that can work on both. This makes it a lot more
    convenient for developers to spread their software across different platforms,
    and for users to just download a single file and run it on their system without
    having to worry about compatibility issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We tell GoReleaser to use universal binaries by adding the `universal_binaries`
    field and setting the `replace` value to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Brews
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `brews` field allows developers to specify the details for creating and
    publishing Homebrew as part of their release process. Let’s take a look at the
    following addition to our configuration for the audiofile CLI project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s at least define what these fields are defining for the Homebrew creation
    and publishing process. A **tap repository** is a GitHub repository that contains
    one or more formula files, which define how to install a particular package on
    Homebrew. Note that the tap repository, although defined in the configuration,
    will be created in *Step 3*, *Setting up your* *GitHub repositories*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – Defaults to the project name, audiofile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`homepage` – Your CLI application’s homepage. This defaults to empty, but set
    it to your GitHub repository name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tap` – Defines the GitHub/GitLab repository to publish the formula to. The
    `owner` field is the owner of the repository. The `name` field is the name of
    the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commit_author` – This is the Git author that shows up when committing to the
    repository. It defaults to `goreleaserbot`, but in our case, we set it to our
    GitHub handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view all the available customizations available for the `brew` field
    at [https://goreleaser.com/customization/homebrew/](https://goreleaser.com/customization/homebrew/).
  prefs: []
  type: TYPE_NORMAL
- en: Onto the next step!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring GitHub Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within this section, we’ll learn about GitHub Actions and how they can be integrated
    with the GoReleaser tool. First, **Github Actions**, as you may recall, is a CI/CD
    tool, but get ready for this, it also has an incredible feature that allows you
    to set off an execution of whatever code you like on your repository when a certain
    event occurs! You may already know this actually, but for those who now know,
    new doors of opportunity are opening. Let’s discuss the main components of GitHub
    Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Events**: Any GitHub event, such as pushing code, creating a new branch,
    opening a PR, a pull request, or commenting on an issue. Events trigger workflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runners**: A runner is a process that starts executing a workflow when triggered
    by an event. There is a one-to-one relationship between a runner and a job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/.``github/workflows` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jobs**: A single job is a series of tasks. A task could be a script or another
    GitHub action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: An action is a task. Some tasks may perform complex tasks such
    as publishing a Go package to Homebrew, or simple tasks, such as setting an environment
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram may help to indicate the relationship between the four
    major components of GitHub Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Relationship between events, runners, workflows, jobs, and
    actions](img/Figure_14.2_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Relationship between events, runners, workflows, jobs, and actions
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve grasped the concept of GitHub Actions, let’s see how we can
    take events, such as pushing tags, to trigger a GoReleaser job, which performs
    the complex task of publishing a Go package to Homebrew for us. First, we need
    to create the configuration file. From the root of the repository, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `.github`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subfolder inside of the `.github` folder, called `workflows`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `release.yml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GoReleaser website provides a default configuration for GitHub Actions on
    their website at [https://goreleaser.com/ci/actions/](https://goreleaser.com/ci/actions/).
    You may copy and paste this from their website to give you a good starting point.
    We’ll make a few modifications, but before we do, let’s walk through the default
    configuration together. Let’s begin by discussing the fields that exist within
    the GitHub Actions `release.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'On'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `on` field within the Github Actions repository specifies the events that
    trigger the workflow. It could be a single event or multiple. Let’s go through
    some of the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Push`: The `push` field is used to tell the action to trigger a push. For
    example, this can be customized to specify pushing to a branch or tag. The syntax
    for this field is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on.push.<branches|tags|branches-ignore|tags-ignore>.<paths|paths-ignore>`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `branches` filter to include specific branch names and the `branches-ignore`
    filter to exclude certain branch names. Remember, don’t use both `branches` and
    `branches-ignore` in the same workflow event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `tags` filter for including specific tag names and `tags-ignore` for
    excluding certain tag names. Again, be careful, don’t use both `tags` and `tags-ignore`
    in the same workflow! Apparently, the workflow won’t run if that’s the case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `paths` and `paths-ignore` fields can be used to specify if code has changed
    within a particular path. The value of those fields may be set to glob patterns
    that use the `*` and `**` wildcard characters. The `paths` and `paths-ignore`
    filters allow you to control what paths are included or excluded from path pattern
    matching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pull request`: The `pull_request` field is used to tell the action to trigger
    a pull request. Like the previous field, we can specify the `branches` filter
    to include specific branch names or the `branches-ignore` filter to exclude branch
    names. Similarly, the `paths` and `paths-ignore` fields may also be set. The `branches`
    and `branches-ignore` fields also accept glob patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event_name`: The `event_name` field defines the type of activity that will
    trigger a workflow to be executed. Within GitHub, there are events that can be
    triggered from more than one activity. The syntax of the full defined event that
    includes this field is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on.<event_name>.types`'
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a long list of available events that can be used, including the
    two that we covered earlier, `push` and `pull_request`, but also `check_run`,
    `label`, `release`, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more that can be done with GitHub Actions, so to see the full
    list of options to customize the `on` field, visit [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a good understanding of GitHub Actions, let’s look at the
    default configuration and see what it has set for the `on` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! This is pretty much exactly what we need. The preceding block of code
    specifies running the workflow triggered by tags being pushed.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `permissions` field is used to define the level of access that the GitHub
    Actions workflow has to various resources within your GitHub repository. Essentially,
    it helps you control what your workflow can and can’t do within your repository.
    Let’s take a look at the default configuration for the `permissions` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines are commented out, but we can still discuss them. Within
    the preceding code, there are three permission types specified: `contents`, `packages`,
    and `issues`. Since these permissions are all set to `write`, but the latter two
    are commented out, then we limit the workflow permissions to `contents: write`
    to the repository. Based on the documentation on GoReleaser, the `contents:write`
    permission is required in order to upload archives as GitHub releases or to publish
    to Homebrew.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to push Docker images to GitHub, you’ll need to enable the `packages:
    write` permission. If you use milestone closing capacity, you’ll need the `issues:
    write` permission enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `jobs` field defines the individual tasks that make up your workflow. It
    is basically the blueprint of the workflow, defining each job and specifying in
    which order they will be executed. Let’s take a look at the default value set
    within our configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s clarify the preceding code. There is only one job, named `goreleaser`,
    defined under the `jobs` field. The `goreleaser` job has the following steps defined
    in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actions/checkout@v3` action to check out the code from your GitHub repository.
    The `fetch-depth` parameter is set to `0`, which ensures that all branches and
    tags are fetched from the repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git fetch --force --tags` command, which fetches all tags from the Git repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`actions/setup-go@v3` action to set up a Go environment. The `go-version` parameter
    is set to `>=1.20.0`, which specifies the minimum version of Go required for this
    job. The `cache` parameter is set to `true`, which tells GitHub Actions to cache
    the Go environment, speeding up subsequent runs of this job.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`goreleaser/goreleaser-action@v4` action to release the code with GoReleaser.
    The `distribution` parameter is set to `goreleaser`, which specifies the type
    of distribution to be used. The `version` parameter is set to `latest`, which
    specifies the latest version of GoReleaser to be used. The `args` parameter is
    set to `release --clean`, which specifies the command-line arguments to be passed
    to GoReleaser when the release is performed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only modification that we’ll need to do to the default configuration is
    to modify the `with.version` field for the `goreleaser/goreleaser-action` step.
    Currently, the default value is set to `latest`. Let’s replace it with `${{ env.GITHUB_REF_NAME
    }}`. The environment variable, `env.GITHUB_REF_NAME`, is automatically set by
    GitHub and represents the branch or tag name for the current Git reference.
  prefs: []
  type: TYPE_NORMAL
- en: Final note, at the bottom of the configuration file, the environment variables
    are set to be used when `goreleaser` runs. `secrets.GITHUB_TOKEN` must be replaced
    with `secrets.PUBLISHER_TOKEN`. This token will be used when publishing to our
    other repository, the Homebrew tap repository. We’ve completed the configuration
    of our GitHub Actions, so now we can move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your GitHub repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve been following along with the audiofile CLI repository, then the repository
    already exists on GitHub. However, if you are creating your own CLI application
    in tandem, now is the time to make sure the repository exists on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Besides pushing your CLI application’s repository to GitHub, we’ll also need
    to create the Homebrew tap repository that was defined earlier in the GoReleaser
    configuration file. A Homebrew `homebrew/core` repository, onto their computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow the steps to creating a new Homebrew tap repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to GitHub [https://github.com](https://github.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **New repository** button from your GitHub dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the repository details. In our example, enter the name, homebrew-audiofile,
    that matches what we set within the GoReleaser configuration. Make sure that the
    repository is set to `Public` as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the repository by clicking on the **Create** **repository** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clone the repository to your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s no reason to add any files at this point. The GoReleaser tool, once
    we run the release process, will push the formula to this repository, but first,
    we need to create a token to use.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your GitHub Token for Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make the GoReleaser and GitHub Actions workflow work, we need to
    create a GitHub token and Actions secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a GitHub Token, click on your user menu and select the **Settings**
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – User menu with the Settings option selected](img/Figure_14.3_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – User menu with the Settings option selected
  prefs: []
  type: TYPE_NORMAL
- en: Once you are on the **Settings** page, scroll down the menu to see the last
    option, **Developer Settings**. When you select **Developer Settings**, you should
    now see the **Personal access tokens** option in the menu on the left side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – The Developer Settings page with Generate new token options](img/Figure_14.4_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – The Developer Settings page with Generate new token options
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Generate new token** button. You might need to authenticate
    again if you have a two-factor authentication setup, but then you should be routed
    to the **New personal access token (classic)** page. From this page, take the
    following steps to create your GitHub token:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a value for the `audiofile` since this will be used for the audiofile
    CLI project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Select scopes** section, select **repo**. This will give it permission
    to run actions against your repositories. Then, scroll to the bottom and click
    the **Generate** **token** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.5 – The Personal access tokens page once the token has been generated](img/Figure_14.5_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – The Personal access tokens page once the token has been generated
  prefs: []
  type: TYPE_NORMAL
- en: Copy the generated token (which has been blocked out within the preceding screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to your CLI repository; in our case, we went back to the [https://github.com/marianina8/audiofile](https://github.com/marianina8/audiofile).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu on the left side, click on **Secrets and Variables**, which expands
    to show more options. Click on the **Actions** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New repository secret**, which is in the top right corner of the
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Actions secrets and variables page](img/Figure_14.6_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Actions secrets and variables page
  prefs: []
  type: TYPE_NORMAL
- en: From the `env.GITHUB_TOKEN` value in the template was set to `secrets.PUBLISHER_TOKEN`.
    Enter the `PUBLISHER_TOKEN` value into the **Name** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the secret you copied in *step 3* into the **Secret** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add** **secret** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that the secret now exists in your **Actions secrets and** **variables**
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Repository secrets showing newly created PUBLISHER_TOKEN](img/Figure_14.7_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Repository secrets showing newly created PUBLISHER_TOKEN
  prefs: []
  type: TYPE_NORMAL
- en: Now that the publisher token is set, let’s move on to the final step.
  prefs: []
  type: TYPE_NORMAL
- en: Trigger release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the configuration files have been set up for GoReleaser and GitHub
    Actions, and the publisher tokens to give access to make changes to the repositories
    are also created and shared, we are ready to trigger a release with the next step
    of the workflow: tag and push the code. Before we do so, let’s take a step back
    and discuss what happens when you trigger the goReleaser job:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparation**: GoReleaser checks the configuration files, validates the environment,
    and sets up the necessary environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building**: Builds the Go binary and compiles it for multiple platforms (such
    as Windows, Linux, and macOS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: Generates a new version number based on the existing version
    and the user’s configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating the release artifacts**: Generates the release artifacts, such as
    tarballs, deb/rpm packages, and zip files for each platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating a Git tag**: Creates a new Git tag for the release, which is used
    to reference the release in the future'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uploading the artifacts**: Uploads the generated release artifacts to the
    specified locations, such as a GitHub release, a file server, or a cloud storage
    service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updating Homebrew formulas**: If you are using Homebrew, it will update the
    Homebrew formulas to reflect the new release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notifying stakeholders**: If set up to do so, GoReleaser can notify stakeholders
    about the new release through various channels, such as email, Slack, or webhooks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the previous steps may vary based on the specific configuration and
    plugins used with GoReleaser. Moving on, let’s trigger it with the push of a tag.
  prefs: []
  type: TYPE_NORMAL
- en: Tag and push the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, make sure all the code changes you have been pushed to the remote
    repository for your CLI project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tag your CLI with the appropriate version. For our CLI project, within the
    audiofile repository, we run the following Git command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now push the tag to the repository. This should trigger the GitHub Actions
    to take place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Visit the CLI repository, and you’ll now notice a yellow dot appear at the
    top of the file listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Repository showing yellow dot](img/Figure_14.8_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Repository showing yellow dot
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the yellow dot, and a popup will appear. To view the details of the
    GoReleaser process, click on the **Details** link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Details popup of goReleaser process](img/Figure_14.9_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Details popup of goReleaser process
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Details** link will take you to a page where you can watch
    the GoReleaser workflow progressing through each task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.10 – List of tasks and their progress within the goreleaser job](img/Figure_14.10_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – List of tasks and their progress within the goreleaser job
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it successfully completes, from the CLI repository, click on the tag listed
    under the **Releases** section on the right-hand side of the page. From there,
    you’ll see the changelog and list of **Assets**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.11 – List of assets generated from the goreleaser job](img/Figure_14.11_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – List of assets generated from the goreleaser job
  prefs: []
  type: TYPE_NORMAL
- en: Looks like all the builds were successfully generated and archived and are available
    as assets on the **Releases** page. What if it can be installed successfully with
    Homebrew? For the final confirmation, let’s jump to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing with Homebrew and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the GoReleaser job ran successfully, we should be able to install the
    CLI application with Homebrew. Let’s begin by telling Homebrew to tap the repository
    we’ve created for the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output generated from the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, tapping the repository adds to the list of Homebrew formulas to
    install. Next, let’s try installing the audiofile CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output generated for the installation of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the final test, let’s run the `audiofile` command and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Output of the audiofile command installed by Homebrew](img/Figure_14.12_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – Output of the audiofile command installed by Homebrew
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now try some of the commands; first, let’s start the API in one terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal, let’s run the player by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13 – The audiofile player](img/Figure_14.13_B18883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.13 – The audiofile player
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been able to install with the Homebrew package manager and play around
    with the audiofile to know that it works well. This concludes our chapter on publishing
    your Go binary as a Homebrew formula with GoReleaser. While Homebrew is just one
    package manager, you can follow a similar process for **GoFish**, a cross-platform
    systems package manager that allows users to easily install applications on Linux
    and Windows. Combined, you’ll be able to expand your user base and make it easy
    for your users to install and update your CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a closer look at how GoReleaser and GitHub Actions
    can work together to make releasing a CLI application a breeze. First, we got
    to know GoReleaser, a handy tool that makes building, testing, and deploying Go
    binary packages a snap. We went over the default configuration file and also talked
    about some simple tweaks you can make to fit your needs. Then, we explored GitHub
    Actions and how to integrate them with GoReleaser.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we had a good understanding of how to use these
    tools to create a seamless and efficient release process, complete with publishing
    on Homebrew. Releasing through Homebrew opens up the possibility of reaching more
    users who prefer to use package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When are `before` hooks run? Are there `after` hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `PUBLISHER_TOKEN` GitHub token used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you trigger a GitHub Action workflow on a pull request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GoReleaser documentation can be found at [https://goreleaser.com/](https://goreleaser.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions documentation can be found at [https://docs.github.com/en/actions](https://docs.github.com/en/actions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homebrew documentation can be found at [https://docs.brew.sh/](https://docs.brew.sh/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `before` hooks field specifies scripts that are run before the release process.
    Yes, although not discussed in this chapter, there are `after` hooks, too!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PUBLISHER_TOKEN` GitHub token is set as an environment variable on the
    goreleaser job in the `release.yml` file that defines the GitHub Actions release
    workflow. The token is configured within GitHub to give repository access to GitHub
    Actions, allowing the `goreleaser` job to publish the Homebrew formula to the
    `homebrew-audiofile` tap repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, among many other triggers described in this chapter, pull requests can
    also trigger GitHub Action workflows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
