<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Microservices</h1>
                </header>
            
            <article>
                
<p>First, we are going to look at how easy it is to create a simple web server with a single endpoint using the <kbd>net/http</kbd> package. Then, we will move on to examine the <kbd>encoding/json</kbd> package to see just how easy Go makes it for us to use JSON objects for our requests and our responses. Finally, we will look at how routing and handlers work and how we can manage context between these handlers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a simple web server with net/http</h1>
                </header>
            
            <article>
                
<p>The <kbd>net/http</kbd> package provides all the features we need to write HTTP clients and servers. It gives us the capability to send requests to other servers communicating using the HTTP protocol as well as the ability to run a HTTP server that can route requests to separate Go funcs, serve static files, and much more.</p>
<p>To begin we should ask the question, <em>what technical book would be complete without a simple hello world example?</em> I say none and this is exactly where we will begin.</p>
<p>In this example, we are going to create an HTTP server with a single endpoint that returns static text represented by the JSON standard, this will introduce the basic functions of the HTTP server and handlers. We will then modify this endpoint to accept a request that is encoded in JSON and using the <kbd>encoding/json</kbd> package return a response to the client. We will also examine how the routing works by adding a second endpoint that returns a simple image.</p>
<p>By the end of this chapter, you will have a fundamental grasp of the basic packages and how you can use them to quickly and efficiently build a simple microservice.</p>
<p>Building a web server in Go is incredibly easy thanks to the HTTP package, which is distributed as part of the standard library.</p>
<p>It has everything you need to manage routing, dealing with <strong>Transport Layer Security</strong> (<strong>TLS</strong>), which we will cover in <a href="d38f7017-1c2e-4a12-b1dc-5870121afd4e.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Security</em>, support for HTTP/2 out of the box, and the capability to run an incredibly efficient server that can deal with a huge number of requests.</p>
<p>The source code for this chapter can be found on GitHub at <a href="http://github.com/building-microservices-with-go/chapter1.git">http://github.com/building-microservices-with-go/chapter1.git</a>, all the examples in this and subsequent chapters will reference the source extensively so if you have not already done so, go and clone this repo before continuing.</p>
<p>Let's look at the syntax for creating a basic server then we can walk through the packages in more depth:</p>
<p>Example 1.0 <kbd>basic_http_example/basic_http_example.go</kbd></p>
<pre>
09 func main() { <br/>10  port := 8080 <br/>11 <br/>12  http.HandleFunc("/helloworld", helloWorldHandler) <br/>13 <br/>14  log.Printf("Server starting on port %v\n", 8080) <br/>15  log.Fatal(http.ListenAndServe(fmt.Sprintf(":%v", port), nil)) <br/>16 } <br/>17 <br/>18 func helloWorldHandler(w http.ResponseWriter, r *http.Request) { <br/>19   fmt.Fprint(w, "Hello World\n") <br/>20 } 
</pre>
<p>The first thing we are doing is calling the <kbd>HandleFunc</kbd> method on the <kbd>http</kbd> package. The <kbd>HandleFunc</kbd> method creates a <kbd>Handler</kbd> type on the <kbd>DefaultServeMux</kbd> handler, mapping the path passed in the first parameter to the function in the second parameter:</p>
<pre>
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) 
</pre>
<p>In line <strong>15</strong> we start the HTTP server, <kbd>ListenAndServe</kbd> takes two parameters, the TCP network address to bind the server to and the handler that will be used to route requests:</p>
<pre>
func ListenAndServe(addr string, handler Handler) error 
</pre>
<p>In our example, we are passing the network address <kbd>:8080"</kbd> this means we would like to bind the server to all available IP addresses on port <kbd>8080</kbd>.</p>
<p>The second parameter we are passing is <kbd>nil</kbd>, this is because we are using the <kbd>DefaultServeMux</kbd> handler, which we are setting up with our call to <kbd>http.HandleFunc</kbd>. In <a href="cfab2776-305a-417c-853f-26e4caba67d2.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Introducing Docker</em>, you will see the use of this second parameter when we introduce more sophisticated routers, but for now we can ignore it.</p>
<p>If the <kbd>ListenAndServe</kbd> function fails to start a server it will return an error, the most common reason for this is that you may be trying to bind to a port that is already in use on the server. In our example, we are passing the output of <kbd>ListenAndServe</kbd> straight to <kbd>log.Fatal(error)</kbd>, which is a convenience function equivalent to calling <kbd>fmt.Print(a ...interface{})</kbd> followed by a call to <kbd>os.Exit(1)</kbd>. Since <kbd>ListenAndServe</kbd> blocks if the server starts correctly we will never exit on a successful start.</p>
<p>Let's quickly run and test our new server:</p>
<pre>
<strong>$ go run ./basic_http_example.go</strong>  
</pre>
<p>You should now see the application output:</p>
<pre>
<strong>2016/07/30 01:08:21 Server starting on port 8080</strong>  
</pre>
<p>What if you do not see the preceding output and instead see something like the following?</p>
<pre>
<strong>2016/07/19 03:51:11 listen tcp :8080: bind: address already in use exit status 1</strong>  
</pre>
<p>Take another look at the signature of <kbd>ListenAndServe</kbd> and the way we are calling it. Remember what we were saying about why we were using <kbd>log.Fatal</kbd>?</p>
<p>If you do get this error message it means that you are already running an application on your computer that is using port <kbd>8080</kbd>, this could be another instance of your program or it could be another application. You can check that you do not have another instance running by checking the running processes:</p>
<pre>
<strong>$ ps -aux | grep 'go run'</strong>  
</pre>
<p>If you do see another <kbd>go run ./basic_http_example.go</kbd> then you can simply kill it and retry. If you do not have another instance running, then you probably have some other software that is bound to this port. Try changing the port on line <strong>10</strong> and restart your program.</p>
<p>To test the server, open a new browser and type in the URI <kbd>http://127.0.0.1:8080/helloworld</kbd> and if things are working correctly you should see the following response from the server:</p>
<pre>
Hello World 
</pre>
<p>Congratulations, that's the first step into microservice mastery. Now that we have our first program running, let's take a closer look at how we can return and accept JSON.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading and writing JSON</h1>
                </header>
            
            <article>
                
<p>Thanks to the <kbd>encoding /json</kbd> package, which is built into the standard library encoding and decoding JSON to and from Go types is both fast and easy. It implements the simplistic <kbd>Marshal</kbd> and <kbd>Unmarshal</kbd> functions; however, if we need them, the package also provides <kbd>Encoder</kbd> and <kbd>Decoder</kbd> types that allow us greater control when reading and writing streams of JSON data. In this section, we are going to examine both of these approaches, but first let's take a look at how simple it is to convert a standard Go <kbd>struct</kbd> into its corresponding JSON string.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Marshalling Go structs to JSON</h1>
                </header>
            
            <article>
                
<p>To encode JSON data, the <kbd>encoding/json</kbd> package provides the <kbd>Marshal</kbd> function, which has the following signature:</p>
<pre>
func Marshal(v interface{}) ([]byte, error) 
</pre>
<p>This function takes one parameter, which is of type <kbd>interface</kbd>, so pretty much any object you can think of since <kbd>interface</kbd> represents any type in Go. It returns a tuple of <kbd>([]byte, error)</kbd>, you will see this return style quite frequently in Go, some languages implement a try catch approach that encourages an error to be thrown when an operation cannot be performed, Go suggests the pattern <kbd>(return type, error)</kbd>, where the error is <kbd>nil</kbd> when an operation succeeds.</p>
<p>In Go, unhandled errors are a bad thing, and whilst the language does implement <kbd>Panic</kbd> and <kbd>Recover</kbd>, which resemble exception handling in other languages, the situations where you should use these are quite different (see <em>The Go Programming Language</em>, Kernaghan). In Go, the <kbd>panic</kbd> function causes normal execution to stop and all deferred function calls in the Go routine are executed, the program will then crash with a log message. It is generally used for unexpected errors that indicate a bug in the code and good robust Go code will attempt to handle these runtime exceptions and return a detailed <kbd>error</kbd> object back to the calling function.</p>
<p>This pattern is exactly what is implemented with the <kbd>Marshal</kbd> function. In the instance that <kbd>Marshal</kbd> cannot create a JSON encoded byte array from the given object, which could be due to a runtime panic, then this is captured and an error object detailing the problem is returned to the caller.</p>
<p>Let's try this out, expanding on our existing example, instead of simply printing a string from our handler, let's create a simple <kbd>struct</kbd> for the response and return this instead.</p>
<p>Example 1.1 <kbd>reading_writing_json_1/reading_writing_json_1.go</kbd></p>
<pre>
10 type helloWorldResponse struct { <br/>11    Message string <br/>12 } 
</pre>
<p>In our handler, we will create an instance of this object, set the message, then use the <kbd>Marshal</kbd> function to encode it to a string before returning.</p>
<p>Let's see what that will look like:</p>
<pre>
23 func helloWorldHandler(w http.ResponseWriter, r *http.Request) { <br/>24   response := helloWorldResponse{Message: "HelloWorld"} <br/>25   data, err := json.Marshal(response) <br/>26   if err != nil { <br/>27     panic("Ooops") <br/>28   } <br/>29  <br/>30   fmt.Fprint(w, string(data)) <br/>31 } 
</pre>
<p>Now, when we run our program again and refresh our browser, we see the following output rendered in valid JSON:</p>
<pre>
{"Message":"Hello World"} 
</pre>
<p>This is awesome; however, the default behavior of <kbd>Marshal</kbd> is to take the literal name of the field and use this as the field in the JSON output. What if I prefer to use camel case and would rather see "message", could we just rename the field in the <kbd>helloWorldResponse</kbd> struct?</p>
<p>Unfortunately we can't, as in Go, lowercase properties are not exported, <kbd>Marshal</kbd> will ignore these and will not include them in the output.</p>
<p>All is not lost as the <kbd>encoding/json</kbd> package implements <kbd>struct</kbd> field attributes that allow us to change the output for the property to anything we choose.</p>
<p>Example 1.2 <kbd>reading_writing_json_2/reading_writing_json_2.go</kbd></p>
<pre>
10 type helloWorldResponse struct { <br/>11   Message string `json:"message"` <br/>12 } 
</pre>
<p>Using the <kbd>struct</kbd> field's tags, we can have greater control of how the output will look. In the preceding example, when we marshal this <kbd>struct</kbd> the output from our server would be:</p>
<pre>
{"message":"Hello World"} 
</pre>
<p>This is exactly what we want, but we can use field tags to control the output even further. We can convert object types and even ignore a field altogether if we need to:</p>
<pre>
type helloWorldResponse struct {<br/>// change the output field to be "message" <br/>   Message   string `json:"message"` <br/>   // do not output this field <br/>   Author  string `json:"-"` <br/>   // do not output the field if the value is empty <br/>   Date    string `json:",omitempty"` <br/>   // convert output to a string and rename "id" <br/>   Id    int    `json:"id, string"` <br/>} 
</pre>
<p>Channel, complex types, and functions cannot be encoded in JSON; attempting to encode these types will result in an <kbd>UnsupportedTypeError</kbd> being returned by the <kbd>Marshal</kbd> function.</p>
<p>It also can't represent cyclic data structures; if your <kbd>stuct</kbd> contains a circular reference then <kbd>Marshal</kbd> will result in an infinite recursion, which is never a good thing for a web request.</p>
<p>If we want to export our JSON prettily formatted with indentation, we can use the <kbd>MarshallIndent</kbd> function, this allows you to pass an additional parameter of <kbd>string</kbd> to specify what you would like the indent to be. Two spaces right, not a tab?</p>
<pre>
func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) 
</pre>
<p>The astute reader might have noticed that we are decoding our <kbd>struct</kbd> into a byte array and then writing that to the response stream, this does not seem to be particularly efficient and in fact it is not. Go provides <kbd>Encoders</kbd> and <kbd>Decoders</kbd>, which can write directly to a stream, since we already have a stream with the <kbd>ResponseWriter</kbd> then let's do just that.</p>
<p>Before we do, I think we need to look at the <kbd>ResponseWriter</kbd> a little to see what is going on there.</p>
<p>The <kbd>ResponseWriter</kbd> is an interface that defines three methods:</p>
<pre>
// Returns the map of headers which will be sent by the <br/>// WriteHeader method. <br/>Header() <br/><br/>// Writes the data to the connection. If WriteHeader has not <br/>// already been called then Write will call <br/>// WriteHeader(http.StatusOK). <br/>Write([]byte) (int, error) <br/><br/>// Sends an HTTP response header with the status code. <br/>WriteHeader(int) 
</pre>
<p>If we have a <kbd>ResponseWriter</kbd> interface, how can we use this with <kbd>fmt.Fprint(w io.Writer, a ...interface{})</kbd>? This method requires a <kbd>Writer</kbd> interface as a parameter and we have a <kbd>ResponseWriter</kbd> interface. If we look at the signature for <kbd>Writer</kbd> we can see that it is:</p>
<pre>
Write(p []byte) (n int, err error) 
</pre>
<p>Because the <kbd>ResponseWriter</kbd> interface implements this method, it also satisfies the interface <kbd>Writer</kbd> and therefore any object that implements <kbd>ResponseWriter</kbd> can be passed to any function that expects <kbd>Writer</kbd>.</p>
<p>Amazing, Go rocks, but we have not answered our question, <em>Is there any better way to send our data to the output stream without marshalling to a temporary object before we return it?</em></p>
<p>The <kbd>encoding/json</kbd> package has a function called <kbd>NewEncoder</kbd> this returns us an <kbd>Encoder</kbd> object that can be used to write JSON straight to an open writer and guess what; we have one of those:</p>
<pre>
func NewEncoder(w io.Writer) *Encoder 
</pre>
<p>So instead of storing the output of <kbd>Marshal</kbd> into a byte array, we can write it straight to the HTTP response.</p>
<p>Example 1.3 <kbd>reading_writing_json_3/reading_writing_json_3.go</kbd>:</p>
<pre>
func helloWorldHandler(w http.ResponseWriter, r *http.Request) { <br/>    response := HelloWorldResponse{Message: "HelloWorld"} <br/>    encoder := json.NewEncoder(w) <br/>    encoder.Encode(&amp;response) <br/>}                
</pre>
<p>We will look at benchmarking in a later chapter, but to see why this is important we have created a simple benchmark to check the two methods against each other, have a look at the output.</p>
<p>Example 1.4 <kbd>reading_writing_json_2/reading_writing_json_2.go</kbd>:</p>
<pre>
<strong>$go test -v -run="none" -bench=. -benchtime="5s" -benchmem<br/></strong><strong><br/>BenchmarkHelloHandlerVariable-8  20000000  511 ns/op  248 B/op  5 allocs/op<br/></strong><strong>BenchmarkHelloHandlerEncoder-8  20000000  328 ns/op   24 B/op  2 allocs/op<br/></strong><strong>BenchmarkHelloHandlerEncoderReference-8  20000000  304 ns/op  8 B/op  1 allocs/op<br/></strong><strong>PASS<br/></strong><strong>ok  github.com/building-microservices-with-go/chapter1/reading_writing_json_2  24.109s</strong> 
</pre>
<p>Using <kbd>Encoder</kbd> rather than marshalling to a byte array is nearly 50% faster. We are dealing with nanoseconds here so that time may seem irrelevant, but it isn't; this was two lines of code. If you have that level of inefficiency throughout the rest of your code then your application will run slower, you will need more hardware to satisfy the load and that will cost you money. There is nothing clever in the differences between the two methods all we have done is understood how the standard packages work and chosen the correct option for our requirements, that is not performance tuning, that is understanding the framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unmarshalling JSON to Go structs</h1>
                </header>
            
            <article>
                
<p>Now we have learned how we can send JSON back to the client, what if we need to read input before returning the output? We could use URL parameters and we will see what that is all about in the next chapter, but commonly you will need more complex data structures that involve the service to accept JSON as part of an HTTP <kbd>POST</kbd> request.</p>
<p>Applying similar techniques that we learned in the previous section to write JSON, reading JSON is just as easy. To decode JSON into a <kbd>stuct</kbd> field the <kbd>encoding/json</kbd> package provides us with the <kbd>Unmarshal</kbd> function:</p>
<pre>
func Unmarshal(data []byte, v interface{}) error 
</pre>
<p>The <kbd>Unmarshal</kbd> function works in the opposite way to <kbd>Marshal</kbd>; it allocates maps, slices, and pointers as required. Incoming object keys are matched using either the <kbd>struct</kbd> field name or its tag and will work with a case-insensitive match; however, an exact match is preferred. Like <kbd>Marshal</kbd>, <kbd>Unmarshal</kbd> will only set exported <kbd>struct</kbd> fields, those that start with an upper-case letter.</p>
<p>We start by adding a new <kbd>struct</kbd> field to represent the request, whilst <kbd>Unmarshal</kbd> can decode the JSON into an <kbd>interface{}</kbd>, which would be of <kbd>map[string]interface{} // for JSON objects type</kbd> or: <kbd>[]interface{} // for JSON arrays</kbd>, depending if our JSON is an object or an array.</p>
<p>In my opinion it is much clearer to the readers of our code if we explicitly state what we are expecting as a request. We can also save ourselves work by not having to manually cast the data when we come to use it.</p>
<p>Remember two things:</p>
<ul>
<li>You do not write code for the compiler, you write code for humans to understand</li>
<li>You will spend more time reading code than you do writing it</li>
</ul>
<p>Taking these two points into account we create a simple <kbd>struct</kbd> to represent our request, which will look like this:</p>
<p>Example 1.5 <kbd>reading_writing_json_4/reading_writing_json_4.go</kbd>:</p>
<pre>
14 type helloWorldRequest struct { <br/>15   Name string `json:"name"` <br/>16 } 
</pre>
<p>Again, we are going to use <kbd>struct</kbd> field tags as whilst we could let <kbd>Unmarshal</kbd> do case-insensitive matching so <kbd>{"name": "World}</kbd> would correctly unmarshal into the <kbd>struct</kbd> the same as <kbd>{"Name": "World"}</kbd>, when we specify a tag we are being explicit about the request form and that is a good thing. In terms of speed and performance it is also about 10% faster, and remember, performance matters.</p>
<p>To access the JSON sent with the request we need to take a look at the <kbd>http.Request</kbd> object passed to our handler. The following listing does not show all the methods on the request, just the ones we are going to be immediately dealing with, for full documentation I recommend checking out the documentation at <a href="https://godoc.org/net/http#Request"><span class="URLPACKT">https://godoc.org/net/http#Request</span></a>:</p>
<pre>
type Requests struct { <br/>... <br/>  // Method specifies the HTTP method (GET, POST, PUT, etc.). <br/>  Method string <br/><br/>// Header contains the request header fields received by the server. The type Header is a link to map[string] []string.  <br/>Header Header <br/><br/>// Body is the request's body. <br/>Body io.ReadCloser <br/>... <br/>} 
</pre>
<p>The JSON that has been sent with the request is accessible in the <kbd>Body</kbd> field. Body implements the interface <kbd>io.ReadCloser</kbd> as a stream and does not return a <kbd>[]byte</kbd> or a <kbd>string</kbd>. If we need the data contained in the body, we can simply read it into a byte array, as shown in the following example:</p>
<pre>
30 body, err := ioutil.ReadAll(r.Body) <br/>31 if err != nil { <br/>32     http.Error(w, "Bad request", http.StatusBadRequest) <br/>33     return   <br/>34 } 
</pre>
<p>Here is something we'll need to remember. We are not calling <kbd>Body.Close()</kbd>, if we were making a call with a client we would need to do this as it is not automatically closed, however, when used in a <kbd>ServeHTTP</kbd> handler, the server automatically closes the request stream.</p>
<p>To see how this all works inside our handler, we can look at the following handler:</p>
<pre>
28 func helloWorldHandler(w http.ResponseWriter, r *http.Request) { <br/>29  <br/>30   body, err := ioutil.ReadAll(r.Body) <br/>31   if err != nil { <br/>32     http.Error(w, "Bad request", http.StatusBadRequest) <br/>33             return <br/>34   } <br/>35  <br/>36   var request helloWorldRequest <br/>37   err = json.Unmarshal(body, &amp;request) <br/>38   if err != nil { <br/>39     http.Error(w, "Bad request", http.StatusBadRequest) <br/>40             return <br/>41   } <br/>42  <br/>43  response := helloWorldResponse{Message: "Hello " + request.Name} <br/>44  <br/>45   encoder := json.NewEncoder(w) <br/>46   encoder.Encode(response) <br/>47 } 
</pre>
<p>Let's run this example and see how it works. To test, we can simply use the <kbd>curl</kbd> command to send a request to the running server. If you feel more comfortable using a GUI tool than Postman (which is available for the Google Chrome browser), they will work just fine or feel free to use your preferred tool:</p>
<pre>
<strong>$ curl localhost:8080/helloworld -d '{"name":"Nic"}'</strong>  
</pre>
<p>You should see the following response:</p>
<pre>
{"message":"Hello Nic"} 
</pre>
<p>What do you think will happen if you do not include a body with your request?</p>
<pre>
<strong>$ curl localhost:8080/helloworld</strong>  
</pre>
<p>If you guessed correctly, that you would get a <kbd>HTTP status 400 Bad Request</kbd>, then you win a prize:</p>
<pre>
func Error(w ResponseWriter, error string, code int) 
</pre>
<p>Errors reply to the request with the given message and status code. Once we have sent this, we need to return stopping further execution of the function as this does not close the <kbd>ResponseWriter</kbd> interface and return flow to the calling function automatically.</p>
<p>Just before you think you are done, have a go and see if you can improve the performance of the handler. Think about the things we were talking about when marshaling JSON.</p>
<p>Got it?</p>
<p>Well if not here is the answer, again all we are doing is using the <kbd>Decoder</kbd>, which is the opposite of the <kbd>Encoder</kbd> that we used in writing JSON. It has an instant 33% performance increase and less code too.</p>
<p>Example 1.6 <kbd>reading_writing_json_5/reading_writing_json_5.go</kbd>:</p>
<pre>
27 func helloWorldHandler(w http.ResponseWriter, r *http.Request) { <br/>28 <br/>29   var request HelloWorldRequest <br/>30   decoder := json.NewDecoder(r.Body) <br/>31  <br/>32   err := decoder.Decode(&amp;request) <br/>33   if err != nil { <br/>34     http.Error(w, "Bad request", http.StatusBadRequest) <br/>35             return <br/>36   } <br/>37  <br/>38   response := HelloWorldResponse{Message: "Hello " + request.Name} <br/>39  <br/>40   encoder := json.NewEncoder(w) <br/>41   encoder.Encode(response) <br/>42 } 
</pre>
<p>Now we can see just how easy it is to encode and decode JSON with Go, I would recommend taking five minutes now to spend some time digging through the documentation for the <kbd>encoding/json</kbd> package (<span class="URLPACKT"><a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a></span>) as there is a whole lot more that you can do with this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing in net/http</h1>
                </header>
            
            <article>
                
<p>Even a simple microservice will need the capability to route requests to different handlers dependent on the requested path or method. In Go this is handled by the <kbd>DefaultServeMux</kbd> method which is an instance of <kbd>ServerMux</kbd>. Earlier in this chapter, we briefly covered that when nil is passed to the handler parameter for the <kbd>ListenAndServe</kbd> function then the <kbd>DefaultServeMux</kbd> method is used. When we call the <kbd>http.HandleFunc("/helloworld", helloWorldHandler)</kbd> package function we are actually just indirectly calling <kbd>http.DefaultServerMux.HandleFunc(…)</kbd>.</p>
<p>The Go HTTP server does not have a specific router instead any object which implements the <kbd>http.Handler</kbd> interface is passed as a top level function to the <kbd>Listen()</kbd> function, when a request comes into the server the <kbd>ServeHTTP</kbd> method of this handler is called and it is responsible for performing or delegating any work. To facilitate the handling of multiple routes the HTTP package has a special object called <kbd>ServerMux</kbd>, which implements the <kbd>http.Handler</kbd> interface.</p>
<p>There are two functions to adding handlers to a <kbd>ServerMux</kbd> handler:</p>
<pre>
func HandlerFunc(pattern string, handler func(ResponseWriter, *Request)) <br/>func Handle(pattern string, handler Handler) 
</pre>
<p>The <kbd>HandleFunc</kbd> function is a convenience function that creates a handler who's <kbd>ServeHTTP</kbd> method calls an ordinary function with the <kbd>func(ResponseWriter, *Request)</kbd> signature that you pass as a parameter.</p>
<p>The <kbd>Handle</kbd> function requires that you pass two parameters, the pattern that you would like to register the handler and an object that implements the <kbd>Handler</kbd> interface:</p>
<pre>
type Handler interface { <br/>  ServeHTTP(ResponseWriter, *Request) <br/>} 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Paths</h1>
                </header>
            
            <article>
                
<p>We already explained how <kbd>ServeMux</kbd> is responsible for routing inbound requests to the registered handlers, however the way that the routes are matched can be quite confusing. The <kbd>ServeMux</kbd> handler has a very simple routing model it does not support wildcards or regular expressions, with <kbd>ServeMux</kbd> you must be explicit about the registered paths.</p>
<p>You can register both fixed rooted paths, such as <kbd>/images/cat.jpg</kbd>, or rooted subtrees such as <kbd>/images/</kbd>. The trailing slash in the rooted subtree is important as any request that starts with <kbd>/images/</kbd>, for example <kbd>/images/happy_cat.jpg</kbd>, would be routed to the handler associated with <kbd>/images/</kbd>.</p>
<p>If we register a path <kbd>/images/</kbd> to the handler foo, and the user makes a request to our service at <kbd>/images</kbd> (note no trailing slash), then <kbd>ServerMux</kbd> will forward the request to the <kbd>/images/</kbd> handler, appending a trailing slash.</p>
<p>If we also register the path <kbd>/images</kbd> (note no trailing slash) to the handler bar and the user requests <kbd>/images</kbd> then this request will be directed to bar; however, <kbd>/images/</kbd> or <kbd>/images/cat.jpg</kbd> will be directed to foo:</p>
<pre>
http.Handle("/images/", newFooHandler())<br/>http.Handle("/images/persian/", newBarHandler())<br/>http.Handle("/images", newBuzzHandler())<br/>/images                  =&gt; Buzz<br/>/images/                 =&gt; Foo<br/>/images/cat              =&gt; Foo<br/>/images/cat.jpg          =&gt; Foo<br/>/images/persian/cat.jpg  =&gt; Bar
</pre>
<p>Longer paths will always take precedence over shorter ones so it is possible to have an explicit route that points to a different handler to a catch all route.</p>
<p>We can also specify the hostname, we could register a path such as <kbd>search.google.com/</kbd> and <kbd>/ServerMux</kbd> would forward any requests to <kbd>http://search.google.com</kbd> and <kbd>http://www.google.com</kbd> to their respective handlers.</p>
<p>If you are used to a framework based application development approach such as using Ruby on Rails or ExpressJS you may find this router incredibly simple and it is, remember that we are not using a framework but the standard packages of Go, the intention is always to provide a basis that can be built upon. In very simple cases the <kbd>ServeMux</kbd> approach more than good enough and in fact I personally don't use anything else. Everyone's needs are different however and the beauty and simplicity of the standard packages makes it incredibly simple to build your own route as all is needed is an object which implements the <kbd>Handler</kbd> interface. A quick trawl through google will surface some very good third party routers but my recommendation for you is to learn the limitations of <kbd>ServeMux</kbd> first before deciding to choose a third-party package it will greatly help with your decision process as you will know the problem you are trying to solve.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Convenience handlers</h1>
                </header>
            
            <article>
                
<p>The <kbd>net/http</kbd> package implements several methods that create different types of convenience handlers, let's examine these.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FileServer</h1>
                </header>
            
            <article>
                
<p>A <kbd>FileServer</kbd> function returns a handler that serves HTTP requests with the contents of the filesystem. This can be used to serve static files such as images or other content that is stored on the file system:</p>
<pre>
func FileServer(root FileSystem) Handler 
</pre>
<p>Take a look at the following code:</p>
<pre>
http.Handle("/images", http.FileServer(http.Dir("./images")))
</pre>
<p>This allows us to map the contents of the file system path <kbd>./images</kbd> to the server route <kbd>/images</kbd>, <kbd>Dir</kbd> implements a file system which is restricted to a specific directory tree, the <kbd>FileServer</kbd> method uses this to be able to serve the assets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NotFoundHandler</h1>
                </header>
            
            <article>
                
<p>The <kbd>NotFoundHandler</kbd> function returns a simple request handler that replies to each request with a <kbd>404 page not found reply</kbd>:</p>
<pre>
func NotFoundHandler() Handler 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RedirectHandler</h1>
                </header>
            
            <article>
                
<p>The <kbd>RedirectHandler</kbd> function returns a request handler that redirects each request it receives to the given URI using the given status code. The provided code should be in the 3xx range and is usually <kbd>StatusMovedPermanently</kbd>, <kbd>StatusFound</kbd>, or <kbd>StatusSeeOther</kbd>:</p>
<pre>
func RedirectHandler(url string, code int) Handler 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StripPrefix</h1>
                </header>
            
            <article>
                
<p>The <kbd>StripPrefix</kbd> function returns a handler that serves HTTP requests by removing the given prefix from the request URL's path and then invoking <kbd>h</kbd> handler. If a path does not exist, then <kbd>StripPrefix</kbd> will reply with an HTTP 404 not found error:</p>
<pre>
func StripPrefix(prefix string, h Handler) Handler 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TimeoutHandler</h1>
                </header>
            
            <article>
                
<p>The <kbd>TimeoutHandler</kbd> function returns a <kbd>Handler</kbd> interface that runs <kbd>h</kbd> with the given time limit. When we investigate common patterns in <a href="74445ff8-eb01-4a2f-a910-0551e7d85a5f.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Microservice Frameworks</em>, we will see just how useful this can be for avoiding cascading failures in your service:</p>
<pre>
func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler 
</pre>
<p>The new handler calls <kbd>h.ServeHTTP</kbd> to handle each request, but if a call runs for longer than its time limit, the handler responds with a <kbd>503 Service Unavailable</kbd> response with the given message <kbd>(msg)</kbd> in its body.</p>
<p>The last two handlers are especially interesting as they are, in effect, chaining handlers. This is a technique that we will go into more in-depth in a later chapter as it allows you to both practice clean code and also allows you to keep your code DRY.</p>
<p>I may have lifted most of the descriptions for these handlers straight from the Go documentation and you probably have already read these because you have read the documentation right? With Go, the documentation is excellent and writing documentation for your own packages is heavily encouraged, even enforced, if you use the <kbd>golint</kbd> command that comes with the standard package then this will report areas of your code which do not conform to the standards. I really recommend spending a little time browsing the standard docs when you are using one of the packages, not only will you learn the correct usage, you may learn that there is a better approach. You will certainly be exposed to good practice and style and you may even be able to keep working on the sad day that Stack Overflow stops working and the entire industry grinds to a halt.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static file handler</h1>
                </header>
            
            <article>
                
<p>Whilst we are mostly going to be dealing with APIs in this book, it is a useful illustration to see how the default router and paths work by adding a secondary endpoint.</p>
<p>As a little exercise, try to modify the code in <kbd>reading_writing_json_5/reading_writing_json_5.go</kbd> to add an endpoint <kbd>/cat</kbd>, which returns the cat picture specified in the URI. To give you a little hint, you are going to need to use the <kbd>FileServer</kbd> function on the <kbd>net/http</kbd> package and your URI will look something like <kbd>http://localhost:8080/cat/cat.jpg</kbd>.</p>
<p>Did it work the first time or did you forget to add the <kbd>StripPrefix</kbd> handler?</p>
<p>Example 1.7 <kbd>reading_writing_json_6/reading_writing_json_6.go</kbd>:</p>
<pre>
21 cathandler := http.FileServer(http.Dir("./images")) <br/>22 http.Handle("/cat/", http.StripPrefix("/cat/", cathandler)) 
</pre>
<p>In the preceding example, we are registering a <kbd>StripPrefix</kbd> handler with our path <kbd>/cat/</kbd>. If we did not do this, then the <kbd>FileServer</kbd> handler would be looking for our image in the <kbd>images/cat</kbd> directory. It is also worth reminding ourselves about the difference with <kbd>/cat</kbd> and <kbd>/cat/</kbd> as paths. If we registered our path as <kbd>/cat</kbd> then we would not match <kbd>/cat/cat.jpg</kbd>. If we register our path as <kbd>/cat/</kbd>, we will match both <kbd>/cat</kbd> and <kbd>/cat/whatever</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating handlers</h1>
                </header>
            
            <article>
                
<p>We will now finish off our examples here by showing how you can create a <kbd>Handler</kbd> rather than just using <kbd>HandleFunc</kbd>. We are going to split the code that performs the request validation for our <kbd>helloworld</kbd> endpoint and the code that returns the response out into separate handlers to illustrate how it is possible to chain handlers.</p>
<p>Example 1.8 <kbd>chapter1/reading_writing_json_7.go</kbd>:</p>
<pre>
31 type validationHandler struct { <br/>32   next http.Handler <br/>33 } <br/>34  <br/>35 func newValidationHandler(next http.Handler) http.Handler { <br/>36   return validationHandler{next: next} <br/>37 } 
</pre>
<p>The first thing we need to do when creating our own <kbd>Handler</kbd> is to define a <kbd>struct</kbd> field that will implement the methods in the <kbd>Handlers</kbd> interface. Since in this example, we are going to be chaining handlers together, the first handler, which is our validation handler, needs to have a reference to the next in the chain as it has the responsibility for calling <kbd>ServeHTTP</kbd> or returning a response.</p>
<p>For convenience, we have added a function that returns us a new handler; however, we could have just set the next field. This method, however, is better form as it makes our code a little easier to read and when we need to pass complex dependencies to the handler using a function to create, it keeps things a little neater:</p>
<pre>
37 func (h validationHandler) ServeHTTP(rw http.ResponseWriter, r  <br/>*http.Request) {<br/>38   var request helloWorldRequest<br/>39   decoder := json.NewDecoder(r.Body)<br/>40<br/>41   err := decoder.Decode(&amp;request)<br/>42   if err != nil {<br/>43     http.Error(rw, "Bad request", http.StatusBadRequest)<br/>44     return<br/>45   }<br/>46<br/>47   h.next.ServeHTTP(rw, r)<br/>48 } 
</pre>
<p>The previous code block illustrates how we would implement the <kbd>ServeHTTP</kbd> method. The only interesting thing to note here is the statement that begins at line <strong>44</strong>. If an error is returned from decoding the request, we write a 500 error to the response, the handler chain would stop here. Only when no error is returned do we call the next handler in the chain and we do this simply by invoking its <kbd>ServeHTTP</kbd> method. To pass the name decoded from the request, we are simply setting a variable:</p>
<pre>
53 type helloWorldHandler struct{} <br/>54  <br/>55 func newHelloWorldHandler() http.Handler { <br/>56   return helloWorldHandler{} <br/>57 } <br/>58  <br/>59 func (h helloWorldHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) { <br/>60   response := helloWorldResponse{Message: "Hello " + name} <br/>61  <br/>62   encoder := json.NewEncoder(rw) <br/>63   encoder.Encode(response) <br/>64 } 
</pre>
<p>The <kbd>helloWorldHandler</kbd> type that writes the response does not look too different from when we were using a simple function. If you compare this to <em>example 1.6</em>, you will see that all we really have done is remove the request decoding.</p>
<p>Now the first thing I want to mention about this code is that it is purely to illustrate how you can do something, not that you should do something. In this simple case, splitting the request validation and response sending into two handlers adds a lot of needless complexity and it is not really making our code DRYer. The technique, however, is useful. When we examine authentication in a later chapter, you will see this pattern as it allows us to centralize our authentication logic and share it among handlers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Context</h1>
                </header>
            
            <article>
                
<p>The problem with the previous pattern is that there is no way that you can pass the validated request from one handler to the next without breaking the <kbd>http.Handler</kbd> interface, but guess what Go has us covered. The context package was listed as experimental for several years before finally making it in to the standard package with Go 1.7. The <kbd>Context</kbd> type implements a safe method for accessing request-scoped data that is safe to use simultaneously by multiple Go routines. Let’s take a quick look at this package and then update our example to see it in use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Background</h1>
                </header>
            
            <article>
                
<p>The <kbd>Background</kbd> method returns an empty context that has no values; it is typically used by the main function and as the top-level <kbd>Context</kbd>:</p>
<pre>
func Background() Context 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WithCancel</h1>
                </header>
            
            <article>
                
<p>The <kbd>WithCancel</kbd> method returns a copy of the parent context with a cancel function, calling the cancel function releases resources associated with the context and should be called as soon as operations running in the <kbd>Context</kbd> type are complete:</p>
<pre>
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WithDeadline</h1>
                </header>
            
            <article>
                
<p>The <kbd>WithDeadline</kbd> method returns a copy of the parent context that expires after the current time is greater than deadline. At this point, the context's <kbd>Done</kbd> channel is closed and the resources associated are released. It also passes back a <kbd>CancelFunc</kbd> method that allows manual cancellation of the context:</p>
<pre>
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WithTimeout</h1>
                </header>
            
            <article>
                
<p>The <kbd>WithTimeout</kbd> method is similar to <kbd>WithDeadline</kbd> except you pass it a duration for which the <kbd>Context</kbd> type should exist. Once this duration has elapsed, the <kbd>Done</kbd> channel is closed and the resources associated with the context are released:</p>
<pre>
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WithValue</h1>
                </header>
            
            <article>
                
<p>The <kbd>WithValue</kbd> method returns a copy of the parent <kbd>Context</kbd> in which the <kbd>val</kbd> value is associated with the key. The <kbd>Context</kbd> values are perfect to be used for request-scoped data:</p>
<pre>
func WithValue(parent Context, key interface{}, val interface{}) Context 
</pre>
<p>Why not attempt to modify <em>example 1.7</em> to implement a request scoped context. The key could be in the previous sentence; every request needs its own context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using contexts</h1>
                </header>
            
            <article>
                
<p>You probably found that rather painful, especially if you come from a background in a framework such as Rails or Spring. Writing this kind of code is not really something you want to be spending your time on, building application features is far more important. One thing to note however is that neither Ruby or Java have anything more advanced in their base packages. Thankfully for us, over the seven years that Go has been in existence, many excellent people have done just that, and when looking at frameworks in <a href="cfab2776-305a-417c-853f-26e4caba67d2.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Introducing Docker</em>, we will find that all of this complexity has been taken care of by some awesome open source authors.</p>
<p>In addition to the adoption of context into the main Go release version 1.7 implements an important update on the <kbd>http.Request</kbd> structure, we have the following additions:</p>
<pre>
func (r *Request) Context() context.Context
</pre>
<p>The <kbd>Context()</kbd> method gives us access to a <kbd>context.Context</kbd> structure which is always non nil as it is populated when the request is originally created. For inbound requests the <kbd>http.Server</kbd> manages the lifecycle of the context automatically cancelling it when the client connection closes. For outbound requests, <kbd>Context</kbd> controls cancellation, by this we mean that if we cancel the <kbd>Context()</kbd> method we can cancel the outgoing request. This concept is illustrated in the following example:</p>
<pre>
70 func fetchGoogle(t *testing.T) {<br/>71   r, _ := http.NewRequest("GET", "https://google.com", nil)<br/>72<br/>73   timeoutRequest, cancelFunc := context.WithTimeout(r.Context(), 1*time.Millisecond)<br/>74   defer cancelFunc()<br/>75<br/>76   r = r.WithContext(timeoutRequest)<br/>77<br/>78   _, err := http.DefaultClient.Do(r)<br/>79   if err != nil {<br/>80     fmt.Println("Error:", err)<br/>81   }<br/>82 }
</pre>
<p> </p>
<p>In line <strong>74</strong>, we are creating a timeout context from the original in the request, and unlike an inbound request where the context is automatically cancelled for you we must manually perform this step in an outbound request.</p>
<p> </p>
<p>Line <strong>77</strong> implements the second of the two new context methods which have been added to the <kbd>http.Request</kbd> object:</p>
<pre>
func (r *Request) WithContext(ctx context.Context) *Request
</pre>
<p>The <kbd>WithContext</kbd> object returns a shallow copy of the original request which has the context changed to the given <kbd>ctx</kbd> context.</p>
<p>When we execute this function we will find that after 1 millisecond the request will complete with an error:</p>
<pre>
Error: Get https://google.com: context deadline exceeded
</pre>
<p>The context is timing out before the request has a change to complete and the do method immediately returns. This is an excellent technique to use for outbound connections and thanks to the changes in Go 1.7 is now incredibly easy to implement.</p>
<p>What about our inbound connection Let’s see how we can update our previous example. Example 1.9 updates our example to show how we can leverage the <kbd>context</kbd> package to implement Go routine safe access to objects. The full example can be found in <kbd>reading_writing_json_8/reading_writing_json_8.go</kbd> but all of the modification we need to make are in the two <kbd>ServeHTTP</kbd> methods for our handlers:</p>
<pre>
41 func (h validationHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {<br/>42   var request helloWorldRequest<br/>43   decoder := json.NewDecoder(r.Body)<br/>44<br/>45   err := decoder.Decode(&amp;request)<br/>46   if err != nil {<br/>47     http.Error(rw, "Bad request", http.StatusBadRequest)<br/>48     return<br/>49   }<br/>50<br/>51   c := context.WithValue(r.Context(), validationContextKey("name"), request.Name)<br/>52   r = r.WithContext(c)<br/>53<br/>54   h.next.ServeHTTP(rw, r)<br/>55 }
</pre>
<p>If we take a quick look at our <kbd>validationHandler</kbd> you will see that when we have a valid request, we are creating a new context for this request and then setting the value of the <kbd>Name</kbd> field in the request into the context. You might also wonder what is going on with line <strong>51</strong>. When you add an item to a context such as with the <kbd>WithValue</kbd> call, the method returns a copy of the previous context, to save a little time and add a little confusion, we are holding a pointer to the context, so in order to pass this as a copy to <kbd>WithValue</kbd>, we must dereference it. To update our pointer, we must also set the returned value to the value referenced by the pointer hence again we need to dereference it. The other think we need to look at with this method call is the key, we are using <kbd>validationContextKey</kbd> this is an explicitly declared type of string:</p>
<pre>
13 type validationContextKey string
</pre>
<p>The reason we are not just using a simple string is that context often flows across packages and if we just used string then we could end up with a key clash where one package within your control is writing a <kbd>name</kbd> key and another package which is outside of your control is also using the context and writing a key called <kbd>name</kbd>, in this instance the second package would inadvertently overwrite your context value. By declaring a package level type <kbd>validationContextKey</kbd> and using this we can ensure that we avoid these collisions:</p>
<pre>
64 func (h helloWorldHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {<br/>65   name := r.Context().Value(validationContextKey("name")).(string)<br/>66   response := helloWorldResponse{Message: "Hello " + name}<br/>67<br/>68   encoder := json.NewEncoder(rw)<br/>69   encoder.Encode(response)<br/>70 }
</pre>
<p>To retrieve the value, all we have to do is obtain the context and then call the <kbd>Value</kbd> method casting it into a string.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RPC in the Go standard library</h1>
                </header>
            
            <article>
                
<p>As expected, the Go standard library has fantastic support for RPC right out-of-the-box. Let's look at a few examples of how we can use this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple RPC example</h1>
                </header>
            
            <article>
                
<p>In this simple example, we will see how we can use the standard RPC package to create a client and server that use a shared interface to communicate over RPC. We will follow the typical Hello World example that we ran through when learning the <kbd>net/http</kbd> package and see just how easy it is to build an RPC-based API in go:</p>
<p><kbd>rpc/server/server.go</kbd>:</p>
<pre>
34 type HelloWorldHandler struct{} <br/>35  <br/>36 func (h *HelloWorldHandler) HelloWorld(args *contract.HelloWorldRequest, reply *contract.HelloWorldResponse) error { <br/>37   reply.Message = ""Hello "" + args.Name <br/>38   return nil <br/>39 } 
</pre>
<p>Like our example on creating REST APIs using the standard library for RPC, we will also define a handler. The difference between this handler and <kbd>http.Handler</kbd> is that it does not need to conform to an interface; as long as we have a <kbd>struct</kbd> field with methods on it we can register this with the RPC server:</p>
<pre>
func Register(rcvr interface{}) error 
</pre>
<p>The <kbd>Register</kbd> function, which is in the <kbd>rpc</kbd> package, publishes the methods that are part of the given interface to the default server and allows them to be called by clients connecting to the service. The name of the method uses the name of the concrete type, so in our instance if my client wanted to call the <kbd>HelloWorld</kbd> method, we would access it using <kbd>HelloWorldHandler.HelloWorld</kbd>. If we do not wish to use the concrete types name, we can register it with a different name using the <kbd>RegisterName</kbd> function, which uses the provided name instead:</p>
<pre>
func RegisterName(name string, rcvr interface{}) error 
</pre>
<p>This would enable me to keep the name of the <kbd>struct</kbd> field to whatever is meaningful to my code; however, for my client contract I might decide to use something different such as <kbd>Greet</kbd>:</p>
<pre>
19 func StartServer() { <br/>20   helloWorld := &amp;HelloWorldHandler{} <br/>21   rpc.Register(helloWorld) <br/>22  <br/>23   l, err := net.Listen("("tcp",", fmt.Sprintf(":%(":%v",", port)) <br/>24   if err != nil { <br/>25     log.Fatal(fmt.Sprintf("("Unable to listen on given port: %s",", err)) <br/>26   } <br/>27  <br/>28   for { <br/>29     conn, _ := l.Accept() <br/>30     go rpc.ServeConn(conn) <br/>31   } <br/>32 } 
</pre>
<p>In the <kbd>StartServer</kbd> function, we first create a new instance of our handler and then we register this with the default RPC server.</p>
<p>Unlike the convenience of <kbd>net/http</kbd> where we can just create a server with <kbd>ListenAndServe</kbd>, when we are using RPC we need to do a little more manual work. In line <strong>23</strong>, we are creating a socket using the given protocol and binding it to the IP address and port. This gives us the capability to specifically select the protocol we would like to use for the server, <kbd>tcp</kbd>, <kbd>tcp4</kbd>, <kbd>tcp6</kbd>, <kbd>unix</kbd>, or <kbd>unixpacket</kbd>:</p>
<pre>
func Listen(net, laddr string) (Listener, error) 
</pre>
<p>The <kbd>Listen()</kbd> function returns an instance that implements the <kbd>Listener</kbd> interface:</p>
<pre>
type Listener interface { <br/>  // Accept waits for and returns the next connection to the listener. <br/>  Accept() (Conn, error) <br/><br/>  // Close closes the listener. <br/>  // Any blocked Accept operations will be unblocked and return errors. <br/>  Close() error <br/><br/>  // Addr returns the listener's network address. <br/>  Addr() Addr <br/>} 
</pre>
<p>To receive connections, we must call the <kbd>Accept</kbd> method on the listener. If you look at line <strong>29</strong>, you will see that we have an endless for loop, this is because unlike <kbd>ListenAndServe</kbd> which blocks for all connections, with an RPC server we handle each connection individually and as soon as we deal with the first connection we need to continue to again call <kbd>Accept</kbd> to handle subsequent connections or the application would exit. Accept is a blocking method so if there are no clients currently attempting to connect to the service then <kbd>Accept</kbd> will block until one does. Once we receive a connection then we need to call the <kbd>Accept</kbd> method again to process the next connection. If you look at line <strong>30</strong> in our example code, you will see we are calling the <kbd>ServeConn</kbd> method:</p>
<pre>
func ServeConn(conn io.ReadWriteCloser) 
</pre>
<p>The <kbd>ServeConn</kbd> method runs the <kbd>DefaultServer</kbd> method on the given connection, and will block until the client completes. In our example, we are using the go statement before running the server so that we can immediately process the next waiting connection without blocking for the first client to close its connection.</p>
<p>In terms of communication protocol, <kbd>ServeConn</kbd> uses the <kbd>gob</kbd> wire format <a href="https://golang.org/pkg/encoding/gob/"><span class="URLPACKT">https://golang.org/pkg/encoding/gob/</span></a>, we will see when we look at JSON-RPC how we can use a different encoding.</p>
<p>The <kbd>gob</kbd> format was specifically designed to facilitate Go to Go-based communication and was designed around the idea of something easier to use and possibly more efficient than the likes of protocol buffers, this comes at a cost of cross language communication.</p>
<p>With gobs, the source and destination values and types do not need to correspond exactly, when you send <kbd>struct</kbd>, if a field is in the source but not in the receiving <kbd>struct</kbd>, then the decoder will ignore this field and the processing will continue without error. If a field is present in the destination that is not in the source, then again the decoder will ignore this field and will successfully process the rest of the message. Whilst this seems like a minor benefit, it is a huge advancement over the RPC messages of old such as JMI where the exact same interface must be present on both the client and server. This level of inflexibility with JMI introduced tight coupling between the two code bases and caused no end of complexity when it was required to deploy an update to our application.</p>
<p>To make a request to our client we can no longer simply use curl as we are no longer are using the HTTP protocol and the message format is no longer JSON. If we look at the example in <kbd>rpc/client/client.go</kbd> we can see how to implement a connecting client:</p>
<pre>
13 func CreateClient() *rpc.Client {<br/>14   client, err := rpc.Dial("tcp", fmt.Sprintf("localhost:%v", port))<br/>15   if err != nil {<br/>16     log.Fatal("dialing:", err)<br/>17   }<br/>18<br/>19   return client<br/>20 }
</pre>
<p> </p>
<p>The previous block shows how we need to setup <kbd>rpc.Client</kbd>, the first thing we need to do on line <strong>14</strong> is to create the client itself using the <kbd>Dial()</kbd> function in the <kbd>rpc</kbd> package:</p>
<pre>
func Dial(network, address string) (*Client, error)
</pre>
<p>We then use this returned connection to make a request to the server:</p>
<pre>
22 func PerformRequest(client *rpc.Client) <br/>contract.HelloWorldResponse {<br/>23   args := &amp;contract.HelloWorldRequest{Name: "World"}<br/>24   var reply contract.HelloWorldResponse<br/>25<br/>26   err := client.Call("HelloWorldHandler.HelloWorld", args, &amp;reply)<br/>27   if err != nil {<br/>28     log.Fatal("error:", err)<br/>29   }<br/>30<br/>31   return reply<br/>32 }
</pre>
<p> </p>
<p>In line <strong>26</strong>, we are using the <kbd>Call()</kbd> method on the client to invoke the named function on the server:</p>
<pre>
func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error
</pre>
<p><kbd>Call</kbd> is a blocking function which waits until the server sends a reply writing the response assuming there is no error to the reference of our <kbd>HelloWorldResponse</kbd> passed to the method and if an error occurs when processing the request this is returned and can be handled accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RPC over HTTP</h1>
                </header>
            
            <article>
                
<p>In the instance that you need to use HTTP as your transport protocol then the <kbd>rpc</kbd> package can facilitate this by calling the <kbd>HandleHTTP</kbd> method.</p>
<p>The <kbd>HandleHTTP</kbd> method sets up two endpoints in your application:</p>
<pre>
const ( <br/>  // Defaults used by HandleHTTP <br/>  DefaultRPCPath   = "/_"/_goRPC_"_" <br/>  DefaultDebugPath = "/"/debug/rpc"" <br/>) 
</pre>
<p>If you point your browser at the <kbd>DefaultDebugPath</kbd> you can see details for the registered endpoints, there are two things to note:</p>
<ul>
<li>This does not mean you can communicate easily with your API from a web browser. The messages are still <kbd>gob</kbd> encoded so you would need to write a gob encoder and decoder in JavaScript, which I am not actually sure is possible. It was certainly never the intent of the package to support this capability and therefore I would not advise this action, a JSON or JSON-RPC based message is much better suited to this use case.</li>
<li>The debug endpoint is not going to provide you with auto-generated documentation for your API. The output is fairly basic and the intention seems to be so you can track the number of calls made to an endpoint.</li>
</ul>
<p>All that said there may be a reason why you need to use HTTP, possibly your network does not allow any other protocol or potentially you have a load balancer that is not capable of dealing with pure TCP connections. We can also take advantage of HTTP headers and other metadata which is not available using a pure TCP request.</p>
<p><kbd>rpc_http/server/server.go</kbd></p>
<pre>
22 func StartServer() { <br/>23   helloWorld := &amp;HelloWorldHandler{} <br/>24   rpc.Register(helloWorld) <br/>25   rpc.HandleHTTP() <br/>26  <br/>27   l, err := net.Listen("("tcp",", fmt.Sprintf(":%(":%v",", port)) <br/>28   if err != nil { <br/>29       log.Fatal(fmt.Sprintf("("Unable to listen on given port: %s",", err)) <br/>30   } <br/>31  <br/>32   log.Printf("("Server starting on port %v\n",", port) <br/>33  <br/>34   http.Serve(l, nil) <br/>35 } 
</pre>
<p>If we look at line <strong>25</strong>, in the preceding example, we can see we are calling the <kbd>rpc.HandleHTTP</kbd> method, this is a requirement using HTTP with RPC as it will register the HTTP handlers we mentioned earlier with the <kbd>DefaultServer</kbd> method. We then call the <kbd>http.Serve</kbd> method and pass it the listener we are creating in line <strong>27</strong>, we are setting the second parameter to be <kbd>nil</kbd> as we wish to use the <kbd>DefaultServer</kbd> method. This is exactly the same method that we looked at in the previous examples when we were looking at RESTful endpoints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON-RPC over HTTP</h1>
                </header>
            
            <article>
                
<p>In this last example, we will look at the <kbd>net/rpc/jsonrpc</kbd> package that provides a built-in codec for serializing and deserializing to the JSON-RPC standard. We will also look at how we can send these responses over HTTP, whilst you may ask why not just use REST, and to some extent I will agree with you, it is an interesting example to be able to see how we can extend the standard framework.</p>
<p>The <kbd>StartServer</kbd> method contains nothing we have not seen before it is the standard <kbd>rpc</kbd> server setup, the main difference is line <strong>42</strong> where instead of starting the RPC server we are starting an <kbd>http</kbd> server and passing the listener to it along with a handler:</p>
<p><kbd>rpc_http_json/server/server.go</kbd></p>
<pre>
33 func StartServer() { <br/>34  helloWorld := new(HelloWorldHandler) <br/>35  rpc.Register(helloWorld) <br/>36 <br/>37  l, err := net.Listen("("tcp",", fmt.Sprintf(":%(":%v",", port)) <br/>38  if err != nil { <br/>39    log.Fatal(fmt.Sprintf("("Unable to listen on given port: %s",", err)) <br/>40  } <br/>41 <br/>42 http.Serve(l, http.HandlerFunc(httpHandler)) <br/>43 } 
</pre>
<p>The handler we are passing to the server is where the magic happens:</p>
<pre>
45 func httpHandler(w http.ResponseWriter, r *http.Request) { <br/>46   serverCodec := jsonrpc.NewServerCodec(&amp;HttpConn{in: r.Body, out: w}) <br/>47   err := rpc.ServeRequest(serverCodec) <br/>48   if err != nil { <br/>49     log.Printf("("Error while serving JSON request: %v",", err) <br/>50   http.Error(w, ""Error while serving JSON request, details have been logged.",.", 500) <br/>51   return <br/>52   } <br/>53 } 
</pre>
<p>In line <strong>46</strong>, we are calling the <kbd>jsonrpc.NewServerCodec</kbd> function and passing to it a type that implements <kbd>io.ReadWriteCloser</kbd>. The <kbd>NewServerCodec</kbd> method returns a type that implements <kbd>rpc.ClientCodec</kbd>, which has the following methods:</p>
<pre>
type ClientCodec interface { <br/>  // WriteRequest must be safe for concurrent use by multiple goroutines. <br/>  WriteRequest(*Request, interface{}) error <br/>  ReadResponseHeader(*Response) error <br/>  ReadResponseBody(interface{}) error <br/><br/>  Close() error <br/>} 
</pre>
<p>A <kbd>ClientCodec</kbd> type implements the writing of RPC request and reading RPC responses. To write a request to the connection a client calls the <kbd>WriteRequest</kbd> method. To read the response, the client must call <kbd>ReadResponseHeader</kbd> and <kbd>ReadResponseBody</kbd> as a pair. Once the body has been read, it is the client's responsibility to call the <kbd>Close</kbd> method to close the connection. If a nil interface is passed to <kbd>ReadResponseBody</kbd> then the body of the response should be read and then discarded:</p>
<pre>
17 type HttpConn struct { <br/>18   in  io.Reader <br/>19   out io.Writer <br/>20 } <br/>21 <br/>22 func (c *HttpConn) Read(p []byte) (n int, err error)  { return c.in.Read(p) } <br/>23 func (c *HttpConn) Write(d []byte) (n int, err error) { return c.out.Write(d) } <br/>24 func (c *HttpConn) Close() error                      { return nil } 
</pre>
<p>The <kbd>NewServerCodec</kbd> method requires that we pass it a type that implements the <kbd>ReadWriteCloser</kbd> interface. As we do not have such a type passed to us as parameters in the <kbd>httpHandler</kbd> method we have defined our own type, <kbd>HttpConn</kbd>, which encapsulates the <kbd>http.Request</kbd> body, which implements <kbd>io.Reader</kbd>, and the <kbd>ResponseWriter</kbd> method, that implements <kbd>io.Writer</kbd>. We can then write our own methods that proxy the calls to the reader and writer creating a type that has the correct interface.</p>
<p>And that is it for our short intro to RPC with the standard libraries; we will see when we look at some frameworks more in depth in <a href="cfab2776-305a-417c-853f-26e4caba67d2.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Introducing Docker</em>, how these can be used to build a production microservice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>That's it for this chapter, we have just written our first microservice in Go and only using the standard library, you should now have an appreciation of just how powerful the standard library is providing us with many of the features we need to write RESTful and RPC-based microservices. We have also looked at encoding and decoding data using the <kbd>encoding/json</kbd> package and how we can create light weight messaging by using <kbd>gobs</kbd>.</p>
<p>As you progress through this book, you will see how the many, wonderful open source packages build on these foundations to make Go such a fantastic language for microservice development, and by the end of the book you will have all the knowledge required for successfully building microservices in Go.</p>


            </article>

            
        </section>
    </body></html>