- en: Introduction to Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we are going to look at how easy it is to create a simple web server
    with a single endpoint using the `net/http` package. Then, we will move on to
    examine the `encoding/json` package to see just how easy Go makes it for us to
    use JSON objects for our requests and our responses. Finally, we will look at
    how routing and handlers work and how we can manage context between these handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple web server with net/http
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package provides all the features we need to write HTTP clients
    and servers. It gives us the capability to send requests to other servers communicating
    using the HTTP protocol as well as the ability to run a HTTP server that can route
    requests to separate Go funcs, serve static files, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: To begin we should ask the question, *what technical book would be complete
    without a simple hello world example?* I say none and this is exactly where we
    will begin.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to create an HTTP server with a single endpoint
    that returns static text represented by the JSON standard, this will introduce
    the basic functions of the HTTP server and handlers. We will then modify this
    endpoint to accept a request that is encoded in JSON and using the `encoding/json`
    package return a response to the client. We will also examine how the routing
    works by adding a second endpoint that returns a simple image.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a fundamental grasp of the basic packages
    and how you can use them to quickly and efficiently build a simple microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Building a web server in Go is incredibly easy thanks to the HTTP package, which
    is distributed as part of the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: It has everything you need to manage routing, dealing with **Transport Layer
    Security** (**TLS**), which we will cover in [Chapter 8](d38f7017-1c2e-4a12-b1dc-5870121afd4e.xhtml),
    *Security*, support for HTTP/2 out of the box, and the capability to run an incredibly
    efficient server that can deal with a huge number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found on GitHub at [http://github.com/building-microservices-with-go/chapter1.git](http://github.com/building-microservices-with-go/chapter1.git),
    all the examples in this and subsequent chapters will reference the source extensively
    so if you have not already done so, go and clone this repo before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the syntax for creating a basic server then we can walk through
    the packages in more depth:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1.0 `basic_http_example/basic_http_example.go`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we are doing is calling the `HandleFunc` method on the `http`
    package. The `HandleFunc` method creates a `Handler` type on the `DefaultServeMux`
    handler, mapping the path passed in the first parameter to the function in the
    second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In line **15** we start the HTTP server, `ListenAndServe` takes two parameters,
    the TCP network address to bind the server to and the handler that will be used
    to route requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we are passing the network address `:8080"` this means we would
    like to bind the server to all available IP addresses on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter we are passing is `nil`, this is because we are using the
    `DefaultServeMux` handler, which we are setting up with our call to `http.HandleFunc`.
    In [Chapter 3](cfab2776-305a-417c-853f-26e4caba67d2.xhtml), *Introducing Docker*,
    you will see the use of this second parameter when we introduce more sophisticated
    routers, but for now we can ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: If the `ListenAndServe` function fails to start a server it will return an error,
    the most common reason for this is that you may be trying to bind to a port that
    is already in use on the server. In our example, we are passing the output of
    `ListenAndServe` straight to `log.Fatal(error)`, which is a convenience function
    equivalent to calling `fmt.Print(a ...interface{})` followed by a call to `os.Exit(1)`.
    Since `ListenAndServe` blocks if the server starts correctly we will never exit
    on a successful start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly run and test our new server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the application output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What if you do not see the preceding output and instead see something like the
    following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Take another look at the signature of `ListenAndServe` and the way we are calling
    it. Remember what we were saying about why we were using `log.Fatal`?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do get this error message it means that you are already running an application
    on your computer that is using port `8080`, this could be another instance of
    your program or it could be another application. You can check that you do not
    have another instance running by checking the running processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you do see another `go run ./basic_http_example.go` then you can simply kill
    it and retry. If you do not have another instance running, then you probably have
    some other software that is bound to this port. Try changing the port on line
    **10** and restart your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the server, open a new browser and type in the URI `http://127.0.0.1:8080/helloworld`
    and if things are working correctly you should see the following response from
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, that's the first step into microservice mastery. Now that we
    have our first program running, let's take a closer look at how we can return
    and accept JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the `encoding /json` package, which is built into the standard library
    encoding and decoding JSON to and from Go types is both fast and easy. It implements
    the simplistic `Marshal` and `Unmarshal` functions; however, if we need them,
    the package also provides `Encoder` and `Decoder` types that allow us greater
    control when reading and writing streams of JSON data. In this section, we are
    going to examine both of these approaches, but first let's take a look at how
    simple it is to convert a standard Go `struct` into its corresponding JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling Go structs to JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To encode JSON data, the `encoding/json` package provides the `Marshal` function,
    which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function takes one parameter, which is of type `interface`, so pretty much
    any object you can think of since `interface` represents any type in Go. It returns
    a tuple of `([]byte, error)`, you will see this return style quite frequently
    in Go, some languages implement a try catch approach that encourages an error
    to be thrown when an operation cannot be performed, Go suggests the pattern `(return
    type, error)`, where the error is `nil` when an operation succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, unhandled errors are a bad thing, and whilst the language does implement
    `Panic` and `Recover`, which resemble exception handling in other languages, the
    situations where you should use these are quite different (see *The Go Programming
    Language*, Kernaghan). In Go, the `panic` function causes normal execution to
    stop and all deferred function calls in the Go routine are executed, the program
    will then crash with a log message. It is generally used for unexpected errors
    that indicate a bug in the code and good robust Go code will attempt to handle
    these runtime exceptions and return a detailed `error` object back to the calling
    function.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is exactly what is implemented with the `Marshal` function. In
    the instance that `Marshal` cannot create a JSON encoded byte array from the given
    object, which could be due to a runtime panic, then this is captured and an error
    object detailing the problem is returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try this out, expanding on our existing example, instead of simply printing
    a string from our handler, let's create a simple `struct` for the response and
    return this instead.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1.1 `reading_writing_json_1/reading_writing_json_1.go`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our handler, we will create an instance of this object, set the message,
    then use the `Marshal` function to encode it to a string before returning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what that will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run our program again and refresh our browser, we see the following
    output rendered in valid JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is awesome; however, the default behavior of `Marshal` is to take the literal
    name of the field and use this as the field in the JSON output. What if I prefer
    to use camel case and would rather see "message", could we just rename the field
    in the `helloWorldResponse` struct?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately we can't, as in Go, lowercase properties are not exported, `Marshal`
    will ignore these and will not include them in the output.
  prefs: []
  type: TYPE_NORMAL
- en: All is not lost as the `encoding/json` package implements `struct` field attributes
    that allow us to change the output for the property to anything we choose.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1.2 `reading_writing_json_2/reading_writing_json_2.go`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `struct` field''s tags, we can have greater control of how the output
    will look. In the preceding example, when we marshal this `struct` the output
    from our server would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we want, but we can use field tags to control the output
    even further. We can convert object types and even ignore a field altogether if
    we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Channel, complex types, and functions cannot be encoded in JSON; attempting
    to encode these types will result in an `UnsupportedTypeError` being returned
    by the `Marshal` function.
  prefs: []
  type: TYPE_NORMAL
- en: It also can't represent cyclic data structures; if your `stuct` contains a circular
    reference then `Marshal` will result in an infinite recursion, which is never
    a good thing for a web request.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to export our JSON prettily formatted with indentation, we can use
    the `MarshallIndent` function, this allows you to pass an additional parameter
    of `string` to specify what you would like the indent to be. Two spaces right,
    not a tab?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The astute reader might have noticed that we are decoding our `struct` into
    a byte array and then writing that to the response stream, this does not seem
    to be particularly efficient and in fact it is not. Go provides `Encoders` and
    `Decoders`, which can write directly to a stream, since we already have a stream
    with the `ResponseWriter` then let's do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do, I think we need to look at the `ResponseWriter` a little to see
    what is going on there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ResponseWriter` is an interface that defines three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a `ResponseWriter` interface, how can we use this with `fmt.Fprint(w
    io.Writer, a ...interface{})`? This method requires a `Writer` interface as a
    parameter and we have a `ResponseWriter` interface. If we look at the signature
    for `Writer` we can see that it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because the `ResponseWriter` interface implements this method, it also satisfies
    the interface `Writer` and therefore any object that implements `ResponseWriter`
    can be passed to any function that expects `Writer`.
  prefs: []
  type: TYPE_NORMAL
- en: Amazing, Go rocks, but we have not answered our question, *Is there any better
    way to send our data to the output stream without marshalling to a temporary object
    before we return it?*
  prefs: []
  type: TYPE_NORMAL
- en: 'The `encoding/json` package has a function called `NewEncoder` this returns
    us an `Encoder` object that can be used to write JSON straight to an open writer
    and guess what; we have one of those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So instead of storing the output of `Marshal` into a byte array, we can write
    it straight to the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1.3 `reading_writing_json_3/reading_writing_json_3.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will look at benchmarking in a later chapter, but to see why this is important
    we have created a simple benchmark to check the two methods against each other,
    have a look at the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1.4 `reading_writing_json_2/reading_writing_json_2.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using `Encoder` rather than marshalling to a byte array is nearly 50% faster.
    We are dealing with nanoseconds here so that time may seem irrelevant, but it
    isn't; this was two lines of code. If you have that level of inefficiency throughout
    the rest of your code then your application will run slower, you will need more
    hardware to satisfy the load and that will cost you money. There is nothing clever
    in the differences between the two methods all we have done is understood how
    the standard packages work and chosen the correct option for our requirements,
    that is not performance tuning, that is understanding the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Unmarshalling JSON to Go structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have learned how we can send JSON back to the client, what if we need
    to read input before returning the output? We could use URL parameters and we
    will see what that is all about in the next chapter, but commonly you will need
    more complex data structures that involve the service to accept JSON as part of
    an HTTP `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying similar techniques that we learned in the previous section to write
    JSON, reading JSON is just as easy. To decode JSON into a `stuct` field the `encoding/json`
    package provides us with the `Unmarshal` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Unmarshal` function works in the opposite way to `Marshal`; it allocates
    maps, slices, and pointers as required. Incoming object keys are matched using
    either the `struct` field name or its tag and will work with a case-insensitive
    match; however, an exact match is preferred. Like `Marshal`, `Unmarshal` will
    only set exported `struct` fields, those that start with an upper-case letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding a new `struct` field to represent the request, whilst `Unmarshal`
    can decode the JSON into an `interface{}`, which would be of `map[string]interface{}
    // for JSON objects type` or: `[]interface{} // for JSON arrays`, depending if
    our JSON is an object or an array.'
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion it is much clearer to the readers of our code if we explicitly
    state what we are expecting as a request. We can also save ourselves work by not
    having to manually cast the data when we come to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember two things:'
  prefs: []
  type: TYPE_NORMAL
- en: You do not write code for the compiler, you write code for humans to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will spend more time reading code than you do writing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking these two points into account we create a simple `struct` to represent
    our request, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1.5 `reading_writing_json_4/reading_writing_json_4.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we are going to use `struct` field tags as whilst we could let `Unmarshal`
    do case-insensitive matching so `{"name": "World}` would correctly unmarshal into
    the `struct` the same as `{"Name": "World"}`, when we specify a tag we are being
    explicit about the request form and that is a good thing. In terms of speed and
    performance it is also about 10% faster, and remember, performance matters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the JSON sent with the request we need to take a look at the `http.Request`
    object passed to our handler. The following listing does not show all the methods
    on the request, just the ones we are going to be immediately dealing with, for
    full documentation I recommend checking out the documentation at [https://godoc.org/net/http#Request](https://godoc.org/net/http#Request):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON that has been sent with the request is accessible in the `Body` field.
    Body implements the interface `io.ReadCloser` as a stream and does not return
    a `[]byte` or a `string`. If we need the data contained in the body, we can simply
    read it into a byte array, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here is something we'll need to remember. We are not calling `Body.Close()`,
    if we were making a call with a client we would need to do this as it is not automatically
    closed, however, when used in a `ServeHTTP` handler, the server automatically
    closes the request stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this all works inside our handler, we can look at the following
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this example and see how it works. To test, we can simply use the
    `curl` command to send a request to the running server. If you feel more comfortable
    using a GUI tool than Postman (which is available for the Google Chrome browser),
    they will work just fine or feel free to use your preferred tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What do you think will happen if you do not include a body with your request?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you guessed correctly, that you would get a `HTTP status 400 Bad Request`,
    then you win a prize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Errors reply to the request with the given message and status code. Once we
    have sent this, we need to return stopping further execution of the function as
    this does not close the `ResponseWriter` interface and return flow to the calling
    function automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Just before you think you are done, have a go and see if you can improve the
    performance of the handler. Think about the things we were talking about when
    marshaling JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Got it?
  prefs: []
  type: TYPE_NORMAL
- en: Well if not here is the answer, again all we are doing is using the `Decoder`,
    which is the opposite of the `Encoder` that we used in writing JSON. It has an
    instant 33% performance increase and less code too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1.6 `reading_writing_json_5/reading_writing_json_5.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see just how easy it is to encode and decode JSON with Go, I would
    recommend taking five minutes now to spend some time digging through the documentation
    for the `encoding/json` package ([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))
    as there is a whole lot more that you can do with this.
  prefs: []
  type: TYPE_NORMAL
- en: Routing in net/http
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even a simple microservice will need the capability to route requests to different
    handlers dependent on the requested path or method. In Go this is handled by the
    `DefaultServeMux` method which is an instance of `ServerMux`. Earlier in this
    chapter, we briefly covered that when nil is passed to the handler parameter for
    the `ListenAndServe` function then the `DefaultServeMux` method is used. When
    we call the `http.HandleFunc("/helloworld", helloWorldHandler)` package function
    we are actually just indirectly calling `http.DefaultServerMux.HandleFunc(…)`.
  prefs: []
  type: TYPE_NORMAL
- en: The Go HTTP server does not have a specific router instead any object which
    implements the `http.Handler` interface is passed as a top level function to the
    `Listen()` function, when a request comes into the server the `ServeHTTP` method
    of this handler is called and it is responsible for performing or delegating any
    work. To facilitate the handling of multiple routes the HTTP package has a special
    object called `ServerMux`, which implements the `http.Handler` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions to adding handlers to a `ServerMux` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `HandleFunc` function is a convenience function that creates a handler who's
    `ServeHTTP` method calls an ordinary function with the `func(ResponseWriter, *Request)`
    signature that you pass as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Handle` function requires that you pass two parameters, the pattern that
    you would like to register the handler and an object that implements the `Handler`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already explained how `ServeMux` is responsible for routing inbound requests
    to the registered handlers, however the way that the routes are matched can be
    quite confusing. The `ServeMux` handler has a very simple routing model it does
    not support wildcards or regular expressions, with `ServeMux` you must be explicit
    about the registered paths.
  prefs: []
  type: TYPE_NORMAL
- en: You can register both fixed rooted paths, such as `/images/cat.jpg`, or rooted
    subtrees such as `/images/`. The trailing slash in the rooted subtree is important
    as any request that starts with `/images/`, for example `/images/happy_cat.jpg`,
    would be routed to the handler associated with `/images/`.
  prefs: []
  type: TYPE_NORMAL
- en: If we register a path `/images/` to the handler foo, and the user makes a request
    to our service at `/images` (note no trailing slash), then `ServerMux` will forward
    the request to the `/images/` handler, appending a trailing slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we also register the path `/images` (note no trailing slash) to the handler
    bar and the user requests `/images` then this request will be directed to bar;
    however, `/images/` or `/images/cat.jpg` will be directed to foo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Longer paths will always take precedence over shorter ones so it is possible
    to have an explicit route that points to a different handler to a catch all route.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify the hostname, we could register a path such as `search.google.com/`
    and `/ServerMux` would forward any requests to `http://search.google.com` and
    `http://www.google.com` to their respective handlers.
  prefs: []
  type: TYPE_NORMAL
- en: If you are used to a framework based application development approach such as
    using Ruby on Rails or ExpressJS you may find this router incredibly simple and
    it is, remember that we are not using a framework but the standard packages of
    Go, the intention is always to provide a basis that can be built upon. In very
    simple cases the `ServeMux` approach more than good enough and in fact I personally
    don't use anything else. Everyone's needs are different however and the beauty
    and simplicity of the standard packages makes it incredibly simple to build your
    own route as all is needed is an object which implements the `Handler` interface.
    A quick trawl through google will surface some very good third party routers but
    my recommendation for you is to learn the limitations of `ServeMux` first before
    deciding to choose a third-party package it will greatly help with your decision
    process as you will know the problem you are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package implements several methods that create different types
    of convenience handlers, let's examine these.
  prefs: []
  type: TYPE_NORMAL
- en: FileServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `FileServer` function returns a handler that serves HTTP requests with the
    contents of the filesystem. This can be used to serve static files such as images
    or other content that is stored on the file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to map the contents of the file system path `./images` to the
    server route `/images`, `Dir` implements a file system which is restricted to
    a specific directory tree, the `FileServer` method uses this to be able to serve
    the assets.
  prefs: []
  type: TYPE_NORMAL
- en: NotFoundHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NotFoundHandler` function returns a simple request handler that replies
    to each request with a `404 page not found reply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: RedirectHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RedirectHandler` function returns a request handler that redirects each
    request it receives to the given URI using the given status code. The provided
    code should be in the 3xx range and is usually `StatusMovedPermanently`, `StatusFound`,
    or `StatusSeeOther`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: StripPrefix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StripPrefix` function returns a handler that serves HTTP requests by removing
    the given prefix from the request URL''s path and then invoking `h` handler. If
    a path does not exist, then `StripPrefix` will reply with an HTTP 404 not found
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: TimeoutHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `TimeoutHandler` function returns a `Handler` interface that runs `h` with
    the given time limit. When we investigate common patterns in [Chapter 6](74445ff8-eb01-4a2f-a910-0551e7d85a5f.xhtml),
    *Microservice Frameworks*, we will see just how useful this can be for avoiding
    cascading failures in your service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The new handler calls `h.ServeHTTP` to handle each request, but if a call runs
    for longer than its time limit, the handler responds with a `503 Service Unavailable`
    response with the given message `(msg)` in its body.
  prefs: []
  type: TYPE_NORMAL
- en: The last two handlers are especially interesting as they are, in effect, chaining
    handlers. This is a technique that we will go into more in-depth in a later chapter
    as it allows you to both practice clean code and also allows you to keep your
    code DRY.
  prefs: []
  type: TYPE_NORMAL
- en: I may have lifted most of the descriptions for these handlers straight from
    the Go documentation and you probably have already read these because you have
    read the documentation right? With Go, the documentation is excellent and writing
    documentation for your own packages is heavily encouraged, even enforced, if you
    use the `golint` command that comes with the standard package then this will report
    areas of your code which do not conform to the standards. I really recommend spending
    a little time browsing the standard docs when you are using one of the packages,
    not only will you learn the correct usage, you may learn that there is a better
    approach. You will certainly be exposed to good practice and style and you may
    even be able to keep working on the sad day that Stack Overflow stops working
    and the entire industry grinds to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: Static file handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whilst we are mostly going to be dealing with APIs in this book, it is a useful
    illustration to see how the default router and paths work by adding a secondary
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: As a little exercise, try to modify the code in `reading_writing_json_5/reading_writing_json_5.go`
    to add an endpoint `/cat`, which returns the cat picture specified in the URI.
    To give you a little hint, you are going to need to use the `FileServer` function
    on the `net/http` package and your URI will look something like `http://localhost:8080/cat/cat.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: Did it work the first time or did you forget to add the `StripPrefix` handler?
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1.7 `reading_writing_json_6/reading_writing_json_6.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are registering a `StripPrefix` handler with our
    path `/cat/`. If we did not do this, then the `FileServer` handler would be looking
    for our image in the `images/cat` directory. It is also worth reminding ourselves
    about the difference with `/cat` and `/cat/` as paths. If we registered our path
    as `/cat` then we would not match `/cat/cat.jpg`. If we register our path as `/cat/`,
    we will match both `/cat` and `/cat/whatever`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now finish off our examples here by showing how you can create a `Handler`
    rather than just using `HandleFunc`. We are going to split the code that performs
    the request validation for our `helloworld` endpoint and the code that returns
    the response out into separate handlers to illustrate how it is possible to chain
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1.8 `chapter1/reading_writing_json_7.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do when creating our own `Handler` is to define a
    `struct` field that will implement the methods in the `Handlers` interface. Since
    in this example, we are going to be chaining handlers together, the first handler,
    which is our validation handler, needs to have a reference to the next in the
    chain as it has the responsibility for calling `ServeHTTP` or returning a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, we have added a function that returns us a new handler; however,
    we could have just set the next field. This method, however, is better form as
    it makes our code a little easier to read and when we need to pass complex dependencies
    to the handler using a function to create, it keeps things a little neater:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code block illustrates how we would implement the `ServeHTTP`
    method. The only interesting thing to note here is the statement that begins at
    line **44**. If an error is returned from decoding the request, we write a 500
    error to the response, the handler chain would stop here. Only when no error is
    returned do we call the next handler in the chain and we do this simply by invoking
    its `ServeHTTP` method. To pass the name decoded from the request, we are simply
    setting a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `helloWorldHandler` type that writes the response does not look too different
    from when we were using a simple function. If you compare this to *example 1.6*,
    you will see that all we really have done is remove the request decoding.
  prefs: []
  type: TYPE_NORMAL
- en: Now the first thing I want to mention about this code is that it is purely to
    illustrate how you can do something, not that you should do something. In this
    simple case, splitting the request validation and response sending into two handlers
    adds a lot of needless complexity and it is not really making our code DRYer.
    The technique, however, is useful. When we examine authentication in a later chapter,
    you will see this pattern as it allows us to centralize our authentication logic
    and share it among handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with the previous pattern is that there is no way that you can pass
    the validated request from one handler to the next without breaking the `http.Handler`
    interface, but guess what Go has us covered. The context package was listed as
    experimental for several years before finally making it in to the standard package
    with Go 1.7\. The `Context` type implements a safe method for accessing request-scoped
    data that is safe to use simultaneously by multiple Go routines. Let’s take a
    quick look at this package and then update our example to see it in use.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Background` method returns an empty context that has no values; it is
    typically used by the main function and as the top-level `Context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: WithCancel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WithCancel` method returns a copy of the parent context with a cancel
    function, calling the cancel function releases resources associated with the context
    and should be called as soon as operations running in the `Context` type are complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: WithDeadline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WithDeadline` method returns a copy of the parent context that expires
    after the current time is greater than deadline. At this point, the context''s
    `Done` channel is closed and the resources associated are released. It also passes
    back a `CancelFunc` method that allows manual cancellation of the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: WithTimeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WithTimeout` method is similar to `WithDeadline` except you pass it a
    duration for which the `Context` type should exist. Once this duration has elapsed,
    the `Done` channel is closed and the resources associated with the context are
    released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: WithValue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WithValue` method returns a copy of the parent `Context` in which the
    `val` value is associated with the key. The `Context` values are perfect to be
    used for request-scoped data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Why not attempt to modify *example 1.7* to implement a request scoped context.
    The key could be in the previous sentence; every request needs its own context.
  prefs: []
  type: TYPE_NORMAL
- en: Using contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably found that rather painful, especially if you come from a background
    in a framework such as Rails or Spring. Writing this kind of code is not really
    something you want to be spending your time on, building application features
    is far more important. One thing to note however is that neither Ruby or Java
    have anything more advanced in their base packages. Thankfully for us, over the
    seven years that Go has been in existence, many excellent people have done just
    that, and when looking at frameworks in [Chapter 3](cfab2776-305a-417c-853f-26e4caba67d2.xhtml),
    *Introducing Docker*, we will find that all of this complexity has been taken
    care of by some awesome open source authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the adoption of context into the main Go release version 1.7
    implements an important update on the `http.Request` structure, we have the following
    additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Context()` method gives us access to a `context.Context` structure which
    is always non nil as it is populated when the request is originally created. For
    inbound requests the `http.Server` manages the lifecycle of the context automatically
    cancelling it when the client connection closes. For outbound requests, `Context`
    controls cancellation, by this we mean that if we cancel the `Context()` method
    we can cancel the outgoing request. This concept is illustrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In line **74**, we are creating a timeout context from the original in the request,
    and unlike an inbound request where the context is automatically cancelled for
    you we must manually perform this step in an outbound request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line **77** implements the second of the two new context methods which have
    been added to the `http.Request` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `WithContext` object returns a shallow copy of the original request which
    has the context changed to the given `ctx` context.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute this function we will find that after 1 millisecond the request
    will complete with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The context is timing out before the request has a change to complete and the
    do method immediately returns. This is an excellent technique to use for outbound
    connections and thanks to the changes in Go 1.7 is now incredibly easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about our inbound connection Let’s see how we can update our previous
    example. Example 1.9 updates our example to show how we can leverage the `context`
    package to implement Go routine safe access to objects. The full example can be
    found in `reading_writing_json_8/reading_writing_json_8.go` but all of the modification
    we need to make are in the two `ServeHTTP` methods for our handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a quick look at our `validationHandler` you will see that when we
    have a valid request, we are creating a new context for this request and then
    setting the value of the `Name` field in the request into the context. You might
    also wonder what is going on with line **51**. When you add an item to a context
    such as with the `WithValue` call, the method returns a copy of the previous context,
    to save a little time and add a little confusion, we are holding a pointer to
    the context, so in order to pass this as a copy to `WithValue`, we must dereference
    it. To update our pointer, we must also set the returned value to the value referenced
    by the pointer hence again we need to dereference it. The other think we need
    to look at with this method call is the key, we are using `validationContextKey`
    this is an explicitly declared type of string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we are not just using a simple string is that context often flows
    across packages and if we just used string then we could end up with a key clash
    where one package within your control is writing a `name` key and another package
    which is outside of your control is also using the context and writing a key called
    `name`, in this instance the second package would inadvertently overwrite your
    context value. By declaring a package level type `validationContextKey` and using
    this we can ensure that we avoid these collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve the value, all we have to do is obtain the context and then call
    the `Value` method casting it into a string.
  prefs: []
  type: TYPE_NORMAL
- en: RPC in the Go standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As expected, the Go standard library has fantastic support for RPC right out-of-the-box.
    Let's look at a few examples of how we can use this.
  prefs: []
  type: TYPE_NORMAL
- en: Simple RPC example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this simple example, we will see how we can use the standard RPC package
    to create a client and server that use a shared interface to communicate over
    RPC. We will follow the typical Hello World example that we ran through when learning
    the `net/http` package and see just how easy it is to build an RPC-based API in
    go:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rpc/server/server.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Like our example on creating REST APIs using the standard library for RPC,
    we will also define a handler. The difference between this handler and `http.Handler`
    is that it does not need to conform to an interface; as long as we have a `struct`
    field with methods on it we can register this with the RPC server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Register` function, which is in the `rpc` package, publishes the methods
    that are part of the given interface to the default server and allows them to
    be called by clients connecting to the service. The name of the method uses the
    name of the concrete type, so in our instance if my client wanted to call the
    `HelloWorld` method, we would access it using `HelloWorldHandler.HelloWorld`.
    If we do not wish to use the concrete types name, we can register it with a different
    name using the `RegisterName` function, which uses the provided name instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This would enable me to keep the name of the `struct` field to whatever is
    meaningful to my code; however, for my client contract I might decide to use something
    different such as `Greet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the `StartServer` function, we first create a new instance of our handler
    and then we register this with the default RPC server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the convenience of `net/http` where we can just create a server with
    `ListenAndServe`, when we are using RPC we need to do a little more manual work.
    In line **23**, we are creating a socket using the given protocol and binding
    it to the IP address and port. This gives us the capability to specifically select
    the protocol we would like to use for the server, `tcp`, `tcp4`, `tcp6`, `unix`,
    or `unixpacket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Listen()` function returns an instance that implements the `Listener`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive connections, we must call the `Accept` method on the listener. If
    you look at line **29**, you will see that we have an endless for loop, this is
    because unlike `ListenAndServe` which blocks for all connections, with an RPC
    server we handle each connection individually and as soon as we deal with the
    first connection we need to continue to again call `Accept` to handle subsequent
    connections or the application would exit. Accept is a blocking method so if there
    are no clients currently attempting to connect to the service then `Accept` will
    block until one does. Once we receive a connection then we need to call the `Accept`
    method again to process the next connection. If you look at line **30** in our
    example code, you will see we are calling the `ServeConn` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `ServeConn` method runs the `DefaultServer` method on the given connection,
    and will block until the client completes. In our example, we are using the go
    statement before running the server so that we can immediately process the next
    waiting connection without blocking for the first client to close its connection.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of communication protocol, `ServeConn` uses the `gob` wire format [https://golang.org/pkg/encoding/gob/](https://golang.org/pkg/encoding/gob/),
    we will see when we look at JSON-RPC how we can use a different encoding.
  prefs: []
  type: TYPE_NORMAL
- en: The `gob` format was specifically designed to facilitate Go to Go-based communication
    and was designed around the idea of something easier to use and possibly more
    efficient than the likes of protocol buffers, this comes at a cost of cross language
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: With gobs, the source and destination values and types do not need to correspond
    exactly, when you send `struct`, if a field is in the source but not in the receiving
    `struct`, then the decoder will ignore this field and the processing will continue
    without error. If a field is present in the destination that is not in the source,
    then again the decoder will ignore this field and will successfully process the
    rest of the message. Whilst this seems like a minor benefit, it is a huge advancement
    over the RPC messages of old such as JMI where the exact same interface must be
    present on both the client and server. This level of inflexibility with JMI introduced
    tight coupling between the two code bases and caused no end of complexity when
    it was required to deploy an update to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a request to our client we can no longer simply use curl as we are
    no longer are using the HTTP protocol and the message format is no longer JSON.
    If we look at the example in `rpc/client/client.go` we can see how to implement
    a connecting client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous block shows how we need to setup `rpc.Client`, the first thing
    we need to do on line **14** is to create the client itself using the `Dial()`
    function in the `rpc` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use this returned connection to make a request to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In line **26**, we are using the `Call()` method on the client to invoke the
    named function on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`Call` is a blocking function which waits until the server sends a reply writing
    the response assuming there is no error to the reference of our `HelloWorldResponse`
    passed to the method and if an error occurs when processing the request this is
    returned and can be handled accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: RPC over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the instance that you need to use HTTP as your transport protocol then the
    `rpc` package can facilitate this by calling the `HandleHTTP` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HandleHTTP` method sets up two endpoints in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you point your browser at the `DefaultDebugPath` you can see details for
    the registered endpoints, there are two things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean you can communicate easily with your API from a web browser.
    The messages are still `gob` encoded so you would need to write a gob encoder
    and decoder in JavaScript, which I am not actually sure is possible. It was certainly
    never the intent of the package to support this capability and therefore I would
    not advise this action, a JSON or JSON-RPC based message is much better suited
    to this use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debug endpoint is not going to provide you with auto-generated documentation
    for your API. The output is fairly basic and the intention seems to be so you
    can track the number of calls made to an endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All that said there may be a reason why you need to use HTTP, possibly your
    network does not allow any other protocol or potentially you have a load balancer
    that is not capable of dealing with pure TCP connections. We can also take advantage
    of HTTP headers and other metadata which is not available using a pure TCP request.
  prefs: []
  type: TYPE_NORMAL
- en: '`rpc_http/server/server.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If we look at line **25**, in the preceding example, we can see we are calling
    the `rpc.HandleHTTP` method, this is a requirement using HTTP with RPC as it will
    register the HTTP handlers we mentioned earlier with the `DefaultServer` method.
    We then call the `http.Serve` method and pass it the listener we are creating
    in line **27**, we are setting the second parameter to be `nil` as we wish to
    use the `DefaultServer` method. This is exactly the same method that we looked
    at in the previous examples when we were looking at RESTful endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last example, we will look at the `net/rpc/jsonrpc` package that provides
    a built-in codec for serializing and deserializing to the JSON-RPC standard. We
    will also look at how we can send these responses over HTTP, whilst you may ask
    why not just use REST, and to some extent I will agree with you, it is an interesting
    example to be able to see how we can extend the standard framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StartServer` method contains nothing we have not seen before it is the
    standard `rpc` server setup, the main difference is line **42** where instead
    of starting the RPC server we are starting an `http` server and passing the listener
    to it along with a handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rpc_http_json/server/server.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler we are passing to the server is where the magic happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In line **46**, we are calling the `jsonrpc.NewServerCodec` function and passing
    to it a type that implements `io.ReadWriteCloser`. The `NewServerCodec` method
    returns a type that implements `rpc.ClientCodec`, which has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ClientCodec` type implements the writing of RPC request and reading RPC
    responses. To write a request to the connection a client calls the `WriteRequest`
    method. To read the response, the client must call `ReadResponseHeader` and `ReadResponseBody`
    as a pair. Once the body has been read, it is the client''s responsibility to
    call the `Close` method to close the connection. If a nil interface is passed
    to `ReadResponseBody` then the body of the response should be read and then discarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `NewServerCodec` method requires that we pass it a type that implements
    the `ReadWriteCloser` interface. As we do not have such a type passed to us as
    parameters in the `httpHandler` method we have defined our own type, `HttpConn`,
    which encapsulates the `http.Request` body, which implements `io.Reader`, and
    the `ResponseWriter` method, that implements `io.Writer`. We can then write our
    own methods that proxy the calls to the reader and writer creating a type that
    has the correct interface.
  prefs: []
  type: TYPE_NORMAL
- en: And that is it for our short intro to RPC with the standard libraries; we will
    see when we look at some frameworks more in depth in [Chapter 3](cfab2776-305a-417c-853f-26e4caba67d2.xhtml),
    *Introducing Docker*, how these can be used to build a production microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it for this chapter, we have just written our first microservice in Go
    and only using the standard library, you should now have an appreciation of just
    how powerful the standard library is providing us with many of the features we
    need to write RESTful and RPC-based microservices. We have also looked at encoding
    and decoding data using the `encoding/json` package and how we can create light
    weight messaging by using `gobs`.
  prefs: []
  type: TYPE_NORMAL
- en: As you progress through this book, you will see how the many, wonderful open
    source packages build on these foundations to make Go such a fantastic language
    for microservice development, and by the end of the book you will have all the
    knowledge required for successfully building microservices in Go.
  prefs: []
  type: TYPE_NORMAL
