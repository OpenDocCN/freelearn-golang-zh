- en: Introduction to Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: First, we are going to look at how easy it is to create a simple web server
    with a single endpoint using the `net/http` package. Then, we will move on to
    examine the `encoding/json` package to see just how easy Go makes it for us to
    use JSON objects for our requests and our responses. Finally, we will look at
    how routing and handlers work and how we can manage context between these handlers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看如何使用`net/http`包轻松创建一个具有单个端点的简单Web服务器。然后，我们将检查`encoding/json`包，看看Go如何使我们能够轻松地使用JSON对象进行请求和响应。最后，我们将查看路由和处理器的工作方式以及我们如何在这些处理器之间管理上下文。
- en: Building a simple web server with net/http
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用net/http构建简单Web服务器
- en: The `net/http` package provides all the features we need to write HTTP clients
    and servers. It gives us the capability to send requests to other servers communicating
    using the HTTP protocol as well as the ability to run a HTTP server that can route
    requests to separate Go funcs, serve static files, and much more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包提供了我们编写HTTP客户端和服务器所需的所有功能。它使我们能够向使用HTTP协议的其他服务器发送请求，以及运行可以将请求路由到单独的Go函数、提供静态文件以及更多功能的HTTP服务器。'
- en: To begin we should ask the question, *what technical book would be complete
    without a simple hello world example?* I say none and this is exactly where we
    will begin.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该提出一个问题，*没有简单hello world示例的技术书会完整吗？* 我认为没有，这正是我们将开始的地方。
- en: In this example, we are going to create an HTTP server with a single endpoint
    that returns static text represented by the JSON standard, this will introduce
    the basic functions of the HTTP server and handlers. We will then modify this
    endpoint to accept a request that is encoded in JSON and using the `encoding/json`
    package return a response to the client. We will also examine how the routing
    works by adding a second endpoint that returns a simple image.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个具有单个端点的HTTP服务器，该端点返回由JSON标准表示的静态文本，这将介绍HTTP服务器和处理器的基本功能。然后，我们将修改此端点以接受编码为JSON的请求，并使用`encoding/json`包向客户端返回响应。我们还将通过添加第二个端点返回简单图像来检查路由的工作方式。
- en: By the end of this chapter, you will have a fundamental grasp of the basic packages
    and how you can use them to quickly and efficiently build a simple microservice.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将基本掌握基本包及其如何快速高效地构建简单微服务的方法。
- en: Building a web server in Go is incredibly easy thanks to the HTTP package, which
    is distributed as part of the standard library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准库中包含的HTTP包，使用Go构建Web服务器变得极其简单。
- en: It has everything you need to manage routing, dealing with **Transport Layer
    Security** (**TLS**), which we will cover in [Chapter 8](d38f7017-1c2e-4a12-b1dc-5870121afd4e.xhtml),
    *Security*, support for HTTP/2 out of the box, and the capability to run an incredibly
    efficient server that can deal with a huge number of requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它拥有你管理路由、处理**传输层安全性**（**TLS**）（我们将在第8章中介绍），支持HTTP/2开箱即用，以及运行一个处理大量请求的非常高效的服务器的所有功能。
- en: The source code for this chapter can be found on GitHub at [http://github.com/building-microservices-with-go/chapter1.git](http://github.com/building-microservices-with-go/chapter1.git),
    all the examples in this and subsequent chapters will reference the source extensively
    so if you have not already done so, go and clone this repo before continuing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到，网址为[http://github.com/building-microservices-with-go/chapter1.git](http://github.com/building-microservices-with-go/chapter1.git)，本章节和随后的章节将广泛引用这些示例，所以如果你还没有这样做，请在继续之前去克隆这个仓库。
- en: 'Let''s look at the syntax for creating a basic server then we can walk through
    the packages in more depth:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建基本服务器的语法，然后我们可以更深入地了解这些包：
- en: Example 1.0 `basic_http_example/basic_http_example.go`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.0 `basic_http_example/basic_http_example.go`
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing we are doing is calling the `HandleFunc` method on the `http`
    package. The `HandleFunc` method creates a `Handler` type on the `DefaultServeMux`
    handler, mapping the path passed in the first parameter to the function in the
    second parameter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是在`http`包上调用`HandleFunc`方法。`HandleFunc`方法在`DefaultServeMux`处理器上创建一个`Handler`类型，将第一个参数中传入的路径映射到第二个参数中的函数：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In line **15** we start the HTTP server, `ListenAndServe` takes two parameters,
    the TCP network address to bind the server to and the handler that will be used
    to route requests:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**15**行，我们启动HTTP服务器，`ListenAndServe`接受两个参数，将服务器绑定到的TCP网络地址和用于路由请求的处理程序：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our example, we are passing the network address `:8080"` this means we would
    like to bind the server to all available IP addresses on port `8080`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们传递了网络地址 `:8080"`，这意味着我们希望将服务器绑定到所有可用的 IP 地址上的端口 `8080`。
- en: The second parameter we are passing is `nil`, this is because we are using the
    `DefaultServeMux` handler, which we are setting up with our call to `http.HandleFunc`.
    In [Chapter 3](cfab2776-305a-417c-853f-26e4caba67d2.xhtml), *Introducing Docker*,
    you will see the use of this second parameter when we introduce more sophisticated
    routers, but for now we can ignore it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的第二个参数是 `nil`，这是因为我们正在使用 `DefaultServeMux` 处理器，它是通过我们的 `http.HandleFunc`
    调用来设置的。在 [第 3 章](cfab2776-305a-417c-853f-26e4caba67d2.xhtml) *介绍 Docker* 中，你将看到当我们介绍更复杂的路由器时使用这个第二个参数，但现在我们可以忽略它。
- en: If the `ListenAndServe` function fails to start a server it will return an error,
    the most common reason for this is that you may be trying to bind to a port that
    is already in use on the server. In our example, we are passing the output of
    `ListenAndServe` straight to `log.Fatal(error)`, which is a convenience function
    equivalent to calling `fmt.Print(a ...interface{})` followed by a call to `os.Exit(1)`.
    Since `ListenAndServe` blocks if the server starts correctly we will never exit
    on a successful start.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ListenAndServe` 函数无法启动服务器，它将返回一个错误，最常见的原因可能是你正在尝试绑定服务器上已经使用的端口。在我们的例子中，我们将
    `ListenAndServe` 的输出直接传递给 `log.Fatal(error)`，这是一个方便的函数，相当于调用 `fmt.Print(a ...interface{})`
    然后调用 `os.Exit(1)`。由于 `ListenAndServe` 如果服务器启动正确则会阻塞，所以我们永远不会在成功启动时退出。
- en: 'Let''s quickly run and test our new server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行并测试我们的新服务器：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should now see the application output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到应用程序的输出：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What if you do not see the preceding output and instead see something like the
    following?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到前面的输出，而是看到以下内容？
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Take another look at the signature of `ListenAndServe` and the way we are calling
    it. Remember what we were saying about why we were using `log.Fatal`?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看 `ListenAndServe` 的签名和我们调用它的方式。还记得我们之前说的为什么我们使用 `log.Fatal` 吗？
- en: 'If you do get this error message it means that you are already running an application
    on your computer that is using port `8080`, this could be another instance of
    your program or it could be another application. You can check that you do not
    have another instance running by checking the running processes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实收到这个错误消息，这意味着你的电脑上已经运行了一个使用端口 `8080` 的应用程序，这可能是你程序的另一个实例，也可能是另一个应用程序。你可以通过检查正在运行的过程来确认没有其他实例在运行：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you do see another `go run ./basic_http_example.go` then you can simply kill
    it and retry. If you do not have another instance running, then you probably have
    some other software that is bound to this port. Try changing the port on line
    **10** and restart your program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到另一个 `go run ./basic_http_example.go`，你可以简单地将其终止并重试。如果你没有其他实例在运行，那么你可能有一些其他软件绑定到了这个端口。尝试在行
    **10** 上更改端口并重新启动你的程序。
- en: 'To test the server, open a new browser and type in the URI `http://127.0.0.1:8080/helloworld`
    and if things are working correctly you should see the following response from
    the server:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试服务器，打开一个新的浏览器，输入 URI `http://127.0.0.1:8080/helloworld`，如果一切正常，你应该从服务器看到以下响应：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Congratulations, that's the first step into microservice mastery. Now that we
    have our first program running, let's take a closer look at how we can return
    and accept JSON.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，这是进入微服务大师的第一步。现在我们有了第一个运行起来的程序，让我们更仔细地看看我们如何返回和接受 JSON。
- en: Reading and writing JSON
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入 JSON
- en: Thanks to the `encoding /json` package, which is built into the standard library
    encoding and decoding JSON to and from Go types is both fast and easy. It implements
    the simplistic `Marshal` and `Unmarshal` functions; however, if we need them,
    the package also provides `Encoder` and `Decoder` types that allow us greater
    control when reading and writing streams of JSON data. In this section, we are
    going to examine both of these approaches, but first let's take a look at how
    simple it is to convert a standard Go `struct` into its corresponding JSON string.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢内置在标准库中的 `encoding/json` 包，它使得将 JSON 编码和解码为 Go 类型既快速又简单。它实现了简单的 `Marshal`
    和 `Unmarshal` 函数；然而，如果需要的话，该包还提供了 `Encoder` 和 `Decoder` 类型，这让我们在读取和写入 JSON 数据流时有了更大的控制权。在本节中，我们将探讨这两种方法，但首先让我们看看将标准的
    Go `struct` 转换为其对应的 JSON 字符串是多么简单。
- en: Marshalling Go structs to JSON
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Go 结构体序列化为 JSON
- en: 'To encode JSON data, the `encoding/json` package provides the `Marshal` function,
    which has the following signature:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要编码 JSON 数据，`encoding/json` 包提供了 `Marshal` 函数，其签名如下：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function takes one parameter, which is of type `interface`, so pretty much
    any object you can think of since `interface` represents any type in Go. It returns
    a tuple of `([]byte, error)`, you will see this return style quite frequently
    in Go, some languages implement a try catch approach that encourages an error
    to be thrown when an operation cannot be performed, Go suggests the pattern `(return
    type, error)`, where the error is `nil` when an operation succeeds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个参数，其类型为 `interface`，因此在 Go 中，几乎任何你能想到的对象都可以，因为 `interface` 代表了任何类型。它返回一个元组
    `([]byte, error)`，你会在 Go 中经常看到这种返回风格，一些语言实现了 try catch 方法，鼓励在操作无法执行时抛出错误，Go 建议使用
    `(return type, error)` 模式，其中错误为 `nil` 表示操作成功。
- en: In Go, unhandled errors are a bad thing, and whilst the language does implement
    `Panic` and `Recover`, which resemble exception handling in other languages, the
    situations where you should use these are quite different (see *The Go Programming
    Language*, Kernaghan). In Go, the `panic` function causes normal execution to
    stop and all deferred function calls in the Go routine are executed, the program
    will then crash with a log message. It is generally used for unexpected errors
    that indicate a bug in the code and good robust Go code will attempt to handle
    these runtime exceptions and return a detailed `error` object back to the calling
    function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，未处理的错误是坏事，尽管该语言实现了 `Panic` 和 `Recover`，这与其他语言的异常处理类似，但你应该使用这些函数的情况是相当不同的（参见
    *The Go Programming Language*，Kernaghan）。在 Go 中，`panic` 函数会导致正常执行停止，并且执行 Go 线程中所有延迟调用的函数，然后程序会崩溃并显示日志消息。它通常用于指示代码中存在错误的意外错误，良好的健壮的
    Go 代码将尝试处理这些运行时异常，并将详细的 `error` 对象返回给调用函数。
- en: This pattern is exactly what is implemented with the `Marshal` function. In
    the instance that `Marshal` cannot create a JSON encoded byte array from the given
    object, which could be due to a runtime panic, then this is captured and an error
    object detailing the problem is returned to the caller.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式正是使用 `Marshal` 函数实现的。在 `Marshal` 无法从给定的对象创建 JSON 编码的字节数组的情况下，这可能是因为运行时崩溃，那么这个错误会被捕获，并返回一个详细说明问题的错误对象给调用者。
- en: Let's try this out, expanding on our existing example, instead of simply printing
    a string from our handler, let's create a simple `struct` for the response and
    return this instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下，基于我们现有的示例进行扩展，而不是简单地从我们的处理器中打印一个字符串，让我们创建一个简单的 `struct` 用于响应，并返回这个 `struct`。
- en: Example 1.1 `reading_writing_json_1/reading_writing_json_1.go`
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.1 `reading_writing_json_1/reading_writing_json_1.go`
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our handler, we will create an instance of this object, set the message,
    then use the `Marshal` function to encode it to a string before returning.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的处理器中，我们将创建这个对象的实例，设置消息，然后使用 `Marshal` 函数将其编码为字符串后再返回。
- en: 'Let''s see what that will look like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它会是什么样子：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we run our program again and refresh our browser, we see the following
    output rendered in valid JSON:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行我们的程序并刷新浏览器时，我们会看到以下输出以有效的 JSON 格式渲染：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is awesome; however, the default behavior of `Marshal` is to take the literal
    name of the field and use this as the field in the JSON output. What if I prefer
    to use camel case and would rather see "message", could we just rename the field
    in the `helloWorldResponse` struct?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒；然而，`Marshal` 的默认行为是取字段的字面名称并将其用作 JSON 输出中的字段。如果我想使用驼峰命名法，并希望看到 "message"，我们能否在
    `helloWorldResponse` `struct` 中重命名字段？
- en: Unfortunately we can't, as in Go, lowercase properties are not exported, `Marshal`
    will ignore these and will not include them in the output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不能这样做，因为在 Go 中，小写属性不是导出的，`Marshal` 会忽略这些属性，并且不会将它们包含在输出中。
- en: All is not lost as the `encoding/json` package implements `struct` field attributes
    that allow us to change the output for the property to anything we choose.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，`encoding/json` 包实现了 `struct` 字段属性，允许我们将属性输出更改为我们选择的任何内容。
- en: Example 1.2 `reading_writing_json_2/reading_writing_json_2.go`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.2 `reading_writing_json_2/reading_writing_json_2.go`
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the `struct` field''s tags, we can have greater control of how the output
    will look. In the preceding example, when we marshal this `struct` the output
    from our server would be:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `struct` 字段的标签，我们可以更好地控制输出格式。在前面的示例中，当我们对 `struct` 进行编码时，服务器的输出会是：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is exactly what we want, but we can use field tags to control the output
    even further. We can convert object types and even ignore a field altogether if
    we need to:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的，但我们可以使用字段标签来进一步控制输出。我们可以转换对象类型，甚至如果我们需要的话，可以完全忽略一个字段：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Channel, complex types, and functions cannot be encoded in JSON; attempting
    to encode these types will result in an `UnsupportedTypeError` being returned
    by the `Marshal` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通道、复杂数据类型和函数不能被编码成 JSON；尝试编码这些类型将会导致`Marshal`函数返回一个`UnsupportedTypeError`。
- en: It also can't represent cyclic data structures; if your `stuct` contains a circular
    reference then `Marshal` will result in an infinite recursion, which is never
    a good thing for a web request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它也不能表示循环数据结构；如果你的`struct`包含循环引用，那么`Marshal`将导致无限递归，这对网络请求来说绝不是好事。
- en: If we want to export our JSON prettily formatted with indentation, we can use
    the `MarshallIndent` function, this allows you to pass an additional parameter
    of `string` to specify what you would like the indent to be. Two spaces right,
    not a tab?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要以缩进格式导出我们的 JSON，我们可以使用`MarshallIndent`函数，这允许你传递一个额外的`string`参数来指定你想要的缩进。右对齐两个空格，不是制表符吗？
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The astute reader might have noticed that we are decoding our `struct` into
    a byte array and then writing that to the response stream, this does not seem
    to be particularly efficient and in fact it is not. Go provides `Encoders` and
    `Decoders`, which can write directly to a stream, since we already have a stream
    with the `ResponseWriter` then let's do just that.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 精明的读者可能已经注意到，我们在将我们的`struct`解码成字节数组，然后将它写入响应流中，这似乎并不特别高效，实际上确实如此。Go 提供了`Encoders`和`Decoders`，它们可以直接写入流，因为我们已经有了带有`ResponseWriter`的流，那么我们就这么做吧。
- en: Before we do, I think we need to look at the `ResponseWriter` a little to see
    what is going on there.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这么做之前，我认为我们需要稍微看看一下`ResponseWriter`，看看那里发生了什么。
- en: 'The `ResponseWriter` is an interface that defines three methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseWriter`是一个定义了三个方法的接口：'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we have a `ResponseWriter` interface, how can we use this with `fmt.Fprint(w
    io.Writer, a ...interface{})`? This method requires a `Writer` interface as a
    parameter and we have a `ResponseWriter` interface. If we look at the signature
    for `Writer` we can see that it is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`ResponseWriter`接口，我们如何使用它与`fmt.Fprint(w io.Writer, a ...interface{})`方法一起使用？这个方法需要一个`Writer`接口作为参数，而我们有一个`ResponseWriter`接口。如果我们查看`Writer`的签名，我们可以看到它是：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because the `ResponseWriter` interface implements this method, it also satisfies
    the interface `Writer` and therefore any object that implements `ResponseWriter`
    can be passed to any function that expects `Writer`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`ResponseWriter`接口实现了这个方法，所以它也满足了`Writer`接口，因此任何实现了`ResponseWriter`的对象都可以传递给任何期望`Writer`的函数。
- en: Amazing, Go rocks, but we have not answered our question, *Is there any better
    way to send our data to the output stream without marshalling to a temporary object
    before we return it?*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，Go 真是强大，但我们还没有回答我们的问题，*有没有更好的方法在返回之前不将数据序列化到一个临时对象中，直接发送到输出流？*
- en: 'The `encoding/json` package has a function called `NewEncoder` this returns
    us an `Encoder` object that can be used to write JSON straight to an open writer
    and guess what; we have one of those:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoding/json`包有一个名为`NewEncoder`的函数，这个函数返回一个`Encoder`对象，可以用来将 JSON 直接写入一个打开的写入器，猜猜看；我们就有这样一个：'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So instead of storing the output of `Marshal` into a byte array, we can write
    it straight to the HTTP response.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要将`Marshal`的输出存储到字节数组中，我们可以直接将其写入 HTTP 响应。
- en: 'Example 1.3 `reading_writing_json_3/reading_writing_json_3.go`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.3 `reading_writing_json_3/reading_writing_json_3.go`：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will look at benchmarking in a later chapter, but to see why this is important
    we have created a simple benchmark to check the two methods against each other,
    have a look at the output.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中讨论基准测试，但为了了解为什么这很重要，我们创建了一个简单的基准测试来检查这两种方法之间的差异，看看输出结果。
- en: 'Example 1.4 `reading_writing_json_2/reading_writing_json_2.go`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.4 `reading_writing_json_2/reading_writing_json_2.go`：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using `Encoder` rather than marshalling to a byte array is nearly 50% faster.
    We are dealing with nanoseconds here so that time may seem irrelevant, but it
    isn't; this was two lines of code. If you have that level of inefficiency throughout
    the rest of your code then your application will run slower, you will need more
    hardware to satisfy the load and that will cost you money. There is nothing clever
    in the differences between the two methods all we have done is understood how
    the standard packages work and chosen the correct option for our requirements,
    that is not performance tuning, that is understanding the framework.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Encoder` 而不是将数据序列化到字节数组中几乎快了 50%。我们在这里处理的是纳秒，所以时间可能看起来无关紧要，但事实并非如此；这仅仅是两行代码。如果你在代码的其他部分也有这种低效的情况，那么你的应用程序将运行得更慢，你需要更多的硬件来满足负载，这将花费你金钱。这两种方法之间的差异并没有什么巧妙之处，我们所做的只是理解标准包的工作原理，并为我们自己的需求选择了正确的选项，这并不是性能调优，这是理解框架。
- en: Unmarshalling JSON to Go structs
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 JSON 解码到 Go 结构体
- en: Now we have learned how we can send JSON back to the client, what if we need
    to read input before returning the output? We could use URL parameters and we
    will see what that is all about in the next chapter, but commonly you will need
    more complex data structures that involve the service to accept JSON as part of
    an HTTP `POST` request.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将 JSON 发送回客户端，如果我们需要在返回输出之前读取输入怎么办？我们可以使用 URL 参数，我们将在下一章中看到这一点，但通常你将需要更复杂的数据结构，这些结构涉及服务以接受
    JSON 作为 HTTP `POST` 请求的一部分。
- en: 'Applying similar techniques that we learned in the previous section to write
    JSON, reading JSON is just as easy. To decode JSON into a `stuct` field the `encoding/json`
    package provides us with the `Unmarshal` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们在上一节中学到的类似技术应用于编写 JSON，读取 JSON 也很容易。要将 JSON 解码到 `struct` 字段，`encoding/json`
    包为我们提供了 `Unmarshal` 函数：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Unmarshal` function works in the opposite way to `Marshal`; it allocates
    maps, slices, and pointers as required. Incoming object keys are matched using
    either the `struct` field name or its tag and will work with a case-insensitive
    match; however, an exact match is preferred. Like `Marshal`, `Unmarshal` will
    only set exported `struct` fields, those that start with an upper-case letter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unmarshal` 函数与 `Marshal` 函数的作用相反；它根据需要分配映射、切片和指针。传入的对象键使用 `struct` 字段名或其标签进行匹配，并将进行不区分大小写的匹配；然而，精确匹配是首选。与
    `Marshal` 类似，`Unmarshal` 只会设置导出的 `struct` 字段，即以大写字母开头的字段。'
- en: 'We start by adding a new `struct` field to represent the request, whilst `Unmarshal`
    can decode the JSON into an `interface{}`, which would be of `map[string]interface{}
    // for JSON objects type` or: `[]interface{} // for JSON arrays`, depending if
    our JSON is an object or an array.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个新的 `struct` 字段来表示请求，而 `Unmarshal` 可以将 JSON 解码到 `interface{}` 中，这将是一个
    `map[string]interface{} // 用于 JSON 对象类型` 或 `[]interface{} // 用于 JSON 数组`，具体取决于我们的
    JSON 是对象还是数组。
- en: In my opinion it is much clearer to the readers of our code if we explicitly
    state what we are expecting as a request. We can also save ourselves work by not
    having to manually cast the data when we come to use it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，如果我们明确地说明我们期望的请求内容，这将使我们的代码对读者来说更加清晰。我们还可以通过在需要使用数据时不必手动转换数据来节省我们的工作。
- en: 'Remember two things:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记住两点：
- en: You do not write code for the compiler, you write code for humans to understand
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不是为编译器编写代码，你是为人类编写代码以便理解
- en: You will spend more time reading code than you do writing it
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你阅读代码的时间将比编写代码的时间多
- en: 'Taking these two points into account we create a simple `struct` to represent
    our request, which will look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这两点，我们创建了一个简单的 `struct` 来表示我们的请求，它看起来是这样的：
- en: 'Example 1.5 `reading_writing_json_4/reading_writing_json_4.go`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 1.5 `reading_writing_json_4/reading_writing_json_4.go`:'
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, we are going to use `struct` field tags as whilst we could let `Unmarshal`
    do case-insensitive matching so `{"name": "World}` would correctly unmarshal into
    the `struct` the same as `{"Name": "World"}`, when we specify a tag we are being
    explicit about the request form and that is a good thing. In terms of speed and
    performance it is also about 10% faster, and remember, performance matters.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，我们将使用 `struct` 字段标签，因为我们可以让 `Unmarshal` 进行不区分大小写的匹配，所以 `{"name": "World}`
    会正确地解码到 `struct` 中，就像 `{"Name": "World"}` 一样，当我们指定一个标签时，我们是在明确请求的形式，这是好事。在速度和性能方面，它也大约快了
    10%，记住，性能很重要。'
- en: 'To access the JSON sent with the request we need to take a look at the `http.Request`
    object passed to our handler. The following listing does not show all the methods
    on the request, just the ones we are going to be immediately dealing with, for
    full documentation I recommend checking out the documentation at [https://godoc.org/net/http#Request](https://godoc.org/net/http#Request):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问与请求一起发送的 JSON，我们需要查看传递给我们的处理器的 `http.Request` 对象。以下列表并没有显示请求上的所有方法，只是我们立即要处理的方法，对于完整的文档，我建议查看
    [https://godoc.org/net/http#Request](https://godoc.org/net/http#Request) 上的文档：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The JSON that has been sent with the request is accessible in the `Body` field.
    Body implements the interface `io.ReadCloser` as a stream and does not return
    a `[]byte` or a `string`. If we need the data contained in the body, we can simply
    read it into a byte array, as shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请求中发送的 JSON 数据可以在 `Body` 字段中访问。`Body` 实现了 `io.ReadCloser` 接口作为流，并且不会返回 `[]byte`
    或 `string`。如果我们需要获取正文中的数据，我们可以简单地将其读取到一个字节数组中，如下面的示例所示：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here is something we'll need to remember. We are not calling `Body.Close()`,
    if we were making a call with a client we would need to do this as it is not automatically
    closed, however, when used in a `ServeHTTP` handler, the server automatically
    closes the request stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们需要记住的事情。我们没有调用 `Body.Close()`，如果我们用客户端进行调用，我们就需要这样做，因为它是不会自动关闭的；然而，当在
    `ServeHTTP` 处理器中使用时，服务器会自动关闭请求流。
- en: 'To see how this all works inside our handler, we can look at the following
    handler:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解所有这些是如何在我们的处理器中工作的，我们可以查看以下处理器：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s run this example and see how it works. To test, we can simply use the
    `curl` command to send a request to the running server. If you feel more comfortable
    using a GUI tool than Postman (which is available for the Google Chrome browser),
    they will work just fine or feel free to use your preferred tool:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个示例，看看它是如何工作的。为了测试，我们可以简单地使用 `curl` 命令向运行中的服务器发送请求。如果你觉得使用 GUI 工具（如 Postman，它适用于
    Google Chrome 浏览器）比使用 Postman 更舒服，它们也可以正常工作，或者你可以自由使用你喜欢的工具：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see the following response:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What do you think will happen if you do not include a body with your request?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在请求中不包括正文，你认为会发生什么？
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you guessed correctly, that you would get a `HTTP status 400 Bad Request`,
    then you win a prize:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜对了，你会得到 `HTTP 状态 400 错误请求`，那么你就能赢得奖品：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Errors reply to the request with the given message and status code. Once we
    have sent this, we need to return stopping further execution of the function as
    this does not close the `ResponseWriter` interface and return flow to the calling
    function automatically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 错误会以给定的消息和状态码回复请求。一旦我们发送了这些，我们就需要返回停止函数的进一步执行，因为这个操作不会自动关闭 `ResponseWriter`
    接口并返回到调用函数。
- en: Just before you think you are done, have a go and see if you can improve the
    performance of the handler. Think about the things we were talking about when
    marshaling JSON.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在你认为你已经完成之前，尝试一下，看看你是否能提高处理器的性能。想想我们在序列化 JSON 时讨论的事情。
- en: Got it?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？
- en: Well if not here is the answer, again all we are doing is using the `Decoder`,
    which is the opposite of the `Encoder` that we used in writing JSON. It has an
    instant 33% performance increase and less code too.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果不是这样，这里就是答案，我们只是在使用 `Decoder`，它是我们在写入 JSON 时使用的 `Encoder` 的相反。它有即时 33%
    的性能提升，代码也更少。
- en: 'Example 1.6 `reading_writing_json_5/reading_writing_json_5.go`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.6 `reading_writing_json_5/reading_writing_json_5.go`：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now we can see just how easy it is to encode and decode JSON with Go, I would
    recommend taking five minutes now to spend some time digging through the documentation
    for the `encoding/json` package ([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))
    as there is a whole lot more that you can do with this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到使用 Go 编码和解码 JSON 是多么简单，我建议现在花五分钟时间花些时间研究 `encoding/json` 包的文档 ([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))，因为你可以用这个包做很多事情。
- en: Routing in net/http
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `net/http` 中的路由
- en: Even a simple microservice will need the capability to route requests to different
    handlers dependent on the requested path or method. In Go this is handled by the
    `DefaultServeMux` method which is an instance of `ServerMux`. Earlier in this
    chapter, we briefly covered that when nil is passed to the handler parameter for
    the `ListenAndServe` function then the `DefaultServeMux` method is used. When
    we call the `http.HandleFunc("/helloworld", helloWorldHandler)` package function
    we are actually just indirectly calling `http.DefaultServerMux.HandleFunc(…)`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个简单的微服务也需要能够根据请求的路径或方法将请求路由到不同的处理程序。在 Go 中，这由 `DefaultServeMux` 方法处理，它是一个
    `ServerMux` 实例。在本章的早期，我们简要介绍了当将 nil 传递给 `ListenAndServe` 函数的处理程序参数时，将使用 `DefaultServeMux`
    方法。当我们调用 `http.HandleFunc("/helloworld", helloWorldHandler)` 包函数时，我们实际上只是间接调用
    `http.DefaultServerMux.HandleFunc(…)`。
- en: The Go HTTP server does not have a specific router instead any object which
    implements the `http.Handler` interface is passed as a top level function to the
    `Listen()` function, when a request comes into the server the `ServeHTTP` method
    of this handler is called and it is responsible for performing or delegating any
    work. To facilitate the handling of multiple routes the HTTP package has a special
    object called `ServerMux`, which implements the `http.Handler` interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Go HTTP 服务器没有特定的路由器，而是将实现 `http.Handler` 接口的对象作为顶级函数传递给 `Listen()` 函数。当请求进入服务器时，此处理程序的
    `ServeHTTP` 方法被调用，并负责执行或委托任何工作。为了便于处理多个路由，HTTP 包有一个特殊对象 `ServerMux`，它实现了 `http.Handler`
    接口。
- en: 'There are two functions to adding handlers to a `ServerMux` handler:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `ServerMux` 处理程序添加处理程序有两个函数：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `HandleFunc` function is a convenience function that creates a handler who's
    `ServeHTTP` method calls an ordinary function with the `func(ResponseWriter, *Request)`
    signature that you pass as a parameter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleFunc` 函数是一个便利函数，它创建了一个处理程序，该处理程序的 `ServeHTTP` 方法会调用一个带有 `func(ResponseWriter,
    *Request)` 签名的普通函数，该函数作为参数传递。'
- en: 'The `Handle` function requires that you pass two parameters, the pattern that
    you would like to register the handler and an object that implements the `Handler`
    interface:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handle` 函数要求你传递两个参数，你想要注册的处理程序的模式以及实现 `Handler` 接口的对象：'
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Paths
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径
- en: We already explained how `ServeMux` is responsible for routing inbound requests
    to the registered handlers, however the way that the routes are matched can be
    quite confusing. The `ServeMux` handler has a very simple routing model it does
    not support wildcards or regular expressions, with `ServeMux` you must be explicit
    about the registered paths.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了 `ServeMux` 负责将传入请求路由到已注册的处理程序的方式，然而路由匹配的方式可能相当令人困惑。`ServeMux` 处理程序有一个非常简单的路由模型，它不支持通配符或正则表达式，使用
    `ServeMux` 时，你必须明确注册的路径。
- en: You can register both fixed rooted paths, such as `/images/cat.jpg`, or rooted
    subtrees such as `/images/`. The trailing slash in the rooted subtree is important
    as any request that starts with `/images/`, for example `/images/happy_cat.jpg`,
    would be routed to the handler associated with `/images/`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注册固定根路径，例如 `/images/cat.jpg`，或者根子树，例如 `/images/`。根子树中的尾部斜杠很重要，因为任何以 `/images/`
    开头的请求，例如 `/images/happy_cat.jpg`，都将被路由到与 `/images/` 关联的处理程序。
- en: If we register a path `/images/` to the handler foo, and the user makes a request
    to our service at `/images` (note no trailing slash), then `ServerMux` will forward
    the request to the `/images/` handler, appending a trailing slash.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将路径 `/images/` 注册到处理程序 foo，并且用户向我们的服务发送到 `/images` 的请求（注意没有尾部斜杠），那么 `ServerMux`
    将将请求转发到 `/images/` 处理程序，并附加一个尾部斜杠。
- en: 'If we also register the path `/images` (note no trailing slash) to the handler
    bar and the user requests `/images` then this request will be directed to bar;
    however, `/images/` or `/images/cat.jpg` will be directed to foo:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还将路径 `/images`（注意没有尾部斜杠）注册到处理程序 bar，并且用户请求 `/images`，则此请求将被导向 bar；然而，`/images/`
    或 `/images/cat.jpg` 将被导向 foo：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Longer paths will always take precedence over shorter ones so it is possible
    to have an explicit route that points to a different handler to a catch all route.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的路径始终优先于较短的路径，因此可以有一个显式路由指向不同的处理程序，以捕获所有路由。
- en: We can also specify the hostname, we could register a path such as `search.google.com/`
    and `/ServerMux` would forward any requests to `http://search.google.com` and
    `http://www.google.com` to their respective handlers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定主机名，例如可以注册路径 `search.google.com/`，那么 `/ServerMux` 将将任何请求转发到 `http://search.google.com`
    和 `http://www.google.com`，并转发到它们各自的处理程序。
- en: If you are used to a framework based application development approach such as
    using Ruby on Rails or ExpressJS you may find this router incredibly simple and
    it is, remember that we are not using a framework but the standard packages of
    Go, the intention is always to provide a basis that can be built upon. In very
    simple cases the `ServeMux` approach more than good enough and in fact I personally
    don't use anything else. Everyone's needs are different however and the beauty
    and simplicity of the standard packages makes it incredibly simple to build your
    own route as all is needed is an object which implements the `Handler` interface.
    A quick trawl through google will surface some very good third party routers but
    my recommendation for you is to learn the limitations of `ServeMux` first before
    deciding to choose a third-party package it will greatly help with your decision
    process as you will know the problem you are trying to solve.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了基于框架的应用程序开发方法，例如使用 Ruby on Rails 或 ExpressJS，你可能会觉得这个路由器非常简单，确实如此，记住我们不是使用框架，而是
    Go 的标准包，我们的目的是始终提供一个可以在此基础上构建的基础。在非常简单的情况下，`ServeMux` 方法已经足够好了，事实上我个人根本不使用其他任何东西。然而，每个人的需求都是不同的，标准包的美丽和简洁性使得构建自己的路由变得极其简单，因为所需的所有东西只是一个实现了
    `Handler` 接口的对象。快速在谷歌上搜索会找到一些非常好的第三方路由器，但我的建议是，在决定选择第三方包之前，首先学习 `ServeMux` 的限制，这将大大有助于你的决策过程，因为你将知道你试图解决的问题。
- en: Convenience handlers
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方便处理程序
- en: The `net/http` package implements several methods that create different types
    of convenience handlers, let's examine these.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包实现了几个创建不同类型方便处理程序的方法，让我们来检查这些。'
- en: FileServer
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileServer
- en: 'A `FileServer` function returns a handler that serves HTTP requests with the
    contents of the filesystem. This can be used to serve static files such as images
    or other content that is stored on the file system:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileServer` 函数返回一个处理程序，它使用文件系统的内容来服务 HTTP 请求。这可以用来服务静态文件，如图像或其他存储在文件系统上的内容：'
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Take a look at the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This allows us to map the contents of the file system path `./images` to the
    server route `/images`, `Dir` implements a file system which is restricted to
    a specific directory tree, the `FileServer` method uses this to be able to serve
    the assets.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将文件系统路径 `./images` 的内容映射到服务器路由 `/images`，`Dir` 实现了一个仅限于特定目录树的文件系统，`FileServer`
    方法使用它来提供资产服务。
- en: NotFoundHandler
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NotFoundHandler
- en: 'The `NotFoundHandler` function returns a simple request handler that replies
    to each request with a `404 page not found reply`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotFoundHandler` 函数返回一个简单的请求处理程序，对每个请求回复一个 `404 页面未找到` 的回复：'
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: RedirectHandler
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RedirectHandler
- en: 'The `RedirectHandler` function returns a request handler that redirects each
    request it receives to the given URI using the given status code. The provided
    code should be in the 3xx range and is usually `StatusMovedPermanently`, `StatusFound`,
    or `StatusSeeOther`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedirectHandler` 函数返回一个请求处理程序，它将接收到的每个请求重定向到给定的 URI，并使用给定的状态码。提供的代码应在 3xx
    范围内，通常是 `StatusMovedPermanently`、`StatusFound` 或 `StatusSeeOther`：'
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: StripPrefix
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StripPrefix
- en: 'The `StripPrefix` function returns a handler that serves HTTP requests by removing
    the given prefix from the request URL''s path and then invoking `h` handler. If
    a path does not exist, then `StripPrefix` will reply with an HTTP 404 not found
    error:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`StripPrefix` 函数返回一个处理程序，它通过从请求 URL 的路径中移除给定的前缀来服务 HTTP 请求，然后调用 `h` 处理程序。如果路径不存在，则
    `StripPrefix` 将回复一个 HTTP 404 未找到错误：'
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: TimeoutHandler
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TimeoutHandler
- en: 'The `TimeoutHandler` function returns a `Handler` interface that runs `h` with
    the given time limit. When we investigate common patterns in [Chapter 6](74445ff8-eb01-4a2f-a910-0551e7d85a5f.xhtml),
    *Microservice Frameworks*, we will see just how useful this can be for avoiding
    cascading failures in your service:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeoutHandler` 函数返回一个 `Handler` 接口，它以给定的时间限制运行 `h`。当我们研究第 6 章（74445ff8-eb01-4a2f-a910-0551e7d85a5f.xhtml）中常见的模式，即
    *微服务框架* 时，我们将看到这如何有助于避免服务中的级联故障：'
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The new handler calls `h.ServeHTTP` to handle each request, but if a call runs
    for longer than its time limit, the handler responds with a `503 Service Unavailable`
    response with the given message `(msg)` in its body.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 新的处理程序调用 `h.ServeHTTP` 来处理每个请求，但如果调用运行时间超过了其时间限制，处理程序将回复一个包含给定消息 `(msg)` 的 `503
    服务不可用` 响应：
- en: The last two handlers are especially interesting as they are, in effect, chaining
    handlers. This is a technique that we will go into more in-depth in a later chapter
    as it allows you to both practice clean code and also allows you to keep your
    code DRY.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个处理器特别有趣，因为它们实际上是在链式处理。这是一个我们将在后面的章节中更深入探讨的技术，它允许你练习编写干净的代码，同时也允许你保持代码的DRY（Don't
    Repeat Yourself）。
- en: I may have lifted most of the descriptions for these handlers straight from
    the Go documentation and you probably have already read these because you have
    read the documentation right? With Go, the documentation is excellent and writing
    documentation for your own packages is heavily encouraged, even enforced, if you
    use the `golint` command that comes with the standard package then this will report
    areas of your code which do not conform to the standards. I really recommend spending
    a little time browsing the standard docs when you are using one of the packages,
    not only will you learn the correct usage, you may learn that there is a better
    approach. You will certainly be exposed to good practice and style and you may
    even be able to keep working on the sad day that Stack Overflow stops working
    and the entire industry grinds to a halt.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能直接从Go文档中提取了这些处理器的多数描述，你可能已经阅读过这些内容，因为你已经阅读过文档，对吧？在Go中，文档非常出色，并且强烈鼓励（甚至强制）为你的包编写文档，如果你使用标准包中包含的`golint`命令，那么它将报告你的代码中不符合标准的部分。我强烈建议在使用某个包时花点时间浏览标准文档，这不仅可以帮助你了解正确的用法，你可能会发现更好的方法。你肯定会接触到良好的实践和风格，甚至可能在你继续工作的那一天（Stack
    Overflow停止工作，整个行业停滞不前）有所帮助。
- en: Static file handler
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态文件处理器
- en: Whilst we are mostly going to be dealing with APIs in this book, it is a useful
    illustration to see how the default router and paths work by adding a secondary
    endpoint.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这本书中我们主要会处理API，但通过添加一个二级端点来观察默认路由器和路径的工作方式是有益的说明。
- en: As a little exercise, try to modify the code in `reading_writing_json_5/reading_writing_json_5.go`
    to add an endpoint `/cat`, which returns the cat picture specified in the URI.
    To give you a little hint, you are going to need to use the `FileServer` function
    on the `net/http` package and your URI will look something like `http://localhost:8080/cat/cat.jpg`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小练习，尝试修改`reading_writing_json_5/reading_writing_json_5.go`中的代码，添加一个端点`/cat`，它返回URI中指定的猫的图片。为了给你一点提示，你需要使用`net/http`包中的`FileServer`函数，你的URI将类似于`http://localhost:8080/cat/cat.jpg`。
- en: Did it work the first time or did you forget to add the `StripPrefix` handler?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试就成功了，还是你忘记添加`StripPrefix`处理器了？
- en: 'Example 1.7 `reading_writing_json_6/reading_writing_json_6.go`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '示例1.7 `reading_writing_json_6/reading_writing_json_6.go`:'
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, we are registering a `StripPrefix` handler with our
    path `/cat/`. If we did not do this, then the `FileServer` handler would be looking
    for our image in the `images/cat` directory. It is also worth reminding ourselves
    about the difference with `/cat` and `/cat/` as paths. If we registered our path
    as `/cat` then we would not match `/cat/cat.jpg`. If we register our path as `/cat/`,
    we will match both `/cat` and `/cat/whatever`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们向路径`/cat/`注册了一个`StripPrefix`处理器。如果我们没有这样做，那么`FileServer`处理器就会在我们的`images/cat`目录中寻找我们的图片。也值得提醒一下关于`/cat`和`/cat/`作为路径的区别。如果我们注册我们的路径为`/cat`，那么我们不会匹配`/cat/cat.jpg`。如果我们注册我们的路径为`/cat/`，我们将匹配`/cat`和`/cat/whatever`。
- en: Creating handlers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建处理器
- en: We will now finish off our examples here by showing how you can create a `Handler`
    rather than just using `HandleFunc`. We are going to split the code that performs
    the request validation for our `helloworld` endpoint and the code that returns
    the response out into separate handlers to illustrate how it is possible to chain
    handlers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过展示如何创建`Handler`而不是仅仅使用`HandleFunc`来结束这里的示例。我们将把为我们的`helloworld`端点执行请求验证的代码和返回响应的代码分别放入单独的处理程序中，以说明如何链式处理。
- en: 'Example 1.8 `chapter1/reading_writing_json_7.go`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '示例1.8 `chapter1/reading_writing_json_7.go`:'
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing we need to do when creating our own `Handler` is to define a
    `struct` field that will implement the methods in the `Handlers` interface. Since
    in this example, we are going to be chaining handlers together, the first handler,
    which is our validation handler, needs to have a reference to the next in the
    chain as it has the responsibility for calling `ServeHTTP` or returning a response.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的 `Handler` 时，我们首先需要定义一个 `struct` 字段，该字段将实现 `Handlers` 接口中的方法。由于在这个例子中，我们将要链式连接处理程序，第一个处理程序，也就是我们的验证处理程序，需要有一个对链中下一个处理程序的引用，因为它有调用
    `ServeHTTP` 或返回响应的责任。
- en: 'For convenience, we have added a function that returns us a new handler; however,
    we could have just set the next field. This method, however, is better form as
    it makes our code a little easier to read and when we need to pass complex dependencies
    to the handler using a function to create, it keeps things a little neater:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们添加了一个返回新处理程序的函数；然而，我们也可以直接设置下一个字段。但是，这种方法是更好的形式，因为它使我们的代码更容易阅读，并且当我们需要通过一个创建函数传递复杂依赖项到处理程序时，它可以使事情保持整洁一些：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The previous code block illustrates how we would implement the `ServeHTTP`
    method. The only interesting thing to note here is the statement that begins at
    line **44**. If an error is returned from decoding the request, we write a 500
    error to the response, the handler chain would stop here. Only when no error is
    returned do we call the next handler in the chain and we do this simply by invoking
    its `ServeHTTP` method. To pass the name decoded from the request, we are simply
    setting a variable:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块展示了我们如何实现 `ServeHTTP` 方法。这里需要注意的唯一有趣的事情是从第 **44** 行开始的语句。如果解码请求返回错误，我们将向响应写入
    500 错误，处理链在这里会停止。只有当没有错误返回时，我们才会调用链中的下一个处理程序，我们通过调用其 `ServeHTTP` 方法来完成此操作。为了传递从请求中解码出的名称，我们只是设置了一个变量：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `helloWorldHandler` type that writes the response does not look too different
    from when we were using a simple function. If you compare this to *example 1.6*,
    you will see that all we really have done is remove the request decoding.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 写入响应的 `helloWorldHandler` 类型与我们使用简单函数时看起来并没有太大区别。如果你将其与 *示例 1.6* 进行比较，你会发现我们真正做的只是移除了请求解码。
- en: Now the first thing I want to mention about this code is that it is purely to
    illustrate how you can do something, not that you should do something. In this
    simple case, splitting the request validation and response sending into two handlers
    adds a lot of needless complexity and it is not really making our code DRYer.
    The technique, however, is useful. When we examine authentication in a later chapter,
    you will see this pattern as it allows us to centralize our authentication logic
    and share it among handlers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我首先要提到的是，这段代码纯粹是为了说明你可以如何做某事，而不是你应该这样做。在这个简单的情况下，将请求验证和响应发送拆分为两个处理程序增加了许多不必要的复杂性，并且并没有真正使我们的代码更加简洁。然而，这项技术是有用的。当我们稍后在章节中检查身份验证时，你会看到这个模式，因为它允许我们将身份验证逻辑集中化并在处理程序之间共享。
- en: Context
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Context
- en: The problem with the previous pattern is that there is no way that you can pass
    the validated request from one handler to the next without breaking the `http.Handler`
    interface, but guess what Go has us covered. The context package was listed as
    experimental for several years before finally making it in to the standard package
    with Go 1.7\. The `Context` type implements a safe method for accessing request-scoped
    data that is safe to use simultaneously by multiple Go routines. Let’s take a
    quick look at this package and then update our example to see it in use.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之前模式的问题是没有办法在不破坏 `http.Handler` 接口的情况下，将验证过的请求从一个处理程序传递到下一个处理程序，但是猜猜看，Go 已经为我们解决了这个问题。`context`
    包在 Go 1.7 之前被列为实验性包，最终被纳入标准包。`Context` 类型实现了一种安全的方法来访问请求范围内的数据，该数据可以由多个 Go 线程安全地同时使用。让我们快速看一下这个包，然后更新我们的示例以查看其使用情况。
- en: Background
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: 'The `Background` method returns an empty context that has no values; it is
    typically used by the main function and as the top-level `Context`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Background` 方法返回一个没有任何值的空上下文；它通常用于主函数和顶级 `Context`：'
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: WithCancel
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WithCancel
- en: 'The `WithCancel` method returns a copy of the parent context with a cancel
    function, calling the cancel function releases resources associated with the context
    and should be called as soon as operations running in the `Context` type are complete:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithCancel` 方法返回一个带有取消函数的父上下文副本，调用取消函数会释放与上下文关联的资源，应该在 `Context` 类型的操作完成后立即调用：'
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: WithDeadline
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WithDeadline
- en: 'The `WithDeadline` method returns a copy of the parent context that expires
    after the current time is greater than deadline. At this point, the context''s
    `Done` channel is closed and the resources associated are released. It also passes
    back a `CancelFunc` method that allows manual cancellation of the context:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithDeadline` 方法返回父上下文的副本，该副本在当前时间大于截止日期后过期。此时，上下文的 `Done` 通道关闭，与之关联的资源被释放。它还返回一个
    `CancelFunc` 方法，允许手动取消上下文：'
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: WithTimeout
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WithTimeout`'
- en: 'The `WithTimeout` method is similar to `WithDeadline` except you pass it a
    duration for which the `Context` type should exist. Once this duration has elapsed,
    the `Done` channel is closed and the resources associated with the context are
    released:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithTimeout` 方法与 `WithDeadline` 类似，但你需要传递一个持续时间，`Context` 类型应该存在。一旦这个持续时间过去，`Done`
    通道关闭，与上下文关联的资源被释放：'
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: WithValue
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WithValue`'
- en: 'The `WithValue` method returns a copy of the parent `Context` in which the
    `val` value is associated with the key. The `Context` values are perfect to be
    used for request-scoped data:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithValue` 方法返回父 `Context` 的一个副本，其中 `val` 值与键相关联。`Context` 值非常适合用于请求作用域的数据：'
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Why not attempt to modify *example 1.7* to implement a request scoped context.
    The key could be in the previous sentence; every request needs its own context.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不尝试修改 *示例 1.7* 来实现一个请求作用域的上下文。关键可能就在上一句中；每个请求都需要自己的上下文。
- en: Using contexts
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文
- en: You probably found that rather painful, especially if you come from a background
    in a framework such as Rails or Spring. Writing this kind of code is not really
    something you want to be spending your time on, building application features
    is far more important. One thing to note however is that neither Ruby or Java
    have anything more advanced in their base packages. Thankfully for us, over the
    seven years that Go has been in existence, many excellent people have done just
    that, and when looking at frameworks in [Chapter 3](cfab2776-305a-417c-853f-26e4caba67d2.xhtml),
    *Introducing Docker*, we will find that all of this complexity has been taken
    care of by some awesome open source authors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得这相当痛苦，尤其是如果你来自像 Rails 或 Spring 这样的框架背景。编写这类代码并不是你想要花费时间的事情，构建应用程序功能要重要得多。然而，有一点需要注意，Ruby
    或 Java 的基础包中都没有更高级的功能。幸运的是，自从 Go 存在的七年里，许多优秀的人已经做到了这一点，当我们查看第 3 章 [介绍 Docker](cfab2776-305a-417c-853f-26e4caba67d2.xhtml)
    中的框架时，我们会发现所有这些复杂性都已被一些出色的开源作者处理好了。
- en: 'In addition to the adoption of context into the main Go release version 1.7
    implements an important update on the `http.Request` structure, we have the following
    additions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将上下文引入 Go 的主要发布版本 1.7 以外，还对 `http.Request` 结构体进行了重要更新，我们还有以下新增功能：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Context()` method gives us access to a `context.Context` structure which
    is always non nil as it is populated when the request is originally created. For
    inbound requests the `http.Server` manages the lifecycle of the context automatically
    cancelling it when the client connection closes. For outbound requests, `Context`
    controls cancellation, by this we mean that if we cancel the `Context()` method
    we can cancel the outgoing request. This concept is illustrated in the following
    example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context()` 方法让我们能够访问一个 `context.Context` 结构体，它始终不为空，因为它在请求最初创建时被填充。对于入站请求，`http.Server`
    自动管理上下文的生命周期，当客户端连接关闭时自动取消上下文。对于出站请求，`Context` 通过以下方式控制取消：这意味着如果我们取消 `Context()`
    方法，我们可以取消出站请求。这一概念在以下示例中得到了说明：'
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In line **74**, we are creating a timeout context from the original in the request,
    and unlike an inbound request where the context is automatically cancelled for
    you we must manually perform this step in an outbound request.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 **74** 行，我们正在从请求中的原始上下文创建一个超时上下文，与自动取消上下文的入站请求不同，我们必须在出站请求中手动执行此步骤。
- en: 'Line **77** implements the second of the two new context methods which have
    been added to the `http.Request` object:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第 **77** 行实现了添加到 `http.Request` 对象的两个新上下文方法中的第二个：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `WithContext` object returns a shallow copy of the original request which
    has the context changed to the given `ctx` context.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithContext` 对象返回原始请求的一个浅拷贝，其上下文已更改为给定的 `ctx` 上下文。'
- en: 'When we execute this function we will find that after 1 millisecond the request
    will complete with an error:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个函数时，我们会发现 1 毫秒后请求将因错误而完成：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The context is timing out before the request has a change to complete and the
    do method immediately returns. This is an excellent technique to use for outbound
    connections and thanks to the changes in Go 1.7 is now incredibly easy to implement.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文在请求有机会完成之前就超时了，而`do`方法立即返回。这是一个用于出站连接的绝佳技术，多亏了Go 1.7中的变化，现在实现起来非常简单。
- en: 'What about our inbound connection Let’s see how we can update our previous
    example. Example 1.9 updates our example to show how we can leverage the `context`
    package to implement Go routine safe access to objects. The full example can be
    found in `reading_writing_json_8/reading_writing_json_8.go` but all of the modification
    we need to make are in the two `ServeHTTP` methods for our handlers:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的入站连接怎么办？让我们看看我们如何更新之前的示例。示例1.9更新了我们的示例，展示了我们如何利用`context`包实现Go协程安全访问对象。完整的示例可以在`reading_writing_json_8/reading_writing_json_8.go`中找到，但我们需要的所有修改都在我们处理器的两个`ServeHTTP`方法中：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we take a quick look at our `validationHandler` you will see that when we
    have a valid request, we are creating a new context for this request and then
    setting the value of the `Name` field in the request into the context. You might
    also wonder what is going on with line **51**. When you add an item to a context
    such as with the `WithValue` call, the method returns a copy of the previous context,
    to save a little time and add a little confusion, we are holding a pointer to
    the context, so in order to pass this as a copy to `WithValue`, we must dereference
    it. To update our pointer, we must also set the returned value to the value referenced
    by the pointer hence again we need to dereference it. The other think we need
    to look at with this method call is the key, we are using `validationContextKey`
    this is an explicitly declared type of string:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们快速查看我们的`validationHandler`，你会看到当我们收到一个有效的请求时，我们为这个请求创建一个新的上下文，然后将请求中的`Name`字段的值设置到上下文中。你也可能想知道第**51**行发生了什么。当你向上下文中添加一个项目，比如使用`WithValue`调用时，该方法返回前一个上下文的副本，为了节省一点时间并增加一点混淆，我们持有上下文的指针，因此为了将这个副本传递给`WithValue`，我们必须取消引用它。为了更新我们的指针，我们还必须将返回的值设置到指针引用的值，因此我们再次需要取消引用它。我们还需要关注这个方法调用中的键，我们使用`validationContextKey`，这是一个显式声明的字符串类型：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The reason we are not just using a simple string is that context often flows
    across packages and if we just used string then we could end up with a key clash
    where one package within your control is writing a `name` key and another package
    which is outside of your control is also using the context and writing a key called
    `name`, in this instance the second package would inadvertently overwrite your
    context value. By declaring a package level type `validationContextKey` and using
    this we can ensure that we avoid these collisions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以不直接使用简单的字符串，是因为上下文经常跨越包，如果我们只使用字符串，那么我们可能会遇到键冲突，其中一个受我们控制的包正在写入`name`键，而另一个不受我们控制的包也在使用上下文并写入名为`name`的键，在这种情况下，第二个包会意外地覆盖你的上下文值。通过声明包级别的类型`validationContextKey`并使用它，我们可以确保避免这些冲突：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To retrieve the value, all we have to do is obtain the context and then call
    the `Value` method casting it into a string.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索值，我们只需获取上下文，然后调用`Value`方法将其转换为字符串。
- en: RPC in the Go standard library
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go标准库中的RPC
- en: As expected, the Go standard library has fantastic support for RPC right out-of-the-box.
    Let's look at a few examples of how we can use this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，Go标准库对RPC的支持非常出色，直接开箱即用。让我们看看一些示例，了解我们如何使用它。
- en: Simple RPC example
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的RPC示例
- en: 'In this simple example, we will see how we can use the standard RPC package
    to create a client and server that use a shared interface to communicate over
    RPC. We will follow the typical Hello World example that we ran through when learning
    the `net/http` package and see just how easy it is to build an RPC-based API in
    go:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们将看到如何使用标准RPC包创建一个客户端和服务器，它们使用共享接口通过RPC进行通信。我们将遵循我们在学习`net/http`包时运行的典型Hello
    World示例，看看构建基于RPC的API在Go中有多简单：
- en: '`rpc/server/server.go`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpc/server/server.go`:'
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Like our example on creating REST APIs using the standard library for RPC,
    we will also define a handler. The difference between this handler and `http.Handler`
    is that it does not need to conform to an interface; as long as we have a `struct`
    field with methods on it we can register this with the RPC server:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在使用标准库创建RPC API的例子中一样，我们也将定义一个处理器。这个处理器与`http.Handler`的区别在于它不需要符合一个接口；只要我们有一个带有方法的`struct`字段，我们就可以将其注册到RPC服务器上：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Register` function, which is in the `rpc` package, publishes the methods
    that are part of the given interface to the default server and allows them to
    be called by clients connecting to the service. The name of the method uses the
    name of the concrete type, so in our instance if my client wanted to call the
    `HelloWorld` method, we would access it using `HelloWorldHandler.HelloWorld`.
    If we do not wish to use the concrete types name, we can register it with a different
    name using the `RegisterName` function, which uses the provided name instead:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`函数，位于`rpc`包中，将给定接口中的方法发布到默认服务器，并允许客户端连接到服务时调用它们。方法名称使用具体类型的名称，所以在我们这个实例中，如果我的客户端想要调用`HelloWorld`方法，我们将使用`HelloWorldHandler.HelloWorld`来访问它。如果我们不想使用具体类型的名称，我们可以使用`RegisterName`函数将其注册为不同的名称，该函数使用提供的名称：'
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This would enable me to keep the name of the `struct` field to whatever is
    meaningful to my code; however, for my client contract I might decide to use something
    different such as `Greet`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我能够将`struct`字段的名称保持为对我的代码有意义的任何名称；然而，对于我的客户端合同，我可能决定使用不同的名称，例如`Greet`：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the `StartServer` function, we first create a new instance of our handler
    and then we register this with the default RPC server.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StartServer`函数中，我们首先创建我们处理器的新的实例，然后将其注册到默认RPC服务器。
- en: 'Unlike the convenience of `net/http` where we can just create a server with
    `ListenAndServe`, when we are using RPC we need to do a little more manual work.
    In line **23**, we are creating a socket using the given protocol and binding
    it to the IP address and port. This gives us the capability to specifically select
    the protocol we would like to use for the server, `tcp`, `tcp4`, `tcp6`, `unix`,
    or `unixpacket`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与`net/http`的便利性不同，我们可以直接使用`ListenAndServe`创建服务器，当我们使用RPC时，我们需要做一些更多的人工工作。在**23**行，我们使用给定的协议创建一个套接字，并将其绑定到IP地址和端口。这使我们能够特别选择我们希望服务器使用的协议，`tcp`、`tcp4`、`tcp6`、`unix`或`unixpacket`：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `Listen()` function returns an instance that implements the `Listener`
    interface:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listen()`函数返回一个实现了`Listener`接口的实例：'
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To receive connections, we must call the `Accept` method on the listener. If
    you look at line **29**, you will see that we have an endless for loop, this is
    because unlike `ListenAndServe` which blocks for all connections, with an RPC
    server we handle each connection individually and as soon as we deal with the
    first connection we need to continue to again call `Accept` to handle subsequent
    connections or the application would exit. Accept is a blocking method so if there
    are no clients currently attempting to connect to the service then `Accept` will
    block until one does. Once we receive a connection then we need to call the `Accept`
    method again to process the next connection. If you look at line **30** in our
    example code, you will see we are calling the `ServeConn` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收连接，我们必须在监听器上调用`Accept`方法。如果你查看**29**行，你会看到我们有一个无限循环，这是因为与`ListenAndServe`不同，它会阻塞所有连接，而在RPC服务器中，我们逐个处理每个连接，一旦我们处理了第一个连接，我们就需要再次调用`Accept`来处理后续的连接，否则应用程序会退出。`Accept`是一个阻塞方法，所以如果没有客户端当前尝试连接到服务，则`Accept`将阻塞，直到有一个客户端尝试连接。一旦我们收到一个连接，我们就需要再次调用`Accept`方法来处理下一个连接。如果你查看我们的示例代码中的**30**行，你会看到我们正在调用`ServeConn`方法：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `ServeConn` method runs the `DefaultServer` method on the given connection,
    and will block until the client completes. In our example, we are using the go
    statement before running the server so that we can immediately process the next
    waiting connection without blocking for the first client to close its connection.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServeConn`方法在给定的连接上运行`DefaultServer`方法，并且会阻塞直到客户端完成。在我们的示例中，我们在运行服务器之前使用go语句，这样我们就可以立即处理下一个等待的连接，而不会阻塞第一个客户端关闭其连接。'
- en: In terms of communication protocol, `ServeConn` uses the `gob` wire format [https://golang.org/pkg/encoding/gob/](https://golang.org/pkg/encoding/gob/),
    we will see when we look at JSON-RPC how we can use a different encoding.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在通信协议方面，`ServeConn`使用`gob`线格式[https://golang.org/pkg/encoding/gob/](https://golang.org/pkg/encoding/gob/)，当我们查看JSON-RPC时，我们将看到如何使用不同的编码。
- en: The `gob` format was specifically designed to facilitate Go to Go-based communication
    and was designed around the idea of something easier to use and possibly more
    efficient than the likes of protocol buffers, this comes at a cost of cross language
    communication.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`gob`格式是专门设计来促进Go到Go之间的通信，并且围绕着一个更容易使用且可能比协议缓冲区等更高效的思路进行设计，但这会牺牲跨语言通信的能力。'
- en: With gobs, the source and destination values and types do not need to correspond
    exactly, when you send `struct`, if a field is in the source but not in the receiving
    `struct`, then the decoder will ignore this field and the processing will continue
    without error. If a field is present in the destination that is not in the source,
    then again the decoder will ignore this field and will successfully process the
    rest of the message. Whilst this seems like a minor benefit, it is a huge advancement
    over the RPC messages of old such as JMI where the exact same interface must be
    present on both the client and server. This level of inflexibility with JMI introduced
    tight coupling between the two code bases and caused no end of complexity when
    it was required to deploy an update to our application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gob，源和目标值以及类型不需要完全对应，当你发送`struct`时，如果源中有一个字段但接收到的`struct`中没有，那么解码器将忽略这个字段，并且处理将继续而不会出错。如果目标中有一个字段在源中不存在，那么解码器同样会忽略这个字段，并成功处理消息的其余部分。虽然这似乎是一个小的优势，但与旧版本的RPC消息（如JMI）相比，这是一个巨大的进步，因为JMI要求客户端和服务器上必须存在完全相同的接口。JMI的这种不灵活性在两个代码库之间引入了紧密耦合，并在需要部署应用程序更新时带来了无尽的复杂性。
- en: 'To make a request to our client we can no longer simply use curl as we are
    no longer are using the HTTP protocol and the message format is no longer JSON.
    If we look at the example in `rpc/client/client.go` we can see how to implement
    a connecting client:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向我们的客户提出请求，我们不能再简单地使用curl，因为我们不再使用HTTP协议，消息格式也不再是JSON。如果我们查看`rpc/client/client.go`中的示例，我们可以看到如何实现一个连接客户端：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The previous block shows how we need to setup `rpc.Client`, the first thing
    we need to do on line **14** is to create the client itself using the `Dial()`
    function in the `rpc` package:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块显示了我们需要如何设置`rpc.Client`，在**14**行，我们首先需要使用`rpc`包中的`Dial()`函数创建客户端本身：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then use this returned connection to make a request to the server:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这个返回的连接向服务器发送请求：
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In line **26**, we are using the `Call()` method on the client to invoke the
    named function on the server:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在**26**行，我们正在使用客户端上的`Call()`方法在服务器上调用命名函数：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`Call` is a blocking function which waits until the server sends a reply writing
    the response assuming there is no error to the reference of our `HelloWorldResponse`
    passed to the method and if an error occurs when processing the request this is
    returned and can be handled accordingly.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Call`是一个阻塞函数，它等待服务器发送回复，假设没有错误，将响应写入我们传递给方法的`HelloWorldResponse`引用中，如果在处理请求时发生错误，则返回错误，并可以相应地处理。'
- en: RPC over HTTP
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP的RPC
- en: In the instance that you need to use HTTP as your transport protocol then the
    `rpc` package can facilitate this by calling the `HandleHTTP` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在你需要使用HTTP作为传输协议的情况下，`rpc`包可以通过调用`HandleHTTP`方法来提供这种支持。
- en: 'The `HandleHTTP` method sets up two endpoints in your application:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleHTTP`方法在你的应用程序中设置两个端点：'
- en: '[PRE67]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you point your browser at the `DefaultDebugPath` you can see details for
    the registered endpoints, there are two things to note:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将浏览器指向`DefaultDebugPath`，你可以看到已注册端点的详细信息，有两点需要注意：
- en: This does not mean you can communicate easily with your API from a web browser.
    The messages are still `gob` encoded so you would need to write a gob encoder
    and decoder in JavaScript, which I am not actually sure is possible. It was certainly
    never the intent of the package to support this capability and therefore I would
    not advise this action, a JSON or JSON-RPC based message is much better suited
    to this use case.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并不意味着你可以轻松地从网页浏览器与你的API进行通信。消息仍然是`gob`编码的，因此你需要编写JavaScript中的gob编码器和解码器，我实际上不确定这是否可能。包的明确意图绝不是支持这种功能，因此我不会建议这样做，基于JSON或JSON-RPC的消息更适合这个用例。
- en: The debug endpoint is not going to provide you with auto-generated documentation
    for your API. The output is fairly basic and the intention seems to be so you
    can track the number of calls made to an endpoint.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试端点不会为你提供 API 的自动生成文档。输出相当基础，意图似乎是让你可以跟踪对端点的调用次数。
- en: All that said there may be a reason why you need to use HTTP, possibly your
    network does not allow any other protocol or potentially you have a load balancer
    that is not capable of dealing with pure TCP connections. We can also take advantage
    of HTTP headers and other metadata which is not available using a pure TCP request.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，可能存在需要使用 HTTP 的原因，可能是你的网络不允许使用任何其他协议，或者可能你有一个无法处理纯 TCP 连接的负载均衡器。我们还可以利用
    HTTP 标头和其他元数据，这些在纯 TCP 请求中是不可用的。
- en: '`rpc_http/server/server.go`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpc_http/server/server.go`'
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If we look at line **25**, in the preceding example, we can see we are calling
    the `rpc.HandleHTTP` method, this is a requirement using HTTP with RPC as it will
    register the HTTP handlers we mentioned earlier with the `DefaultServer` method.
    We then call the `http.Serve` method and pass it the listener we are creating
    in line **27**, we are setting the second parameter to be `nil` as we wish to
    use the `DefaultServer` method. This is exactly the same method that we looked
    at in the previous examples when we were looking at RESTful endpoints.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前面的示例中的第 **25** 行，我们可以看到我们调用的是 `rpc.HandleHTTP` 方法，这是使用 HTTP 与 RPC 一起使用的要求，因为它会将我们之前提到的
    HTTP 处理程序与 `DefaultServer` 方法注册。然后我们调用 `http.Serve` 方法，并传递我们在第 **27** 行创建的监听器，我们将第二个参数设置为
    `nil`，因为我们希望使用 `DefaultServer` 方法。这正是我们在之前的示例中查看 RESTful 端点时所查看的方法。
- en: JSON-RPC over HTTP
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTP 的 JSON-RPC
- en: In this last example, we will look at the `net/rpc/jsonrpc` package that provides
    a built-in codec for serializing and deserializing to the JSON-RPC standard. We
    will also look at how we can send these responses over HTTP, whilst you may ask
    why not just use REST, and to some extent I will agree with you, it is an interesting
    example to be able to see how we can extend the standard framework.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，我们将查看 `net/rpc/jsonrpc` 包，它提供了一个内置的编解码器，用于将数据序列化和反序列化为 JSON-RPC 标准。我们还将查看如何通过
    HTTP 发送这些响应，虽然你可能想知道为什么不直接使用 REST，在某种程度上，我会同意你的观点，这是一个有趣的例子，可以展示我们如何扩展标准框架。
- en: 'The `StartServer` method contains nothing we have not seen before it is the
    standard `rpc` server setup, the main difference is line **42** where instead
    of starting the RPC server we are starting an `http` server and passing the listener
    to it along with a handler:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartServer` 方法中包含的内容我们之前都见过，这是标准的 `rpc` 服务器设置，主要区别在于第 **42** 行，在那里我们不是启动
    RPC 服务器，而是启动一个 `http` 服务器，并将监听器及其处理程序传递给它：'
- en: '`rpc_http_json/server/server.go`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpc_http_json/server/server.go`'
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The handler we are passing to the server is where the magic happens:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给服务器的处理程序是魔法发生的地方：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In line **46**, we are calling the `jsonrpc.NewServerCodec` function and passing
    to it a type that implements `io.ReadWriteCloser`. The `NewServerCodec` method
    returns a type that implements `rpc.ClientCodec`, which has the following methods:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 **46** 行，我们调用 `jsonrpc.NewServerCodec` 函数，并传递一个实现 `io.ReadWriteCloser` 类型的类型。`NewServerCodec`
    方法返回一个实现 `rpc.ClientCodec` 类型的类型，它具有以下方法：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A `ClientCodec` type implements the writing of RPC request and reading RPC
    responses. To write a request to the connection a client calls the `WriteRequest`
    method. To read the response, the client must call `ReadResponseHeader` and `ReadResponseBody`
    as a pair. Once the body has been read, it is the client''s responsibility to
    call the `Close` method to close the connection. If a nil interface is passed
    to `ReadResponseBody` then the body of the response should be read and then discarded:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientCodec` 类型实现了 RPC 请求的写入和 RPC 响应的读取。为了将请求写入连接，客户端调用 `WriteRequest` 方法。为了读取响应，客户端必须成对地调用
    `ReadResponseHeader` 和 `ReadResponseBody`。一旦读取了主体，客户端就有责任调用 `Close` 方法来关闭连接。如果将
    nil 接口传递给 `ReadResponseBody`，则应读取并丢弃响应的主体：'
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `NewServerCodec` method requires that we pass it a type that implements
    the `ReadWriteCloser` interface. As we do not have such a type passed to us as
    parameters in the `httpHandler` method we have defined our own type, `HttpConn`,
    which encapsulates the `http.Request` body, which implements `io.Reader`, and
    the `ResponseWriter` method, that implements `io.Writer`. We can then write our
    own methods that proxy the calls to the reader and writer creating a type that
    has the correct interface.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewServerCodec` 方法要求我们传递一个实现了 `ReadWriteCloser` 接口类型的参数。由于在我们的 `httpHandler`
    方法中并没有传递给我们这样的类型作为参数，因此我们定义了自己的类型 `HttpConn`，它封装了 `http.Request` 的主体，实现了 `io.Reader`
    接口，以及 `ResponseWriter` 方法，实现了 `io.Writer` 接口。然后我们可以编写自己的方法，代理对读取器和写入器的调用，创建一个具有正确接口的类型。'
- en: And that is it for our short intro to RPC with the standard libraries; we will
    see when we look at some frameworks more in depth in [Chapter 3](cfab2776-305a-417c-853f-26e4caba67d2.xhtml),
    *Introducing Docker*, how these can be used to build a production microservice.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们关于标准库中 RPC 的简短介绍，这就结束了；我们将在[第 3 章](cfab2776-305a-417c-853f-26e4caba67d2.xhtml)“介绍
    Docker”中更深入地探讨一些框架，看看这些框架是如何被用来构建生产级微服务的。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That's it for this chapter, we have just written our first microservice in Go
    and only using the standard library, you should now have an appreciation of just
    how powerful the standard library is providing us with many of the features we
    need to write RESTful and RPC-based microservices. We have also looked at encoding
    and decoding data using the `encoding/json` package and how we can create light
    weight messaging by using `gobs`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这章的内容就到这里，我们刚刚用 Go 语言编写了我们的第一个微服务，并且只使用了标准库，你现在应该已经对标准库的强大功能有了认识，它为我们提供了编写基于
    RESTful 和 RPC 的微服务所需的大部分功能。我们还探讨了使用 `encoding/json` 包进行数据编码和解码的方法，以及如何通过使用 `gobs`
    创建轻量级消息。
- en: As you progress through this book, you will see how the many, wonderful open
    source packages build on these foundations to make Go such a fantastic language
    for microservice development, and by the end of the book you will have all the
    knowledge required for successfully building microservices in Go.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读这本书的进程，你将看到许多奇妙的开源软件包是如何建立在这些基础之上，使得 Go 语言成为微服务开发的绝佳选择，并且到书的结尾，你将拥有成功使用
    Go 语言构建微服务所需的所有知识。
