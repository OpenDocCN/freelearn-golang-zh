<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Designing a Great API</h1>
                </header>
            
            <article>
                
<p>Regardless of whether you are experienced in building APIs and microservices and looking for the techniques on how you can apply them with Go or you are completely new to the world of microservices, it is worth spending the time to read this chapter.</p>
<p>Writing an API contract feels part art, part science and, when you discuss your design with other engineers, you will most certainly agree to disagree, not to the level of tabs versus spaces, but there is certainly something personal about API contracts.</p>
<p>In this chapter, we will look at the two most popular options, which are RESTful and RPC. We will examine the semantics of each approach, which will equip you with the knowledge to argue your case when the inevitable discussion (read argument) occurs. Choosing between REST or RPC may be entirely down to your current environment. If you currently have services running that implement a RESTful approach, then I suggest you stick with it, likewise if you now use RPC. One thing I would suggest is that you read the entire chapter to understand the semantics, pros, and cons of each approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RESTful APIs</h1>
                </header>
            
            <article>
                
<p>The term <strong>REST</strong> was suggested by Roy Fielding in his Ph.D. dissertation in the year 2000. It stands for <strong>Representational State Transfer</strong> and is described as:</p>
<div class="packt_quote">"REST emphasizes scalability of component interactions, generality of interfaces, independent deployment of components, and intermediary components to reduce interaction latency, enforce security and encapsulate legacy systems."</div>
<p>Having an API that conforms to the REST principles is what makes it RESTful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URIs</h1>
                </header>
            
            <article>
                
<p>One of the main components in the HTTP protocol is a URI. <strong>URI</strong> stands for <strong>Uniform Resource Identifiers</strong> and is the method by which you will access the API. You may be <span>asking</span> what the difference between a URI and a URL (Uniform Resource Locator) is? When I started to write this chapter, I wondered about this myself and did what any self-respecting developer would do, which is to head over to Stack Overflow. Unfortunately, my confusion only grew as there were lots of detailed answers, none of which I found particularly enlightening. Time to head over to the inner circle of hell also known as W3C standards to look up the RFC for the official answer.</p>
<p>In short, there is no difference, a URL is a URI that identifies a resource by its network location, and it is acceptable to interchange the terms when describing a resource entirely.</p>
<p>The clarification document published back in 2001 (<a href="http://www.w3.org/TR/uri-clarification"><span class="URLPACKT">http://www.w3.org/TR/uri-clarification</span></a>) goes on to explain that in the early to mid-90s there was an assumption that an identifier is cast into one or two classes. An identifier might specify the location of a resource (URL) or its name (Uniform Resource Name URN) independent of location. A URI could either be a URL or a URN. Using this example, <kbd>http://</kbd> would be a URL scheme and <kbd>isbn:</kbd> a URN scheme. However, this changed over time and the importance of the additional level of hierarchy lessened. The view changed that an individual scheme does not need to be cast into one of a discrete set of types.</p>
<p>The conventional approach is that <kbd>http:</kbd> is a URI scheme and <kbd>urn:</kbd> is also a URI scheme. URNs take the form <kbd>urn:isbn:n-nn-nnnnnn-n</kbd>, <kbd>isbn:</kbd> is a URN namespace identifier, not a URN scheme or a URI scheme.</p>
<p>Following this view, the term URL does not refer to a formal partition of URI space rather, URL is an informal concept; a URL is a type of URI that identifies a resource via its network location.</p>
<p>For the rest of this book, we will use the term URI and when we do we will be talking about a method to access a resource that is running on a remote server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URI format</h1>
                </header>
            
            <article>
                
<p>RFC 3986, which was published in 2005 <a href="https://www.ietf.org/rfc/rfc3986.txt"><span class="URLPACKT">https://www.ietf.org/rfc/rfc3986.txt</span></a>, defines the format that makes valid URIs:</p>
<pre>
URI = scheme "://" authority "/" path [ "?" query] ["#" fragment"] <br/>URI = http://myserver.com/mypath?query=1#document 
</pre>
<p>We are will use the path element in order to locate an endpoint that is running on our server. In a REST endpoint, this can contain parameters as well as a document location. The query string is equally important, as you will use this to pass parameters such as page number or ordering to control the data that is returned.</p>
<p>Some general rules for URI formatting:</p>
<ul>
<li>A forward slash <kbd>/</kbd> is used to indicate a hierarchical relationship between resources</li>
<li>A trailing forward slash <kbd>/</kbd> should not be included in URIs</li>
<li>Hyphens <kbd>-</kbd> should be used to improve readability</li>
<li>Underscores <kbd>_</kbd> should not be used in URIs</li>
<li>Lowercase letters are preferred as case sensitivity is a differentiator in the <kbd>path</kbd> part of a URI</li>
</ul>
<p>The concept behind many of the rules is that a URI should be easy to read and to construct. It should also be consistent in the way that it is built so you should follow the same taxonomy for all the endpoints in your API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URI path design for REST services</h1>
                </header>
            
            <article>
                
<p>Paths are broken into documents, collections, stores, and controllers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collections</h1>
                </header>
            
            <article>
                
<p>A collection is a directory of resources typically broken by parameters to access an individual document. For example:</p>
<pre>
GET /cats   -&gt; All cats in the collection <br/>GET /cats/1 -&gt; Single document for a cat 1 
</pre>
<p>When defining a collection, we should always use a plural noun such as <kbd>cats</kbd> or <kbd>people</kbd> for the collection name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Documents</h1>
                </header>
            
            <article>
                
<p>A document is a resource pointing to a single object, similar to a row in a database. It has the ability to have child resources that may be both sub-documents or collections. For example:</p>
<pre>
GET /cats/1           -&gt; Single document for cat 1 <br/>GET /cats/1/kittens   -&gt; All kittens belonging to cat 1 <br/>GET /cats/1/kittens/1 -&gt; Kitten 1 for cat 1 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controller</h1>
                </header>
            
            <article>
                
<p>A controller resource is like a procedure, this is typically used when a resource cannot be mapped to standard <strong>CRUD</strong> (<strong>create</strong>, <strong>retrieve</strong>, <strong>update</strong>, and <strong>delete</strong>) functions.</p>
<p>The names for controllers appear as the last segment in a URI path with no child resources. If the controller requires parameters, these would typically be included in the query string:</p>
<pre>
POST /cats/1/feed           -&gt; Feed cat 1 <br/>POST /cats/1/feed?food=fish -&gt;Feed cat 1 a fish 
</pre>
<p>When defining a controller name we should always use a verb. A verb is a word that indicates an action or a state of being, such as <kbd>feed</kbd> or <kbd>send</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Store</h1>
                </header>
            
            <article>
                
<p>A store is a client-managed resource repository, it allows the client to add, retrieve, and delete resources. Unlike a collection, a store will never generate a new URI it will use the one specified by the client. Take a look at the following example that would add a new cat to our store:</p>
<pre>
PUT /cats/2 
</pre>
<p>This would add a new cat to the store with an ID of <kbd>2</kbd>, if we had posted the new cat omitting the ID to a collection the response would need to include a reference to the newly defined document so we could later interact with it. Like controllers we should use a plural noun for store names.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CRUD function names</h1>
                </header>
            
            <article>
                
<p>When designing great REST URIs we never use a CRUD function name as part of the URI, instead we use a HTTP verb. For example:</p>
<pre>
DELETE /cats/1234
</pre>
<p>We do not include the verb in the name of the method as this is specified by the HTTP verb, the following URIs would be considered an anti-pattern:</p>
<pre>
GET /deleteCat/1234 <br/>DELETE /deleteCat/1234 <br/>POST /cats/1234/delete
</pre>
<p>When we look at HTTP verbs in the next section this will make more sense.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP verbs</h1>
                </header>
            
            <article>
                
<p>The commonly used HTTP verbs are:</p>
<ul>
<li><kbd>GET</kbd></li>
<li><kbd>POST</kbd></li>
<li><kbd>PUT</kbd></li>
<li><kbd>PATCH</kbd></li>
<li><kbd>DELETE</kbd></li>
<li><kbd>HEAD</kbd></li>
<li><kbd>OPTIONS</kbd></li>
</ul>
<p>Each of these methods has a well-defined semantic within the context of our REST API and the correct implementation will help your user understand your intention.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GET</h1>
                </header>
            
            <article>
                
<p>The <kbd>GET</kbd> method is used to retrieve a resource and should never be used to mutate an operation, such as updating a record. Typically, a body is not passed with a <kbd>GET</kbd> request; however, it is not an invalid <kbd>HTTP</kbd> request to do so.</p>
<p><strong>Request</strong>:</p>
<pre>
GET /v1/cats HTTP/1.1 
</pre>
<p><strong>Response</strong>:</p>
<pre>
HTTP/1.1 200 OK <br/>Content-Type: application/json <br/>Content-Length: xxxx <br/><br/>{"name": "Fat Freddie's Cat", "weight": 15} 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">POST</h1>
                </header>
            
            <article>
                
<p>The <kbd>POST</kbd> method is used to create a new resource in a collection or to execute a controller. It is typically a non-idempotent action, in that multiple posts to create an element in a collection that will create multiple elements not updated after the first call.</p>
<p>The <kbd>POST</kbd> method is always used when calling controllers as the actions of this is considered non-idempotent.</p>
<p><strong>Request</strong>:</p>
<pre>
POST /v1/cats HTTP/1.1 <br/>Content-Type: application/json <br/>Content-Length: xxxx <br/><br/>{"name": "Felix", "weight": 5} 
</pre>
<p><strong>Response</strong>:</p>
<pre>
HTTP/1.1 201 Created <br/>Content-Type: application/json <br/>Content-Length: 0 <br/>Location: /v1/cats/12343 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PUT</h1>
                </header>
            
            <article>
                
<p>The <kbd>PUT</kbd> method is used to update a mutable resource and must always include the resource locator. The <kbd>PUT</kbd> method calls are also idempotent in that multiple requests will not mutate the resource to a different state than the first call.</p>
<p><strong>Request</strong>:</p>
<pre>
PUT /v1/cats HTTP/1.1 <br/>Content-Type: application/json <br/>Content-Length: xxxx <br/><br/>{"name": "Thomas", "weight": 7 } 
</pre>
<p><strong>Response</strong>:</p>
<pre>
HTTP/1.1 201 Created <br/>Content-Type: application/json <br/>Content-Length: 0 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PATCH</h1>
                </header>
            
            <article>
                
<p>The <kbd>PATCH</kbd> verb is used to perform a partial update, for example, if we only wanted to update the name of our cat we could make a <kbd>PATCH</kbd> request only containing the details that we would like to change.</p>
<p><strong>Request</strong>:</p>
<pre>
PATCH /v1/cats/12343 HTTP/1.1 <br/>Content-Type: application/json <br/>Content-Length: xxxx <br/><br/>{"weight": 9} 
</pre>
<p><strong>Response</strong>:</p>
<pre>
HTTP/1.1 204 No Body <br/>Content-Type: application/json <br/>Content-Length: 0 
</pre>
<p>In my experience PATCH updates are rarely used, the general convention is to use a PUT and to update the whole object, this not only makes the code easier to write but also makes an API which is simpler to understand.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DELETE</h1>
                </header>
            
            <article>
                
<p>The <kbd>DELETE</kbd> verb is used when we want to remove a resource, generally we would pass the ID of the resource as part of the path rather than in the body of the request. This way, we have a consistent method for updating, deleting, and retrieving a document.</p>
<p><strong>Request</strong>:</p>
<pre>
DELETE /v1/cats/12343 HTTP/1.1 <br/>Content-Type: application/json <br/>Content-Length: 0 
</pre>
<p><strong>Response</strong>:</p>
<pre>
HTTP/1.1 204 No Body <br/>Content-Type: application/json <br/>Content-Length: 0 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HEAD</h1>
                </header>
            
            <article>
                
<p>A client would use the <kbd>HEAD</kbd> verb when they would like to retrieve the headers for a resource without the body. The <kbd>HEAD</kbd> verb is typically used in place of a <kbd>GET</kbd> verb when a client only wants to check if a resource exists or to read the metadata.</p>
<p><strong>Request</strong>:</p>
<pre>
HEAD /v1/cats/12343 HTTP/1.1 <br/>Content-Type: application/json <br/>Content-Length: 0 
</pre>
<p><strong>Response</strong>:</p>
<pre>
HTTP/1.1 200 OK <br/>Content-Type: application/json <br/>Last-Modified: Wed, 25 Feb 2004 22:37:23 GMT <br/>Content-Length: 45 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OPTIONS</h1>
                </header>
            
            <article>
                
<p>The <kbd>OPTIONS</kbd> verb is used when a client would like to retrieve the possible interactions for a resource. Typically, the server will return an <kbd>Allow</kbd> header, which will include the <kbd>HTTP</kbd> verbs that can be used with this resource.</p>
<p><strong>Request</strong>:</p>
<pre>
OPTIONS /v1/cats/12343 HTTP/1.1 <br/>Content-Length: 0 
</pre>
<p><strong>Response</strong>:</p>
<pre>
HTTP/1.1 200 OK <br/>Content-Length: 0 <br/>Allow: GET, PUT, DELETE
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URI query design</h1>
                </header>
            
            <article>
                
<p>It is perfectly acceptable to use a query string as part of an API call; however, I would refrain from using this to pass data to the service. Instead the query should be used to perform actions such as:</p>
<ul>
<li>Paging</li>
<li>Filtering</li>
<li>Sorting</li>
</ul>
<p>If we need to make a call to a controller, we discussed earlier that we should use a <kbd>POST</kbd> request as this is most likely a non-idempotent request. To pass data to the service, we should include the data inside of the body. However, we could use a query string to filter the action of the controller:</p>
<pre>
POST /sendStatusUpdateEmail?$group=admin <br/>{ <br/>  ""message": "": "All services are now operational\nPlease accept our <br/>              apologies for any inconvenience caused.\n <br/>              The Kitten API team"" <br/>} 
</pre>
<p>In the preceding example, we would send a status update email with the message included in the body of the request, because we are using the group filter passed in the query string we could restrict the action of this controller to only send to the admin group.</p>
<p>If we had added the message to the query string and not passed a message body, then we would potentially be causing two problems for ourselves. The first is that the max length for a URI is 2083 characters. The second is that generally a <kbd>POST</kbd> request would always include a request body. Whilst this is not required by the <kbd>HTTP</kbd> specification, it would be expected behavior by the majority of your users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Response codes</h1>
                </header>
            
            <article>
                
<p>When writing a great API, we should use <kbd>HTTP</kbd> status codes to indicate to the client the success or failure of the request. In this chapter, we will not be taking a comprehensive look at all the status codes available; there are many resources on the Internet that have this information. We will provide some sources for further reading, what we will do is look at the status codes that you as a software engineer will want your microservice to return.</p>
<p>Currently, it is a generally held consensus that this is good practice as it allows the client to immediately determine the status of a request without having to dive into the request body to gain further insight. In the instance of a failure and APIs that always return a <kbd>200 OK</kbd> response to the user with a message body containing further information is not good practice as it requires the client to have to inspect the body to determine outcome. It also means that the message body will contain additional information other than the object that it should represent. Consider the following bad practice:</p>
<p>Bad request body:</p>
<pre>
POST /kittens <br/>RESPONSE HTTP 200 OK <br/>{ <br/>  ""status":": 401, <br/>  ""statusMessage": "": "Bad Request"" <br/>} 
</pre>
<p>Successful request:</p>
<pre>
POST /kittens <br/>RESPONSE HTTP 201 CREATED <br/>{ <br/>  ""status":": 201, <br/>  ""statusMessage": "": "Created",", <br/>  ""kitten":": { <br/>    ""id": "": "1234334dffdf23",", <br/>    ""name": "": "Fat Freddy'sFreddy's Cat"" <br/>  } <br/>} 
</pre>
<p>Imagine if you were writing a client for the preceding request, you need to add logic to your application to check the status node in the response before you could read and process the returned kitten.</p>
<p>Now consider something even worse:</p>
<p>And even worse failure:</p>
<pre>
POST /kittens <br/>RESPONSE HTTP 200 OK <br/>{ <br/>  ""status":": 400, <br/>  ""statusMessage": "": "Bad Request"" <br/>} 
</pre>
<p>And even worse success:</p>
<pre>
POST /kittens <br/>RESPONSE HTTP 200 OK <br/>{ <br/>  ""id": "": "123434jhjh3433",", <br/>  ""name": "": "Fat Freddy'sFreddy's Cat"" <br/>} 
</pre>
<p>If your API author had done something like the preceding example, you need to check to see if the response that has been returned is an error or the kitten that you were expecting. The number of WTFs per minute you would utter whilst coding a client for this API would not endear you to its author. These might seem like extreme examples, but there are instances like this out in the wild, at some point in my career I'm fairly sure I have been guilty of such a crime, but then I had not read this book.</p>
<p>What the author in their best intention has done is try to take the HTTP status codes too literally. W3C RFC2616 states that the HTTP status code relates to the attempt to understand and satisfy the request (<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1"><span class="URLPACKT">https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1</span></a>); however, this is a little ambiguous when you look at some of the individual status codes. Modern consensus is that it is OK to use HTTP status codes to indicate the processing state of an API request not just the server's ability to process the request. Consider how we could make these requests better by implementing this approach.</p>
<p>A good example of a failure:</p>
<pre>
POST /kittens <br/>RESPONSE HTTP 400 BAD REQUEST <br/>{ <br/>  ""errorMessage": "": "Name should be between 1 and 256 characters in <br/>  length and only contain [A-Z] - ['-.]"'-.]" <br/>} 
</pre>
<p>A good example of a success:</p>
<pre>
POST /kittens <br/>RESPONSE HTTP 201 CREATED <br/>{ <br/>  ""id": "": "123hjhjh2322",", <br/>  ""name": "": "Fat Freddy'sFreddy's cat"" <br/>} 
</pre>
<p>This is far more semantic; the user only ever needs to read the response in the instance of a failure if they require further information. In addition to this we can provide a standard error object that is used across all the endpoints of our API, which provides further but non-required information to determine why a request failed. We will look at error objects in a little while, but for now let's look at HTTP status codes more in depth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">2xx Success</h1>
                </header>
            
            <article>
                
<p>2xx status codes indicate that the clients request has been successfully received and understood.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">200 OK</h1>
                </header>
            
            <article>
                
<p>This is a generic response code indicating that the request has succeeded. The response accompanying this code is generally:</p>
<ul>
<li><kbd>GET</kbd>: An, an entity corresponding to the requested resource</li>
<li><kbd>HEAD</kbd>: The, the header fields corresponding to the requested resource without the message body</li>
<li><kbd>POST</kbd>: An, an entity describing or containing the result of the action</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">201 Created</h1>
                </header>
            
            <article>
                
<p>The created response is sent when a request succeeds and the result is that a new entity has been created. Along with the response it is common that the API will return a <kbd>Location</kbd> header with the location of the newly created entity:</p>
<pre>
201 Created <br/>Location: https://api.kittens.com/v1/kittens/123dfdf111 
</pre>
<p>It is optional to return an object body with this response type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">204 No Content</h1>
                </header>
            
            <article>
                
<p>This status informs the client that the request has been successfully processed; however, there will be no message body with the response. For example, if the user makes a <kbd>DELETE</kbd> request to the collection then the response may return a 204 status.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">3xx Redirection</h1>
                </header>
            
            <article>
                
<p>The 3xx indicate class of status codes indicates that the client must take additional action to complete the request. Many of these status codes are used by CDNs and other content redirection techniques, however, code 304 can exceptionally useful when designing our APIs to provide semantic feedback to the client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">301 Moved Permanently</h1>
                </header>
            
            <article>
                
<p>This tells the client that the resource they have requested has been permanently moved to a different location. Whilst this is traditionally used to redirect a page or resource from a web server it can also be useful to us when we are building our APIs. In the instance that we rename a collection we could use a 301 redirect to send the client to the correct location. This however should be used as an exception rather than the norm. Some clients do not implicitly follow 301 redirect and implementing this capability adds additional complexity for your consumers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">304 Not Modified</h1>
                </header>
            
            <article>
                
<p>This response is generally used by a CDN or caching server and is set to indicate that the response has not been modified since the last call to the API. This is designed to save bandwidth and the request will not return a body, but will return a <kbd>Content-Location</kbd> and <kbd>Expires</kbd> header.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">4xx Client Error</h1>
                </header>
            
            <article>
                
<p>In the instance of an error caused by a client, not the server, the server will return a 4xx response and will always return an entity that gives further details on the error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">400 Bad Request</h1>
                </header>
            
            <article>
                
<p>This response indicates that the request could not be understood by the client due to a malformed request or due to a failure of domain validation (missing data, or an operation that would cause invalid state).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">401 Unauthorized</h1>
                </header>
            
            <article>
                
<p>This indicates that the request requires user authentication and will include a <kbd>WWW-Authenticate</kbd> header containing a challenge applicable to the requested resource. If the user has included the required credentials in the <kbd>WWW-Authenticate</kbd> header, then the response should include an error object that may contain relevant diagnostic information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">403 Forbidden</h1>
                </header>
            
            <article>
                
<p>The server has understood the request, but is refusing to fulfill it. This could be due to incorrect access level to a resource not that the user is not authenticated.</p>
<p>If the server does not wish to make the fact that a request is not able to access a resource due to access level public, then it is permissible to return a <kbd>404 Not found</kbd> status instead of this response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">404 Not Found</h1>
                </header>
            
            <article>
                
<p>This response indicates that the server has not found anything matching the requested URI. No indication is given of whether the condition is temporary or permanent.</p>
<p>It is permissible for the client to make multiple requests to this endpoint as the state may not be permanent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">405 Method Not Allowed</h1>
                </header>
            
            <article>
                
<p>The method specified in the request is not allowed for the resource indicated by the URI. This may be when the client attempts to mutate a collection by sending a <kbd>POST</kbd>, <kbd>PUT</kbd>, or <kbd>PATCH</kbd> to a collection that only serves retrieval of documents.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">408 Request Timeout</h1>
                </header>
            
            <article>
                
<p>The client did not produce a request within the time that the server is prepared to wait. The client may repeat the request without modification at a later time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">5xx Server Error</h1>
                </header>
            
            <article>
                
<p>Response status codes within the 500 range indicate that something has gone "Bang", the server knows this and is sorry for the situation.</p>
<p>The RFC advises that an error entity should be returned in the response explaining whether this is permanent or temporary and containing an explanation of the error. When we look at our chapter on security we will look at the recommendation about not giving too much information away in error messages as this state may have been engineered by a user in the attempt to compromise your system and by returning things such as a stack trace or other internal information with a 5xx error can actually help to compromise your system. With this in mind it is currently common that a 500 error will just return something very generic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">500 Internal Server Error</h1>
                </header>
            
            <article>
                
<p>A generic error message indicating that something did not go quite as planned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">503 Service Unavailable</h1>
                </header>
            
            <article>
                
<p>The server is currently unavailable due to temporary overloading or maintenance. There is a rather useful pattern that you can implement to avoid cascading failure in the instance of a malfunction in which the microservice will monitor its internal state and in the case of failure or overloading will refuse to accept the request and immediately signal this to the client. We will look at this pattern more in chapter xx; however, this instance is probably where you will be wanting to return a 503 status code. This could also be used as part of your health checks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP headers</h1>
                </header>
            
            <article>
                
<p>Request headers are a really important part of the HTTP request and response process and implementing a standard approach helps your users to transition from one API to another. In this sub section, we will not cover all the possible headers that you can use in your API, but we will look at the most common headers for full information on the HTTP protocol please take a look at RFC 7231 <a href="https://tools.ietf.org/html/rfc7231"><span class="URLPACKT">https://tools.ietf.org/html/rfc7231</span></a>. This document contains a comprehensive overview of the current standard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standard request headers</h1>
                </header>
            
            <article>
                
<p>Request headers provide additional information for the request and the response of your API. Think of them like metadata for the operation. They can be used to augment other data for the response that does not belong in the body itself such as the content encoding. They can also be utilized by the client to provide information that can help the server process the response. Where possible we should always use the standard headers as this gives consistency to your user and provides them with a common standard across multiple endpoints from many different vendors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization - string</h1>
                </header>
            
            <article>
                
<p>Authorization is one of the most commonly used request headers, even if you have a public read only API I advise you to ask the user to authorize their requests. By requesting that the user authorizes a request, you have the capability to perform operations such as user level logging and rate limiting. Quite often you may see authorization conducted with a custom request header such as "X-API-Authorization". I would recommend you do not use this approach as the standard Authorization header as specified by the W3C RFC 2616 (<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html"><span class="URLPACKT">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</span></a>) has all the capability we need. Many companies such as Twitter and PayPal use this header to authenticate requests let's. Let's look at a simple example from Twitter's developer documentation to see how this can be implemented:</p>
<pre>
Authorization:  <br/>        OAuth oauth_consumer_key="="xvz1evFS4wEEPTGEFPHBog",",  <br/>              oauth_nonce="="kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg",",  <br/>              oauth_signature="="tnnArxj06cWHq44gCs1OSKk%2FjLY%3D",",  <br/>              oauth_signature_method="="HMAC-SHA1",",  <br/>              oauth_timestamp="="1318622958",",  <br/>              oauth_token="="370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb",",  <br/>              oauth_version="="1.0"" 
</pre>
<p>The header is in the form of <kbd>[Authorization method] [Comma separated URL encoded values]</kbd>. This clearly informs the server that the authorization type is OAuth and the various components of this authorization follow this in a comma delaminated format. By following this standard approach you can enable your consumers to use a third-party library that implements this standard and thus save them the work of having to build a bespoke implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Date</h1>
                </header>
            
            <article>
                
<p>Timestamp of the request in RFC 3339 format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accept - content type</h1>
                </header>
            
            <article>
                
<p>The requested content type for the response, such as:</p>
<ul>
<li><kbd>application/xml</kbd></li>
<li><kbd>text/xml</kbd></li>
<li><kbd>application/json</kbd></li>
<li><kbd>text/javascript</kbd> (for JSONP)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accept-Encoding - gzip, deflate</h1>
                </header>
            
            <article>
                
<p>REST endpoints should always support gzip and deflate encoding, when applicable.</p>
<p>Implementing gzip support in Go is relatively straightforward; we showed how it is possible to implement middleware into your microservices in <a href="ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Introduction to Microservices</em>. In the following example, we will use this technique to create a gzip response writer.</p>
<p>The core of writing a response in a gzipped format is the <kbd>compress/gzip</kbd> package, which is part of the standard library. It allows you to create a <kbd>Writer</kbd> interface that implements <kbd>ioWriteCloser</kbd> wrapping an existing <kbd>io.Writer</kbd>, which writes to the given writer using the gzip compression:</p>
<pre>
func NewWriter(w io.Writer) *Writer 
</pre>
<p>To create our handler we are going to write the <kbd>NewGzipHandler</kbd> function, this returns a new <kbd>http.Handler</kbd> that will wrap our standard output handler.</p>
<p>The first thing we need to do is create our own <kbd>ResponseWriter</kbd> that embeds <kbd>http.ResponseWriter</kbd>.</p>
<p>Example 2.1 <kbd>chapter2/gzip/gzip_deflate.go</kbd>:</p>
<pre>
68 type GzipResponseWriter struct { <br/>69   gw *gzip.Writer <br/>70   http.ResponseWriter <br/>71} 
</pre>
<p>The core method for this is the implementation of the <kbd>Write</kbd> method:</p>
<pre>
73 func (w GzipResponseWriter) Write(b []byte) (int, error) { <br/>74   if _, ok := w.Header()["()["Content-Type"];"]; !ok { <br/>75     // If content type is not set, infer it from the uncompressed body. <br/>76   w.Header().Set("("Content-Type",", http.DetectContentType(b)) <br/>77   } <br/>78   return w.gw.Write(b) <br/>79 } 
</pre>
<p>If you look at the implementation for <kbd>Write</kbd> in the standard <kbd>http.Response</kbd> struct there is a whole load of stuff going on in there that we neither want to lose or re-implement because the <kbd>gzip.Writer</kbd> object is created with a writer when we call <kbd>Write</kbd> on it, it then in turn calls write on <kbd>http.Response</kbd> and we lose none of the complexity.</p>
<p>Internally in our <kbd>NewGzipHandler</kbd> our handler checks to see if the client has sent the <kbd>Accept-Encoding</kbd> header and if so we will write the response using the <kbd>GzipResponseWriter</kbd> method if the client has requested uncompressed content then we only call <kbd>ServeHttp</kbd> with the standard <kbd>ResponseWriter</kbd>:</p>
<pre>
40 type GZipHandler struct { <br/>41  next http.Handler <br/>42 } <br/>43 <br/>44 func (h *GZipHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { <br/>45  encodings := r.Header.Get("("Accept-Encoding")") <br/>46 <br/>47  if strings.Contains(encodings, ""gzip")") { <br/>48      h.serveGzipped(w, r) <br/>49  } else if strings.Contains(encodings, ""deflate")") { <br/>50      panic("("Deflate not implemented")") <br/>51  } else { <br/>52      h.servePlain(w, r) <br/>53  } <br/>54 } <br/>55 <br/>56 func (h *GZipHandler) serveGzipped(w http.ResponseWriter, r *http.Request) { <br/>57  gzw := gzip.NewWriter(w) <br/>58  defer gzw.Close() <br/>59 <br/>60  w.Header().Set("("Content-Encoding", "", "gzip")") <br/>61  h.next.ServeHTTP(GzipResponseWriter{gzw, w}, r) <br/>62 } <br/><br/>63 func (h *GZipHandler) servePlain(w http.ResponseWriter, r *http.Request) 64 { <br/>65  h.next.ServeHTTP(w, r) <br/>66 } 
</pre>
<p>This is by no means a comprehensive example and there are many open source packages like the one from the team at the NY Times (<a href="https://github.com/NYTimes/gziphandler"><span class="URLPACKT">https://github.com/NYTimes/gziphandler</span></a>), which manages this for you.</p>
<p>As a little programming test, why not try and modify this example to implement <kbd>DEFLATE</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standard response headers</h1>
                </header>
            
            <article>
                
<p>All services should return the following headers.</p>
<ul>
<li><kbd>Date</kbd>: The date that the request was processed in RFC 3339 format.</li>
<li><kbd>Content-Type</kbd>: The content type of the response.</li>
<li><kbd>Content-Encoding</kbd>: gzip or deflate.</li>
<li><kbd>X-Request-ID</kbd>/<kbd>X-Correlation-ID</kbd>: Whilst you may not directly request your clients to implement this header it may be something that you add to requests when you call downstream services. When you are trying to debug a service that is running in production it can be incredibly useful to be able to group all the requests by a single transaction ID. A common practice that we will see when we look at logging and monitoring is to store all logs in a common database such as Elastic Search. By setting the standard way of working when building many connected microservices that they pass the correlation ID with each downstream call you will be able to query your logs in Kibana or another log query tool and group them into a single transaction:</li>
</ul>
<pre>
        X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Returning errors</h1>
                </header>
            
            <article>
                
<p>In the instance of failure, users of your API should be able to write one piece of code that handles errors across different endpoints. A standard error entity will help your consumers by enabling them to write DRY code whenever an error caused by client or server occurs.</p>
<p>The Microsoft API guidelines recommend the following format for these entities:</p>
<pre>
{ <br/>  ""error":": { <br/>    ""code": "": "BadArgument",", <br/>    ""message": "": "Previous passwords may not be reused",", <br/>    ""target": "": "password",", <br/>    ""innererror":": a { <br/>      ""code": "": "PasswordError",", <br/>  ""innererror":": { <br/>    ""code": "": "PasswordDoesNotMeetPolicy",", <br/>    ""minLength": "": "6",", <br/>    ""maxLength": "": "64",", <br/>    ""characterTypes": ["": ["lowerCase","","upperCase","","number","","symbol"],"], <br/>    ""minDistinctCharacterTypes": "": "2",", <br/>    ""innererror":": { <br/>      ""code": "": "PasswordReuseNotAllowed"" <br/>    } <br/>      } <br/>    } <br/>  } <br/>} 
</pre>
<p><strong>ErrorResponse</strong>: <strong>Object</strong></p>
<p>The <kbd>ErrorResponse</kbd> is the top level object which will be returned by our response and contains the following fields:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Type</strong></p>
</td>
<td>
<p><strong>Required</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>error</p>
</td>
<td>
<p>Error</p>
</td>
<td>
<p><img height="20" width="20" src="assets/e2f574a5-74e7-43c1-a797-49375f0cbcc0.png"/></p>
</td>
<td>
<p>The error object.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Error: Object</strong></p>
<p>The <kbd>Error</kbd> object is the detail for our error response; it provides full detail for the reason that the error occurred:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Type</strong></p>
</td>
<td>
<p><strong>Required</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Code</p>
</td>
<td>
<p><kbd>String</kbd> (enumerated)</p>
</td>
<td>
<p><img height="21" width="21" src="assets/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png"/></p>
</td>
<td>
<p>One of a server-defined set of error codes.</p>
</td>
</tr>
<tr>
<td>
<p>message</p>
</td>
<td>
<p>String</p>
</td>
<td>
<p><img height="23" width="23" src="assets/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png"/></p>
</td>
<td>
<p>A human-readable representation of the error.</p>
</td>
</tr>
<tr>
<td>
<p>Target</p>
</td>
<td>
<p>String</p>
</td>
<td>-</td>
<td>
<p>The target of the error.</p>
</td>
</tr>
<tr>
<td>
<p>Details</p>
</td>
<td>
<p>Error[]</p>
</td>
<td>-</td>
<td>
<p>An array of details about specific errors that led to this reported error.</p>
</td>
</tr>
<tr>
<td>
<p>innererror</p>
</td>
<td>
<p>InnerError</p>
</td>
<td>-</td>
<td>
<p>An object containing more specific information than the current object about the error.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>InnerError</strong>: <strong>Object</strong></p>
<table>
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Type</strong></p>
</td>
<td>
<p><strong>Required</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Code</p>
</td>
<td>
<p>String</p>
</td>
<td>-</td>
<td>
<p>A more specific error code than was provided by the containing error.</p>
</td>
</tr>
<tr>
<td>
<p>innererror</p>
</td>
<td>
<p>InnerError</p>
</td>
<td>-</td>
<td>
<p>An object containing more specific information than the current object about the error.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Microsoft has provided an excellent API guidelines resource, you can read more about returning errors by looking at the following link:</p>
<p><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors"><span class="URLPACKT">https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing APIs from JavaScript</h1>
                </header>
            
            <article>
                
<p>Web browsers implement a sandbox mechanism that restricts resources in one domain from accessing resources in another. For example, you may have an API that allows the modification and retrieval of user data and a website that provides an interface for this API. If the browser did not implement the "same-origin policy" and assuming the user did not log out of their session then it would be possible for a malicious page to send a request to the API and modify it without you knowing.</p>
<p>To get around this, there are two methods that can be implemented by your microservice to allow this access, <strong>JSONP</strong> which stands for (<strong>JSON with Padding</strong>) and <strong>CORS</strong> (<strong>Cross-Origin Resource Sharing</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSONP</h1>
                </header>
            
            <article>
                
<p>JSONP is pretty much a hack, and it is implemented by most browsers that do not implement the later CORS standard. It is restricted to <kbd>GET</kbd> requests only and works by getting round the issue that while <kbd>XMLHTTPRequest</kbd> is blocked from making requests to third-party servers, there are no restrictions on HTML script elements.</p>
<p>A JSONP request inserts a <kbd>&lt;script src="..."&gt;</kbd> element into the browsers DOM with the API's URI as the <kbd>src</kbd> target. This component returns a function call with the JSON data as a parameter, and when this loads, the function executes passing the data to the callback.</p>
<p>JavaScript callback is defined in the code:</p>
<pre>
function success(data) { <br/>  alert(data.message); <br/>} 
</pre>
<p>This is the response from the API call:</p>
<pre>
success({"({"message":"":"Hello World"})"}) 
</pre>
<p>To denote a request for data to be returned as JSONP, generally the <kbd>callback=functionName</kbd> parameter is added to the URI, in our example this would be <kbd>/helloworld?callback=success</kbd>. Implementing this is particularly straightforward let's take a look at our simple Go <kbd>helloworld</kbd> example and see how we can modify this to implement JSONP.</p>
<p>One thing to note is the <kbd>Content-Type</kbd> header that we are returning. We are no longer returning <kbd>application/json</kbd> as we are not returning JSON we are actually returning JavaScript so we must set the <kbd>Content-Type</kbd> header accordingly:</p>
<pre>
Content-Type: application/javascript 
</pre>
<p>Example <kbd>chapter2/jsonp/jsonp.go</kbd>:</p>
<p>Let's take a quick look at an example of how we can send JSONP with Go, our response object is going to be exactly the same as the ones in <a href="ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Introduction to Microservices</em>:</p>
<pre>
18 type helloWorldResponse struct { <br/>19  Message string `json:":"message"`"` <br/>20 } 
</pre>
<p>The difference is all in the handler, if we look at line <strong>30</strong> we are checking to see if there is a callback parameter in the query string. This would be provided by the client and indicates the function they expect to be called when the response is returned:</p>
<pre>
23 func helloWorldHandler(w http.ResponseWriter, r *http.Request) { <br/>24  response := helloWorldResponse{Message: ""HelloWorld"}"} <br/>25  data, err := json.Marshal(response) <br/>26  if err != nil { <br/>27    panic("("Ooops")") <br/>28 } <br/>29 <br/>30  callback := r.URL.Query().Get("("callback")") <br/>31  if callback != """" { <br/>32    r.Headers().Add("("Content-Type", "", "application/javascript")") <br/>33    fmt.Fprintf(w, "%"%s(%s)",)", callback, string(data)) <br/>34  } else { <br/>35    fmt.Fprint(w, string(data)) <br/>36  } <br/>37 } 
</pre>
<p>To return our response in JSONP format all we need to do is wrap the standard response to a JavaScript function call. In line <strong>33</strong>, we are taking the callback function name that was passed by the client and encapsulating the response we would normally send. The resultant output would look something like this:</p>
<p><strong>Request</strong>:</p>
<pre>
GET /helloworld?callback=hello 
</pre>
<p><strong>Response</strong>:</p>
<pre>
hello({"message":"Hello World"})  
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CORS</h1>
                </header>
            
            <article>
                
<p>Assuming your users are using a desktop browser that has been released in the last five years, or a mobile browser such as iOS 9 or Android 4.2+, then implementing CORS will be more than enough. <a href="http://caniuse.com/#feat=cors"><span class="URLPACKT">http://caniuse.com/#feat=cors</span></a> says that it is over 92% of all Internet users. I was looking forward to bashing IE for the lack of full adoption; however, since this has been supported since IE8 I will have to complain about mobile users.</p>
<p>CORS is a W3C proposal to standardize cross-origin requests from the browser. It works by the browsers built in <kbd>HTTP</kbd> client making an <kbd>OPTIONS</kbd> request to a URI before the real request.</p>
<p>If the server at the other end returns a header that contains the origin of the domain from which the script is being loaded, then the browser will trust the server and will allow a cross-site request to be made:</p>
<pre>
Access-Control-Allow-Origin: origin.com 
</pre>
<p>Implementing this in Go is quite straightforward and we could create a middleware to globally manage this for us. For simplicity, in our example we have hard coded this into the handler:</p>
<p>Example 2.2 <kbd>chapter2/cors/cors.go</kbd></p>
<pre>
25 if r.Method == ""OPTIONS"" { <br/>26  w.Header().Add("("Access-Control-Allow-Origin", "*")", "*") <br/>27  w.Header().Add("("Access-Control-Allow-Methods", "", "GET")") <br/>28  w.WriteHeader(http.StatusNoContent) <br/>29  return <br/>30 }  
</pre>
<p>In line <strong>25</strong>, we detect if the request method is <kbd>OPTIONS</kbd> and instead of returning the response we return the <kbd>Access-Control-Allow-Origin</kbd> header that the client is expecting. In our example, we are simply returning <kbd>\*</kbd>, which means all domains are allowed to interact with this API. This is not the safest implementation and quite often you will request your API users to register the domains that will be interacting with the API and restrict the <kbd>Allow-Origin</kbd> to only include those domains. In addition to the <kbd>Allow-Origin</kbd> header we are also returning the following:</p>
<pre>
Access-Control-Allow-Methods: GET 
</pre>
<p>This tells the browser that it can only make <kbd>GET</kbd> requests to this URI and that it is forbidden to make <kbd>POST</kbd>, <kbd>PUT</kbd>, and so on. This is an optional header, but it can be used to enhance your user's security when interacting with the API. One thing to note is that we are not sending back a <kbd>200 OK</kbd> response we are using <kbd>204 No Content</kbd> since it is invalid to return a body with an <kbd>OPTIONS</kbd> request.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RPC APIs</h1>
                </header>
            
            <article>
                
<p>RPC stands for remote procedure call; it is a method of executing a function or method on a remote machine. RPC has been around since the dawn of time and there are many different types of RPC technology some of which relies on there being an interface definition (SOAP, Thrift Protocol Buffers). This interface definition can make it easier to generate client and server stubs for different technology stacks. Generally, the interface is defined using a <strong>DSL</strong> (<strong>domain specific language</strong>) and a generator program will use this to create application clients and servers.</p>
<p>Where REST needs to use HTTP as a transport layer, RPC is not bound by this constraint, and while it is possible to send RPC calls over HTTP, you can use the lightness of TCP or even UDP sockets if you choose to.</p>
<p>RPC has seen a resurgence in use lately with many large-scale systems built by the likes of Uber, Google, Netflix, and so on are using RPC. Due to the speed and performance that you can get from the lower latency from not using HTTP and the smaller message size attained by implementing a binary message format rather than JSON or XML.</p>
<p>The detractors of RPC mention the tight coupling that can occur between the client and the server in that if you update the contract on the server then all the clients need to be updated too. With many modern RPC implementations this is less of a problem and in fact is no less a problem than you can have with RESTful APIs. Whilst old technology such as JMI was tightly bound, requiring the client and the server to share the same interface, modern implementations such as Protocol Buffers marshal the object sensibly and will not throw an error should there be minor differences. Thus by following the standard guidelines in the <em>Versioning APIs</em> section you have no less a problem than if you were implementing a RESTful API.</p>
<p>One of the benefits of RPC is that you can quickly generate a client for your users, this allows an abstraction from both the transport and the message type and allows them to depend upon an interface. As the creator you can change the underlying implementation of your application such as a move from Thrift to Proto buffers, without requiring the client to do anything other than use the latest version of your provided client. Versioning also allows you to retain the same backward compatibility that you can achieve with REST.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RPC API design</h1>
                </header>
            
            <article>
                
<p>Some of the principles we have just discussed for creating a good RESTful API can also apply to RPC. However; one of the main differences is that you may not be using HTTP as your transport; therefore you are not always going to be able to use HTTP status codes as an indicator of success or failure. <strong>RPC</strong> stands for <strong>Remote Procedure Call</strong> and dates way back before the Internet. It was originally conceived as a way to execute a procedure that could be running in a separate application on the same machine or even potentially on the network. While we take this for granted now, back in the 90s this was cutting edge. Unfortunately, frameworks such as CORBA and Java RMI gave RPC a bad name and even now if you speak to an opponent of RPC they will most likely bring these two frameworks up. The benefits, however, were performance, using binary serialization is incredibly efficient on the network and we no longer have the tight coupling that RMI and CORBA enforced. We are also not trying to do anything too clever; we are no longer attempting to share an object across two processes we are taking a more functional approach, that is, methods that return immutable objects. This gives us the best of both worlds; the simplicity of interoperation and the speed and small payload of binary messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RPC message frameworks</h1>
                </header>
            
            <article>
                
<p>These days we are no longer coupled to having the same interface implementation on both the client and the server, this would not adhere to our mantra of independently versionable and deployable. Thankfully frameworks are more flexible we can take the same approach as we do with REST, it is OK to add, however, removing elements or changing the signatures of a method must trigger a version update.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gob</h1>
                </header>
            
            <article>
                
<p>We have already looked at gob in the previous chapter but as a quick re-cap, the gob format was specifically designed to facilitate Go to Go-based communication and was structured around the idea of something easier to use and possibly more efficient than the likes of protocol buffers, this comes at a cost of cross-language communication.</p>
<p><strong>gob object definition:</strong></p>
<pre>
type HelloWorldRequest struct {<br/>  Name string<br/>}
</pre>
<p>More information about gob can be found in the Go documentation at <a href="https://golang.org/pkg/encoding/gob/">https://golang.org/pkg/encoding/gob/</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thrift</h1>
                </header>
            
            <article>
                
<p>The Thrift framework was created by Facebook and was open sourced in 2007. It is currently maintained by the Apache Software Foundation. The main aims of Thrift are:</p>
<ul>
<li><strong>Simplicity</strong>: Thrift code is straightforward and approachable, free of unnecessary dependencies</li>
<li><strong>Transparency</strong>: Thrift conforms to the most common idioms in all languages</li>
<li><strong>Consistency</strong>: Niche, language-specific features belong in extensions, not in the core library</li>
<li><strong>Performance</strong>: Strive for performance first, elegance second</li>
</ul>
<p>This is a thrift service definition:</p>
<pre>
struct User { <br/>  1: string name, <br/>  2: i32 id, <br/>  3: string email <br/>} <br/><br/>struct Error { <br/>  1: i32 code, <br/>  2: string detail <br/>} <br/><br/>service Users { <br/>  Error createUser(1: User user) <br/>} 
</pre>
<p>Find more information on Apache Thrift at <a href="https://thrift.apache.org"><span class="URLPACKT">https://thrift.apache.org</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protocol Buffers</h1>
                </header>
            
            <article>
                
<p>Protocol Buffers are a Google product, and they have just entered their third revision. Protocol Buffers take the approach of providing a DSL that the generator (written in C) reads and can generate client and server stubs for over ten languages, the primary ten are maintained by Google and encompass: Go, Java, C, JavaScript for NodeJS.</p>
<p>Protocol Buffers is a pluggable architecture, so it is possible to write your own plugins to generate all kinds of endpoints not just RPC; however, RPC is the main use case as they are coupled to the gRPC framework.</p>
<p>gRPC was designed by Google to be a fast and language agnostic RPC framework, which originated from an internal project where latency and speed were of the utmost importance in Google's architecture. By default, gRPC uses protocol buffers as the method for serializing and de-serializing structured data. An example of this DSL is shown in the following example.</p>
<p>Protocol buffer service definition:</p>
<pre>
service Users { <br/>  rpc CreateUser (User) returns (Error) {} <br/>} <br/><br/>message User { <br/>  required string name = 1; <br/>  required int32 id = 2; <br/>  optional string email = 3; <br/>} <br/><br/>message Error { <br/>  optional code int32 = 1 <br/>  optional detail string = 2 <br/>} 
</pre>
<p>Find more information on Protocol Buffers at <a href="https://developers.google.com/protocol-buffers/"><span class="URLPACKT">https://developers.google.com/protocol-buffers/</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON-RPC</h1>
                </header>
            
            <article>
                
<p>JSON-RPC is an attempt at a standard way of representing objects for RPC using JSON. This removes the need to decode any proprietary binary protocol at the expense of transfer speed. There is no requirement for any particular client or server to serve this data format, TCP sockets, and the ability to write strings that pretty much most all programming languages can manage are all you require.</p>
<p>Unlike Thrift and Protocol Buffers, JSON-RPC sets the standard for the message serialization.</p>
<p>JSON-RPC implements some nice features that allow the batching of requests; every request contains an <kbd>id</kbd> parameter, which is established by the client. When the server responds it will return the same identifier allowing the client to understand to which request a response relates.</p>
<p>This is a JSON-RPC serialized request:</p>
<pre>
{<br/>  "jsonrpc": "2.0", <br/>  "method": "": "Users.v1.CreateUser",<br/>  "params": {<br/>    "name": "Nic Jackson", <br/>    "id": 12335432434<br/>  }, <br/>  "id": 1<br/>} 
</pre>
<p>This is a JSON-RPC serialized response:</p>
<pre>
{<br/>  "jsonrpc": "2.0", <br/>  "result": {...}, <br/>  "id":": 1<br/>} 
</pre>
<p>Find more information on JSON-RPC 2.0 at <a href="http://www.jsonrpc.org/specification"><span class="URLPACKT">http://www.jsonrpc.org/specification</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering</h1>
                </header>
            
            <article>
                
<p>When we looked at RESTful APIs we discussed the concept of using the query string to perform filtering actions such as:</p>
<ul>
<li>Paging</li>
<li>Filtering</li>
<li>Sorting</li>
</ul>
<p>Obviously, if we are writing an RPC API, we do not have the luxury of a query string; however, implementing these concepts is incredibly useful. As long as we are consistent there is no reason at all that we cannot define a parameter on our request object for the filter condition:</p>
<pre>
{<br/> "jsonrpc": "2.0", <br/> "method": "": "Users.v1.GetUserLog",<br/> "params": {<br/>   "name": "Nic Jackson", <br/>   "id": 12335432434,<br/>   "filter": { <br/>     "page_start":": 1,  //optional <br/>     "page_size"" : 10,  //optional <br/>     "sort": "name DESC" //optional <br/>   },<br/> "id": 1<br/>}
</pre>
<p>This is just an example and you will probably choose to implement something specific to your own needs, however, the key is consistency. If we use this same object for every method, we can be reasonably sure that our users will be cool with this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning APIs</h1>
                </header>
            
            <article>
                
<p>API versioning is something you should think about from the very beginning and avoid as long as you can. In general, you will need to make changes to your API, however, having to maintain <em>n</em> different versions can be a royal pain in the backside, so doing the upfront design thinking at the beginning can save you a whole load of trouble.</p>
<p>Before we look at how you can version your API, which is quite straightforward let's look at when you should version.</p>
<p>You would increment your API version number when you introduce a breaking change.</p>
<p>Breaking changes include:</p>
<ul>
<li>Removing or renaming APIs or API parameters</li>
<li>Changing the type of an API parameter, for example, from integer to string</li>
<li>Changes to response codes, error codes, or fault contracts</li>
<li>Changes to the behavior of an existing API</li>
</ul>
<p>Things that do not involve a breaking change include:</p>
<ul>
<li>Adding parameters to a returned entity</li>
<li>Adding additional endpoints or functionality</li>
<li>Bug fixes or other maintenance that does not include items in the breaking changes list</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Semantic versioning</h1>
                </header>
            
            <article>
                
<p>Microservices should implement the Major versioning scheme. Quite often, designers will elect to only implement a Major version number and imply <kbd>.0</kbd> for the minor version as according to the semantic versioning principles <a href="http://semver.org"><span class="URLPACKT">http://semver.org</span></a> a Minor version would generally indicate the addition of functionality that has been implemented in a backwards compatible way. This could be adding additional endpoints to your API. It can be argued that since this would not affect the client's ability to interact with your API you should not worry about Minor versions and only concentrate on major as the client will not need to request a particular version without these additions in order to function.</p>
<p>When versioning APIs I think it is cleaner to drop the minor version and only concentrate on major version. We would take this approach for two reasons:</p>
<ul>
<li>The URI becomes more readable, and dots are only used as network location separators. When using an RPC API dots are only used to separate <kbd>API.VERSION.METHOD</kbd> and make everything easier to read.</li>
<li>We should be inferring through our API versioning that change is a big thing and has an impact on the function of the client. Internally we can still use <kbd>Major.Minor</kbd>; however, this does not need to be something to the client as they will not have the capability to elect to use minor versions of the API.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning formats for REST APIs</h1>
                </header>
            
            <article>
                
<p>To allow the client to request a particular API version, there are three common ways you can do this.</p>
<p>It can be done as part of the URI:</p>
<pre>
https://myserver.com/v1/helloworld 
</pre>
<p>It can also be done as a query string parameter:</p>
<pre>
https://myserver.com/helloworld?api-version=1 
</pre>
<p>Finally, It can be done by using a custom HTTP header:</p>
<pre>
<span>GET https://myserver.com/helloworld<br/></span><span>api-version: 2</span>
</pre>
<p>Whichever way you implement versioning is up to you and your team, but it should play a big part in your upfront design thinking. Once you have decided on an option stick, to it as providing a consistent and great experience for your consumers should be one of your primary goals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning formats for RPC APIs</h1>
                </header>
            
            <article>
                
<p>Versioning RPC can be a little more difficult as most likely you are not using HTTP as your transport. However, this is still possible. The best way to deal with this is the namespace of your handlers.</p>
<p>In the go base packages, you have the capability to give your handler a name, <kbd>Greet.v1.HelloWorld</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Naming for RPC</h1>
                </header>
            
            <article>
                
<p>With RPC you do not have the luxury of using HTTP verbs to confer the intent of the API, for example, you have the collection users. With an HTTP API you would be able to split up the various actions using <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>DELETE</kbd>, and so on. This is not possible with an RPC API and you need to think in the same way as if you were writing methods inside your Go code, so for example:</p>
<pre>
GET /v1/users 
</pre>
<p>The preceding code might be written as an RPC method as follows:</p>
<pre>
Users.v1.Users <br/>GET /v1/users/123434 
</pre>
<p>Alternatively, it might be written as an RPC method as follows:</p>
<pre>
Users.v1.User 
</pre>
<p>Sub collections become a little less semantic, whereas in a RESTful API you would be able to do the following:</p>
<pre>
GET /v1/users/12343/permissions/1232 
</pre>
<p>You cannot do this with an RPC API and you must explicitly specify the method as a separate entity:</p>
<pre>
Permissions.v1.Permission 
</pre>
<p>The method name also needs to infer the action that the API is going to perform; you cannot rely on the use of HTTP verbs, so in the instance that you have a method that can delete a user you would have to add the delete verb into the method call, for example:</p>
<pre>
DELETE /v1/users/123123 
</pre>
<p>The preceding code would become:</p>
<pre>
Users.v1.DeleteUser 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object type standardization</h1>
                </header>
            
            <article>
                
<p>Whether you are using custom binary serialization, JSON, or JSON-RPC you need to think about how your user is going to handle the object at the other side of the transaction. Many of the serialization packages Protocol Buffers such as protocol buffers and Thrift that use stubs to generate client code will happily deal with serialization of simple types such as Dates into native types that enable your consumer to easily use and manipulate these objects. However, if you are using JSON or JSON-RPC there is no concept of a Date as a native type therefore it can be useful to fall back to ISO standards which the user of the client can easily deserialize. The Microsoft API design guidelines provide some good advice on how to handle Dates and Durations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dates</h1>
                </header>
            
            <article>
                
<p>When returning a date, you should always use the <kbd>DateLiteral</kbd> format and preferably the <kbd>Iso8601Literal</kbd>. If you do need to send back a date in a format other than <kbd>Iso8601Literal</kbd>, then you can use a <kbd>StructuredDateLiteral</kbd> format, which allows you to specify the kind as part of the returned entity.</p>
<p>The informal <kbd>Iso8601Literal</kbd> format is the simplest method to use and should be understandable by almost any client consuming your API:</p>
<pre>
{"date": "2016-07-14T16:00Z"} 
</pre>
<p>The more formal <kbd>StucturedDateLiteral</kbd> does not return a string, but an entity that contains two properties, <kbd>kind</kbd> and <kbd>value</kbd>:</p>
<pre>
{"date": {"kind": "U", "value": 1471186826}} 
</pre>
<p>The permissible kinds are:</p>
<ul>
<li><kbd>C</kbd>: <strong>CLR</strong>; number of milliseconds since midnight January 1 00</li>
<li><kbd>E</kbd>: <strong>ECMAScript</strong>; number of milliseconds since midnight, January 1, 1970</li>
<li><kbd>I</kbd>: <strong>ISO 8601</strong>; a string limited to the ECMAScript subset</li>
<li><kbd>O</kbd>: <strong>OLE Date</strong>; integral part is the number of days since midnight, December 31, 1899, and fractional part is the time within the day (0.5 = midday)</li>
<li><kbd>T</kbd>: <strong>Ticks</strong>; number of ticks (100-nanosecond intervals) since midnight January 1, 1601</li>
<li><kbd>U</kbd>: <strong>UNIX</strong>; number of seconds since midnight, January 1, 1970</li>
<li><kbd>W</kbd>: <strong>Windows</strong>; number of milliseconds since midnight January 1, 1601</li>
<li><kbd>X</kbd>: <strong>Excel</strong>; as for O, but the year 1900 is incorrectly treated as a leap year, and day 0 is "January 0 (zero)"</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Durations</h1>
                </header>
            
            <article>
                
<p>Durations are serialized to conform with ISO 8601 and are represented by the following format:</p>
<pre>
P[n]Y[n]M[n]DT[n]H[n]M[n]S 
</pre>
<ul>
<li><kbd>P</kbd>: This is the duration designator (historically called "period") placed at the start of the duration representation</li>
<li><kbd>Y</kbd>: This is the year designator that follows the value for the number of years</li>
<li><kbd>M</kbd>: This is the month designator that follows the value for the number of months</li>
<li><kbd>W</kbd>: This is the week designator that follows the value for the number of weeks</li>
<li><kbd>D</kbd>: This is the day designator that follows the value for the number of days</li>
<li><kbd>T</kbd>: This is the time designator that precedes the time components of the representation</li>
<li><kbd>H</kbd>: This is the hour designator that follows the value for the number of hours</li>
<li><kbd>M</kbd>: This is the minute designator that follows the value for the number of minutes</li>
<li><kbd>S</kbd>: This is the second designator that follows the value for the number of seconds</li>
</ul>
<p>For example, <kbd>P3Y6M4DT12H30M5S</kbd> represents a duration of "three years, six months, four days, twelve hours, thirty minutes, and five seconds".</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Intervals</h1>
                </header>
            
            <article>
                
<p>Again part of the ISO 8601 specification is if you need to receive or send an interval you can use the following format:</p>
<ul>
<li>Start and end, such as <kbd>2007-03-01T13:00:00Z/2008-05-11T15:30:00Z</kbd></li>
<li>Start and duration, such as <kbd>2007-03-01T13:00:00Z/P1Y2M10DT2H30M</kbd></li>
<li>Duration and end, such as <kbd>P1Y2M10DT2H30M/2008-05-11T15:30:00Z</kbd></li>
<li>Duration only, such as <kbd>P1Y2M10DT2H30M</kbd>, with additional context information</li>
</ul>
<p>Find more information on JSON serialization of dates and times at <a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times"><span class="URLPACKT">https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Documenting APIs</h1>
                </header>
            
            <article>
                
<p>Documenting APIs is incredibly useful whether you intend the API to be consumed internally by other teams in your company, external users, or even only yourself. You will thank yourself for spending the time to document the operations of the API and keep this up to date. Keeping documentation up to date should not be an arduous task. There are many applications that can generate documentation automatically from your source code, so all you need to do is run this application as part of your build workflow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST based-based APIs</h1>
                </header>
            
            <article>
                
<p>Currently three primary standards are fighting it out to become the queen of REST API documentation:</p>
<ul>
<li>Swagger</li>
<li>API Blueprint</li>
<li>RAML</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger</h1>
                </header>
            
            <article>
                
<p>Swagger was designed by SmartBear and has been chosen to be part of the Open API Initiative; this potentially gives it the greatest chance of adoption as a standard for documenting RESTful APIs. The Open API Initiative (<a href="https://openapis.org"><span class="URLPACKT">https://openapis.org</span></a>) however is an industry body and whether it gains the recognition that the W3C has around web standards is probably dependent on more big names joining.</p>
<p>Documentation is written in YAML, and various code generation tools can both write Swagger documentation from source code as well as being able to generate client SDKs. The standard is comprehensive in its feature list and is also relatively simple to write as well as being well understood by the developer community.</p>
<p>The code example of Swagger is shown as follows:</p>
<pre>
/pets: <br/>  get: <br/>    description: Returns all pets from the system that the user has access to <br/>    produces: <br/>      - application/json <br/>    responses: <br/>      '200''200': <br/>        description: A list of pets. <br/>  schema: <br/>    type: array <br/>    items: <br/>      $ref: ''#/definitions/Pet'Pet' <br/><br/>definitions: <br/>  Pet: <br/>    type: object <br/>    properties: <br/>      name: <br/>  type: string <br/>    description: name of the pet 
</pre>
<p>Find more information on Swagger at <a href="http://swagger.io"><span class="URLPACKT">http://swagger.io</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API Blueprint</h1>
                </header>
            
            <article>
                
<p>API Blueprint is an open standard designed by Apiary and released under the MIT license. It ties closely into Apiary's products. However, it can be used on its own, and there are a variety of open source tools that read and write the format.</p>
<p>Documentation is written in Markdown, which can make authoring the documentation feel a little more natural rather than dealing with nested layers of objects.</p>
<p>The code example for API Blueprint is shown as follows:</p>
<pre>
FORMAT: 1A <br/><br/># Data Structures <br/><br/>## Pet (object) <br/>+ name: Jason (string) - Name of the pet. <br/><br/># Pets [/pets] <br/><br/>Returns all pets from the system that the user has access to'to' <br/><br/>## Retrieve all pets [GET] <br/>+ Response 200 (application/json) <br/>+ Attributes (array[Pet]) 
</pre>
<p>Find more information on API Blueprint at <a href="https://apiblueprint.org"><span class="URLPACKT">https://apiblueprint.org</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RAML</h1>
                </header>
            
            <article>
                
<p><strong>RAML</strong> stands for <strong>RESTful API Modelling Language</strong> and is written in <kbd>YAML</kbd> format. It aims to allow the definition of a human-readable format that describes resources, methods, parameters, responses, media types, and other HTTP constructs that form the basis of your API.</p>
<p>The code example for RAML is shown as follows:</p>
<pre>
#%RAML 1.0 <br/>title: Pets API <br/>mediaType: [ application/json] <br/>types: <br/>  Pet: <br/>    type: object <br/>    properties: <br/>      name: <br/>        type: string <br/>        description: name of the pet <br/>/pets: <br/>  description: Returns all pets from the system that the user has access to <br/>  get: <br/>    responses: <br/>      200: <br/>        body: Pet[] 
</pre>
<p>Find more information on RAML at <a href="http://raml.org"><span class="URLPACKT">http://raml.org</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RPC based-based APIs</h1>
                </header>
            
            <article>
                
<p>With RPC APIs there is an argument that your contract is your documentation, in the following example we define the interface using the protocol buffers DSL and would make any necessary comments to assist the consumer as required. The predominant theory to follow is one of self-documenting code that your methods and parameter names should infer intent and enough description to negate the use of comments.</p>
<p>Protocol buffer example:</p>
<pre>
// The greeting service definition. <br/>service Users { <br/>  // Create user creates a user in the system with the given User details, <br/>  // it returns an Error message which will be nil on a successful operation <br/>  rpc CreateUser (User) returns (Error) {} <br/>} <br/><br/>// Person describes a user entity <br/>message User { <br/>  // name is a required field and represents the name of <br/>  required string name = 1; <br/>  // id is the unique identifier for the user in the sytem <br/>  required int32 id = 2; <br/>  // email is the users email address and is an optional field  <br/>  optional string email = 3; <br/>} <br/><br/>message Error { <br/>  optional code int32 = 1 <br/>  optional detail string = 2 <br/>} 
</pre>
<p>Which standard you choose is entirely dependent on you, your workflow, your team standards, and your users. It will vary from case to case, however, once you choose an approach in the same way as you do with naming conventions you should stick to a consistent style across all of your APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we did not spend much time looking at code; however, we have looked at some essential concepts around writing a great API, which is as important as being able to write the code.</p>
<p>The bulk of this chapter has been concerned with RESTful APIs as unlike RPC we need to be a little more descriptive in their use. We also have the capability to leverage the principles of HATEOAS, which we do not have when using RPC.</p>
<p>In the next chapter, we will start to look at some of the fantastic frameworks that exist in the Go community, so we can start applying these principles and furthering our advancement to microservice mastery.</p>


            </article>

            
        </section>
    </body></html>