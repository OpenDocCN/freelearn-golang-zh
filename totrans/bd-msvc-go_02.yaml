- en: Designing a Great API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个优秀的API
- en: Regardless of whether you are experienced in building APIs and microservices
    and looking for the techniques on how you can apply them with Go or you are completely
    new to the world of microservices, it is worth spending the time to read this
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是经验丰富的API和微服务构建者，正在寻找如何使用Go应用这些技术的技巧，还是你对微服务世界一无所知，花时间阅读这一章都是值得的。
- en: Writing an API contract feels part art, part science and, when you discuss your
    design with other engineers, you will most certainly agree to disagree, not to
    the level of tabs versus spaces, but there is certainly something personal about
    API contracts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编写API合约感觉像是艺术与科学的结合，当你与其他工程师讨论你的设计时，你很可能会同意不同意，不仅仅是关于制表符与空格的问题，但API合约确实有一些个人特色。
- en: In this chapter, we will look at the two most popular options, which are RESTful
    and RPC. We will examine the semantics of each approach, which will equip you
    with the knowledge to argue your case when the inevitable discussion (read argument)
    occurs. Choosing between REST or RPC may be entirely down to your current environment.
    If you currently have services running that implement a RESTful approach, then
    I suggest you stick with it, likewise if you now use RPC. One thing I would suggest
    is that you read the entire chapter to understand the semantics, pros, and cons
    of each approach.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两种最流行的选项，即RESTful和RPC。我们将检查每种方法的语义，这将为你提供在不可避免讨论（即争论）发生时论证你观点的知识。选择REST或RPC可能完全取决于你当前的环境。如果你目前有运行实现RESTful方法的服务的，那么我建议你继续使用它，同样，如果你现在使用RPC。我建议的一件事是，你应该阅读整个章节，以了解每种方法的语义、优点和缺点。
- en: RESTful APIs
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API
- en: 'The term **REST** was suggested by Roy Fielding in his Ph.D. dissertation in
    the year 2000\. It stands for **Representational State Transfer** and is described
    as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**REST**是由Roy Fielding在2000年的博士论文中提出的。它代表**表征状态转移**，其描述如下：
- en: '"REST emphasizes scalability of component interactions, generality of interfaces,
    independent deployment of components, and intermediary components to reduce interaction
    latency, enforce security and encapsulate legacy systems."'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '"REST强调组件交互的可扩展性、接口的通用性、组件的独立部署、以及中间组件以减少交互延迟、加强安全和封装遗留系统。"'
- en: Having an API that conforms to the REST principles is what makes it RESTful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 具备符合REST原则的API才是RESTful的。
- en: URIs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI
- en: One of the main components in the HTTP protocol is a URI. **URI** stands for
    **Uniform Resource Identifiers** and is the method by which you will access the
    API. You may be asking what the difference between a URI and a URL (Uniform Resource
    Locator) is? When I started to write this chapter, I wondered about this myself
    and did what any self-respecting developer would do, which is to head over to
    Stack Overflow. Unfortunately, my confusion only grew as there were lots of detailed
    answers, none of which I found particularly enlightening. Time to head over to
    the inner circle of hell also known as W3C standards to look up the RFC for the
    official answer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议中的一个主要组件是URI。**URI**代表**统一资源标识符**，是你访问API的方法。你可能想知道URI和URL（统一资源定位符）之间的区别是什么？当我开始写这一章时，我自己也对此感到困惑，并做了任何自重的开发者都会做的事情，即前往Stack
    Overflow。不幸的是，我的困惑反而加深了，因为那里有很多详细的答案，但没有一个我认为特别有启发性。是时候前往地狱的内部圈层，也就是W3C标准，查找RFC以获取官方答案了。
- en: In short, there is no difference, a URL is a URI that identifies a resource
    by its network location, and it is acceptable to interchange the terms when describing
    a resource entirely.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，两者没有区别，URL是URI的一种，通过其网络位置标识资源，在描述资源时可以互换使用术语。
- en: The clarification document published back in 2001 ([http://www.w3.org/TR/uri-clarification](http://www.w3.org/TR/uri-clarification))
    goes on to explain that in the early to mid-90s there was an assumption that an
    identifier is cast into one or two classes. An identifier might specify the location
    of a resource (URL) or its name (Uniform Resource Name URN) independent of location.
    A URI could either be a URL or a URN. Using this example, `http://` would be a
    URL scheme and `isbn:` a URN scheme. However, this changed over time and the importance
    of the additional level of hierarchy lessened. The view changed that an individual
    scheme does not need to be cast into one of a discrete set of types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年发布的澄清文档([http://www.w3.org/TR/uri-clarification](http://www.w3.org/TR/uri-clarification))继续解释说，在90年代初，有一个假设认为标识符被归入一个或两个类别。标识符可能指定资源的位置（URL）或其名称（统一资源名称URN），而不考虑位置。URI可以是URL或URN。使用这个例子，`http://`将是一个URL方案，`isbn:`是一个URN方案。然而，随着时间的推移，这一级层次结构的重要性降低了。观点发生了变化，即单个方案不需要被归入离散类型集合中的一个。
- en: The conventional approach is that `http:` is a URI scheme and `urn:` is also
    a URI scheme. URNs take the form `urn:isbn:n-nn-nnnnnn-n`, `isbn:` is a URN namespace
    identifier, not a URN scheme or a URI scheme.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的方法是`http:`是一个URI方案，`urn:`也是一个URI方案。URN的形式为`urn:isbn:n-nn-nnnnnn-n`，`isbn:`是一个URN命名空间标识符，而不是URN方案或URI方案。
- en: Following this view, the term URL does not refer to a formal partition of URI
    space rather, URL is an informal concept; a URL is a type of URI that identifies
    a resource via its network location.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 依据这一观点，术语URL并不指代URI空间的正式划分，相反，URL是一个非正式的概念；URL是一种URI类型，通过其网络位置来标识资源。
- en: For the rest of this book, we will use the term URI and when we do we will be
    talking about a method to access a resource that is running on a remote server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用术语URI，当我们这样做时，我们将讨论一种访问远程服务器上运行的资源的方法。
- en: URI format
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI格式
- en: 'RFC 3986, which was published in 2005 [https://www.ietf.org/rfc/rfc3986.txt](https://www.ietf.org/rfc/rfc3986.txt),
    defines the format that makes valid URIs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年发布的RFC 3986[https://www.ietf.org/rfc/rfc3986.txt](https://www.ietf.org/rfc/rfc3986.txt)定义了使URI有效的格式：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are will use the path element in order to locate an endpoint that is running
    on our server. In a REST endpoint, this can contain parameters as well as a document
    location. The query string is equally important, as you will use this to pass
    parameters such as page number or ordering to control the data that is returned.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用路径元素来定位我们服务器上运行的端点。在REST端点中，这可以包含参数以及文档位置。查询字符串同样重要，因为你将使用它来传递参数，如页码或排序，以控制返回的数据。
- en: 'Some general rules for URI formatting:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: URI格式化的一些通用规则：
- en: A forward slash `/` is used to indicate a hierarchical relationship between
    resources
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正斜杠`/`用于表示资源之间的层次关系
- en: A trailing forward slash `/` should not be included in URIs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI中不应包含尾随正斜杠`/`
- en: Hyphens `-` should be used to improve readability
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连字符`-`可以提高可读性
- en: Underscores `_` should not be used in URIs
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URI中不应使用下划线`_`
- en: Lowercase letters are preferred as case sensitivity is a differentiator in the
    `path` part of a URI
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用小写字母，因为大小写敏感性是URI路径部分的一个区分因素
- en: The concept behind many of the rules is that a URI should be easy to read and
    to construct. It should also be consistent in the way that it is built so you
    should follow the same taxonomy for all the endpoints in your API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 许多规则背后的概念是URI应该易于阅读和构建。它也应该在构建方式上保持一致，因此你应该为API中的所有端点遵循相同的分类法。
- en: URI path design for REST services
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST服务的URI路径设计
- en: Paths are broken into documents, collections, stores, and controllers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 路径被分解为文档、集合、存储和控制器。
- en: Collections
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A collection is a directory of resources typically broken by parameters to
    access an individual document. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是资源的目录，通常通过参数来访问单个文档。例如：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When defining a collection, we should always use a plural noun such as `cats`
    or `people` for the collection name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个集合时，我们应该始终使用复数名词，例如`cats`或`people`作为集合名称。
- en: Documents
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: 'A document is a resource pointing to a single object, similar to a row in a
    database. It has the ability to have child resources that may be both sub-documents
    or collections. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是指向单个对象的资源，类似于数据库中的一行。它具有拥有子资源的能力，这些子资源可以是子文档或集合。例如：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Controller
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: A controller resource is like a procedure, this is typically used when a resource
    cannot be mapped to standard **CRUD** (**create**, **retrieve**, **update**, and
    **delete**) functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器资源就像一个过程，这通常用于资源无法映射到标准的 **CRUD**（**创建**、**检索**、**更新** 和 **删除**）函数时。
- en: 'The names for controllers appear as the last segment in a URI path with no
    child resources. If the controller requires parameters, these would typically
    be included in the query string:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的名称出现在 URI 路径的最后一段，没有子资源。如果控制器需要参数，这些参数通常包含在查询字符串中：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When defining a controller name we should always use a verb. A verb is a word
    that indicates an action or a state of being, such as `feed` or `send`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 定义控制器名称时，我们应该始终使用动词。动词是一个表示动作或状态的词，例如 `feed` 或 `send`。
- en: Store
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储
- en: 'A store is a client-managed resource repository, it allows the client to add,
    retrieve, and delete resources. Unlike a collection, a store will never generate
    a new URI it will use the one specified by the client. Take a look at the following
    example that would add a new cat to our store:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是一个客户端管理的资源仓库，它允许客户端添加、检索和删除资源。与集合不同，存储永远不会生成新的 URI，它将使用客户端指定的 URI。以下是一个示例，它将向我们的存储中添加一只新猫：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would add a new cat to the store with an ID of `2`, if we had posted the
    new cat omitting the ID to a collection the response would need to include a reference
    to the newly defined document so we could later interact with it. Like controllers
    we should use a plural noun for store names.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在存储中添加一只 ID 为 `2` 的新猫，如果我们向集合中发布了没有 ID 的新猫，则响应需要包含对新定义的文档的引用，这样我们就可以稍后与之交互。像控制器一样，我们应该使用复数名词作为存储名称。
- en: CRUD function names
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD 函数名称
- en: 'When designing great REST URIs we never use a CRUD function name as part of
    the URI, instead we use a HTTP verb. For example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计优秀的 REST URI 时，我们从不使用 CRUD 函数名称作为 URI 的一部分，而是使用 HTTP 动词。例如：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We do not include the verb in the name of the method as this is specified by
    the HTTP verb, the following URIs would be considered an anti-pattern:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在方法名称中包含动词，因为这由 HTTP 动词指定，以下 URI 被认为是反模式：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we look at HTTP verbs in the next section this will make more sense.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中查看 HTTP 动词时，这将会更清楚。
- en: HTTP verbs
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 动词
- en: 'The commonly used HTTP verbs are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的 HTTP 动词有：
- en: '`GET`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`POST`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: '`PATCH`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: '`DELETE`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: '`HEAD`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`'
- en: '`OPTIONS`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`'
- en: Each of these methods has a well-defined semantic within the context of our
    REST API and the correct implementation will help your user understand your intention.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都在我们的 REST API 的上下文中有一个明确的语义，正确的实现将帮助用户理解你的意图。
- en: GET
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET
- en: The `GET` method is used to retrieve a resource and should never be used to
    mutate an operation, such as updating a record. Typically, a body is not passed
    with a `GET` request; however, it is not an invalid `HTTP` request to do so.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 方法用于检索资源，不应用于更改操作，例如更新记录。通常，`GET` 请求不会传递正文；然而，这样做并不构成无效的 `HTTP` 请求。'
- en: '**Request**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**:'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Response**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**:'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: POST
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST
- en: The `POST` method is used to create a new resource in a collection or to execute
    a controller. It is typically a non-idempotent action, in that multiple posts
    to create an element in a collection that will create multiple elements not updated
    after the first call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法用于在集合中创建一个新的资源或执行一个控制器。它通常是一个非幂等操作，这意味着多次向集合中创建一个元素将创建多个元素，而这些元素在第一次调用后不会被更新。'
- en: The `POST` method is always used when calling controllers as the actions of
    this is considered non-idempotent.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法在调用控制器时始终使用，因为其操作被认为是非幂等的。'
- en: '**Request**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**:'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Response**:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**:'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: PUT
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT
- en: The `PUT` method is used to update a mutable resource and must always include
    the resource locator. The `PUT` method calls are also idempotent in that multiple
    requests will not mutate the resource to a different state than the first call.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 方法用于更新可变资源，并且必须始终包含资源定位符。`PUT` 方法的调用也是幂等的，这意味着多次请求不会将资源状态更改为与第一次调用不同的状态。'
- en: '**Request**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**:'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Response**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**:'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: PATCH
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PATCH
- en: The `PATCH` verb is used to perform a partial update, for example, if we only
    wanted to update the name of our cat we could make a `PATCH` request only containing
    the details that we would like to change.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH` 动词用于执行部分更新，例如，如果我们只想更新我们猫的名字，我们可以发出只包含我们想要更改的详细信息的 `PATCH` 请求。'
- en: '**Request**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**:'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Response**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**:'
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In my experience PATCH updates are rarely used, the general convention is to
    use a PUT and to update the whole object, this not only makes the code easier
    to write but also makes an API which is simpler to understand.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的经验中，PATCH 更新很少被使用，通常的做法是使用 PUT 来更新整个对象，这不仅使得代码更容易编写，而且使得 API 更易于理解。
- en: DELETE
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: The `DELETE` verb is used when we want to remove a resource, generally we would
    pass the ID of the resource as part of the path rather than in the body of the
    request. This way, we have a consistent method for updating, deleting, and retrieving
    a document.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要删除一个资源时，使用 `DELETE` 动词，通常我们会将资源的 ID 作为路径的一部分传递，而不是在请求体中。这样，我们就有了一个一致的方法来更新、删除和检索文档。
- en: '**Request**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Response**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: HEAD
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部
- en: A client would use the `HEAD` verb when they would like to retrieve the headers
    for a resource without the body. The `HEAD` verb is typically used in place of
    a `GET` verb when a client only wants to check if a resource exists or to read
    the metadata.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要检索资源的头部信息而不需要正文时，会使用 `HEAD` 动词。`HEAD` 动词通常用于替代 `GET` 动词，当客户端只想检查资源是否存在或读取元数据时。
- en: '**Request**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Response**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: OPTIONS
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项
- en: The `OPTIONS` verb is used when a client would like to retrieve the possible
    interactions for a resource. Typically, the server will return an `Allow` header,
    which will include the `HTTP` verbs that can be used with this resource.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要检索资源的可能交互时，会使用 `OPTIONS` 动词。通常，服务器会返回一个 `Allow` 头部，其中包含可以与该资源一起使用的 `HTTP`
    动词。
- en: '**Request**:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**：'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Response**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: URI query design
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI 查询设计
- en: 'It is perfectly acceptable to use a query string as part of an API call; however,
    I would refrain from using this to pass data to the service. Instead the query
    should be used to perform actions such as:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 调用中使用查询字符串作为一部分是完全可接受的；然而，我建议不要用它来传递数据给服务。相反，查询应该用于执行如下操作：
- en: Paging
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页
- en: Filtering
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Sorting
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: 'If we need to make a call to a controller, we discussed earlier that we should
    use a `POST` request as this is most likely a non-idempotent request. To pass
    data to the service, we should include the data inside of the body. However, we
    could use a query string to filter the action of the controller:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要调用一个控制器，我们之前讨论过，应该使用 `POST` 请求，因为这很可能是非幂等请求。为了传递数据给服务，我们应该在体中包含数据。然而，我们可以使用查询字符串来过滤控制器的动作：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we would send a status update email with the message
    included in the body of the request, because we are using the group filter passed
    in the query string we could restrict the action of this controller to only send
    to the admin group.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们会发送包含在请求体中的状态更新电子邮件，因为我们使用了查询字符串中传递的组过滤器，我们可以将这个控制器的动作限制为只发送给管理员组。
- en: If we had added the message to the query string and not passed a message body,
    then we would potentially be causing two problems for ourselves. The first is
    that the max length for a URI is 2083 characters. The second is that generally
    a `POST` request would always include a request body. Whilst this is not required
    by the `HTTP` specification, it would be expected behavior by the majority of
    your users.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将消息添加到查询字符串而没有传递消息体，那么我们可能会给自己造成两个问题。第一个问题是 URI 的最大长度为 2083 个字符。第二个问题是，通常一个
    `POST` 请求总是会包括请求体。虽然这不是 `HTTP` 规范的要求，但这是大多数用户期望的行为。
- en: Response codes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应代码
- en: When writing a great API, we should use `HTTP` status codes to indicate to the
    client the success or failure of the request. In this chapter, we will not be
    taking a comprehensive look at all the status codes available; there are many
    resources on the Internet that have this information. We will provide some sources
    for further reading, what we will do is look at the status codes that you as a
    software engineer will want your microservice to return.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个优秀的 API 时，我们应该使用 `HTTP` 状态码来向客户端指示请求的成功或失败。在本章中，我们不会全面查看所有可用的状态码；互联网上有许多资源提供了这些信息。我们将提供一些进一步阅读的资源，我们将要做的是查看作为软件工程师，你希望你的微服务返回的状态码。
- en: 'Currently, it is a generally held consensus that this is good practice as it
    allows the client to immediately determine the status of a request without having
    to dive into the request body to gain further insight. In the instance of a failure
    and APIs that always return a `200 OK` response to the user with a message body
    containing further information is not good practice as it requires the client
    to have to inspect the body to determine outcome. It also means that the message
    body will contain additional information other than the object that it should
    represent. Consider the following bad practice:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，普遍认为这是一种好的做法，因为它允许客户端立即确定请求的状态，而无需深入请求体以获得更多信息。在失败的情况下，如果API总是向用户返回包含进一步信息的`200
    OK`响应，这不是一个好的做法，因为它要求客户端检查体以确定结果。这也意味着消息体将包含除了它应该表示的对象之外的其他信息。考虑以下不良做法：
- en: 'Bad request body:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 错误请求体：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Successful request:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的请求：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Imagine if you were writing a client for the preceding request, you need to
    add logic to your application to check the status node in the response before
    you could read and process the returned kitten.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个针对先前请求的客户端，你需要在你能够读取和处理返回的小猫之前，在你的应用程序中添加逻辑来检查响应中的状态节点。
- en: 'Now consider something even worse:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一些更糟糕的情况：
- en: 'And even worse failure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的失败例子：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And even worse success:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的成功例子：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If your API author had done something like the preceding example, you need to
    check to see if the response that has been returned is an error or the kitten
    that you were expecting. The number of WTFs per minute you would utter whilst
    coding a client for this API would not endear you to its author. These might seem
    like extreme examples, but there are instances like this out in the wild, at some
    point in my career I'm fairly sure I have been guilty of such a crime, but then
    I had not read this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的API作者做了像前面例子中的事情，你需要检查返回的响应是错误还是你期望的小猫。在编写这个API客户端的过程中，你每分钟会说出多少个WTF，这不会让你对它的作者产生好感。这些可能看起来像是极端的例子，但野外确实有类似的情况，在我的职业生涯中，我相当确信我犯过这样的错误，但那时我没有读过这本书。
- en: What the author in their best intention has done is try to take the HTTP status
    codes too literally. W3C RFC2616 states that the HTTP status code relates to the
    attempt to understand and satisfy the request ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1));
    however, this is a little ambiguous when you look at some of the individual status
    codes. Modern consensus is that it is OK to use HTTP status codes to indicate
    the processing state of an API request not just the server's ability to process
    the request. Consider how we could make these requests better by implementing
    this approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作者在最好的意图下所做的尝试是过于字面地理解HTTP状态码。W3C RFC2616指出，HTTP状态码与尝试理解和满足请求有关([https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1))；然而，当你查看一些单独的状态码时，这有点模糊。现代共识是，使用HTTP状态码来指示API请求的处理状态，而不仅仅是服务器的处理能力是可以接受的。考虑一下，如果我们通过实施这种方法，我们如何使这些请求变得更好。
- en: 'A good example of a failure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个失败的例子：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A good example of a success:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的例子：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is far more semantic; the user only ever needs to read the response in
    the instance of a failure if they require further information. In addition to
    this we can provide a standard error object that is used across all the endpoints
    of our API, which provides further but non-required information to determine why
    a request failed. We will look at error objects in a little while, but for now
    let's look at HTTP status codes more in depth.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加语义化；在失败的情况下，如果用户需要更多信息，他们只需要阅读响应。除此之外，我们还可以提供一个标准错误对象，该对象用于我们API的所有端点，它提供了进一步但非必需的信息，以确定请求失败的原因。我们稍后会看看错误对象，但现在让我们更深入地看看HTTP状态码。
- en: 2xx Success
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2xx 成功
- en: 2xx status codes indicate that the clients request has been successfully received
    and understood.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 2xx 状态码表示客户端的请求已被成功接收并理解。
- en: 200 OK
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 200 OK
- en: 'This is a generic response code indicating that the request has succeeded.
    The response accompanying this code is generally:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的响应码，表示请求已成功。伴随此代码的响应通常是：
- en: '`GET`: An, an entity corresponding to the requested resource'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：一个对应于请求资源的实体'
- en: '`HEAD`: The, the header fields corresponding to the requested resource without
    the message body'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：请求的资源对应的头字段，没有消息体'
- en: '`POST`: An, an entity describing or containing the result of the action'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：一个描述或包含操作结果的实体'
- en: 201 Created
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 201 已创建
- en: 'The created response is sent when a request succeeds and the result is that
    a new entity has been created. Along with the response it is common that the API
    will return a `Location` header with the location of the newly created entity:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求成功且结果是一个新实体被创建时，会发送创建的响应。除了响应之外，API通常还会返回一个`Location`头，其中包含新创建实体的位置：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is optional to return an object body with this response type.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对象体是否可选取决于此响应类型。
- en: 204 No Content
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 204 无内容
- en: This status informs the client that the request has been successfully processed;
    however, there will be no message body with the response. For example, if the
    user makes a `DELETE` request to the collection then the response may return a
    204 status.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此状态通知客户端请求已成功处理；然而，响应中不会有消息体。例如，如果用户对集合发出`DELETE`请求，则响应可能返回204状态。
- en: 3xx Redirection
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3xx 重定向
- en: The 3xx indicate class of status codes indicates that the client must take additional
    action to complete the request. Many of these status codes are used by CDNs and
    other content redirection techniques, however, code 304 can exceptionally useful
    when designing our APIs to provide semantic feedback to the client.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 3xx 状态码类表示客户端必须采取额外操作以完成请求。许多这些状态码由CDN和其他内容重定向技术使用，然而，代码304在为我们的API设计提供语义反馈给客户端时非常有用。
- en: 301 Moved Permanently
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 301 永久移动
- en: This tells the client that the resource they have requested has been permanently
    moved to a different location. Whilst this is traditionally used to redirect a
    page or resource from a web server it can also be useful to us when we are building
    our APIs. In the instance that we rename a collection we could use a 301 redirect
    to send the client to the correct location. This however should be used as an
    exception rather than the norm. Some clients do not implicitly follow 301 redirect
    and implementing this capability adds additional complexity for your consumers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉客户端他们请求的资源已被永久移动到不同的位置。虽然这传统上用于将页面或资源从Web服务器重定向，但它在我们构建API时也可能很有用。如果我们重命名一个集合，我们可以使用301重定向将客户端发送到正确的位置。然而，这应该被视为例外而不是常规做法。一些客户端不会隐式遵循301重定向，实现此功能会增加消费者额外的复杂性。
- en: 304 Not Modified
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 304 未修改
- en: This response is generally used by a CDN or caching server and is set to indicate
    that the response has not been modified since the last call to the API. This is
    designed to save bandwidth and the request will not return a body, but will return
    a `Content-Location` and `Expires` header.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应通常由CDN或缓存服务器使用，并设置为指示自上次调用API以来响应未修改。这是为了节省带宽，请求将不会返回一个体，但将返回`Content-Location`和`Expires`头。
- en: 4xx Client Error
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4xx 客户端错误
- en: In the instance of an error caused by a client, not the server, the server will
    return a 4xx response and will always return an entity that gives further details
    on the error.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误是由客户端而非服务器引起的，服务器将返回4xx响应，并且总是返回一个实体，其中包含有关错误的更多详细信息。
- en: 400 Bad Request
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 400 错误请求
- en: This response indicates that the request could not be understood by the client
    due to a malformed request or due to a failure of domain validation (missing data,
    or an operation that would cause invalid state).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应表示客户端由于请求格式错误或域验证失败（数据缺失或会导致无效状态的操作）而无法理解请求。
- en: 401 Unauthorized
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 401 未授权
- en: This indicates that the request requires user authentication and will include
    a `WWW-Authenticate` header containing a challenge applicable to the requested
    resource. If the user has included the required credentials in the `WWW-Authenticate`
    header, then the response should include an error object that may contain relevant
    diagnostic information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示请求需要用户身份验证，并将包含一个包含适用于请求资源的挑战的`WWW-Authenticate`头。如果用户已在`WWW-Authenticate`头中包含了所需的凭据，则响应应包含一个可能包含相关诊断信息的错误对象。
- en: 403 Forbidden
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 403 禁止
- en: The server has understood the request, but is refusing to fulfill it. This could
    be due to incorrect access level to a resource not that the user is not authenticated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已理解请求，但拒绝执行。这可能是因为对资源的访问级别不正确，而不是用户未认证。
- en: If the server does not wish to make the fact that a request is not able to access
    a resource due to access level public, then it is permissible to return a `404
    Not found` status instead of this response.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器不希望公开请求无法访问资源的事实，那么可以返回`404 Not found`状态码而不是此响应。
- en: 404 Not Found
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 404 未找到
- en: This response indicates that the server has not found anything matching the
    requested URI. No indication is given of whether the condition is temporary or
    permanent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应表示服务器未找到与请求URI匹配的内容。没有给出关于条件是暂时性还是永久性的指示。
- en: It is permissible for the client to make multiple requests to this endpoint
    as the state may not be permanent.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以多次向此端点发送请求，因为状态可能不是永久的。
- en: 405 Method Not Allowed
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 405 方法不允许
- en: The method specified in the request is not allowed for the resource indicated
    by the URI. This may be when the client attempts to mutate a collection by sending
    a `POST`, `PUT`, or `PATCH` to a collection that only serves retrieval of documents.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请求中指定的方法不允许对URI指示的资源进行操作。这可能是当客户端尝试通过向仅提供文档检索功能的集合发送`POST`、`PUT`或`PATCH`来修改集合时。
- en: 408 Request Timeout
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 408 请求超时
- en: The client did not produce a request within the time that the server is prepared
    to wait. The client may repeat the request without modification at a later time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端没有在服务器准备等待的时间内产生请求。客户端可以在稍后时间重复请求，无需修改。
- en: 5xx Server Error
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5xx 服务器错误
- en: Response status codes within the 500 range indicate that something has gone
    "Bang", the server knows this and is sorry for the situation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 范围在500之间的响应状态码表示服务器发生了“Bang”，服务器知道这一点，并为这种情况感到抱歉。
- en: The RFC advises that an error entity should be returned in the response explaining
    whether this is permanent or temporary and containing an explanation of the error.
    When we look at our chapter on security we will look at the recommendation about
    not giving too much information away in error messages as this state may have
    been engineered by a user in the attempt to compromise your system and by returning
    things such as a stack trace or other internal information with a 5xx error can
    actually help to compromise your system. With this in mind it is currently common
    that a 500 error will just return something very generic.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: RFC建议在响应中返回一个错误实体，说明这是永久性的还是暂时性的，并包含错误解释。当我们查看关于安全性的章节时，我们会看到关于在错误信息中不要透露太多信息的建议，因为这种状态可能是用户试图破坏您的系统而人为制造的。通过返回诸如堆栈跟踪或其他内部信息之类的5xx错误，实际上可能会帮助破坏您的系统。因此，目前通常的做法是，500错误只会返回一个非常通用的信息。
- en: 500 Internal Server Error
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 500 内部服务器错误
- en: A generic error message indicating that something did not go quite as planned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的错误信息，表明事情并没有按计划进行。
- en: 503 Service Unavailable
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 503 服务不可用
- en: The server is currently unavailable due to temporary overloading or maintenance.
    There is a rather useful pattern that you can implement to avoid cascading failure
    in the instance of a malfunction in which the microservice will monitor its internal
    state and in the case of failure or overloading will refuse to accept the request
    and immediately signal this to the client. We will look at this pattern more in
    chapter xx; however, this instance is probably where you will be wanting to return
    a 503 status code. This could also be used as part of your health checks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器当前因临时过载或维护而不可用。在微服务发生故障或过载的情况下，有一个非常有用的模式可以实现，该模式可以避免级联故障。在这种情况下，微服务将监控其内部状态，在发生故障或过载时，将拒绝接受请求，并立即向客户端发出信号。我们将在第xx章中更详细地探讨这个模式；然而，这个实例可能是您想要返回503状态码的地方。这也可以作为您的健康检查的一部分使用。
- en: HTTP headers
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP头
- en: Request headers are a really important part of the HTTP request and response
    process and implementing a standard approach helps your users to transition from
    one API to another. In this sub section, we will not cover all the possible headers
    that you can use in your API, but we will look at the most common headers for
    full information on the HTTP protocol please take a look at RFC 7231 [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231).
    This document contains a comprehensive overview of the current standard.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头是HTTP请求和响应过程中的一个非常重要的部分，实施标准方法有助于您的用户从一个API过渡到另一个API。在本节中，我们不会涵盖您可以在API中使用的所有可能的头，但我们将查看最常见的头，以获取有关HTTP协议的完整信息，请参阅RFC
    7231 [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)。该文档包含了对当前标准的全面概述。
- en: Standard request headers
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准请求头
- en: Request headers provide additional information for the request and the response
    of your API. Think of them like metadata for the operation. They can be used to
    augment other data for the response that does not belong in the body itself such
    as the content encoding. They can also be utilized by the client to provide information
    that can help the server process the response. Where possible we should always
    use the standard headers as this gives consistency to your user and provides them
    with a common standard across multiple endpoints from many different vendors.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头为API的请求和响应提供额外的信息。把它们想象成操作的元数据。它们可以用来增强响应中的其他数据，这些数据本身不属于主体，例如内容编码。它们也可以被客户端利用，提供有助于服务器处理响应的信息。在可能的情况下，我们应该始终使用标准头，因为这为你的用户提供了一致性，并为他们提供了多个端点从多个不同供应商的通用标准。
- en: Authorization - string
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Authorization - 字符串
- en: 'Authorization is one of the most commonly used request headers, even if you
    have a public read only API I advise you to ask the user to authorize their requests.
    By requesting that the user authorizes a request, you have the capability to perform
    operations such as user level logging and rate limiting. Quite often you may see
    authorization conducted with a custom request header such as "X-API-Authorization".
    I would recommend you do not use this approach as the standard Authorization header
    as specified by the W3C RFC 2616 ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html))
    has all the capability we need. Many companies such as Twitter and PayPal use
    this header to authenticate requests let''s. Let''s look at a simple example from
    Twitter''s developer documentation to see how this can be implemented:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是使用最广泛的请求头之一，即使你有公共只读API，我也建议你要求用户授权他们的请求。通过要求用户授权请求，你就有能力执行用户级日志记录和速率限制等操作。通常，你可能会看到使用自定义请求头（如“X-API-Authorization”）进行授权。我建议你不要使用这种方法，因为W3C
    RFC 2616中指定的标准授权头（[https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)）具有我们所需的所有功能。许多公司，如Twitter和PayPal，使用此头进行请求认证。让我们看看Twitter开发者文档中的一个简单示例，看看这是如何实现的：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The header is in the form of `[Authorization method] [Comma separated URL encoded
    values]`. This clearly informs the server that the authorization type is OAuth
    and the various components of this authorization follow this in a comma delaminated
    format. By following this standard approach you can enable your consumers to use
    a third-party library that implements this standard and thus save them the work
    of having to build a bespoke implementation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 头部格式为`[Authorization method] [逗号分隔的URL编码值]`。这清楚地告知服务器授权类型是OAuth，并且此授权的各个组件以逗号分隔的格式跟随。通过遵循这种标准方法，你可以让你的消费者使用实现此标准的第三方库，从而节省他们构建定制实现的工作。
- en: Date
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期
- en: Timestamp of the request in RFC 3339 format.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的RFC 3339格式的时间戳。
- en: Accept - content type
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Accept - 内容类型
- en: 'The requested content type for the response, such as:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 响应请求的内容类型，例如：
- en: '`application/xml`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/xml`'
- en: '`text/xml`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/xml`'
- en: '`application/json`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`'
- en: '`text/javascript` (for JSONP)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/javascript`（用于JSONP）'
- en: Accept-Encoding - gzip, deflate
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Accept-Encoding - gzip, deflate
- en: REST endpoints should always support gzip and deflate encoding, when applicable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当适用时，REST端点应始终支持gzip和deflate编码。
- en: Implementing gzip support in Go is relatively straightforward; we showed how
    it is possible to implement middleware into your microservices in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml),
    *Introduction to Microservices*. In the following example, we will use this technique
    to create a gzip response writer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中实现gzip支持相对简单；我们在[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)，“微服务简介”中展示了如何将中间件实现到你的微服务中。在下面的示例中，我们将使用这项技术来创建gzip响应writer。
- en: 'The core of writing a response in a gzipped format is the `compress/gzip` package,
    which is part of the standard library. It allows you to create a `Writer` interface
    that implements `ioWriteCloser` wrapping an existing `io.Writer`, which writes
    to the given writer using the gzip compression:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在gzip格式中编写响应的核心是`compress/gzip`包，它是标准库的一部分。它允许你创建一个实现`ioWriteCloser`接口的`Writer`，该接口包装现有的`io.Writer`，使用gzip压缩将数据写入给定的writer：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To create our handler we are going to write the `NewGzipHandler` function, this
    returns a new `http.Handler` that will wrap our standard output handler.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的处理程序，我们将编写`NewGzipHandler`函数，这个函数返回一个新的`http.Handler`，它将包装我们的标准输出处理程序。
- en: The first thing we need to do is create our own `ResponseWriter` that embeds
    `http.ResponseWriter`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是创建自己的`ResponseWriter`，它嵌入`http.ResponseWriter`。
- en: 'Example 2.1 `chapter2/gzip/gzip_deflate.go`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.1 `chapter2/gzip/gzip_deflate.go`：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The core method for this is the implementation of the `Write` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 核心方法是实现`Write`方法：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you look at the implementation for `Write` in the standard `http.Response`
    struct there is a whole load of stuff going on in there that we neither want to
    lose or re-implement because the `gzip.Writer` object is created with a writer
    when we call `Write` on it, it then in turn calls write on `http.Response` and
    we lose none of the complexity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看标准`http.Response`结构体中`Write`方法的实现，那里有很多事情在进行，我们既不想丢失也不想重新实现，因为当我们对`gzip.Writer`对象调用`Write`时，它会反过来调用`http.Response`的`write`方法，我们不会丢失任何复杂性。
- en: 'Internally in our `NewGzipHandler` our handler checks to see if the client
    has sent the `Accept-Encoding` header and if so we will write the response using
    the `GzipResponseWriter` method if the client has requested uncompressed content
    then we only call `ServeHttp` with the standard `ResponseWriter`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`NewGzipHandler`内部，我们的处理程序会检查客户端是否发送了`Accept-Encoding`头，如果是的话，我们将使用`GzipResponseWriter`方法来写入响应；如果客户端请求未压缩的内容，我们则只调用带有标准`ResponseWriter`的`ServeHttp`：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is by no means a comprehensive example and there are many open source packages
    like the one from the team at the NY Times ([https://github.com/NYTimes/gziphandler](https://github.com/NYTimes/gziphandler)),
    which manages this for you.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一个全面的示例，而且有许多开源包，例如来自《纽约时报》团队的那个（[https://github.com/NYTimes/gziphandler](https://github.com/NYTimes/gziphandler)），它为你管理这些。
- en: As a little programming test, why not try and modify this example to implement
    `DEFLATE`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小型的编程测试，为什么不尝试修改这个示例来实现`DEFLATE`。
- en: Standard response headers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准响应头
- en: All services should return the following headers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务都应该返回以下头信息。
- en: '`Date`: The date that the request was processed in RFC 3339 format.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`: 请求被处理的日期，格式为RFC 3339。'
- en: '`Content-Type`: The content type of the response.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type`: 响应的内容类型。'
- en: '`Content-Encoding`: gzip or deflate.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Encoding`: gzip或deflate。'
- en: '`X-Request-ID`/`X-Correlation-ID`: Whilst you may not directly request your
    clients to implement this header it may be something that you add to requests
    when you call downstream services. When you are trying to debug a service that
    is running in production it can be incredibly useful to be able to group all the
    requests by a single transaction ID. A common practice that we will see when we
    look at logging and monitoring is to store all logs in a common database such
    as Elastic Search. By setting the standard way of working when building many connected
    microservices that they pass the correlation ID with each downstream call you
    will be able to query your logs in Kibana or another log query tool and group
    them into a single transaction:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Request-ID`/`X-Correlation-ID`：虽然你可能不会直接要求你的客户端实现这个头，但它可能是你在调用下游服务时添加到请求中的内容。当你试图调试在生产环境中运行的服务时，能够根据单个事务ID分组所有请求可以非常有用。当我们查看日志和监控时，我们会看到的一种常见做法是将所有日志存储在公共数据库中，例如Elastic
    Search。通过在构建许多相互连接的微服务时设置标准的工作方式，它们在每个下游调用中传递关联ID，你将能够使用Kibana或其他日志查询工具查询你的日志并将它们分组到单个事务中：'
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Returning errors
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回错误
- en: In the instance of failure, users of your API should be able to write one piece
    of code that handles errors across different endpoints. A standard error entity
    will help your consumers by enabling them to write DRY code whenever an error
    caused by client or server occurs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败的情况下，你的API用户应该能够编写一段代码来处理不同端点的错误。一个标准的错误实体将帮助你的消费者，使他们能够在客户端或服务器发生错误时编写DRY（Don't
    Repeat Yourself）代码。
- en: 'The Microsoft API guidelines recommend the following format for these entities:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 微软API指南推荐以下格式来处理这些实体：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**ErrorResponse**: **Object**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误响应**：**对象**'
- en: 'The `ErrorResponse` is the top level object which will be returned by our response
    and contains the following fields:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorResponse`是返回响应的最高级对象，它包含以下字段：'
- en: '| **Property** | **Type** | **Required** | **Description** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **必需** | **描述** |'
- en: '| error | Error | ![](img/e2f574a5-74e7-43c1-a797-49375f0cbcc0.png) | The error
    object. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 错误 | ![](img/e2f574a5-74e7-43c1-a797-49375f0cbcc0.png) | 错误对象。 |'
- en: '**Error: Object**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误：对象**'
- en: 'The `Error` object is the detail for our error response; it provides full detail
    for the reason that the error occurred:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`对象是我们错误响应的详情；它提供了错误发生原因的完整详情：'
- en: '| **Property** | **Type** | **Required** | **Description** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **必需** | **描述** |'
- en: '| Code | `String` (enumerated) | ![](img/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png)
    | One of a server-defined set of error codes. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| Code | `String` (枚举) | ![图片](img/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png)
    | 服务器定义的错误代码集合中的一个。 |'
- en: '| message | String | ![](img/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png) | A
    human-readable representation of the error. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| message | String | ![图片](img/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png) |
    错误的可读表示形式。 |'
- en: '| Target | String | - | The target of the error. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| Target | String | - | 错误的目标。 |'
- en: '| Details | Error[] | - | An array of details about specific errors that led
    to this reported error. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| Details | Error[] | - | 导致此报告错误的具体错误详情数组。 |'
- en: '| innererror | InnerError | - | An object containing more specific information
    than the current object about the error. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| innererror | InnerError | - | 包含比当前对象更具体错误信息的对象。 |'
- en: '**InnerError**: **Object**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**InnerError**：**对象**'
- en: '| **Property** | **Type** | **Required** | **Description** |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **必需** | **描述** |'
- en: '| Code | String | - | A more specific error code than was provided by the containing
    error. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| Code | String | - | 比包含错误提供的错误代码更具体的错误代码。 |'
- en: '| innererror | InnerError | - | An object containing more specific information
    than the current object about the error. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| innererror | InnerError | - | 包含比当前对象更具体错误信息的对象。 |'
- en: 'Microsoft has provided an excellent API guidelines resource, you can read more
    about returning errors by looking at the following link:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了一个优秀的API指南资源，你可以通过以下链接了解更多关于返回错误的信息：
- en: '[https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors)'
- en: Accessing APIs from JavaScript
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JavaScript访问API
- en: Web browsers implement a sandbox mechanism that restricts resources in one domain
    from accessing resources in another. For example, you may have an API that allows
    the modification and retrieval of user data and a website that provides an interface
    for this API. If the browser did not implement the "same-origin policy" and assuming
    the user did not log out of their session then it would be possible for a malicious
    page to send a request to the API and modify it without you knowing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器实现了一个沙盒机制，该机制限制了一个域中的资源访问另一个域中的资源。例如，你可能有一个允许修改和检索用户数据的API，以及一个提供此API接口的网站。如果浏览器没有实现“同源策略”，并且假设用户没有注销他们的会话，那么恶意页面就可以向API发送请求并修改它，而你却不知道。
- en: To get around this, there are two methods that can be implemented by your microservice
    to allow this access, **JSONP** which stands for (**JSON with Padding**) and **CORS**
    (**Cross-Origin Resource Sharing**).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你的微服务可以实现两种方法来允许这种访问，**JSONP**（代表**带有填充的JSON**）和**CORS**（**跨源资源共享**）。
- en: JSONP
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSONP
- en: JSONP is pretty much a hack, and it is implemented by most browsers that do
    not implement the later CORS standard. It is restricted to `GET` requests only
    and works by getting round the issue that while `XMLHTTPRequest` is blocked from
    making requests to third-party servers, there are no restrictions on HTML script
    elements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP基本上是一个漏洞，并且大多数没有实现后续CORS标准的浏览器都实现了它。它仅限于`GET`请求，并且通过绕过问题来工作，即虽然`XMLHTTPRequest`被阻止向第三方服务器发出请求，但HTML脚本元素没有限制。
- en: A JSONP request inserts a `<script src="img/...">` element into the browsers
    DOM with the API's URI as the `src` target. This component returns a function
    call with the JSON data as a parameter, and when this loads, the function executes
    passing the data to the callback.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP请求将一个`<script src="img/...">`元素插入到浏览器的DOM中，API的URI作为`src`目标。此组件返回一个带有JSON数据的函数调用，当它加载时，该函数执行并将数据传递给回调。
- en: 'JavaScript callback is defined in the code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 回调在代码中定义：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the response from the API call:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是API调用的响应：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To denote a request for data to be returned as JSONP, generally the `callback=functionName`
    parameter is added to the URI, in our example this would be `/helloworld?callback=success`.
    Implementing this is particularly straightforward let's take a look at our simple
    Go `helloworld` example and see how we can modify this to implement JSONP.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示请求返回JSONP格式的数据，通常会在URI中添加`callback=functionName`参数，在我们的例子中，这将是在`/helloworld?callback=success`。实现这一点特别简单，让我们看看我们的简单Go
    `helloworld`示例，看看我们如何修改它以实现JSONP。
- en: 'One thing to note is the `Content-Type` header that we are returning. We are
    no longer returning `application/json` as we are not returning JSON we are actually
    returning JavaScript so we must set the `Content-Type` header accordingly:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是我们返回的`Content-Type`标题。我们不再返回`application/json`，因为我们不是返回JSON，实际上我们在返回JavaScript，因此我们必须相应地设置`Content-Type`标题：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Example `chapter2/jsonp/jsonp.go`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 `chapter2/jsonp/jsonp.go`：
- en: 'Let''s take a quick look at an example of how we can send JSONP with Go, our
    response object is going to be exactly the same as the ones in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml),
    *Introduction to Microservices*:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下如何使用Go发送JSONP的示例，我们的响应对象将完全与[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)，*微服务简介*中的那些相同：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The difference is all in the handler, if we look at line **30** we are checking
    to see if there is a callback parameter in the query string. This would be provided
    by the client and indicates the function they expect to be called when the response
    is returned:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 差异全在于处理器，如果我们查看第**30**行，我们正在检查查询字符串中是否有回调参数。这将由客户端提供，并指示当响应返回时他们期望被调用的函数：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To return our response in JSONP format all we need to do is wrap the standard
    response to a JavaScript function call. In line **33**, we are taking the callback
    function name that was passed by the client and encapsulating the response we
    would normally send. The resultant output would look something like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要以JSONP格式返回我们的响应，我们只需要将标准响应包装成JavaScript函数调用。在第**33**行，我们正在获取客户端传递的回调函数名称，并将我们通常要发送的响应封装起来。结果输出将类似于以下这样：
- en: '**Request**:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求**：'
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Response**:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: CORS
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CORS
- en: Assuming your users are using a desktop browser that has been released in the
    last five years, or a mobile browser such as iOS 9 or Android 4.2+, then implementing
    CORS will be more than enough. [http://caniuse.com/#feat=cors](http://caniuse.com/#feat=cors)
    says that it is over 92% of all Internet users. I was looking forward to bashing
    IE for the lack of full adoption; however, since this has been supported since
    IE8 I will have to complain about mobile users.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的用户正在使用过去五年内发布的桌面浏览器，或者iOS 9或Android 4.2+等移动浏览器，那么实现CORS将绰绰有余。[http://caniuse.com/#feat=cors](http://caniuse.com/#feat=cors)
    表示这超过了所有互联网用户的92%。我期待着批评IE因未完全采用而受到的缺乏；然而，由于这自IE8以来就已经得到支持，我不得不抱怨移动用户。
- en: CORS is a W3C proposal to standardize cross-origin requests from the browser.
    It works by the browsers built in `HTTP` client making an `OPTIONS` request to
    a URI before the real request.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: CORS是W3C的一个提案，旨在标准化浏览器中的跨源请求。它是通过浏览器内置的`HTTP`客户端在真实请求之前向URI发送一个`OPTIONS`请求来工作的。
- en: 'If the server at the other end returns a header that contains the origin of
    the domain from which the script is being loaded, then the browser will trust
    the server and will allow a cross-site request to be made:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一端的服务器返回一个包含从该脚本加载的域的源头的标题，那么浏览器将信任该服务器，并允许进行跨站请求：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implementing this in Go is quite straightforward and we could create a middleware
    to globally manage this for us. For simplicity, in our example we have hard coded
    this into the handler:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中实现这一点相当简单，我们可以创建一个中间件来全局管理这一点。为了简单起见，在我们的例子中，我们将其硬编码到处理器中：
- en: Example 2.2 `chapter2/cors/cors.go`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2.2 `chapter2/cors/cors.go`
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In line **25**, we detect if the request method is `OPTIONS` and instead of
    returning the response we return the `Access-Control-Allow-Origin` header that
    the client is expecting. In our example, we are simply returning `\*`, which means
    all domains are allowed to interact with this API. This is not the safest implementation
    and quite often you will request your API users to register the domains that will
    be interacting with the API and restrict the `Allow-Origin` to only include those
    domains. In addition to the `Allow-Origin` header we are also returning the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在**25**行，我们检测到请求方法是`OPTIONS`，而不是返回响应，我们返回客户端期望的`Access-Control-Allow-Origin`报头。在我们的示例中，我们简单地返回`\*`，这意味着所有域名都可以与此API交互。这不是最安全的实现，而且通常你会要求你的API用户注册将与API交互的域名，并将`Allow-Origin`限制只包括那些域名。除了`Allow-Origin`报头外，我们还返回以下内容：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This tells the browser that it can only make `GET` requests to this URI and
    that it is forbidden to make `POST`, `PUT`, and so on. This is an optional header,
    but it can be used to enhance your user's security when interacting with the API.
    One thing to note is that we are not sending back a `200 OK` response we are using
    `204 No Content` since it is invalid to return a body with an `OPTIONS` request.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉浏览器它只能对此URI发起`GET`请求，并且禁止发起`POST`、`PUT`等请求。这是一个可选的报头，但可以在与API交互时增强用户的安全性。需要注意的是，我们不是发送回`200
    OK`响应，而是使用`204 No Content`，因为在`OPTIONS`请求中返回正文是不合法的。
- en: RPC APIs
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC API
- en: RPC stands for remote procedure call; it is a method of executing a function
    or method on a remote machine. RPC has been around since the dawn of time and
    there are many different types of RPC technology some of which relies on there
    being an interface definition (SOAP, Thrift Protocol Buffers). This interface
    definition can make it easier to generate client and server stubs for different
    technology stacks. Generally, the interface is defined using a **DSL** (**domain
    specific language**) and a generator program will use this to create application
    clients and servers.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: RPC代表远程过程调用；它是在远程机器上执行函数或方法的一种方法。RPC自诞生以来一直存在，并且有众多不同类型的RPC技术，其中一些依赖于存在接口定义（如SOAP、Thrift协议缓冲区）。这种接口定义可以使得为不同的技术栈生成客户端和服务器存根变得更加容易。通常，接口是用**领域特定语言（DSL**）定义的，生成器程序将使用它来创建应用程序客户端和服务器。
- en: Where REST needs to use HTTP as a transport layer, RPC is not bound by this
    constraint, and while it is possible to send RPC calls over HTTP, you can use
    the lightness of TCP or even UDP sockets if you choose to.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST需要使用HTTP作为传输层不同，RPC不受此限制，虽然可以将RPC调用发送到HTTP，但如果选择，你也可以使用TCP或甚至UDP套接字的轻量级。
- en: RPC has seen a resurgence in use lately with many large-scale systems built
    by the likes of Uber, Google, Netflix, and so on are using RPC. Due to the speed
    and performance that you can get from the lower latency from not using HTTP and
    the smaller message size attained by implementing a binary message format rather
    than JSON or XML.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，RPC的使用有所回升，许多由Uber、Google、Netflix等公司构建的大规模系统都在使用RPC。这得益于不使用HTTP所带来的低延迟速度和性能，以及通过实现二进制消息格式而不是JSON或XML所获得的更小的消息大小。
- en: The detractors of RPC mention the tight coupling that can occur between the
    client and the server in that if you update the contract on the server then all
    the clients need to be updated too. With many modern RPC implementations this
    is less of a problem and in fact is no less a problem than you can have with RESTful
    APIs. Whilst old technology such as JMI was tightly bound, requiring the client
    and the server to share the same interface, modern implementations such as Protocol
    Buffers marshal the object sensibly and will not throw an error should there be
    minor differences. Thus by following the standard guidelines in the *Versioning
    APIs* section you have no less a problem than if you were implementing a RESTful
    API.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: RPC的批评者提到，客户端和服务器之间可能会出现紧密耦合，即如果你更新了服务器上的合约，那么所有客户端也需要更新。在许多现代RPC实现中，这个问题已经不那么严重了，实际上，与RESTful
    API相比，这个问题并不更严重。虽然像JMI这样的旧技术紧密耦合，要求客户端和服务器共享相同的接口，但现代实现如Protocol Buffers合理地封装了对象，即使存在细微的差异也不会抛出错误。因此，通过遵循*版本化API*部分的标准指南，你遇到的问题并不比实现RESTful
    API时更严重。
- en: One of the benefits of RPC is that you can quickly generate a client for your
    users, this allows an abstraction from both the transport and the message type
    and allows them to depend upon an interface. As the creator you can change the
    underlying implementation of your application such as a move from Thrift to Proto
    buffers, without requiring the client to do anything other than use the latest
    version of your provided client. Versioning also allows you to retain the same
    backward compatibility that you can achieve with REST.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: RPC的一个好处是您可以快速为您的用户生成客户端，这允许从传输和消息类型中抽象出来，并使他们依赖于接口。作为创建者，您可以更改应用程序的底层实现，例如从Thrift迁移到Proto
    buffers，而无需要求客户端做任何事情，只需使用您提供的最新版本的客户端。版本化还允许您保留与REST相同的前向兼容性。
- en: RPC API design
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC API设计
- en: Some of the principles we have just discussed for creating a good RESTful API
    can also apply to RPC. However; one of the main differences is that you may not
    be using HTTP as your transport; therefore you are not always going to be able
    to use HTTP status codes as an indicator of success or failure. **RPC** stands
    for **Remote Procedure Call** and dates way back before the Internet. It was originally
    conceived as a way to execute a procedure that could be running in a separate
    application on the same machine or even potentially on the network. While we take
    this for granted now, back in the 90s this was cutting edge. Unfortunately, frameworks
    such as CORBA and Java RMI gave RPC a bad name and even now if you speak to an
    opponent of RPC they will most likely bring these two frameworks up. The benefits,
    however, were performance, using binary serialization is incredibly efficient
    on the network and we no longer have the tight coupling that RMI and CORBA enforced.
    We are also not trying to do anything too clever; we are no longer attempting
    to share an object across two processes we are taking a more functional approach,
    that is, methods that return immutable objects. This gives us the best of both
    worlds; the simplicity of interoperation and the speed and small payload of binary
    messages.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的创建良好RESTful API的一些原则也可以应用于RPC。然而，主要区别之一是您可能不会使用HTTP作为传输协议；因此，您并不总是能够使用HTTP状态码作为成功或失败的指示。**RPC**代表**远程过程调用**，其历史可以追溯到互联网出现之前。最初，它被构想为执行可以在同一台机器上运行的独立应用程序中的过程，甚至可能在网络上。虽然我们现在认为这是理所当然的，但在20世纪90年代，这可是前沿技术。不幸的是，像CORBA和Java
    RMI这样的框架给RPC带来了坏名声，即使现在，如果您与RPC的反对者交谈，他们很可能会提到这两个框架。然而，好处是性能，使用二进制序列化在网络上非常高效，我们不再有RMI和CORBA强制执行的紧密耦合。我们也不再试图做任何太聪明的事情；我们不再尝试在两个进程之间共享对象，我们采取了一种更功能性的方法，即返回不可变对象的方法。这让我们拥有了两者之优；交互的简单性和二进制消息的速度与负载小。
- en: RPC message frameworks
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC消息框架
- en: These days we are no longer coupled to having the same interface implementation
    on both the client and the server, this would not adhere to our mantra of independently
    versionable and deployable. Thankfully frameworks are more flexible we can take
    the same approach as we do with REST, it is OK to add, however, removing elements
    or changing the signatures of a method must trigger a version update.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天我们不再需要在客户端和服务器上使用相同的接口实现，这不符合我们独立可版本化和可部署的口号。幸运的是，框架更加灵活，我们可以采取与REST相同的方法，添加元素是可以的，但是删除元素或更改方法签名必须触发版本更新。
- en: Gob
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gob
- en: We have already looked at gob in the previous chapter but as a quick re-cap,
    the gob format was specifically designed to facilitate Go to Go-based communication
    and was structured around the idea of something easier to use and possibly more
    efficient than the likes of protocol buffers, this comes at a cost of cross-language
    communication.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中讨论了gob，但作为一个快速回顾，gob格式是专门为促进Go到Go通信而设计的，并且围绕着一个更容易使用且可能比类似协议缓冲区更高效的想法构建，但这牺牲了跨语言通信。
- en: '**gob object definition:**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**gob对象定义：**'
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: More information about gob can be found in the Go documentation at [https://golang.org/pkg/encoding/gob/](https://golang.org/pkg/encoding/gob/)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 关于gob的更多信息可以在Go文档中找到，网址为[https://golang.org/pkg/encoding/gob/](https://golang.org/pkg/encoding/gob/)
- en: Thrift
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thrift
- en: 'The Thrift framework was created by Facebook and was open sourced in 2007\.
    It is currently maintained by the Apache Software Foundation. The main aims of
    Thrift are:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook创建了Thrift框架，并于2007年开源。目前由Apache软件基金会维护。Thrift的主要目标是：
- en: '**Simplicity**: Thrift code is straightforward and approachable, free of unnecessary
    dependencies'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：Thrift代码简单易懂，没有不必要的依赖'
- en: '**Transparency**: Thrift conforms to the most common idioms in all languages'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明性**：Thrift符合所有语言中最常见的习惯用法'
- en: '**Consistency**: Niche, language-specific features belong in extensions, not
    in the core library'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：特定于语言的特性属于扩展，而不是核心库'
- en: '**Performance**: Strive for performance first, elegance second'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：首先追求性能，其次追求优雅'
- en: 'This is a thrift service definition:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Thrift服务定义：
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Find more information on Apache Thrift at [https://thrift.apache.org](https://thrift.apache.org).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://thrift.apache.org](https://thrift.apache.org)上找到更多关于Apache Thrift的信息。
- en: Protocol Buffers
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲
- en: 'Protocol Buffers are a Google product, and they have just entered their third
    revision. Protocol Buffers take the approach of providing a DSL that the generator
    (written in C) reads and can generate client and server stubs for over ten languages,
    the primary ten are maintained by Google and encompass: Go, Java, C, JavaScript
    for NodeJS.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲是谷歌的产品，它们刚刚进入第三个版本。协议缓冲采用提供一种DSL的方法，该生成器（用C编写）读取并可以生成超过十种语言的客户端和服务器存根，其中主要的前十种由谷歌维护，包括：Go、Java、C、NodeJS的JavaScript。
- en: Protocol Buffers is a pluggable architecture, so it is possible to write your
    own plugins to generate all kinds of endpoints not just RPC; however, RPC is the
    main use case as they are coupled to the gRPC framework.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲是一个可插拔的架构，因此可以编写自己的插件来生成各种端点，而不仅仅是RPC；然而，RPC是主要用例，因为它们与gRPC框架耦合。
- en: gRPC was designed by Google to be a fast and language agnostic RPC framework,
    which originated from an internal project where latency and speed were of the
    utmost importance in Google's architecture. By default, gRPC uses protocol buffers
    as the method for serializing and de-serializing structured data. An example of
    this DSL is shown in the following example.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是由谷歌设计的一个快速且语言无关的RPC框架，它起源于一个内部项目，在该项目中延迟和速度在谷歌的架构中至关重要。默认情况下，gRPC使用协议缓冲作为序列化和反序列化结构化数据的方法。以下示例展示了这种DSL的一个例子。
- en: 'Protocol buffer service definition:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲服务定义：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Find more information on Protocol Buffers at [https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/)上找到更多关于协议缓冲的信息。
- en: JSON-RPC
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-RPC
- en: JSON-RPC is an attempt at a standard way of representing objects for RPC using
    JSON. This removes the need to decode any proprietary binary protocol at the expense
    of transfer speed. There is no requirement for any particular client or server
    to serve this data format, TCP sockets, and the ability to write strings that
    pretty much most all programming languages can manage are all you require.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC是尝试使用JSON表示对象以用于RPC的标准方式。这消除了解码任何专有二进制协议的需要，但以传输速度为代价。没有要求任何特定的客户端或服务器提供此数据格式，TCP套接字，以及能够编写大多数所有编程语言都能管理的字符串的能力，这些都是您所需的所有。
- en: Unlike Thrift and Protocol Buffers, JSON-RPC sets the standard for the message
    serialization.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与Thrift和协议缓冲不同，JSON-RPC为消息序列化设定了标准。
- en: JSON-RPC implements some nice features that allow the batching of requests;
    every request contains an `id` parameter, which is established by the client.
    When the server responds it will return the same identifier allowing the client
    to understand to which request a response relates.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC实现了一些很好的功能，允许批量处理请求；每个请求都包含一个`id`参数，由客户端建立。当服务器响应时，它将返回相同的标识符，使客户端能够理解响应与哪个请求相关。
- en: 'This is a JSON-RPC serialized request:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JSON-RPC序列化请求：
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is a JSON-RPC serialized response:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JSON-RPC序列化响应：
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Find more information on JSON-RPC 2.0 at [http://www.jsonrpc.org/specification](http://www.jsonrpc.org/specification).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://www.jsonrpc.org/specification](http://www.jsonrpc.org/specification)上找到更多关于JSON-RPC
    2.0的信息。
- en: Filtering
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'When we looked at RESTful APIs we discussed the concept of using the query
    string to perform filtering actions such as:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看RESTful API时，我们讨论了使用查询字符串执行过滤操作的概念，例如：
- en: Paging
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页
- en: Filtering
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Sorting
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: 'Obviously, if we are writing an RPC API, we do not have the luxury of a query
    string; however, implementing these concepts is incredibly useful. As long as
    we are consistent there is no reason at all that we cannot define a parameter
    on our request object for the filter condition:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们正在编写RPC API，我们没有查询字符串的便利；然而，实现这些概念非常有用。只要我们保持一致性，就没有任何理由我们不能在我们的请求对象上定义用于过滤条件的参数：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is just an example and you will probably choose to implement something
    specific to your own needs, however, the key is consistency. If we use this same
    object for every method, we can be reasonably sure that our users will be cool
    with this.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，你可能会选择根据自己特定的需求实现，然而，关键在于一致性。如果我们为每个方法使用相同的对象，我们可以合理地确信我们的用户会对此感到满意。
- en: Versioning APIs
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本控制
- en: API versioning is something you should think about from the very beginning and
    avoid as long as you can. In general, you will need to make changes to your API,
    however, having to maintain *n* different versions can be a royal pain in the
    backside, so doing the upfront design thinking at the beginning can save you a
    whole load of trouble.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: API版本控制是你从一开始就应该考虑的事情，并且尽量避免。一般来说，你将需要修改你的API，然而，维护*n*个不同版本可能会非常痛苦，所以一开始就进行前期设计思考可以节省你很多麻烦。
- en: Before we look at how you can version your API, which is quite straightforward
    let's look at when you should version.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看您如何可以版本控制API之前，这相当直接，让我们看看您应该在何时进行版本控制。
- en: You would increment your API version number when you introduce a breaking change.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当您引入重大变更时，您将增加API版本号。
- en: 'Breaking changes include:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重大变更包括：
- en: Removing or renaming APIs or API parameters
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或重命名API或API参数
- en: Changing the type of an API parameter, for example, from integer to string
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变API参数的类型，例如，从整数更改为字符串
- en: Changes to response codes, error codes, or fault contracts
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改响应代码、错误代码或故障合同
- en: Changes to the behavior of an existing API
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变现有API的行为
- en: 'Things that do not involve a breaking change include:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 不涉及重大变更的事情包括：
- en: Adding parameters to a returned entity
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向返回实体添加参数
- en: Adding additional endpoints or functionality
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加额外的端点或功能
- en: Bug fixes or other maintenance that does not include items in the breaking changes
    list
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复错误或其他不包含在重大变更列表中的维护工作
- en: Semantic versioning
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义版本控制
- en: Microservices should implement the Major versioning scheme. Quite often, designers
    will elect to only implement a Major version number and imply `.0` for the minor
    version as according to the semantic versioning principles [http://semver.org](http://semver.org)
    a Minor version would generally indicate the addition of functionality that has
    been implemented in a backwards compatible way. This could be adding additional
    endpoints to your API. It can be argued that since this would not affect the client's
    ability to interact with your API you should not worry about Minor versions and
    only concentrate on major as the client will not need to request a particular
    version without these additions in order to function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该实施主版本号方案。通常，设计者会选择只实现主版本号，并暗示次要版本为`.0`，根据语义版本控制原则[http://semver.org](http://semver.org)，次要版本通常表示以向后兼容的方式实现的功能添加。这可能是向您的API添加额外的端点。可以争辩说，由于这不会影响客户端与您的API交互的能力，因此您不必担心次要版本，只需关注主版本即可，因为客户端不需要请求特定的版本才能正常工作。
- en: 'When versioning APIs I think it is cleaner to drop the minor version and only
    concentrate on major version. We would take this approach for two reasons:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当对API进行版本控制时，我认为删除次要版本并只关注主版本会更简洁。我们会采取这种方法的两个原因：
- en: The URI becomes more readable, and dots are only used as network location separators.
    When using an RPC API dots are only used to separate `API.VERSION.METHOD` and
    make everything easier to read.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI变得更加易读，点号仅用作网络位置分隔符。当使用RPC API时，点号仅用于分隔`API.VERSION.METHOD`，使一切更容易阅读。
- en: We should be inferring through our API versioning that change is a big thing
    and has an impact on the function of the client. Internally we can still use `Major.Minor`;
    however, this does not need to be something to the client as they will not have
    the capability to elect to use minor versions of the API.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该通过我们的API版本控制推断出变化是一件大事，并且对客户端的功能有影响。内部我们仍然可以使用`Major.Minor`；然而，这不需要对客户端来说是一个需要考虑的事情，因为他们将没有能力选择使用API的次要版本。
- en: Versioning formats for REST APIs
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API的版本控制格式
- en: To allow the client to request a particular API version, there are three common
    ways you can do this.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许客户端请求特定的API版本，有三种常见的方法可以实现。
- en: 'It can be done as part of the URI:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以作为URI的一部分来完成：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It can also be done as a query string parameter:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以作为查询字符串参数来完成：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, It can be done by using a custom HTTP header:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以通过使用自定义HTTP头来完成：
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Whichever way you implement versioning is up to you and your team, but it should
    play a big part in your upfront design thinking. Once you have decided on an option
    stick, to it as providing a consistent and great experience for your consumers
    should be one of your primary goals.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式来实现版本控制，这都取决于你和你团队，但它在你的前期设计思考中应该扮演重要角色。一旦你决定了一个选项，坚持使用它，确保为你的消费者提供一致且优秀的体验应该是你的主要目标之一。
- en: Versioning formats for RPC APIs
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC API的版本控制格式
- en: Versioning RPC can be a little more difficult as most likely you are not using
    HTTP as your transport. However, this is still possible. The best way to deal
    with this is the namespace of your handlers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: RPC的版本控制可能稍微困难一些，因为你很可能没有使用HTTP作为传输。然而，这仍然是可能的。处理这种情况的最佳方式是处理程序的命名空间。
- en: In the go base packages, you have the capability to give your handler a name,
    `Greet.v1.HelloWorld`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在go基础包中，你可以给你的处理程序命名，例如`Greet.v1.HelloWorld`。
- en: Naming for RPC
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC的命名
- en: 'With RPC you do not have the luxury of using HTTP verbs to confer the intent
    of the API, for example, you have the collection users. With an HTTP API you would
    be able to split up the various actions using `GET`, `POST`, `DELETE`, and so
    on. This is not possible with an RPC API and you need to think in the same way
    as if you were writing methods inside your Go code, so for example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RPC时，你没有使用HTTP动词来传达API意图的奢侈，例如，你有用户集合。在使用HTTP API的情况下，你可以通过`GET`、`POST`、`DELETE`等来分割各种操作。这在RPC
    API中是不可能的，你需要像编写Go代码中的方法一样思考，所以例如：
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code might be written as an RPC method as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码也可以写成如下RPC方法：
- en: '[PRE56]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Alternatively, it might be written as an RPC method as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以写成如下RPC方法：
- en: '[PRE57]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Sub collections become a little less semantic, whereas in a RESTful API you
    would be able to do the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 子集合在语义上变得稍微少一些，而在RESTful API中，你可以做以下操作：
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You cannot do this with an RPC API and you must explicitly specify the method
    as a separate entity:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用RPC API来做这件事，你必须明确指定方法作为一个单独的实体：
- en: '[PRE59]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The method name also needs to infer the action that the API is going to perform;
    you cannot rely on the use of HTTP verbs, so in the instance that you have a method
    that can delete a user you would have to add the delete verb into the method call,
    for example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名也需要推断API将要执行的操作；你不能依赖于HTTP动词的使用，所以如果你有一个可以删除用户的方法，你必须将删除动词添加到方法调用中，例如：
- en: '[PRE60]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding code would become:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将变为：
- en: '[PRE61]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Object type standardization
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类型标准化
- en: Whether you are using custom binary serialization, JSON, or JSON-RPC you need
    to think about how your user is going to handle the object at the other side of
    the transaction. Many of the serialization packages Protocol Buffers such as protocol
    buffers and Thrift that use stubs to generate client code will happily deal with
    serialization of simple types such as Dates into native types that enable your
    consumer to easily use and manipulate these objects. However, if you are using
    JSON or JSON-RPC there is no concept of a Date as a native type therefore it can
    be useful to fall back to ISO standards which the user of the client can easily
    deserialize. The Microsoft API design guidelines provide some good advice on how
    to handle Dates and Durations.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是自定义二进制序列化、JSON还是JSON-RPC，你都需要考虑你的用户将如何处理交易另一端的对象。许多使用stub生成客户端代码的序列化包，如Protocol
    Buffers和Thrift，会愉快地处理简单类型如日期的序列化到本地类型，这使得消费者可以轻松使用和操作这些对象。然而，如果你使用JSON或JSON-RPC，没有日期作为本地类型的概念，因此回退到ISO标准可能是有用的，客户端用户可以轻松反序列化。微软API设计指南提供了一些关于如何处理日期和持续时间的良好建议。
- en: Dates
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期
- en: When returning a date, you should always use the `DateLiteral` format and preferably
    the `Iso8601Literal`. If you do need to send back a date in a format other than
    `Iso8601Literal`, then you can use a `StructuredDateLiteral` format, which allows
    you to specify the kind as part of the returned entity.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回日期时，你应该始终使用`DateLiteral`格式，最好是`Iso8601Literal`。如果你需要以除`Iso8601Literal`之外的其他格式发送日期，则可以使用`StructuredDateLiteral`格式，这允许你在返回的实体中指定类型。
- en: 'The informal `Iso8601Literal` format is the simplest method to use and should
    be understandable by almost any client consuming your API:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式的 `Iso8601Literal` 格式是使用最简单的方法，并且几乎任何消费您API的客户端都应该能够理解：
- en: '[PRE62]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The more formal `StucturedDateLiteral` does not return a string, but an entity
    that contains two properties, `kind` and `value`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式的 `StucturedDateLiteral` 不返回字符串，而是一个包含两个属性 `kind` 和 `value` 的实体：
- en: '[PRE63]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The permissible kinds are:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的种类有：
- en: '`C`: **CLR**; number of milliseconds since midnight January 1 00'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`: **CLR**；自2000年1月1日午夜以来的毫秒数'
- en: '`E`: **ECMAScript**; number of milliseconds since midnight, January 1, 1970'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E`: **ECMAScript**；自1970年1月1日午夜以来的毫秒数'
- en: '`I`: **ISO 8601**; a string limited to the ECMAScript subset'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I`: **ISO 8601**；一个限于ECMAScript子集的字符串'
- en: '`O`: **OLE Date**; integral part is the number of days since midnight, December
    31, 1899, and fractional part is the time within the day (0.5 = midday)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O`: **OLE日期**；整数部分是自1899年12月31日午夜以来的天数，小数部分是当天的时间（0.5 = 中午）'
- en: '`T`: **Ticks**; number of ticks (100-nanosecond intervals) since midnight January
    1, 1601'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`: **刻度**；自1601年1月1日午夜以来的刻度（100纳秒间隔）数'
- en: '`U`: **UNIX**; number of seconds since midnight, January 1, 1970'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U`: **UNIX**；自1970年1月1日午夜以来的秒数'
- en: '`W`: **Windows**; number of milliseconds since midnight January 1, 1601'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`: **Windows**；自1601年1月1日午夜以来的毫秒数'
- en: '`X`: **Excel**; as for O, but the year 1900 is incorrectly treated as a leap
    year, and day 0 is "January 0 (zero)"'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`: **Excel**；与 `O` 相同，但1900年被错误地视为闰年，且天数为 "January 0 (零)"'
- en: Durations
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续时间
- en: 'Durations are serialized to conform with ISO 8601 and are represented by the
    following format:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间序列化为符合ISO 8601，并以下列格式表示：
- en: '[PRE64]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`P`: This is the duration designator (historically called "period") placed
    at the start of the duration representation'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P`: 这是持续时间标识符（历史上称为"周期"），放置在持续时间表示的开始处'
- en: '`Y`: This is the year designator that follows the value for the number of years'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Y`: 这是跟随年数值的年标识符'
- en: '`M`: This is the month designator that follows the value for the number of
    months'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`: 这是跟随月数值的月标识符'
- en: '`W`: This is the week designator that follows the value for the number of weeks'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`: 这是跟随周数值的周标识符'
- en: '`D`: This is the day designator that follows the value for the number of days'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`: 这是跟随天数值的日标识符'
- en: '`T`: This is the time designator that precedes the time components of the representation'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`: 这是时间表示中的时间组件之前的时间标识符'
- en: '`H`: This is the hour designator that follows the value for the number of hours'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`: 这是跟随小时数值的时标识符'
- en: '`M`: This is the minute designator that follows the value for the number of
    minutes'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`: 这是跟随分钟数值的分钟标识符'
- en: '`S`: This is the second designator that follows the value for the number of
    seconds'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`: 这是跟随秒数值的秒标识符'
- en: For example, `P3Y6M4DT12H30M5S` represents a duration of "three years, six months,
    four days, twelve hours, thirty minutes, and five seconds".
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`P3Y6M4DT12H30M5S` 表示 "三年，六个月，四天，十二小时，三十分钟和五秒" 的持续时间。
- en: Intervals
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间隔
- en: 'Again part of the ISO 8601 specification is if you need to receive or send
    an interval you can use the following format:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，ISO 8601规范的一部分是，如果您需要接收或发送一个间隔，您可以使用以下格式：
- en: Start and end, such as `2007-03-01T13:00:00Z/2008-05-11T15:30:00Z`
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束，例如 `2007-03-01T13:00:00Z/2008-05-11T15:30:00Z`
- en: Start and duration, such as `2007-03-01T13:00:00Z/P1Y2M10DT2H30M`
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和持续时间，例如 `2007-03-01T13:00:00Z/P1Y2M10DT2H30M`
- en: Duration and end, such as `P1Y2M10DT2H30M/2008-05-11T15:30:00Z`
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间和结束，例如 `P1Y2M10DT2H30M/2008-05-11T15:30:00Z`
- en: Duration only, such as `P1Y2M10DT2H30M`, with additional context information
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅持续时间，例如 `P1Y2M10DT2H30M`，带有额外的上下文信息
- en: Find more information on JSON serialization of dates and times at [https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times)
    查找有关日期和时间的JSON序列化的更多信息。
- en: Documenting APIs
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录API
- en: Documenting APIs is incredibly useful whether you intend the API to be consumed
    internally by other teams in your company, external users, or even only yourself.
    You will thank yourself for spending the time to document the operations of the
    API and keep this up to date. Keeping documentation up to date should not be an
    arduous task. There are many applications that can generate documentation automatically
    from your source code, so all you need to do is run this application as part of
    your build workflow.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 记录 API 非常有用，无论你打算让 API 被公司内部的其他团队、外部用户，甚至只是你自己使用。你会感谢自己花时间记录 API 操作并保持文档更新。保持文档更新不应是一项艰巨的任务。有许多应用程序可以从你的源代码自动生成文档，所以你只需要在构建工作流程中运行此应用程序即可。
- en: REST based-based APIs
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 REST 的 API
- en: 'Currently three primary standards are fighting it out to become the queen of
    REST API documentation:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有三个主要标准正在争夺成为 REST API 文档的皇后：
- en: Swagger
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger
- en: API Blueprint
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API Blueprint
- en: RAML
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAML
- en: Swagger
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger
- en: Swagger was designed by SmartBear and has been chosen to be part of the Open
    API Initiative; this potentially gives it the greatest chance of adoption as a
    standard for documenting RESTful APIs. The Open API Initiative ([https://openapis.org](https://openapis.org))
    however is an industry body and whether it gains the recognition that the W3C
    has around web standards is probably dependent on more big names joining.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 是由 SmartBear 设计的，并被选为 Open API 创新计划的一部分；这可能会给它带来最大的机会，成为文档化 RESTful
    API 的标准。然而，Open API 创新计划 ([https://openapis.org](https://openapis.org)) 是一个行业机构，它是否能够获得
    W3C 在网络标准方面的认可，可能取决于更多知名企业的加入。
- en: Documentation is written in YAML, and various code generation tools can both
    write Swagger documentation from source code as well as being able to generate
    client SDKs. The standard is comprehensive in its feature list and is also relatively
    simple to write as well as being well understood by the developer community.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是用 YAML 编写的，各种代码生成工具既可以从源代码生成 Swagger 文档，也可以生成客户端 SDK。该标准在功能列表上非常全面，并且相对简单易写，同时被开发社区广泛理解。
- en: 'The code example of Swagger is shown as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 的代码示例如下所示：
- en: '[PRE65]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Find more information on Swagger at [http://swagger.io](http://swagger.io).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://swagger.io](http://swagger.io) 查找有关 Swagger 的更多信息。
- en: API Blueprint
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API Blueprint
- en: API Blueprint is an open standard designed by Apiary and released under the
    MIT license. It ties closely into Apiary's products. However, it can be used on
    its own, and there are a variety of open source tools that read and write the
    format.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: API Blueprint 是由 Apiary 设计的开放标准，并按照 MIT 许可证发布。它与 Apiary 的产品紧密相连。然而，它也可以独立使用，并且有各种开源工具可以读取和写入该格式。
- en: Documentation is written in Markdown, which can make authoring the documentation
    feel a little more natural rather than dealing with nested layers of objects.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是用 Markdown 编写的，这使得编写文档感觉更加自然，而不是处理嵌套的对象层。
- en: 'The code example for API Blueprint is shown as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: API Blueprint 的代码示例如下所示：
- en: '[PRE66]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Find more information on API Blueprint at [https://apiblueprint.org](https://apiblueprint.org).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://apiblueprint.org](https://apiblueprint.org) 查找有关 API Blueprint 的更多信息。
- en: RAML
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAML
- en: '**RAML** stands for **RESTful API Modelling Language** and is written in `YAML`
    format. It aims to allow the definition of a human-readable format that describes
    resources, methods, parameters, responses, media types, and other HTTP constructs
    that form the basis of your API.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAML** 代表 **RESTful API Modelling Language**，并以 `YAML` 格式编写。它的目标是允许定义一种人类可读的格式，用于描述资源、方法、参数、响应、媒体类型以及其他构成你
    API 基础的 HTTP 构造。'
- en: 'The code example for RAML is shown as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: RAML 的代码示例如下所示：
- en: '[PRE67]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Find more information on RAML at [http://raml.org](http://raml.org).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://raml.org](http://raml.org) 查找有关 RAML 的更多信息。
- en: RPC based-based APIs
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 RPC 的 API
- en: With RPC APIs there is an argument that your contract is your documentation,
    in the following example we define the interface using the protocol buffers DSL
    and would make any necessary comments to assist the consumer as required. The
    predominant theory to follow is one of self-documenting code that your methods
    and parameter names should infer intent and enough description to negate the use
    of comments.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RPC API 中，有一种观点认为你的合同就是你的文档，在以下示例中，我们使用协议缓冲区 DSL 定义接口，并根据需要添加任何必要的注释来帮助消费者。主要遵循的理论是自文档化代码，你的方法和参数名称应该推断意图并提供足够的描述，以消除注释的使用。
- en: 'Protocol buffer example:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区示例：
- en: '[PRE68]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Which standard you choose is entirely dependent on you, your workflow, your
    team standards, and your users. It will vary from case to case, however, once
    you choose an approach in the same way as you do with naming conventions you should
    stick to a consistent style across all of your APIs.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪种标准完全取决于你，你的工作流程，你的团队标准，以及你的用户。然而，一旦你选择了与命名约定相同的方法，你应该坚持在你的所有 API 中保持一致的风格。
- en: Summary
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we did not spend much time looking at code; however, we have
    looked at some essential concepts around writing a great API, which is as important
    as being able to write the code.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们没有花太多时间查看代码；然而，我们已经研究了编写优秀 API 的某些基本概念，这和能够编写代码一样重要。
- en: The bulk of this chapter has been concerned with RESTful APIs as unlike RPC
    we need to be a little more descriptive in their use. We also have the capability
    to leverage the principles of HATEOAS, which we do not have when using RPC.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都关注于 RESTful API，因为与 RPC 不同，我们需要在它们的用法上更加描述性。我们还有能力利用 HATEOAS 的原则，这是在使用
    RPC 时所不具备的。
- en: In the next chapter, we will start to look at some of the fantastic frameworks
    that exist in the Go community, so we can start applying these principles and
    furthering our advancement to microservice mastery.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨 Go 社区中存在的一些令人惊叹的框架，这样我们就可以开始应用这些原则，并进一步深化我们对微服务精通的进步。
