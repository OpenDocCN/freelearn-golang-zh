- en: Designing a Great API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of whether you are experienced in building APIs and microservices
    and looking for the techniques on how you can apply them with Go or you are completely
    new to the world of microservices, it is worth spending the time to read this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an API contract feels part art, part science and, when you discuss your
    design with other engineers, you will most certainly agree to disagree, not to
    the level of tabs versus spaces, but there is certainly something personal about
    API contracts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the two most popular options, which are RESTful
    and RPC. We will examine the semantics of each approach, which will equip you
    with the knowledge to argue your case when the inevitable discussion (read argument)
    occurs. Choosing between REST or RPC may be entirely down to your current environment.
    If you currently have services running that implement a RESTful approach, then
    I suggest you stick with it, likewise if you now use RPC. One thing I would suggest
    is that you read the entire chapter to understand the semantics, pros, and cons
    of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term **REST** was suggested by Roy Fielding in his Ph.D. dissertation in
    the year 2000\. It stands for **Representational State Transfer** and is described
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '"REST emphasizes scalability of component interactions, generality of interfaces,
    independent deployment of components, and intermediary components to reduce interaction
    latency, enforce security and encapsulate legacy systems."'
  prefs: []
  type: TYPE_NORMAL
- en: Having an API that conforms to the REST principles is what makes it RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: URIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main components in the HTTP protocol is a URI. **URI** stands for
    **Uniform Resource Identifiers** and is the method by which you will access the
    API. You may be asking what the difference between a URI and a URL (Uniform Resource
    Locator) is? When I started to write this chapter, I wondered about this myself
    and did what any self-respecting developer would do, which is to head over to
    Stack Overflow. Unfortunately, my confusion only grew as there were lots of detailed
    answers, none of which I found particularly enlightening. Time to head over to
    the inner circle of hell also known as W3C standards to look up the RFC for the
    official answer.
  prefs: []
  type: TYPE_NORMAL
- en: In short, there is no difference, a URL is a URI that identifies a resource
    by its network location, and it is acceptable to interchange the terms when describing
    a resource entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The clarification document published back in 2001 ([http://www.w3.org/TR/uri-clarification](http://www.w3.org/TR/uri-clarification))
    goes on to explain that in the early to mid-90s there was an assumption that an
    identifier is cast into one or two classes. An identifier might specify the location
    of a resource (URL) or its name (Uniform Resource Name URN) independent of location.
    A URI could either be a URL or a URN. Using this example, `http://` would be a
    URL scheme and `isbn:` a URN scheme. However, this changed over time and the importance
    of the additional level of hierarchy lessened. The view changed that an individual
    scheme does not need to be cast into one of a discrete set of types.
  prefs: []
  type: TYPE_NORMAL
- en: The conventional approach is that `http:` is a URI scheme and `urn:` is also
    a URI scheme. URNs take the form `urn:isbn:n-nn-nnnnnn-n`, `isbn:` is a URN namespace
    identifier, not a URN scheme or a URI scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Following this view, the term URL does not refer to a formal partition of URI
    space rather, URL is an informal concept; a URL is a type of URI that identifies
    a resource via its network location.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this book, we will use the term URI and when we do we will be
    talking about a method to access a resource that is running on a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: URI format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RFC 3986, which was published in 2005 [https://www.ietf.org/rfc/rfc3986.txt](https://www.ietf.org/rfc/rfc3986.txt),
    defines the format that makes valid URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are will use the path element in order to locate an endpoint that is running
    on our server. In a REST endpoint, this can contain parameters as well as a document
    location. The query string is equally important, as you will use this to pass
    parameters such as page number or ordering to control the data that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some general rules for URI formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: A forward slash `/` is used to indicate a hierarchical relationship between
    resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trailing forward slash `/` should not be included in URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyphens `-` should be used to improve readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscores `_` should not be used in URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowercase letters are preferred as case sensitivity is a differentiator in the
    `path` part of a URI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept behind many of the rules is that a URI should be easy to read and
    to construct. It should also be consistent in the way that it is built so you
    should follow the same taxonomy for all the endpoints in your API.
  prefs: []
  type: TYPE_NORMAL
- en: URI path design for REST services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Paths are broken into documents, collections, stores, and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A collection is a directory of resources typically broken by parameters to
    access an individual document. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When defining a collection, we should always use a plural noun such as `cats`
    or `people` for the collection name.
  prefs: []
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A document is a resource pointing to a single object, similar to a row in a
    database. It has the ability to have child resources that may be both sub-documents
    or collections. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A controller resource is like a procedure, this is typically used when a resource
    cannot be mapped to standard **CRUD** (**create**, **retrieve**, **update**, and
    **delete**) functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names for controllers appear as the last segment in a URI path with no
    child resources. If the controller requires parameters, these would typically
    be included in the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When defining a controller name we should always use a verb. A verb is a word
    that indicates an action or a state of being, such as `feed` or `send`.
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A store is a client-managed resource repository, it allows the client to add,
    retrieve, and delete resources. Unlike a collection, a store will never generate
    a new URI it will use the one specified by the client. Take a look at the following
    example that would add a new cat to our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would add a new cat to the store with an ID of `2`, if we had posted the
    new cat omitting the ID to a collection the response would need to include a reference
    to the newly defined document so we could later interact with it. Like controllers
    we should use a plural noun for store names.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD function names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing great REST URIs we never use a CRUD function name as part of
    the URI, instead we use a HTTP verb. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not include the verb in the name of the method as this is specified by
    the HTTP verb, the following URIs would be considered an anti-pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we look at HTTP verbs in the next section this will make more sense.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The commonly used HTTP verbs are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these methods has a well-defined semantic within the context of our
    REST API and the correct implementation will help your user understand your intention.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GET` method is used to retrieve a resource and should never be used to
    mutate an operation, such as updating a record. Typically, a body is not passed
    with a `GET` request; however, it is not an invalid `HTTP` request to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `POST` method is used to create a new resource in a collection or to execute
    a controller. It is typically a non-idempotent action, in that multiple posts
    to create an element in a collection that will create multiple elements not updated
    after the first call.
  prefs: []
  type: TYPE_NORMAL
- en: The `POST` method is always used when calling controllers as the actions of
    this is considered non-idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: PUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `PUT` method is used to update a mutable resource and must always include
    the resource locator. The `PUT` method calls are also idempotent in that multiple
    requests will not mutate the resource to a different state than the first call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: PATCH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `PATCH` verb is used to perform a partial update, for example, if we only
    wanted to update the name of our cat we could make a `PATCH` request only containing
    the details that we would like to change.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In my experience PATCH updates are rarely used, the general convention is to
    use a PUT and to update the whole object, this not only makes the code easier
    to write but also makes an API which is simpler to understand.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DELETE` verb is used when we want to remove a resource, generally we would
    pass the ID of the resource as part of the path rather than in the body of the
    request. This way, we have a consistent method for updating, deleting, and retrieving
    a document.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: HEAD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A client would use the `HEAD` verb when they would like to retrieve the headers
    for a resource without the body. The `HEAD` verb is typically used in place of
    a `GET` verb when a client only wants to check if a resource exists or to read
    the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: OPTIONS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OPTIONS` verb is used when a client would like to retrieve the possible
    interactions for a resource. Typically, the server will return an `Allow` header,
    which will include the `HTTP` verbs that can be used with this resource.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: URI query design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is perfectly acceptable to use a query string as part of an API call; however,
    I would refrain from using this to pass data to the service. Instead the query
    should be used to perform actions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Paging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we need to make a call to a controller, we discussed earlier that we should
    use a `POST` request as this is most likely a non-idempotent request. To pass
    data to the service, we should include the data inside of the body. However, we
    could use a query string to filter the action of the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we would send a status update email with the message
    included in the body of the request, because we are using the group filter passed
    in the query string we could restrict the action of this controller to only send
    to the admin group.
  prefs: []
  type: TYPE_NORMAL
- en: If we had added the message to the query string and not passed a message body,
    then we would potentially be causing two problems for ourselves. The first is
    that the max length for a URI is 2083 characters. The second is that generally
    a `POST` request would always include a request body. Whilst this is not required
    by the `HTTP` specification, it would be expected behavior by the majority of
    your users.
  prefs: []
  type: TYPE_NORMAL
- en: Response codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing a great API, we should use `HTTP` status codes to indicate to the
    client the success or failure of the request. In this chapter, we will not be
    taking a comprehensive look at all the status codes available; there are many
    resources on the Internet that have this information. We will provide some sources
    for further reading, what we will do is look at the status codes that you as a
    software engineer will want your microservice to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, it is a generally held consensus that this is good practice as it
    allows the client to immediately determine the status of a request without having
    to dive into the request body to gain further insight. In the instance of a failure
    and APIs that always return a `200 OK` response to the user with a message body
    containing further information is not good practice as it requires the client
    to have to inspect the body to determine outcome. It also means that the message
    body will contain additional information other than the object that it should
    represent. Consider the following bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bad request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Successful request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Imagine if you were writing a client for the preceding request, you need to
    add logic to your application to check the status node in the response before
    you could read and process the returned kitten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider something even worse:'
  prefs: []
  type: TYPE_NORMAL
- en: 'And even worse failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And even worse success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If your API author had done something like the preceding example, you need to
    check to see if the response that has been returned is an error or the kitten
    that you were expecting. The number of WTFs per minute you would utter whilst
    coding a client for this API would not endear you to its author. These might seem
    like extreme examples, but there are instances like this out in the wild, at some
    point in my career I'm fairly sure I have been guilty of such a crime, but then
    I had not read this book.
  prefs: []
  type: TYPE_NORMAL
- en: What the author in their best intention has done is try to take the HTTP status
    codes too literally. W3C RFC2616 states that the HTTP status code relates to the
    attempt to understand and satisfy the request ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1));
    however, this is a little ambiguous when you look at some of the individual status
    codes. Modern consensus is that it is OK to use HTTP status codes to indicate
    the processing state of an API request not just the server's ability to process
    the request. Consider how we could make these requests better by implementing
    this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A good example of a success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is far more semantic; the user only ever needs to read the response in
    the instance of a failure if they require further information. In addition to
    this we can provide a standard error object that is used across all the endpoints
    of our API, which provides further but non-required information to determine why
    a request failed. We will look at error objects in a little while, but for now
    let's look at HTTP status codes more in depth.
  prefs: []
  type: TYPE_NORMAL
- en: 2xx Success
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2xx status codes indicate that the clients request has been successfully received
    and understood.
  prefs: []
  type: TYPE_NORMAL
- en: 200 OK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a generic response code indicating that the request has succeeded.
    The response accompanying this code is generally:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: An, an entity corresponding to the requested resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: The, the header fields corresponding to the requested resource without
    the message body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: An, an entity describing or containing the result of the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 201 Created
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The created response is sent when a request succeeds and the result is that
    a new entity has been created. Along with the response it is common that the API
    will return a `Location` header with the location of the newly created entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is optional to return an object body with this response type.
  prefs: []
  type: TYPE_NORMAL
- en: 204 No Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This status informs the client that the request has been successfully processed;
    however, there will be no message body with the response. For example, if the
    user makes a `DELETE` request to the collection then the response may return a
    204 status.
  prefs: []
  type: TYPE_NORMAL
- en: 3xx Redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 3xx indicate class of status codes indicates that the client must take additional
    action to complete the request. Many of these status codes are used by CDNs and
    other content redirection techniques, however, code 304 can exceptionally useful
    when designing our APIs to provide semantic feedback to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 301 Moved Permanently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tells the client that the resource they have requested has been permanently
    moved to a different location. Whilst this is traditionally used to redirect a
    page or resource from a web server it can also be useful to us when we are building
    our APIs. In the instance that we rename a collection we could use a 301 redirect
    to send the client to the correct location. This however should be used as an
    exception rather than the norm. Some clients do not implicitly follow 301 redirect
    and implementing this capability adds additional complexity for your consumers.
  prefs: []
  type: TYPE_NORMAL
- en: 304 Not Modified
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This response is generally used by a CDN or caching server and is set to indicate
    that the response has not been modified since the last call to the API. This is
    designed to save bandwidth and the request will not return a body, but will return
    a `Content-Location` and `Expires` header.
  prefs: []
  type: TYPE_NORMAL
- en: 4xx Client Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the instance of an error caused by a client, not the server, the server will
    return a 4xx response and will always return an entity that gives further details
    on the error.
  prefs: []
  type: TYPE_NORMAL
- en: 400 Bad Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This response indicates that the request could not be understood by the client
    due to a malformed request or due to a failure of domain validation (missing data,
    or an operation that would cause invalid state).
  prefs: []
  type: TYPE_NORMAL
- en: 401 Unauthorized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This indicates that the request requires user authentication and will include
    a `WWW-Authenticate` header containing a challenge applicable to the requested
    resource. If the user has included the required credentials in the `WWW-Authenticate`
    header, then the response should include an error object that may contain relevant
    diagnostic information.
  prefs: []
  type: TYPE_NORMAL
- en: 403 Forbidden
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server has understood the request, but is refusing to fulfill it. This could
    be due to incorrect access level to a resource not that the user is not authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: If the server does not wish to make the fact that a request is not able to access
    a resource due to access level public, then it is permissible to return a `404
    Not found` status instead of this response.
  prefs: []
  type: TYPE_NORMAL
- en: 404 Not Found
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This response indicates that the server has not found anything matching the
    requested URI. No indication is given of whether the condition is temporary or
    permanent.
  prefs: []
  type: TYPE_NORMAL
- en: It is permissible for the client to make multiple requests to this endpoint
    as the state may not be permanent.
  prefs: []
  type: TYPE_NORMAL
- en: 405 Method Not Allowed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method specified in the request is not allowed for the resource indicated
    by the URI. This may be when the client attempts to mutate a collection by sending
    a `POST`, `PUT`, or `PATCH` to a collection that only serves retrieval of documents.
  prefs: []
  type: TYPE_NORMAL
- en: 408 Request Timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client did not produce a request within the time that the server is prepared
    to wait. The client may repeat the request without modification at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 5xx Server Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Response status codes within the 500 range indicate that something has gone
    "Bang", the server knows this and is sorry for the situation.
  prefs: []
  type: TYPE_NORMAL
- en: The RFC advises that an error entity should be returned in the response explaining
    whether this is permanent or temporary and containing an explanation of the error.
    When we look at our chapter on security we will look at the recommendation about
    not giving too much information away in error messages as this state may have
    been engineered by a user in the attempt to compromise your system and by returning
    things such as a stack trace or other internal information with a 5xx error can
    actually help to compromise your system. With this in mind it is currently common
    that a 500 error will just return something very generic.
  prefs: []
  type: TYPE_NORMAL
- en: 500 Internal Server Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generic error message indicating that something did not go quite as planned.
  prefs: []
  type: TYPE_NORMAL
- en: 503 Service Unavailable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server is currently unavailable due to temporary overloading or maintenance.
    There is a rather useful pattern that you can implement to avoid cascading failure
    in the instance of a malfunction in which the microservice will monitor its internal
    state and in the case of failure or overloading will refuse to accept the request
    and immediately signal this to the client. We will look at this pattern more in
    chapter xx; however, this instance is probably where you will be wanting to return
    a 503 status code. This could also be used as part of your health checks.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Request headers are a really important part of the HTTP request and response
    process and implementing a standard approach helps your users to transition from
    one API to another. In this sub section, we will not cover all the possible headers
    that you can use in your API, but we will look at the most common headers for
    full information on the HTTP protocol please take a look at RFC 7231 [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231).
    This document contains a comprehensive overview of the current standard.
  prefs: []
  type: TYPE_NORMAL
- en: Standard request headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Request headers provide additional information for the request and the response
    of your API. Think of them like metadata for the operation. They can be used to
    augment other data for the response that does not belong in the body itself such
    as the content encoding. They can also be utilized by the client to provide information
    that can help the server process the response. Where possible we should always
    use the standard headers as this gives consistency to your user and provides them
    with a common standard across multiple endpoints from many different vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization - string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Authorization is one of the most commonly used request headers, even if you
    have a public read only API I advise you to ask the user to authorize their requests.
    By requesting that the user authorizes a request, you have the capability to perform
    operations such as user level logging and rate limiting. Quite often you may see
    authorization conducted with a custom request header such as "X-API-Authorization".
    I would recommend you do not use this approach as the standard Authorization header
    as specified by the W3C RFC 2616 ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html))
    has all the capability we need. Many companies such as Twitter and PayPal use
    this header to authenticate requests let''s. Let''s look at a simple example from
    Twitter''s developer documentation to see how this can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The header is in the form of `[Authorization method] [Comma separated URL encoded
    values]`. This clearly informs the server that the authorization type is OAuth
    and the various components of this authorization follow this in a comma delaminated
    format. By following this standard approach you can enable your consumers to use
    a third-party library that implements this standard and thus save them the work
    of having to build a bespoke implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timestamp of the request in RFC 3339 format.
  prefs: []
  type: TYPE_NORMAL
- en: Accept - content type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requested content type for the response, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/javascript` (for JSONP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept-Encoding - gzip, deflate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST endpoints should always support gzip and deflate encoding, when applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing gzip support in Go is relatively straightforward; we showed how
    it is possible to implement middleware into your microservices in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml),
    *Introduction to Microservices*. In the following example, we will use this technique
    to create a gzip response writer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core of writing a response in a gzipped format is the `compress/gzip` package,
    which is part of the standard library. It allows you to create a `Writer` interface
    that implements `ioWriteCloser` wrapping an existing `io.Writer`, which writes
    to the given writer using the gzip compression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To create our handler we are going to write the `NewGzipHandler` function, this
    returns a new `http.Handler` that will wrap our standard output handler.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is create our own `ResponseWriter` that embeds
    `http.ResponseWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2.1 `chapter2/gzip/gzip_deflate.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The core method for this is the implementation of the `Write` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the implementation for `Write` in the standard `http.Response`
    struct there is a whole load of stuff going on in there that we neither want to
    lose or re-implement because the `gzip.Writer` object is created with a writer
    when we call `Write` on it, it then in turn calls write on `http.Response` and
    we lose none of the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally in our `NewGzipHandler` our handler checks to see if the client
    has sent the `Accept-Encoding` header and if so we will write the response using
    the `GzipResponseWriter` method if the client has requested uncompressed content
    then we only call `ServeHttp` with the standard `ResponseWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is by no means a comprehensive example and there are many open source packages
    like the one from the team at the NY Times ([https://github.com/NYTimes/gziphandler](https://github.com/NYTimes/gziphandler)),
    which manages this for you.
  prefs: []
  type: TYPE_NORMAL
- en: As a little programming test, why not try and modify this example to implement
    `DEFLATE`.
  prefs: []
  type: TYPE_NORMAL
- en: Standard response headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All services should return the following headers.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date`: The date that the request was processed in RFC 3339 format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Type`: The content type of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Encoding`: gzip or deflate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Request-ID`/`X-Correlation-ID`: Whilst you may not directly request your
    clients to implement this header it may be something that you add to requests
    when you call downstream services. When you are trying to debug a service that
    is running in production it can be incredibly useful to be able to group all the
    requests by a single transaction ID. A common practice that we will see when we
    look at logging and monitoring is to store all logs in a common database such
    as Elastic Search. By setting the standard way of working when building many connected
    microservices that they pass the correlation ID with each downstream call you
    will be able to query your logs in Kibana or another log query tool and group
    them into a single transaction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Returning errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the instance of failure, users of your API should be able to write one piece
    of code that handles errors across different endpoints. A standard error entity
    will help your consumers by enabling them to write DRY code whenever an error
    caused by client or server occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Microsoft API guidelines recommend the following format for these entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**ErrorResponse**: **Object**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ErrorResponse` is the top level object which will be returned by our response
    and contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Type** | **Required** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| error | Error | ![](img/e2f574a5-74e7-43c1-a797-49375f0cbcc0.png) | The error
    object. |'
  prefs: []
  type: TYPE_TB
- en: '**Error: Object**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Error` object is the detail for our error response; it provides full detail
    for the reason that the error occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Type** | **Required** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Code | `String` (enumerated) | ![](img/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png)
    | One of a server-defined set of error codes. |'
  prefs: []
  type: TYPE_TB
- en: '| message | String | ![](img/9b35e8ba-feaa-4967-8bec-ebf5269f3b15.png) | A
    human-readable representation of the error. |'
  prefs: []
  type: TYPE_TB
- en: '| Target | String | - | The target of the error. |'
  prefs: []
  type: TYPE_TB
- en: '| Details | Error[] | - | An array of details about specific errors that led
    to this reported error. |'
  prefs: []
  type: TYPE_TB
- en: '| innererror | InnerError | - | An object containing more specific information
    than the current object about the error. |'
  prefs: []
  type: TYPE_TB
- en: '**InnerError**: **Object**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Type** | **Required** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Code | String | - | A more specific error code than was provided by the containing
    error. |'
  prefs: []
  type: TYPE_TB
- en: '| innererror | InnerError | - | An object containing more specific information
    than the current object about the error. |'
  prefs: []
  type: TYPE_TB
- en: 'Microsoft has provided an excellent API guidelines resource, you can read more
    about returning errors by looking at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-errors)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing APIs from JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web browsers implement a sandbox mechanism that restricts resources in one domain
    from accessing resources in another. For example, you may have an API that allows
    the modification and retrieval of user data and a website that provides an interface
    for this API. If the browser did not implement the "same-origin policy" and assuming
    the user did not log out of their session then it would be possible for a malicious
    page to send a request to the API and modify it without you knowing.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this, there are two methods that can be implemented by your microservice
    to allow this access, **JSONP** which stands for (**JSON with Padding**) and **CORS**
    (**Cross-Origin Resource Sharing**).
  prefs: []
  type: TYPE_NORMAL
- en: JSONP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSONP is pretty much a hack, and it is implemented by most browsers that do
    not implement the later CORS standard. It is restricted to `GET` requests only
    and works by getting round the issue that while `XMLHTTPRequest` is blocked from
    making requests to third-party servers, there are no restrictions on HTML script
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: A JSONP request inserts a `<script src="img/...">` element into the browsers
    DOM with the API's URI as the `src` target. This component returns a function
    call with the JSON data as a parameter, and when this loads, the function executes
    passing the data to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript callback is defined in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the response from the API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To denote a request for data to be returned as JSONP, generally the `callback=functionName`
    parameter is added to the URI, in our example this would be `/helloworld?callback=success`.
    Implementing this is particularly straightforward let's take a look at our simple
    Go `helloworld` example and see how we can modify this to implement JSONP.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note is the `Content-Type` header that we are returning. We are
    no longer returning `application/json` as we are not returning JSON we are actually
    returning JavaScript so we must set the `Content-Type` header accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Example `chapter2/jsonp/jsonp.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at an example of how we can send JSONP with Go, our
    response object is going to be exactly the same as the ones in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml),
    *Introduction to Microservices*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is all in the handler, if we look at line **30** we are checking
    to see if there is a callback parameter in the query string. This would be provided
    by the client and indicates the function they expect to be called when the response
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To return our response in JSONP format all we need to do is wrap the standard
    response to a JavaScript function call. In line **33**, we are taking the callback
    function name that was passed by the client and encapsulating the response we
    would normally send. The resultant output would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Response**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: CORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming your users are using a desktop browser that has been released in the
    last five years, or a mobile browser such as iOS 9 or Android 4.2+, then implementing
    CORS will be more than enough. [http://caniuse.com/#feat=cors](http://caniuse.com/#feat=cors)
    says that it is over 92% of all Internet users. I was looking forward to bashing
    IE for the lack of full adoption; however, since this has been supported since
    IE8 I will have to complain about mobile users.
  prefs: []
  type: TYPE_NORMAL
- en: CORS is a W3C proposal to standardize cross-origin requests from the browser.
    It works by the browsers built in `HTTP` client making an `OPTIONS` request to
    a URI before the real request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server at the other end returns a header that contains the origin of
    the domain from which the script is being loaded, then the browser will trust
    the server and will allow a cross-site request to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing this in Go is quite straightforward and we could create a middleware
    to globally manage this for us. For simplicity, in our example we have hard coded
    this into the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2.2 `chapter2/cors/cors.go`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In line **25**, we detect if the request method is `OPTIONS` and instead of
    returning the response we return the `Access-Control-Allow-Origin` header that
    the client is expecting. In our example, we are simply returning `\*`, which means
    all domains are allowed to interact with this API. This is not the safest implementation
    and quite often you will request your API users to register the domains that will
    be interacting with the API and restrict the `Allow-Origin` to only include those
    domains. In addition to the `Allow-Origin` header we are also returning the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This tells the browser that it can only make `GET` requests to this URI and
    that it is forbidden to make `POST`, `PUT`, and so on. This is an optional header,
    but it can be used to enhance your user's security when interacting with the API.
    One thing to note is that we are not sending back a `200 OK` response we are using
    `204 No Content` since it is invalid to return a body with an `OPTIONS` request.
  prefs: []
  type: TYPE_NORMAL
- en: RPC APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RPC stands for remote procedure call; it is a method of executing a function
    or method on a remote machine. RPC has been around since the dawn of time and
    there are many different types of RPC technology some of which relies on there
    being an interface definition (SOAP, Thrift Protocol Buffers). This interface
    definition can make it easier to generate client and server stubs for different
    technology stacks. Generally, the interface is defined using a **DSL** (**domain
    specific language**) and a generator program will use this to create application
    clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Where REST needs to use HTTP as a transport layer, RPC is not bound by this
    constraint, and while it is possible to send RPC calls over HTTP, you can use
    the lightness of TCP or even UDP sockets if you choose to.
  prefs: []
  type: TYPE_NORMAL
- en: RPC has seen a resurgence in use lately with many large-scale systems built
    by the likes of Uber, Google, Netflix, and so on are using RPC. Due to the speed
    and performance that you can get from the lower latency from not using HTTP and
    the smaller message size attained by implementing a binary message format rather
    than JSON or XML.
  prefs: []
  type: TYPE_NORMAL
- en: The detractors of RPC mention the tight coupling that can occur between the
    client and the server in that if you update the contract on the server then all
    the clients need to be updated too. With many modern RPC implementations this
    is less of a problem and in fact is no less a problem than you can have with RESTful
    APIs. Whilst old technology such as JMI was tightly bound, requiring the client
    and the server to share the same interface, modern implementations such as Protocol
    Buffers marshal the object sensibly and will not throw an error should there be
    minor differences. Thus by following the standard guidelines in the *Versioning
    APIs* section you have no less a problem than if you were implementing a RESTful
    API.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of RPC is that you can quickly generate a client for your
    users, this allows an abstraction from both the transport and the message type
    and allows them to depend upon an interface. As the creator you can change the
    underlying implementation of your application such as a move from Thrift to Proto
    buffers, without requiring the client to do anything other than use the latest
    version of your provided client. Versioning also allows you to retain the same
    backward compatibility that you can achieve with REST.
  prefs: []
  type: TYPE_NORMAL
- en: RPC API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the principles we have just discussed for creating a good RESTful API
    can also apply to RPC. However; one of the main differences is that you may not
    be using HTTP as your transport; therefore you are not always going to be able
    to use HTTP status codes as an indicator of success or failure. **RPC** stands
    for **Remote Procedure Call** and dates way back before the Internet. It was originally
    conceived as a way to execute a procedure that could be running in a separate
    application on the same machine or even potentially on the network. While we take
    this for granted now, back in the 90s this was cutting edge. Unfortunately, frameworks
    such as CORBA and Java RMI gave RPC a bad name and even now if you speak to an
    opponent of RPC they will most likely bring these two frameworks up. The benefits,
    however, were performance, using binary serialization is incredibly efficient
    on the network and we no longer have the tight coupling that RMI and CORBA enforced.
    We are also not trying to do anything too clever; we are no longer attempting
    to share an object across two processes we are taking a more functional approach,
    that is, methods that return immutable objects. This gives us the best of both
    worlds; the simplicity of interoperation and the speed and small payload of binary
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: RPC message frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These days we are no longer coupled to having the same interface implementation
    on both the client and the server, this would not adhere to our mantra of independently
    versionable and deployable. Thankfully frameworks are more flexible we can take
    the same approach as we do with REST, it is OK to add, however, removing elements
    or changing the signatures of a method must trigger a version update.
  prefs: []
  type: TYPE_NORMAL
- en: Gob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already looked at gob in the previous chapter but as a quick re-cap,
    the gob format was specifically designed to facilitate Go to Go-based communication
    and was structured around the idea of something easier to use and possibly more
    efficient than the likes of protocol buffers, this comes at a cost of cross-language
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: '**gob object definition:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: More information about gob can be found in the Go documentation at [https://golang.org/pkg/encoding/gob/](https://golang.org/pkg/encoding/gob/)
  prefs: []
  type: TYPE_NORMAL
- en: Thrift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Thrift framework was created by Facebook and was open sourced in 2007\.
    It is currently maintained by the Apache Software Foundation. The main aims of
    Thrift are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: Thrift code is straightforward and approachable, free of unnecessary
    dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparency**: Thrift conforms to the most common idioms in all languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Niche, language-specific features belong in extensions, not
    in the core library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Strive for performance first, elegance second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a thrift service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Find more information on Apache Thrift at [https://thrift.apache.org](https://thrift.apache.org).
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Protocol Buffers are a Google product, and they have just entered their third
    revision. Protocol Buffers take the approach of providing a DSL that the generator
    (written in C) reads and can generate client and server stubs for over ten languages,
    the primary ten are maintained by Google and encompass: Go, Java, C, JavaScript
    for NodeJS.'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Buffers is a pluggable architecture, so it is possible to write your
    own plugins to generate all kinds of endpoints not just RPC; however, RPC is the
    main use case as they are coupled to the gRPC framework.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC was designed by Google to be a fast and language agnostic RPC framework,
    which originated from an internal project where latency and speed were of the
    utmost importance in Google's architecture. By default, gRPC uses protocol buffers
    as the method for serializing and de-serializing structured data. An example of
    this DSL is shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocol buffer service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Find more information on Protocol Buffers at [https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/).
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON-RPC is an attempt at a standard way of representing objects for RPC using
    JSON. This removes the need to decode any proprietary binary protocol at the expense
    of transfer speed. There is no requirement for any particular client or server
    to serve this data format, TCP sockets, and the ability to write strings that
    pretty much most all programming languages can manage are all you require.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Thrift and Protocol Buffers, JSON-RPC sets the standard for the message
    serialization.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC implements some nice features that allow the batching of requests;
    every request contains an `id` parameter, which is established by the client.
    When the server responds it will return the same identifier allowing the client
    to understand to which request a response relates.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a JSON-RPC serialized request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a JSON-RPC serialized response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Find more information on JSON-RPC 2.0 at [http://www.jsonrpc.org/specification](http://www.jsonrpc.org/specification).
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we looked at RESTful APIs we discussed the concept of using the query
    string to perform filtering actions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Paging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, if we are writing an RPC API, we do not have the luxury of a query
    string; however, implementing these concepts is incredibly useful. As long as
    we are consistent there is no reason at all that we cannot define a parameter
    on our request object for the filter condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is just an example and you will probably choose to implement something
    specific to your own needs, however, the key is consistency. If we use this same
    object for every method, we can be reasonably sure that our users will be cool
    with this.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API versioning is something you should think about from the very beginning and
    avoid as long as you can. In general, you will need to make changes to your API,
    however, having to maintain *n* different versions can be a royal pain in the
    backside, so doing the upfront design thinking at the beginning can save you a
    whole load of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at how you can version your API, which is quite straightforward
    let's look at when you should version.
  prefs: []
  type: TYPE_NORMAL
- en: You would increment your API version number when you introduce a breaking change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking changes include:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing or renaming APIs or API parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the type of an API parameter, for example, from integer to string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to response codes, error codes, or fault contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to the behavior of an existing API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Things that do not involve a breaking change include:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding parameters to a returned entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding additional endpoints or functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bug fixes or other maintenance that does not include items in the breaking changes
    list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices should implement the Major versioning scheme. Quite often, designers
    will elect to only implement a Major version number and imply `.0` for the minor
    version as according to the semantic versioning principles [http://semver.org](http://semver.org)
    a Minor version would generally indicate the addition of functionality that has
    been implemented in a backwards compatible way. This could be adding additional
    endpoints to your API. It can be argued that since this would not affect the client's
    ability to interact with your API you should not worry about Minor versions and
    only concentrate on major as the client will not need to request a particular
    version without these additions in order to function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When versioning APIs I think it is cleaner to drop the minor version and only
    concentrate on major version. We would take this approach for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The URI becomes more readable, and dots are only used as network location separators.
    When using an RPC API dots are only used to separate `API.VERSION.METHOD` and
    make everything easier to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should be inferring through our API versioning that change is a big thing
    and has an impact on the function of the client. Internally we can still use `Major.Minor`;
    however, this does not need to be something to the client as they will not have
    the capability to elect to use minor versions of the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning formats for REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow the client to request a particular API version, there are three common
    ways you can do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be done as part of the URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be done as a query string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, It can be done by using a custom HTTP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Whichever way you implement versioning is up to you and your team, but it should
    play a big part in your upfront design thinking. Once you have decided on an option
    stick, to it as providing a consistent and great experience for your consumers
    should be one of your primary goals.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning formats for RPC APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Versioning RPC can be a little more difficult as most likely you are not using
    HTTP as your transport. However, this is still possible. The best way to deal
    with this is the namespace of your handlers.
  prefs: []
  type: TYPE_NORMAL
- en: In the go base packages, you have the capability to give your handler a name,
    `Greet.v1.HelloWorld`.
  prefs: []
  type: TYPE_NORMAL
- en: Naming for RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With RPC you do not have the luxury of using HTTP verbs to confer the intent
    of the API, for example, you have the collection users. With an HTTP API you would
    be able to split up the various actions using `GET`, `POST`, `DELETE`, and so
    on. This is not possible with an RPC API and you need to think in the same way
    as if you were writing methods inside your Go code, so for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code might be written as an RPC method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it might be written as an RPC method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Sub collections become a little less semantic, whereas in a RESTful API you
    would be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot do this with an RPC API and you must explicitly specify the method
    as a separate entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The method name also needs to infer the action that the API is going to perform;
    you cannot rely on the use of HTTP verbs, so in the instance that you have a method
    that can delete a user you would have to add the delete verb into the method call,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Object type standardization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you are using custom binary serialization, JSON, or JSON-RPC you need
    to think about how your user is going to handle the object at the other side of
    the transaction. Many of the serialization packages Protocol Buffers such as protocol
    buffers and Thrift that use stubs to generate client code will happily deal with
    serialization of simple types such as Dates into native types that enable your
    consumer to easily use and manipulate these objects. However, if you are using
    JSON or JSON-RPC there is no concept of a Date as a native type therefore it can
    be useful to fall back to ISO standards which the user of the client can easily
    deserialize. The Microsoft API design guidelines provide some good advice on how
    to handle Dates and Durations.
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When returning a date, you should always use the `DateLiteral` format and preferably
    the `Iso8601Literal`. If you do need to send back a date in a format other than
    `Iso8601Literal`, then you can use a `StructuredDateLiteral` format, which allows
    you to specify the kind as part of the returned entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The informal `Iso8601Literal` format is the simplest method to use and should
    be understandable by almost any client consuming your API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The more formal `StucturedDateLiteral` does not return a string, but an entity
    that contains two properties, `kind` and `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The permissible kinds are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C`: **CLR**; number of milliseconds since midnight January 1 00'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E`: **ECMAScript**; number of milliseconds since midnight, January 1, 1970'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I`: **ISO 8601**; a string limited to the ECMAScript subset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O`: **OLE Date**; integral part is the number of days since midnight, December
    31, 1899, and fractional part is the time within the day (0.5 = midday)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T`: **Ticks**; number of ticks (100-nanosecond intervals) since midnight January
    1, 1601'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U`: **UNIX**; number of seconds since midnight, January 1, 1970'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: **Windows**; number of milliseconds since midnight January 1, 1601'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X`: **Excel**; as for O, but the year 1900 is incorrectly treated as a leap
    year, and day 0 is "January 0 (zero)"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Durations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Durations are serialized to conform with ISO 8601 and are represented by the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`P`: This is the duration designator (historically called "period") placed
    at the start of the duration representation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Y`: This is the year designator that follows the value for the number of years'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: This is the month designator that follows the value for the number of
    months'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: This is the week designator that follows the value for the number of weeks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: This is the day designator that follows the value for the number of days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T`: This is the time designator that precedes the time components of the representation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: This is the hour designator that follows the value for the number of hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: This is the minute designator that follows the value for the number of
    minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: This is the second designator that follows the value for the number of
    seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `P3Y6M4DT12H30M5S` represents a duration of "three years, six months,
    four days, twelve hours, thirty minutes, and five seconds".
  prefs: []
  type: TYPE_NORMAL
- en: Intervals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again part of the ISO 8601 specification is if you need to receive or send
    an interval you can use the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: Start and end, such as `2007-03-01T13:00:00Z/2008-05-11T15:30:00Z`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start and duration, such as `2007-03-01T13:00:00Z/P1Y2M10DT2H30M`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duration and end, such as `P1Y2M10DT2H30M/2008-05-11T15:30:00Z`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duration only, such as `P1Y2M10DT2H30M`, with additional context information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information on JSON serialization of dates and times at [https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#113-json-serialization-of-dates-and-times).
  prefs: []
  type: TYPE_NORMAL
- en: Documenting APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documenting APIs is incredibly useful whether you intend the API to be consumed
    internally by other teams in your company, external users, or even only yourself.
    You will thank yourself for spending the time to document the operations of the
    API and keep this up to date. Keeping documentation up to date should not be an
    arduous task. There are many applications that can generate documentation automatically
    from your source code, so all you need to do is run this application as part of
    your build workflow.
  prefs: []
  type: TYPE_NORMAL
- en: REST based-based APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently three primary standards are fighting it out to become the queen of
    REST API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger was designed by SmartBear and has been chosen to be part of the Open
    API Initiative; this potentially gives it the greatest chance of adoption as a
    standard for documenting RESTful APIs. The Open API Initiative ([https://openapis.org](https://openapis.org))
    however is an industry body and whether it gains the recognition that the W3C
    has around web standards is probably dependent on more big names joining.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is written in YAML, and various code generation tools can both
    write Swagger documentation from source code as well as being able to generate
    client SDKs. The standard is comprehensive in its feature list and is also relatively
    simple to write as well as being well understood by the developer community.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code example of Swagger is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Find more information on Swagger at [http://swagger.io](http://swagger.io).
  prefs: []
  type: TYPE_NORMAL
- en: API Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Blueprint is an open standard designed by Apiary and released under the
    MIT license. It ties closely into Apiary's products. However, it can be used on
    its own, and there are a variety of open source tools that read and write the
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is written in Markdown, which can make authoring the documentation
    feel a little more natural rather than dealing with nested layers of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code example for API Blueprint is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Find more information on API Blueprint at [https://apiblueprint.org](https://apiblueprint.org).
  prefs: []
  type: TYPE_NORMAL
- en: RAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RAML** stands for **RESTful API Modelling Language** and is written in `YAML`
    format. It aims to allow the definition of a human-readable format that describes
    resources, methods, parameters, responses, media types, and other HTTP constructs
    that form the basis of your API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code example for RAML is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Find more information on RAML at [http://raml.org](http://raml.org).
  prefs: []
  type: TYPE_NORMAL
- en: RPC based-based APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With RPC APIs there is an argument that your contract is your documentation,
    in the following example we define the interface using the protocol buffers DSL
    and would make any necessary comments to assist the consumer as required. The
    predominant theory to follow is one of self-documenting code that your methods
    and parameter names should infer intent and enough description to negate the use
    of comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocol buffer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Which standard you choose is entirely dependent on you, your workflow, your
    team standards, and your users. It will vary from case to case, however, once
    you choose an approach in the same way as you do with naming conventions you should
    stick to a consistent style across all of your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we did not spend much time looking at code; however, we have
    looked at some essential concepts around writing a great API, which is as important
    as being able to write the code.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of this chapter has been concerned with RESTful APIs as unlike RPC
    we need to be a little more descriptive in their use. We also have the capability
    to leverage the principles of HATEOAS, which we do not have when using RPC.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to look at some of the fantastic frameworks
    that exist in the Go community, so we can start applying these principles and
    furthering our advancement to microservice mastery.
  prefs: []
  type: TYPE_NORMAL
