- en: Introducing Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Docker
- en: Before we go any further with this book, we need to look at a little thing called
    Docker, before we begin don't forget to clone the example code repository [https://github.com/building-microservices-with-go/chapter3.git](https://github.com/building-microservices-with-go/chapter3.git).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续本书的内容之前，我们需要先了解一下被称为 Docker 的这个小东西，在我们开始之前，别忘了克隆示例代码仓库 [https://github.com/building-microservices-with-go/chapter3.git](https://github.com/building-microservices-with-go/chapter3.git)。
- en: Introducing Containers with Docker
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 介绍容器
- en: Docker is a platform that has risen to prominence in the last three years; it
    was born out of the desire to simplify the process of building, shipping, and
    running applications. Docker is not the inventor of the container, Jacques Gélinas
    created the VServer project back in 2001, and since then the other main projects
    have been LXC from IBM and rkt from CoreOS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个在过去三年中崛起的平台；它诞生于简化构建、运输和运行应用程序过程的愿望。Docker 不是容器的发明者，Jacques Gélinas
    在 2001 年创建了 VServer 项目，从那时起，其他主要项目还包括 IBM 的 LXC 和 CoreOS 的 rkt。
- en: 'If you would like to read more about the history, then I recommend this excellent
    blog post by Redhat: [http://rhelblog.redhat.com/2015/08/28/the-history-of-containers](http://rhelblog.redhat.com/2015/08/28/the-history-of-containers),
    this section is going to concentrate on Docker which is by far the most popular
    current technology.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于历史的信息，我推荐阅读 Redhat 的这篇优秀的博客文章：[http://rhelblog.redhat.com/2015/08/28/the-history-of-containers](http://rhelblog.redhat.com/2015/08/28/the-history-of-containers)，本节将重点介绍
    Docker，这是目前最受欢迎的技术。
- en: 'The concept of a container is process isolation and application packaging.
    To quote Docker:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的概念是进程隔离和应用程序打包。引用 Docker 的话：
- en: 'A container image is a lightweight, stand-alone, executable package of a piece
    of software that includes everything needed to run it: code, runtime, system tools,
    system libraries, settings.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是一个轻量级、独立、可执行的软件包，它包含了运行该软件所需的一切：代码、运行时、系统工具、系统库、设置。
- en: '...'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Containers isolate software from its surroundings, for example, differences
    between development and staging environments and help reduce conflicts between
    teams running different software on the same infrastructure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将软件与其环境隔离开来，例如，开发环境和预发布环境之间的差异，并有助于减少在相同基础设施上运行不同软件的团队之间的冲突。
- en: Where they benefit application development is that we can take advantage of
    this when deploying these applications as it allows us to pack them closer together,
    saving on hardware resources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在应用开发中的好处是，在部署这些应用程序时，我们可以利用这一点，因为它允许我们将它们打包得更紧密，节省硬件资源。
- en: From a development and test lifecycle, containers give us the capability to
    run production code on our development machines with no complicated setup; it
    also allows us to create that `Clean Room` environment without having different
    instances of the same database installed to trial new software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发和测试生命周期来看，容器使我们能够在开发机器上运行生产代码，而无需复杂的设置；它还允许我们创建一个“洁净室”环境，而无需安装不同实例的同数据库来测试新软件。
- en: Containers have become the primary choice for packaging microservices, and as
    we progress through the examples in this book, you will learn how invaluable it
    is to your workflow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已成为打包微服务的首选方案，随着我们在本书中的示例进展，你将了解到这对你的工作流程是多么宝贵。
- en: Containers work by isolating processes and filesystems from each other. Unless
    explicitly specified, containers cannot access each other's file systems. They
    also cannot interact with one another via TCP or UDP sockets unless again specified.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过隔离进程和文件系统来工作。除非明确指定，否则容器无法访问彼此的文件系统。除非再次指定，否则它们也不能通过 TCP 或 UDP 套接字相互交互。
- en: Docker is made up of many parts; however, at its core is the Docker Engine,
    a lightweight application runtime with features for orchestration, scheduling
    networking, and security. Docker Engine can be installed anywhere on a physical
    or virtual host, and it supports both Windows and Linux. Containers allow developers
    to package large or small amounts of code and their dependencies together into
    an isolated package.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 由许多部分组成；然而，其核心是 Docker 引擎，这是一个轻量级的应用程序运行时，具有编排、调度、网络和安全功能。Docker 引擎可以安装在物理或虚拟主机上的任何位置，并且支持
    Windows 和 Linux。容器允许开发者将大量或少量代码及其依赖项打包到一个隔离的包中。
- en: We can also draw from a huge array of pre-created images, just about all software
    vendors from MySQL to IBM's WebSphere have an official image that is available
    for us to use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从大量的预先创建的镜像中获取资源，几乎所有的软件供应商，从MySQL到IBM的WebSphere，都有官方镜像可供我们使用。
- en: Docker also uses Go, in fact nearly all of the code that goes into the Docker
    Engine and other applications are written in Go.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker也使用Go语言，实际上，几乎所有的Docker Engine和其他应用程序的代码都是用Go编写的。
- en: Rather than write an essay on how Docker works, let's examine each of the features
    by example. By the end of this chapter, we will take one of the simple examples
    that we created in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml), *Introduction
    to Microservices*, and create a Docker image for it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不如通过实例来检查每个功能，而不是写一篇关于Docker如何工作的论文。到本章结束时，我们将使用在[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)，“微服务简介”中创建的一个简单示例，并为它创建一个Docker镜像。
- en: Installing Docker
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Head over to [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)
    and install the correct version of Docker on your machine. You will find versions
    for Mac, Windows, and Linux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)，并在你的机器上安装正确的Docker版本。你将找到适用于Mac、Windows和Linux的版本。
- en: Running our first container
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的第一个容器
- en: To validate Docker has been installed correctly, let's run our first container,
    **hello-world** is actually an image, an image is an immutable snapshot of a container.
    Once we start these with the following command they become containers, think of
    it like types and instances, a type defines fields and methods making up behavior.
    An instance is a living instantiation of this type, you can assign other types
    to the fields and call the methods to perform actions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证Docker是否正确安装，让我们运行我们的第一个容器，**hello-world**实际上是一个镜像，镜像是一个不可变的容器快照。一旦我们用以下命令启动它们，它们就变成了容器，把它想象成类型和实例，类型定义了构成行为的字段和方法。实例是这个类型的活生生的实例化，你可以将其他类型分配给字段并调用方法来执行操作。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing you should see is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该看到的是：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you execute a `docker run` the first thing the engine does is check to
    see if you have the image installed locally. If it doesn't then it connects to
    the default registry, in this case, [https://hub.docker.com/](https://hub.docker.com/)
    to retrieve it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行`docker run`时，引擎首先会检查你是否已经安装了镜像。如果没有，它会连接到默认的注册表，在这种情况下，[https://hub.docker.com/](https://hub.docker.com/)，以检索它。
- en: 'Once the image has been downloaded, the daemon can create a container from
    the downloaded image, all the output is streamed to the output on your terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像被下载，守护进程可以从下载的镜像创建一个容器，所有输出都会流到你的终端上：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `--rm` flag tells the Docker engine to remove the container and delete
    any resources such as volumes it was using on exit. Unless we would like to re-start
    a container at some point it is good practice to use the `--rm` flag to keep our
    filesystem clean, otherwise, all of the temporary volumes which are created will
    sit around and consume space.Let''s try something a little more complicated, this
    time, we will start a container and create a shell inside of it to show how you
    can navigate to the internal file system. Execute the following command in your
    terminal:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`--rm`标志告诉Docker引擎在退出时删除容器并删除它所使用的任何资源，如卷。除非我们想在某个时候重新启动容器，否则使用`--rm`标志来保持我们的文件系统干净是一个好习惯，否则，所有创建的临时卷都会存在并占用空间。让我们尝试一个稍微复杂一些的例子，这次，我们将启动一个容器并在其中创建一个shell来展示如何导航到内部文件系统。在你的终端中执行以下命令： '
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alpine is a lightweight version of Linux and is perfect for running Go applications.
    The `-it` flags stand for **interactive terminal** it maps the standard in from
    your terminal to the input of the running container. The `sh` statement after
    the name of the image we want to run is the name of the command we would like
    to execute in the container when it starts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine是Linux的一个轻量级版本，非常适合运行Go应用程序。`-it`标志代表**交互式终端**，它将你的终端的标准输入映射到正在运行的容器的输入。在我们要运行的镜像名称之后的`sh`语句是我们希望在容器启动时执行的命令的名称。
- en: 'If all went well, you should now be inside a shell of the container. If you
    check the current directory by executing the `ls` command, you will see the following,
    which hopefully is not the directory you were in before running the command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你现在应该已经在一个容器的shell中了。如果你通过执行`ls`命令检查当前目录，你会看到以下内容，希望这并不是你在运行命令之前的目录：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the root folder of the newly started container, containers are immutable,
    so any changes you make to the file system in a running container is disposed
    of when the container is stopped. While this may seem to be a problem, there are
    solutions for persisting data, which we will look at in a little bit, however,
    for now, the important concept to remember is that:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新启动的容器的根文件夹，容器是不可变的，所以你对运行中的容器文件系统所做的任何更改，在容器停止时都会被丢弃。虽然这看起来可能是一个问题，但有一些持久化数据的方法，我们稍后会看看，但现在，重要的是要记住：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent"'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: “容器是不可变的镜像实例，并且默认情况下数据卷是非持久的”
- en: You need to remember this when designing your services, to illustrate how this
    works take a look at this simple example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计你的服务时，你需要记住这一点，为了说明这是如何工作的，请看这个简单的例子。
- en: 'Open another terminal and execute the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端并执行以下命令：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `docker ps` command queries the engine and returns a list of the containers,
    by default this only shows the running containers, however, if we add the `-a`
    flag we can also see stopped containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps` 命令查询引擎并返回一个容器列表，默认情况下这仅显示正在运行的容器，然而，如果我们添加 `-a` 标志，我们也可以看到停止的容器。'
- en: 'The Alpine Linux container that we started earlier is currently running, so
    jump back to your previous terminal window and create a file in the root file
    system:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前启动的 Alpine Linux 容器目前正在运行，所以回到你之前的终端窗口，在根文件系统中创建一个文件：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we list the directory structure again, we can see that a file has been created
    in the root of the file system:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次列出目录结构，我们可以看到在文件系统的根目录下创建了一个文件：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now exit the container using the `exit` command and run `docker ps` again,
    you should see the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 `exit` 命令退出容器，并再次运行 `docker ps`，你应该看到以下输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we add the `-a` flag command to see stopped containers too, we should see
    the container we started earlier:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加 `-a` 标志命令来查看停止的容器，我们也应该看到我们之前启动的容器：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, start another container again using the `docker run` command and list the
    directory contents in the root folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次使用 `docker run` 命令启动另一个容器，并列出根文件夹中的目录内容。
- en: 'No `mytestfile.txt` right? The reason this does not exist is because of the
    principle we were discussing earlier, which I think is important to mention again
    as if this is the first time you have used Docker it will catch you out:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `mytestfile.txt` 吧？这个文件不存在的原因是因为我们之前讨论的原则，我认为再次提到这一点很重要，因为如果你是第一次使用 Docker，这可能会让你感到意外：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent."'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “容器是不可变的镜像实例，并且默认情况下数据卷是非持久的。”
- en: There is something worth noting, however, unless you explicitly remove a container
    it will persist in a stopped state on the Docker host.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一点值得注意，除非你明确删除容器，否则它将保持在 Docker 主机上的停止状态。
- en: Removing containers is important to remember for two reasons; the first is that
    if you do not remember this, you will fill up the disk on your host quickly as
    every time you create a container Docker will allocate space on the host for the
    container volumes. The second is that the container can be restarted.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 删除容器有两个重要原因；第一个是如果你不记得这一点，你很快就会填满主机的磁盘，因为每次你创建一个容器，Docker 都会在主机上为容器卷分配空间。第二个原因是容器可以被重启。
- en: 'Restarted that sounds cool, in fact, it is a handy feature, not something you
    should use in your production environment, for that you need to remember the golden
    rule and design your application accordingly:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重启听起来很酷，实际上，这是一个方便的功能，不是你应该在生产环境中使用的东西，为此你需要记住黄金法则并相应地设计你的应用程序：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent."'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “容器是不可变的镜像实例，并且默认情况下数据卷是非持久的。”
- en: However, the use of Docker extends far beyond simply running applications for
    your microservices. It is an awesome way to manage your development dependencies
    without cluttering up your development machine. We will look at that a little
    later on, but for now, we are interested in how we can restart a stopped container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker的使用远远超出了仅仅为你的微服务运行应用程序。这是一个管理你的开发依赖项而不会让你的开发机器变得杂乱无章的绝佳方式。我们稍后会看看这一点，但现在，我们感兴趣的是我们如何重启一个停止的容器。
- en: 'If we execute the `docker ps -a` command, we will see that we now have two
    stopped containers. The oldest one is the first container we started to which
    we added our `mytestfile.txt`. This is the one we want to restart, so grab the
    ID of the container and execute the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`docker ps -a`命令，我们会看到现在有两个停止的容器。最老的一个是我们第一次启动并添加了`mytestfile.txt`的容器。这是我们想要重新启动的容器，所以获取容器的ID并执行以下命令：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, you should be in a shell at the root of the container if you check the
    directory contents what do you think you will find?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你检查容器的目录内容，你应该在容器的根目录下的shell中，你认为你会找到什么？
- en: That's right, `mytestfile.txt`; this is because when you restarted the container,
    the engine remounted the volumes that were attached the first time you ran the
    command. These are the same volumes you mutated to add the file as mentioned earlier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，`mytestfile.txt`；这是因为当你重新启动容器时，引擎重新挂载了你在第一次运行命令时附加的卷。这些就是之前提到的你修改以添加文件的相同卷。
- en: 'So we can restart our container; however, I just want to repeat the golden
    rule one last time:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们可以重新启动我们的容器；然而，我只想最后一次重复黄金法则：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent."'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"容器是镜像的不变实例，数据卷默认是非持久的。"'
- en: When running in a production environment, you cannot ensure that you can restart
    a container. There are a million reasons for this, one of the main ones that we
    will look at more in depth when we look at orchestration is that containers are
    generally run on a cluster of hosts. Since there is no guarantee which host the
    container will be restarted on or even that the host the container was previously
    running on actually exists. There are many projects that attempt to solve this,
    but the best approach is to avoid the complexity altogether. If you need to persist
    files, then store them in something that is designed for the job such as Amazon
    S3 or Google Cloud Storage. Design your applications around this principle and
    you will spend far less time panicking when the inevitable happens, and your super
    sensitive data container disappears.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行时，你不能确保可以重新启动一个容器。这里有成千上万的原因，其中一个主要的原因是我们将在查看编排时更深入地探讨，那就是容器通常运行在一组主机上。由于无法保证容器将在哪个主机上重新启动，甚至无法保证容器之前运行的主机实际上存在。有许多项目试图解决这个问题，但最好的方法是完全避免这种复杂性。如果你需要持久化文件，那么将它们存储在为这项工作设计的某些东西中，比如Amazon
    S3或Google Cloud Storage。围绕这个原则设计你的应用程序，这样当不可避免的事情发生时，你将花更少的时间惊慌，而且你的超级敏感数据容器不会消失。
- en: OK, before we look at Docker volumes in more depth let's clean up after ourselves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在我们更深入地了解Docker卷之前，让我们清理一下。
- en: Exit your container and get back to the shell on the Docker host. If we run
    `docker ps -a` ,we will see that there are two stopped containers. To remove these,
    we can use the `docker rm containerid` command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 退出你的容器并回到Docker主机上的shell。如果我们运行`docker ps -a`，我们会看到有两个停止的容器。为了删除这些容器，我们可以使用`docker
    rm containerid`命令。
- en: Run this now using the first `containerid` in your list, if this is successful,
    the container ID you asked to be removed would be echoed back to you, and the
    container will is deleted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用你列表中的第一个`containerid`运行此命令，如果成功，你请求删除的容器ID将被回显给你，并且容器将被删除。
- en: 'If you want to remove all the stopped containers you can use the following
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要删除所有停止的容器，可以使用以下命令：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `docker ps -a -q` the `-a` flag will list all the containers including the
    stopped ones, `-q` will return a list of the container IDs rather than the full
    details. We are passing this as a parameter list to `docker rm`, which will remove
    all the containers in the list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps -a -q`，`-a`标志将列出所有容器，包括停止的容器，`-q`将返回容器ID的列表而不是完整详情。我们将此作为参数列表传递给`docker
    rm`，它将删除列表中的所有容器。'
- en: To avoid having to remove a container we can use the `--rm` flag when starting
    a new container. This flag tells Docker to remove the container when it stops.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要删除容器，我们可以在启动新容器时使用`--rm`标志。此标志告诉Docker在容器停止时删除它。
- en: Docker volumes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker卷
- en: We have seen how Docker containers are immutable; however, there are some instances
    when you may wish to write some files to a disk or when you want to read data
    from a disk such as in a development setup. Docker has the concept of volumes,
    which can be mounted either from the host running the Docker machine or from another
    Docker container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Docker容器是不可变的；然而，在某些情况下，您可能希望将一些文件写入磁盘，或者当您想要从磁盘读取数据，例如在开发环境中。Docker有卷的概念，可以从运行Docker机器的主机或另一个Docker容器挂载。
- en: Union filesystem
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: To keep our images efficient and compact Docker uses the concept of a Union
    File System. The Union filesystem allows us to represent a logical file system
    by grouping different directories and or files together. It uses a **Copy on Write**
    technique, which copies the layer when we modify the file system, this way we
    only use about 1MB of space when creating a new image. When data is written to
    the file system Docker copies the layer and puts it on the top of the stack. When
    building images and extending existing images we are leveraging this technique,
    also when starting an image and creating a container the only difference is this
    writable layer, which means we do not need to copy all the layers every time and
    fill up our disk.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的镜像高效且紧凑，Docker使用了联合文件系统的概念。联合文件系统允许我们通过将不同的目录和或文件组合在一起来表示一个逻辑文件系统。它使用**写时复制**技术，在我们修改文件系统时复制层，这样我们在创建新镜像时只使用大约1MB的空间。当数据写入文件系统时，Docker会复制层并将其放在栈的顶部。在构建镜像和扩展现有镜像时，我们利用了这项技术，同样，在启动镜像和创建容器时，唯一的区别就是这个可写层，这意味着我们不需要每次都复制所有层并填满我们的磁盘。
- en: Mounting volumes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载卷
- en: The `-v`, or `--volume` parameter allows you to specify a pair of values corresponding
    to the file system you wish to mount on the host and the path where you would
    like to mount the volume inside the container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v` 或 `--volume` 参数允许您指定一对值，这对值对应于您希望在主机上挂载的文件系统以及您希望在容器内部挂载卷的路径。'
- en: 'Let''s try our example from earlier, but this time mounting a volume on the
    local file system:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试之前的示例，但这次是在本地文件系统上挂载一个卷：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you change into the host folder, you will see that there is access to the
    same folder from where you ran the `docker run` command. The syntax for the values
    for `-v` is `hostfolder:destinationfolder`, one thing I think is important to
    point out is that these paths need to be absolute, and you cannot use a relative
    path like `./` or `../foldername`. The volume you have just mounted has read/write
    access, any changes you make will be synchronized to the folder on the host so
    be careful to not go running `rm -rf *`. Creating Volumes on a production environment
    should be used very sparingly, I would advise that where possible you avoid doing
    it all together as in a production environment there is no guarantee if a container
    dies and is re-created that it will be replaced on the same host where it was
    previously. This means that any changes you have made to the volume will be lost.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您切换到主机文件夹，您会看到从您运行`docker run`命令的位置可以访问相同的文件夹。`-v`参数值的语法是`hostfolder:destinationfolder`，我认为需要指出的一点是，这些路径必须是绝对路径，您不能使用相对路径，如`./`或`../foldername`。您刚刚挂载的卷具有读写访问权限，您所做的任何更改都将同步到主机上的文件夹，所以请小心不要执行`rm
    -rf *`。在生产环境中创建卷应该非常谨慎使用，我建议在可能的情况下完全避免这样做，因为在生产环境中，没有保证如果容器死亡并被重新创建，它将替换为之前所在的主机。这意味着您对卷所做的任何更改都将丢失。
- en: Docker ports
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker端口
- en: When running web applications inside a container, it is quite common that we
    will need to expose some ports to the outside world. By default, a Docker container
    is completely isolated, and if you start a server running on port `8080` inside
    your container unless you explicitly specify that port is accessible from the
    outside, it will not be accessible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当在容器内运行Web应用时，我们通常会需要将一些端口暴露给外部世界。默认情况下，Docker容器是完全隔离的，如果您在容器内启动一个运行在端口`8080`的服务器，除非您明确指定该端口可以从外部访问，否则它将不可访问。
- en: Mapping ports is a good thing from a security perspective as we are operating
    on a principle of no trust. It is also effortless to expose these ports. Using
    one of the examples we created in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml),
    *Introduction to Microservices*, let's see just how easy this is.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，映射端口是一件好事，因为我们遵循的是不信任的原则。同时，暴露这些端口也毫不费力。使用我们在[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)“微服务简介”中创建的示例，让我们看看这有多简单。
- en: 'Move to the folder where you checked out the sample code, and run the following
    Docker command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到您检出示例代码的文件夹，并运行以下Docker命令：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-w` flag we are passing is to set the working directory that means that
    any command we run in the container will be run inside this folder. When we start
    the shell, you will see that rather than having to change into the folder we specify
    in the second part of the volume mounting we are already in that folder and can
    run our application. We are also using a slightly different image this time. We
    are not using `alpine:latest`, which is a lightweight version of Linux, we are
    using `golang:alpine`, which is a version of Alpine with the most recent Go tools
    installed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的`-w`标志是用来设置工作目录的，这意味着我们在容器中运行的任何命令都将在这个文件夹内运行。当我们启动shell时，你会看到，我们不需要切换到我们在卷挂载的第二部分指定的文件夹，我们已经在那个文件夹里，可以运行我们的应用程序。我们这次也使用了一个稍微不同的镜像。我们不是使用`alpine:latest`，这是一个轻量级的Linux版本，我们使用的是`golang:alpine`，这是一个安装了最新Go工具的Alpine版本。
- en: 'If we start our application using the `go run main.go` command; we should see
    the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`go run main.go`命令启动我们的应用程序；我们应该会看到以下输出：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now change to another shell and try to curl the API endpoint:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到另一个shell，并尝试curl API端点：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see something like the following message returned:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的消息返回：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we run the `docker ps` command to inspect the running containers, we will
    see that there are no ports exposed. Go back to your previous terminal window
    and kill the command and then exit the container.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`docker ps`命令来检查正在运行的容器，我们会看到没有端口被暴露。回到你之前的终端窗口，终止命令并退出容器。
- en: This time, when we start it, we will add the `-p` argument to specify the port.
    Like volumes, this takes a pair of values separated by a colon `(:)`. The first
    is the destination port on the host that we would like to bind to the second is
    the source port on the Docker container to which our application is bound.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们启动它时，我们将添加`-p`参数来指定端口。就像卷一样，这需要一对由冒号（`:`）分隔的值。第一个是我们希望绑定到主机上的目标端口，第二个是我们应用程序绑定的Docker容器上的源端口。
- en: Because this binds to the port on the host machine, in the same way that you
    would not be able to start the program locally twice because of the port binding,
    you cannot do this with the host port mappings in Docker either. Of course, you
    can start multiple instances of your code in separate containers and bind to different
    ports, and we will see how you can do that in just a bit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这绑定到了主机上的端口，就像你因为端口绑定而无法在本地两次启动程序一样，你也不能在Docker的主机端口映射中这样做。当然，你可以在不同的容器中启动你的代码的多个实例，并将它们绑定到不同的端口，我们将在稍后看到如何做到这一点。
- en: But first let's take a look at that port command, rather than starting a container
    and creating a shell to run our application we can do this in one command by replacing
    the `/bin/sh` command with our `go run` command. Give that a try and see if you
    can get your application running.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先让我们看看那个端口命令，而不是启动一个容器并创建一个shell来运行我们的应用程序，我们可以通过将`/bin/sh`命令替换为我们的`go run`命令，用一条命令来完成这个操作。试一试，看看你能否运行你的应用程序。
- en: Got it?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？
- en: 'You should have typed something like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该输入了类似以下的内容：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now try your `curl` to send some data to the API again, you should see the
    following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次尝试使用`curl`向API发送一些数据，你应该会看到以下输出：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Like volumes, you can specify multiple instances of the `-p` argument, which
    enables you to set up the binding for multiple ports.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像卷一样，你可以指定多个`-p`参数实例，这使你能够为多个端口设置绑定。
- en: Removing a container starting with an explicit name
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除以显式名称开始的容器
- en: 'Containers that start with a name parameter are not automatically removed even
    if you specify the `--rm` argument. To remove a container started in this way,
    we must manually use the `docker rm` command. If we append the `-v` option to
    the command, we can also remove the volumes that are associated with it. We should
    really do this now, or when we try to recreate the container later in the chapter,
    you might be left a little puzzled:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以名称参数开始的容器即使指定了`--rm`参数也不会自动删除。要删除以这种方式启动的容器，我们必须手动使用`docker rm`命令。如果我们向命令中添加`-v`选项，我们还可以删除与其关联的卷。我们真的应该现在就做这件事，或者当我们试图在本章的后面重新创建容器时，你可能会感到有些困惑：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Docker networking
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker网络
- en: I never intended this chapter to be a full reproduction of the official Docker
    documentation; I am just trying to explain some of the key concepts that will
    help you as you progress through the rest of this book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未打算让这一章成为官方Docker文档的完整复制；我只是试图解释一些关键概念，这些概念将帮助您在阅读本书的其余部分时进步。
- en: 'Docker networking is an interesting topic, and by default, Docker supports
    the following network modes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网络是一个有趣的话题，默认情况下，Docker支持以下网络模式：
- en: bridge
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bridge
- en: host
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: host
- en: none
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: none
- en: overlay
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: overlay
- en: Bridge networking
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接网络
- en: The bridge network is the default network that your containers will connect
    to when you launch them; this is how we were able to join our containers together
    in the last example. To facilitate this, Docker uses some of the core Linux capabilities
    such as networking namespaces and virtual Ethernet interfaces (or `veth` interfaces).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接网络是当你启动容器时它们将连接到的默认网络；这是我们能够在上一个示例中将容器连接在一起的原因。为了实现这一点，Docker使用了一些核心Linux功能，如网络命名空间和虚拟以太网接口（或`veth`接口）。
- en: When the Docker engine starts, it creates the `docker0` virtual interface on
    the host machine. The `docker0` interface is a virtual Ethernet bridge that automatically
    forwards packets between any other network interfaces that are attached to it.
    When a container starts it creates a `veth` pair, it gives one to the container,
    which becomes its `eth0,` and the other connects to the `docker0` bridge.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker引擎启动时，它会在主机机器上创建`docker0`虚拟接口。`docker0`接口是一个虚拟以太网桥，它自动将数据包转发到连接到它的任何其他网络接口。当容器启动时，它会创建一个`veth`对，它将一个分配给容器，这成为它的`eth0`，另一个连接到`docker0`桥。
- en: Host networking
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机网络
- en: The host network is essentially the same network that the Docker engine is running
    on. When you connect a container to the host network all of the ports that are
    exposed by the container are automatically mapped to the hosts, it also shares
    the IP address of the host. While this may seem like a nice convenience, Docker
    was always designed to be capable of running multiple instances of the same container
    on the engine, and since you can only bind a socket to one port in Linux using
    the `host network` limits this feature.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 主网络实际上是与Docker引擎运行在同一个网络。当你将容器连接到主网络时，容器暴露的所有端口都会自动映射到主机上，它还共享主机的IP地址。虽然这看起来像是一种方便，但Docker始终被设计为能够在引擎上运行同一容器的多个实例，并且由于在Linux中使用`host
    network`只能将套接字绑定到一个端口，这限制了这一功能。
- en: The host network can also pose a security risk to your container as it is no
    longer protected by the principle of no trust and you no longer have the ability
    to explicitly control if a port is exposed or not. That being said, due to the
    efficiencies of host networking it may in some instances be appropriate to connect
    a container to the host network if you anticipate that it is going to heavily
    use the network. An API gateway might be one such example, this container would
    still be possible to route requests to other API containers that are sitting on
    the bridge network.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主网络也可能对您的容器构成安全风险，因为它不再受“不信任”原则的保护，您也不再能够明确控制端口是否暴露。话虽如此，由于主机网络的效率，在某些情况下，如果您预计容器将大量使用网络，将容器连接到主机网络可能是合适的。API网关可能就是这样一个例子，这个容器仍然可以将请求路由到位于桥接网络上的其他API容器。
- en: No network
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无网络
- en: Removing your container from any network might in some instances be something
    you wish to do. Consider the situation where you have an application that only
    processes data stored in a file. Utilizing the principle of no trust, we may determine
    that the securest thing to do is to not connect it to any container and to only
    allow it to write to a volume that is mounted on the host. Attaching your container
    to the `none` network provides exactly this capability, and while the use case
    might be somewhat limited it is there, and it's nice to know about it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望从任何网络中移除您的容器。考虑这种情况：您有一个只处理存储在文件中的数据的应用程序。利用“不信任”原则，我们可能确定最安全的事情是不将其连接到任何容器，并且只允许它写入挂载在主机上的卷。将您的容器连接到`none`网络正好提供了这种能力，尽管用例可能有些有限，但它确实存在，了解这一点是很好的。
- en: Overlay network
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖网络
- en: The Docker overlay network is a unique Docker network that is used to connect
    containers running on separate hosts to one another. With the bridge network as
    we have already learned, network communication is localized to the Docker host
    and this is generally fine when you are developing software. When you run your
    code in production however, all this changes, as you will typically be running
    multiple hosts, each running multiple containers as part of your high availability
    setup. The containers still need to talk to one another, and while we could route
    all traffic through an **ESB** (**enterprise service bus**), this is a little
    bit of an anti-pattern in the microservice world. The recommended approach as
    we will see in a later chapter, is for the service to be responsible for its own
    discovery and load balancing client calls. The Docker overlay network solves this
    problem, it is in effect a network tunnel between machines which passes the traffic
    unmodified over the physical network. The problem with the overlay is that you
    can no longer rely on Docker to update the `etc/hosts` file for you, and you must
    depend on a dynamic service registry.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的覆盖网络是一种独特的Docker网络，用于连接运行在不同主机上的容器。正如我们之前所学的，使用桥接网络时，网络通信被限制在Docker主机上，这在开发软件时通常是可行的。然而，当你将代码部署到生产环境中时，所有这些都会改变，因为你通常会在多个主机上运行多个容器，作为你的高可用性配置的一部分。容器仍然需要相互通信，虽然我们可以通过**ESB**（企业服务总线）路由所有流量，但在微服务世界中这有点反模式。正如我们将在后面的章节中看到的，推荐的方法是服务负责自己的发现和负载均衡客户端调用。Docker覆盖网络解决了这个问题，实际上它是在机器之间创建一个网络隧道，将流量无修改地通过物理网络传递。覆盖网络的问题是你不能再依赖Docker为你更新`etc/hosts`文件，你必须依赖于动态服务注册。
- en: Custom network drivers
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义网络驱动程序
- en: Docker also supports plugins for networking, based around its open source `libnetwork`
    project, you can write custom networking plugins that can replace the networking
    subsystem of the Docker engine. They also give the capability for you to connect
    non-Docker applications to your container network such as a physical database
    server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还支持基于其开源`libnetwork`项目的网络插件，你可以编写自定义网络插件来替换Docker引擎的网络子系统。它们还提供了将非Docker应用程序连接到容器网络的能力，例如物理数据库服务器。
- en: Weaveworks
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Weaveworks
- en: Weaveworks is one of the most popular plugins, it gives you the capability to
    securely link your Docker hosts and also provides a whole host of additional tools
    such as service discovery with weavedns and visualization with weavescope, so
    you can see how your network is connected together.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Weaveworks是最受欢迎的插件之一，它使你能够安全地链接你的Docker主机，并提供一系列额外的工具，如weavedns的服务发现和weavescope的可视化，这样你可以看到你的网络是如何连接在一起的。
- en: '[https://www.weave.works](https://www.weave.works)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.weave.works](https://www.weave.works)'
- en: Project Calico
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Calico
- en: Project Calico attempts to solve the speed and efficiency problems that using
    virtual LANs, bridging, and tunneling can cause. It achieves this by connecting
    your containers to a vRouter, which then routes traffic directly over the L3 network.
    This can give huge advantages when you are sending data between multiple data
    centers as there is no reliance on NAT and the smaller packet sizes reduce CPU
    utilization.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Project Calico试图解决使用虚拟局域网、桥接和隧道可能引起的速度和效率问题。它通过将你的容器连接到vRouter来实现这一点，然后直接在L3网络上路由流量。当你需要在多个数据中心之间发送数据时，这可以带来巨大的优势，因为没有依赖NAT，较小的数据包大小减少了CPU利用率。
- en: '[https://www.projectcalico.org](https://www.projectcalico.org)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.projectcalico.org](https://www.projectcalico.org)'
- en: Creating custom bridge networks
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义桥接网络
- en: Implementing a custom overlay network is beyond the scope of this book, however,
    understanding how you can create custom bridge networks is something that we should
    look at as Docker-Compose, which we are going to introduce later in this chapter,
    utilizes these concepts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义覆盖网络超出了本书的范围，然而，了解如何创建自定义桥接网络是我们应该关注的，因为Docker-Compose，我们将在本章后面介绍，利用了这些概念。
- en: 'Like many of the Docker tools, creating a bridge network is quite straightforward.
    To see the currently running networks on your Docker engine, we can execute the
    following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多Docker工具一样，创建桥接网络相当简单。要查看Docker引擎上当前正在运行的网络，我们可以执行以下命令：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be something like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will find that there are three networks created by default, which is three
    of the ones we discussed earlier. Because these are default networks, we are unable
    to remove these, Docker requires these networks to function correctly and allowing
    you to remove them would be a bad thing indeed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现默认创建了三个网络，这是我们之前讨论的三个之一。因为这些是默认网络，我们无法删除它们，Docker需要这些网络才能正确运行，允许你删除它们确实是不好的。
- en: Creating a bridge network
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个桥接网络
- en: 'To create a bridge network, we can use the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个桥接网络，我们可以使用以下命令：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run this now in your terminal and list the networks again to see the results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的终端中运行这个命令，再次列出网络以查看结果。
- en: You will see that there is now a fourth network in your list that uses the bridge
    driver and that has the name you specified as one of the arguments. By default,
    when you create a network, it uses the `bridge` as a default driver, of course,
    it is possible to create a network to a custom driver, and this can be easily
    facilitated by specifying the additional argument, `-d drivername`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到现在在你的列表中有一个使用桥接驱动程序并且名称是你指定的一个参数的网络。默认情况下，当你创建一个网络时，它使用`bridge`作为默认驱动程序，当然，你可以创建一个使用自定义驱动程序的网络，这可以通过指定额外的参数`-d
    drivername`来轻松实现。
- en: Connecting containers to a custom network
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器连接到自定义网络
- en: 'To connect a container to a custom network, let''s again use the example application
    that we created in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml), *Introduction
    to Microservices*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要将容器连接到自定义网络，让我们再次使用我们在[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)中创建的示例应用程序：*微服务简介*：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Did you get the error message that the name is already in use because you forgot
    to remove the container in the earlier section? If so, it might be time to head
    back a few pages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否收到了错误信息，说名称已被使用，因为你忘记在早期部分移除容器？如果是这样，可能需要回翻几页。
- en: 'Assuming all went well, you should see the server starting message, now let''s
    try to curl the container using the same command we executed earlier:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，你应该看到服务器启动的消息，现在让我们尝试使用我们之前执行的相同命令来curl容器：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should have received the following error message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经收到了以下错误信息：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This was expected, have a go to see if you can update the `docker run` command
    to make it work with our API container.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，尝试更新`docker run`命令，使其与我们的API容器一起工作。
- en: Got it?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？
- en: 'If not, here is the modified command with the added network argument:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，这里有一个添加了网络参数的修改后的命令：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command should have worked just fine the second time, and you should see
    the expected output. Now remove the server container, and we will take a look
    at how you can write your own Docker files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该第二次运行得很好，你应该看到预期的输出。现在移除服务器容器，我们将看看如何编写你自己的Docker文件。
- en: Writing Dockerfiles
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Dockerfile
- en: Dockerfiles are the recipes for our images; the define the base image, software
    to be installed and give us the capability to set the various structure that our
    application needs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是我们的镜像配方；它们定义了基本镜像、要安装的软件，并赋予我们设置应用程序所需的各种结构的权限。
- en: In this section, we are going to look at how we can create a Docker file for
    our example API. Again, this is not going to be a comprehensive overview of how
    Dockerfiles work as there are many books and online resources that exist for that
    explicit purpose. What we will do is to look at the salient points that will give
    us the basics.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何为我们的示例API创建Dockerfile。再次强调，这不会是Dockerfile如何工作的全面概述，因为有许多书籍和在线资源专门为此目的存在。我们将查看关键点，这将给我们基础知识。
- en: The first thing we are going to do is build our application code as when we
    package this into a Docker file we will be executing a binary, not using the `go
    run` command. The image we are going to create will have only the software installed
    that we need to run our application. Limiting the software installed is a Docker
    best practice when creating images as it reduces the attack surface by only including
    what is necessary.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是构建我们的应用程序代码，因为当我们将其打包到Dockerfile中时，我们将执行一个二进制文件，而不是使用`go run`命令。我们将创建的镜像将只包含运行我们的应用程序所需的软件。在创建镜像时限制安装的软件是Docker的最佳实践，因为它通过仅包含必要的软件来减少攻击面。
- en: Building application code for Docker
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Docker构建应用程序代码
- en: 'We are going to execute a slightly different command for creating our files
    from the usual `go build`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行一个与通常的`go build`略有不同的命令来创建我们的文件：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding command, we are passing the argument `-ldflags '-s'`, this
    argument passes the `-s` argument to the linker when we build the application
    and tells it to statically link all dependencies. This is very useful when we
    use the popular Scratch container as a base; Scratch is the lightest base you
    can get it has no application frameworks or applications this is opposed to Ubuntu,
    which takes about 150MB. The difference between Scratch and Ubuntu is that Scratch
    does not have access to the standard C library `GLibC`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们传递了参数 `-ldflags '-s'`，这个参数在构建应用程序时将 `-s` 参数传递给链接器，并告诉它静态链接所有依赖项。当我们使用流行的
    Scratch 容器作为基础时，这非常有用；Scratch 是最轻的基础之一，它没有任何应用程序框架或应用程序，这与占用约 150MB 的 Ubuntu 相反。Scratch
    和 Ubuntu 之间的区别在于 Scratch 没有访问标准 C 库 `GLibC` 的权限。
- en: If we do not build a static binary, then it will not execute if we try to run
    it in a Scratch container. The reason for this is that while you may think that
    your Go application is a static binary it still has a dependency on `GLibC`, both
    the `net` and the `os/user` packages link to `GLibC` so if we are to run our application
    with a Scratch base image we need to statically link this. The benefit, however,
    is an incredibly small image, we end up with an image which is roughly 4MB in
    size, exactly the size of our compile Go application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不构建静态二进制文件，那么如果我们尝试在 Scratch 容器中运行它，它将不会执行。这是因为虽然您可能认为您的 Go 应用程序是一个静态二进制文件，但它仍然依赖于
    `GLibC`，`net` 和 `os/user` 包都链接到 `GLibC`，因此如果我们要在 Scratch 基础镜像上运行我们的应用程序，我们需要静态链接这个库。然而，好处是图像非常小，我们最终得到的图像大小大约为
    4MB，正好是我们编译的 Go 应用程序的大小。
- en: Because the Docker engine is running on Linux, we also need to build our Go
    binary for the Linux architecture. Even if you are using Docker for Mac or Docker
    for Windows, what is happening under the hood is that the Docker engine is running
    a lightweight virtual machine on either `HyperV` or the Mac's `xhyve` virtual
    machine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Docker 引擎是在 Linux 上运行的，所以我们还需要为 Linux 架构构建我们的 Go 可执行文件。即使您使用 Docker for Mac
    或 Docker for Windows，底层发生的事情是 Docker 引擎在 `HyperV` 或 Mac 的 `xhyve` 虚拟机上运行一个轻量级的虚拟机。
- en: If you are not using Linux to run your go build command and since Go has excellent
    capability for cross-platform compilation, you don't need to do much. All you
    do need to do is prefix the architecture variables `GOOS=linux GOARCH=386` to
    your go build command as we did in the earlier example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是使用 Linux 运行 go build 命令，并且由于 Go 具有出色的跨平台编译能力，您不需要做太多。您只需要像我们在前面的示例中做的那样，在
    go build 命令前加上架构变量 `GOOS=linux GOARCH=386`。
- en: 'Now that we have created a binary for our application, let''s take a look at
    the Docker file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的应用程序创建了一个二进制文件，让我们来看看 Dockerfile：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: FROM
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FROM
- en: 'The `FROM` instruction set the base image for subsequent instructions. You
    can use any image that is either stored in a remote registry or locally on your
    Docker Engine. When you execute `docker build`, if you do not already have this
    image, then Docker will pull it from the registry as the first step of the build
    process. The format for the `FROM` command is the same as you would use when issuing
    a `docker run` command it is either:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 指令为后续指令设置基础镜像。您可以使用存储在远程注册表或本地 Docker 引擎上的任何镜像。当您执行 `docker build` 时，如果您还没有这个镜像，Docker
    将在构建过程的第一个步骤中从注册表中拉取它。`FROM` 命令的格式与您在发出 `docker run` 命令时使用的格式相同，它可以是：'
- en: '`FROM image` // assuming latest'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM image` // 假设为最新版本'
- en: '`FROM image:tag` // where you can specify a tag to use'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM image:tag` // 其中您可以指定要使用的标签'
- en: In **line 1**, we are using the image name scratch, this is a particular kind
    of image, which is basically a blank canvas. We could use Ubuntu or Debian or
    Alpine or pretty much anything really, but since all we need to run our Go application
    is the application itself then we can use scratch to produce the smallest possible
    image.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **第 1 行**，我们使用的是 image 名称 scratch，这是一种特殊的镜像，基本上是一个空白画布。我们可以使用 Ubuntu、Debian、Alpine
    或几乎所有其他东西，但由于我们只需要运行我们的 Go 应用程序本身，因此我们可以使用 scratch 来生成可能最小的镜像。
- en: MAINTAINER
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护者
- en: The `MAINTAINER` instruction allows you to set the author of the generated image.
    This is an optional instruction; however, it can be good practice to include this
    even if you are not planning on publishing your image to the public registry.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAINTAINER` 指令允许您设置生成的镜像的作者。这是一个可选指令；然而，即使您不打算将您的镜像发布到公共注册表，包含这个指令也是一个好的实践。'
- en: EXPOSE
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EXPOSE
- en: The `EXPOSE` instruction informs Docker that the container listens on the specified
    networks ports at runtime. Expose does not make the ports accessible to the host;
    this function still needs to be performed with the `-p` mapping.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 指令通知 Docker 容器在运行时监听指定的网络端口。`Expose` 不会使端口对主机可访问；此功能仍需要使用 `-p` 映射来执行。'
- en: COPY
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COPY
- en: 'The `COPY` instruction copies files from the source in the first part of this
    instruction to the destination specified in the second part:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令将文件从指令第一部分的源复制到第二部分指定的目标：'
- en: '`COPY <src> <dest>`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY <src> <dest>`'
- en: '`COPY ["<src">, "<dest>"]` // useful when paths contain whitespace'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY ["<src>", "<dest>"]` // 当路径包含空格时很有用'
- en: The `<src>` in the `COPY` instruction may contain wildcards with the matching
    done using Go's `filepath.Match` rules.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令中的 `<src>` 可以包含通配符，匹配规则使用 Go 的 `filepath.Match` 规则。'
- en: 'Note:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: '`<src>` must be part of the context for the build, you cannot specify relative
    folders such as `../;`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<src>` 必须是构建上下文的一部分，您不能指定相对文件夹，例如 `../;`'
- en: A root `/` specified in the `<src>` will be the root of the context
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `<src>` 中指定的根 `/` 将是上下文的根
- en: A root `/` specified in the `<dest>` will map to the containers root file system
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `<dest>` 中指定的根 `/` 将映射到容器的根文件系统
- en: Specifying a `COPY` instruction without a destination will copy the file or
    folder into the `WORKDIR` with the same name as the original
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定没有目标的 `COPY` 指令将文件或文件夹复制到与原始文件同名的 `WORKDIR`
- en: ENTRYPOINT
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENTRYPOINT
- en: An `ENTRYPOINT` allows you to configure the executable that you would like to
    run when your container starts. Using `ENTRYPOINT` makes it possible to specify
    arguments as part of the `docker run` command which is appended to the `ENTRYPOINT`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 允许您配置在容器启动时您希望运行的可执行文件。使用 `ENTRYPOINT` 可以在 `docker run` 命令中指定参数，这些参数将附加到
    `ENTRYPOINT`。'
- en: '`ENTRYPOINT` has two forms:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 有两种形式：'
- en: '`ENTRYPOINT ["executable", "param1", "param2"]` // preferred form'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT ["executable", "param1", "param2"]` // 优先形式'
- en: '`ENTRYPOINT command param1 param2` //shell form'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT command param1 param2` // shell 形式'
- en: 'For example, in our Docker file, we are specifying the `ENTRYPOINT ./server`.
    This is our Go binary that we would like to run. When we start our container with
    the following `docker run helloworld` command, we do not need to explicitly tell
    the container to execute the binary and launch the server. We can, however, pass
    additional arguments to the application via the `docker run` command arguments;
    these would then be appended to the `ENTRYPOINT` before the application is run.
    For example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的 Docker 文件中，我们指定了 `ENTRYPOINT ./server`。这是我们想要运行的 Go 可执行文件。当我们使用以下 `docker
    run helloworld` 命令启动容器时，我们不需要明确告诉容器执行二进制文件并启动服务器。然而，我们可以通过 `docker run` 命令的参数传递额外的参数给应用程序；这些参数将在应用程序运行之前附加到
    `ENTRYPOINT`。例如：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding command would append the arguments to the executed statement
    defined in the entry point, which would be the equivalent of executing the following
    shell command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令将参数附加到入口点中定义的执行语句，这相当于执行以下 shell 命令：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: CMD
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMD
- en: 'The CMD instruction has three forms:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD` 指令有三种形式：'
- en: '`CMD ["executable", "param1", "param2"]` // exec form'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["executable", "param1", "param2"]` // exec 形式'
- en: '`CMD ["param1", "param2"]` // append default parameters to `ENTRYPOINT`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["param1", "param2"]` // 将默认参数附加到 `ENTRYPOINT`'
- en: '`CMD command param1 param2` // shell form'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD command param1 param2` // shell 形式'
- en: When `CMD` is used to provide default arguments for the `ENTRYPOINT` instruction
    then both the `CMD` and `ENTRYPOINT` instructions should be specified using the
    `JSON` array format.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `CMD` 为 `ENTRYPOINT` 指令提供默认参数时，应使用 `JSON` 数组格式指定 `CMD` 和 `ENTRYPOINT` 指令。
- en: If we specify a default value for `CMD`, we can still override it by passing
    the command arguments to the `docker run` command.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 `CMD` 指定默认值，我们仍然可以通过传递命令参数到 `docker run` 命令来覆盖它。
- en: Only one `CMD` instruction is permitted in a Docker file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中只允许有一个 `CMD` 指令。
- en: Good practice for creating Dockerfiles
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Dockerfile 的良好实践
- en: Taking all of this into account, we need to remember how the union file system
    works in Docker and how we can leverage it to create small and compact images.
    Every time we issue a command in the Dockerfile, Docker will create a new layer.
    When we mutate this command, the layer must be completely recreated and potentially
    all the following layers too, which can dramatically slow down your build. It
    is therefore recommended a good practice that you should attempt to group your
    commands as tightly as possible to reduce the possibility of this occurring.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们需要记住Docker中的联合文件系统是如何工作的，以及我们如何利用它来创建小型和紧凑的镜像。每次我们在Dockerfile中发出命令时，Docker都会创建一个新的层。当我们修改这个命令时，这个层必须完全重新创建，甚至可能所有后续的层也需要重新创建，这可能会显著减慢你的构建速度。因此，建议你尽可能紧密地分组你的命令，以减少这种情况发生的可能性。
- en: Quite often, you will see Dockerfiles which instead of having a separate `RUN`
    command for every command we would like to execute, we chain these using standard
    bash formatting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，你会看到Dockerfile，而不是为每个我们想要执行的命令单独有一个`RUN`命令，我们使用标准的bash格式来链式执行这些命令。
- en: For example, consider the following, which would install software from a package
    manager.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容，它将从包管理器安装软件。
- en: '**Bad Practice:**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**不良实践：**'
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Good Practice:**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践：**'
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The second example would only create one layer, which in turn would create a
    much smaller and more compact image, it is also good practice to organize your
    COPY statements placing the statement which changes the least further up in the
    Dockerfile, this way you avoid invalidation of subsequent layers even if there
    are no changes to these layers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例只会创建一层，这又会进一步创建一个更小、更紧凑的图像，将更改最少的语句放在Dockerfile的上方也是一种良好的实践，这样即使这些层没有变化，也可以避免后续层的无效化。
- en: Building images from Dockerfiles
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Dockerfile构建镜像
- en: 'To build an image from our Dockerfile, we can execute a straightforward command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的Dockerfile构建一个镜像，我们可以执行一个简单的命令：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Breaking this down the `-t` argument is the tag we wish to give the container,
    this takes the form name:tag, If we omit the `tag` portion of the argument as
    we have in our example command, then the tag `latest` will be automatically assigned.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 分解这个`-t`参数是我们想要赋予容器的标签，它采用name:tag的形式，如果我们像示例命令中那样省略了`tag`部分，那么将自动分配标签`latest`。
- en: If you run `docker images`, you will see that our `testserver` image has been
    given this tag.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`docker images`，你会看到我们的`testserver`镜像已经被赋予了这个标签。
- en: The final argument is the context we would like to send to the Docker Engine.
    When you run a Docker build, the context is automatically forwarded to the server.
    This may seem strange, but you have to remember that it is not uncommon that the
    Docker Engine will not be running on your local machine, and therefore it will
    not have access to your local filesystem. For this reason, we should be careful
    about where we are setting our context as it can mean that potentially a large
    amount of data is being sent to the engine, which will slow things down. Context
    then becomes the root for your `COPY` commands.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是我们想要发送给Docker Engine的上下文。当你运行Docker构建时，上下文会自动转发到服务器。这听起来可能有些奇怪，但你要记住，Docker
    Engine可能不会在你的本地机器上运行，因此它将无法访问你的本地文件系统。因此，我们应该小心设置上下文的位置，因为这可能意味着大量数据被发送到引擎，这会减慢速度。上下文然后成为你的`COPY`命令的根。
- en: 'Now that we have our running container, let''s test it out. Why not start a
    container from our newly built image and check the API by curling the endpoint:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了正在运行的容器，让我们来测试它。为什么不从一个新构建的镜像中启动一个容器，并通过curl端点来检查API呢：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Docker build context
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker构建上下文
- en: When we run our Docker build command, we set the context path as the final argument.
    What actually happens when the command executes is that the context is transferred
    to the server. This can cause problems if you have a large source folder, so it
    is good practice to only send the files you need to be packaged inside the container
    or the files you need when building the container. There are two ways we can mitigate
    this problem. The first is to ensure that our context only has the files on it
    we require. Since this is not always possible we have a secondary option of using
    a `.dockerignore` file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 Docker 构建命令时，我们将上下文路径设置为最后一个参数。当命令执行时实际上发生的情况是上下文被传输到服务器。如果你有一个大的源文件夹，这可能会导致问题，因此只发送需要打包到容器内或构建容器时需要的文件是一种良好的实践。我们可以通过两种方式来减轻这个问题。第一种是确保我们的上下文只包含我们需要的文件。由于这并不总是可能的，所以我们还有一个次要选项，即使用
    `.dockerignore` 文件。
- en: Docker Ignore files
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 忽略文件
- en: 'The `.dockerignore` file is similar to a git ignore file before the CLI sends
    the context to the Engine, it excludes files and directories that match patterns
    in the `.dockerignore` file. It uses the patterns which are defined in Go''s `filepath.Match`
    rules you can find more information about them in the following Go documentation:
    [https://godoc.org/path/filepath#Match](https://godoc.org/path/filepath#Match)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CLI 将上下文发送到引擎之前，`.dockerignore` 文件类似于 git 忽略文件，它排除了与 `.dockerignore` 文件中匹配模式的文件和目录。它使用
    Go 的 `filepath.Match` 规则定义的模式，你可以在以下 Go 文档中找到更多关于它们的信息：[https://godoc.org/path/filepath#Match](https://godoc.org/path/filepath#Match)
- en: '| **Rule** | **Behavior** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **规则** | **行为** |'
- en: '| `# comment` | Ignored. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `# comment` | 被忽略。 |'
- en: '| `*/temp*` | Exclude files and directories whose names start with temp in
    any immediate subdirectory of the root. For example, the plain file `/somedir/temporary.txt`
    is excluded, as is the directory `/somedir/temp`. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `*/temp*` | 排除根目录任何直接子目录中以 temp 开头的文件和目录。例如，普通文件 `/somedir/temporary.txt`
    被排除，同样 `/somedir/temp` 目录也被排除。 |'
- en: '| `*/*/temp*` | Exclude files and directories starting with temp from any subdirectory
    that is two levels below the root. For example, `/somedir/subdir/temporary.txt`
    is excluded. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `*/*/temp*` | 排除根目录下两级以下子目录中以 temp 开头的文件和目录。例如，`/somedir/subdir/temporary.txt`
    被排除。 |'
- en: '| `temp?` | Exclude files and directories in the root directory whose names
    are a one-character extension of temp. For example, `/tempa` and `/tempb` are
    excluded. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `temp?` | 排除根目录中名称为 temp 的一字符扩展名的文件和目录。例如，`/tempa` 和 `/tempb` 被排除。 |'
- en: '[https://docs.docker.com/engine/reference/builder/#/dockerignore-file](https://docs.docker.com/engine/reference/builder/#/dockerignore-file)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/reference/builder/#/dockerignore-file](https://docs.docker.com/engine/reference/builder/#/dockerignore-file)'
- en: "[\uFEFF](https://docs.docker.com/engine/reference/builder/#/dockerignore-file)"
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: "[\uFEFF](https://docs.docker.com/engine/reference/builder/#/dockerignore-file)"
- en: Running Daemons in containers
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行守护进程
- en: One of the things you might be used to when deploying an application to a VM
    or physical server is to use a Daemon runner such as `initd` or `systemd` to ensure
    that the application is started in the background and continues to run even if
    it crashes. This is an anti-pattern when you are using Docker containers, for
    Docker to successfully stop the application it will attempt to kill the process
    running with PID 1\. Daemons will generally start with PID 1 and start your application
    with another process ID, which will mean they are not killed when you stop the
    Docker container. This can cause containers to hang when the `docker stop` command
    is executed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在虚拟机或物理服务器上部署应用程序时，你可能习惯于使用 `initd` 或 `systemd` 这样的守护进程运行器来确保应用程序在后台启动并继续运行，即使它崩溃了。当你使用
    Docker 容器时，这是一个反模式，因为 Docker 要成功停止应用程序，它将尝试杀死 PID 为 1 的进程。守护进程通常以 PID 1 启动，并使用另一个进程
    ID 启动你的应用程序，这意味着当停止 Docker 容器时，它们不会被杀死。这可能导致在执行 `docker stop` 命令时容器挂起。
- en: In the instance that you need to ensure that your application keeps running
    even after a crash then you delegate this responsibility to the orchestrator who
    is starting your Docker container. We will learn more about this when we look
    at orchestration in a later chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要确保应用程序即使在崩溃后也能继续运行，那么你可以将这个责任委托给启动你的 Docker 容器的编排器。我们将在稍后的章节中学习更多关于编排的内容。
- en: Docker Compose
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: That was all super easy-ish, let's now take a look at a compelling feature of
    Docker that allows you to start multiple containers at once with your stack definition
    stored in a handy YAML file.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很简单，现在让我们看看Docker的一个引人注目的特性，它允许您通过存储在方便的YAML文件中的堆栈定义一次性启动多个容器。
- en: Installing Docker Compose on Linux
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装Docker Compose
- en: If you have either Docker for Mac or Docker for Windows installed then it already
    comes bundled with `docker-compose`, if however, you are using Linux, then you
    may need to install this yourself as it does not come as part of the default Docker
    package.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了Docker for Mac或Docker for Windows，那么`docker-compose`已经捆绑在其中了；然而，如果您正在使用Linux，那么您可能需要自己安装它，因为它不是默认Docker包的一部分。
- en: 'To install Docker Compose on Linux, execute the following command in your terminal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux上安装Docker Compose，请在您的终端中执行以下命令：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Before we look at how we can run our application with `docker-compose`, let''s
    take a look at the file we are going to run and some of the important facets of
    it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看看如何使用`docker-compose`运行我们的应用程序之前，让我们看看我们将要运行的文件以及它的一些重要方面：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Docker Compose files are written in YAML, inside this file you can define services
    that will make up your application. In our simple example, we are only describing
    two services. The first is our example code that we have just built and the second
    is a simple service that curls this API. As a production example, this is not
    particularly useful I admit, but it is only intended to show how to set up these
    files. As we progress through later chapters, we will heavily rely on compose
    files to create our databases and other data stores that make up our application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose文件是用YAML编写的，在这个文件中，您可以定义将构成您应用程序的服务。在我们的简单示例中，我们只描述了两个服务。第一个是我们刚刚构建的示例代码，第二个是一个简单的服务，它会向这个API发送curl请求。我承认，作为一个生产示例，这并不特别有用，但它只是用来展示如何设置这些文件。随着我们进入后面的章节，我们将大量依赖这些文件来创建我们的数据库和其他数据存储，这些数据存储构成了我们的应用程序。
- en: '**Line 1** defines the version of the Docker compose file we are using, version
    2 is the latest version and is a breaking change from version 1 which along with
    the `--link` directive is now deprecated and will be removed in a future release.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1行**定义了我们使用的Docker Compose文件的版本，版本2是最新版本，与版本1相比是一个重大变化，`--link`指令现在已弃用，将在未来的版本中删除。'
- en: In **line 2** we define the services. Services are the containers that you would
    like to start with your stack. Each service has to have a unique name to the compose
    file, but not necessarily to all the containers running on your Docker Engine.
    To avoid conflicts when starting a stack, we can pass `-p projectname` to the
    `docker-compose up` command; this will prefix the name of any of our containers
    with the specified project name.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第2行**中我们定义了服务。服务是您希望与堆栈一起启动的容器。每个服务都必须在compose文件中有一个唯一的名称，但不必与在您的Docker Engine上运行的容器名称相同。为了避免在启动堆栈时发生冲突，我们可以将`-p
    projectname`传递给`docker-compose up`命令；这将给我们的任何容器的名称前加上指定的项目名称。
- en: The minimum information you need to specify for a service is the image, which
    is the image you wish to start a container from. In the same way that `docker
    run` works, this can either be a local image on the Docker Engine or it can be
    a reference to an image in a remote registry. When you start a stack, compose
    will check to see if the image is available locally and if not it will automatically
    pull it from the registry.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为服务指定的最小信息是镜像，这是您希望从中启动容器的镜像。与`docker run`的工作方式相同，这可以是Docker Engine上的本地镜像，也可以是远程注册表中镜像的引用。当您启动堆栈时，compose将检查镜像是否本地可用，如果不可用，它将自动从注册表中拉取。
- en: '**Line 6** defines our second service; this is simply going to execute a command
    to curl a request to the API exposed by the first service.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6行**定义了我们的第二个服务；这只是一个简单地执行命令来向第一个服务暴露的API发送curl请求。'
- en: In this service definition block, we are both specifying the image and an entry
    point.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务定义块中，我们既指定了镜像又指定了入口点。
- en: Service startup
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务启动
- en: The previous command looks a little weird, but there is a gotcha with Docker
    compose, which quite a few people fall foul too, there is no real way for compose
    to know when an application is running. Even if we use the `depends-on` configuration,
    we are only informing compose that there are dependencies and that it should control
    the start order of the services.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令看起来有点奇怪，但 Docker Compose 有一个陷阱，很多人都会犯这个错误，那就是 compose 没有真正的方法知道应用程序何时正在运行。即使我们使用了
    `depends-on` 配置，我们只是在通知 compose 存在依赖关系，并且它应该控制服务的启动顺序。
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All compose will do is check that the container has been started. The general
    problem occurs with a misunderstanding that a container being started equals it
    is ready to receive requests. More often than not this is not the case, it can
    take time for your application to start and be ready to accept requests. If you
    have a dependency like we have specified in our entry point to curl the endpoint
    in another service, then we cannot assume that the dependent service is ready
    for requests before we execute our command. We will cover a pattern for dealing
    with this in [Chapter 6](74445ff8-eb01-4a2f-a910-0551e7d85a5f.xhtml), *Microservice
    Frameworks*, but for now we can be aware that:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 所做的只是检查容器是否已启动。一般问题发生在对容器启动等于它准备好接收请求的误解。通常情况下并非如此，应用程序启动并准备好接受请求可能需要一些时间。如果你有一个像我们在
    curl 入口点指定的那样依赖另一个服务的端点，那么我们不能假设在执行我们的命令之前，依赖的服务已经准备好接收请求。我们将在 [第 6 章](74445ff8-eb01-4a2f-a910-0551e7d85a5f.xhtml)
    “微服务框架”中介绍处理这种模式的方法，但现在我们可以意识到：
- en: '"Container started, and service ready is not the same thing."'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '"容器已启动，服务已准备好并不等同于它已经准备好接收请求。"'
- en: In our simple example, we know that it roughly takes a second or so for the
    service to start, so we will just sleep for three seconds to give it plenty of
    time to get ready before executing our command. This method is not good practice,
    and it is only to illustrate how we can use compose to link services. In reality,
    you would probably never start a single command like we are here in your compose
    file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，我们知道服务启动大概需要一秒钟左右的时间，所以我们只需等待三秒钟，给服务足够的时间准备，然后再执行我们的命令。这种方法并不是一个好的实践，它只是为了说明我们如何使用
    compose 来连接服务。实际上，你很可能不会在你的 compose 文件中启动单个命令，就像我们在这里做的那样。
- en: When you use a Docker network, Docker automatically adds a mapping to the containers
    `resolve.conf` pointing to the built in Docker DNS server, we can then contact
    other containers connected to the same network by referencing them by name. Looking
    at our curl command, this DNS capability is exactly what allows us to use the
    hostname testserver.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Docker 网络，Docker 会自动将映射添加到容器的 `resolve.conf` 文件中，指向内置的 Docker DNS 服务器，然后我们可以通过名称引用连接到同一网络的其他容器。查看我们的
    curl 命令，这个 DNS 功能正是允许我们使用主机名 testserver 的原因。
- en: 'OK, time to test it out, run the following command from your terminal:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候测试一下了，从您的终端运行以下命令：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All being well you should see the following message returned in the output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该在输出中看到以下消息：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Ctrl* + *C* will exit compose, however, since we did run this with the `docker
    run` command and passed the arguments `--rm` to remove the container, we need
    to ensure that we clean up after ourselves. To remove any stopped container that
    you have started with `docker-compose`, we can use the particular compose command
    `rm` and pass the `-v` argument to remove any associated volumes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *C* 将退出 compose，然而，由于我们使用 `docker run` 命令并传递了 `--rm` 参数来删除容器，我们需要确保自己清理。要删除使用
    `docker-compose` 启动的任何已停止容器，我们可以使用特定的 compose 命令 `rm` 并传递 `-v` 参数来删除任何相关卷：'
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Specifying the location of a compose file
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定 compose 文件的存储位置
- en: 'Whenever you run `docker-compose`, it looks for a file named `docker-compose.yml`
    in the current folder as a default file. To specify an alternate file, we can
    pass the `-f` argument to compose with a path to the compose file we would like
    to load:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行 `docker-compose` 时，它都会在当前文件夹中查找名为 `docker-compose.yml` 的文件作为默认文件。要指定一个不同的文件，我们可以向
    compose 传递 `-f` 参数，并指定我们想要加载的 compose 文件路径：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Specifying a project name
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定项目名称
- en: 'As we discussed earlier when we start `docker-compose`, it will create services
    with the given names in your Compose file appending the project name `default`
    to them. If we need to run multiple instances of this compose file, then `docker-compose`
    will not start another instance as it will check to see if any services are running
    with the given names first. To override this, we can specify the project name
    replacing the default name of `default`. To do this we just need to specify the
    `-p projectname` argument to our command as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在启动`docker-compose`时讨论的那样，它将创建在您的Compose文件中给定名称的服务，并在其后面附加项目名称`default`。如果我们需要运行多个此Compose文件实例，那么`docker-compose`不会启动另一个实例，因为它会先检查是否有任何服务以给定名称运行。为了覆盖这一点，我们可以指定项目名称，以替换默认的`default`名称。为此，我们只需在命令中指定`-p
    projectname`参数，如下所示：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will then create two containers:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个容器：
- en: '`testproject_testserver`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testproject_testserver`'
- en: '`testproject_curl`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testproject_curl`'
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In summary, we have learned how to work with Docker in this chapter, and while
    this is only a brief overview, I suggest you head over to the documentation and
    read more in depth on the concepts of Dockerfiles, Composefiles, the Docker Engine,
    and Docker Compose. Docker is an invaluable tool for development, testing, and
    production and as we progress through the following chapters, we will use these
    concepts extensively. In the next chapter, we are going to look at testing, which
    builds on all of the things you have learned so far.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中我们学习了如何使用Docker，虽然这只是一个简要概述，但我建议您查阅文档，更深入地了解Dockerfile、Composefile、Docker
    Engine和Docker Compose的概念。Docker是开发、测试和生产中不可或缺的工具，随着我们进入接下来的章节，我们将广泛使用这些概念。在下一章，我们将探讨测试，这将建立在您迄今为止所学的一切之上。
