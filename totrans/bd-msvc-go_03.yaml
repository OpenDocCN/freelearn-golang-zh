- en: Introducing Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Docker
- en: Before we go any further with this book, we need to look at a little thing called
    Docker, before we begin don't forget to clone the example code repository [https://github.com/building-microservices-with-go/chapter3.git](https://github.com/building-microservices-with-go/chapter3.git).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续本书的内容之前，我们需要先了解一下被称为 Docker 的这个小东西，在我们开始之前，别忘了克隆示例代码仓库 [https://github.com/building-microservices-with-go/chapter3.git](https://github.com/building-microservices-with-go/chapter3.git)。
- en: Introducing Containers with Docker
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 介绍容器
- en: Docker is a platform that has risen to prominence in the last three years; it
    was born out of the desire to simplify the process of building, shipping, and
    running applications. Docker is not the inventor of the container, Jacques Gélinas
    created the VServer project back in 2001, and since then the other main projects
    have been LXC from IBM and rkt from CoreOS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个在过去三年中崛起的平台；它诞生于简化构建、运输和运行应用程序过程的愿望。Docker 不是容器的发明者，Jacques Gélinas
    在 2001 年创建了 VServer 项目，从那时起，其他主要项目还包括 IBM 的 LXC 和 CoreOS 的 rkt。
- en: 'If you would like to read more about the history, then I recommend this excellent
    blog post by Redhat: [http://rhelblog.redhat.com/2015/08/28/the-history-of-containers](http://rhelblog.redhat.com/2015/08/28/the-history-of-containers),
    this section is going to concentrate on Docker which is by far the most popular
    current technology.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于历史的信息，我推荐阅读 Redhat 的这篇优秀的博客文章：[http://rhelblog.redhat.com/2015/08/28/the-history-of-containers](http://rhelblog.redhat.com/2015/08/28/the-history-of-containers)，本节将重点介绍
    Docker，这是目前最受欢迎的技术。
- en: 'The concept of a container is process isolation and application packaging.
    To quote Docker:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的概念是进程隔离和应用程序打包。引用 Docker 的话：
- en: 'A container image is a lightweight, stand-alone, executable package of a piece
    of software that includes everything needed to run it: code, runtime, system tools,
    system libraries, settings.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是一个轻量级、独立、可执行的软件包，它包含了运行该软件所需的一切：代码、运行时、系统工具、系统库、设置。
- en: '...'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Containers isolate software from its surroundings, for example, differences
    between development and staging environments and help reduce conflicts between
    teams running different software on the same infrastructure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将软件与其环境隔离开来，例如，开发环境和预发布环境之间的差异，并有助于减少在相同基础设施上运行不同软件的团队之间的冲突。
- en: Where they benefit application development is that we can take advantage of
    this when deploying these applications as it allows us to pack them closer together,
    saving on hardware resources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在应用开发中的好处是，在部署这些应用程序时，我们可以利用这一点，因为它允许我们将它们打包得更紧密，节省硬件资源。
- en: From a development and test lifecycle, containers give us the capability to
    run production code on our development machines with no complicated setup; it
    also allows us to create that `Clean Room` environment without having different
    instances of the same database installed to trial new software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发和测试生命周期来看，容器使我们能够在开发机器上运行生产代码，而无需复杂的设置；它还允许我们创建一个“洁净室”环境，而无需安装不同实例的同数据库来测试新软件。
- en: Containers have become the primary choice for packaging microservices, and as
    we progress through the examples in this book, you will learn how invaluable it
    is to your workflow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已成为打包微服务的首选方案，随着我们在本书中的示例进展，你将了解到这对你的工作流程是多么宝贵。
- en: Containers work by isolating processes and filesystems from each other. Unless
    explicitly specified, containers cannot access each other's file systems. They
    also cannot interact with one another via TCP or UDP sockets unless again specified.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过隔离进程和文件系统来工作。除非明确指定，否则容器无法访问彼此的文件系统。除非再次指定，否则它们也不能通过 TCP 或 UDP 套接字相互交互。
- en: Docker is made up of many parts; however, at its core is the Docker Engine,
    a lightweight application runtime with features for orchestration, scheduling
    networking, and security. Docker Engine can be installed anywhere on a physical
    or virtual host, and it supports both Windows and Linux. Containers allow developers
    to package large or small amounts of code and their dependencies together into
    an isolated package.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 由许多部分组成；然而，其核心是 Docker 引擎，这是一个轻量级的应用程序运行时，具有编排、调度、网络和安全功能。Docker 引擎可以安装在物理或虚拟主机上的任何位置，并且支持
    Windows 和 Linux。容器允许开发者将大量或少量代码及其依赖项打包到一个隔离的包中。
- en: We can also draw from a huge array of pre-created images, just about all software
    vendors from MySQL to IBM's WebSphere have an official image that is available
    for us to use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Docker also uses Go, in fact nearly all of the code that goes into the Docker
    Engine and other applications are written in Go.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Rather than write an essay on how Docker works, let's examine each of the features
    by example. By the end of this chapter, we will take one of the simple examples
    that we created in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml), *Introduction
    to Microservices*, and create a Docker image for it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Head over to [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)
    and install the correct version of Docker on your machine. You will find versions
    for Mac, Windows, and Linux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Running our first container
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To validate Docker has been installed correctly, let's run our first container,
    **hello-world** is actually an image, an image is an immutable snapshot of a container.
    Once we start these with the following command they become containers, think of
    it like types and instances, a type defines fields and methods making up behavior.
    An instance is a living instantiation of this type, you can assign other types
    to the fields and call the methods to perform actions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing you should see is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you execute a `docker run` the first thing the engine does is check to
    see if you have the image installed locally. If it doesn't then it connects to
    the default registry, in this case, [https://hub.docker.com/](https://hub.docker.com/)
    to retrieve it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has been downloaded, the daemon can create a container from
    the downloaded image, all the output is streamed to the output on your terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `--rm` flag tells the Docker engine to remove the container and delete
    any resources such as volumes it was using on exit. Unless we would like to re-start
    a container at some point it is good practice to use the `--rm` flag to keep our
    filesystem clean, otherwise, all of the temporary volumes which are created will
    sit around and consume space.Let''s try something a little more complicated, this
    time, we will start a container and create a shell inside of it to show how you
    can navigate to the internal file system. Execute the following command in your
    terminal:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alpine is a lightweight version of Linux and is perfect for running Go applications.
    The `-it` flags stand for **interactive terminal** it maps the standard in from
    your terminal to the input of the running container. The `sh` statement after
    the name of the image we want to run is the name of the command we would like
    to execute in the container when it starts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'If all went well, you should now be inside a shell of the container. If you
    check the current directory by executing the `ls` command, you will see the following,
    which hopefully is not the directory you were in before running the command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the root folder of the newly started container, containers are immutable,
    so any changes you make to the file system in a running container is disposed
    of when the container is stopped. While this may seem to be a problem, there are
    solutions for persisting data, which we will look at in a little bit, however,
    for now, the important concept to remember is that:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新启动的容器的根文件夹，容器是不可变的，所以你对运行中的容器文件系统所做的任何更改，在容器停止时都会被丢弃。虽然这看起来可能是一个问题，但有一些持久化数据的方法，我们稍后会看看，但现在，重要的是要记住：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent"'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: “容器是不可变的镜像实例，并且默认情况下数据卷是非持久的”
- en: You need to remember this when designing your services, to illustrate how this
    works take a look at this simple example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计你的服务时，你需要记住这一点，为了说明这是如何工作的，请看这个简单的例子。
- en: 'Open another terminal and execute the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端并执行以下命令：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `docker ps` command queries the engine and returns a list of the containers,
    by default this only shows the running containers, however, if we add the `-a`
    flag we can also see stopped containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps` 命令查询引擎并返回一个容器列表，默认情况下这仅显示正在运行的容器，然而，如果我们添加 `-a` 标志，我们也可以看到停止的容器。'
- en: 'The Alpine Linux container that we started earlier is currently running, so
    jump back to your previous terminal window and create a file in the root file
    system:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前启动的 Alpine Linux 容器目前正在运行，所以回到你之前的终端窗口，在根文件系统中创建一个文件：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we list the directory structure again, we can see that a file has been created
    in the root of the file system:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次列出目录结构，我们可以看到在文件系统的根目录下创建了一个文件：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now exit the container using the `exit` command and run `docker ps` again,
    you should see the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 `exit` 命令退出容器，并再次运行 `docker ps`，你应该看到以下输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we add the `-a` flag command to see stopped containers too, we should see
    the container we started earlier:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加 `-a` 标志命令来查看停止的容器，我们也应该看到我们之前启动的容器：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, start another container again using the `docker run` command and list the
    directory contents in the root folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次使用 `docker run` 命令启动另一个容器，并列出根文件夹中的目录内容。
- en: 'No `mytestfile.txt` right? The reason this does not exist is because of the
    principle we were discussing earlier, which I think is important to mention again
    as if this is the first time you have used Docker it will catch you out:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `mytestfile.txt` 吧？这个文件不存在的原因是因为我们之前讨论的原则，我认为再次提到这一点很重要，因为如果你是第一次使用 Docker，这可能会让你感到意外：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent."'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “容器是不可变的镜像实例，并且默认情况下数据卷是非持久的。”
- en: There is something worth noting, however, unless you explicitly remove a container
    it will persist in a stopped state on the Docker host.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一点值得注意，除非你明确删除容器，否则它将保持在 Docker 主机上的停止状态。
- en: Removing containers is important to remember for two reasons; the first is that
    if you do not remember this, you will fill up the disk on your host quickly as
    every time you create a container Docker will allocate space on the host for the
    container volumes. The second is that the container can be restarted.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 删除容器有两个重要原因；第一个是如果你不记得这一点，你很快就会填满主机的磁盘，因为每次你创建一个容器，Docker 都会在主机上为容器卷分配空间。第二个原因是容器可以被重启。
- en: 'Restarted that sounds cool, in fact, it is a handy feature, not something you
    should use in your production environment, for that you need to remember the golden
    rule and design your application accordingly:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重启听起来很酷，实际上，这是一个方便的功能，不是你应该在生产环境中使用的东西，为此你需要记住黄金法则并相应地设计你的应用程序：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent."'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “容器是不可变的镜像实例，并且默认情况下数据卷是非持久的。”
- en: However, the use of Docker extends far beyond simply running applications for
    your microservices. It is an awesome way to manage your development dependencies
    without cluttering up your development machine. We will look at that a little
    later on, but for now, we are interested in how we can restart a stopped container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker的使用远远超出了仅仅为你的微服务运行应用程序。这是一个管理你的开发依赖项而不会让你的开发机器变得杂乱无章的绝佳方式。我们稍后会看看这一点，但现在，我们感兴趣的是我们如何重启一个停止的容器。
- en: 'If we execute the `docker ps -a` command, we will see that we now have two
    stopped containers. The oldest one is the first container we started to which
    we added our `mytestfile.txt`. This is the one we want to restart, so grab the
    ID of the container and execute the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`docker ps -a`命令，我们会看到现在有两个停止的容器。最老的一个是我们第一次启动并添加了`mytestfile.txt`的容器。这是我们想要重新启动的容器，所以获取容器的ID并执行以下命令：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, you should be in a shell at the root of the container if you check the
    directory contents what do you think you will find?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你检查容器的目录内容，你应该在容器的根目录下的shell中，你认为你会找到什么？
- en: That's right, `mytestfile.txt`; this is because when you restarted the container,
    the engine remounted the volumes that were attached the first time you ran the
    command. These are the same volumes you mutated to add the file as mentioned earlier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，`mytestfile.txt`；这是因为当你重新启动容器时，引擎重新挂载了你在第一次运行命令时附加的卷。这些就是之前提到的你修改以添加文件的相同卷。
- en: 'So we can restart our container; however, I just want to repeat the golden
    rule one last time:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们可以重新启动我们的容器；然而，我只想最后一次重复黄金法则：
- en: '"Containers are immutable instances of images, and the data volumes are by
    default non-persistent."'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"容器是镜像的不变实例，数据卷默认是非持久的。"'
- en: When running in a production environment, you cannot ensure that you can restart
    a container. There are a million reasons for this, one of the main ones that we
    will look at more in depth when we look at orchestration is that containers are
    generally run on a cluster of hosts. Since there is no guarantee which host the
    container will be restarted on or even that the host the container was previously
    running on actually exists. There are many projects that attempt to solve this,
    but the best approach is to avoid the complexity altogether. If you need to persist
    files, then store them in something that is designed for the job such as Amazon
    S3 or Google Cloud Storage. Design your applications around this principle and
    you will spend far less time panicking when the inevitable happens, and your super
    sensitive data container disappears.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行时，你不能确保可以重新启动一个容器。这里有成千上万的原因，其中一个主要的原因是我们将在查看编排时更深入地探讨，那就是容器通常运行在一组主机上。由于无法保证容器将在哪个主机上重新启动，甚至无法保证容器之前运行的主机实际上存在。有许多项目试图解决这个问题，但最好的方法是完全避免这种复杂性。如果你需要持久化文件，那么将它们存储在为这项工作设计的某些东西中，比如Amazon
    S3或Google Cloud Storage。围绕这个原则设计你的应用程序，这样当不可避免的事情发生时，你将花更少的时间惊慌，而且你的超级敏感数据容器不会消失。
- en: OK, before we look at Docker volumes in more depth let's clean up after ourselves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在我们更深入地了解Docker卷之前，让我们清理一下。
- en: Exit your container and get back to the shell on the Docker host. If we run
    `docker ps -a` ,we will see that there are two stopped containers. To remove these,
    we can use the `docker rm containerid` command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 退出你的容器并回到Docker主机上的shell。如果我们运行`docker ps -a`，我们会看到有两个停止的容器。为了删除这些容器，我们可以使用`docker
    rm containerid`命令。
- en: Run this now using the first `containerid` in your list, if this is successful,
    the container ID you asked to be removed would be echoed back to you, and the
    container will is deleted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用你列表中的第一个`containerid`运行此命令，如果成功，你请求删除的容器ID将被回显给你，并且容器将被删除。
- en: 'If you want to remove all the stopped containers you can use the following
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要删除所有停止的容器，可以使用以下命令：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `docker ps -a -q` the `-a` flag will list all the containers including the
    stopped ones, `-q` will return a list of the container IDs rather than the full
    details. We are passing this as a parameter list to `docker rm`, which will remove
    all the containers in the list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps -a -q`，`-a`标志将列出所有容器，包括停止的容器，`-q`将返回容器ID的列表而不是完整详情。我们将此作为参数列表传递给`docker
    rm`，它将删除列表中的所有容器。'
- en: To avoid having to remove a container we can use the `--rm` flag when starting
    a new container. This flag tells Docker to remove the container when it stops.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要删除容器，我们可以在启动新容器时使用`--rm`标志。此标志告诉Docker在容器停止时删除它。
- en: Docker volumes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker卷
- en: We have seen how Docker containers are immutable; however, there are some instances
    when you may wish to write some files to a disk or when you want to read data
    from a disk such as in a development setup. Docker has the concept of volumes,
    which can be mounted either from the host running the Docker machine or from another
    Docker container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Docker容器是不可变的；然而，在某些情况下，您可能希望将一些文件写入磁盘，或者当您想要从磁盘读取数据，例如在开发环境中。Docker有卷的概念，可以从运行Docker机器的主机或另一个Docker容器挂载。
- en: Union filesystem
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: To keep our images efficient and compact Docker uses the concept of a Union
    File System. The Union filesystem allows us to represent a logical file system
    by grouping different directories and or files together. It uses a **Copy on Write**
    technique, which copies the layer when we modify the file system, this way we
    only use about 1MB of space when creating a new image. When data is written to
    the file system Docker copies the layer and puts it on the top of the stack. When
    building images and extending existing images we are leveraging this technique,
    also when starting an image and creating a container the only difference is this
    writable layer, which means we do not need to copy all the layers every time and
    fill up our disk.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的镜像高效且紧凑，Docker使用了联合文件系统的概念。联合文件系统允许我们通过将不同的目录和或文件组合在一起来表示一个逻辑文件系统。它使用**写时复制**技术，在我们修改文件系统时复制层，这样我们在创建新镜像时只使用大约1MB的空间。当数据写入文件系统时，Docker会复制层并将其放在栈的顶部。在构建镜像和扩展现有镜像时，我们利用了这项技术，同样，在启动镜像和创建容器时，唯一的区别就是这个可写层，这意味着我们不需要每次都复制所有层并填满我们的磁盘。
- en: Mounting volumes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载卷
- en: The `-v`, or `--volume` parameter allows you to specify a pair of values corresponding
    to the file system you wish to mount on the host and the path where you would
    like to mount the volume inside the container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v` 或 `--volume` 参数允许您指定一对值，这对值对应于您希望在主机上挂载的文件系统以及您希望在容器内部挂载卷的路径。'
- en: 'Let''s try our example from earlier, but this time mounting a volume on the
    local file system:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试之前的示例，但这次是在本地文件系统上挂载一个卷：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you change into the host folder, you will see that there is access to the
    same folder from where you ran the `docker run` command. The syntax for the values
    for `-v` is `hostfolder:destinationfolder`, one thing I think is important to
    point out is that these paths need to be absolute, and you cannot use a relative
    path like `./` or `../foldername`. The volume you have just mounted has read/write
    access, any changes you make will be synchronized to the folder on the host so
    be careful to not go running `rm -rf *`. Creating Volumes on a production environment
    should be used very sparingly, I would advise that where possible you avoid doing
    it all together as in a production environment there is no guarantee if a container
    dies and is re-created that it will be replaced on the same host where it was
    previously. This means that any changes you have made to the volume will be lost.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您切换到主机文件夹，您会看到从您运行`docker run`命令的位置可以访问相同的文件夹。`-v`参数值的语法是`hostfolder:destinationfolder`，我认为需要指出的一点是，这些路径必须是绝对路径，您不能使用相对路径，如`./`或`../foldername`。您刚刚挂载的卷具有读写访问权限，您所做的任何更改都将同步到主机上的文件夹，所以请小心不要执行`rm
    -rf *`。在生产环境中创建卷应该非常谨慎使用，我建议在可能的情况下完全避免这样做，因为在生产环境中，没有保证如果容器死亡并被重新创建，它将替换为之前所在的主机。这意味着您对卷所做的任何更改都将丢失。
- en: Docker ports
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker端口
- en: When running web applications inside a container, it is quite common that we
    will need to expose some ports to the outside world. By default, a Docker container
    is completely isolated, and if you start a server running on port `8080` inside
    your container unless you explicitly specify that port is accessible from the
    outside, it will not be accessible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当在容器内运行Web应用时，我们通常会需要将一些端口暴露给外部世界。默认情况下，Docker容器是完全隔离的，如果您在容器内启动一个运行在端口`8080`的服务器，除非您明确指定该端口可以从外部访问，否则它将不可访问。
- en: Mapping ports is a good thing from a security perspective as we are operating
    on a principle of no trust. It is also effortless to expose these ports. Using
    one of the examples we created in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml),
    *Introduction to Microservices*, let's see just how easy this is.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，映射端口是一件好事，因为我们遵循的是不信任的原则。同时，暴露这些端口也毫不费力。使用我们在[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)“微服务简介”中创建的示例，让我们看看这有多简单。
- en: 'Move to the folder where you checked out the sample code, and run the following
    Docker command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到您检出示例代码的文件夹，并运行以下Docker命令：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-w` flag we are passing is to set the working directory that means that
    any command we run in the container will be run inside this folder. When we start
    the shell, you will see that rather than having to change into the folder we specify
    in the second part of the volume mounting we are already in that folder and can
    run our application. We are also using a slightly different image this time. We
    are not using `alpine:latest`, which is a lightweight version of Linux, we are
    using `golang:alpine`, which is a version of Alpine with the most recent Go tools
    installed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的`-w`标志是用来设置工作目录的，这意味着我们在容器中运行的任何命令都将在这个文件夹内运行。当我们启动shell时，你会看到，我们不需要切换到我们在卷挂载的第二部分指定的文件夹，我们已经在那个文件夹里，可以运行我们的应用程序。我们这次也使用了一个稍微不同的镜像。我们不是使用`alpine:latest`，这是一个轻量级的Linux版本，我们使用的是`golang:alpine`，这是一个安装了最新Go工具的Alpine版本。
- en: 'If we start our application using the `go run main.go` command; we should see
    the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`go run main.go`命令启动我们的应用程序；我们应该会看到以下输出：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now change to another shell and try to curl the API endpoint:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到另一个shell，并尝试curl API端点：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see something like the following message returned:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的消息返回：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we run the `docker ps` command to inspect the running containers, we will
    see that there are no ports exposed. Go back to your previous terminal window
    and kill the command and then exit the container.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`docker ps`命令来检查正在运行的容器，我们会看到没有端口被暴露。回到你之前的终端窗口，终止命令并退出容器。
- en: This time, when we start it, we will add the `-p` argument to specify the port.
    Like volumes, this takes a pair of values separated by a colon `(:)`. The first
    is the destination port on the host that we would like to bind to the second is
    the source port on the Docker container to which our application is bound.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们启动它时，我们将添加`-p`参数来指定端口。就像卷一样，这需要一对由冒号（`:`）分隔的值。第一个是我们希望绑定到主机上的目标端口，第二个是我们应用程序绑定的Docker容器上的源端口。
- en: Because this binds to the port on the host machine, in the same way that you
    would not be able to start the program locally twice because of the port binding,
    you cannot do this with the host port mappings in Docker either. Of course, you
    can start multiple instances of your code in separate containers and bind to different
    ports, and we will see how you can do that in just a bit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这绑定到了主机上的端口，就像你因为端口绑定而无法在本地两次启动程序一样，你也不能在Docker的主机端口映射中这样做。当然，你可以在不同的容器中启动你的代码的多个实例，并将它们绑定到不同的端口，我们将在稍后看到如何做到这一点。
- en: But first let's take a look at that port command, rather than starting a container
    and creating a shell to run our application we can do this in one command by replacing
    the `/bin/sh` command with our `go run` command. Give that a try and see if you
    can get your application running.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先让我们看看那个端口命令，而不是启动一个容器并创建一个shell来运行我们的应用程序，我们可以通过将`/bin/sh`命令替换为我们的`go run`命令，用一条命令来完成这个操作。试一试，看看你能否运行你的应用程序。
- en: Got it?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？
- en: 'You should have typed something like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该输入了类似以下的内容：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now try your `curl` to send some data to the API again, you should see the
    following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次尝试使用`curl`向API发送一些数据，你应该会看到以下输出：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Like volumes, you can specify multiple instances of the `-p` argument, which
    enables you to set up the binding for multiple ports.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像卷一样，你可以指定多个`-p`参数实例，这使你能够为多个端口设置绑定。
- en: Removing a container starting with an explicit name
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除以显式名称开始的容器
- en: 'Containers that start with a name parameter are not automatically removed even
    if you specify the `--rm` argument. To remove a container started in this way,
    we must manually use the `docker rm` command. If we append the `-v` option to
    the command, we can also remove the volumes that are associated with it. We should
    really do this now, or when we try to recreate the container later in the chapter,
    you might be left a little puzzled:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以名称参数开始的容器即使指定了`--rm`参数也不会自动删除。要删除以这种方式启动的容器，我们必须手动使用`docker rm`命令。如果我们向命令中添加`-v`选项，我们还可以删除与其关联的卷。我们真的应该现在就做这件事，或者当我们试图在本章的后面重新创建容器时，你可能会感到有些困惑：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Docker networking
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker网络
- en: I never intended this chapter to be a full reproduction of the official Docker
    documentation; I am just trying to explain some of the key concepts that will
    help you as you progress through the rest of this book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未打算让这一章成为官方Docker文档的完整复制；我只是试图解释一些关键概念，这些概念将帮助您在阅读本书的其余部分时进步。
- en: 'Docker networking is an interesting topic, and by default, Docker supports
    the following network modes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网络是一个有趣的话题，默认情况下，Docker支持以下网络模式：
- en: bridge
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bridge
- en: host
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: host
- en: none
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: none
- en: overlay
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: overlay
- en: Bridge networking
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接网络
- en: The bridge network is the default network that your containers will connect
    to when you launch them; this is how we were able to join our containers together
    in the last example. To facilitate this, Docker uses some of the core Linux capabilities
    such as networking namespaces and virtual Ethernet interfaces (or `veth` interfaces).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接网络是当你启动容器时它们将连接到的默认网络；这是我们能够在上一个示例中将容器连接在一起的原因。为了实现这一点，Docker使用了一些核心Linux功能，如网络命名空间和虚拟以太网接口（或`veth`接口）。
- en: When the Docker engine starts, it creates the `docker0` virtual interface on
    the host machine. The `docker0` interface is a virtual Ethernet bridge that automatically
    forwards packets between any other network interfaces that are attached to it.
    When a container starts it creates a `veth` pair, it gives one to the container,
    which becomes its `eth0,` and the other connects to the `docker0` bridge.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker引擎启动时，它会在主机机器上创建`docker0`虚拟接口。`docker0`接口是一个虚拟以太网桥，它自动将数据包转发到连接到它的任何其他网络接口。当容器启动时，它会创建一个`veth`对，它将一个分配给容器，这成为它的`eth0`，另一个连接到`docker0`桥。
- en: Host networking
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机网络
- en: The host network is essentially the same network that the Docker engine is running
    on. When you connect a container to the host network all of the ports that are
    exposed by the container are automatically mapped to the hosts, it also shares
    the IP address of the host. While this may seem like a nice convenience, Docker
    was always designed to be capable of running multiple instances of the same container
    on the engine, and since you can only bind a socket to one port in Linux using
    the `host network` limits this feature.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 主网络实际上是与Docker引擎运行在同一个网络。当你将容器连接到主网络时，容器暴露的所有端口都会自动映射到主机上，它还共享主机的IP地址。虽然这看起来像是一种方便，但Docker始终被设计为能够在引擎上运行同一容器的多个实例，并且由于在Linux中使用`host
    network`只能将套接字绑定到一个端口，这限制了这一功能。
- en: The host network can also pose a security risk to your container as it is no
    longer protected by the principle of no trust and you no longer have the ability
    to explicitly control if a port is exposed or not. That being said, due to the
    efficiencies of host networking it may in some instances be appropriate to connect
    a container to the host network if you anticipate that it is going to heavily
    use the network. An API gateway might be one such example, this container would
    still be possible to route requests to other API containers that are sitting on
    the bridge network.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主网络也可能对您的容器构成安全风险，因为它不再受“不信任”原则的保护，您也不再能够明确控制端口是否暴露。话虽如此，由于主机网络的效率，在某些情况下，如果您预计容器将大量使用网络，将容器连接到主机网络可能是合适的。API网关可能就是这样一个例子，这个容器仍然可以将请求路由到位于桥接网络上的其他API容器。
- en: No network
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无网络
- en: Removing your container from any network might in some instances be something
    you wish to do. Consider the situation where you have an application that only
    processes data stored in a file. Utilizing the principle of no trust, we may determine
    that the securest thing to do is to not connect it to any container and to only
    allow it to write to a volume that is mounted on the host. Attaching your container
    to the `none` network provides exactly this capability, and while the use case
    might be somewhat limited it is there, and it's nice to know about it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望从任何网络中移除您的容器。考虑这种情况：您有一个只处理存储在文件中的数据的应用程序。利用“不信任”原则，我们可能确定最安全的事情是不将其连接到任何容器，并且只允许它写入挂载在主机上的卷。将您的容器连接到`none`网络正好提供了这种能力，尽管用例可能有些有限，但它确实存在，了解这一点是很好的。
- en: Overlay network
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖网络
- en: The Docker overlay network is a unique Docker network that is used to connect
    containers running on separate hosts to one another. With the bridge network as
    we have already learned, network communication is localized to the Docker host
    and this is generally fine when you are developing software. When you run your
    code in production however, all this changes, as you will typically be running
    multiple hosts, each running multiple containers as part of your high availability
    setup. The containers still need to talk to one another, and while we could route
    all traffic through an **ESB** (**enterprise service bus**), this is a little
    bit of an anti-pattern in the microservice world. The recommended approach as
    we will see in a later chapter, is for the service to be responsible for its own
    discovery and load balancing client calls. The Docker overlay network solves this
    problem, it is in effect a network tunnel between machines which passes the traffic
    unmodified over the physical network. The problem with the overlay is that you
    can no longer rely on Docker to update the `etc/hosts` file for you, and you must
    depend on a dynamic service registry.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的覆盖网络是一种独特的Docker网络，用于连接运行在不同主机上的容器。正如我们之前所学的，使用桥接网络时，网络通信被限制在Docker主机上，这在开发软件时通常是可行的。然而，当你将代码部署到生产环境中时，所有这些都会改变，因为你通常会在多个主机上运行多个容器，作为你的高可用性配置的一部分。容器仍然需要相互通信，虽然我们可以通过**ESB**（企业服务总线）路由所有流量，但在微服务世界中这有点反模式。正如我们将在后面的章节中看到的，推荐的方法是服务负责自己的发现和负载均衡客户端调用。Docker覆盖网络解决了这个问题，实际上它是在机器之间创建一个网络隧道，将流量无修改地通过物理网络传递。覆盖网络的问题是你不能再依赖Docker为你更新`etc/hosts`文件，你必须依赖于动态服务注册。
- en: Custom network drivers
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义网络驱动程序
- en: Docker also supports plugins for networking, based around its open source `libnetwork`
    project, you can write custom networking plugins that can replace the networking
    subsystem of the Docker engine. They also give the capability for you to connect
    non-Docker applications to your container network such as a physical database
    server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还支持基于其开源`libnetwork`项目的网络插件，你可以编写自定义网络插件来替换Docker引擎的网络子系统。它们还提供了将非Docker应用程序连接到容器网络的能力，例如物理数据库服务器。
- en: Weaveworks
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Weaveworks
- en: Weaveworks is one of the most popular plugins, it gives you the capability to
    securely link your Docker hosts and also provides a whole host of additional tools
    such as service discovery with weavedns and visualization with weavescope, so
    you can see how your network is connected together.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Weaveworks是最受欢迎的插件之一，它使你能够安全地链接你的Docker主机，并提供一系列额外的工具，如weavedns的服务发现和weavescope的可视化，这样你可以看到你的网络是如何连接在一起的。
- en: '[https://www.weave.works](https://www.weave.works)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.weave.works](https://www.weave.works)'
- en: Project Calico
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Calico
- en: Project Calico attempts to solve the speed and efficiency problems that using
    virtual LANs, bridging, and tunneling can cause. It achieves this by connecting
    your containers to a vRouter, which then routes traffic directly over the L3 network.
    This can give huge advantages when you are sending data between multiple data
    centers as there is no reliance on NAT and the smaller packet sizes reduce CPU
    utilization.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Project Calico试图解决使用虚拟局域网、桥接和隧道可能引起的速度和效率问题。它通过将你的容器连接到vRouter来实现这一点，然后直接在L3网络上路由流量。当你需要在多个数据中心之间发送数据时，这可以带来巨大的优势，因为没有依赖NAT，较小的数据包大小减少了CPU利用率。
- en: '[https://www.projectcalico.org](https://www.projectcalico.org)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.projectcalico.org](https://www.projectcalico.org)'
- en: Creating custom bridge networks
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义桥接网络
- en: Implementing a custom overlay network is beyond the scope of this book, however,
    understanding how you can create custom bridge networks is something that we should
    look at as Docker-Compose, which we are going to introduce later in this chapter,
    utilizes these concepts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义覆盖网络超出了本书的范围，然而，了解如何创建自定义桥接网络是我们应该关注的，因为Docker-Compose，我们将在本章后面介绍，利用了这些概念。
- en: 'Like many of the Docker tools, creating a bridge network is quite straightforward.
    To see the currently running networks on your Docker engine, we can execute the
    following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多Docker工具一样，创建桥接网络相当简单。要查看Docker引擎上当前正在运行的网络，我们可以执行以下命令：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be something like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will find that there are three networks created by default, which is three
    of the ones we discussed earlier. Because these are default networks, we are unable
    to remove these, Docker requires these networks to function correctly and allowing
    you to remove them would be a bad thing indeed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bridge network
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a bridge network, we can use the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run this now in your terminal and list the networks again to see the results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: You will see that there is now a fourth network in your list that uses the bridge
    driver and that has the name you specified as one of the arguments. By default,
    when you create a network, it uses the `bridge` as a default driver, of course,
    it is possible to create a network to a custom driver, and this can be easily
    facilitated by specifying the additional argument, `-d drivername`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Connecting containers to a custom network
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect a container to a custom network, let''s again use the example application
    that we created in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml), *Introduction
    to Microservices*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Did you get the error message that the name is already in use because you forgot
    to remove the container in the earlier section? If so, it might be time to head
    back a few pages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming all went well, you should see the server starting message, now let''s
    try to curl the container using the same command we executed earlier:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should have received the following error message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This was expected, have a go to see if you can update the `docker run` command
    to make it work with our API container.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Got it?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, here is the modified command with the added network argument:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command should have worked just fine the second time, and you should see
    the expected output. Now remove the server container, and we will take a look
    at how you can write your own Docker files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Writing Dockerfiles
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dockerfiles are the recipes for our images; the define the base image, software
    to be installed and give us the capability to set the various structure that our
    application needs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to look at how we can create a Docker file for
    our example API. Again, this is not going to be a comprehensive overview of how
    Dockerfiles work as there are many books and online resources that exist for that
    explicit purpose. What we will do is to look at the salient points that will give
    us the basics.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we are going to do is build our application code as when we
    package this into a Docker file we will be executing a binary, not using the `go
    run` command. The image we are going to create will have only the software installed
    that we need to run our application. Limiting the software installed is a Docker
    best practice when creating images as it reduces the attack surface by only including
    what is necessary.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Building application code for Docker
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to execute a slightly different command for creating our files
    from the usual `go build`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding command, we are passing the argument `-ldflags '-s'`, this
    argument passes the `-s` argument to the linker when we build the application
    and tells it to statically link all dependencies. This is very useful when we
    use the popular Scratch container as a base; Scratch is the lightest base you
    can get it has no application frameworks or applications this is opposed to Ubuntu,
    which takes about 150MB. The difference between Scratch and Ubuntu is that Scratch
    does not have access to the standard C library `GLibC`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If we do not build a static binary, then it will not execute if we try to run
    it in a Scratch container. The reason for this is that while you may think that
    your Go application is a static binary it still has a dependency on `GLibC`, both
    the `net` and the `os/user` packages link to `GLibC` so if we are to run our application
    with a Scratch base image we need to statically link this. The benefit, however,
    is an incredibly small image, we end up with an image which is roughly 4MB in
    size, exactly the size of our compile Go application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Because the Docker engine is running on Linux, we also need to build our Go
    binary for the Linux architecture. Even if you are using Docker for Mac or Docker
    for Windows, what is happening under the hood is that the Docker engine is running
    a lightweight virtual machine on either `HyperV` or the Mac's `xhyve` virtual
    machine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If you are not using Linux to run your go build command and since Go has excellent
    capability for cross-platform compilation, you don't need to do much. All you
    do need to do is prefix the architecture variables `GOOS=linux GOARCH=386` to
    your go build command as we did in the earlier example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created a binary for our application, let''s take a look at
    the Docker file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: FROM
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FROM` instruction set the base image for subsequent instructions. You
    can use any image that is either stored in a remote registry or locally on your
    Docker Engine. When you execute `docker build`, if you do not already have this
    image, then Docker will pull it from the registry as the first step of the build
    process. The format for the `FROM` command is the same as you would use when issuing
    a `docker run` command it is either:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM image` // assuming latest'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FROM image:tag` // where you can specify a tag to use'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **line 1**, we are using the image name scratch, this is a particular kind
    of image, which is basically a blank canvas. We could use Ubuntu or Debian or
    Alpine or pretty much anything really, but since all we need to run our Go application
    is the application itself then we can use scratch to produce the smallest possible
    image.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: MAINTAINER
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MAINTAINER` instruction allows you to set the author of the generated image.
    This is an optional instruction; however, it can be good practice to include this
    even if you are not planning on publishing your image to the public registry.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: EXPOSE
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction informs Docker that the container listens on the specified
    networks ports at runtime. Expose does not make the ports accessible to the host;
    this function still needs to be performed with the `-p` mapping.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: COPY
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `COPY` instruction copies files from the source in the first part of this
    instruction to the destination specified in the second part:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`COPY <src> <dest>`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY ["<src">, "<dest>"]` // useful when paths contain whitespace'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<src>` in the `COPY` instruction may contain wildcards with the matching
    done using Go's `filepath.Match` rules.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`<src>` must be part of the context for the build, you cannot specify relative
    folders such as `../;`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A root `/` specified in the `<src>` will be the root of the context
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A root `/` specified in the `<dest>` will map to the containers root file system
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a `COPY` instruction without a destination will copy the file or
    folder into the `WORKDIR` with the same name as the original
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ENTRYPOINT
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `ENTRYPOINT` allows you to configure the executable that you would like to
    run when your container starts. Using `ENTRYPOINT` makes it possible to specify
    arguments as part of the `docker run` command which is appended to the `ENTRYPOINT`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` has two forms:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`ENTRYPOINT ["executable", "param1", "param2"]` // preferred form'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT command param1 param2` //shell form'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in our Docker file, we are specifying the `ENTRYPOINT ./server`.
    This is our Go binary that we would like to run. When we start our container with
    the following `docker run helloworld` command, we do not need to explicitly tell
    the container to execute the binary and launch the server. We can, however, pass
    additional arguments to the application via the `docker run` command arguments;
    these would then be appended to the `ENTRYPOINT` before the application is run.
    For example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding command would append the arguments to the executed statement
    defined in the entry point, which would be the equivalent of executing the following
    shell command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: CMD
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CMD instruction has three forms:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`CMD ["executable", "param1", "param2"]` // exec form'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["param1", "param2"]` // append default parameters to `ENTRYPOINT`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD command param1 param2` // shell form'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `CMD` is used to provide default arguments for the `ENTRYPOINT` instruction
    then both the `CMD` and `ENTRYPOINT` instructions should be specified using the
    `JSON` array format.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If we specify a default value for `CMD`, we can still override it by passing
    the command arguments to the `docker run` command.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Only one `CMD` instruction is permitted in a Docker file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Good practice for creating Dockerfiles
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking all of this into account, we need to remember how the union file system
    works in Docker and how we can leverage it to create small and compact images.
    Every time we issue a command in the Dockerfile, Docker will create a new layer.
    When we mutate this command, the layer must be completely recreated and potentially
    all the following layers too, which can dramatically slow down your build. It
    is therefore recommended a good practice that you should attempt to group your
    commands as tightly as possible to reduce the possibility of this occurring.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, you will see Dockerfiles which instead of having a separate `RUN`
    command for every command we would like to execute, we chain these using standard
    bash formatting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the following, which would install software from a package
    manager.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad Practice:**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Good Practice:**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The second example would only create one layer, which in turn would create a
    much smaller and more compact image, it is also good practice to organize your
    COPY statements placing the statement which changes the least further up in the
    Dockerfile, this way you avoid invalidation of subsequent layers even if there
    are no changes to these layers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Building images from Dockerfiles
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build an image from our Dockerfile, we can execute a straightforward command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Breaking this down the `-t` argument is the tag we wish to give the container,
    this takes the form name:tag, If we omit the `tag` portion of the argument as
    we have in our example command, then the tag `latest` will be automatically assigned.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If you run `docker images`, you will see that our `testserver` image has been
    given this tag.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The final argument is the context we would like to send to the Docker Engine.
    When you run a Docker build, the context is automatically forwarded to the server.
    This may seem strange, but you have to remember that it is not uncommon that the
    Docker Engine will not be running on your local machine, and therefore it will
    not have access to your local filesystem. For this reason, we should be careful
    about where we are setting our context as it can mean that potentially a large
    amount of data is being sent to the engine, which will slow things down. Context
    then becomes the root for your `COPY` commands.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our running container, let''s test it out. Why not start a
    container from our newly built image and check the API by curling the endpoint:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Docker build context
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run our Docker build command, we set the context path as the final argument.
    What actually happens when the command executes is that the context is transferred
    to the server. This can cause problems if you have a large source folder, so it
    is good practice to only send the files you need to be packaged inside the container
    or the files you need when building the container. There are two ways we can mitigate
    this problem. The first is to ensure that our context only has the files on it
    we require. Since this is not always possible we have a secondary option of using
    a `.dockerignore` file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Docker Ignore files
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.dockerignore` file is similar to a git ignore file before the CLI sends
    the context to the Engine, it excludes files and directories that match patterns
    in the `.dockerignore` file. It uses the patterns which are defined in Go''s `filepath.Match`
    rules you can find more information about them in the following Go documentation:
    [https://godoc.org/path/filepath#Match](https://godoc.org/path/filepath#Match)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '| **Rule** | **Behavior** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| `# comment` | Ignored. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| `*/temp*` | Exclude files and directories whose names start with temp in
    any immediate subdirectory of the root. For example, the plain file `/somedir/temporary.txt`
    is excluded, as is the directory `/somedir/temp`. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| `*/*/temp*` | Exclude files and directories starting with temp from any subdirectory
    that is two levels below the root. For example, `/somedir/subdir/temporary.txt`
    is excluded. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| `temp?` | Exclude files and directories in the root directory whose names
    are a one-character extension of temp. For example, `/tempa` and `/tempb` are
    excluded. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '[https://docs.docker.com/engine/reference/builder/#/dockerignore-file](https://docs.docker.com/engine/reference/builder/#/dockerignore-file)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: "[\uFEFF](https://docs.docker.com/engine/reference/builder/#/dockerignore-file)"
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Running Daemons in containers
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things you might be used to when deploying an application to a VM
    or physical server is to use a Daemon runner such as `initd` or `systemd` to ensure
    that the application is started in the background and continues to run even if
    it crashes. This is an anti-pattern when you are using Docker containers, for
    Docker to successfully stop the application it will attempt to kill the process
    running with PID 1\. Daemons will generally start with PID 1 and start your application
    with another process ID, which will mean they are not killed when you stop the
    Docker container. This can cause containers to hang when the `docker stop` command
    is executed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In the instance that you need to ensure that your application keeps running
    even after a crash then you delegate this responsibility to the orchestrator who
    is starting your Docker container. We will learn more about this when we look
    at orchestration in a later chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was all super easy-ish, let's now take a look at a compelling feature of
    Docker that allows you to start multiple containers at once with your stack definition
    stored in a handy YAML file.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker Compose on Linux
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have either Docker for Mac or Docker for Windows installed then it already
    comes bundled with `docker-compose`, if however, you are using Linux, then you
    may need to install this yourself as it does not come as part of the default Docker
    package.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Docker Compose on Linux, execute the following command in your terminal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Before we look at how we can run our application with `docker-compose`, let''s
    take a look at the file we are going to run and some of the important facets of
    it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Docker Compose files are written in YAML, inside this file you can define services
    that will make up your application. In our simple example, we are only describing
    two services. The first is our example code that we have just built and the second
    is a simple service that curls this API. As a production example, this is not
    particularly useful I admit, but it is only intended to show how to set up these
    files. As we progress through later chapters, we will heavily rely on compose
    files to create our databases and other data stores that make up our application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 1** defines the version of the Docker compose file we are using, version
    2 is the latest version and is a breaking change from version 1 which along with
    the `--link` directive is now deprecated and will be removed in a future release.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In **line 2** we define the services. Services are the containers that you would
    like to start with your stack. Each service has to have a unique name to the compose
    file, but not necessarily to all the containers running on your Docker Engine.
    To avoid conflicts when starting a stack, we can pass `-p projectname` to the
    `docker-compose up` command; this will prefix the name of any of our containers
    with the specified project name.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The minimum information you need to specify for a service is the image, which
    is the image you wish to start a container from. In the same way that `docker
    run` works, this can either be a local image on the Docker Engine or it can be
    a reference to an image in a remote registry. When you start a stack, compose
    will check to see if the image is available locally and if not it will automatically
    pull it from the registry.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 6** defines our second service; this is simply going to execute a command
    to curl a request to the API exposed by the first service.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In this service definition block, we are both specifying the image and an entry
    point.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Service startup
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous command looks a little weird, but there is a gotcha with Docker
    compose, which quite a few people fall foul too, there is no real way for compose
    to know when an application is running. Even if we use the `depends-on` configuration,
    we are only informing compose that there are dependencies and that it should control
    the start order of the services.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All compose will do is check that the container has been started. The general
    problem occurs with a misunderstanding that a container being started equals it
    is ready to receive requests. More often than not this is not the case, it can
    take time for your application to start and be ready to accept requests. If you
    have a dependency like we have specified in our entry point to curl the endpoint
    in another service, then we cannot assume that the dependent service is ready
    for requests before we execute our command. We will cover a pattern for dealing
    with this in [Chapter 6](74445ff8-eb01-4a2f-a910-0551e7d85a5f.xhtml), *Microservice
    Frameworks*, but for now we can be aware that:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '"Container started, and service ready is not the same thing."'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In our simple example, we know that it roughly takes a second or so for the
    service to start, so we will just sleep for three seconds to give it plenty of
    time to get ready before executing our command. This method is not good practice,
    and it is only to illustrate how we can use compose to link services. In reality,
    you would probably never start a single command like we are here in your compose
    file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: When you use a Docker network, Docker automatically adds a mapping to the containers
    `resolve.conf` pointing to the built in Docker DNS server, we can then contact
    other containers connected to the same network by referencing them by name. Looking
    at our curl command, this DNS capability is exactly what allows us to use the
    hostname testserver.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, time to test it out, run the following command from your terminal:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All being well you should see the following message returned in the output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Ctrl* + *C* will exit compose, however, since we did run this with the `docker
    run` command and passed the arguments `--rm` to remove the container, we need
    to ensure that we clean up after ourselves. To remove any stopped container that
    you have started with `docker-compose`, we can use the particular compose command
    `rm` and pass the `-v` argument to remove any associated volumes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Specifying the location of a compose file
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever you run `docker-compose`, it looks for a file named `docker-compose.yml`
    in the current folder as a default file. To specify an alternate file, we can
    pass the `-f` argument to compose with a path to the compose file we would like
    to load:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Specifying a project name
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier when we start `docker-compose`, it will create services
    with the given names in your Compose file appending the project name `default`
    to them. If we need to run multiple instances of this compose file, then `docker-compose`
    will not start another instance as it will check to see if any services are running
    with the given names first. To override this, we can specify the project name
    replacing the default name of `default`. To do this we just need to specify the
    `-p projectname` argument to our command as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will then create two containers:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`testproject_testserver`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testproject_curl`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In summary, we have learned how to work with Docker in this chapter, and while
    this is only a brief overview, I suggest you head over to the documentation and
    read more in depth on the concepts of Dockerfiles, Composefiles, the Docker Engine,
    and Docker Compose. Docker is an invaluable tool for development, testing, and
    production and as we progress through the following chapters, we will use these
    concepts extensively. In the next chapter, we are going to look at testing, which
    builds on all of the things you have learned so far.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
