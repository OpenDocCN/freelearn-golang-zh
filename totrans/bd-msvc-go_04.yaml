- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: When you try to define what testing is, you will come up with a multitude of
    answers, and many of us will not understand the full benefits of testing until
    we've been burnt by buggy software or we have tried to change a complex code base
    which has no tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图定义什么是测试时，你会得到各种各样的答案，我们中的许多人直到被有缺陷的软件烧伤或试图更改没有测试的复杂代码库时，才真正理解测试的全部好处。
- en: 'When I tried to define testing, I came up with the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我试图定义测试时，我得到了以下定义：
- en: '"The art of a good night''s sleep is knowing you will not get woken by a support
    call and the piece of mind from being able to confidently change your software
    in an always moving market."'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “良好的夜晚睡眠的艺术是知道你不会因为支持电话而被吵醒，以及在不断变化的市场中能够自信地更改你的软件所带来的安心感。”
- en: OK, so I am trying to be funny, but the concept is correct. Nobody enjoys debugging
    poorly written code, and indeed, nobody enjoys the stress caused when a system
    fails. Starting out with a mantra of quality first can alleviate many of these
    problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我试图讲一个笑话，但这个概念是正确的。没有人喜欢调试糟糕的代码，确实，没有人喜欢系统失败时带来的压力。从质量第一的咒语开始可以缓解许多这些问题。
- en: 'Over the last 20 years, techniques like TDD have become commonplace. In some
    instances, it is not as common as I would like, but at least people are talking
    about testing now. In some ways, we have the Agile Alliance to thank for this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的20年里，像TDD这样的技术已经变得司空见惯。在某些情况下，它并不像我希望的那样普遍，但至少人们现在在谈论测试了。在某种程度上，我们要感谢敏捷联盟：
- en: the principle of releasing little and often provides significant business benefits;
    the downside (or the benefit, depending on your viewpoint) to releasing little
    and often is that you can no longer spend three months running through a regression
    test suite before you release to market.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步释放的原则提供了显著的商业效益；然而，频繁地逐步释放的缺点（或从你的观点来看是好处）是，你不能再在发布到市场之前花上三个月的时间运行回归测试套件。
- en: In my office, context switching is one of the biggest complaints. Nobody enjoys
    having to drop what they are doing to investigate a problem on work that they
    or even a colleague may have carried out months or years ago. We want to be moving
    forward; and to ensure we can do that, we have to make sure that what we have
    previously delivered meets the specification and is of high enough quality to
    meet the client's requirement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的办公室里，上下文切换是最大的抱怨之一。没有人喜欢放下手头的工作去调查可能是由他们或甚至是一个同事几个月或几年前完成的工作中的问题。我们希望向前推进；为了确保我们能这样做，我们必须确保我们之前交付的内容符合规格，并且质量足够高以满足客户的要求。
- en: I also mentioned a change in my definition, and one of the biggest problems
    with change is the concern that the change you are making may have an undesirable
    effect on another part of the system. This effect applies to microservices as
    well as large monolithic systems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我还提到了定义上的变化，而变化的最大问题之一是担心你正在进行的更改可能会对系统的另一部分产生不良影响。这种影响适用于微服务，也适用于大型单体系统。
- en: What if I also told you that the side effect of code that is easy to test is
    probably well-written code that is loosely coupled and has the right abstractions?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，易于测试的代码的副作用可能是编写得很好的代码，这种代码松散耦合并且具有正确的抽象？
- en: 'Testing, however, is not just about the developer: there is a definite need
    for manual testing by people detached from the code base. This exploratory testing
    can bring out missing requirements or incorrect assumptions. In itself, this is
    a specialized field and way beyond the scope of this book, so we are going to
    concentrate on the kind of testing that you should be doing.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试并不仅仅是关于开发者的：确实需要有人从代码库中分离出来进行手动测试。这种探索性测试可以揭示缺失的需求或错误的假设。本身，这是一个专业领域，远远超出了本书的范围，所以我们将会集中讨论你应该进行的测试类型。
- en: The testing pyramid
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: Mike Cohn is credited with having created the concept of a testing pyramid in
    his book *Succeeding with Agile*. The concept is that your cheapest (fastest)
    tests to run, which will be your unit tests, go at the bottom of the pyramid;
    service level integration tests are on top of this, and at the very top, you place
    full end-to-end tests, which are the costliest element. Because this is a pyramid,
    the number of tests gets smaller as you move up the pyramid.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Mike Cohn 因在其书籍《成功实施敏捷》中创造了测试金字塔的概念而受到赞誉。这个概念是，你运行成本最低（最快）的测试，即单元测试，位于金字塔的底部；服务级别集成测试位于此之上，而在金字塔的顶端，你放置完整的端到端测试，这是成本最高的元素。因为这是一个金字塔，随着你向上移动金字塔，测试的数量会减少。
- en: '![](img/e41fa6ed-58a7-46a2-a5af-8358f58a61ee.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e41fa6ed-58a7-46a2-a5af-8358f58a61ee.png)'
- en: In the early days of automated testing, all the testing was completed at the
    top of the pyramid. While this did work from a quality perspective, it meant the
    process of debugging the area at fault would be incredibly complicated and time-consuming.
    If you were lucky, there might be a complete failure which could be tracked down
    to a stack trace. If you were unlucky, then the problem would be behavioral; and
    even if you knew the system inside out, it would involve plowing through thousands
    of lines of code and manually repeating the action to reproduce the failure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试的早期，所有的测试都是在金字塔的顶端完成的。虽然从质量角度来看这确实有效，但它意味着调试有问题的区域的过程将会极其复杂且耗时。如果你很幸运，可能会出现完全失败的情况，这可以通过堆栈跟踪来追踪。如果你不幸，那么问题可能是行为上的；即使你完全了解系统，你也可能需要翻阅数千行代码并手动重复操作来重现失败。
- en: Outside-in development
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外向内开发
- en: When writing tests, I like to follow a process called outside-in development.
    With outside-in development, you start by writing your tests almost at the top
    of the pyramid, determine what the functionality is going to be for the story
    you are working on, and then write some failing test for this story. Then you
    work on implementing the unit tests and code which starts to get the various steps
    in the behavioral tests to pass.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，我喜欢遵循一个称为从外向内开发的过程。在从外向内开发中，你首先几乎在金字塔的顶端编写测试，确定你正在工作的故事的功能，然后为这个故事编写一些失败的测试。然后你开始实现单元测试和代码，这开始让行为测试的各个步骤通过。
- en: '![](img/e16cc217-a7e6-4d93-a49e-1c0efc11e146.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e16cc217-a7e6-4d93-a49e-1c0efc11e146.png)'
- en: This initial specification also becomes the living documentation for your system.
    We will go into more detail as to how you can create this later in this chapter,
    but more often than not it is written in a language like **Gherkin** and is defined
    by working in a group with a domain specialist like a product owner, a developer,
    and a testing expert. The intention behind Gherkin is to create a universal language
    that everyone understands. This ubiquitous language uses verbs and nouns that
    have special meaning to the team, and which is almost always domain-specific,
    but should also be understandable to outsiders.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始规范也成为了你系统的活文档。我们将在本章后面更详细地介绍如何创建它，但大多数情况下，它是以**Gherkin**这样的语言编写的，并且是由一个包含领域专家（如产品所有者、开发人员和测试专家）的团队共同定义的。Gherkin背后的意图是创建一个每个人都理解的全局语言。这种普遍使用的语言使用具有特殊意义的动词和名词，几乎总是特定于领域，但也应该对外部人员是可理解的。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The feature is the story which, in an agile environment is owned by the product
    owner. The feature is then broken down into scenarios which explain in greater
    detail the qualities that the code must have to be acceptable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能是敏捷环境中由产品所有者拥有的故事。然后功能被分解为场景，这些场景更详细地说明了代码必须具备的、可接受的特性。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we get to the section on BDD in a little while we will examine this in
    greater depth; we will also look at a framework for Go for writing and executing
    Cucumber specifications. Now, however, I am going to break the rules of outside
    in development by showing you how to write great unit tests in Go. The concepts
    we are about to learn will be greatly beneficial when we do start to look at BDD,
    so I think it is best we cover them first. Like the previous chapters, it will
    be useful to you when reading through this chapter to have the source code handy;
    you can clone the code from the following location: [https://github.com/building-microservices-with-go/chapter4.git](https://github.com/building-microservices-with-go/chapter4.git)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后进入BDD部分时，我们将更深入地探讨这个问题；我们还将查看一个用于编写和执行Cucumber规范的Go框架。现在，然而，我将通过向您展示如何在Go中编写优秀的单元测试来打破“自外向内”开发规则。我们即将学习的概念在我们开始研究BDD时将非常有用，因此我认为最好我们先了解它们。像前面的章节一样，在阅读本章时，手头有源代码会很有用；您可以从以下位置克隆代码：[https://github.com/building-microservices-with-go/chapter4.git](https://github.com/building-microservices-with-go/chapter4.git)
- en: Unit tests
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Our unit tests go right down to the bottom of the pyramid. This book was never
    intended to be a lesson in TDD, there are plenty of better places to learn that.
    We will, however, take a look at the testing framework which is built into Go.
    Before we do that, let''s just remind ourselves of the three laws of testing as
    defined by the awesome Uncle Bob Martin in his book *Clean Code*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试直接到底层的金字塔。这本书从未打算成为TDD的教程，有太多更好的地方可以学习。然而，我们将查看Go中内置的测试框架。在我们这样做之前，让我们先提醒自己由Bob
    Martin叔叔在他的书《Clean Code》中定义的三个测试定律：
- en: '**First law**: You may not write production code until you have written a failing
    unit test'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一定律**：在你编写失败的单元测试之前，你不得编写生产代码'
- en: '**Second law**: You may not write more of a unit test than is sufficient to
    fail, and not compiling is failing'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二定律**：你不得编写超过足够失败的单元测试，不编译即视为失败'
- en: '**Third law**: You may not write more production code than is sufficient to
    pass the currently failing test'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三定律**：你不得编写超过足够通过当前失败的测试的生产代码'
- en: One of the most effective ways to test a microservice in Go is not to fall into
    the trap of trying to execute all the tests through the HTTP interface. We need
    to develop a pattern that avoids creating a physical web server for testing our
    handlers, the code to create this kind of test is slow to run and incredibly tedious
    to write. What need to be doing is to test our handlers and the code within them
    as unit tests. These tests will run far quicker than testing through the web server,
    and if we think about the coverage, we will be able to test the wiring of the
    handlers in the Cucumber tests that execute a request to the running server which
    overall gives us 100% coverage of our code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中对微服务进行测试的最有效方法之一不是陷入通过HTTP接口执行所有测试的陷阱。我们需要开发一种模式，避免为测试我们的处理程序创建物理Web服务器，创建这种测试的代码运行速度慢，编写起来极其繁琐。我们需要做的是将我们的处理程序及其内部的代码作为单元测试来测试。这些测试将比通过Web服务器进行测试运行得更快，如果我们考虑覆盖率，我们将在执行请求到运行服务器的Cucumber测试中测试处理程序的连接，这总体上为我们提供了代码的100%覆盖率。
- en: '`main.go`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will see in the main function that we have split the handlers out into a
    separate package. Breaking up the code in this way allows us to test these in
    isolation, so let's go ahead and write some unit tests for our `SearchHandler`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在主函数中看到我们将处理程序拆分到一个单独的包中。以这种方式拆分代码允许我们单独测试这些处理程序，所以让我们继续为我们的`SearchHandler`编写一些单元测试。
- en: The convention is that we define our test files in the same folder as the package
    to which they belong, and we name them the same as the file they are testing followed
    by `_test`. For our example, we are going to write some tests for our `SearchHandler`
    which lives in the `handlers/search.go` file; therefore our test file will be
    named `handlers/search_test.go`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，我们将在与它们所属的包相同的文件夹中定义我们的测试文件，并将它们命名为它们要测试的文件名，后面跟`_test`。在我们的例子中，我们将为位于`handlers/search.go`文件中的`SearchHandler`编写一些测试；因此，我们的测试文件将被命名为`handlers/search_test.go`。
- en: 'The signature for a test method looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法的签名看起来像这样：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The name of the test must have a particular name beginning with `Test` and then
    immediately following this an uppercase character or number. So we could not call
    our test `TestmyHandler`, but we could name it `Test1Handler` or `TestMyHandler`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试名称必须有一个特定的名称，以`Test`开头，然后紧接着是一个大写字母或数字。因此，我们不能将我们的测试命名为`TestmyHandler`，但我们可以将其命名为`Test1Handler`或`TestMyHandler`。
- en: Again, drawing on Uncle Bob's wisdom, we need to think about the names of our
    tests as carefully as we would the names for our methods in our production code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，借鉴Uncle Bob的智慧，我们需要像对待生产代码中的方法名称一样仔细考虑我们的测试名称。
- en: 'The first test we are going to write is the one who will validate that search
    criteria have been sent with the request and the implementation is going to look
    like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第一个测试是验证请求中是否已发送搜索条件，其实现将如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `net/http/httptest` package has two fantastic convenience methods for us
    `NewRequest` and `NewResponse`, if you are familiar with unit testing concepts,
    then one of the fundamentals isolate dependency. Often we replace the dependencies
    with Mocks or Spies which allow us to test the behavior of our code without having
    to execute code in the dependencies. These two functions enable us to do exactly
    this; they generate Mock versions of the dependent objects `http.Request` and
    `http.ResponseWriter`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http/httptest`包为我们提供了两个出色的方便方法`NewRequest`和`NewResponse`，如果你熟悉单元测试的概念，那么其中一个基本原理是隔离依赖。我们经常用Mock或Spies替换依赖项，这样我们就可以在不执行依赖项中的代码的情况下测试我们的代码的行为。这两个函数使我们能够做到这一点；它们生成依赖对象的Mock版本`http.Request`和`http.ResponseWriter`。'
- en: httptest.NewRequest
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: httptest.NewRequest
- en: 'The first line we need to pay attention to is line **11**: the `net/http/httptest`
    package has some nice convenience methods for us. The `NewRequest` method returns
    an incoming server request which we can then pass to our `http.Handler`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要特别注意的第一行是第**11**行：`net/http/httptest`包为我们提供了一些方便的方法。`NewRequest`方法返回一个传入的服务器请求，然后我们可以将其传递给我们的`http.Handler`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can pass parameters to the method and the target, which is either the path
    or an absolute URL. If we only pass a path, then `example.com` will be used as
    our host setting. Finally, we can give it an `io.Reader` file which will correspond
    to the body of the request; if we do not pass a nil value then `Request.ContentLength`
    is set.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向方法和方法的目标传递参数，目标可以是路径或绝对URL。如果我们只传递一个路径，那么`example.com`将用作我们的主机设置。最后，我们可以提供一个`io.Reader`文件，它将对应于请求的主体；如果我们不传递nil值，则`Request.ContentLength`被设置。
- en: httptest.NewRecorder
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: httptest.NewRecorder
- en: 'In line **12** we are creating a `ResponseRecorder` type: this is going to
    be our instance of `ResponseWriter` that we pass to the handler. Because a handler
    has no return function to validate correct operation, we need to check what has
    been written to the output. The `ResponseRecorder` type is an implementation of
    `http.ResponseWriter` which does just that: it records all the mutations we make
    so that it is later possible to make our assertions against it.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**12**行，我们正在创建一个`ResponseRecorder`类型：这将是我们传递给处理器的`ResponseWriter`实例。因为处理器没有返回函数来验证正确操作，我们需要检查已经写入输出的内容。`ResponseRecorder`类型是`http.ResponseWriter`的一个实现，它正是这样做的：它记录我们所做的所有更改，以便稍后可以对它进行断言。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All we then need to do is to call the `ServeHTTP` method with our dummy request
    and response and then assert that we have the correct outcome.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是调用`ServeHTTP`方法，并带上我们的模拟请求和响应，然后断言我们得到了正确的结果。
- en: Go does not have an assertion library as you would find with RSpec or JUnit.
    We will look at a third-party framework later in this chapter, but for now, let's
    concentrate on the standard packages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有像RSpec或JUnit那样的断言库。我们将在本章后面部分查看第三方框架，但到目前为止，让我们专注于标准包。
- en: In line **16**, we are checking to see if the response code returned from the
    handler is equal to the expected code `http.BadRequest`. If it is not, then we
    call the Errorf method on the testing framework.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**16**行，我们正在检查从处理器返回的响应代码是否等于预期的代码`http.BadRequest`。如果不是，那么我们就调用测试框架上的Errorf方法。
- en: '**ErrorF**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**ErrorF**'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Errorf` function takes the parameters of a format string and a variadic
    list of parameters; internally this calls the `Logf` method before calling `Fail`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Errorf`函数接受一个格式字符串的参数和一个可变数量的参数列表；在调用`Fail`之前，它内部调用`Logf`方法。'
- en: 'If we run our tests by running the command `go test -v -race ./...` , we should
    see the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过运行命令`go test -v -race ./...`来运行我们的测试，我们应该看到以下输出：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `-v` flag will print the output in a verbose style, and it will also print
    all the text written to the output by the application, even if the test succeeds.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v` 标志将以详细模式打印输出，并且它还会打印出应用程序写入输出的所有文本，即使测试成功。'
- en: The `-race` flag enables Go's race detector which holds discover bugs with concurrency
    problems. A data race occurs when two Go routines access the same variable concurrently,
    and at least one of the accesses is a write. The race flag adds a small overhead
    to your test run, so I recommend you add it to all executions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`-race` 标志启用了 Go 的竞态检测器，它可以检测并发问题中的错误。当两个 Go 线程同时访问同一个变量，并且至少有一个访问是写入时，就会发生数据竞争。竞态标志会给你的测试运行增加一点开销，所以我建议你将其添加到所有执行中。'
- en: Using `-./...` as our final parameter allows us to run all our tests in the
    current folder as well as the child folders, it saves us from manually having
    to construct a list of packages or files to test.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-./...` 作为我们的最终参数允许我们在当前文件夹以及子文件夹中运行所有测试，这使我们免去了手动构建要测试的包或文件列表的麻烦。
- en: 'Now we have a failing test we can go ahead and write the implementation to
    make the test pass:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个失败的测试，我们可以继续编写实现来使测试通过：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we rerun the tests, we can see that they have succeeded:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新运行测试时，我们可以看到它们已经成功：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This output is awesome; but what if passing a query to the request with a blank
    string constitutes a failure? Time to write another test:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出很棒；但如果将空字符串传递给请求被视为失败呢？是时候写另一个测试了：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This test is very similar to the last one; the only difference is that we are
    passing some JSON in the request body. While this test will fail correctly, we
    should take the lead from Uncle Bob and refactor this to make it more readable:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与上一个非常相似；唯一的区别是我们正在将一些 JSON 传递到请求体中。虽然这个测试会正确失败，但我们应该从 Uncle Bob 那里吸取教训，对这个测试进行重构以使其更易于阅读：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have refactored our test to add a setup method which is shared across the
    two tests, the intention behind this is to keep our tests focused on three core
    areas:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重构了测试，添加了一个共享于两个测试的设置方法，其背后的意图是保持我们的测试专注于三个核心领域：
- en: Setup
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置
- en: Execute
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行
- en: Assert
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言
- en: 'Bad tests with duplicated code can be worse than bad code: your tests should
    be clear, easy to understand and contain the same care that you would add to your
    production code.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码的糟糕测试可能比糟糕的代码更糟糕：你的测试应该是清晰、易于理解的，并且包含你会在生产代码中添加的相同关注。
- en: 'Now, if the test fails, we can go ahead and update our code to implement the
    feature:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果测试失败，我们可以继续更新我们的代码来实现这个功能：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All we needed to do was make a simple modification to our `if` statement. As
    our system grows in complexity and we find more cases for what constitutes an
    invalid search query, we will refactor this into a separate method; but, for now,
    this is the minimum we need to do to make the test pass.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是对 `if` 语句进行简单的修改。随着我们的系统复杂性增加，我们发现更多关于构成无效搜索查询的情况，我们将将其重构为单独的方法；但，目前，这是我们使测试通过所需的最小修改。
- en: Dependency injection and mocking
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入和模拟
- en: To get the tests that return items from the `Search` handler to pass, we are
    going to need a data store. Whether we implement our data store in a database
    or a simple in-memory store we do not want to run our tests against the actual
    data store as we will be checking both data store and our handler. For this reason,
    we are going to need to manage the dependencies on our handler so that we can
    replace them in our tests. To do this, we are going to use a technique called
    dependency injection where we will pass our dependencies into our handler rather
    than creating them internally.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使返回 `Search` 处理器项的测试通过，我们需要一个数据存储。无论我们是在数据库中实现数据存储还是在简单的内存存储中实现，我们都不想在实际的数据存储上运行我们的测试，因为我们将会检查数据存储和我们的处理器。因此，我们需要管理处理器上的依赖，以便在测试中替换它们。为此，我们将使用一种称为依赖注入的技术，我们将通过传递依赖项到处理器而不是在内部创建它们来实现这一点。
- en: This method allows us to replace these dependencies with stubs or mocks when
    we are testing the handler, making it possible to control the behavior of the
    dependency and check how the calling code responds to this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法允许我们在测试处理器时用存根或模拟来替换这些依赖，这样我们就可以控制依赖的行为并检查调用代码对此的反应。
- en: 'Before we do anything, we need to create our dependency. In our simple example,
    we are going to create an in-memory data store which has a single method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做任何事情之前，我们需要创建我们的依赖。在我们的简单示例中，我们将创建一个内存数据存储，它有一个单独的方法：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To replace the type with a mock, we need to change our handler to depend on
    an interface which represents our data store. We can then interchange this with
    either an actual data store or a mock instance of the store without needing to
    change the underlying code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要用模拟替换类型，我们需要将我们的处理器修改为依赖于代表我们的数据存储的接口。然后我们可以用实际的数据存储或存储的模拟实例来交换，而无需更改底层代码：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can now go ahead and create the implementation for this. Since this is a
    simple example, we are going to hardcode our list of kittens as a slice and the
    search method will just select from this slice when the criteria given as a parameter
    matches the name of the kitten.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建这个实现的代码。由于这是一个简单的示例，我们将将小猫的列表硬编码为一个切片，并且搜索方法将只从匹配作为参数给出的标准的小猫名称的切片中进行选择。
- en: 'OK, great; we now have our data store created, so let''s see how we are going
    to modify our handler to accept this dependency. It is quite simple: because we
    created a struct which implements the `ServeHTTP` method, we can just add our
    dependencies onto this struct:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太棒了；我们现在已经创建了数据存储，所以让我们看看我们将如何修改我们的处理器以接受这个依赖项。这很简单：因为我们创建了一个实现了 `ServeHTTP`
    方法的结构体，我们只需将我们的依赖项添加到这个结构体上：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note how we are using a reference to the interface rather than the concrete
    type, which allows us to interchange this object with anything that implements
    the store interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用接口的引用而不是具体类型，这允许我们将这个对象与实现存储接口的任何东西进行交换。
- en: 'Now, back to our unit tests: we would like to ensure that, when we call the
    `ServeHTTP` method with a search string, we are querying the data store and returning
    the kittens from it.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的单元测试：我们希望确保，当我们用搜索字符串调用 `ServeHTTP` 方法时，我们正在查询数据存储并返回其中的小猫。
- en: To do this, we are going to create a mock instance of our data store. We could
    create the mock ourselves; however, there is an excellent package by Matt Ryer
    who incidentally is also a Packt author. Testify ([https://github.com/stretchr/testify.git](https://github.com/stretchr/testify.git))
    has a fully featured mocking framework with assertions. It also has an excellent
    package for testing the equality of objects in our tests and removes quite a lot
    of the boilerplate code we have to write.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将创建数据存储的模拟实例。我们可以自己创建模拟；然而，Matt Ryer 有一个非常好的包，他碰巧也是 Packt 的作者。Testify
    ([https://github.com/stretchr/testify.git](https://github.com/stretchr/testify.git))
    有一个功能齐全的模拟框架，带有断言。它还有一个用于测试测试中对象相等性的优秀包，并消除了我们不得不编写的许多样板代码。
- en: 'In the data package, we are going to create a new file called `mockstore.go`.
    This structure will be our mock implementation of the data store:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包中，我们将创建一个名为 `mockstore.go` 的新文件。这个结构将是我们的数据存储模拟实现：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In line **6**, we are defining our `MockStore` object. There is nothing unusual
    about this, except you will note that it is embedding the `mock.Mock` type. Embedding
    Mock will give us all of the methods on the `mock.Mock` struct.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 **6** 行，我们定义了我们的 `MockStore` 对象。这没有什么不寻常的，除了你会注意到它嵌入了 `mock.Mock` 类型。嵌入 Mock
    将给我们 `mock.Mock` 结构体上的所有方法。
- en: 'When we write the implementation for our search method, we are first calling
    the `Called` method and passing it the arguments that are sent to `Search`. Internally,
    the mock package is recording that this method was called and with what parameters
    so that we can later write an assertion against it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写搜索方法的实现时，我们首先调用 `Called` 方法，并传递发送到 `Search` 的参数。内部，模拟包正在记录这个方法被调用以及传递了什么参数，这样我们就可以稍后针对它编写断言：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we are returning `args.Get(0).(Kitten)`. When we call the `Called`
    method, the mock returns us a list of arguments that we provided in the setup.
    We are casting this to our output type and returning to the caller. Let's take
    a quick look at the test method and see how this works.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回 `args.Get(0).(Kitten)`。当我们调用 `Called` 方法时，模拟返回我们设置中提供的参数列表。我们将这些参数转换为我们的输出类型，并返回给调用者。让我们快速看一下测试方法，看看它是如何工作的。
- en: 'Line **57** is the start of our test setup. The first thing we are going to
    do is to create an instance of our `MockStore`. We then set this as a dependency
    for our `Search` handler. If we skip back up the file to line **38**, you will
    see that we are calling the `On` method on our `mockStore`. The `On` method is
    a setup method for the mock and has the signature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第 **57** 行是测试设置的开始。我们首先要做的是创建我们的 `MockStore` 实例。然后，我们将这个实例设置为 `Search` 处理器的依赖项。如果我们回溯到文件的第
    **38** 行，你会看到我们在 `mockStore` 上调用 `On` 方法。`On` 方法是模拟的设置方法，其签名如下：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we do not call the `On` method with the parameter `Search` then when we call
    the `Search` method in our code we will get an exception from the test saying
    that `Search` has been called yet has not been setup. One of the reasons why I
    like to use mocking rather than a simple Stub is this ability to assert that a
    method has been called and we can explicitly dictate the behavior that the code
    under test is allowed to exhibit. This way we can ensure that we are not doing
    work the output of which has not been tested.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用参数`Search`调用`On`方法，那么当我们调用代码中的`Search`方法时，测试将抛出一个异常，表示`Search`已被调用但尚未设置。我喜欢使用模拟而不是简单的存根的一个原因就是这种能力，可以断言一个方法已被调用，并且我们可以明确地规定代码被测试可以表现出的行为。这样我们可以确保我们没有做那些输出未经测试的工作。
- en: In our instance, we are setting up the condition that, when the `Search` method
    is called with the parameter `Fat Freddy's Cat`, we would like to return an array
    of kittens.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们设置的条件是，当`Search`方法使用参数`Fat Freddy's Cat`被调用时，我们希望返回一个包含小猫的数组。
- en: The assertion is that we are calling the `Search` method on the data store and
    passing it the query that was sent in the HTTP response. Using assertions in this
    way is a handy technique as it allows us to test the unhappy path such as when
    a data store may not be able to return data due to an internal error or another
    reason. If we were trying to test this with an integration test, it could be tough
    to persuade the database to fail on demand.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在数据存储上调用`Search`方法，并传递HTTP响应中发送的查询。以这种方式使用断言是一种方便的技术，因为它允许我们测试不愉快的路径，例如当数据存储可能由于内部错误或其他原因而无法返回数据时。如果我们试图使用集成测试来测试这个，可能会很难说服数据库按需失败。
- en: Why don't you spend five minutes as a little exercise and go ahead and write
    this code to finish off?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不花五分钟作为一个小练习，然后继续编写这段代码来完成？
- en: 'Did it all work? Don''t worry if not, you can just check out the example code
    to see where you have gone wrong, but I hope that the process is useful. You can
    see how you can take a measured approach through two layers of testing to produce
    a working application. These tests are now your safety net: whenever you change
    the code to add a new feature, you can be sure that you are not breaking something
    unintentionally.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都工作了吗？如果没有，别担心，你只需查看示例代码，看看你哪里出了错，但我希望这个过程是有用的。你可以看到，你可以通过两层测试来采取一种有节制的做法，从而产生一个可工作的应用程序。这些测试现在是你的安全网：无论何时你更改代码以添加新功能，你都可以确信你没有无意中破坏了某些东西。
- en: Code coverage
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Code coverage is an excellent metric to ensure that the code you are writing
    has adequate coverage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个很好的指标，可以确保你编写的代码有足够的覆盖率。
- en: 'The most simplistic way of getting a readout of test coverage is to execute
    our tests with the `-cover` option:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 获取测试覆盖率的最简单方法是在执行测试时使用`-cover`选项：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we run this against our example code in the root folder of our example code
    we will see the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在示例代码根目录中运行这段代码，我们会看到以下输出：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now our handlers look beautiful: we have 100% coverage of this package. However,
    our data package is only reporting 20% coverage. Before we get too alarmed at
    this, let''s take a look at what we are trying to test.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理器的样子看起来很漂亮：我们对这个包的覆盖率达到了100%。然而，我们的数据包只报告了20%的覆盖率。在我们对此过于担忧之前，让我们看看我们正在尝试测试的内容。
- en: If we first examine the `datastore.go` file, this is only an interface and therefore
    does not have any test files; however, the `memorystore.go` does. This file is
    well covered with 100% test coverage for this file. The files that are letting
    us down are our mock class and our MongoDB implementation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先检查`datastore.go`文件，这只是一个接口，因此没有测试文件；然而，`memorystore.go`有。这个文件对这个文件的测试覆盖率达到了100%。让我们失望的文件是我们的模拟类和我们的MongoDB实现。
- en: Now the mock type I am not too bothered about, but the Mongo store is an interesting
    problem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我对模拟类型不太关心，但Mongo存储是一个有趣的问题。
- en: 'This type would be incredibly difficult to test due to the dependency on the
    MongoDB. We could create a mock implementation of the Mongo package to test our
    code, but this could be more complicated than the implementation. There are however
    some critical areas where we could make mistakes in this class. Consider line
    **26**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖于MongoDB，这种类型将非常难以测试。我们可以创建Mongo包的模拟实现来测试我们的代码，但这可能比实现更复杂。然而，在这个类中，我们有一些关键区域可能会出错。考虑第**26**行：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This line retrieves the collection `kittens` from the database `kittenserver`.
    If we make a simple spelling mistake here, then our application will not work.
    We do not want to wait until this code gets out into production to see that this
    is happening. We also do not want to have to manually test this as, in a larger
    application, this could be considerably time-consuming. Integration tests are
    really where our Cucumber tests shine. If you remember, we are writing some very
    high-level end-to-end tests to make sure that the input into our API results in
    the correct output. Because this is running against an actual database, if we
    had made such an error, then it would be picked up. So, while the Go coverage
    report states that we are not covered, it's because we have higher level tests
    that the Go test is not looking at, so we are covered. The central area where
    we could run into problems would be by omitting line **23**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码从数据库`kittenserver`中检索集合`kittens`。如果我们在这里犯了一个简单的拼写错误，那么我们的应用程序将无法工作。我们不希望等到代码进入生产环境后才发现这个问题。我们也不想手动测试这个，因为在更大的应用程序中，这可能会非常耗时。集成测试确实是我们的Cucumber测试大放异彩的地方。如果你还记得，我们正在编写一些非常高级的端到端测试，以确保我们的API输入产生正确的输出。因为这是针对实际数据库运行的，如果我们犯了这样的错误，那么它就会被捕捉到。所以，虽然Go覆盖率报告显示我们没有覆盖，但这是因为我们有更高层次的测试，Go测试没有查看，所以我们是有覆盖的。我们可能遇到问题的核心区域是省略了第**23**行。
- en: If we do not close the connection to the database after we have opened it, we
    are going to be leaking connections; after a while, we may find that we can no
    longer open another as the pool is exhausted. There is no simple way to test this,
    but there is, however, a way to catch the problem post-deploy. When we look at
    logging and monitoring in [Chapter 7](bcd70598-81c4-4f0c-8319-bc078e854db5.xhtml),
    *Logging and* *Monitoring*, we will see how we can expose such information to
    help us ensure our production system is functioning correctly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在打开数据库后没有关闭连接，我们将泄漏连接；过一段时间后，我们可能会发现我们无法再打开另一个，因为连接池已经耗尽。没有简单的方法来测试这个问题，但是，然而，有一种方法可以在部署后捕捉到这个问题。当我们查看第7章中的日志和监控[Chapter
    7](bcd70598-81c4-4f0c-8319-bc078e854db5.xhtml)，*日志和* *监控*时，我们将看到我们如何将这些信息暴露出来，以帮助我们确保我们的生产系统正常运行。
- en: Behavioral Driven Development
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: '**Behavioral Driven Development** (**BDD**) and is a technique often executed
    by an application framework called **Cucumber**. It was developed by Dan North
    and was designed to create a common ground between developers and product owners.
    In theory, it should be possible to test complete coverage of the system with
    BDD; however, since this would create a significant number of slow running tests
    it is not the best approach. What we should be doing is defining the boundaries
    of our system, and we can save the granularity for our unit tests.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是一种通常由名为**Cucumber**的应用框架执行的技术。它是由丹·诺斯（Dan North）开发的，旨在在开发人员和产品所有者之间建立一个共同的基础。从理论上讲，应该可以使用BDD对系统的完整覆盖进行测试；然而，由于这将创建大量运行缓慢的测试，这不是最佳方法。我们应该做的是定义我们系统的边界，并且我们可以将粒度留给我们的单元测试。'
- en: In our Three Amigos group, we discuss the facets of the feature and what the
    essential qualities of it are and start to write scenarios.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“三个朋友”小组中，我们讨论特性的各个方面以及它的基本质量，并开始编写场景。
- en: '**Sad path**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**悲伤路径**'
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Happy path**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**快乐路径**'
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These scenarios are quite a simple example, but I think you can understand how,
    when using this language with non-technical people, it would be quite straightforward
    to come up with these descriptions. From an automation perspective what we then
    do is to write the steps which correspond to each of these `Given`, `When`, and
    `Then` statements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景是一个非常简单的例子，但我认为你可以理解，当与非技术人员使用这种语言时，提出这些描述将会非常直接。从自动化的角度来看，我们接下来要做的就是编写与每个`Given`、`When`和`Then`语句相对应的步骤。
- en: 'For this book, we are going to take a look at the GoDog framework which allows
    us to implement the step definitions in Go. We will first need to install the
    application you can do this by running the command: `fgo get github.com/DATA-DOG/godog/cmd/godog`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将探讨GoDog框架，它允许我们使用Go实现步骤定义。我们首先需要安装应用程序，你可以通过运行以下命令来完成：`fgo get github.com/DATA-DOG/godog/cmd/godog`
- en: If we look at `features/search.feature` we can see that we have implemented
    this feature and the scenarios.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`features/search.feature`，我们可以看到我们已经实现了这个功能和场景。
- en: 'If we run the `godog ./` command to run these tests without first creating
    the features, we should see the following error message:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建特性之前运行 `godog ./` 命令来运行这些测试，我们应该看到以下错误信息：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can implement step definitions for undefined steps with these snippets:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些片段为未定义的步骤实现步骤定义：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Usefully, this gives us the boilerplate to perform our steps; once we implement
    this and rerun the command we get a different message:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的是，这为我们执行步骤提供了模板；一旦我们实现这一点并重新运行命令，我们会得到不同的消息：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can now start filling in the details for the steps which should fail as we
    have not yet written our code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始填写那些应该失败的步骤的详细信息，因为我们还没有编写代码。
- en: 'We can implement our code using plain Go which gives us the capability to use
    any of the interfaces and packages. Take a look at the example which corresponds
    to the method `iCallTheSearchEndpoint`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用纯 Go 实现我们的代码，这使我们能够使用任何接口和包。看看与 `iCallTheSearchEndpoint` 方法对应的示例：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we have some tests implemented we should run Cucumber tests as some of the
    steps should be passing. To test the system, we need to start our main application;
    we could split our main function out into a `StartServer` function, which could
    be called directly from Cucumber. However, that is omitting the fact that we forgot
    to call `StartServer` in the main function. For this reason, the best approach
    is to test the complete application in our Cucumber test from the outside in.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实现了一些测试，我们应该运行 Cucumber 测试，因为一些步骤应该通过。为了测试系统，我们需要启动我们的主要应用程序；我们可以将主函数拆分出来成为一个
    `StartServer` 函数，这个函数可以直接从 Cucumber 中调用。然而，这忽略了我们在主函数中忘记调用 `StartServer` 的事实。因此，最好的方法是使用
    Cucumber 测试从外部测试整个应用程序。
- en: 'To do this, we are going to add a couple of new functions to the `features/search_test.go`
    file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将在 `features/search_test.go` 文件中添加几个新的函数：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In line **66**, we are using the `BeforeScenario` method on `godog`: this allows
    us to run a function before our scenario starts. We would use this for clearing
    up any data in the data store, but in our simple example, we are just going to
    start our application server. Later on in this chapter, we will look at a more
    complex example, which uses Docker Compose to start a stack of containers containing
    our server and a database.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 **66** 行，我们正在使用 `godog` 上的 `BeforeScenario` 方法：这允许我们在场景开始之前运行一个函数。我们会用这个来清理数据存储中的任何数据，但在我们的简单示例中，我们只是将要启动应用程序服务器。在本章的后面部分，我们将查看一个更复杂的示例，该示例使用
    Docker Compose 启动包含我们的服务器和数据库的容器堆栈。
- en: The `startServer` function spawns a new process to run `go run ../main.go`.
    We have to run this in `gofunc` as we do not want the test to block. Line **81**
    contains a small pause to see if our server has started. In reality, we should
    be checking the health endpoint of the API, but for now, this will suffice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`startServer` 函数会启动一个新的进程来运行 `go run ../main.go`。我们必须在 `gofunc` 中运行这个命令，因为我们不希望测试被阻塞。第
    **81** 行包含一个短暂的暂停，以查看我们的服务器是否已启动。实际上，我们应该检查 API 的健康端点，但现在这已经足够了。'
- en: Line **71** will execute after the scenario has finished and tears down our
    server. If we don't do this then the next time we try to start our server it will
    fail as the process will already be running and bound to the port.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 行 **71** 将在场景结束后执行并拆解我们的服务器。如果我们不这样做，那么下次我们尝试启动服务器时将会失败，因为进程已经运行并且绑定到了端口。
- en: 'Let''s go ahead and run our Cucumber tests, and the output should look something
    like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行我们的 Cucumber 测试，输出应该看起来像这样：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Perfect! We are getting there, some of the steps are passing now, and one of
    the features is passing. We can now go ahead finish these tests off, but first,
    we need to look at how we can use Docker Compose to test against a real database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们正在取得进展，一些步骤现在正在通过，其中一个特性正在通过。我们现在可以继续完成这些测试，但首先，我们需要看看我们如何使用 Docker Compose
    来测试真实数据库。
- en: Testing with Docker Compose
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 进行测试
- en: So far this has been relatively simple implementation, but it is not particularly
    useful as a real-world example. It is going to be pretty rare that you find yourself
    implementing an in-memory data store with only three items in it. More often than
    not you are going to be using a functioning database. Of course, the integration
    between a real database and our code needs testing; we need to ensure that the
    connection to the data store is correct and that the query we are sending to it
    is valid.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是一个相对简单的实现，但作为一个现实世界的例子，它并不特别有用。你找到自己只包含三个项目的内存数据存储的情况将会非常罕见。通常情况下，你将使用一个功能数据库。当然，真实数据库和我们的代码之间的集成需要测试；我们需要确保数据存储的连接是正确的，并且我们发送给它的查询是有效的。
- en: To do this, we need to spin up a real database and to do that we can use Docker-Compose
    as it is a fantastic way of starting our dependencies.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要启动一个真实数据库，而为了做到这一点，我们可以使用 Docker-Compose，因为它是一种启动依赖项的绝佳方式。
- en: 'In our sample file `docker-compose.yml`, we have the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例文件 `docker-compose.yml` 中，我们有以下内容：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we run `docker-compose up` command, we will download the image of MongoDB
    and start an instance exposing these ports on our local host.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `docker-compose up` 命令时，我们将下载 MongoDB 的镜像并启动一个实例，在本地主机上暴露这些端口。
- en: We now need to create a new struct in our project which is going to implement
    the store interface. We can then execute commands against the real database as
    opposed to using a mock or a simple in-memory store.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的项目中创建一个新的结构体，该结构体将实现存储接口。然后我们可以对真实数据库执行命令，而不是使用模拟或简单的内存存储。
- en: 'The implementation for `MongoStore` is quite straight forward. Looking at the
    file in `data/monogstore.go`, you will see that we have two additional methods
    not defined in our interface, namely:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`MongoStore` 的实现相当直接。查看 `data/monogstore.go` 文件，你会看到我们有两个未在接口中定义的额外方法，即：'
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These are here because we need them for the setup of our functional tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容在这里是因为我们需要它们来设置我们的功能测试。
- en: If we look at our file `features/search_test.go` you will see that we have added
    a couple of extra calls to the `FeatureContext` method in our setup.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的文件 `features/search_test.go`，你会看到我们在设置中添加了对 `FeatureContext` 方法的几个额外调用。
- en: 'The first thing we are doing is to call the `waitForDB` method: because we
    cannot control when our Mongo instance is going to be ready to accept connections,
    we need to wait for it before kicking off the tests. The process is that we will
    try to create an instance to our `MongoStore` using the convenience method `NewMongoStore`,
    internally this is doing the following work:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是调用 `waitForDB` 方法：因为我们无法控制我们的 Mongo 实例何时准备好接受连接，所以在启动测试之前我们需要等待它。这个过程是这样的：我们将尝试使用便利方法
    `NewMongoStore` 创建一个 `MongoStore` 实例，内部它执行以下工作：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Dial` method attempts to connect to the instance of MongoDB specified
    in the connection string. If this connection fails, then an error is returned.
    In our code, if we receive an error, we return this to the caller of `NewMongoStore`
    with a nil instance of our struct. The `waitForDB` method works by repeatedly
    attempting to create this connection until it no longer receives an error. To
    avoid spamming the database while it is trying to start, we sleep for one second
    after every failed attempt, to a maximum time of 10 seconds. This method will
    block the main Go routine, but this is by design as we do not want the tests to
    execute until we are sure we have this connection:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dial` 方法尝试连接到连接字符串中指定的 MongoDB 实例。如果连接失败，则返回错误。在我们的代码中，如果我们收到错误，我们将这个错误返回给
    `NewMongoStore` 的调用者，并返回我们结构体的 nil 实例。`waitForDB` 方法通过重复尝试创建此连接直到不再收到错误来工作。为了避免在数据库尝试启动时进行垃圾邮件发送，我们每次失败尝试后都会暂停一秒钟，最多暂停
    10 秒。这个方法将阻塞主 Go 线程，但这是由设计决定的，因为我们不希望在确保我们有了这个连接之前执行测试：'
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have also added some code to the `BeforeScenario` setup: the first thing
    we are going to do is wipe our database clearing down any previous test data.
    Clearing data is an incredibly important step as, should we have had any methods
    which mutate the data; we would not get predictable test results after each run.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `BeforeScenario` 设置中添加了一些代码：我们首先要做的是清除我们的数据库，删除任何之前的测试数据。清除数据是一个极其重要的步骤，因为如果我们有任何修改数据的函数，那么在每次运行后，我们不会得到可预测的测试结果。
- en: Finally, we insert the `setupData` method into our test data, and then we will
    proceed to execute the tests.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `setupData` 方法插入到测试数据中，然后我们将继续执行测试。
- en: We now have quite a few things to do before we can test our code, we need to
    run docker-compose, perform our tests and then stop docker-compose. An efficient
    way of scripting this process is to use Makefiles, Makefiles have been around
    forever and are still the primary software build mechanisms for many applications.
    They allow us to define commands in a simple text file which we can then run by
    executing **make [command]**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以测试我们的代码之前，我们有很多事情要做，我们需要运行docker-compose，执行我们的测试，然后停止docker-compose。一种高效地编写此过程的方法是使用Makefiles，Makefiles已经存在很长时间了，并且仍然是许多应用程序的主要软件构建机制。它们允许我们在简单的文本文件中定义命令，然后通过执行**make
    [command]**来运行这些命令。
- en: 'If we look at the Cucumber command in the Makefile in the example repository,
    we can see how we script the steps that need to be carried out to run our tests.
    We are starting our Mongo instance with `docker-compose`, running our Cucumber
    tests and then tearing the database down again:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看示例存储库中的Makefile中的Cucumber命令，我们可以看到我们如何编写执行测试所需的步骤。我们使用`docker-compose`启动Mongo实例，运行Cucumber测试，然后再次拆毁数据库：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you are wondering why we still need the `waitForDB` method when we are starting
    our database before running the tests, remember that Docker only knows when the
    primary process is executed. There can be a considerable lag between the commencement
    of the process and it being ready to accept connections. To run this we run `make
    cucumber` from the command line the result should be passing cucumber tests:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在运行测试之前启动数据库时，你可能想知道为什么我们还需要`waitForDB`方法，记住Docker只知道主进程何时执行。进程开始和准备好接受连接之间可能会有相当大的延迟。为了运行这个，我们从命令行运行`make
    cucumber`，结果应该是通过cucumber测试：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That is all for this section, we have learned that, with a few well-placed patterns,
    it is easy to write a robust test suite that will keep us safe and sound asleep
    instead of getting up in the middle of the night to diagnose a broken system.
    In the next section, we are going to look at some of the fantastic features of
    Go to ensure that our code is fast and optimized.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分就到这里了，我们了解到，通过一些放置得当的模式，编写一个健壮的测试套件很容易，这将让我们安心地睡个好觉，而不是半夜起床诊断一个损坏的系统。在下一节中，我们将探讨Go的一些出色功能，以确保我们的代码快速且优化。
- en: Benchmarking and profiling
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试和性能分析
- en: Go has two excellent ways to analyze the performance of your code. We have benchmark
    tests and the fantastic pprof.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Go有两种出色的方法来分析你的代码性能。我们有基准测试和出色的pprof。
- en: Benchmarks
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: Benchmarking is a way of measuring the performance of your code by executing
    it multiple times with a fixed workload. We took a look at this briefly in [Chapter
    1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml), *Introduction to Microservices*,
    where we ascertained that the `json.Marshal` method was slower than the `json.Encode`
    method. While this is a useful feature, I find it tough to work out what I should
    benchmark. If I am writing an algorithm, then this is relatively straightforward.
    However, when writing a microservice that is predominately interacting with a
    database, it is far more challenging.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试是通过多次以固定工作量执行代码来衡量代码性能的一种方法。我们在[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)中简要介绍了这种方法，*微服务简介*，我们确定`json.Marshal`方法比`json.Encode`方法慢。虽然这是一个有用的功能，但我发现很难确定我应该基准测试什么。如果我在编写算法，那么这相对简单。然而，当编写主要与数据库交互的微服务时，这要困难得多。
- en: 'To demonstrate how easy it is to execute benchmarks in Go, take a look at `chandlers/search_bench_test.go`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示在Go中执行基准测试是多么容易，请查看`chandlers/search_bench_test.go`：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The most important part of this code is hidden away at line **21**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码最重要的部分隐藏在第**21**行：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When running a benchmark, Go needs to run it multiple times to get an accurate
    reason. The number of times that the benchmark will run is the field `N` on the
    benchmark's struct. Before setting this number, Go will execute a few iterations
    of your code to get an approximate measurement of the execution time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行基准测试时，Go需要多次运行以获得准确的结果。基准测试将运行的次数是基准结构体上的字段`N`。在设置这个数字之前，Go将执行你的代码的一些迭代以获得执行时间的近似测量。
- en: 'We would execute our benchmark using the `go test-bench -benchmem` command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`go test-bench -benchmem`命令执行基准测试：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we are passing an additional flag to see the memory allocations for each
    execution. We know that our handler when running with the mock takes 43,183 nanoseconds
    or 0.043183 milliseconds to execute and performs 68 memory allocations. It'd be
    good if the code would run this fast when running in real life, but we might have
    to wait a few years before we see this level of speed from an API connected to
    a database.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递一个额外的标志来查看每次执行的内存分配情况。我们知道，当使用模拟运行时，我们的处理程序执行需要43,183纳秒或0.043183毫秒，并执行了68次内存分配。如果代码在实际运行中也能这么快，那就太好了，但我们可能需要等待几年才能看到与数据库连接的API达到这种速度级别。
- en: 'One of the other nice features of benchmark tests is that we can run them and
    it outputs profiles which can be used with pprof:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的另一个优点是，我们可以运行它们，并输出配置文件，这些配置文件可以与pprof一起使用：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The output of this command will give us more information about where this time
    and memory is being consumed and can help us to optimize our code correctly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出将给我们更多关于时间和内存消耗位置的信息，并有助于我们正确优化代码。
- en: Profiling
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: When we wish to take a look at the speed of our program, the best technique
    we can employ is profiling. Profiling automatically samples your running application
    while it is executing; and then we can compute that data, such as the running
    time of a particular function, into a statistical summary called a profile.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想查看我们程序的速度时，我们可以采用的最佳技术是分析。分析在应用程序执行时自动采样运行中的应用程序；然后我们可以将数据，如特定函数的运行时间，计算到称为配置文件的统计摘要中。
- en: 'Go supports three different types of profiling:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持三种不同类型的分析：
- en: '**CPU**: Identifies the tasks which require the most CPU time'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：标识需要最多CPU时间的任务'
- en: '**Heap**: Identifies the statements responsible for allocating the most memory'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heap**：标识负责分配最多内存的语句'
- en: '**Blocking**: Identifies the operations responsible for blocking Go routines
    for the longest time'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blocking**：标识负责最长时间阻塞Go例程的操作'
- en: 'If we would like to enable profiling on our application, we can do one of two
    things:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在我们的应用程序中启用分析，我们可以做两件事之一：
- en: Add `import "net/http/pprof"` to your startup file
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动文件中添加`import "net/http/pprof"`
- en: Manually start profiling
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动启动分析
- en: 'The first option is the most straightforward. You only add it to the beginning
    of your main Go file and, if you are not already running an HTTP web server, start
    one:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是最直接的。您只需将其添加到主Go文件的开头，如果您还没有运行HTTP网络服务器，就启动一个：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method then exposes various paths on your HTTP server at `/debug/pprof/`
    which can then be accessed via a URL. The side effect of this, however, is that
    when this import statement is in your go file, then you will be profiling, which
    not only could slow down your application, but you also don't want to expose this
    information for public consumption.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法随后在您的HTTP服务器上的`/debug/pprof/`路径下公开各种路径，然后可以通过URL访问。然而，这种做法的副作用是，当这个导入语句在您的go文件中时，您将进行性能分析，这不仅可能会减慢您的应用程序，而且您也不希望公开这些信息供公众消费。
- en: 'Another method of profiling is to start the profiler when you start your application
    by passing some additional command line flags:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分析方法是，在启动应用程序时通过传递一些额外的命令行标志来启动分析器：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On line **26**, we are checking whether we have specified an output file for
    CPU profiling, and if so, we are creating the file and then starting the profiler
    with `pprof.StartCPUProfile(f)`, and passing it a reference to the file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**26**行，我们检查是否指定了用于CPU分析的输出文件，如果是，我们就创建文件，然后使用`pprof.StartCPUProfile(f)`启动分析器，并传递文件引用：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `StartCPUProfile` function enables the CPU profiling for the current process
    and buffers the output to `w`. While running, the CPU profiler will stop your
    application roughly 100 times per second and record the data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartCPUProfile`函数为当前进程启用CPU分析，并将输出缓冲到`w`。在运行时，CPU分析器大约每秒停止应用程序100次并记录数据。'
- en: 'To profile heap allocations, we use a slightly different command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析堆分配，我们使用一个稍微不同的命令：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Lookup()` function returns the profile with the given name, or if no such
    profile exists, the predefined profiles available are:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lookup()`函数返回具有给定名称的配置文件，如果没有这样的配置文件，则可用的预定义配置文件是：'
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`WriteTo` outputs the profile to the given write in the pprof format. If we
    set the debug flag to `1`, then `WriteTo` will add comments to function names
    and line numbers instead of just hexadecimal addresses that pprof uses. These
    comments are so you can read the file without needing any special tooling.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteTo` 将配置文件输出到指定的写入位置，以 pprof 格式。如果我们设置调试标志为 `1`，那么 `WriteTo` 将在函数名称和行号上添加注释，而不是像
    pprof 使用的仅十六进制地址。这些注释是为了让你能够阅读文件而无需任何特殊工具。'
- en: If you look at the example code in the folder `benchmark`, you will find an
    example profile and the binary from which it was generated.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `benchmark` 文件夹中的示例代码，你会找到一个示例配置文件以及生成它的二进制文件。
- en: 'We can now run the pprof tool to examine what is going on. To do this, we need
    to run the tool on the command line and provide a reference to the binary that
    the profile was executed against, and also the profile:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行 pprof 工具来检查发生了什么。为此，我们需要在命令行上运行工具，并提供一个指向执行配置文件的二进制文件的引用，以及配置文件本身：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The simplest command we can run is `top`. Top will show us the functions which
    consumed the most CPU during the execution of our application:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行的 simplest 命令是 `top`。Top 将显示在我们的应用程序执行期间消耗了最多 CPU 的函数：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The main offender in this instance is `syscall.Syscall`. If we look this up
    in the documentation, we find that package syscall contains an interface to the
    low-level operating system primitives.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，主要的违规者是 `syscall.Syscall`。如果我们查阅文档，我们会发现 syscall 包包含对低级操作系统原语的接口。
- en: 'On its own this output is not particularly useful, so let''s generate a call
    graph which will show us more detail. We can do this again from the pprof tool.
    However, we do need to install Graphviz first. If you are using macOS then you
    can install this with brew:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这个输出并不特别有用，所以让我们生成一个调用图，它将显示更多细节。我们可以再次使用 pprof 工具来做这件事。然而，我们首先需要安装 Graphviz。如果你使用
    macOS，可以使用 brew 来安装：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you are using a Linux based system and have the apt package manager, you
    can use that:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用基于 Linux 的系统并且有 apt 软件包管理器，你可以使用它：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output for this looks like this `benchmark/cpu.png`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '这个输出的样子看起来是这样的 `benchmark/cpu.png`:'
- en: '![](img/621e4bd5-e5a2-4e16-aadf-0fc8dc90d0e0.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/621e4bd5-e5a2-4e16-aadf-0fc8dc90d0e0.png)'
- en: That is quite something! However, we can see that `syscall.Syscall` is in the
    largest font as it is responsible for consuming the most CPU. If we start here
    at the bottom and start tracing backward, we can see that the root of this seems
    to be our data store's search function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当令人印象深刻！然而，我们可以看到 `syscall.Syscall` 以最大的字体显示，因为它消耗了最多的 CPU。如果我们从这里开始，从底部开始回溯，我们可以看到这个问题的根源似乎是我们数据存储的搜索函数。
- en: 'To get a closer look at exactly where this is happening, we can use the list
    command and then pass the name of an object or method we would like to investigate
    further:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地查看这是在哪里发生的，我们可以使用 list 命令，然后传递我们想要进一步调查的对象或方法的名称：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When we do this with the search method, we can see that a huge percentage of
    our CPU cycles were spent executing queries to MongoDB. If we look at the other
    route from `syscall.Syscall`, it shows that another large consumer is the `http.ResponseWriter`
    interface.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用搜索方法做这件事时，我们可以看到我们的大部分 CPU 周期都花在了执行对 MongoDB 的查询上。如果我们查看来自 `syscall.Syscall`
    的其他路由，它显示另一个大消费者是 `http.ResponseWriter` 接口。
- en: This output all makes sense as we are not doing anything too clever in our API;
    it just retrieves some data from a database. The nice thing about pprof is that
    we can use the same commands to query the heap usage.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出都是有意义的，因为我们没有在我们的 API 中做任何特别聪明的事情；它只是从数据库中检索一些数据。pprof 的好处是我们可以使用相同的命令来查询堆的使用情况。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned some best practice approaches to testing microservices
    in Go. We have looked at the testing package, including some special features
    for dealing with requests and responses. We have also looked at writing integration
    tests with Cucumber.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了一些在 Go 中测试微服务的最佳实践方法。我们查看测试包，包括一些处理请求和响应的特殊功能。我们还探讨了使用 Cucumber 编写集成测试。
- en: Ensuring that your code works without fault, however, is only part of the job,
    we also need to make sure that our code is performant, and Go has some excellent
    tools for managing this too.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确保你的代码无故障运行只是工作的一部分，我们还需要确保我们的代码性能良好，Go 也提供了一些出色的工具来管理这一点。
- en: 'I would always recommend that you test your code and that you do this religiously.
    As for performance optimization, this is open for debate, no doubt you have heard
    comments that premature optimization is the root of all evil. However, this quote
    from Donald Knuth is much-misunderstood: he did not mean that you should never
    optimize until you have a problem; he said that you should only optimize what
    matters. With pprof, we have an easy way to figure out what, if anything, actually
    matters. Include the practice of profiling into your development routine, and
    you will have faster and more efficient applications, profiling is also an excellent
    technique to understand your application better when you are trying to track down
    that tricky bug.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是会建议你测试你的代码，并且要虔诚地这样做。至于性能优化，这无疑是一个值得讨论的话题，你无疑已经听到过这样的评论：过早的优化是万恶之源。然而，唐纳德·克努特（Donald
    Knuth）的这句话被误解了很多：他并不是说在你遇到问题之前永远不要优化；他说的是你应该只优化那些真正重要的东西。有了pprof，我们有一个简单的方法来确定什么，如果有的话，实际上才是重要的。将性能分析实践纳入你的开发流程，你将拥有更快、更高效的应用程序，性能分析也是当你试图追踪那些棘手的错误时，更好地理解你的应用程序的绝佳技术。
- en: '"Programmers waste enormous amounts of time thinking about, or worrying about,
    the speed of noncritical parts of their programs, and these attempts at efficiency
    have a strong negative impact when debugging and maintenance are considered. We
    should forget about small efficiencies, say about 97% of the time: premature optimization
    is the root of all evil. Yet we should not pass up our opportunities in that critical
    3%."'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: “程序员们浪费了大量的时间在思考或担心他们程序中非关键部分的运行速度上，当考虑到调试和维护时，这些对效率的追求有着强烈的负面影响。我们应该忘记那些小的效率，比如说97%的时间：过早的优化是万恶之源。然而，我们不应该错过那关键的3%的机会。”
- en: '- Donald Knuth'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: —— 唐纳德·克努特
