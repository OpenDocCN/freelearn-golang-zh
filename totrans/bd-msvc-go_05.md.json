["```go\n{ \n  \"id\": \"ABCDERE2342323SDSD\", \n  \"queue\" \"registration.welcome_email\", \n  \"dispatch_date\": \"2016-03-04 T12:23:12:232\", \n  \"payload\": { \n    \"name\": \"Nic Jackson\", \n    \"email\": \"mail@nicholasjackson.io\" \n  } \n} \n\n```", "```go\n{ \n \"id\": \"ABCDERE2342323SDSD\", \n \"queue\" \"registration.welcome_email\", \n \"dispatch_date\": \"2016-03-04 T12:23:12:232\", \n \"payload\": { \n \"name\": \"Nic Jackson\", \n \"email\": \"mail@nicholasjackson.io\" \n }, \n \"error\": [{\n   \"status_code\": 3343234,\n   \"message\": \"Message rejected from mail API, quota exceeded\",\n   \"stack_trace\": \"mail_handler.go line 32 ...\",\n   \"date\": \"2016-03-04 T12:24:01:132\"\n }]\n} \n\n```", "```go\n 24 func makeTimeoutRequest() { \n 25   dl := deadline.New(1 * time.Second) \n 26   err := dl.Run(func(stopper <-chan struct{}) error { \n 27     slowFunction() \n 28     return nil \n 29   }) \n 30 \n 31   switch err { \n 32   case deadline.ErrTimedOut: \n 33     fmt.Println(\"Timeout\") \n 34   default: \n 35     fmt.Println(err) \n 36   } \n 37 } \n\n```", "```go\nfunc New(backoff []time.Duration, class Classifier) *Retrier \n\n```", "```go\nfunc ConstantBackoff(n int, amount time.Duration) []time.Duration \n\n```", "```go\nfunc ExponentialBackoff(n int, initialAmount time.Duration) []time.Duration \n\n```", "```go\ntype DefaultClassifier struct{} \n\n```", "```go\ntype BlacklistClassifier []error \n\n```", "```go\ntype WhitelistClassifier []error \n\n```", "```go\nfunc New(errorThreshold, successThreshold int, timeout time.Duration) *Breaker \n\n```", "```go\n 11   b := breaker.New(3, 1, 5*time.Second) \n 12 \n 13   for { \n 14     result := b.Run(func() error { \n 15       // Call some service \n 16       time.Sleep(2 * time.Second) \n 17       return fmt.Errorf(\"Timeout\") \n 18     }) \n 19 \n 20     switch result { \n 21     case nil: \n 22       // success! \n 23     case breaker.ErrBreakerOpen: \n 24       // our function wasn't run because the breaker was open \n 25       fmt.Println(\"Breaker open\") \n 26     default: \n 27       fmt.Println(result) \n 28     } \n 29 \n 30     time.Sleep(500 * time.Millisecond) \n 31   } \n\n```", "```go\nTimeout\nTimeout\nTimeout\nBreaker open\nBreaker open\nBreaker open\n...\nBreaker open\nBreaker open\nTimeout\nBreaker open\nBreaker open  \n\n```", "```go\n18 func main() {\n19   ma = ewma.NewMovingAverage()\n20\n21   http.HandleFunc(\"/\", mainHandler)\n22   http.HandleFunc(\"/health\", healthHandler)\n23\n24   http.ListenAndServe(\":8080\", nil)\n25 }\n\n```", "```go\n 27 func mainHandler(rw http.ResponseWriter, r *http.Request) {\n 28   startTime := time.Now()\n 29\n 30   if !isHealthy() {\n 31     respondServiceUnhealthy(rw)\n 32     return\n 33   }\n 34\n 35   rw.WriteHeader(http.StatusOK)\n 36   fmt.Fprintf(rw, \"Average request time: %f (ms)\\n\", ma.Value()/1000000)\n 37\n 38   duration := time.Now().Sub(startTime)\n 39   ma.Add(float64(duration))\n 40 }\n\n```", "```go\n55 func respondServiceUnhealthy(rw http.ResponseWriter) {\n56   rw.WriteHeader(http.StatusServiceUnavailable)\n57\n58   resetMutex.RLock()\n59   defer resetMutex.RUnlock()\n60\n61   if !resetting {\n62     go sleepAndResetAverage()\n63   }\n64 }\n\n```", "```go\n63 func sleepAndResetAverage() {\n64   resetMutex.Lock()\n65   resetting = true\n66   resetMutex.Unlock()\n67\n68   time.Sleep(timeout)\n69   ma = ewma.NewMovingAverage()\n70\n71   resetMutex.Lock()\n72   resetting = false\n73   resetMutex.Unlock()\n74 }\n\n```", "```go\n  9 type LimitHandler struct { \n 10   connections chan struct{} \n 11   handler     http.Handler \n 12 } \n\n```", "```go\n16 func NewLimitHandler(connections int, next http.Handler) \n   *LimitHandler { \n17   cons := make(chan struct{}, connections) \n18   for i := 0; i < connections; i++ { \n19     cons <- struct{}{} \n20   } \n21 \n22   return &LimitHandler{ \n23     connections: cons, \n24     handler:     next, \n25   } \n26 } \n\n```", "```go\n28 func (l *LimitHandler) ServeHTTP(rw http.ResponseWriter, r \n   *http.Request) { \n29   select { \n30   case <-l.connections: \n31     l.handler.ServeHTTP(rw, r) \n32     l.connections <- struct{}{} // release the lock \n32   default: \n33     http.Error(rw, \"Busy\", http.StatusTooManyRequests) \n34   } \n35 } \n\n```", "```go\n 14 func newTestHandler(ctx context.Context) http.Handler { \n 15   return http.HandlerFunc(func(rw http.ResponseWriter, r \n      *http.Request) { \n 16     rw.WriteHeader(http.StatusOK) \n 17     <-r.Context().Done() \n 18   }) \n 19 } \n\n 84 func TestReturnsBusyWhenConnectionsExhausted(t *testing.T) { \n 85   ctx, cancel := context.WithCancel(context.Background()) \n 86   ctx2, cancel2 := context.WithCancel(context.Background()) \n 87   handler := NewLimitHandler(1, newTestHandler(ctx)) \n 88   rw, r := setup(ctx) \n 89   rw2, r2 := setup(ctx2) \n 90 \n 91   time.AfterFunc(10*time.Millisecond, func() { \n 92     cancel() \n 93     cancel2() \n 94   }) \n 95 \n 96   waitGroup := sync.WaitGroup{} \n 97   waitGroup.Add(2) \n 98 \n 99   go func() { \n100     handler.ServeHTTP(rw, r) \n101     waitGroup.Done() \n102   }() \n103 \n104   go func() { \n105     handler.ServeHTTP(rw2, r2) \n106     waitGroup.Done() \n107   }() \n108 \n109   waitGroup.Wait() \n110 \n111   if rw.Code == http.StatusOK && rw2.Code == http.StatusOK { \n112     t.Fatalf(\"One request should have been busy, request 1: %v, \n        request 2: %v\", rw.Code, rw2.Code) \n113   } \n114 } \n\n```", "```go\nPASS \ncoverage: 100.0% of statements \nok      github.com/nicholasjackson/building-microservices-in-go/chapter5/health 0.033s  \n\n```", "```go\nfunc NewLoadBalancer(strategy Strategy, endpoints []url.URL) *LoadBalancer \n\n```", "```go\n 10 // Strategy is an interface to be implemented by loadbalancing \n 11 // strategies like round robin or random. \n 12 type Strategy interface { \n 13   NextEndpoint() url.URL \n 14   SetEndpoints([]url.URL) \n 15 } \n\nNextEndpoint() url.URL \n\n```", "```go\nSetEndpoints([]url.URL) \n\n```", "```go\n 56 func main() { \n 57   endpoints := []url.URL{ \n 58     url.URL{Host: \"www.google.com\"}, \n 59     url.URL{Host: \"www.google.co.uk\"}, \n 60   } \n 61 \n 62   lb := NewLoadBalancer(&RandomStrategy{}, endpoints) \n 63 \n 64   fmt.Println(lb.GetEndpoint()) \n 65 } \n\n```"]