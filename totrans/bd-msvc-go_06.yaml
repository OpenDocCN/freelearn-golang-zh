- en: Microservice Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务框架
- en: In this chapter, we are going to look at some of the most popular frameworks
    for building microservices and look at an example project to see the implementation.
    We will examine both RESTful and RPC based microservices and, to throw a curve
    ball in, we are also going to look at a commercial framework which provides much
    of the glue needed when building a highly distributed system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些构建微服务的最流行框架，并查看一个示例项目以了解其实施情况。我们将检查基于RESTful和RPC的微服务，并且为了增加一些变化，我们还将查看一个提供构建高度分布式系统所需大部分粘合剂的商业框架。
- en: The source code to accompany this chapter can be found at [https://github.com/building-microservices-with-go/chapter6](https://github.com/building-microservices-with-go/chapter6)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随本章的源代码可以在[https://github.com/building-microservices-with-go/chapter6](https://github.com/building-microservices-with-go/chapter6)找到
- en: What makes a good microservice framework?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么构成了一个好的微服务框架？
- en: 'What makes a microservice framework is an incredibly good question and one
    which is open to a lot of opinions. In an attempt to remove the subjectivity,
    we will break down the features of a good framework and try to allocate a score
    for each of these functions in a consistent way. The following diagram is a hierarchical
    mind map of the features which I deem necessary. When you are assessing the framework
    which is the best for you and your project, you can use this framework, adding
    or removing any of the attributes which may be relevant:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 什么构成了一个微服务框架是一个非常好且具有许多不同观点的问题。为了减少主观性，我们将分解优秀框架的特性，并尝试以一致的方式为这些功能中的每一个分配一个分数。以下图表是我认为必要的特性的层级思维导图。当你评估最适合你和你项目的框架时，可以使用这个框架，添加或删除可能相关的任何属性：
- en: '![](img/e168c43e-07e3-42d4-abcd-8e6b49abfe59.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e168c43e-07e3-42d4-abcd-8e6b49abfe59.png)'
- en: 'Here are some of the features you need to keep in mind while choosing a good
    framework:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择一个好的框架时，以下是一些需要考虑的功能：
- en: '**Ability to interface with other frameworks**: It must be possible to interact
    with any service built with the framework by clients who are not built using the
    same framework.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他框架的接口能力**：必须能够通过未使用相同框架构建的客户端与使用该框架构建的任何服务进行交互。'
- en: '**Implement standards**: A standard message protocol should be used to maximize
    interaction, for example:'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施标准**：应使用标准消息协议以最大化交互，例如：'
- en: JSON-RPC
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-RPC
- en: Thrift
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thrift
- en: Protocol Buffers
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protocol Buffers
- en: JSON
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: '**Open**: The framework should be open in both the source code and the roadmap.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放性**：框架在源代码和路线图上都应该保持开放。'
- en: '**Patterns:** The framework must implement the standard patterns of microservice
    architecture:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**：框架必须实现微服务架构的标准模式：'
- en: '**Circuit breaking**: Client calls to downstream services must implement circuit
    breaking.'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：对下游服务的客户端调用必须实现断路器。'
- en: '**Service discovery**: It must be capable of registering with a dynamic service
    registry and capable of querying the same registry to locate connected services'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：必须能够向动态服务注册表注册，并且能够查询同一注册表以定位连接的服务'
- en: '**Proprietary**: Proprietary service registries must be open and usable from
    other clients who do not implement the framework or its SDKs.'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专有**：专有服务注册表必须对未实现框架或其SDK的其他客户端开放和可用。'
- en: '**Timeouts**: Downstream client calls should be configurable with a user determined
    timeout.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时设置**：下游客户端调用应可配置用户定义的超时时间。'
- en: '**Health checks**: The framework must create an automatic health check endpoint.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康检查**：框架必须创建一个自动的健康检查端点。'
- en: '**Routing**: The framework must support multiple routes with an easy to use
    pattern based matching.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：框架必须支持易于使用的基于模式的多个路由。'
- en: '**Middleware**: The framework must support middleware to allow the user to
    create shared code for handlers.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**：框架必须支持中间件，以便用户为处理器创建共享代码。'
- en: '**Load balancing**: Downstream client connections should be capable of load
    balancing.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：下游客户端连接应能够进行负载均衡。'
- en: '**Language independence**: The framework needs to be language independent to
    enable cross-team polyglot workflow. At a minimum, it should be possible to create
    client SDKs in multiple languages.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言无关性**：框架需要是语言无关的，以实现跨团队的多语言工作流程。至少，应该能够在多种语言中创建客户端SDK。'
- en: '**Communication Protocols:** The service should support good standards in one
    of the following communication protocols:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信协议**：服务应支持以下通信协议中的良好标准：'
- en: '**REST:** If the framework implements REST, it must take full advantage of
    semantic API design with appropriate use of HTTP verbs and status codes.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST**：如果框架实现REST，它必须充分利用语义API设计，并适当使用HTTP动词和状态码。'
- en: '**RPC:** If the framework is RPC-based, it must use a standard and open messaging
    protocol.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPC**：如果框架基于RPC，它必须使用标准且开放的消息协议。'
- en: '**Maintainable:** The framework must be maintainable with the minimum effort:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：框架必须以最小的努力进行维护：'
- en: '**Easy to update**: It must be easy to update with the minimum amount of code
    changes.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于更新**：它必须易于更新，代码更改量最小。'
- en: '**Well versioned**: The framework must be well versioned with breaking changes
    to the API mainly restricted to major version updates.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**良好版本控制**：框架必须具有良好的版本控制，API的主要破坏性更改主要限于主要版本更新。'
- en: '**Tooling**: There must be adequate tooling to fit with modern development
    practices:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具**：必须有足够的工具来适应现代开发实践：'
- en: '**CI/CD**: It must integrate and work well with continuous integration and
    continuous deployment pipelines; the tooling must be scriptable.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD**：它必须与持续集成和持续部署管道集成并良好工作；工具必须是可脚本化的。'
- en: '**Cross-platform**: The tools must work cross-platform, with OSX, and Linux
    as a bare minimum.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：工具必须跨平台工作，至少包括OSX和Linux。'
- en: '**Code generation**: It should support code generation templates to scaffold
    a service and possibly extend the service.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成**：它应该支持代码生成模板，以构建服务，并可能扩展服务。'
- en: '**Fast set up**: The framework should be fast to set up and with the minimum
    number of steps and dependencies.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速设置**：框架应该快速设置，步骤和依赖项最少。'
- en: '**Ease of use**: Any good framework should be easy to use; you will not thank
    yourself for choosing a framework which is a pain to work with. This category
    has been broken down into the following subcategories:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：任何好的框架都应该易于使用；你不会为选择了一个难以工作的框架而感到高兴。这个类别已经被分解为以下子类别：'
- en: '**Extensible**: When required, the user should be able to extend the framework
    through:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：当需要时，用户应该能够通过以下方式扩展框架：'
- en: '**Plugins**: A pluggable software architecture to be able to create generators
    and templates.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：一个可插拔的软件架构，以便能够创建生成器和模板。'
- en: '**Middleware**: Extension through handler middleware.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**：通过处理中间件进行扩展。'
- en: '**Support**: A good support network is incredibly important throughout the
    life cycle of the service.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：在整个服务生命周期中，一个良好的支持网络至关重要。'
- en: '**Maintained**: The framework must be well maintained with:'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护**：框架必须得到良好的维护，包括：'
- en: '**Regular updates**: The framework is regularly updated and released.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期更新**：框架定期更新和发布。'
- en: '**Accepts pull requests**: The author accepts pull requests from community
    contributors.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受拉取请求**：作者接受来自社区贡献者的拉取请求。'
- en: '**Corporate sponsor**: While this option is not essential, a corporate sponsor
    can extend the life cycle of a framework as there is less likelihood of a leftpad
    situation. ([http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)).'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业赞助商**：虽然这个选项不是必需的，但企业赞助商可以延长框架的生命周期，因为出现leftpad情况的可能性较小。（[http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)）'
- en: '**Documentation**: The framework should be well documented with clear and concise
    examples and comprehensive API documentation.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：框架应该有良好的文档，包括清晰简洁的示例和全面的API文档。'
- en: '**Easy to follow**: Documentation should be accessible and easy to read.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**：文档应该是可访问的，并且易于阅读。'
- en: '**Code samples**: Adequate code examples should be provided to support a developer
    using the framework.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码示例**：应提供足够的代码示例以支持使用框架的开发者。'
- en: '**Tutorials**: The framework will ideally have community contributed tutorials
    in both blog and video formats.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教程**：框架理想情况下应该有社区贡献的教程，包括博客和视频格式。'
- en: '**Community**: There should be a healthy community using and supporting the
    framework with at least one of the following channels of communication:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区**：应该有一个健康的社区在使用和支持框架，至少有一个以下沟通渠道：'
- en: Slack
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slack
- en: Gitter
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gitter
- en: Github
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Github
- en: Mailing list
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件列表
- en: Stack Overflow
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stack Overflow
- en: '**Secure**: The framework should be secure and implement the latest industry
    standards:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：框架应该是安全的，并实施最新的行业标准：'
- en: '**TLS**: Securing the endpoints of the framework using TLS should be possible.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS**：使用TLS保护框架的端点应该是可能的。'
- en: '**OWASP**: The framework should implement OWASP advisory.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OWASP**：框架应该实施OWASP咨询。'
- en: '**Validation**: Requests should be automatically validated based on rules implemented
    by message annotation.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：请求应根据消息注解中实现的规则自动验证。'
- en: '**Well patched**: Security vulnerabilities should be regularly assessed and
    patched.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修补良好**：应定期评估和修补安全漏洞。'
- en: '**Authentication / Authorization**: The framework should implement a method
    of authentication and authorization such as the OAuth standard.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证/授权**：框架应实现认证和授权的方法，例如OAuth标准。'
- en: '**Open source**: The framework should be open sourced and released under a
    license which allows forking and modification:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：框架应该是开源的，并发布在允许分叉和修改的许可证下：'
- en: '**Community**: There should be a good open source community following and contribution
    for the project.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区**：应该有一个良好的开源社区关注和为项目做出贡献。'
- en: '**Popular**: The framework should be popular and commercially used.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流行**：框架应该是流行的，并且商业上被使用。'
- en: '**Quality**: The code quality of the framework should be visible and of a high
    standard. Community contributions should follow a published process and standard.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：框架的代码质量应该是可见的，并且达到高标准。社区贡献应遵循已发布的流程和标准。'
- en: '**High test coverage**: Test coverage should be high and monitored; pull requests
    should ensure adherence to coding standards.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高测试覆盖率**：测试覆盖率应该高，并受到监控；拉取请求应确保遵守编码标准。'
- en: '**Unit tests**: High fast running unit tests are essential.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：快速运行的单元测试是必不可少的。'
- en: '**Behavioral/functional**: Ideally, the framework should implement behavioral
    and functional tests regarding the generated code and the build process:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为/功能**：理想情况下，框架应实现关于生成代码和构建过程的行为和功能测试：'
- en: '**Automated builds**: Automated builds of the source code should be present
    and visible. Pull requests should run an automated build, and the state reported
    on the request.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化构建**：应存在并可见的源代码自动化构建。拉取请求应运行自动化构建，并在请求上报告状态。'
- en: '**Code quality**: Automated code quality tools should be used and the results
    visible, for example:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码质量**：应使用自动化的代码质量工具，并且结果应该是可见的，例如：'
- en: Coveralls ([https://coveralls.io/](https://coveralls.io/))
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coveralls ([https://coveralls.io/](https://coveralls.io/))
- en: Code Climate ([https://codeclimate.com/](https://codeclimate.com/))
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Code Climate ([https://codeclimate.com/](https://codeclimate.com/))
- en: Sonar ([https://www.sonarqube.org/](https://www.sonarqube.org/))
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sonar ([https://www.sonarqube.org/](https://www.sonarqube.org/))
- en: '**Standard language patterns**: A standard method of writing the code taking
    account of the language level idioms is essential.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准语言模式**：考虑语言级别的惯用法的编写代码的标准方法是必不可少的。'
- en: '**Efficient**: The framework must produce code which is efficient when run.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效**：框架必须生成在运行时高效的代码。'
- en: '**Fast**: The code must execute quickly and be designed for performance.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：代码必须快速执行，并且设计用于性能。'
- en: '**Low latency**: Requests should be low latency.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低延迟**：请求应具有低延迟。'
- en: '**Low memory**: The service should be memory efficient.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存低**：服务应该内存效率高。'
- en: '**Supports a large number of connections**: It should support a significant
    number of concurrent connections.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持大量连接**：它应该支持大量的并发连接。'
- en: It's hard to compare the various frameworks on a like-for-like basis as each
    framework provides a different set of features and all of these features will
    affect the performance. I think it is useful, however, to try and run some performance
    tests against each of the frameworks. To do this, we will be running our example
    service in Docker on a small Digital Ocean host with two CPU cores and 2 GB of
    RAM. We will then use another server of the same size to execute the benchmarking
    application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的基础上比较各种框架很难，因为每个框架都提供了一套不同的功能，所有这些功能都会影响性能。然而，我认为尝试对每个框架运行一些性能测试是有用的。为此，我们将在具有两个CPU核心和2GB
    RAM的小型Digital Ocean主机上运行我们的示例服务。然后，我们将使用相同大小的另一台服务器来执行基准测试应用程序。
- en: Our strategy is to run a 5-minute test with 400 connections and a 5-second timeout.
    The connections will be ramped up over a 90-second interval.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略是运行一个5分钟的测试，有400个连接和5秒的超时。连接将在90秒的间隔内逐步增加。
- en: The process is not a scientific test, but it will give us an indication of the
    response time and to identify if the server can cope with a reasonable number
    of concurrent connections.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程不是一个科学测试，但它将给我们提供响应时间的指示，并确定服务器能否处理合理的并发连接数量。
- en: As a benchmark, I have created a vanilla HTTP server using JSON as a message
    protocol. The results can be seen for this service are outlined in following the
    sections and compared to other frameworks to form a base line efficiency.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基准测试，我创建了一个使用 JSON 作为消息协议的纯 HTTP 服务器。该服务的结果将在以下章节中概述，并与其他框架进行比较，以形成基准效率。
- en: It should be noted, however, that some frameworks have advanced capabilities
    such as request validation, circuit breaking out of the box. The number of these
    features present will influence the latency of the service, so it will not be
    possible to do a true like for like comparison.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，一些框架具有一些高级功能，如开箱即用的请求验证、断路器。这些功能的存在数量将影响服务的延迟，因此不可能进行真正的类似比较。
- en: '**Results:**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果：**'
- en: '| Threads | 400 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 线程数 | 400 |'
- en: '| Total Requests: | 1546084 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 总请求数： | 1546084 |'
- en: '| Avg. Request Time | 51.50ms |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 平均请求时间 | 51.50ms |'
- en: '| Total Success | 1546049 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 总成功数 | 1546049 |'
- en: '| Total Timeouts | 35 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 总超时数 | 35 |'
- en: '| Total Failures | 35 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 总失败数 | 35 |'
- en: '**Requests over time:**![](img/860ca5ff-2248-4be8-bc69-105a99a80c3d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**随时间变化的请求：**![](img/860ca5ff-2248-4be8-bc69-105a99a80c3d.png)'
- en: Micro
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Micro
- en: 'The first framework we are going to look at is Micro by Asim Aslam. It has
    been under active development over the last couple of years and has production
    credentials with its use at the car rental firm, Sixt. Micro is a pluggable RPC
    microservices framework supporting service discovery, load-balancing, synchronous
    and asynchronous communication and multiple message encoding formats. For a more
    in-depth overview of Micro''s features and to check out the source code it is
    hosted on GitHub at the following location: [https://github.com/micro/go-micro](https://github.com/micro/go-micro)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个框架是由 Asim Aslam 开发的 Micro。在过去几年中，它一直在积极开发，并在汽车租赁公司 Sixt 的实际使用中获得了生产资质。Micro
    是一个可插拔的 RPC 微服务框架，支持服务发现、负载均衡、同步和异步通信以及多种消息编码格式。要深入了解 Micro 的功能和查看其源代码，请访问 GitHub
    上的以下位置：[https://github.com/micro/go-micro](https://github.com/micro/go-micro)
- en: Setup
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: Installation for Micro is easy; well, it is Go so it would be. You do need to
    install `protoc`, the application for generating source code which is part of
    Google's `Protocol Buffers` package. As a messaging protocol, `protobufs` are
    taking off big time and you will find this messaging protocol used in quite a
    few frameworks we are going to look at in this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Micro 的安装很简单；嗯，它是 Go，所以应该是这样的。你需要安装 `protoc`，这是生成源代码的应用程序，它是 Google 的 `Protocol
    Buffers` 包的一部分。作为消息协议，`protobufs` 正在迅速发展，你将在我们将在本章中查看的许多框架中找到这个消息协议。
- en: Code generation
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码生成
- en: The `protoc` application is used for code generating our Go code from the proto
    file definition. In fact, the beautiful thing about `protoc` is that it can generate
    code in about 10 different languages. Micro also has the capability to use a `protoc`
    plugin to generate your clients and server code automatically. This is a nice
    feature and can indeed save a few keystrokes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`protoc` 应用程序用于从 proto 文件定义中生成我们的 Go 代码。实际上，`protoc` 的美妙之处在于它可以生成大约 10 种不同语言的代码。Micro
    还具有使用 `protoc` 插件自动生成客户端和服务器代码的能力。这是一个很好的功能，确实可以节省一些按键。'
- en: Let's take a look at how we can generate our Go code, which defines our message
    protocol, using `protoc`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `protoc` 生成我们的 Go 代码，这些代码定义了我们的消息协议。在 `20 min` 内就能深入理解知识点，而且记忆深刻，*难以遗忘*。
- en: '`gomicro/proto/kittens.proto`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`gomicro/proto/kittens.proto`'
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you run the `protoc` command, it processes the proto DSL file and outputs
    native language source files. In our example, a snippet of that code looks like
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `protoc` 命令时，它会处理 proto DSL 文件并输出本地语言源文件。在我们的例子中，该代码片段看起来如下所示：
- en: '`gomicro/proto/kittens.pb.go`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`gomicro/proto/kittens.pb.go`'
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We never edit this file by hand, so it does not matter what the code looks like.
    All this is doing is allowing a struct to be serialized using the binary standard
    set out by Protocol Buffers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从不手动编辑此文件，因此代码看起来如何并不重要。这一切只是在允许使用 Protocol Buffers 规定的二进制标准序列化结构体。
- en: 'To use this with Micro, we do not have to do very much at all. Let''s take
    a look at the main function and see how easy it is to set up:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 Micro 一起使用，我们实际上不需要做很多事情。让我们看看主函数，看看设置有多简单：
- en: '`gomicro/server/main.go`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`gomicro/server/main.go`'
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In line **24**, we are initializing the micro server, passing it some options.
    In the same way that we could pass our basic HTTP server an address to configure
    what the IP and port the server would bind to, we are doing the same thing in
    line **27**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**24**行，我们正在初始化micro服务器，传递一些选项。就像我们可以传递基本HTTP服务器一个地址来配置服务器将绑定到的IP和端口一样，我们在第**27**行做了同样的事情。
- en: 'The handlers section from line **31** should look familiar to you too; Micro
    uses exactly the same signature which is present in the `net/rpc` package. Creating
    a handler is as simple as defining a `struct` and adding methods to it. Micro
    will automatically register these as routes on your service:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从第**31**行开始的处理器部分也应该对你很熟悉；Micro使用与`net/rpc`包中相同的签名。创建一个处理器就像定义一个`struct`并向它添加方法一样简单。Micro会自动将这些注册为你的服务上的路由：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The form of the handler looks very similar to the one from the `net/http` package;
    we can see the same context object we looked at in the first chapter. If you remember
    from that chapter the Context is a safe method for accessing request scoped data
    which can be accessed from multiple Goroutines. The request and the response objects
    are those which we defined in our proto file. Instead of writing our response
    to a `ResponseWriter` in this handler, we set the values we wish to return to
    the reference of the response which is passed to the function. Regarding returning,
    we have the option to return an error if something went wrong and we wish to notify
    the caller.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的形式看起来与`net/http`包中的非常相似；我们可以看到我们在第一章中查看过的相同上下文对象。如果你还记得，上下文是一个安全的方法，用于访问请求作用域的数据，可以从多个Goroutines中访问。请求和响应对象是我们定义在proto文件中的那些。在这个处理器中，我们不是将响应写入`ResponseWriter`，而是将我们希望返回的值设置到传递给函数的响应引用中。关于返回，如果我们遇到错误并希望通知调用者，我们有返回错误选项。
- en: Tooling (CI/CD, cross platform)
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具（CI/CD，跨平台）
- en: Because Micro is written in pure Go, with the only external dependency being
    `protoc`, it creates a very lightweight framework which would be possible to use
    on Linux, Mac, and Windows with ease. It would also be easy to set up onto a CI
    server; the main complexity is the installation of `protoc`, but this application
    is incredibly well supported by Google and is available for all the main operating
    systems and architectures.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Micro是用纯Go编写的，唯一的依赖项是`protoc`，它创建了一个非常轻量级的框架，可以轻松地在Linux、Mac和Windows上使用。它也容易设置到CI服务器上；主要复杂性是`protoc`的安装，但这个应用程序得到了Google的极大支持，并且适用于所有主要操作系统和架构。
- en: Maintainable
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: The way that Micro has been built is incredibly sympathetic towards modern enterprise
    problems of updating and maintaining microservices. Versioning is incorporated
    into the framework, and in our example, we are setting the version in the `server.Init`
    method. It is possible for multiple services to co-exist differentiated by their
    version number. When requesting the service, it is possible to filter by a version
    which allows new versions of a service to be deployed without causing disruption
    to the rest of the estate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Micro的构建方式对现代企业中微服务的更新和维护问题非常具有同情心。版本控制被纳入框架中，在我们的示例中，我们在`server.Init`方法中设置版本。多个服务可以通过它们的版本号区分开来而共存。在请求服务时，可以通过版本进行筛选，这样就可以部署新版本的服务，而不会对其他服务造成干扰。
- en: Format (REST/RPC)
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式（REST/RPC）
- en: At its heart, Micro uses Google's Protocol Buffers as its core messaging protocol.
    This, however, is not the only method by which you can communicate with the services.
    Micro also implements the sidecar pattern which is an RPC proxy. This gives a
    really simple way of integrating any application into the Micro ecosystem. The
    sidecar can be used as an API gateway, which is a single point of entry for multiple
    downstream services. In Micro's case, the gateway handles HTTP requests and converts
    them to RPC; it is also capable of providing reverse-proxy functionality. This
    is a very versatile pattern, and the sidecar can be scaled differently to the
    primary services, allowing you to expose this as a public facing endpoint for
    non-Micro consumers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Micro使用Google的Protocol Buffers作为其核心消息协议。然而，这并不是与服务通信的唯一方法。Micro还实现了边车模式，这是一个RPC代理。这为将任何应用程序集成到Micro生态系统提供了一个非常简单的方法。边车可以用作API网关，这是多个下游服务的单一入口点。在Micro的情况下，网关处理HTTP请求并将它们转换为RPC；它还具备提供反向代理功能的能力。这是一个非常灵活的模式，边车可以与主要服务不同地扩展，允许你将其作为面向非Micro消费者的公开端点暴露出来。
- en: More information on the architecture of Micro can be found on the Micro website
    at [https://blog.micro.mu/2016/03/20/micro.html](https://blog.micro.mu/2016/03/20/micro.html)
    and [https://blog.micro.mu/2016/04/18/micro-architecture.html](https://blog.micro.mu/2016/04/18/micro-architecture.html).
    I thoroughly recommend anyone who is thinking about using Micro to read these
    articles as they give an excellent overview of just what it is capable of and
    the fantastic array of patterns that it uses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Micro架构的信息可以在Micro网站上找到，地址为[https://blog.micro.mu/2016/03/20/micro.html](https://blog.micro.mu/2016/03/20/micro.html)和[https://blog.micro.mu/2016/04/18/micro-architecture.html](https://blog.micro.mu/2016/04/18/micro-architecture.html)。我强烈推荐任何考虑使用Micro的人阅读这些文章，因为它们提供了关于Micro能够做什么以及它使用的令人惊叹的模式概览。
- en: Micro also implements a codec interface for encoding and decoding messages so
    while, by default, this supports `proto-rpc` and `json-rpc`, it would be incredibly
    easy to apply the messaging protocol of your choice.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Micro还实现了编码和解码消息的编解码器接口，所以默认情况下，它支持`proto-rpc`和`json-rpc`，但应用你选择的任何消息协议将变得极其容易。
- en: Patterns
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: In general, Micro has been very well architected and built with production use
    in mind. Asim, who created Micro and is the primary maintainer, has an incredible
    pedigree as a software architect and software engineer. Most of the common patterns
    that we will discuss in this chapter have been implemented in Micro and many more
    are available as community plugins. Full PubSub support is included and again
    supports a vast array of backend servers including Redis and NATS. Due to the
    architectural model, it is comparatively easy to write your own plugins should
    your backend of choice not be supported as part of the standard package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Micro架构得非常好，并且考虑到生产使用。Micro的创建者Asim，同时也是主要维护者，作为软件架构师和软件工程师有着令人难以置信的背景。我们将在本章讨论的大多数常见模式已经在Micro中实现，并且还有许多作为社区插件可用。它包括完整的PubSub支持，并且再次支持包括Redis和NATS在内的广泛的后端服务器。由于架构模型，如果你选择的后端不是标准包的一部分，编写自己的插件相对容易。
- en: Language independence
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言无关性
- en: Thanks to two nice design choices with the use of Protocol Buffers as a messaging
    format and the ability of the sidecar, it is possible to interface with microservices
    from just about any language that can support an HTTP transport.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了两个很好的设计选择，即使用Protocol Buffers作为消息格式以及边车的功能，我们几乎可以从任何支持HTTP传输的语言中与微服务进行接口。
- en: 'Let''s take a quick look at how we could send and receive messages using Ruby.
    This example is probably a little more complicated than just making a simple REST
    call, and most people who use Micro would probably opt to use JSON-RPC from the
    sidecar. However, it is interesting to see how we can interface using the RPC
    interface. While there may seem to be far more boilerplate than what you would
    find if you were making a call using the Go client for Micro, this could be wrapped
    up into a library and distributed as a gem; this code is only to illustrate the
    possibilities:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下如何使用Ruby发送和接收消息。这个例子可能比仅仅做一个简单的REST调用要复杂一些，而且大多数使用Micro的人可能会选择从边车使用JSON-RPC。然而，看到我们如何使用RPC接口进行接口是很有趣的。虽然看起来可能比使用Micro的Go客户端进行调用有更多的样板代码，但这些可以封装成一个库并作为gem分发；这段代码只是为了说明可能性：
- en: '`gomicro/client/client.rb`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`gomicro/client/client.rb`'
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the same way that we generated some native Go code from the proto file,
    we can do the same for Ruby. This makes it possible to share these service definitions
    and save the consumer the trouble of having to write them by hand. In line **86**,
    we are creating our request which is sent to the Micro service. Even though Micro
    is an RPC service, it still uses HTTP as the transport which makes it easy to
    make a request using Ruby''s standard `NET::HTTP` library. Before we can do this,
    however, we need to understand how the message protocol for Micro works. Following
    is the Micro message format:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从proto文件中生成了一些原生Go代码一样，我们也可以为Ruby做同样的事情。这使得共享这些服务定义并节省消费者手动编写的麻烦成为可能。在**86**行，我们正在创建一个请求，该请求被发送到Micro服务。尽管Micro是一个RPC服务，但它仍然使用HTTP作为传输协议，这使得使用Ruby的标准的`NET::HTTP`库来发送请求变得容易。然而，在我们能够这样做之前，我们需要了解Micro的消息协议是如何工作的。以下就是Micro的消息格式：
- en: '| Envelope Size(4 bytes) | Envelope(n bytes) | Message Size(4 bytes) | Message(n
    bytes) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 信封大小(4字节) | 信封(n字节) | 消息大小(4字节) | 消息(n字节) |'
- en: The first 4 bytes in the body are the length of the envelope. The envelope itself
    is the method by which Micro determines where the message is sent to; it is similar
    to the way you would use a URI in a RESTful API. The envelope is written to the
    body using Protocol Buffer's binary serialization using the encode method. Thankfully,
    all this work is done for us by the `protobuf` package. We then write the message
    size again using exactly 4 bytes and following that the message, which again is
    encoded into a binary representation using the Protocol Buffers package.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 消息体中的前4个字节是信封的长度。信封本身是Micro确定消息发送目的的方法；它类似于你在RESTful API中使用URI的方式。信封使用Protocol
    Buffer的二进制序列化方法通过encode方法写入到消息体中。幸运的是，所有这些工作都由`protobuf`包为我们完成。然后我们再次使用正好4个字节写入消息大小，随后是消息，这同样使用Protocol
    Buffers包编码成二进制表示。
- en: The message can then be sent as an HTTP post. To let Micro know we are sending
    a binary message and not JSON-RPC, we have to specify the `Content-Type` header
    and set this to `application/octet-stream`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以随后作为HTTP POST发送。为了让Micro知道我们发送的是二进制消息而不是JSON-RPC，我们必须指定`Content-Type`头并将其设置为`application/octet-stream`。
- en: The response which is returned by Micro will be in the same format as the request.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Micro返回的响应将与请求格式相同。
- en: Ability to interface with other frameworks
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他框架的接口能力
- en: Because of its language-agnostic interface, it is possible to integrate Micro
    with many different frameworks. Theoretically, you could even write your Micro
    compatible service which takes advantage of all the service discovery and registration
    in a language which is not Go. Why would we want to do that though? After all,
    Go is fantastic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其语言无关的接口，可以将Micro与许多不同的框架集成。理论上，你甚至可以编写一个与Micro兼容的服务，利用所有服务发现和注册功能，而使用的语言不是Go。然而，我们为什么要这样做呢？毕竟，Go语言非常出色。
- en: Efficiency
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效率
- en: Micro performs admirably, managing to hold 400 connections with roughly a 125
    ms response. The response time gives us nearly 3,000 requests per second. While
    this is not a direct reflection on how your server will perform in production,
    we will be using the same setup to test all the frameworks in this chapter. When
    load testing Micro, the memory consumption was efficient, only consuming approximately
    10% of the available memory on the server. CPU loads, like all tests, were running
    at maximum but this is to be expected when the system is handling so many concurrent
    requests for such a small setup.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Micro表现优异，能够管理400个连接，响应时间大约为125毫秒。响应时间使我们几乎每秒可以处理3,000个请求。虽然这并不是直接反映你的服务器在生产中的表现，但我们将使用相同的设置来测试本章中所有框架。在负载测试Micro时，内存消耗效率高，仅消耗服务器上大约10%的可用内存。CPU负载，像所有测试一样，都在最大值运行，但这是在系统处理如此多的并发请求时可以预料的。
- en: '**Results:**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果：**'
- en: '| Threads | 400 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 线程数 | 400 |'
- en: '| Total Requests: | 806011 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 总请求数 | 806011 |'
- en: '| Avg. Request Time | 125.58ms |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 平均请求时间 | 125.58ms |'
- en: '| Total Success | 806011 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 总成功数 | 806011 |'
- en: '| Total Timeouts | 0 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 总超时数 | 0 |'
- en: '| Total Failures | 0 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 总失败数 | 0 |'
- en: '**Requests over time:**![](img/cbe35ccd-4cd5-439a-9e4b-f0b5096f00d1.png)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求随时间变化：**![](img/cbe35ccd-4cd5-439a-9e4b-f0b5096f00d1.png)'
- en: Quality
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量性
- en: The quality of the Micro framework is very high with automated builds, and decent
    code coverage where needed, and it should be straightforward to navigate implementing
    many of the standard Go idioms.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Micro框架的质量非常高，具有自动构建、所需的地方有适当的代码覆盖率，并且实现许多标准Go编程习惯应该非常直接。
- en: Open source
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源
- en: The framework is open source using the Apache license. Regarding popularity,
    Micro has over 2,000 stars on GitHub and accepts contributions from the community.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架采用Apache许可证开源。至于流行度，Micro在GitHub上有超过2,000颗星，并接受社区的贡献。
- en: Security
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Out of the box, Micro does not have an explicit authentication or authorization
    layer, and I believe this is a good thing. It would be relatively trivial to implement
    your authentication into the service framework using JWT or if you really must,
    your proprietary format. Request validation is handled in part by the Protocol
    Buffers. However, to do more complex validation would possible using something
    like `govalidator` ([https://github.com/asaskevich/govalidator](https://github.com/asaskevich/govalidator)).
    However, since you cannot directly modify the request objects to add the fields
    tags required, you may have to jump through a few hoops here. The issue with validation,
    however, is more to do with the Protocol Buffers framework, not Micro.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Micro 没有明确的身份验证或授权层，我认为这是好事。使用 JWT 或如果你真的需要，使用你自己的格式将身份验证集成到服务框架中相对简单。请求验证部分由
    Protocol Buffers 处理。然而，要执行更复杂的验证，可能需要使用类似 `govalidator` ([https://github.com/asaskevich/govalidator](https://github.com/asaskevich/govalidator))
    的工具。然而，由于你不能直接修改请求对象来添加所需的字段标签，你可能不得不跳过几个步骤。然而，验证的问题更多是与 Protocol Buffers 框架有关，而不是
    Micro。
- en: From a secure communication perspective, Micro uses `net/http` as the base transport,
    so it will be a trivial matter to introduce TLS encryption, not just for the public
    facing services, but also for private services. You will see why this is important
    when we take a more in-depth look at security.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全通信的角度来看，Micro 使用 `net/http` 作为基础传输，因此引入 TLS 加密将是一件非常简单的事情，不仅适用于面向公众的服务，也适用于私有服务。当我们更深入地了解安全性时，你会看到这为什么很重要。
- en: Support
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持
- en: Support for using the framework is pretty excellent; there are plenty of code
    examples, and there is a Slack group which is well used, so any questions you
    may have can be answered either by other users or by Asim himself, who is very
    active in the group in providing support.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对框架的支持相当出色；有很多代码示例，还有一个使用得很好的 Slack 群组，所以你可能会有的任何问题都可以由其他用户或 Asim 本身回答，Asim
    在群组中非常活跃，提供支持。
- en: Extensibility
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展性
- en: One of the nice features of Micro is the way that it has been architected for
    extensibility. All of the standard dependencies for service discovery, messaging,
    and transport follow an interface-driven abstraction. Should you need to implement
    a particular use case or for upgrades when a breaking change may be introduced
    by the likes of an etcd version update, it will be no problem to write a plugin
    specific to this and use this within your services. As expected of a framework
    of this quality, middleware is supported on both the client and the server interfaces,
    which would enable a vast array of functionality from authentication and authorization
    to request validation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Micro 的一个很好的特性是它为了扩展性而设计的架构方式。服务发现、消息传递和传输的所有标准依赖项都遵循接口驱动的抽象。如果你需要实现特定的用例，或者当可能由于
    etcd 版本更新等引入破坏性更改时进行升级，编写一个特定于此的插件并在你的服务中使用它将不成问题。对于一个这样的框架来说，客户端和服务器接口都支持中间件，这将使从身份验证和授权到请求验证的广泛功能成为可能。
- en: What we learned about Micro
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们从 Micro中学到的东西
- en: In general, Micro is a nice framework which covers nearly all of your needs
    when building a highly scalable distributed system. Asim has done an excellent
    job, both in creating this and maintaining it, and his skill and experience shine
    through in the patterns he has implemented.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，Micro 是一个很好的框架，几乎涵盖了构建高度可扩展的分布式系统时所需的所有需求。Asim 在创建和维护这个框架方面都做得非常出色，他的技能和经验在他的实现模式中得到了体现。
- en: Kite
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kite
- en: Kite is a framework that is developed by the team responsible for Koding, the
    browser-based IDE. The framework is used by the Koding team and was open sourced
    as they believed that it would be useful for other microservice practitioners,
    having faced many of the problems themselves.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Kite 是由负责 Koding（基于浏览器的 IDE）的团队开发的框架。该框架被 Koding 团队使用，并且由于他们自己面临了许多问题，因此将其开源，他们认为这对其他微服务实践者会有所帮助。
- en: The concept behind the framework is that everything is a Kite, both servers,
    and clients and that they communicate in a bi-directional manner using web sockets
    and an RPC based protocol. Web sockets make inter-service communication incredibly
    efficient as it removes the overhead of constantly having to handshake a connection
    which can take as much time as the message passing itself. Kite also has a built
    in service discovery feature which allows you to make a call to a Kite without
    knowing the specific endpoint.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 框架背后的概念是，一切都是风筝，无论是服务器还是客户端，它们都通过 WebSocket 和基于 RPC 的协议进行双向通信。WebSocket 使得服务间通信非常高效，因为它消除了不断进行握手连接的开销，这个过程可能需要的时间与消息传递本身一样长。Kite
    还内置了服务发现功能，允许你调用风筝而无需知道具体的端点。
- en: Setup
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: The installation of Kite is relatively simple; there are a few dependencies
    for service discovery, such as `etcd`, but all the code you need to create a Kite
    is found in the Go package. If we install this package using the `go get` command
    we can go ahead and start writing our first Kite.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Kite 的安装相对简单；有一些服务发现的依赖项，例如 `etcd`，但创建风筝所需的所有代码都位于 Go 包中。如果我们使用 `go get` 命令安装此包，我们就可以开始编写我们的第一个风筝了。
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The way Kite works is that there is a service which runs along with your application
    Kites called **kontrol**. This handles service discovery, and all of your application
    services register with this service so that the clients can query the service
    catalog to obtain the service endpoint. The kontrol Kite comes bundled within
    the main package, and for convenience, I have created a Docker Compose file, which
    starts this along with `etcd`, which is used as the service registry.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kite 的工作方式是有一个与你的应用程序风筝一起运行的服务，称为 **kontrol**。这个服务处理服务发现，你的所有应用程序服务都注册到这个服务上，以便客户端可以查询服务目录以获取服务端点。kontrol
    风筝包含在主包中，为了方便，我创建了一个 Docker Compose 文件，它启动了这个服务以及 `etcd`，它用作服务注册。
- en: 'If we take a look at our server implementation, we can see the various steps
    we need to add to register our new service:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们的服务器实现，我们可以看到我们需要添加的注册新服务的各个步骤：
- en: '`kite/server/main.go`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`kite/server/main.go`'
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In line **15**, we are creating our new Kite. We pass two arguments to the
    `New` method: the name of our Kite and the service version. We then obtain a reference
    to the configuration and set this to our Kite. To be able to register our kite
    with the service discovery, we have to set the `KontrolURL` with the correct URI
    for our kontrol server:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 **15** 行，我们正在创建我们的新风筝。我们向 `New` 方法传递两个参数：我们的风筝名称和服务版本。然后我们获取配置的引用并将其设置到我们的风筝中。为了能够将我们的风筝注册到服务发现中，我们必须将
    `KontrolURL` 设置为我们 kontrol 服务器的正确 URI：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you look at the URL we are passing it; we are using the name that is supplied
    by Docker when we link together some containers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看我们传递的 URL；我们使用的是 Docker 在我们将一些容器链接在一起时提供的名称。
- en: In the next line, we are registering our container with the kontrol server.
    We need to pass the URL scheme we are using. In this instance, HTTP is the hostname;
    this needs to the accessible name for the application. We are cheating a little
    bit with this host as we are exposing the ports to the Docker host; we could have
    passed the internal name had our client application had been linked to this one.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们正在将我们的容器注册到 kontrol 服务器。我们需要传递我们正在使用的 URL 方案。在这个例子中，HTTP 是主机名；这需要是应用程序的可访问名称。我们在主机名上有点作弊，因为我们正在将端口暴露给
    Docker 主机；如果我们的客户端应用程序已经链接到这个容器，我们本可以传递内部名称。
- en: 'Now the interesting stuff starts, and we define the methods that our Kite will
    have available to it. If we take a look at line **25**, we will see a pattern
    that should look quite familiar:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有趣的部分开始了，我们定义了风筝将可用的方法。如果我们看一下第 **25** 行，我们会看到一个应该看起来相当熟悉的模式：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The signature for `HandleFunc` is very similar to that of the standard HTTP
    library; we set up a route and pass a function which would be responsible for
    executing that request. You will see that both the request and the response are
    not typed. Well, that is not exactly correct for the `Request` method, but certainly,
    there is no explicitly defined contract.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleFunc` 的签名与标准 HTTP 库非常相似；我们设置一个路由并传递一个负责执行该请求的函数。你会看到请求和响应都没有类型。嗯，对于
    `Request` 方法来说，这并不完全正确，但确实没有明确定义的合同。'
- en: 'To get the arguments which are passed with the `Request` method, we use the
    `Args` object, which is a `dnode` message. Unlike the other frameworks we have
    looked at, a `dnode` message does not have a contract which can be shared between
    consumers and producers of this message, so each must implement their interpretation.
    The `dnode` message itself is a newline terminated JSON message and is heavily
    abstracted by the kite framework, for the curious, the protocol definition can
    be found in the following document: [https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol](https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取通过 `Request` 方法传递的参数，我们使用 `Args` 对象，它是一个 `dnode` 消息。与其他我们考虑过的框架不同，`dnode`
    消息没有可以在消息的消费者和生成者之间共享的合约，因此每个都必须实现自己的解释。`dnode` 消息本身是一个以换行符终止的 JSON 消息，并且被 kite
    框架高度抽象化，对于好奇的人来说，协议定义可以在以下文档中找到：[https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol](https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol)
- en: The output of our `HandleFunc` is the standard Go pattern of `interface{} error`,
    again the `interface{}` which is the response we would like to send to the caller.
    This is not strongly typed, and it is most likely just a struct which can be serialized
    down to a `dnode` payload, the representation of which is just JSON.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `HandleFunc` 输出是标准的 Go 模式 `interface{} error`，这里的 `interface{}` 是我们希望发送给调用者的响应。这不是强类型，它很可能只是一个可以序列化到
    `dnode` 有效载荷的 struct，其表示形式是 JSON。
- en: One of the nice features of Kite is that authentication is built in and, in
    our instance, we are disabling this. It is quite common to restrict the actions
    of a particular service call based upon the permissions of the caller. Under the
    hood, Kite is using `JWT` to break down these permissions into a set of claims.
    The principle is that a key is signed and therefore a receiving service only has
    to validate the signature of the key to trust its payload rather than having to
    call a downstream service. The final line we are calling is `k.Run()`; this starts
    our Kite and blocks our main function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Kite 的一个优点是内置了身份验证，在我们的实例中，我们已禁用此功能。根据调用者的权限限制特定服务调用的操作相当常见。在底层，Kite 使用 `JWT`
    将这些权限分解成一系列声明。原则是密钥被签名，因此接收服务只需验证密钥的签名即可信任其有效载荷，而不是必须调用下游服务。我们最后调用的行是 `k.Run()`；这启动了我们的
    Kite 并阻塞了主函数。
- en: Code generation
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码生成
- en: With Kite, there is no code generation or templates to help set up your servers
    and clients. That said, the simplicity of creating a server does not warrant the
    need for this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kite，无需代码生成或模板来帮助设置您的服务器和客户端。话虽如此，创建服务器的简单性并不需要这种需求。
- en: Tooling
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: Besides Go, there is little you need to set up Kite. etcd, which is used for
    your service discovery, and Kite, are easily packaged into a Docker container,
    which allows a standard testing and deployment workflow.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Go 语言之外，您几乎不需要设置 Kite。用于服务发现的 etcd 和 Kite 都可以轻松地打包进 Docker 容器，这允许标准的测试和部署工作流程。
- en: The cross-platform elements of the framework are limited to areas which can
    be compiled with the Go framework, which, as I write this, is a rather impressive
    array.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的跨平台元素仅限于可以使用 Go 框架编译的领域，在我撰写本文时，这是一个相当令人印象深刻的列表。
- en: Maintainable
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: Kite is a relatively mature framework with active development over a period
    of three years. It is also actively used by the Koding service which was acquired
    by Amazon in 2016.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Kite 是一个相对成熟的框架，在三年多的时间里一直处于活跃开发状态。它还被 Koding 服务积极使用，该服务于 2016 年被亚马逊收购。
- en: Due to the way that routing works by registering a handler, it would be possible
    to cleanly separate your implementation from the main Kite packages, which would
    allow easy updating of the main package when upstream changes are made.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由是通过注册处理程序来工作的，因此可以干净地将您的实现与主 Kite 包分开，这允许在上游更改时轻松更新主包。
- en: I do have a slight reservation about the lack of contracts around the `dnode`
    messages. This could cause maintenance problems if not properly managed, as the
    consumer has the responsibility of discovering the protocol implementation and
    the supplier service must document this protocol and ensure that it is correctly
    versioned to avoid breaking changes. As far as I am aware, there is no capability
    to produce documentation from the code source automatically. Since dnode uses
    JSON under the hood, it might be an idea to have a single argument in the payload
    containing a JSON object, the type of which is known and could be easily serialized
    to a struct using the standard package.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我对`dnode`消息周围的合同缺失有一些保留。如果不妥善管理，这可能会引起维护问题，因为消费者有责任发现协议实现，而供应商服务必须记录此协议并确保其正确版本化以避免破坏性更改。据我所知，没有从代码源自动生成文档的能力。由于dnode底层使用JSON，可能有一个想法是在有效负载中包含一个JSON对象，其类型已知并且可以很容易地使用标准包序列化到结构体中。
- en: Format
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式
- en: Kite uses dnode as its messaging protocol. While this is not a concern if you
    are doing kite-to-kite communication or if you are using the JavaScript framework
    for Kite, it might be an issue if you would like to interface from another language
    in your stack. The protocol definition is listed in the GitHub project at [https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol](https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol)
    and it is JSON-based. Looking at the documentation for dnode, it seems that the
    messaging protocol and the execution framework was never intended to be loosely
    coupled. My personal recommendation when choosing a messaging protocol is that
    you should ensure there are encoders and decoders already written for your chosen
    languages. If there is no package, then you need to assess if the protocol has
    a large enough user base that the actions of writing this would be warranted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Kite使用dnode作为其消息协议。虽然如果你正在进行风筝到风筝的通信或如果你使用Kite的JavaScript框架，这不会成为问题，但如果你想从你的堆栈中的另一种语言进行接口，这可能会成为一个问题。协议定义列在GitHub项目[https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol](https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown#the-protocol)中，并且它是基于JSON的。查看dnode的文档，似乎消息协议和执行框架从未打算松散耦合。我个人的建议是在选择消息协议时，你应该确保已经为你的选择语言编写了编码器和解码器。如果没有包，那么你需要评估协议是否有足够大的用户基础，以至于编写这个包的行动是合理的。
- en: Patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: Service discovery is built into Kite with the application kontrol. The backend
    store for kontrol is not proprietary, but it uses a plugin architecture and supports
    etcd, consul, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现是Kite应用程序控制的一部分。kontrol的后端存储不是专有的，但它使用插件架构并支持etcd、consul等。
- en: If we look at our client application, we can see how this works in action.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的客户端应用程序，我们可以看到这个功能是如何实际工作的。
- en: In line **19**, we are calling the `GetKites` method and passing a `KontrolQuery`
    as a parameter. The query contains the username, environment, and the name of
    the service we would like to reference.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**19**行，我们调用`GetKites`方法，并传递一个`KontrolQuery`作为参数。查询包含用户名、环境和我们要引用的服务名称。
- en: The return type of this call is a slice of Kites. In our simple example, we
    are just getting a reference to the first item in the list. This process does
    mean that we have to implement load balancing and circuit breaking ourselves;
    it would have been nice if we could have had this feature built into kontrol.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用的返回类型是Kites的切片。在我们的简单示例中，我们只是获取列表中的第一个元素的引用。这个过程确实意味着我们必须自己实现负载均衡和断路器；如果kontrol内置了这个功能会更好。
- en: 'To connect to Kite, we have two methods at our disposal:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到Kite，我们有两种方法可供选择：
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Dial()` method takes a timeout, which, when elapsed, the method will return
    regardless of whether it has been possible to connect to the downstream service
    or not. The `DialForever()` method, as the method name suggests, will not. In
    both instances, a channel is returned which we use to pause execution until we
    have obtained our connection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dial()`方法接受一个超时时间，无论是否成功连接到下游服务，超时后该方法都会返回。`DialForever()`方法，正如其名称所暗示的，不会超时。在这两种情况下，都会返回一个通道，我们使用它来暂停执行，直到我们获得连接。'
- en: Calling the service is now as simple as executing `Tell`, and passing the method
    name, you wish to run and the parameters as an interface for that method. In my
    humble opinion, Kite loses points here. The contracts for the service calls are
    very loose and creating an implementation for the consumers will not be without
    effort.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Language independence
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kite as a framework is predominately Go, and JavaScript based. The JavaScript
    package [https://github.com/koding/kite.js](https://github.com/koding/kite.js)
    allows you to write a Kite in JavaScript which would run on the server with NodeJS
    or you can also use the plugin direct from the browser, which would enable you
    to build rich user interfaces.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with Kite from a language such as Ruby would require a degree
    of effort. Custom code would need to be written to interact with kontrol and to
    execute queries to the Kites. This would certainly be possible, and if you build
    this framework, please push it back to the open source community.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kite is fast. Thanks to the way it uses web sockets there seems to be little
    overhead once you are connected. When I was testing the system, I did experience
    some problems with creating multiple Kite connections; this was not on the server
    but the client. To be honest, I have not dug too far into this, and the performance
    from using a shared Kite in the client is pretty impressive. In terms of CPU and
    memory consumption, Kite consumes the most of all the frameworks evaluated. For
    the 400 connection test, Kite was consuming 1.8 GB of the 2 GB of RAM available
    on the client; the server was consuming 1.6 GB. Both client and server were heavy
    users of the CPU:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Results table:**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '| Threads | 400 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| Total Requests: | 1649754 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| Avg. Request Time | 33.55ms |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| Total Success | 1649754 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| Total Timeouts | 0 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| Total Failures | 0 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '**Requests over time:**![](img/eacee694-2628-49ad-98f1-b5495747c2f3.png)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Quality
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kite framework uses Travis CI, and there are unit and integration tests
    executed for each build. Code coverage is not huge; however, it seems to cover
    the complexities and looking at the issues in GitHub, there is nothing outstanding.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Open source
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project is fairly popular with over 1,200 GitHub stars. However, there is
    no slack community or forum. The authors are, however, excellent at answering
    questions when they are posted to GitHub issues.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security wise, Kite has its own authentication layer using `JWT` and supports
    the standard Go TLS configuration to connect two Kites securely. Request validation
    does not, however, seem to be present, and I guess this is due to the dnode protocol
    being quite dynamic. It should be relatively straightforward to implement this
    as the handlers could be chained in the same way a middleware pattern could be
    built with `net/http`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Support
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Kite is used in a commercial context with Koding, it is very well maintained
    and mature, receiving regular updates. Documentation, however, is somewhat lacking
    and while I was working on the example code, I spent quite a lot of time figuring
    out the various parts. The authors are aware of the problems with the documentation
    and do plan to improve this facet. Google also has little to offer in the way
    of help for Kite. When searching for an issue, generally you will end up back
    on the GitHub repository. This is not a massive problem if you are a relatively
    experienced developer, as you can simply read through the code and reverse engineer
    it. However, if you are just starting out this might be a problem as you may not
    have a solid grasp of the underlying concepts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kite在Koding的商业环境中使用，它得到了非常好的维护和成熟，并定期更新。然而，文档却有些不足，在我编写示例代码时，我花了很多时间来理解各个部分。作者们意识到了文档的问题，并计划改进这一方面。Google在提供Kite的帮助方面也做得很少。在搜索问题时，通常你最终会回到GitHub仓库。如果你是一个相对有经验的开发者，这并不是一个巨大的问题，因为你可以直接阅读代码并逆向工程它。然而，如果你是初学者，这可能会成为一个问题，因为你可能没有牢固掌握底层概念。
- en: There is code level documentation, and the code is self-descriptive; however,
    there are elements which could do with further explanation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有代码级别的文档，代码本身具有描述性；然而，有一些元素可能需要进一步的解释。
- en: Extensibility
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: There is no formal plugin or middleware format for Kite. However, due to the
    way it has been engineered, it should be possible to extend the framework. You
    may run into problems, however. For example, if you wish to add a different backend
    for kontrol storage, the options are hardcoded into the kontrol application, so
    even though storage is derived from an interface, a modification would need to
    be made to kontrol's main function to enable this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Kite没有正式的插件或中间件格式。然而，由于它的设计方式，扩展框架应该是可能的。但是，你可能会遇到问题。例如，如果你希望为kontrol存储添加不同的后端，选项被硬编码到kontrol应用程序中，因此即使存储是从一个接口派生出来的，也需要对kontrol的主函数进行修改以启用这一功能。
- en: Summing up Kite
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结Kite
- en: Kite is a nicely written framework, and if you are only building microservices
    in Go with a requirement for access from the browser, then it could be a right
    choice. In my opinion, the documentation and tutorials need more work; however,
    I suspect this is due to Kite being an internal framework of a small company which
    has been open sourced rather than the intention of producing a community open
    source framework. Kite loses quite a few points due to a lack of standard patterns
    built into the framework. Cross-framework integration also suffers due to the
    messaging protocol dnode and the documentation could be dramatically improved.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Kite是一个编写得很好的框架，如果你只是用Go语言构建需要从浏览器访问的微服务，那么它可能是一个合适的选择。在我看来，文档和教程需要更多的改进；然而，我怀疑这是由于Kite是一个小型公司的内部框架，而不是出于生产社区开源框架的意图而被开源的。Kite由于框架中缺少标准模式而失去了很多分数。由于消息协议dnode，跨框架集成也受到影响，而且文档可以大幅改进。
- en: gRPC
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC
- en: We have already taken a look at the Protocol Buffers messaging protocol from
    Google when we looked at API design in Chapter 2, *Designing a Great API*. gRPC
    is a cross-platform framework which uses HTTP/2 as the transport and Protocol
    Buffers as the messaging protocol. Google developed it as a replacement for their
    Stubby framework which they had used internally for many years.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章“设计一个优秀的API”中查看API设计时，已经了解过Google的Protocol Buffers消息协议。gRPC是一个跨平台框架，它使用HTTP/2作为传输协议，并使用Protocol
    Buffers作为消息协议。Google开发它作为他们内部使用了多年的Stubby框架的替代品。
- en: The intention behind the project was to build a framework which promotes good
    microservice design, concentrating on messages rather than distributed objects.
    gRPC is also optimized for the many network problems we face in microservice architecture,
    such as fragile networks, limited bandwidth, the cost of the transport, and so
    on. One of the other lovely facets of gRPC is its ability to stream data between
    client and server. This can have a huge benefit in certain application types and
    is built into the framework as a standard component. Additionally, for microserivice
    to microservice communication, there is a pure javascript implementation which
    is designed to enable browser clients to access a gRPC server. At the time of
    writing, this has not yet been released, the expected shipping date is quarter
    3 in 2017.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main problem with setting up a gRPC project is installing the `protoc`
    application and the various plugins which are obtained from the following URL:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to install the Go packages for gRPC and the code generation plugin
    for protoc:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For convenience, I have created a Docker container which has all these packages
    (`nicholasjackson/building-microservices-in-go`). If you take a look at the Makefile
    in the example code at `chapter4/grpc/Makefile`, you will see that we are using
    the power of Docker to save the hassle of having to install any applications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Code generation
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of gRPC is the code generation. From the simple `proto` files that
    we looked at in Chapter 2, *Designing a Great API*, we can generate all our client
    and server code. All we then have to do is to wire up our handlers which will
    deal with the business logic.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at the proto file in `chapter4/grpc/proto/kittens.proto`,
    we can see that the file is somewhat similar to the one we reviewed in a previous
    chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference is the following block from line **13**:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is our service definition, which contains the contract for our handlers.
    It is nicely semantic and very readable even though it is written in the proto
    DSL.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate our Go code, all we need to do is to call the `protoc` command
    and tell it to use the Go plugin:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will create our messages and our service definitions, and output them to
    the `kittens.pb.go` file. It is relatively interesting to look at this file, even
    though the code is auto-generated, to see some of the inner workings of the framework.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see just how easy it is to use the framework if we take a look at
    `grpc/server/main.go`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the first thing we are doing is setting up our handler code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In line **15**, we are creating a struct, the methods of which will correspond
    to the `KittenServer` interface, which has been auto-generated for us by the `protoc`
    command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Line **17** is where we are defining our handler, and again the pattern should
    look familiar to the one we examined in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml),
    *Introduction to Microservices*. We have our context and an object which corresponds
    to the request message we defined in our `protos` file and the return tuple of
    response and error.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: This method is where we will do the work for the request, and you can see on
    line **18** that we are creating a response object and then setting the message
    which will be returned to the client.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Wiring up the server is also really straightforward. We only need to create
    a listener and then create a new instance of the server, which has been auto-generated
    for us by the `protoc` command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The client code is similarly straightforward. If we take a look at `grpc/client/client.go`,
    we can see that we are creating a connection to our server and then initiating
    the request:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `grpc.Dial` method has the following signature:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The target is a string which corresponds to the server's network location and
    port and opts is a variadic list of `DialOptions`. In our example, we are only
    using `WithInsecure`, which disables transport security for the client; the default
    is that transport security is set so, in our simple example, we need this option.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The list of choices is very comprehensive, and you can specify configuration
    such as timeouts and using a load balancer. For the full list, please see the
    documentation which can be found at [https://godoc.org/google.golang.org/grpc#WithInsecure](https://godoc.org/google.golang.org/grpc#WithInsecure).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Line **18** is where we are creating our client. This is a type which is defined
    in our auto-generated code file, not the base package. We pass it the connection
    we created earlier and then we can call the methods on the server as shown in
    line **19**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Tooling
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tooling for gRPC is rather impressive. There are a huge number of platforms
    and languages supported, and just with Go and the `protoc` application, it is
    relatively trivial to set up an automated build. In our simple example, I have
    configured the build to run in a Docker container which further limits the requirements
    for any software to be installed on the continuous deployment machines. By doing
    this, we can limit the dependencies which are used in all our builds. This is
    a technique we will learn more about in a later chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Maintainable
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating gRPC is also incredibly easy. Google has put a significant amount of
    work into making the new v3 specification for Protocol Buffers backward compatible
    with v2 and, according to the documentation, there is a desire to maintain this
    as gRPC and Protocol Buffers move forward.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Format
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we may not have the semantic nature of REST, we do have a very clearly
    defined messaging protocol with Protocol Buffers. The definitions are easy to
    understand, and the ability for connecting clients to use the proto files we defined
    and reuse them to create their clients is a very nice feature.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The array of patterns that is also implemented into the framework is very comprehensive,
    supporting health checks and timeouts. There is no explicit support for middleware;
    however, many of the requirements for middleware, such as authentication and request
    validation, we get for free built into the framework. We also do not have circuit
    breaking, but the balancer can be configured to add this functionality. In the
    official documentation, there is a statement that this is an experimental API
    and may be changed or extended in the future. We can, therefore, expect many great
    updates from this feature.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The clients themselves have configuration to deal with a back off algorithm.
    This throttling protects your servers in the instance of high load by not flooding
    a server which may be under pressure with thousands of connections.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: From a service discovery perspective there is no implicit handling of this inside
    the framework; however, the extension points are there to perform this with your
    backend of choice.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Language independence
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of languages which are currently supported by gRPC is quite impressive,
    with 10 languages officially supported and there are many more by a growing community.
    The ability to generate and distribute client SDKs in multiple languages using
    the `protoc` command is fantastic. To see how this could work from a language
    other than Go, we have created a simple example in Ruby which shows just how easy
    it is to make a connection to a gRPC service.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, `grpc/client/client.rb`, we can see that there are very few
    lines of code need to initiate a connection and execute a request to a gRPC endpoint
    written in Go:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the non-Rubyists, in line **6**, we are including our auto-generated code,
    which was generated with the `protoc` command and using the Ruby gRPC plugin.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Line **8** then creates an instance to our server, again passing the option
    of an insecure channel like we did in the Go client.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: We then create a request object in line **10**, set the parameters for this
    request, and execute it. All of the objects for the request and response are defined
    for us and are incredibly easy to use.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Google are currently working on a version of the framework which would enable
    connections to a gRPC service from the web browser. When this arrives, it will
    be very easy to create interactive web applications which are backed by gRPC microservices.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to the use of HTTP/2 and the binary messaging, gRPC is incredibly quick
    and capable of supporting a massive throughput. The option for streaming data
    to the client is a fantastic feature. From a mobile perspective, the client only
    needs to maintain a single connection to the server which is efficient and the
    server can push data updates to this open connection. For an example of how this
    could work, have a look at some code I created for a talk at GoLang UK. This implements
    a simple server and Android client which receives streaming updates. Rather than
    use native gRPC clients on Android, I geeked out using GoMobile to compile a native
    framework which was written in Go and then used this in the Android app:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/gokitter](https://github.com/gokitter)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**Results:**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '| Threads | 400 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| Total Requests: | 2949094 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| Avg. Request Time | 23.81ms |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| Total Success | 2949094 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| Total Timeouts | 0 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| Total Failures | 0 |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '**Requests over time:**![](img/4816c507-f962-449a-99c7-1e83cf17f8d1.png)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Quality
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may expect from Google, the quality of the project is incredibly high
    with some awesome architectural patterns and standard language patterns implemented
    by the framework. All the code is built using continuous integration, and the
    test coverage is excellent.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Open source
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The framework is growing in popularity and is under constant development by
    both Google and community committers. Everything is open source, and if you want
    to dig into the code, it is all available for you at the GitHub repository:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/grpc](https://github.com/grpc)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a security perspective, we have all the features we could need. gRPC supports
    TLS encryption, authentication, and request validation. Because the underlying
    transport is `net/http`, we can also be confident that we are receiving the highest
    quality in the server layer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Support
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation is again excellent with both great examples and source code documentation
    provided on the gRPC website. There is a growing list of community resource with
    further examples provided by bloggers and support can also be found on the Google
    group and Stack overflow.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Extensibility
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From an extensibility perspective, it is possible to write custom plugins for
    both protoc, like the Micro framework does, and also the framework has been well
    written and is extensible. As a new framework only just reaching version 1, the
    current options are very impressive, and I can only see these growing in future
    releases.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: A few lines about gRPC
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am very impressed with the gRPC framework and the array of options and community
    support which seems to grow by the day. The Protocol Buffers messaging format
    also appears to be growing with companies such as Apple contributing their implementation,
    and I can see this becoming an unofficial standard for client-server communication
    replacing JSON in the very near future.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both Micro and gRPC came out top in the evaluation, but for slightly different
    reasons. Micro is ready to use in a production system out of the box if the majority
    of your estate is Go. The development on Micro is continuing, and the current
    focus is on that of performance, which, to be honest, is already pretty impressive.
    That said, with some work around the missing elements which are essential for
    microservice development, grpC is a real contender. The polyglot nature and the
    throughput are excellent, and it is continuously improving.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have looked at a few different frameworks, and I hope they
    will have given you a taster of some of the key features needed if you ever have
    to make a decision yourself. In the next chapter, we are going to look at logging
    and metrics which are essential techniques for running microservices in production.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
