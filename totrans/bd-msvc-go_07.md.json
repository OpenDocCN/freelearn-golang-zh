["```go\nenvironment.host.service.group.segment.outcome \n\n```", "```go\nprod.server1.kittenserver.handlers.list.ok \nprod.server1.kittenserver.mysql.select_kittens.timing \n\n```", "```go\nfunc (h *list) ServeHTTP(rw http.ResponseWriter, r *http.Request) { \n  event := startTimingEvent(\"kittens.handlers.list.timing\", [\"production\", \"192.168.2.2\"]) \n  defer event.Complete() \n\n  dispatchIncrementEvent(\"kittens.handlers.list.called\", [\"production\", \"192.168.2.2\"]) \n\n... \n\n  if err != nil { \n    dispatchIncrementEvent(\"kittens.handlers.list.failed\", [\"production\", 192.168.2.2\"]) \n   return` \n  } \n\n  dispatchIncrementEvent(\"kittens.handlers.list.success\", [\"production\", 192.168.2.2\"]) \n} \n\n```", "```go\nkittens.handlers.*.failed \n\n```", "```go\n*.handlers.*.failed \n\n```", "```go\nstatsd, err := createStatsDClient(os.Getenv(\"STATSD\") \n  if err != nil { \n    log.Fatal(\"Unable to create statsD client\") \n  } \n... \n\nfunc createStatsDClient(address string) (*statsd.Client, error){ \n  return statsd.New(statsd.Address(address)) \n} \n\n```", "```go\nfunc New(opts ...Option) (*Client, error) \n\n```", "```go\ndefer h.statsd.NewTiming().Send(helloworldTiming) \n\n```", "```go\nfunc (c *Client) NewTiming() Timing \n\n```", "```go\nh.statsd.Increment(helloworldSuccess)    \n\n```", "```go\nfunc (c *Client) Increment(bucket string) \n\n```", "```go\nprometheus: \n   image: prom/prometheus \n   links: \n     - statsd \n   volumes: \n     - ./prometheus.yml:/etc/prometheus/prometheus.yml \n   ports: \n     - 9090:9090 \n\n```", "```go\nglobal: \n   scrape_interval:     15s \n\n scrape_configs: \n   - job_name: 'statsd' \n     static_configs: \n       - targets: ['statsd:9102'] \n\n   - job_name: 'prometheus' \n     static_configs: \n       - targets: ['localhost:9090'] \n\n```", "```go\ncurl [docker host ip]:8091/helloworld -d '{\"name\": \"Nic\"}'  \n\n```", "```go\nincrease(kittenserver_helloworld_success_counter{}[30s]) \n\n```", "```go\ntime.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) \n\n```", "```go\nfunc (c *correlationHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) { \n  if r.Header.Get(\"X-Request-ID\") == \"\" { \n    r.Header.Set(\"X-Request-ID\", uuid.New().String()) \n  }\n\n  c.next.ServeHTTP(rw, r)\n}\n\n```", "```go\nhttp.Handle(\"/helloworld\", handlers.NewCorrelationHandler(validation))\n\n```", "```go\nelasticsearch: \n   image: elasticsearch:2.4.2 \n   ports: \n     - 9200:9200 \n     - 9300:9300 \n   environment: \n     ES_JAVA_OPTS: \"-Xms1g -Xmx1g\" \n kibana: \n   image: kibana:4.6.3 \n   ports: \n     - 5601:5601 \n   environment: \n     - ELASTICSEARCH_URL=http://elasticsearch:9200 \n   links: \n     - elasticsearch \n logstash: \n   image: logstash \n   command: -f /etc/logstash/conf.d/ \n   ports: \n     - 5000:5000 \n   volumes: \n     - ./logstash.conf:/etc/logstash/conf.d/logstash.conf \n   links: \n     - elasticsearch \n\n```", "```go\ninput { \n   tcp { \n     port => 5000 \n     codec => \"json\" \n     type => \"json\" \n   } \n } \n\n## Add your filters / logstash plugins configuration here \noutput { \n  elasticsearch { \n    hosts => \"elasticsearch:9200\" \n  } \n} \n\n```", "```go\ncurl $(docker-machine ip):8091/helloworld -d '{\"name\": \"Nic\"}'  \n\n```", "```go\nstatus: 200 \n\n```", "```go\nstatus:200 and message:/.*\"Method\":\"POST\"/ \n\n```", "```go\nserializedRequest := serializeRequest(r) \nmessage, _ := json.Marshal(serializedRequest) \nh.logger.WithFields(logrus.Fields{ \n  \"handler\": \"HelloWorld\", \n  \"status\":  http.StatusOK, \n  \"method\":  serializedRequest.Method, \n}).Info(string(message)) \n\n```", "```go\n56 func createLogger(address string) (*logrus.Logger, error) { \n57  retryCount := 0 \n58 \n59  l := logrus.New() \n60  hostname, _ := os.Hostname() \n61  var err error \n62 \n63  // Retry connection to logstash incase the server has not yet come up \n64  for ; retryCount < 10; retryCount++ { \n65    hook, err := logstash.NewHookWithFields( \n66     \"tcp\", \n67  address, \n68  \"kittenserver\", \n69  logrus.Fields{\"hostname\": hostname}, \n70    ) \n71 \n72    if err == nil { \n73      l.Hooks.Add(hook) \n74      return l, err \n75    } \n76 \n77    log.Println(\"Unable to connect to logstash, retrying\") \n78    time.Sleep(1 * time.Second) \n79  } \n80 \n81  return nil, err \n82 } \n\n```", "```go\nfunc NewHookWithFields(protocol, address, appName string, alwaysSentFields logrus.Fields) (*Hook, error) \n\n```", "```go\nfunc AddHook(hook Hook) \n\n```", "```go\ntype SerialzableRequest struct { \n  *http.Request \n} \n\nfunc (sr *SerialzableRequest) ToJSON() string \n\n```", "```go\nfunc panic(v interface{}) \n\n```", "```go\nfunc recover() interface{} \n\n```", "```go\n18 func (p *panicHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) { \n19  defer func() { \n20    if err := recover(); err != nil { \n21  p.logger.WithFields( \n22  logrus.Fields{ \n23      \"handler\": \"panic\", \n24      \"status\":  http.StatusInternalServerError, \n25      \"method\":  r.Method, \n26      \"path\":    r.URL.Path, \n27      \"query\":   r.URL.RawQuery, \n28      }, \n29  ).Error(fmt.Sprintf(\"Error: %v\\n%s\", err, debug.Stack())) \n30 \n31  rw.WriteHeader(http.StatusInternalServerError) \n32   } \n33  }() \n34 \n35  p.next.ServeHTTP(rw, r) \n36 }   \n\n```", "```go\nfunc Stack() []byte \n\n```", "```go\ncurl -i [docker host ip]:8091/bang  \n\n```"]