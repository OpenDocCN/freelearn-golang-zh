<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>Security in microservices can feel like a minefield, and in some ways it is. This chapter is mainly intended to look at some of the things that you can do to improve the security of your Go code; however, I feel it is important to discuss some of the wider issues. In-depth discussion of topics such as firewall configuration is best left to specialist books; however, we will introduce some of the concepts and problems that are faced so that you can best prepare yourself for some further reading.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encryption and signing</h1>
                </header>
            
            <article>
                
<p>When we look at ways of securing data, either at rest or in transport, many of the methods we discuss will be cryptographically securing data.</p>
<div class="packt_quote">"Cryptography is the science of using mathematics to encrypt and decrypt data. Cryptography enables you to store sensitive information or transmit it across insecure networks (line like the internet) so that it cannot be read by anyone except the intended recipient."<br/>
- An Introduction to Cryptography, Network Associates, Inc.</div>
<p>As a basis for the things we will discuss in this chapter, we must first understand how cryptography works, not in the way that we need a mathematics degree, but to the extent of the parts involved. Cryptography is only as good as the security of the keys involved and we need the knowledge of which of these keys can be distributed freely and which ones need to be guarded with our lives.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Symmetric-key encryption</h1>
                </header>
            
            <article>
                
<p>Symmetric-key encryption is also called secret-key or conventional cryptography: one key is used for both the encryption and decryption of the data. For a remote end to be able to decrypt this information, it must first have the key, and this key must be securely held as a single compromise of one server will lead to the compromise of all servers who share this key. It can also make key management more complicated, as when you need to change the key, and you should change it often, you will need to roll this change out across your entire estate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Public-key cryptography</h1>
                </header>
            
            <article>
                
<p>Public-key cryptography was introduced by Whitfield Diffie and Martin Hellman in 1975 to get around the need for both sides requiring to know the secret. In fact, they were not the first to invent this; it was developed by the British Secret Service some years earlier but was kept a military secret.</p>
<p>Public-key cryptography uses a pair of keys for encryption; you will also hear it called asymmetric encryption. The public key is used for encrypting information while the private can only be used for decrypting. Because there is no way to determine the private key from the public, it is common that public keys will be published to the world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digital signatures</h1>
                </header>
            
            <article>
                
<p>Public-key cryptography also gives us the capability of using digital signatures. A digital signature works by encrypting a message with a private key and then transferring the signed message. If the message can be decrypted with the public key, then the message must have originated from the holder of a private key. Due to the computation time of encrypting messages and the increase in the size of the payload, a standard approach is to create a one-way hash of the message and then use the private key to encrypt this. The recipient will decrypt the hash with the public key and generate the same hash from the message; then, the message can be deemed to be from a trustworthy source.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">X.509 digital certificates</h1>
                </header>
            
            <article>
                
<p>One problem with public keys is that you must be careful that the key you think belongs to a recipient is owned by the recipient. If keys are transferred across public networks, there is always the possibility of a man-in-the-middle attack. An attacker could pose a fake public key as what you believe to be your trusted recipient; however, they could replace this with their keys. This would mean that the message you think has been transferred securely could, in fact, be decrypted and read by a malicious third party.</p>
<p>To avoid these issues, digital certificates exist, simplifying the task of establishing whether a public key belongs to the reported owner.</p>
<p>A digital certificate contains three things:</p>
<ul>
<li>A public key</li>
<li>Certificate information such as the owner's name or ID</li>
<li>One or more digital signatures</li>
</ul>
<p>The thing that makes a certificate trustworthy is the digital signatures. The certificate is signed by a trusted third party or certificate authority (CA) which vouches for your identity and that your public key belongs to you. Anyone can create a CA root certificate and sign their certs, and for non-public access to systems such as inter-microservice communication, this is quite a common practice. For public certificates, however, you pay a CA to sign your certificate. The purpose of the pricing is that the CA will ensure that you are who indeed you say you are; at present, the most popular CAs are Comodo, Symantec (previously Verisign before acquisition), and GoDaddy. The reason you see the padlock in your browser is not just because you are using secured communication but that your browser has validated the signature of the certificate against one of the 100 or so trusted third parties which come bundled with it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TLS/SSL</h1>
                </header>
            
            <article>
                
<p>SSL, which is the common term for secure transmission of data between two systems, is a reference to a deprecated standard first developed by Mozilla back in 1995. It has since been replaced by TLS 1.2, which was released in August 2008; while SSL 3.0 still technically works, it was deprecated in June 2015 after a vulnerability to the <strong>POODLE</strong> (<strong>Paddling Oracle On Downgraded Legacy Encryption</strong>) attack. The POODLE attack discovered by a team of Google security researchers in 2014 works by the attackers making several requests to a server; this data is then analyzed and used, which enables them to decrypt the data in the transport. On average, only 256 SSL 3.0 calls need to be made to decrypt 1 byte of information.</p>
<p>This means that the vulnerability existed for 18 years before being publicly disclosed; you might ask why people were still using SSL 3.0 15 years after the release of the stronger TLS 1.0? This came about due to a problem that some browsers and servers did not support TLS 1.0, so there was a fallback that which would allow fallback to a lower level of encryption. Even though, at the time of discovery, there was pretty much nobody still using SSL 3.0, the fallback was still in the protocol and was, therefore, exploitable by the hackers. The solution for this was quite straightforward: disable anything lower than TLS 1.0 in the configuration of your server. We have a little history of TLS and SSL but how does it keep your data secure?</p>
<p>TLS works using symmetrical encryption, where the client and the server both have a key which is used for encryption and decryption. If you remember the previous section, we introduced symmetrical encryption and the problems of distributing keys. TLS gets around this problem by using asymmetrical encryption in the first part of the handshake. The client retrieves the certificate containing the public key from the server and generates a random number; it uses the public key to encrypt this random number and sends it back to the server. Now that both parties have the random number, they use this to generate symmetrical keys which are used for encrypting and decrypting the data over the transport.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External security</h1>
                </header>
            
            <article>
                
<p>This is your first line of defense to keep your systems safe, it is commonly comprised of layer 2 or 3 firewalls, DDoS protection, web application firewalls, and other software and hardware. Before an attacker can compromise your application, they must first pass through these layers of hardware and software which is not part of your application code but is a shared infrastructure layer that many components in the application may share. In this section, we will look at some of this external security as well as some attacks that could be used against you. Securing the perimeter of your services is often a task completed by operations however as developers we need to understand the processes and risks as it greatly enhances our ability to harden our application code. In this section, we will look at the common methods of external security and also some of the ways hackers can exploit your system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layer 2 or 3 firewalls</h1>
                </header>
            
            <article>
                
<p>Layer 2 is more commonly used for routing as it deals purely with MAC addresses and not IP addresses whereas layer 3 is IP address aware. Traditionally, layer 2 was the only real way to go without adding latency as it would perform at roughly the same speed as the wire. With increases in processing power and memory, layer 3 now performs at wire speeds and generally, when we are looking at edge firewalls, which are generally the first entry point into your system, they will be layer 3 these days. So what does this give us? Firstly, it stops unwanted traffic at the edge: we limit the ports which are accessible to the outside world and traffic destined for something which is not allowed is stopped at the firewall and does not get the chance to execute an attack on the origin. In addition to this, it also allows us to restrict access to certain ports. For example, if you are running a server, you most likely will want some form of remote access such as SSH. The Heartbleed exploit which came out in 2015 took advantage of a vulnerability in OpenSSH, and SSH servers which were directly exposed to the Internet would be prone to this attack. Using a firewall effectively would mean that private ports such as SSH would be locked down to an IP address or IP range, which could be your VPN, office IP, or public IP. This dramatically reduces the attack vector so while you might be running a version of OpenSSH which is vulnerable to Heartbleed, for an attacker to take advantage of this, they would need to be inside of your protected zone.</p>
<p>The Heartbleed vulnerability exploited the ability to execute a buffer overrun attack. For example, you ask the server for a 4-letter word but specify the length of 500; what you get back is the 4-letter word, and the remaining 496 characters are the blocks of memory which follow the memory address of the initial allocation. In practice, this allowed a hacker to access chunks of memory in the server randomly; this may contain items, such as change password requests, which give them credentials to access the server. If you are running a globally available SSH server, then you may find you have a problem:</p>
<div class="CDPAlignCenter CDPAlign"><img height="677" width="318" class=" image-border" src="assets/6c128381-747f-4ba7-8e96-be61fe250825.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web application firewall</h1>
                </header>
            
            <article>
                
<p>A web application firewall (<strong>WAF)</strong> is configured as your second or third line of defense in a system. To understand what a WAF is, let's look at the definition from the Open Web Application Security Project (OWASP):</p>
<div class="packt_quote">"A web application firewall (WAF) is an application firewall for HTTP applications. It applies a set of rules to an HTTP conversation. These rules cover common attacks such as cross-site scripting (XSS) and SQL injection.</div>
<div class="packt_quote">While proxies protect clients, WAFs protect servers. A WAF is deployed to protect a specific web application or set of web applications. A WAF can be considered a reverse proxy.</div>
<div class="packt_quote">WAFs may come in the form of an appliance, server plugin, or filter, and may be customized to an application. The effort to perform this customization can be significant and needs to be maintained as the application is modified."</div>
<p>OWASP is an incredibly useful resource and in fact has provided a core ruleset for ModSecurity, which protects against attacks such as SQL Injection XSS, Shellshock. As a bare minimum, setting up a WAF such as ModSecurity and the OWASP CRS should be your minimum requirement. Hosting this inside a Docker container should be relatively trivial, and this could form the second line of defense behind your layer 2 firewall.</p>
<p>There is also another option: some CDN companies such as Cloudflare offer a hosted WAF. This is protection at the edge of your network and thanks to the expertise of businesses such as Cloudflare, you do not need to worry about configuration. In fact, Cloudflare supports the OWASP CRS (<a href="https://www.modsecurity.org/crs/"><span class="URLPACKT">https://www.modsecurity.org/crs/</span></a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API Gateway</h1>
                </header>
            
            <article>
                
<p>In addition to a WAF, an API Gateway can be a useful tool to have; this can serve a dual purpose of routing your public APIs to their backend services and some additional features such as token validation at the edge and input validation and transformation. When we talked about the confused deputy problem, where an attacker who is behind your firewall can execute commands which they are not privileged to do, we looked at the possibilities for encrypting web tokens; the problem with this is that private keys for decrypting these tokens would need to be distributed across multiple backend services. This makes managing keys far more challenging than it should be. An API Gateway can simplify this situation by being the only layer which can decrypt a message; the other services use the public key to verify a signature. API Gateways often implement many other first-line features such as but not limited to the following:</p>
<ul>
<li>Request validation</li>
<li>Authorization</li>
<li>Rate limiting</li>
<li>Logging</li>
<li>Caching</li>
<li>Request and response transformations</li>
</ul>
<p>There is an element of crossover between a WAF and an API Gateway; however, the two should be treated as two distinctly separate parts of your infrastructure. Regarding providers of an API Gateway, this seems to be a developing area; AWS has an advanced API Gateway which can be used if you have bought into the AWS PaS environment. For standalone deployments, Kong (<a href="https://getkong.org/"><span class="URLPACKT">https://getkong.org/</span></a>), Tyk (<a href="https://tyk.io/"><span class="URLPACKT">https://tyk.io/</span></a>), Apigee (<a href="https://apigee.com/api-management/#/homepage"><span class="URLPACKT">https://apigee.com/api-management/#/homepage</span></a>), Mashery (<a href="https://www.mashery.com/"><span class="URLPACKT">https://www.mashery.com/</span></a>), and the Anypoint Platform from Mulesoft (<a href="https://www.mulesoft.com/"><span class="URLPACKT">https://www.mulesoft.com/</span></a>) are among the leaders in this field. It is, of course, possible to build your own API Gateway backed with Nginx or HAProxy; however, I recommend, you first check out one of the specific platforms before going ahead and building your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DDoS protection</h1>
                </header>
            
            <article>
                
<p>On October 21, 2016, a massive internet outage was caused by attackers targeting DYN's DNS servers using a Mirai botnet. The Mirai exploit takes advantage of vulnerabilities in IP cameras and DVRs made by the Chinese company called XionMai Technologies. Rather than attacking a target, the attackers decided to take down a major part of the internet's infrastructure, knocking out most of the east and west coast of America. The Mirai exploit takes advantage of just 60 usernames and passwords to attempt to update the firmware of the vulnerable devices. Once the malware had been installed, the device was then controllable by the botnet. All that was left to do was tell the bots to start a DNS attack against DYNs nameservers.</p>
<p>The code for Mirai has been published online; you can find it using Google without much effort. The thing I hope you find surprising looking at this code is just how simple it is. Now, I do not want to take anything away from the complexity of devising this attack; I am merely talking about the implementation. Quite a significant portion of the code is written in Go too, so is very readable. There is some excellent use of channels. If you do look at the code, try and identify the area which could be improved with a semaphore.</p>
<p>A report published by Akamai stated that 98.34% of all attacks this year were infrastructure oriented, with only 1.66% aiming for the application layer. Of that 98.34%, many could be avoided with a little network hygiene. Let's look at the top threats and how they work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of DDoS attack</h1>
                </header>
            
            <article>
                
<p>The following are the types of DDos attack:</p>
<ul>
<li>UDP fragment</li>
<li>DNS</li>
<li>NTP</li>
<li>Chargen</li>
<li>UDP</li>
<li>SYN</li>
<li>SSDP</li>
<li>ACK</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UDP fragment attack</h1>
                </header>
            
            <article>
                
<p>A UDP fragment attack is where the attacker exploits the way that datagram fragmentation works on networks. Every network has a limit called a maximum transmission unit (MTU). If a datagram sent to the network is greater than the MTU, it is fragmented to be transmitted successfully.</p>
<p>The UDP fragment attack works by creating datagrams which contain fake packets; when the server attempts to reassemble these packets, it is unable to do so and the resources are quickly overwhelmed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UDP flood</h1>
                </header>
            
            <article>
                
<p>A UDP flood attack works by sending a flood of UDP packets with a spoofed source address to an IP address. The server will respond to these requests, sending a reply to the spoofed addresses. Due to the high volume of the attack, a router will exceed its limit of UDP datagrams per second and stop sending to all addresses in the same security zone for a period.</p>
<p>This also often utilizes a technique called a reflected attack. When the IP address for the source is spoofed, the return packets are not sent back to the real source but the spoofed IP address. The reason this technique is used is that it allows the sender to amplify an attack by only expending resources on the outbound packets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DNS</h1>
                </header>
            
            <article>
                
<p>A DNS attack utilizes a UDP flood to take out a DNS server; many requests are made to query a DNS server. The requests are designed to return a very large reply from a tiny request to maximize the efficiency of the attack since the response is often not received by the sender.</p>
<p>The attack which we looked at earlier, which targeted Dyn's infrastructure, taking out many websites on the east and west coast of America in October 2016, was in the form of this attack. Unlike most DNS attacks, the Miraia net did not use Reflection, it allowed the responses to be returned to the sender, which was possible due to the enormous number of compromised devices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NTP</h1>
                </header>
            
            <article>
                
<p>NTP is another amplification attack which takes advantage of a feature built into NTP servers, which returns up to the last 600 machines that have interacted with it. This attack takes advantage of open NTP servers which support the MONLIST command and have not been patched. The project <a href="http://openntpproject.org/">http://openntpproject.org/</a> aims to identify unpatched servers to encourage the removal of this exploit. Unfortunately, research carried out in 2014 by NSFOCUS found that there were over 17,000 servers worldwide which were vulnerable to the exploit. Assuming all these servers could be used and using payload sizes from an NTP attack which hit CloudFlare in 2014, we have the capability of a DDoS attack of 1.4 Tbps. This traffic would be twice the biggest attack known today. NTP provides a platform for one of the most powerful application attacks and only exists due to poorly patched servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CHARGEN</h1>
                </header>
            
            <article>
                
<p>A <strong>CHARGEN</strong> (<strong>Character Generation Protocol</strong>) attack is another reflected amplification attack. The attack takes advantage of open CHARGEN servers which, running on port <kbd>19</kbd>, will return a random number of characters between 0 and 512 in length every time it receives a datagram from the connecting host. CHARGEN is designed to be used as a source of byte-stream for debugging TCP network code and bandwidth measurement. CHARGEN attacks work by abusing CHARGEN servers which have been enabled on network-connected printers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SYN flood</h1>
                </header>
            
            <article>
                
<p>A SYN flood is a classic DDoS attack that sends a lot of packets to a machine, attempting to keep connections from being closed. The connections eventually time out on the server side; however, the aim is to repeatedly hit the server, consuming all the available resources so genuine connections cannot get through.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SSDP</h1>
                </header>
            
            <article>
                
<p>SSDP is the <strong>Simple Service Discovery Protocol</strong>, often used for the discovery of <strong>Plug &amp; Play</strong> (<strong>UPnP</strong>) devices. This is exactly the protocol implemented by your home router, so next time you complain that your favorite gaming network is offline, why not first check that you are not inadvertently exposing SSDP to the internet?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ACK</h1>
                </header>
            
            <article>
                
<p>An ACK flood takes advantage of the three-way handshake that exists when a client connects to a server. The first step is the client sends an SYN packet to which an SYN-ACK packet is replied from the server. The client then finally replies with an ACK packet and then the connection is open for data. An ACK flood takes one of two forms:</p>
<ul>
<li>The attacker sends a spoofed SYN packet to a server and then follows this with a spoofed SYN-ACK packet. The server then opens and holds open a connection. If enough connections are open, then the server will eventually run out of resources.</li>
<li>The second method is only to send the ACK packet. Since the server does not have an open connection, this packet will be dropped; however, it still consumes resources having to process these packets.</li>
</ul>
<p>The attack is similar to a SYN attack; however, it can be more efficient due to the way it tricks DDoS filters to pass the packets to the server.</p>
<p>Avoiding these attacks is not so simple: you need to detect and filter this activity at the edge of your network. You also require massive amounts of bandwidth to soak up the traffic inbound to your system, and this is not, in my opinion, something that can or should be tackled by an in-house solution.</p>
<p>The first line of defense to avoiding DDoS attacks is to make sure you are not enabling them. Configuring a firewall to ensure you are not exposing vulnerable services and patching your services will mean an attacker cannot use your network infrastructure to attack others. The second line is to leverage the power of Cloudflare, Akamai, Imperva, or the other experts who have the infrastructure and network scrubbing filters to ensure the traffic never gets to your server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application security</h1>
                </header>
            
            <article>
                
<p>We now, hopefully, understand some of the ways that encryption works and some of the ways that our infrastructure is vulnerable, but what about our application? It is entirely plausible that someone will want to break into your system. While a DDoS attack might cause you some inconvenience for a day or so, a hacker who gets past your firewall and into your application servers could cause serious financial or reputational damage. The first thing we need to do is to operate on a principle of no trust. David Strauss, in his talk, <em>Don't build "Death Star" security</em> (2016 O'Reilly software architecture conference) looked at the WikiLeaks website and concluded that it was not the first line of defense which fell, but the attackers were able to gain access to various backend systems.</p>
<p>At the same conference, Sam Newman, who wrote the excellent <em>Microservices</em> book (which I encourage everyone to read if they have not yet), was also giving a talk on the <em>Application Security and Microservices</em>. Sam stated that <em>Microservices give us the capability for multiple perimeters</em>; while this can be a benefit, it can also cause problems. He suggested a model for microservices security which is used by ThoughtWorks; this advises that you follow the following four steps:</p>
<ul>
<li>Prevention</li>
<li>Detection</li>
<li>Response</li>
<li>Recovery</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prevention</h1>
                </header>
            
            <article>
                
<p>Prevention is where you should spend the most of your effort, and the remainder of this chapter will concentrate on just that. This is implementing techniques for secure communication, authorization, and authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Detection</h1>
                </header>
            
            <article>
                
<p>Detection relates to your application logs and ModSecurity logs if you are using it. We discussed in the previous chapter some methods for logging in your system, and I suggest you think about the type of logging you will need to detect malicious intent, not just for fault finding. This should form part of your non-functional requirements when you are planning a feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Response</h1>
                </header>
            
            <article>
                
<p>The response is how you tackle the breach: if an incident occurs, you need to deal with it immediately. This not only involves closing the attackers out of the system but also identifying what has been taken and in the case of personal information or credit card loss, contacting your customers and being open about the problem. Think about what your company does about fire drills in case of fire. You practice so that, in the event there is a fire, everyone knows what to do and how to react quickly. Game days are standard practice for a few companies, where they will rehearse disaster recovery situations. If you intend to practice your response process, you need to ensure that the whole business is involved; while tech will be included in the diagnostic and rectification of the problem, there needs to be involvement on a business level, legal, PR, and communications for this to be truly useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recovery</h1>
                </header>
            
            <article>
                
<p>The recovery process should be the simplest step, assuming your infrastructure is well backed up and automated. Sam suggests not taking any chances and <em>burning it down</em>, rebuilding with new keys and passwords to avoid a further attack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Confused deputy</h1>
                </header>
            
            <article>
                
<p>The confused deputy problem is where one system can abuse the trust another system has and will execute a command which it would not ordinarily be allowed to do. Consider a system which issues refunds inside of your system; you think that the system is safe as it is a private API sitting behind your firewall, but what if an attacker manages to compromise your firewall? If they can detect that sending a <kbd>POST</kbd> request with a payload to a server will refund money to a bank or PayPal account then they do not even need to attempt to attack further into your infrastructure to get their payday. This scenario is all too common; when building systems, we place too much trust on the external defenses and run a principle of trust for anything that sits behind the firewall. You also may be assuming that the attacker is actually outside your organization; what if they have access to the servers legitimately? In the USA, internal fraud accounts for XXX of financial losses; we need to build systems which make this situation difficult and we need to make sure that we have a full audit trail of access and operation. It does not need to be a difficult challenge to solve; we will see two very simple ways that we can counter this problem which when implemented will neither cause you additional development time or operational time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How an attacker could bypass the firewall</h1>
                </header>
            
            <article>
                
<p>You are probably a little confused as to why the internal security of services matters; after all, you have a great firewall, and all of the ports which should be are locked down.</p>
<p>An attacker has multiple tools in their arsenal to bypass your security systems. We are not talking about people attempting to leverage existing exploits using tooling found on the internet. We are talking about sophisticated and intelligent hackers who, for whatever reason, are intent on causing harm to your company.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scenario</h1>
                </header>
            
            <article>
                
<p>You are an e-commerce platform built utilizing the latest microservices architectural patterns. Your application code is running in Docker containers and you are hosting everything on AWS with Kubenetes. The front end of the system is a simple Node.js application which talks to a variety of private APIs to provide many of the transactional capabilities on the site. The application itself does not have a database and there are no secrets stored in the container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attack</h1>
                </header>
            
            <article>
                
<p>An attacker finds a remote code execution vulnerability in the templating engine used for the front end presentation. They discover that the system is running on Kubenettes and that the control API is available inside the compromised container. They use this API to be able to launch a rogue container on your network which, running in privileged mode, starts a reverse SSH tunnel to the attacker's remote server, which completely bypasses the firewall and gives them root access to the container. From here, they sniff the traffic on the network and determine that the payment gateway has <kbd>POST</kbd> endpoint v1/refunds; by sending a JSON payload to this endpoint, it is possible to refund huge amounts of money to an offshore bank account.</p>
<p>Even though the firewall was protecting inbound traffic and only ports <kbd>80</kbd> and <kbd>443</kbd> were allowed inbound, the attacker leveraged a vulnerability inside the application to be able to create a backdoor for themselves. The nonexistent security around launching applications inside the production environment and open non-encrypted communication between the services gave them all they needed to empty the company's bank account.</p>
<p>This is a very real threat, but thankfully Go has many excellent tools to help us make it tough for an attacker.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Input validation</h1>
                </header>
            
            <article>
                
<p>In our scenario, the attacker used a remote code execution exploit to gain access to our environment. The first line of defense after the WAF is input validation. All data should be validated to set bounds; it does not take an enormous amount of time to implement and can help you protect against such an attack. There is an excellent library in Go which is part of the go-playground package (<a href="https://github.com/go-playground/validator"><span class="URLPACKT">https://github.com/go-playground/validator</span></a>).</p>
<p>Take a look at this simple code example to see just how easy it is to implement:</p>
<p><kbd>validation/main.go</kbd></p>
<pre>
3 // Request defines the input structure received by a http handler 
4 type Request struct { 
5  Name  string `json:"name"` 
6  Email string `json:"email" validate:"email"` 
7  URL   string `json:"url" validate:"url"` 
8 } 
</pre>
<p>The nice thing about the validator package is that it works with field tags, which is an unobtrusive way of keeping your code clean. By adding the validate tag, we can specify one of many different validation functions for the field, including email, URL, IP addresses, minimum and maximum length, and event regular expressions. It is also possible to have multiple validators on the same field. For example, should I wish to validate that my input is an email and has a minimum length of three, I could add the following:</p>
<pre>
validate: "email,min=3" 
</pre>
<p>The validators process in the listed order, so the validation function to check whether the field contained an email would be validated before checking the length.</p>
<p>Using the package is also incredibly simple: if we take a look at the example from our tests, we can see that validation is actually only one method call:</p>
<pre>
 9 func TestErrorWhenRequestEmailNotPresent(t *testing.T) { 
10  validate := validator.New() 
11  request := Request{ 
12    URL: "http://nicholasjackson.io", 
13  } 
14 
15  if err := validate.Struct(&amp;request); err == nil { 
16    t.Error("Should have raised an error") 
17  } 
18 } 
</pre>
<p>In its simplest form, all we need to do to validate a request are two method calls. First, we create a new validator like in line 10 using the <kbd>New</kbd> function:</p>
<pre>
func New() *Validate 
</pre>
<p>The <kbd>New</kbd> function returns a new instance of <kbd>validate</kbd> with sane defaults.</p>
<p>Then we can call the <kbd>validate</kbd> method to check that our structure is valid:</p>
<pre>
func (v *Validate) Struct(s interface{}) (err error) 
</pre>
<p>The <kbd>Struct</kbd> function validates a struct's exposed fields, and automatically validates nested structs, unless otherwise specified.</p>
<p>It returns <kbd>InvalidValidationError</kbd> for bad values passed in and nil or <kbd>ValidationErrors</kbd> as error otherwise. You will need to assert the error if it's not nil, for example, <kbd>err.(validator.ValidationErrors)</kbd> to access the array of errors.</p>
<p>If the struct has validation errors, <kbd>Struct</kbd> will return an error; to get detailed messages for the error, we can cast the error to a <kbd>ValidationErrors</kbd> object, which is a collection of <kbd>FieldError</kbd>. To see all the available methods for the <kbd>FieldError</kbd> object, check out the godoc (<a href="https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError"><span class="URLPACKT">https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError</span></a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fuzzing</h1>
                </header>
            
            <article>
                
<p>Of course, we should also beef up our testing techniques. One highly effective way of testing the bounds of input validation is to use a fuzzer inside our tests; this just broadens the scope of what we are testing to make sure we have all the edge cases covered. A potential attacker will most likely use this technique to test the boundary of your API so why not get the edge on them and make sure all of your input is correctly handled?</p>
<p>One of the most popular implementations of a fuzzer in Go is the excellent package <kbd>github.com/dvyukov/go-fuzz/go-fuzz</kbd>. The <kbd>go-fuzz</kbd> is a coverage guided fuzzer, it uses an instrumented build of your application code exposing the code coverage which it uses to ensure that the maximum code paths are covered. The fuzzer generates random input the intent behind which is to either crash the application or to produce unexpected output. Fuzzing is an advanced topic however in the code samples for this chapter at <kbd>validation/fuzzer</kbd> you can find an example of how to fuzz the validation handler we have just covered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TLS</h1>
                </header>
            
            <article>
                
<p>The other exploit that our attacker took advantage of was that all of the traffic behind the firewall was not encrypted and by sniffing the traffic between services, they discovered a method to fake a call to the payments gateway to send a refund to a remote bank account. The other issue might be that you are passing sensitive information such as bank details or credit card numbers between your frontend service and your payment service. Even if you are not storing the credit card numbers on your system, if you are not careful, you could expose this traffic to an attacker by assuming that everything behind your firewall is safe. TLS or Transport Layer Security no longer adds any overhead due to the advances in processing power available to servers these days. In addition to this, services inside a firewall generally have a limited number of connections; so, to improve the time that is lost by the TLS handshake, you can use persistent reusable connections in your service to minimize this problem. Let's take a look at how we can implement TLS really quickly in Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating private keys</h1>
                </header>
            
            <article>
                
<p>Before we do anything, we need to generate a key and a certificate. Go actually has a pretty awesome utility which can generate keys and certificates for us only in Go but before we look at that, let's take a look at how we would traditionally generate a certificate using <kbd>openssl</kbd>:</p>
<pre>
<strong>openssl genrsa -aes256 -out key.pem 4096</strong>  
</pre>
<p>This will generate us a key in PEM format, which uses the RSA algorithm with a 4096 bit size; the key will be encrypted using the aes256 format and will prompt you for a password. However, we also need an X.509 certificate which will be used with this key; to generate this, we can again use <kbd>openssl</kbd> and execute the following command:</p>
<pre>
<strong>openssl req -new -x509 -sha256 -key key.pem -out certificate.pem -days 365</strong>  
</pre>
<p>This command will use the key to generate the certificate again in PEM format with a validity of one year. In practice, we should not generate certificates which have such a long lifespan for our internal services. Since we control the deployment of the services, we should try to rotate keys as often as possible. The other thing to note about this certificate is that while it is valid and secure, it will not be trusted by clients automatically. This is because the root is auto-generated instead of coming from a trusted authority. This is fine for internal use; however, if we need the service to be public facing we would need to ask a trusted source to generate our certificate.</p>
<p>Now we know how to do this with the <kbd>openssl</kbd> command-line tool, let's see how we could achieve the same thing using only the Go crypto libraries. The example application, which can be found at <a href="https://golang.org/src/crypto/tls/generate_cert.go"><span class="URLPACKT">https://golang.org/src/crypto/tls/generate_cert.go</span></a>, gives us the details for this. Let's now take a look at the process step by step.</p>
<p>If we take a look at the example in <kbd>tls/generate_keys</kbd>, we can see that we are using the <kbd>GenerateKey</kbd> method from the <kbd>crypto/edcsa</kbd> package:</p>
<pre>
120 func generatePrivateKey() *rsa.PrivateKey { 
121  key, _ := rsa.GenerateKey(rand.Reader, 4096) 
122  return key 
123 } 
</pre>
<p>The signature for the <kbd>GenerateKey</kbd> method on line <strong>120</strong> is as follows:</p>
<pre>
func GenerateKey(rand io.Reader, bits int) (*PrivateKey, error) 
</pre>
<p>The first parameter is an I/O reader which will return random numbers; for this, we are using the <kbd>rand.Reader</kbd> method, which is a global shared instance of a cryptographically strong pseudo-random generator. On Linux, this will use <kbd>/dev/urandom</kbd> and on Windows, <kbd>CryptGenRandomAPI</kbd>. The second is the bit size to use: bigger is more secure but will result in slower encryption and decryption operations.</p>
<p>In order to serialize the key to a file, we need to run through a few different operations:</p>
<pre>
191 func savePrivateKey(key *rsa.PrivateKey, path string, password []byte) error { 
192  b := x509.MarshalPKCS1PrivateKey(key) 
193  var block *pem.Block 
194  var err error 
195 
196  if len(password) &gt; 3 { 
197    block, err = x509.EncryptPEMBlock(rand.Reader, "RSA PRIVATE  <br/>KEY", b, password, x509.PEMCipherAES256) 
198    if err != nil { 
199      return fmt.Errorf("Unable to encrypt key: %s", err) 
200    } 
201  } else { 
202    block = &amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: b} 
203  } 
204 
205  keyOut, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600) 
206  if err != nil { 
207    return fmt.Errorf("failed to open key.pem for writing: %v", err) 
208  } 
209 
210  pem.Encode(keyOut, block) 
211  keyOut.Close() 
212 
213  return nil 
214 } 
</pre>
<p>On line <strong>192</strong>, we are taking the <kbd>PrivateKey</kbd> reference that is returned from the <kbd>GenerateKey</kbd> function and we need to convert it into a slice of bytes so that we can serialize this to disk. The <kbd>crypto/x509</kbd> package has many useful functions to enable operations like this; the one that we need to use is <kbd>MarshalPKCS1PrivateKey</kbd>, which will marshal our RSA-based private key into ASN.1, DER format:</p>
<pre>
func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) ([]byte, error) 
</pre>
<p>Once we have the key in byte format, we are ready to be able to write it to the file; however, just writing the bytes to a file is not enough; we need to be able to write it in PEM format, which looks like the following example:</p>
<pre>
-----BEGIN RSA PRIVATE KEY----- 
Proc-Type: 4,ENCRYPTED 
DEK-Info: AES-256-CBC,c4e4be9d17fcd2f44ed4c7f0f6a9b7a8 
 
cfsmkm4ejLN2hi99TgxXNBfxsSQz6Pz8plQ2HJ1XToo8uXGALFlA+5y9ZLzBLGRj 
... 
zVYQvWh5NytrP9wnNogRsXqAufxf4ZLehosx0eUK4R4PsMy/VTDvcNo9P3uq2T32 
 
-----END RSA PRIVATE KEY----- 
</pre>
<p>The format for this file is as shown in the following code, and while we could manually create this file, the crypto library in Go has us covered:</p>
<pre>
-----BEGIN Type----- 
Headers 
base64-encoded Bytes 
-----END Type----- 
</pre>
<p>We also need to keep our private keys safe, so if a password is specified, we are going to encrypt the key like we were doing with the command-line option. In line <strong>196</strong>, we are checking to see whether a password has been specified and, if so, we are calling the method:</p>
<pre>
func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error) 
</pre>
<p>This method returns a PEM block for the given DER encoded data which is encrypted with the given password. The algorithm we are using in our example is AES256; however, Go also supports the following ciphers:</p>
<pre>
const ( 
        PEMCipherDES PEMCipher 
        PEMCipher3DES 
        PEMCipherAES128 
        PEMCipherAES192 
        PEMCipherAES256 
) 
</pre>
<p>If we do not want to encrypt the key with a password then we need to do something slightly different. In line <strong>202</strong>, we need to create the PEM block ourselves; the <kbd>pem</kbd> package provides this capability for us with the following struct:</p>
<pre>
type Block struct { 
        Type    string            // The type, taken from the preamble (i.e. "RSA PRIVATE KEY"). 
        Headers map[string]string // Optional headers. 
        Bytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure. 
} 
</pre>
<p>Whether we are using an encrypted PEM block or unencrypted, we use this with the <kbd>Encode</kbd> function on the same package which will convert our data into the correct format:</p>
<pre>
func Encode(out io.Writer, b *Block) error 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating X.509 certificates</h1>
                </header>
            
            <article>
                
<p>Now that we have a private key, we can go ahead and generate our certificate. We have already seen how easy this is to create with <kbd>openssl</kbd> and it is just as easy in Go:</p>
<pre>
125 func generateX509Certificate( 
126  key *rsa.PrivateKey, 
127  template *x509.Certificate, 
128  duration time.Duration, 
129  parentKey *rsa.PrivateKey, 
130  parentCert *x509.Certificate) []byte { 
131 
132  notBefore := time.Now() 
133   notAfter := notBefore.Add(duration) 
134 
135  template.NotBefore = notBefore 
136  template.NotAfter = notAfter 
137 
138  serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128) 
139  serialNumber, err := rand.Int(rand.Reader, serialNumberLimit) 
140  if err != nil { 
141    panic(fmt.Errorf("failed to generate serial number: %s", err)) 
142  } 
143 
144  template.SerialNumber = serialNumber 
145 
146  subjectKey, err := getSubjectKey(key) 
147  if err != nil { 
148    panic(fmt.Errorf("unable to get subject key: %s", err)) 
149  } 
150 
151  template.SubjectKeyId = subjectKey 
152 
153  if parentKey == nil { 
154    parentKey = key 
155  } 
156 
157  if parentCert == nil { 
158    parentCert = template 
159  } 
160 
161  cert, err := x509.CreateCertificate(rand.Reader, template, parentCert, &amp;key.PublicKey, parentKey) 
162  if err != nil { 
163    panic(err) 
164  } 
165 
166  return cert 
167 } 
</pre>
<p>We are passing in a few parameters into this method. One of the first, which might be a little strange, is the template. Because we need to generate different kinds of certificate, such as those which can sign other certificates to create a chain of trust, we need to create a template to use which has some of the defaults populated. If we look at the <kbd>rootTemplate</kbd>, which is defined at line <strong>22</strong>, we can examine some of these options:</p>
<pre>
22 var rootTemplate = x509.Certificate{ 
23  Subject: pkix.Name{ 
24    Country:            []string{"UK"}, 
25    Organization:       []string{"Acme Co"}, 
26    OrganizationalUnit: []string{"Tech"}, 
27    CommonName:         "Root", 
28  }, 
29 
30  KeyUsage: x509.KeyUsageKeyEncipherment | 
31    x509.KeyUsageDigitalSignature | 
32    x509.KeyUsageCertSign | 
33    x509.KeyUsageCRLSign, 
34  BasicConstraintsValid: true, 
35  IsCA: true, 
36 } 
</pre>
<p>Subject, which is an instance of the <kbd>pkix.Name</kbd> struct, has the following fields:</p>
<pre>
type Name struct { 
        Country, Organization, OrganizationalUnit []string 
        Locality, Province                        []string 
        StreetAddress, PostalCode                 []string 
        SerialNumber, CommonName                  string 
 
        Names      []AttributeTypeAndValue 
        ExtraNames []AttributeTypeAndValue 
} 
</pre>
<p>These are the common elements of the X.509 distinguished name; most of these elements are straightforward and represent the details of the owner of the certificate. <kbd>SerialNumber</kbd> is one of the most important. The serial number must be unique for a certificate chain; however, it does not need to be sequential. If we look at our example in line <strong>138</strong>, we are generating a large random integer 128 bits in length but you can change this to be anything you like.</p>
<p>The next interesting bit of our certificate generation is the <kbd>SubjectKey</kbd>; this is required for the chain of trust to work correctly. If a certificate is signed by another then the Authority Key Identifier will match the parent certificate's Subject Key Identifier:</p>
<pre>
X509v3 Subject Key Identifier: 
                5E:18:F9:33:BB:7B:E0:73:70:A5:3B:13:A8:40:38:3E:C9:4C:B4:17 
X509v3 Authority Key Identifier: 
                keyid:72:38:FD:0F:68:5C:66:77:C0:AF:CB:43:C7:91:4C:5A:DD:DC:4D:D8 
</pre>
<p>To generate the subject keys, we need to serialize the public version of the key into DER format, and then extract the bytes for just the key part:</p>
<pre>
174 func getSubjectKey(key *rsa.PrivateKey) ([]byte, error) { 
175  publicKey, err := x509.MarshalPKIXPublicKey(&amp;key.PublicKey) 
176  if err != nil { 
177    return nil, fmt.Errorf("failed to marshal public key: %s", err) 
178  } 
179 
200  var subPKI subjectPublicKeyInfo 
201  _, err = asn1.Unmarshal(publicKey, &amp;subPKI) 
202  if err != nil { 
203    return nil, fmt.Errorf("failed to unmarshal public key: %s", err) 
204  } 
205 
206  h := sha1.New() 
207  h.Write(subPKI.SubjectPublicKey.Bytes) 
208  return h.Sum(nil), nil 
209 } 
</pre>
<p>In line <strong>174</strong>, we are converting the public key into a byte array using the <kbd>MarshalPKIXPublicKey</kbd> function on the <kbd>x509</kbd> package:</p>
<pre>
func MarshalPKIXPublicKey(pub interface{}) ([]byte, error) 
MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format. 
</pre>
<p>This returns us a byte array which represents an ASN.1 data structure; to get access to the underlying data for the key, we need to unmarshal it into the struct format which is defined at line <strong>169</strong>:</p>
<pre>
169 type subjectPublicKeyInfo struct { 
170  Algorithm        pkix.AlgorithmIdentifier 
171  SubjectPublicKey asn1.BitString 
172 } 
</pre>
<p>To perform this conversion, we can use the <kbd>Unmarshal</kbd> function, which is on the package <kbd>encoding/asn1</kbd>. This method attempts to convert the ASN.1 data format:</p>
<pre>
func Unmarshal(b []byte, val interface{}) (rest []byte, err error) 
Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. 
</pre>
<p>Finally, in line <strong>161</strong>, we can create the certificate, using the <kbd>CreateCertificate</kbd> method on the <kbd>crypto/x509</kbd> package. This method accepts a parent certificate, which will be used to sign the child. For our root certificate, we want this to be self-signed so we set both the parent certificate and the private key to the root certificate's private key and template. For the intermediate and leaf certificates, we would use the parent's details for this:</p>
<pre>
func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error) 
</pre>
<p>The <kbd>CreateCertificate</kbd> function creates a new certificate based on a template. The following members of the template are used: <kbd>SerialNumber</kbd>, <kbd>Subject</kbd>, <kbd>NotBefore</kbd>, <kbd>NotAfter</kbd>, <kbd>KeyUsage</kbd>, <kbd>ExtKeyUsage</kbd>, <kbd>UnknownExtKeyUsage</kbd>, <kbd>BasicConstraintsValid</kbd>, <kbd>IsCA</kbd>, <kbd>MaxPathLen</kbd>, <kbd>SubjectKeyId</kbd>, <kbd>DNSNames</kbd>, <kbd>PermittedDNSDomainsCritical</kbd>, <kbd>PermittedDNSDomains</kbd>, and <kbd>SignatureAlgorithm</kbd>.</p>
<p>The certificate is signed by parent. If the parent is equal to template then the certificate is self-signed. The parameter <kbd>pub</kbd> is the public key of the signee and <kbd>priv</kbd> is the private key of the signer.</p>
<p>Now we have certificates, let's see how we can secure a web server using TLS. Back in <a href="ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Introduction to Microservices</em>, you may remember being introduced to <kbd>http.ListenAndServe</kbd> from the standard HTTP package, which started an HTTP web server. Go, of course, has an equally amazing package for creating a web server which is secured with TLS. In fact, it is only two more parameters than the standard <kbd>ListenAndServe</kbd>:</p>
<pre>
func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error 
</pre>
<p>All we need to do is pass the paths to our certificate and the corresponding private key and the server when started will serve traffic using TLS. If we are using self-signed certificates, and in our example we are, then we need to write some additional code for our clients, otherwise when we try to make a connection to the server, we will get an error message like the following:</p>
<pre>
2017/03/19 14:29:03 Get https://localhost:8433: x509: certificate signed by unknown authority 
exit status 1 
</pre>
<p>To avoid this, we need to create a new cert pool and pass this to the client's TLS settings. By default, Go will use the host's root CA set, which will not include our self-signed certificates:</p>
<pre>
13 roots := x509.NewCertPool() 
14 
15 rootCert, err := ioutil.ReadFile("../generate_keys/root_cert.pem") 
16 if err != nil { 
17  log.Fatal(err) 
18 } 
19 
20 ok := roots.AppendCertsFromPEM(rootCert) 
21 if !ok { 
22   panic("failed to parse root certificate") 
23 } 
24 
25 applicationCert, err := ioutil.ReadFile("../generate_keys/application_cert.pem") 
26 if err != nil { 
27  log.Fatal(err) 
28 } 
29 
30 ok = roots.AppendCertsFromPEM(applicationCert) 
31 if !ok { 
32  panic("failed to parse root certificate") 
33 } 
34 
35 tlsConf := &amp;tls.Config{RootCAs: roots} 
36 
37 tr := &amp;http.Transport{TLSClientConfig: tlsConf} 
38 client := &amp;http.Client{Transport: tr} 
</pre>
<p>In line <strong>13</strong>, we are creating a new certificate pool and then we read the certifcates, which are PEM encoded into a slice of bytes. In line <strong>20</strong>, we can then add these certificates to the new cert pool; for the certificate to be identified as valid, we need both the intermediate certificate and the root certificate. We can then create a new TLS config and add the certs; this is then added to the transport and ultimately, in line <strong>38</strong>, the client.</p>
<p>When we now run the client, it connects without any problem and we will see the <kbd>Hello World</kbd> response correctly returned from the server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing data at rest</h1>
                </header>
            
            <article>
                
<p>Assuming our system had been attached to a database for storing things such as user accounts, the attacker would have been able to get access to the complete database of passwords. One of the things that we should think about when are storing data in a database is the encryption of our data. There is no doubt that encrypting data is more expensive than not encrypting it and that it can sometimes be difficult to figure out which fields or tables we should encrypt and which we should leave plain.</p>
<p>One of the many benefits microservices give us is that we separate function and data between our systems. This can make deciding what data to encrypt easier as rather than attempting to understand which data to encrypt within a datastore, you make a simpler decision: is there any data which needs to be encrypted inside this datastore? If so, then simply encrypt all of it. It may be beneficial to perform this encryption in the application layer rather than the datastore as applications tend to scale better than datastores and you must consider the edge cases that caching may introduce. If, to reduce the pressure on a datastore, you add an intermediary caching layer using Elasticache or another technology, you need to think about the security of your data. If the data is encrypted in the database then you need to ensure that the same level of encryption is applied to the cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Physical machine access</h1>
                </header>
            
            <article>
                
<p>When I say "physically", I mean access by humans; the code could be running on a VM. However, the problem is the same: all too often, I find that companies give developers access to databases and other sources of information running in a production environment. Even if they do not have access to the database password, they may have access to the config store or the ability to SSH into an application server and read the configuration from the application that way. There is a security principle called the <strong>least privilege</strong>; this recommends that accounts and services have the least amount of privilege to perform their business function. Even if you have ensured that the machine-to-machine communication is secured and there are appropriate safeguards with your firewall, there is always an opportunity for an attacker to access your systems by the back door. Consider the following scenario. A nontechnical employee in your company opens an email or downloads some software which installs some malware on their laptop. The attacker uses this to get access to their machine and, from there, manages to travel horizontally through the network and eventually ends up on your laptop. Now, since you are logged in and busy working and connected to the VPN into production, they manage to manage to install a key logger on your machine which gives them access to your passwords, they retrieve your SSH keys from your disk and because you have pretty much full access to production, now so do they. While this may seem like science fiction, it is very possible. You can, of course, secure your internal network but the best way to avoid such an attack is to restrict access to production environments and data severely. You should not ever need this level of access; with robust tests in my code, I often find that when a service misbehaves, it is not something that production access helps me with. I should be able to reproduce almost any error in a staging environment and the logging and metrics data that the service is emitting should be enough for me to diagnose any issues. I am not saying I have never debugged live on production but thankfully not in the last decade. Tooling and practice are such these days that we should never need to return to those acts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OWASP</h1>
                </header>
            
            <article>
                
<p>Whenever you are looking for practical web security advice on security, OWASP should almost always be your first port of call.</p>
<p>For help with APIs, OWASP can also help: they have published the <em>REST Security Cheat Sheet</em> (<a href="https://www.owasp.org/index.php/REST/_Security/_Cheat/_Sheet"><span class="URLPACKT">https://www.owasp.org/index.php/REST\_Security\_Cheat\_Sheet</span></a>).</p>
<p>Of course, as we have already discussed in this book, there are many different standards for building APIs and REST is but one of them; there are, however, some useful generic tips that we can leverage from this guide.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Never storing session tokens in a URL</h1>
                </header>
            
            <article>
                
<p>JWT, which is probably the most common session token you will find used with APIs, encodes into a format which is URL-safe. Storing or passing the token in a URL, however, is not recommended, and it should always be stored in either a cookie or as a <kbd>POST</kbd> variable. The reason for this is that if you pass session tokens in a URL, these can leak into your server logs and, depending upon how you manage the duration of the token, if an attacker gets access to your log files, they may also be able to obtain full access to execute commands for your users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-site scripting (XSS) and cross-site request forgery (CRSF)</h1>
                </header>
            
            <article>
                
<p>XSS and CRSF only apply when your API is going to be used from a web browser, such as in a single page app or a direct JavaScript call. However, to protect against an attacker injecting malicious JavaScript which can retrieve your session token, you should make sure that it is stored in a cookie which is marked as HTTP-only and that you only ever send them over HTTPS to stop them being captured in transit. In addition to this, we can add a layer of security which checks the HTTP referrer sent by the browser against the expected domain. While it is possible to fake the HTTP referrer using something like cURL, it is not possible or incredibly difficult to do this from JavaScript in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Insecure direct object references</h1>
                </header>
            
            <article>
                
<p>When you are building an API, you need to ensure that you are checking the authenticated users can modify the object in the request. This would be performed server side; we do not want to give our attacker the capability to create a genuine login and then be able to manipulate the request to perform an action on behalf of another user.</p>
<p>The OWASP documents are regularly updated as new attacks and vulnerabilities are found; check the site often and keep yourself up to date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication and authorization</h1>
                </header>
            
            <article>
                
<p>Authentication is the process or action of checking something to be true, such as: does this username pair with this password? Authorization is the function of specifying access rights or policy regarding a user.</p>
<p>Authentication is a well-understood concept; however, there are a few concepts we need to understand to ensure that this action cannot be compromised, such as never storing passwords in plain text in a datastore and preventing the hijack of a login session by transferring an active token to a third party. Authorization, however, is equally important; we discussed earlier the confused deputy problem: even when a user is authenticated, we must still control the actions that they can perform on a system. Services which operate on a principle of trust between themselves and do not independently validate a user's rights are wide open to abuse should an attacker compromise your firewall. In this section, we will look at just how easy it is to solve both of these problems, providing you with the patterns so that your services never need to be exposed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Password hashing</h1>
                </header>
            
            <article>
                
<p>A hash is one-way cryptography: you take a series of letters and numbers and by running them through the hashing algorithm, you get a sequence which while reproducible with the same original input cannot be reversed mathematically. So why would you use a hash instead of just encrypting the data? Firstly, hashes do not require any keys, and therefore they are not vulnerable to the loss of private keys, and they are perfect for storing data which does not need to be reversed. Consider passwords: your system never needs to know what the user's password is, and it only needs to know that the value passed to you by the user matches the stored value. Hashing a password is the perfect approach to security: you hash the input from the user and compare this hash with the value you have in your data store. If the database is compromised then the attacker will not be able to decode the passwords. The attacker could, of course, attempt to brute force the password, but currently, there is not enough computing power on the planet to be able to decode a decent hash. Does that mean that hashes are invulnerable? No. In fact, many thought that MD5 hashes were irreversible; however, this algorithm had been compromised. It is possible to find collisions within a matter of seconds. There was a case back in 2011 where attackers used this vulnerability to create fake SSL certificates which allowed them to exploit users' trust. Thankfully, we no longer use MD5 or SHA-1 for cryptographic purposes. You will still find it used for signatures such as in git commits where the possibilities of collision are offset by the speed of calculation but for security, we need to use a more modern algorithm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a little seasoning</h1>
                </header>
            
            <article>
                
<p>While a hash on its own provides a decent level of security, we can add a salt and a pepper. The salt is stored in the database along with the encrypted data. The intention behind this is to make brute forcing data more computationally expensive. It stops the attacker from using Rainbow tables to attack your data. Rainbow tables are precomputed tables of hashes, so instead of having to compute the hash with every attempt, you can simply look up the encrypted string in the table and return the original value. To counter this, we added a salt which is randomly generated for each value and appended to it before hashing. Even though we store this in the database along with the hashed value as we need to use it later to check the value, it stops the use of Rainbow tables as each table would have to be computed for every salt, and this is computationally very expensive. To further enhance security, we often also add a pepper, which is a precomputed value which is stored separately from the salt and hashed value.</p>
<p>Common practice is to pre-generate a list of peppers and store them in a configuration store. When you are first hashing a password or other value, you would select one of the peppers at random and append it to the value in the same way as you do for the salt. Then when checking a supplied value matches the hash, you would loop through the list of peppers and generate a hash to compare with each one. This adds a little computation time to checking a password in your service; however, not nearly as much effort as it will add to the attacker who is attempting to brute force your values. Let's take a look at how we can hash a value in using a salt and a pepper.</p>
<p>If we take a look at the source code in <kbd>hashing/hash.go</kbd>, we can create a hash from an input string using the following <kbd>GenerateHash</kbd> method. The <kbd>GenerateHash</kbd> method has the following signature and given an input string, it returns a random salt and the hashed string using the sha512 algorithm:</p>
<pre>
func GenerateHash(input string) (hash string, salt string) 
</pre>
<p>To use this, we can simply call the method with our string to hash and we would get some output as follows:</p>
<pre>
h:= New(peppers) 
hash, salt := h.GenerateHash("HelloWorld1") 
 
fmt.Println("Salt: ", salt) 
fmt.Println("Hash: ", hash) 
 
---Output 
Salt:  15f42f8b4f1c71dc6183c822fcf28b3c34564c32339509c2c02fa3c4dda0ed4f 
Hash:  b16a89d3c41c9fe045a7c1b892d5aa15aee805d64b753e003f7050851ef4d374e3e16ce23500020746174f7b7d8aeaffebf52939f33c4fda505a5c4e38cdd0e1 
</pre>
<p>Let's look more in depth at what this function is doing:</p>
<pre>
22 // GenerateHash hashes the input string using sha512 with a salt and pepper. 
23 // returns the hash and the salt 
24 func (h *Hash) GenerateHash(input string) (hash string, salt string) { 
25  pepper := h.getRandomPepper() 
26  salt = h.generateRandomSalt() 
27  hash = h.createHash(input, salt, pepper) 
28 
29  return 
30 } 
</pre>
<p>The first thing we are doing, on line <strong>25</strong>, is retrieving a random pepper from the slice of peppers which is passed to the struct when we initialize it with <kbd>New(peppers)</kbd>. The pepper does not need to be stored in the database; this is purely to slow down a potential attacker by requiring them to increase their brute force attempts by a factor of five in our example. We can increase the number of peppers and as you can see from the benchmark below, even at 1,000 peppers, we are still able to compare a hash in 1 ms but for the additional security this will give you is probably not worth it. It takes 4,634 ns to generate one hash and due to the length of the string, we would need to generate a maximum of 6.2e19 or 62 quintillion permutations. This is assuming 63 allowable characters and a password 11 characters in length. That is a pretty big number, and to generate that many hashes would take roughly 9 million years to brute force for a single CPU.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dictionary attacks</h1>
                </header>
            
            <article>
                
<p>However, not all passwords are complex and many are susceptible to an attack known as a dictionary attack. Instead of attempting all 62 quintillion permutations, the dictionary attack concentrates on those which are most likely to succeed. The dictionaries themselves are often derived from password databases which have previously been exploited and since humans are somewhat predictable, we often use the same passwords. Because our password <kbd>HelloWorld1</kbd> is already in the dictionary which contains 14 million other passwords, when I attempted to break the salted hash using <kbd>John the Ripper</kbd>, it only took 2.4 seconds to retrieve the password.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a pepper</h1>
                </header>
            
            <article>
                
<p>There is a fine line as to what we can do to stop our users using simple passwords. We should always have a policy of what constitutes a good password--minimum length, the mixture of case, an addition of symbols, and so on--but usability can be compromised the more complex the password gets. Adding a pepper, however, can help to slow the attacker down: the pepper or peppers are known to the system but not stored with the password and salt. They can be hard coded into the application code, stored as launch configuration or stored in a secure vault which is accessed at runtime. In the same way, we appended the salt to the user's password, we do the same thing with the pepper. Should the database tables become compromised due to a SQL injection attack then unless the attacker can retrieve the peppers, the database is useless. Of course, it is possible for the attacker to get hold of your peppers; however, almost everything in security is about making it difficult and slowing someone down.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">bcrypt</h1>
                </header>
            
            <article>
                
<p>bcrypt is another popular method of hashing passwords, it uses a variable number of rounds to generate the hash which both slows down the ability to brute force the attack and the time it takes to generate the hash. Go has an implementation of bcrypt which is provided by the experimental packages at <a href="https://godoc.org/golang.org/x/crypto/bcrypt">https://godoc.org/golang.org/x/crypto/bcrypt</a><span class="text-muted">. To hash a password with bcrypt we use the <kbd>GenerateFromPassword</kbd> method:</span></p>
<div class="funcdecl decl">
<pre>
func GenerateFromPassword(password []byte, cost int) ([]byte, error)
</pre></div>
<p>The <kbd>GenerateFromPassword</kbd> method returns the bcrypt hash of the password at the given cost. The cost is a variable which allows you to increase the security of the returned hash at the expense of more processing time to generate it.</p>
<p>To check the equality of a bcrypt hash we can not call <kbd>GenerateFromPassword</kbd> again with the given password and compare the output to the hash we have stored as <kbd>GenerateFromPassword</kbd> will create a different hash every time it is run. To compare equality we need to use the <kbd>CompareHashAndPassword</kbd> method:</p>
<div class="funcdecl decl">
<pre>
func CompareHashAndPassword(hashedPassword, password []byte) error
</pre></div>
<p>The <kbd>CompareHashAndPassword</kbd> method compares a bcrypt hashed password with its possible plain text equivalent. bcrypt is a secure method of protecting passwords but it is slow, let's take a look in a little more depth at the cost of generating hashes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benchmarks</h1>
                </header>
            
            <article>
                
<p>The following table illustrates the approximate time it takes to generate and compare a hashed string using the methods we have discussed so far. Even with 1,000 peppers, we would be looking at a processing time of approximately 1.5 ms to run the comparison. This might not seem a huge amount of time; however, we need to take these benchmarks with a pinch of salt as they are running a single operation where your server will be dealing with multiple requests concurrently. What we do know is that comparing a hash with a list of 1,000 peppers takes 10x longer than comparing a list of 100 and this is 10x longer than a list of 10:</p>
<p>Even with 1,000 peppers, we would be looking at a processing time of approximately 1.5 ms to run the comparison. This might not seem a huge amount of time; however, we need to take these benchmarks with a pinch of salt as they are running a single operation where your server will be dealing with multiple requests concurrently. What we do know is that comparing a hash with a list of 1,000 peppers takes 10x longer than comparing a list of 100 and this is 10x longer than a list of 10:</p>
<pre>
BenchmarkGeneratePlainHash-8             30000000     1069 ns/op<br/>BenchmarkGenerateHashWithSaltAndPepper-8  5000000     5223 ns/op<br/>BenchmarkGenerateBcrypt-8                     500 68126630 ns/op<br/>BenchmarkCompareSaltedHash-8             20000000     1276 ns/op<br/>BenchmarkComparePlainHash-8              20000000     1174 ns/op<br/>BenchmarkCompareHash5Peppers-8           20000000     4980 ns/op<br/>BenchmarkCompareHash10Peppers-8          10000000     4669 ns/op<br/>BenchmarkCompareHash100Peppers-8          1000000    22150 ns/op<br/>BenchmarkCompareHash1000Peppers-8           20000  1492037 ns/op<br/>BenchmarkCompareBCrypt-8                      500 70942742 ns/op
</pre>
<p>Given this information, we can balance our service for speed against security; however, we should always lean on the more secure. To learn how Facebook manages hashing I recommend you take a look at Alec Muffett's talk Facebook: <em>Password hashing and Authentication</em> (<a href="https://www.youtube.com/watch?v=NQDo2e3gj1A">https://www.youtube.com/watch?v=NQDo2e3gj1A</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JWTs</h1>
                </header>
            
            <article>
                
<p>A <strong>JSON Web Token</strong> (<strong>JWT</strong>) is a standard for safely passing claims or data attributed to a user within an environment. It is an incredibly popular standard and is available for just about every major language and framework, certainly for Go. There are two main strengths of JWT. One is a standard format for the claims, which makes the availability of reliable frameworks possible. The other is the use of asymmetric encryption, which means that because a token is signed, the receiver only needs the public key of the signer to validate that the token has indeed come from a trusted source and this allows us to lock down access to the private keys to an authorization server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Format of a JWT</h1>
                </header>
            
            <article>
                
<p>A JWT is broken into three different parts, which are encoded as Base64-URL. Like standard Base64, Base64-URL substitutes characters such as <kbd>+</kbd> and <kbd>/</kbd> for <kbd>-</kbd> and <kbd>\_</kbd> and removes all the padding. This allows the token to be safely transferred in a URL.</p>
<p>The result is a token which looks like the following example:</p>
<pre>
<strong>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3NMZXZlbCI6InVzZXIiLCJleHAiOjE4MDc3MDEyNDYsInVzZXJJRCI6ImFiY3NkMjMyamZqZiJ9.iQxUbQuEy4Jh4oTkkz0OPGvS86xOWJjdzxHHDBeAolv0982pXKPBMWskSJDF3F8zd8a8nMIlQ5m9tzePoJWe_E5B9PRJEvYAUuSp6bGm7-IQEum8EzHq2tMvYtPl9uzXgOU4C_pIjZh5CjFUeZLk5tWKwOOo8pW4NUSxsV2ZRQ_CGfIrBqEQgKRodeLTcQ4wJkLBILBzmAqTVl-5sLgBEoZ76C_gcvS6l5HAwEAhmiCqtDMX46o8pA72Oa6NiVRsgxrhrKX9rDUBdJAxNwFAwCjTv6su0jTZvkYD80Li9aXiMuM9NX7q5gncbEhfko_byTYryLsmmaUSXNBlnvC_nQ     </strong>
</pre>
<p>The three distinct parts of the token are the header, the payload, and the signature. The header declares the type of the encoded object and the algorithm for the cryptographic signature:</p>
<pre>
{ 
  "alg": "RS256", 
  "typ": "JWT" 
} 
</pre>
<p>The second object payload which contains the details of the claims related to the token:</p>
<pre>
{ 
  "userID": "abcsd232fjfj", 
  "accessLevel": "user" 
} 
</pre>
<p>And finally, the third part is the signature, which is an optional element shown as follows in the decoded state:</p>
<pre>
Tm 
  &lt;a=&lt;kNX[d\1k$H_3w5C7NAIR1b 
                           Hy 
1TyՊ5D]Ehuq0&amp;B s 
V_{@! 39Tl5t17@(ӿ.پF5~ H_6+&amp;\[1m% 
</pre>
<p>Every element in the JWT is base64URL encoded (<a href="https://en.wikipedia.org/wiki/Base64#URL_applications"><span class="URLPACKT">https://en.wikipedia.org/wiki/Base64#URL_applications</span></a>); the signature represented in its binary form is the sha256 of the message in the following format:</p>
<pre>
Base64URL(header).Base64URL(payload) 
</pre>
<p>The format of the signature can either be symmetrical (HS256) using a shared secret or asymmetrical (RS256), which uses public and private keys. For JWTs, the best option is the asymmetrical option as for a service which needs to authenticate the JWT, it only requires the public part of the key.</p>
<p>We can validate our JWT only using the command line. First, we need to convert our base64URL-encoded signature into standard base64 encoding by replacing <kbd>_</kbd> with <kbd>/</kbd> and <kbd>-</kbd> with <kbd>+</kbd>. We can then pipe that into the base64 command-line application and pass in the <kbd>-D</kbd> flag to decode the input; we then output this into a file:</p>
<pre>
cat signature.txt | sed -e 's/_/\//g' -e 's/-/+/g' | base64 -D &gt; signature.sha256 
</pre>
<p>The next step is to validate that the signature has been signed by the correct key by validating it against a public key:</p>
<pre>
openssl dgst -sha256 -verify ../keys/sample_key.pub -signature signature.sha256 data.txt 
</pre>
<p>Generating JWTs with Go is very straightforward thanks to some amazing community packages. The package we will be using in the example code is called <strong>jose</strong> and has been created by Eric Largergren (<a href="https://github.com/SermoDigital/jose">https://github.com/SermoDigital/jose</a>). According to the listing on <kbd>jwt.io</kbd>, this package implements all the capabilities defined in the standard and was an obvious choice at the time of writing.</p>
<p>If we take a look at the file <kbd>chapter8/jwt/jwt.go</kbd> and look at the <kbd>GenerateJWT</kbd> method, we can see just how simple it is to create a JWT using jose:</p>
<pre>
30 // GenerateJWT creates a new JWT and signs it with the private key 
31 func GenerateJWT() []byte { 
32  claims := jws.Claims{} 
33  claims.SetExpiration(time.Now().Add(2880 * time.Minute)) 
34  claims.Set("userID", "abcsd232jfjf") 
35  claims.Set("accessLevel", "user") 
36 
37  jwt := jws.NewJWT(claims, crypto.SigningMethodRS256) 
38 
39  b, _ := jwt.Serialize(rsaPrivate) 
40 
41  return b 
42 } 
</pre>
<p>The first thing that we need to do is to generate a list of claims and to set an expiration; we are setting the expiration to two weeks. We can then set a list of claims using the <kbd>Set</kbd> function:</p>
<pre>
func (c Claims) Set(key string, val interface{}) 
</pre>
<p>Finally, in line <strong>39</strong>, we can create a new JWT passing the claims and the signing method to the <kbd>NewJWT</kbd> function:</p>
<pre>
func NewJWT(claims Claims, method crypto.SigningMethod) jwt.JWT 
</pre>
<p>We can then call the <kbd>Serialize</kbd> method, which has as a parameter the private key - in our case, an instance of <kbd>rsa.PrivateKey</kbd> - and returns us a slice of bytes in the encoded format:</p>
<pre>
func (j *jws) Serialize(key interface{}) ([]byte, error) 
</pre>
<p>Validating a JWT with jose is as easy as it was to create the JWT:</p>
<pre>
46 func ValidateJWT(token []byte) error { 
47  jwt, err := jws.ParseJWT(token) 
48  if err != nil { 
49    return fmt.Errorf("Unable to parse token: %v", err) 
50  } 
51 
52  if err = jwt.Validate(rsaPublic, crypto.SigningMethodRS256); err != nil { 
54    return fmt.Errorf("Unable to validate token: %v", err) 
55  } 
56 
57  return nil 
58 } 
</pre>
<p>The first thing we need to do is to parse our JWT from a byte array into the <kbd>jwt</kbd> struct using the <kbd>ParseJWT</kbd> function:</p>
<pre>
func ParseJWT(encoded []byte) (jwt.JWT, error) 
</pre>
<p>Then we can call the <kbd>Validate</kbd> method, passing the public key corresponding to the private one which signed the message and the signing method. Optionally, we can provide a customer validator function; the default validation will only check the signature and that the token has not expired:</p>
<pre>
func (j *jws) Validate(key interface{}, m crypto.SigningMethod, v ...*jwt.Validator) error 
</pre>
<p>When the validation fails, an error will be returned; if the error is nil then the token is valid and the claims within can be trusted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Secure messages</h1>
                </header>
            
            <article>
                
<p>When we need to send an encrypted message, one of the best ways to do this is with asymmetric encryption, where we encrypt the message with publically known information which can be easily distributed and then decrypt it with the private key which is securely held by a single party.</p>
<p>The crypto packages in Go have all the features we need to secure our data. If we take a look at the example <kbd>chapter8/asymmetric/asymmetric.go</kbd>, the <kbd>EncryptDataWithPublicKey</kbd> method is a simple implementation of the <kbd>rsa</kbd> package's public key encryption:</p>
<pre>
func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error) 
</pre>
<p>The first parameter is a cryptographic hash which is used as the random oracle to process the message before encryption. This function must be the same for encryption and decryption and the documentation recommends using a sha256. The next parameter is a random number generator; this is used as a source of entropy to ensure that if you encrypt the same message twice, you do not return the same cyphertext. <kbd>pub</kbd> is the <kbd>rsa.PublicKey</kbd> that we would like to use to encrypt the message; the message itself is passed as a slice of bytes. The final parameter is optional and is not encrypted in the resultant cyphertext; it can be used to help the receiver understand information such as which key has been used to encrypt the message, but extreme care must be taken not to add data to the label which could compromise the security of the encrypted message:</p>
<pre>
41 // EncryptMessageWithPublicKey encrypts the given string and retuns the encrypted 
42 // result base64 encoded 
43 func EncryptMessageWithPublicKey(message string) (string, error) { 
44 
45  modulus := rsaPublic.N.BitLen() / 8 
46  hashLength := 256 / 4 
47  maxLength := modulus - (hashLength * 2) - 2 
48 
49  if len(message) &gt; maxLength { 
50    return "", fmt.Errorf("The maximum message size must not exceed: %d", maxLength) 
51  } 
52 
53  data, err := EncryptDataWithPublicKey([]byte(message)) 
54  return base64.StdEncoding.EncodeToString(data), err 
55 }  
</pre>
<p>The first thing we are doing in this method is to check whether the message is shorter than the maximum permitted length for this encryption method. The maximum length must be no longer than public modulus minus twice the hash length minus a further two. Due to the mathematics involved in public key cryptography, we can only allow for the encryption of small messages. We will look at how we can work around this issue a little later on. In line <strong>53</strong>, we are calling another internal function, which simply calls the <kbd>EncryptOAEP</kbd> function in the <kbd>rsa</kbd> package. We then encode the data to base64 and return the result.</p>
<p>Decrypting the data is as straightforward:</p>
<pre>
57 // DecryptMessageWithPrivateKey decrypts the given base64 encoded ciphertext with 
58// the private key and returns plain text 
59 func DecryptMessageWithPrivateKey(message string) (string, error) { 
60  data, err := base64.StdEncoding.DecodeString(message) 
61  if err != nil { 
62    return "", err 
63  } 
64 
65  data, err = DecryptDataWithPrivateKey(data) 
66  return string(data), err 
67 } 
</pre>
<p>Because our implementation of the encryption method returned a base64-encoded string, the first thing we do before decrypting the message is to decode it back into its binary form. We then call the internal method <kbd>DecryptDataWithPrivateKey</kbd>; this is a wrapper for the method <kbd>rsa.DecryptOAEP</kbd>:</p>
<pre>
func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error) 
</pre>
<p>This method has the same parameters to the encrypt method except this time we are using the private key. If we recall how asymmetric encryption works, we can encrypt with a public key but you cannot decrypt a message with the public key. The private key must be used for this purpose.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shared secrets</h1>
                </header>
            
            <article>
                
<p>Symmetrical encryption also has its uses: for one, it is faster and the other is that it can handle a message of any size. Implementing symmetrical encryption in Go is, as you would expect, quite straightforward: we have the excellent <kbd>crypto/aes</kbd> package which manages all the heavy lifting for us. Let's look at how we could encrypt a message with AES. Look at the example file <kbd>symmetric/symmetric.go</kbd>:</p>
<pre>
12 func EncryptData(data []byte, key []byte) ([]byte, error) { 
13  if err := validateKey(key); err != nil { 
14    return make([]byte, 0), err 
15  } 
16 
17  c, err := aes.NewCipher(key) 
18  if err != nil { 
19    return make([]byte, 0), err 
20  } 
21 
22  gcm, err := cipher.NewGCM(c) 
23  if err != nil { 
24    return make([]byte, 0), err 
25  } 
26 
27  nonce := make([]byte, gcm.NonceSize()) 
28  if _, err = io.ReadFull(rand.Reader, nonce); err != nil { 
29    return make([]byte, 0), err 
30  } 
31 
32  return gcm.Seal(nil, nonce, data, nil), nil 
33 } 
</pre>
<p>The first thing we need to do on line <strong>13</strong> is to validate the length of the key. The length of the key determines the strength of the encryption; a 16-byte key will encrypt with AES-128, 24 bytes AES-192, and 32 bytes AES-256. We then create a new <strong>GCM</strong> (<strong>Galois/Counter Mode</strong>) cipher and pass it the reference to our AES cipher:</p>
<pre>
func NewGCM(cipher Block) (AEAD, error) 
</pre>
<p>We then need to create a nonce which is used to protect against replay attacks and finally we can call the <kbd>Seal</kbd> method which encrypts our data:</p>
<pre>
Seal(dst, nonce, plaintext, additionalData []byte) []byte 
</pre>
<p>Unlike RSA public key encryption, the size of the message that AES can handle is pretty much unlimited; the problem, however, is that the secret must be shared by both the writer and the reader, which introduces the problem of distributing keys to both parties.</p>
<p>Decryption works in the reverse of the encryption method, an example of which can be seen in the next code block:</p>
<pre>
35 // DecryptData decrypts the given data with the given key 
36 func DecryptData(data []byte, key []byte) ([]byte, error) { 
37  c, err := aes.NewCipher(key) 
38  if err != nil { 
39    return make([]byte, 0), err 
40  } 
41 
42  gcm, err := cipher.NewGCM(c) 
43  if err != nil { 
44    return make([]byte, 0), err 
45  } 
46 
47  nonceSize := gcm.NonceSize() 
48  if len(data) &lt; nonceSize { 
49    return make([]byte, 0), fmt.Errorf("ciphertext too short") 
50  } 
51 
52  nonce, ciphertext := data[:nonceSize], data[nonceSize:] 
53  return gcm.Open(nil, nonce, ciphertext, nil) 
54 } 
</pre>
<p>The main thing we need to note in this code block is in the <kbd>gcm.Open</kbd> method:</p>
<pre>
Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) 
</pre>
<p>The nonce that we are going to use to decrypt the message needs to be the same one that was used to encrypt the message. When we called <kbd>Seal</kbd>, the slice of bytes returned from the method is the encrypted message and the nonce, so to retrieve it, we only need to calculate the size of the nonce and then split the bytes slice up into two parts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asymmetric encryption with large messages</h1>
                </header>
            
            <article>
                
<p>We have already discussed the problem with asymmetric encryption is that it can only be used for relatively small messages; however, the benefits of not having to deal with key distribution is hugely advantageous over symmetrical. There is a common solution to this problem; that solution is to create a random key and symmetrically encrypt a message then asymmetrically encrypt the key and distribute both parts to the receiver. Only the holder of the private key will be able to decrypt the symmetrical key and only once the symmetrical key has been decrypted can the receiver decrypt the main message:</p>
<pre>
69 // EncryptLargeMessageWithPublicKey encrypts the given message by randomly generating 
70 // a cipher. 
71 // Returns the ciphertext for the given message base64 encoded and the key 
72 // used to encypt the message which is encrypted with the public key 
73 func EncryptLargeMessageWithPublicKey(message string) (ciphertext string, cipherkey string, err error) { 
74  key := utils.GenerateRandomString(16) // 16, 24, 32 keysize, random string is 2 bytes per char so 16 chars returns 32 bytes 
75  cipherData, err := symetric.EncryptData([]byte(message), []byte(key)) 
76  if err != nil { 
77    return "", "", err 
78  } 
79 
80  cipherkey, err = EncryptMessageWithPublicKey(key) 
81  if err != nil { 
82    return "", "", err 
83  } 
84 
85  return base64.StdEncoding.EncodeToString(cipherData), cipherkey, nil 
86 } 
</pre>
<p>Looking at the example in <kbd>asymmetric/asymmetric.go</kbd>, we can see that we are doing exactly this. This function mealy wraps the two methods for symmetrical and asymmetrical encryption that we looked at earlier in this chapter. Decryption is as simple:</p>
<pre>
 88 // DecryptLargeMessageWithPrivateKey decrypts the given base64 encoded message by 
 89 // decrypting the base64 encoded key with the rsa private key and then using 
 90 // the result to decrupt the ciphertext 
 91 func DecryptLargeMessageWithPrivateKey(message, key string) (string, error) { 
 92   keystring, err := DecryptMessageWithPrivateKey(key) 
 93  if err != nil { 
 94    return "", fmt.Errorf("Unable to decrypt key with private key: %s", err) 
 95  } 
 96 
 97  messageData, err := base64.StdEncoding.DecodeString(message) 
 98  if err != nil { 
 99    return "", err 
100  } 
101 
102  data, err := symetric.DecryptData(messageData, []byte(keystring)) 
103 
104  return string(data), err 
105 } 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintenance</h1>
                </header>
            
            <article>
                
<p>One important element of keeping your system secure is making sure you keep it up to date with all the latest security patches. This approach needs to be applied to your application code and your server's operating system and applications, and if you are using Docker, you also need to ensure that your containers are up to date to ensure you are free from vulnerabilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Patching containers</h1>
                </header>
            
            <article>
                
<p>One of the simplest ways to keep your containers secure is to ensure that you build and deploy them regularly. Quite often, if a service is not under active development, then it may not be deployed to production for months on end. Because of this problem, you may be patching host-level application libraries such as OpenSSL but because of the application isolation that a container gives, you may have vulnerable binaries at a container level. The simplest way of keeping things up to date is to run a regular build and deploy even if the application code does not change. You also need to ensure that if you are using a base container in your Dockerfile, this is also built and updated.</p>
<p>Docker hub, <kbd>quay.io</kbd>, and a couple of other software as a service registries have the capability to automatically rebuild a container when a linked container changes. If you are building an image which is based on <kbd>golang:latest</kbd>, you can automatically trigger a build when the upstream image is pushed to the registry. You can also run automated security scanning, which examines the layers in your image and scans for any CVE vulnerabilities. It will let you know in which layer the vulnerability exists and quite often you will find that this is in the base layer, such as Ubuntu or Debian.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software updates</h1>
                </header>
            
            <article>
                
<p>Patching the software on your host and in your Docker image can help keep you safe from vulnerabilities such as Heartbleed, which was found in OpenSSL. Patching software updates are relatively straightforward. You can configure your host to automatically update itself; the other option, which I prefer, is to ensure that your infrastructure is automated so that you can burn it down and rebuild it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Patching application code</h1>
                </header>
            
            <article>
                
<p>In the same way that the software on the host needs to be updated, you must also update your application code to ensure you always have the latest updates. Quite often, an approach of locking your application dependencies to a version is followed and with the vendoring support which was introduced in Go 1.5, this process has been growing in the community. One problem with this and one of the main reasons that vendoring was not present in releases prior to go 1.5 is to encourage you to build your application code against the latest packages and to fix any problems that occur with breaking API changes sooner rather than later. If you do use vendoring, and I am certainly not going to suggest you do not use it, then you should run a nightly build which updates all libraries to the latest version. You do not necessarily have to deploy this to production; however, if the tests pass then why not? If the tests fail then, even if it is a service which is not under active development, this should be a trigger to you to perform a little maintenance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging</h1>
                </header>
            
            <article>
                
<p>If we have protected our passwords and implemented decent security, we still need to know when we are under threat. In the previous chapter, we introduced logging and logging can be a useful tool as part of your security policy. Consider someone attempting to brute force your application login; tracking high levels of authentication errors along with the source IP can be useful when you need to react to this threat. The IP address of the attacker can be blocked by the firewall.</p>
<p>The content of log files needs to consider the following attributes:</p>
<ul>
<li>Who is performing the action</li>
<li>What has failed or succeeded</li>
<li>When is the action occurring</li>
<li>Why this has failed or succeeded</li>
<li>How you can deal with the issue</li>
</ul>
<p>The following example contains nowhere near enough information to be useful and, in fact, other than letting you know there may be a failure, you might as well not even consume the space taken by such logs:</p>
<pre>
Aug 18 11:00:57 [AuthController] Authentication failed. 
</pre>
<p>The following example is far better; it shows the problem in much greater depth and describes in detail the events that a user is taking to access the system. Modern log evaluation tools such as Kibana allow filtering and grouping of such log files, which allows you to build up a dashboard or list of events:</p>
<pre>
Aug 18 11:00:57 [AuthController] Authentication failure 
for nicj@example.com by 127.0.0.1 - user unknown - 
/user/login /user/myaccount 
Aug 18 11:01:18 [AuthController] Authentication failure 
for nicj@example.com by 127.0.0.1 - invalid password - 
/user/login?err=1 /user/login 
Aug 18 11:02:01 [AuthController] Authentication failure 
for nicj@example.com by 127.0.0.1 - incorrect 2FA code 
- /user/login?err=2 /user/login 
</pre>
<p>For example, you could create a dashboard which is looking at failed attempts from a single IP address above a certain threshold, which could indicate a malicious attempt to brute force access to a system. It is often possible to set alerts on such events, allowing you to proactively identify a threat and block access.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned some of the attacks your service may face from an intruder. We, hopefully, should have an introduction on how encryption works and how we can leverage Go's standard package to implement these to keep our service safe. There is little you can do to completely protect yourself from a determined attacker; however, using the simple techniques described in this chapter should form your standard working practice. Implementing many of these techniques will not slow down your development cycle by any significant degree; it will, however, give you an edge to keep you safe.</p>


            </article>

            
        </section>
    </body></html>