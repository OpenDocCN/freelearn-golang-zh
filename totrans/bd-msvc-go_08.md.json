["```go\n3 // Request defines the input structure received by a http handler \n4 type Request struct { \n5  Name  string `json:\"name\"` \n6  Email string `json:\"email\" validate:\"email\"` \n7  URL   string `json:\"url\" validate:\"url\"` \n8 } \n\n```", "```go\nvalidate: \"email,min=3\" \n\n```", "```go\n 9 func TestErrorWhenRequestEmailNotPresent(t *testing.T) { \n10  validate := validator.New() \n11  request := Request{ \n12    URL: \"http://nicholasjackson.io\", \n13  } \n14 \n15  if err := validate.Struct(&request); err == nil { \n16    t.Error(\"Should have raised an error\") \n17  } \n18 } \n\n```", "```go\nfunc New() *Validate \n\n```", "```go\nfunc (v *Validate) Struct(s interface{}) (err error) \n\n```", "```go\nopenssl genrsa -aes256 -out key.pem 4096  \n\n```", "```go\nopenssl req -new -x509 -sha256 -key key.pem -out certificate.pem -days 365  \n\n```", "```go\n120 func generatePrivateKey() *rsa.PrivateKey { \n121  key, _ := rsa.GenerateKey(rand.Reader, 4096) \n122  return key \n123 } \n\n```", "```go\nfunc GenerateKey(rand io.Reader, bits int) (*PrivateKey, error) \n\n```", "```go\n191 func savePrivateKey(key *rsa.PrivateKey, path string, password []byte) error { \n192  b := x509.MarshalPKCS1PrivateKey(key) \n193  var block *pem.Block \n194  var err error \n195 \n196  if len(password) > 3 { \n197    block, err = x509.EncryptPEMBlock(rand.Reader, \"RSA PRIVATE  \nKEY\", b, password, x509.PEMCipherAES256) \n198    if err != nil { \n199      return fmt.Errorf(\"Unable to encrypt key: %s\", err) \n200    } \n201  } else { \n202    block = &pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: b} \n203  } \n204 \n205  keyOut, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600) \n206  if err != nil { \n207    return fmt.Errorf(\"failed to open key.pem for writing: %v\", err) \n208  } \n209 \n210  pem.Encode(keyOut, block) \n211  keyOut.Close() \n212 \n213  return nil \n214 } \n\n```", "```go\nfunc MarshalPKCS1PrivateKey(key *rsa.PrivateKey) ([]byte, error) \n\n```", "```go\n-----BEGIN RSA PRIVATE KEY----- \nProc-Type: 4,ENCRYPTED \nDEK-Info: AES-256-CBC,c4e4be9d17fcd2f44ed4c7f0f6a9b7a8 \n\ncfsmkm4ejLN2hi99TgxXNBfxsSQz6Pz8plQ2HJ1XToo8uXGALFlA+5y9ZLzBLGRj \n... \nzVYQvWh5NytrP9wnNogRsXqAufxf4ZLehosx0eUK4R4PsMy/VTDvcNo9P3uq2T32 \n\n-----END RSA PRIVATE KEY----- \n\n```", "```go\n-----BEGIN Type----- \nHeaders \nbase64-encoded Bytes \n-----END Type----- \n\n```", "```go\nfunc EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error) \n\n```", "```go\nconst ( \n        PEMCipherDES PEMCipher \n        PEMCipher3DES \n        PEMCipherAES128 \n        PEMCipherAES192 \n        PEMCipherAES256 \n) \n\n```", "```go\ntype Block struct { \n        Type    string            // The type, taken from the preamble (i.e. \"RSA PRIVATE KEY\"). \n        Headers map[string]string // Optional headers. \n        Bytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure. \n} \n\n```", "```go\nfunc Encode(out io.Writer, b *Block) error \n\n```", "```go\n125 func generateX509Certificate( \n126  key *rsa.PrivateKey, \n127  template *x509.Certificate, \n128  duration time.Duration, \n129  parentKey *rsa.PrivateKey, \n130  parentCert *x509.Certificate) []byte { \n131 \n132  notBefore := time.Now() \n133   notAfter := notBefore.Add(duration) \n134 \n135  template.NotBefore = notBefore \n136  template.NotAfter = notAfter \n137 \n138  serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128) \n139  serialNumber, err := rand.Int(rand.Reader, serialNumberLimit) \n140  if err != nil { \n141    panic(fmt.Errorf(\"failed to generate serial number: %s\", err)) \n142  } \n143 \n144  template.SerialNumber = serialNumber \n145 \n146  subjectKey, err := getSubjectKey(key) \n147  if err != nil { \n148    panic(fmt.Errorf(\"unable to get subject key: %s\", err)) \n149  } \n150 \n151  template.SubjectKeyId = subjectKey \n152 \n153  if parentKey == nil { \n154    parentKey = key \n155  } \n156 \n157  if parentCert == nil { \n158    parentCert = template \n159  } \n160 \n161  cert, err := x509.CreateCertificate(rand.Reader, template, parentCert, &key.PublicKey, parentKey) \n162  if err != nil { \n163    panic(err) \n164  } \n165 \n166  return cert \n167 } \n\n```", "```go\n22 var rootTemplate = x509.Certificate{ \n23  Subject: pkix.Name{ \n24    Country:            []string{\"UK\"}, \n25    Organization:       []string{\"Acme Co\"}, \n26    OrganizationalUnit: []string{\"Tech\"}, \n27    CommonName:         \"Root\", \n28  }, \n29 \n30  KeyUsage: x509.KeyUsageKeyEncipherment | \n31    x509.KeyUsageDigitalSignature | \n32    x509.KeyUsageCertSign | \n33    x509.KeyUsageCRLSign, \n34  BasicConstraintsValid: true, \n35  IsCA: true, \n36 } \n\n```", "```go\ntype Name struct { \n        Country, Organization, OrganizationalUnit []string \n        Locality, Province                        []string \n        StreetAddress, PostalCode                 []string \n        SerialNumber, CommonName                  string \n\n        Names      []AttributeTypeAndValue \n        ExtraNames []AttributeTypeAndValue \n} \n\n```", "```go\nX509v3 Subject Key Identifier: \n                5E:18:F9:33:BB:7B:E0:73:70:A5:3B:13:A8:40:38:3E:C9:4C:B4:17 \nX509v3 Authority Key Identifier: \n                keyid:72:38:FD:0F:68:5C:66:77:C0:AF:CB:43:C7:91:4C:5A:DD:DC:4D:D8 \n\n```", "```go\n174 func getSubjectKey(key *rsa.PrivateKey) ([]byte, error) { \n175  publicKey, err := x509.MarshalPKIXPublicKey(&key.PublicKey) \n176  if err != nil { \n177    return nil, fmt.Errorf(\"failed to marshal public key: %s\", err) \n178  } \n179 \n200  var subPKI subjectPublicKeyInfo \n201  _, err = asn1.Unmarshal(publicKey, &subPKI) \n202  if err != nil { \n203    return nil, fmt.Errorf(\"failed to unmarshal public key: %s\", err) \n204  } \n205 \n206  h := sha1.New() \n207  h.Write(subPKI.SubjectPublicKey.Bytes) \n208  return h.Sum(nil), nil \n209 } \n\n```", "```go\nfunc MarshalPKIXPublicKey(pub interface{}) ([]byte, error) \nMarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format. \n\n```", "```go\n169 type subjectPublicKeyInfo struct { \n170  Algorithm        pkix.AlgorithmIdentifier \n171  SubjectPublicKey asn1.BitString \n172 } \n\n```", "```go\nfunc Unmarshal(b []byte, val interface{}) (rest []byte, err error) \nUnmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. \n\n```", "```go\nfunc CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error) \n\n```", "```go\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error \n\n```", "```go\n2017/03/19 14:29:03 Get https://localhost:8433: x509: certificate signed by unknown authority \nexit status 1 \n\n```", "```go\n13 roots := x509.NewCertPool() \n14 \n15 rootCert, err := ioutil.ReadFile(\"../generate_keys/root_cert.pem\") \n16 if err != nil { \n17  log.Fatal(err) \n18 } \n19 \n20 ok := roots.AppendCertsFromPEM(rootCert) \n21 if !ok { \n22   panic(\"failed to parse root certificate\") \n23 } \n24 \n25 applicationCert, err := ioutil.ReadFile(\"../generate_keys/application_cert.pem\") \n26 if err != nil { \n27  log.Fatal(err) \n28 } \n29 \n30 ok = roots.AppendCertsFromPEM(applicationCert) \n31 if !ok { \n32  panic(\"failed to parse root certificate\") \n33 } \n34 \n35 tlsConf := &tls.Config{RootCAs: roots} \n36 \n37 tr := &http.Transport{TLSClientConfig: tlsConf} \n38 client := &http.Client{Transport: tr} \n\n```", "```go\nfunc GenerateHash(input string) (hash string, salt string) \n\n```", "```go\nh:= New(peppers) \nhash, salt := h.GenerateHash(\"HelloWorld1\") \n\nfmt.Println(\"Salt: \", salt) \nfmt.Println(\"Hash: \", hash) \n\n---Output \nSalt:  15f42f8b4f1c71dc6183c822fcf28b3c34564c32339509c2c02fa3c4dda0ed4f \nHash:  b16a89d3c41c9fe045a7c1b892d5aa15aee805d64b753e003f7050851ef4d374e3e16ce23500020746174f7b7d8aeaffebf52939f33c4fda505a5c4e38cdd0e1 \n\n```", "```go\n22 // GenerateHash hashes the input string using sha512 with a salt and pepper. \n23 // returns the hash and the salt \n24 func (h *Hash) GenerateHash(input string) (hash string, salt string) { \n25  pepper := h.getRandomPepper() \n26  salt = h.generateRandomSalt() \n27  hash = h.createHash(input, salt, pepper) \n28 \n29  return \n30 } \n\n```", "```go\nfunc GenerateFromPassword(password []byte, cost int) ([]byte, error)\n\n```", "```go\nfunc CompareHashAndPassword(hashedPassword, password []byte) error\n\n```", "```go\nBenchmarkGeneratePlainHash-8             30000000     1069 ns/op\nBenchmarkGenerateHashWithSaltAndPepper-8  5000000     5223 ns/op\nBenchmarkGenerateBcrypt-8                     500 68126630 ns/op\nBenchmarkCompareSaltedHash-8             20000000     1276 ns/op\nBenchmarkComparePlainHash-8              20000000     1174 ns/op\nBenchmarkCompareHash5Peppers-8           20000000     4980 ns/op\nBenchmarkCompareHash10Peppers-8          10000000     4669 ns/op\nBenchmarkCompareHash100Peppers-8          1000000    22150 ns/op\nBenchmarkCompareHash1000Peppers-8           20000  1492037 ns/op\nBenchmarkCompareBCrypt-8                      500 70942742 ns/op\n\n```", "```go\neyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3NMZXZlbCI6InVzZXIiLCJleHAiOjE4MDc3MDEyNDYsInVzZXJJRCI6ImFiY3NkMjMyamZqZiJ9.iQxUbQuEy4Jh4oTkkz0OPGvS86xOWJjdzxHHDBeAolv0982pXKPBMWskSJDF3F8zd8a8nMIlQ5m9tzePoJWe_E5B9PRJEvYAUuSp6bGm7-IQEum8EzHq2tMvYtPl9uzXgOU4C_pIjZh5CjFUeZLk5tWKwOOo8pW4NUSxsV2ZRQ_CGfIrBqEQgKRodeLTcQ4wJkLBILBzmAqTVl-5sLgBEoZ76C_gcvS6l5HAwEAhmiCqtDMX46o8pA72Oa6NiVRsgxrhrKX9rDUBdJAxNwFAwCjTv6su0jTZvkYD80Li9aXiMuM9NX7q5gncbEhfko_byTYryLsmmaUSXNBlnvC_nQ \n\n```", "```go\n{ \n  \"alg\": \"RS256\", \n  \"typ\": \"JWT\" \n} \n\n```", "```go\n{ \n  \"userID\": \"abcsd232fjfj\", \n  \"accessLevel\": \"user\" \n} \n\n```", "```go\nTm \n  <a=<kNX[d\\1k$H_3w5C7NAIR1b \n                           Hy \n1TyՊ5D]Ehuq0&B s \nV_{@! 39Tl5t17@(ӿ.پF5~ H_6+&\\[1m% \n\n```", "```go\nBase64URL(header).Base64URL(payload) \n\n```", "```go\ncat signature.txt | sed -e 's/_/\\//g' -e 's/-/+/g' | base64 -D > signature.sha256 \n\n```", "```go\nopenssl dgst -sha256 -verify ../keys/sample_key.pub -signature signature.sha256 data.txt \n\n```", "```go\n30 // GenerateJWT creates a new JWT and signs it with the private key \n31 func GenerateJWT() []byte { \n32  claims := jws.Claims{} \n33  claims.SetExpiration(time.Now().Add(2880 * time.Minute)) \n34  claims.Set(\"userID\", \"abcsd232jfjf\") \n35  claims.Set(\"accessLevel\", \"user\") \n36 \n37  jwt := jws.NewJWT(claims, crypto.SigningMethodRS256) \n38 \n39  b, _ := jwt.Serialize(rsaPrivate) \n40 \n41  return b \n42 } \n\n```", "```go\nfunc (c Claims) Set(key string, val interface{}) \n\n```", "```go\nfunc NewJWT(claims Claims, method crypto.SigningMethod) jwt.JWT \n\n```", "```go\nfunc (j *jws) Serialize(key interface{}) ([]byte, error) \n\n```", "```go\n46 func ValidateJWT(token []byte) error { \n47  jwt, err := jws.ParseJWT(token) \n48  if err != nil { \n49    return fmt.Errorf(\"Unable to parse token: %v\", err) \n50  } \n51 \n52  if err = jwt.Validate(rsaPublic, crypto.SigningMethodRS256); err != nil { \n54    return fmt.Errorf(\"Unable to validate token: %v\", err) \n55  } \n56 \n57  return nil \n58 } \n\n```", "```go\nfunc ParseJWT(encoded []byte) (jwt.JWT, error) \n\n```", "```go\nfunc (j *jws) Validate(key interface{}, m crypto.SigningMethod, v ...*jwt.Validator) error \n\n```", "```go\nfunc EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error) \n\n```", "```go\n41 // EncryptMessageWithPublicKey encrypts the given string and retuns the encrypted \n42 // result base64 encoded \n43 func EncryptMessageWithPublicKey(message string) (string, error) { \n44 \n45  modulus := rsaPublic.N.BitLen() / 8 \n46  hashLength := 256 / 4 \n47  maxLength := modulus - (hashLength * 2) - 2 \n48 \n49  if len(message) > maxLength { \n50    return \"\", fmt.Errorf(\"The maximum message size must not exceed: %d\", maxLength) \n51  } \n52 \n53  data, err := EncryptDataWithPublicKey([]byte(message)) \n54  return base64.StdEncoding.EncodeToString(data), err \n55 }  \n\n```", "```go\n57 // DecryptMessageWithPrivateKey decrypts the given base64 encoded ciphertext with \n58// the private key and returns plain text \n59 func DecryptMessageWithPrivateKey(message string) (string, error) { \n60  data, err := base64.StdEncoding.DecodeString(message) \n61  if err != nil { \n62    return \"\", err \n63  } \n64 \n65  data, err = DecryptDataWithPrivateKey(data) \n66  return string(data), err \n67 } \n\n```", "```go\nfunc DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error) \n\n```", "```go\n12 func EncryptData(data []byte, key []byte) ([]byte, error) { \n13  if err := validateKey(key); err != nil { \n14    return make([]byte, 0), err \n15  } \n16 \n17  c, err := aes.NewCipher(key) \n18  if err != nil { \n19    return make([]byte, 0), err \n20  } \n21 \n22  gcm, err := cipher.NewGCM(c) \n23  if err != nil { \n24    return make([]byte, 0), err \n25  } \n26 \n27  nonce := make([]byte, gcm.NonceSize()) \n28  if _, err = io.ReadFull(rand.Reader, nonce); err != nil { \n29    return make([]byte, 0), err \n30  } \n31 \n32  return gcm.Seal(nil, nonce, data, nil), nil \n33 } \n\n```", "```go\nfunc NewGCM(cipher Block) (AEAD, error) \n\n```", "```go\nSeal(dst, nonce, plaintext, additionalData []byte) []byte \n\n```", "```go\n35 // DecryptData decrypts the given data with the given key \n36 func DecryptData(data []byte, key []byte) ([]byte, error) { \n37  c, err := aes.NewCipher(key) \n38  if err != nil { \n39    return make([]byte, 0), err \n40  } \n41 \n42  gcm, err := cipher.NewGCM(c) \n43  if err != nil { \n44    return make([]byte, 0), err \n45  } \n46 \n47  nonceSize := gcm.NonceSize() \n48  if len(data) < nonceSize { \n49    return make([]byte, 0), fmt.Errorf(\"ciphertext too short\") \n50  } \n51 \n52  nonce, ciphertext := data[:nonceSize], data[nonceSize:] \n53  return gcm.Open(nil, nonce, ciphertext, nil) \n54 } \n\n```", "```go\nOpen(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) \n\n```", "```go\n69 // EncryptLargeMessageWithPublicKey encrypts the given message by randomly generating \n70 // a cipher. \n71 // Returns the ciphertext for the given message base64 encoded and the key \n72 // used to encypt the message which is encrypted with the public key \n73 func EncryptLargeMessageWithPublicKey(message string) (ciphertext string, cipherkey string, err error) { \n74  key := utils.GenerateRandomString(16) // 16, 24, 32 keysize, random string is 2 bytes per char so 16 chars returns 32 bytes \n75  cipherData, err := symetric.EncryptData([]byte(message), []byte(key)) \n76  if err != nil { \n77    return \"\", \"\", err \n78  } \n79 \n80  cipherkey, err = EncryptMessageWithPublicKey(key) \n81  if err != nil { \n82    return \"\", \"\", err \n83  } \n84 \n85  return base64.StdEncoding.EncodeToString(cipherData), cipherkey, nil \n86 } \n\n```", "```go\n 88 // DecryptLargeMessageWithPrivateKey decrypts the given base64 encoded message by \n 89 // decrypting the base64 encoded key with the rsa private key and then using \n 90 // the result to decrupt the ciphertext \n 91 func DecryptLargeMessageWithPrivateKey(message, key string) (string, error) { \n 92   keystring, err := DecryptMessageWithPrivateKey(key) \n 93  if err != nil { \n 94    return \"\", fmt.Errorf(\"Unable to decrypt key with private key: %s\", err) \n 95  } \n 96 \n 97  messageData, err := base64.StdEncoding.DecodeString(message) \n 98  if err != nil { \n 99    return \"\", err \n100  } \n101 \n102  data, err := symetric.DecryptData(messageData, []byte(keystring)) \n103 \n104  return string(data), err \n105 } \n\n```", "```go\nAug 18 11:00:57 [AuthController] Authentication failed. \n\n```", "```go\nAug 18 11:00:57 [AuthController] Authentication failure \nfor nicj@example.com by 127.0.0.1 - user unknown - \n/user/login /user/myaccount \nAug 18 11:01:18 [AuthController] Authentication failure \nfor nicj@example.com by 127.0.0.1 - invalid password - \n/user/login?err=1 /user/login \nAug 18 11:02:01 [AuthController] Authentication failure \nfor nicj@example.com by 127.0.0.1 - incorrect 2FA code \n- /user/login?err=2 /user/login \n\n```"]