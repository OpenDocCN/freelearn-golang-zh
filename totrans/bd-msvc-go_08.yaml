- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security in microservices can feel like a minefield, and in some ways it is.
    This chapter is mainly intended to look at some of the things that you can do
    to improve the security of your Go code; however, I feel it is important to discuss
    some of the wider issues. In-depth discussion of topics such as firewall configuration
    is best left to specialist books; however, we will introduce some of the concepts
    and problems that are faced so that you can best prepare yourself for some further
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption and signing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we look at ways of securing data, either at rest or in transport, many
    of the methods we discuss will be cryptographically securing data.
  prefs: []
  type: TYPE_NORMAL
- en: '"Cryptography is the science of using mathematics to encrypt and decrypt data.
    Cryptography enables you to store sensitive information or transmit it across
    insecure networks (line like the internet) so that it cannot be read by anyone
    except the intended recipient."'
  prefs: []
  type: TYPE_NORMAL
- en: '- An Introduction to Cryptography, Network Associates, Inc.'
  prefs: []
  type: TYPE_NORMAL
- en: As a basis for the things we will discuss in this chapter, we must first understand
    how cryptography works, not in the way that we need a mathematics degree, but
    to the extent of the parts involved. Cryptography is only as good as the security
    of the keys involved and we need the knowledge of which of these keys can be distributed
    freely and which ones need to be guarded with our lives.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric-key encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symmetric-key encryption is also called secret-key or conventional cryptography:
    one key is used for both the encryption and decryption of the data. For a remote
    end to be able to decrypt this information, it must first have the key, and this
    key must be securely held as a single compromise of one server will lead to the
    compromise of all servers who share this key. It can also make key management
    more complicated, as when you need to change the key, and you should change it
    often, you will need to roll this change out across your entire estate.'
  prefs: []
  type: TYPE_NORMAL
- en: Public-key cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Public-key cryptography was introduced by Whitfield Diffie and Martin Hellman
    in 1975 to get around the need for both sides requiring to know the secret. In
    fact, they were not the first to invent this; it was developed by the British
    Secret Service some years earlier but was kept a military secret.
  prefs: []
  type: TYPE_NORMAL
- en: Public-key cryptography uses a pair of keys for encryption; you will also hear
    it called asymmetric encryption. The public key is used for encrypting information
    while the private can only be used for decrypting. Because there is no way to
    determine the private key from the public, it is common that public keys will
    be published to the world.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Public-key cryptography also gives us the capability of using digital signatures.
    A digital signature works by encrypting a message with a private key and then
    transferring the signed message. If the message can be decrypted with the public
    key, then the message must have originated from the holder of a private key. Due
    to the computation time of encrypting messages and the increase in the size of
    the payload, a standard approach is to create a one-way hash of the message and
    then use the private key to encrypt this. The recipient will decrypt the hash
    with the public key and generate the same hash from the message; then, the message
    can be deemed to be from a trustworthy source.
  prefs: []
  type: TYPE_NORMAL
- en: X.509 digital certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with public keys is that you must be careful that the key you think
    belongs to a recipient is owned by the recipient. If keys are transferred across
    public networks, there is always the possibility of a man-in-the-middle attack.
    An attacker could pose a fake public key as what you believe to be your trusted
    recipient; however, they could replace this with their keys. This would mean that
    the message you think has been transferred securely could, in fact, be decrypted
    and read by a malicious third party.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these issues, digital certificates exist, simplifying the task of establishing
    whether a public key belongs to the reported owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'A digital certificate contains three things:'
  prefs: []
  type: TYPE_NORMAL
- en: A public key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate information such as the owner's name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more digital signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The thing that makes a certificate trustworthy is the digital signatures. The
    certificate is signed by a trusted third party or certificate authority (CA) which
    vouches for your identity and that your public key belongs to you. Anyone can
    create a CA root certificate and sign their certs, and for non-public access to
    systems such as inter-microservice communication, this is quite a common practice.
    For public certificates, however, you pay a CA to sign your certificate. The purpose
    of the pricing is that the CA will ensure that you are who indeed you say you
    are; at present, the most popular CAs are Comodo, Symantec (previously Verisign
    before acquisition), and GoDaddy. The reason you see the padlock in your browser
    is not just because you are using secured communication but that your browser
    has validated the signature of the certificate against one of the 100 or so trusted
    third parties which come bundled with it.
  prefs: []
  type: TYPE_NORMAL
- en: TLS/SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSL, which is the common term for secure transmission of data between two systems,
    is a reference to a deprecated standard first developed by Mozilla back in 1995\.
    It has since been replaced by TLS 1.2, which was released in August 2008; while
    SSL 3.0 still technically works, it was deprecated in June 2015 after a vulnerability
    to the **POODLE** (**Paddling Oracle On Downgraded Legacy Encryption**) attack.
    The POODLE attack discovered by a team of Google security researchers in 2014
    works by the attackers making several requests to a server; this data is then
    analyzed and used, which enables them to decrypt the data in the transport. On
    average, only 256 SSL 3.0 calls need to be made to decrypt 1 byte of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the vulnerability existed for 18 years before being publicly
    disclosed; you might ask why people were still using SSL 3.0 15 years after the
    release of the stronger TLS 1.0? This came about due to a problem that some browsers
    and servers did not support TLS 1.0, so there was a fallback that which would
    allow fallback to a lower level of encryption. Even though, at the time of discovery,
    there was pretty much nobody still using SSL 3.0, the fallback was still in the
    protocol and was, therefore, exploitable by the hackers. The solution for this
    was quite straightforward: disable anything lower than TLS 1.0 in the configuration
    of your server. We have a little history of TLS and SSL but how does it keep your
    data secure?'
  prefs: []
  type: TYPE_NORMAL
- en: TLS works using symmetrical encryption, where the client and the server both
    have a key which is used for encryption and decryption. If you remember the previous
    section, we introduced symmetrical encryption and the problems of distributing
    keys. TLS gets around this problem by using asymmetrical encryption in the first
    part of the handshake. The client retrieves the certificate containing the public
    key from the server and generates a random number; it uses the public key to encrypt
    this random number and sends it back to the server. Now that both parties have
    the random number, they use this to generate symmetrical keys which are used for
    encrypting and decrypting the data over the transport.
  prefs: []
  type: TYPE_NORMAL
- en: External security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is your first line of defense to keep your systems safe, it is commonly
    comprised of layer 2 or 3 firewalls, DDoS protection, web application firewalls,
    and other software and hardware. Before an attacker can compromise your application,
    they must first pass through these layers of hardware and software which is not
    part of your application code but is a shared infrastructure layer that many components
    in the application may share. In this section, we will look at some of this external
    security as well as some attacks that could be used against you. Securing the
    perimeter of your services is often a task completed by operations however as
    developers we need to understand the processes and risks as it greatly enhances
    our ability to harden our application code. In this section, we will look at the
    common methods of external security and also some of the ways hackers can exploit
    your system.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 2 or 3 firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layer 2 is more commonly used for routing as it deals purely with MAC addresses
    and not IP addresses whereas layer 3 is IP address aware. Traditionally, layer
    2 was the only real way to go without adding latency as it would perform at roughly
    the same speed as the wire. With increases in processing power and memory, layer
    3 now performs at wire speeds and generally, when we are looking at edge firewalls,
    which are generally the first entry point into your system, they will be layer
    3 these days. So what does this give us? Firstly, it stops unwanted traffic at
    the edge: we limit the ports which are accessible to the outside world and traffic
    destined for something which is not allowed is stopped at the firewall and does
    not get the chance to execute an attack on the origin. In addition to this, it
    also allows us to restrict access to certain ports. For example, if you are running
    a server, you most likely will want some form of remote access such as SSH. The
    Heartbleed exploit which came out in 2015 took advantage of a vulnerability in
    OpenSSH, and SSH servers which were directly exposed to the Internet would be
    prone to this attack. Using a firewall effectively would mean that private ports
    such as SSH would be locked down to an IP address or IP range, which could be
    your VPN, office IP, or public IP. This dramatically reduces the attack vector
    so while you might be running a version of OpenSSH which is vulnerable to Heartbleed,
    for an attacker to take advantage of this, they would need to be inside of your
    protected zone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Heartbleed vulnerability exploited the ability to execute a buffer overrun
    attack. For example, you ask the server for a 4-letter word but specify the length
    of 500; what you get back is the 4-letter word, and the remaining 496 characters
    are the blocks of memory which follow the memory address of the initial allocation.
    In practice, this allowed a hacker to access chunks of memory in the server randomly;
    this may contain items, such as change password requests, which give them credentials
    to access the server. If you are running a globally available SSH server, then
    you may find you have a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c128381-747f-4ba7-8e96-be61fe250825.png)'
  prefs: []
  type: TYPE_IMG
- en: Web application firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web application firewall (**WAF)** is configured as your second or third
    line of defense in a system. To understand what a WAF is, let''s look at the definition
    from the Open Web Application Security Project (OWASP):'
  prefs: []
  type: TYPE_NORMAL
- en: '"A web application firewall (WAF) is an application firewall for HTTP applications.
    It applies a set of rules to an HTTP conversation. These rules cover common attacks
    such as cross-site scripting (XSS) and SQL injection.'
  prefs: []
  type: TYPE_NORMAL
- en: While proxies protect clients, WAFs protect servers. A WAF is deployed to protect
    a specific web application or set of web applications. A WAF can be considered
    a reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: WAFs may come in the form of an appliance, server plugin, or filter, and may
    be customized to an application. The effort to perform this customization can
    be significant and needs to be maintained as the application is modified."
  prefs: []
  type: TYPE_NORMAL
- en: OWASP is an incredibly useful resource and in fact has provided a core ruleset
    for ModSecurity, which protects against attacks such as SQL Injection XSS, Shellshock.
    As a bare minimum, setting up a WAF such as ModSecurity and the OWASP CRS should
    be your minimum requirement. Hosting this inside a Docker container should be
    relatively trivial, and this could form the second line of defense behind your
    layer 2 firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another option: some CDN companies such as Cloudflare offer a
    hosted WAF. This is protection at the edge of your network and thanks to the expertise
    of businesses such as Cloudflare, you do not need to worry about configuration.
    In fact, Cloudflare supports the OWASP CRS ([https://www.modsecurity.org/crs/](https://www.modsecurity.org/crs/)).'
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to a WAF, an API Gateway can be a useful tool to have; this can
    serve a dual purpose of routing your public APIs to their backend services and
    some additional features such as token validation at the edge and input validation
    and transformation. When we talked about the confused deputy problem, where an
    attacker who is behind your firewall can execute commands which they are not privileged
    to do, we looked at the possibilities for encrypting web tokens; the problem with
    this is that private keys for decrypting these tokens would need to be distributed
    across multiple backend services. This makes managing keys far more challenging
    than it should be. An API Gateway can simplify this situation by being the only
    layer which can decrypt a message; the other services use the public key to verify
    a signature. API Gateways often implement many other first-line features such
    as but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Request validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request and response transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an element of crossover between a WAF and an API Gateway; however,
    the two should be treated as two distinctly separate parts of your infrastructure.
    Regarding providers of an API Gateway, this seems to be a developing area; AWS
    has an advanced API Gateway which can be used if you have bought into the AWS
    PaS environment. For standalone deployments, Kong ([https://getkong.org/](https://getkong.org/)),
    Tyk ([https://tyk.io/](https://tyk.io/)), Apigee ([https://apigee.com/api-management/#/homepage](https://apigee.com/api-management/#/homepage)),
    Mashery ([https://www.mashery.com/](https://www.mashery.com/)), and the Anypoint
    Platform from Mulesoft ([https://www.mulesoft.com/](https://www.mulesoft.com/))
    are among the leaders in this field. It is, of course, possible to build your
    own API Gateway backed with Nginx or HAProxy; however, I recommend, you first
    check out one of the specific platforms before going ahead and building your own.
  prefs: []
  type: TYPE_NORMAL
- en: DDoS protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On October 21, 2016, a massive internet outage was caused by attackers targeting
    DYN's DNS servers using a Mirai botnet. The Mirai exploit takes advantage of vulnerabilities
    in IP cameras and DVRs made by the Chinese company called XionMai Technologies.
    Rather than attacking a target, the attackers decided to take down a major part
    of the internet's infrastructure, knocking out most of the east and west coast
    of America. The Mirai exploit takes advantage of just 60 usernames and passwords
    to attempt to update the firmware of the vulnerable devices. Once the malware
    had been installed, the device was then controllable by the botnet. All that was
    left to do was tell the bots to start a DNS attack against DYNs nameservers.
  prefs: []
  type: TYPE_NORMAL
- en: The code for Mirai has been published online; you can find it using Google without
    much effort. The thing I hope you find surprising looking at this code is just
    how simple it is. Now, I do not want to take anything away from the complexity
    of devising this attack; I am merely talking about the implementation. Quite a
    significant portion of the code is written in Go too, so is very readable. There
    is some excellent use of channels. If you do look at the code, try and identify
    the area which could be improved with a semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: A report published by Akamai stated that 98.34% of all attacks this year were
    infrastructure oriented, with only 1.66% aiming for the application layer. Of
    that 98.34%, many could be avoided with a little network hygiene. Let's look at
    the top threats and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Types of DDoS attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the types of DDos attack:'
  prefs: []
  type: TYPE_NORMAL
- en: UDP fragment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chargen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SYN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP fragment attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A UDP fragment attack is where the attacker exploits the way that datagram fragmentation
    works on networks. Every network has a limit called a maximum transmission unit
    (MTU). If a datagram sent to the network is greater than the MTU, it is fragmented
    to be transmitted successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP fragment attack works by creating datagrams which contain fake packets;
    when the server attempts to reassemble these packets, it is unable to do so and
    the resources are quickly overwhelmed.
  prefs: []
  type: TYPE_NORMAL
- en: UDP flood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A UDP flood attack works by sending a flood of UDP packets with a spoofed source
    address to an IP address. The server will respond to these requests, sending a
    reply to the spoofed addresses. Due to the high volume of the attack, a router
    will exceed its limit of UDP datagrams per second and stop sending to all addresses
    in the same security zone for a period.
  prefs: []
  type: TYPE_NORMAL
- en: This also often utilizes a technique called a reflected attack. When the IP
    address for the source is spoofed, the return packets are not sent back to the
    real source but the spoofed IP address. The reason this technique is used is that
    it allows the sender to amplify an attack by only expending resources on the outbound
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DNS attack utilizes a UDP flood to take out a DNS server; many requests are
    made to query a DNS server. The requests are designed to return a very large reply
    from a tiny request to maximize the efficiency of the attack since the response
    is often not received by the sender.
  prefs: []
  type: TYPE_NORMAL
- en: The attack which we looked at earlier, which targeted Dyn's infrastructure,
    taking out many websites on the east and west coast of America in October 2016,
    was in the form of this attack. Unlike most DNS attacks, the Miraia net did not
    use Reflection, it allowed the responses to be returned to the sender, which was
    possible due to the enormous number of compromised devices.
  prefs: []
  type: TYPE_NORMAL
- en: NTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NTP is another amplification attack which takes advantage of a feature built
    into NTP servers, which returns up to the last 600 machines that have interacted
    with it. This attack takes advantage of open NTP servers which support the MONLIST
    command and have not been patched. The project [http://openntpproject.org/](http://openntpproject.org/)
    aims to identify unpatched servers to encourage the removal of this exploit. Unfortunately,
    research carried out in 2014 by NSFOCUS found that there were over 17,000 servers
    worldwide which were vulnerable to the exploit. Assuming all these servers could
    be used and using payload sizes from an NTP attack which hit CloudFlare in 2014,
    we have the capability of a DDoS attack of 1.4 Tbps. This traffic would be twice
    the biggest attack known today. NTP provides a platform for one of the most powerful
    application attacks and only exists due to poorly patched servers.
  prefs: []
  type: TYPE_NORMAL
- en: CHARGEN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **CHARGEN** (**Character Generation Protocol**) attack is another reflected
    amplification attack. The attack takes advantage of open CHARGEN servers which,
    running on port `19`, will return a random number of characters between 0 and
    512 in length every time it receives a datagram from the connecting host. CHARGEN
    is designed to be used as a source of byte-stream for debugging TCP network code
    and bandwidth measurement. CHARGEN attacks work by abusing CHARGEN servers which
    have been enabled on network-connected printers.
  prefs: []
  type: TYPE_NORMAL
- en: SYN flood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A SYN flood is a classic DDoS attack that sends a lot of packets to a machine,
    attempting to keep connections from being closed. The connections eventually time
    out on the server side; however, the aim is to repeatedly hit the server, consuming
    all the available resources so genuine connections cannot get through.
  prefs: []
  type: TYPE_NORMAL
- en: SSDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSDP is the **Simple Service Discovery Protocol**, often used for the discovery
    of **Plug & Play** (**UPnP**) devices. This is exactly the protocol implemented
    by your home router, so next time you complain that your favorite gaming network
    is offline, why not first check that you are not inadvertently exposing SSDP to
    the internet?
  prefs: []
  type: TYPE_NORMAL
- en: ACK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An ACK flood takes advantage of the three-way handshake that exists when a
    client connects to a server. The first step is the client sends an SYN packet
    to which an SYN-ACK packet is replied from the server. The client then finally
    replies with an ACK packet and then the connection is open for data. An ACK flood
    takes one of two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: The attacker sends a spoofed SYN packet to a server and then follows this with
    a spoofed SYN-ACK packet. The server then opens and holds open a connection. If
    enough connections are open, then the server will eventually run out of resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second method is only to send the ACK packet. Since the server does not
    have an open connection, this packet will be dropped; however, it still consumes
    resources having to process these packets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attack is similar to a SYN attack; however, it can be more efficient due
    to the way it tricks DDoS filters to pass the packets to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoiding these attacks is not so simple: you need to detect and filter this
    activity at the edge of your network. You also require massive amounts of bandwidth
    to soak up the traffic inbound to your system, and this is not, in my opinion,
    something that can or should be tackled by an in-house solution.'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of defense to avoiding DDoS attacks is to make sure you are not
    enabling them. Configuring a firewall to ensure you are not exposing vulnerable
    services and patching your services will mean an attacker cannot use your network
    infrastructure to attack others. The second line is to leverage the power of Cloudflare,
    Akamai, Imperva, or the other experts who have the infrastructure and network
    scrubbing filters to ensure the traffic never gets to your server.
  prefs: []
  type: TYPE_NORMAL
- en: Application security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now, hopefully, understand some of the ways that encryption works and some
    of the ways that our infrastructure is vulnerable, but what about our application?
    It is entirely plausible that someone will want to break into your system. While
    a DDoS attack might cause you some inconvenience for a day or so, a hacker who
    gets past your firewall and into your application servers could cause serious
    financial or reputational damage. The first thing we need to do is to operate
    on a principle of no trust. David Strauss, in his talk, *Don't build "Death Star"
    security* (2016 O'Reilly software architecture conference) looked at the WikiLeaks
    website and concluded that it was not the first line of defense which fell, but
    the attackers were able to gain access to various backend systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same conference, Sam Newman, who wrote the excellent *Microservices*
    book (which I encourage everyone to read if they have not yet), was also giving
    a talk on the *Application Security and Microservices*. Sam stated that *Microservices
    give us the capability for multiple perimeters*; while this can be a benefit,
    it can also cause problems. He suggested a model for microservices security which
    is used by ThoughtWorks; this advises that you follow the following four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prevention is where you should spend the most of your effort, and the remainder
    of this chapter will concentrate on just that. This is implementing techniques
    for secure communication, authorization, and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detection relates to your application logs and ModSecurity logs if you are using
    it. We discussed in the previous chapter some methods for logging in your system,
    and I suggest you think about the type of logging you will need to detect malicious
    intent, not just for fault finding. This should form part of your non-functional
    requirements when you are planning a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The response is how you tackle the breach: if an incident occurs, you need
    to deal with it immediately. This not only involves closing the attackers out
    of the system but also identifying what has been taken and in the case of personal
    information or credit card loss, contacting your customers and being open about
    the problem. Think about what your company does about fire drills in case of fire.
    You practice so that, in the event there is a fire, everyone knows what to do
    and how to react quickly. Game days are standard practice for a few companies,
    where they will rehearse disaster recovery situations. If you intend to practice
    your response process, you need to ensure that the whole business is involved;
    while tech will be included in the diagnostic and rectification of the problem,
    there needs to be involvement on a business level, legal, PR, and communications
    for this to be truly useful.'
  prefs: []
  type: TYPE_NORMAL
- en: Recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recovery process should be the simplest step, assuming your infrastructure
    is well backed up and automated. Sam suggests not taking any chances and *burning
    it down*, rebuilding with new keys and passwords to avoid a further attack.
  prefs: []
  type: TYPE_NORMAL
- en: Confused deputy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The confused deputy problem is where one system can abuse the trust another
    system has and will execute a command which it would not ordinarily be allowed
    to do. Consider a system which issues refunds inside of your system; you think
    that the system is safe as it is a private API sitting behind your firewall, but
    what if an attacker manages to compromise your firewall? If they can detect that
    sending a `POST` request with a payload to a server will refund money to a bank
    or PayPal account then they do not even need to attempt to attack further into
    your infrastructure to get their payday. This scenario is all too common; when
    building systems, we place too much trust on the external defenses and run a principle
    of trust for anything that sits behind the firewall. You also may be assuming
    that the attacker is actually outside your organization; what if they have access
    to the servers legitimately? In the USA, internal fraud accounts for XXX of financial
    losses; we need to build systems which make this situation difficult and we need
    to make sure that we have a full audit trail of access and operation. It does
    not need to be a difficult challenge to solve; we will see two very simple ways
    that we can counter this problem which when implemented will neither cause you
    additional development time or operational time.
  prefs: []
  type: TYPE_NORMAL
- en: How an attacker could bypass the firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are probably a little confused as to why the internal security of services
    matters; after all, you have a great firewall, and all of the ports which should
    be are locked down.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker has multiple tools in their arsenal to bypass your security systems.
    We are not talking about people attempting to leverage existing exploits using
    tooling found on the internet. We are talking about sophisticated and intelligent
    hackers who, for whatever reason, are intent on causing harm to your company.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are an e-commerce platform built utilizing the latest microservices architectural
    patterns. Your application code is running in Docker containers and you are hosting
    everything on AWS with Kubenetes. The front end of the system is a simple Node.js
    application which talks to a variety of private APIs to provide many of the transactional
    capabilities on the site. The application itself does not have a database and
    there are no secrets stored in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An attacker finds a remote code execution vulnerability in the templating engine
    used for the front end presentation. They discover that the system is running
    on Kubenettes and that the control API is available inside the compromised container.
    They use this API to be able to launch a rogue container on your network which,
    running in privileged mode, starts a reverse SSH tunnel to the attacker's remote
    server, which completely bypasses the firewall and gives them root access to the
    container. From here, they sniff the traffic on the network and determine that
    the payment gateway has `POST` endpoint v1/refunds; by sending a JSON payload
    to this endpoint, it is possible to refund huge amounts of money to an offshore
    bank account.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the firewall was protecting inbound traffic and only ports `80`
    and `443` were allowed inbound, the attacker leveraged a vulnerability inside
    the application to be able to create a backdoor for themselves. The nonexistent
    security around launching applications inside the production environment and open
    non-encrypted communication between the services gave them all they needed to
    empty the company's bank account.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very real threat, but thankfully Go has many excellent tools to help
    us make it tough for an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our scenario, the attacker used a remote code execution exploit to gain access
    to our environment. The first line of defense after the WAF is input validation.
    All data should be validated to set bounds; it does not take an enormous amount
    of time to implement and can help you protect against such an attack. There is
    an excellent library in Go which is part of the go-playground package ([https://github.com/go-playground/validator](https://github.com/go-playground/validator)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this simple code example to see just how easy it is to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validation/main.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The nice thing about the validator package is that it works with field tags,
    which is an unobtrusive way of keeping your code clean. By adding the validate
    tag, we can specify one of many different validation functions for the field,
    including email, URL, IP addresses, minimum and maximum length, and event regular
    expressions. It is also possible to have multiple validators on the same field.
    For example, should I wish to validate that my input is an email and has a minimum
    length of three, I could add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The validators process in the listed order, so the validation function to check
    whether the field contained an email would be validated before checking the length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the package is also incredibly simple: if we take a look at the example
    from our tests, we can see that validation is actually only one method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In its simplest form, all we need to do to validate a request are two method
    calls. First, we create a new validator like in line 10 using the `New` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `New` function returns a new instance of `validate` with sane defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can call the `validate` method to check that our structure is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Struct` function validates a struct's exposed fields, and automatically
    validates nested structs, unless otherwise specified.
  prefs: []
  type: TYPE_NORMAL
- en: It returns `InvalidValidationError` for bad values passed in and nil or `ValidationErrors`
    as error otherwise. You will need to assert the error if it's not nil, for example,
    `err.(validator.ValidationErrors)` to access the array of errors.
  prefs: []
  type: TYPE_NORMAL
- en: If the struct has validation errors, `Struct` will return an error; to get detailed
    messages for the error, we can cast the error to a `ValidationErrors` object,
    which is a collection of `FieldError`. To see all the available methods for the
    `FieldError` object, check out the godoc ([https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError](https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError)).
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, we should also beef up our testing techniques. One highly effective
    way of testing the bounds of input validation is to use a fuzzer inside our tests;
    this just broadens the scope of what we are testing to make sure we have all the
    edge cases covered. A potential attacker will most likely use this technique to
    test the boundary of your API so why not get the edge on them and make sure all
    of your input is correctly handled?
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular implementations of a fuzzer in Go is the excellent package
    `github.com/dvyukov/go-fuzz/go-fuzz`. The `go-fuzz` is a coverage guided fuzzer,
    it uses an instrumented build of your application code exposing the code coverage
    which it uses to ensure that the maximum code paths are covered. The fuzzer generates
    random input the intent behind which is to either crash the application or to
    produce unexpected output. Fuzzing is an advanced topic however in the code samples
    for this chapter at `validation/fuzzer` you can find an example of how to fuzz
    the validation handler we have just covered.
  prefs: []
  type: TYPE_NORMAL
- en: TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other exploit that our attacker took advantage of was that all of the traffic
    behind the firewall was not encrypted and by sniffing the traffic between services,
    they discovered a method to fake a call to the payments gateway to send a refund
    to a remote bank account. The other issue might be that you are passing sensitive
    information such as bank details or credit card numbers between your frontend
    service and your payment service. Even if you are not storing the credit card
    numbers on your system, if you are not careful, you could expose this traffic
    to an attacker by assuming that everything behind your firewall is safe. TLS or
    Transport Layer Security no longer adds any overhead due to the advances in processing
    power available to servers these days. In addition to this, services inside a
    firewall generally have a limited number of connections; so, to improve the time
    that is lost by the TLS handshake, you can use persistent reusable connections
    in your service to minimize this problem. Let's take a look at how we can implement
    TLS really quickly in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Generating private keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we do anything, we need to generate a key and a certificate. Go actually
    has a pretty awesome utility which can generate keys and certificates for us only
    in Go but before we look at that, let''s take a look at how we would traditionally
    generate a certificate using `openssl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate us a key in PEM format, which uses the RSA algorithm with
    a 4096 bit size; the key will be encrypted using the aes256 format and will prompt
    you for a password. However, we also need an X.509 certificate which will be used
    with this key; to generate this, we can again use `openssl` and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command will use the key to generate the certificate again in PEM format
    with a validity of one year. In practice, we should not generate certificates
    which have such a long lifespan for our internal services. Since we control the
    deployment of the services, we should try to rotate keys as often as possible.
    The other thing to note about this certificate is that while it is valid and secure,
    it will not be trusted by clients automatically. This is because the root is auto-generated
    instead of coming from a trusted authority. This is fine for internal use; however,
    if we need the service to be public facing we would need to ask a trusted source
    to generate our certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to do this with the `openssl` command-line tool, let's see how
    we could achieve the same thing using only the Go crypto libraries. The example
    application, which can be found at [https://golang.org/src/crypto/tls/generate_cert.go](https://golang.org/src/crypto/tls/generate_cert.go),
    gives us the details for this. Let's now take a look at the process step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the example in `tls/generate_keys`, we can see that we
    are using the `GenerateKey` method from the `crypto/edcsa` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature for the `GenerateKey` method on line **120** is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is an I/O reader which will return random numbers; for
    this, we are using the `rand.Reader` method, which is a global shared instance
    of a cryptographically strong pseudo-random generator. On Linux, this will use
    `/dev/urandom` and on Windows, `CryptGenRandomAPI`. The second is the bit size
    to use: bigger is more secure but will result in slower encryption and decryption
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to serialize the key to a file, we need to run through a few different
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On line **192**, we are taking the `PrivateKey` reference that is returned
    from the `GenerateKey` function and we need to convert it into a slice of bytes
    so that we can serialize this to disk. The `crypto/x509` package has many useful
    functions to enable operations like this; the one that we need to use is `MarshalPKCS1PrivateKey`,
    which will marshal our RSA-based private key into ASN.1, DER format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the key in byte format, we are ready to be able to write it to
    the file; however, just writing the bytes to a file is not enough; we need to
    be able to write it in PEM format, which looks like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The format for this file is as shown in the following code, and while we could
    manually create this file, the crypto library in Go has us covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to keep our private keys safe, so if a password is specified,
    we are going to encrypt the key like we were doing with the command-line option.
    In line **196**, we are checking to see whether a password has been specified
    and, if so, we are calling the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method returns a PEM block for the given DER encoded data which is encrypted
    with the given password. The algorithm we are using in our example is AES256;
    however, Go also supports the following ciphers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not want to encrypt the key with a password then we need to do something
    slightly different. In line **202**, we need to create the PEM block ourselves;
    the `pem` package provides this capability for us with the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether we are using an encrypted PEM block or unencrypted, we use this with
    the `Encode` function on the same package which will convert our data into the
    correct format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Generating X.509 certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a private key, we can go ahead and generate our certificate.
    We have already seen how easy this is to create with `openssl` and it is just
    as easy in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing in a few parameters into this method. One of the first, which
    might be a little strange, is the template. Because we need to generate different
    kinds of certificate, such as those which can sign other certificates to create
    a chain of trust, we need to create a template to use which has some of the defaults
    populated. If we look at the `rootTemplate`, which is defined at line **22**,
    we can examine some of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Subject, which is an instance of the `pkix.Name` struct, has the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These are the common elements of the X.509 distinguished name; most of these
    elements are straightforward and represent the details of the owner of the certificate.
    `SerialNumber` is one of the most important. The serial number must be unique
    for a certificate chain; however, it does not need to be sequential. If we look
    at our example in line **138**, we are generating a large random integer 128 bits
    in length but you can change this to be anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting bit of our certificate generation is the `SubjectKey`;
    this is required for the chain of trust to work correctly. If a certificate is
    signed by another then the Authority Key Identifier will match the parent certificate''s
    Subject Key Identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate the subject keys, we need to serialize the public version of the
    key into DER format, and then extract the bytes for just the key part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In line **174**, we are converting the public key into a byte array using the
    `MarshalPKIXPublicKey` function on the `x509` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns us a byte array which represents an ASN.1 data structure; to get
    access to the underlying data for the key, we need to unmarshal it into the struct
    format which is defined at line **169**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform this conversion, we can use the `Unmarshal` function, which is on
    the package `encoding/asn1`. This method attempts to convert the ASN.1 data format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in line **161**, we can create the certificate, using the `CreateCertificate`
    method on the `crypto/x509` package. This method accepts a parent certificate,
    which will be used to sign the child. For our root certificate, we want this to
    be self-signed so we set both the parent certificate and the private key to the
    root certificate''s private key and template. For the intermediate and leaf certificates,
    we would use the parent''s details for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateCertificate` function creates a new certificate based on a template.
    The following members of the template are used: `SerialNumber`, `Subject`, `NotBefore`,
    `NotAfter`, `KeyUsage`, `ExtKeyUsage`, `UnknownExtKeyUsage`, `BasicConstraintsValid`,
    `IsCA`, `MaxPathLen`, `SubjectKeyId`, `DNSNames`, `PermittedDNSDomainsCritical`,
    `PermittedDNSDomains`, and `SignatureAlgorithm`.'
  prefs: []
  type: TYPE_NORMAL
- en: The certificate is signed by parent. If the parent is equal to template then
    the certificate is self-signed. The parameter `pub` is the public key of the signee
    and `priv` is the private key of the signer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have certificates, let''s see how we can secure a web server using TLS.
    Back in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml), *Introduction
    to Microservices*, you may remember being introduced to `http.ListenAndServe`
    from the standard HTTP package, which started an HTTP web server. Go, of course,
    has an equally amazing package for creating a web server which is secured with
    TLS. In fact, it is only two more parameters than the standard `ListenAndServe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do is pass the paths to our certificate and the corresponding
    private key and the server when started will serve traffic using TLS. If we are
    using self-signed certificates, and in our example we are, then we need to write
    some additional code for our clients, otherwise when we try to make a connection
    to the server, we will get an error message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this, we need to create a new cert pool and pass this to the client''s
    TLS settings. By default, Go will use the host''s root CA set, which will not
    include our self-signed certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In line **13**, we are creating a new certificate pool and then we read the
    certifcates, which are PEM encoded into a slice of bytes. In line **20**, we can
    then add these certificates to the new cert pool; for the certificate to be identified
    as valid, we need both the intermediate certificate and the root certificate.
    We can then create a new TLS config and add the certs; this is then added to the
    transport and ultimately, in line **38**, the client.
  prefs: []
  type: TYPE_NORMAL
- en: When we now run the client, it connects without any problem and we will see
    the `Hello World` response correctly returned from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Securing data at rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming our system had been attached to a database for storing things such
    as user accounts, the attacker would have been able to get access to the complete
    database of passwords. One of the things that we should think about when are storing
    data in a database is the encryption of our data. There is no doubt that encrypting
    data is more expensive than not encrypting it and that it can sometimes be difficult
    to figure out which fields or tables we should encrypt and which we should leave
    plain.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the many benefits microservices give us is that we separate function
    and data between our systems. This can make deciding what data to encrypt easier
    as rather than attempting to understand which data to encrypt within a datastore,
    you make a simpler decision: is there any data which needs to be encrypted inside
    this datastore? If so, then simply encrypt all of it. It may be beneficial to
    perform this encryption in the application layer rather than the datastore as
    applications tend to scale better than datastores and you must consider the edge
    cases that caching may introduce. If, to reduce the pressure on a datastore, you
    add an intermediary caching layer using Elasticache or another technology, you
    need to think about the security of your data. If the data is encrypted in the
    database then you need to ensure that the same level of encryption is applied
    to the cache.'
  prefs: []
  type: TYPE_NORMAL
- en: Physical machine access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When I say "physically", I mean access by humans; the code could be running
    on a VM. However, the problem is the same: all too often, I find that companies
    give developers access to databases and other sources of information running in
    a production environment. Even if they do not have access to the database password,
    they may have access to the config store or the ability to SSH into an application
    server and read the configuration from the application that way. There is a security
    principle called the **least privilege**; this recommends that accounts and services
    have the least amount of privilege to perform their business function. Even if
    you have ensured that the machine-to-machine communication is secured and there
    are appropriate safeguards with your firewall, there is always an opportunity
    for an attacker to access your systems by the back door. Consider the following
    scenario. A nontechnical employee in your company opens an email or downloads
    some software which installs some malware on their laptop. The attacker uses this
    to get access to their machine and, from there, manages to travel horizontally
    through the network and eventually ends up on your laptop. Now, since you are
    logged in and busy working and connected to the VPN into production, they manage
    to manage to install a key logger on your machine which gives them access to your
    passwords, they retrieve your SSH keys from your disk and because you have pretty
    much full access to production, now so do they. While this may seem like science
    fiction, it is very possible. You can, of course, secure your internal network
    but the best way to avoid such an attack is to restrict access to production environments
    and data severely. You should not ever need this level of access; with robust
    tests in my code, I often find that when a service misbehaves, it is not something
    that production access helps me with. I should be able to reproduce almost any
    error in a staging environment and the logging and metrics data that the service
    is emitting should be enough for me to diagnose any issues. I am not saying I
    have never debugged live on production but thankfully not in the last decade.
    Tooling and practice are such these days that we should never need to return to
    those acts.'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you are looking for practical web security advice on security, OWASP
    should almost always be your first port of call.
  prefs: []
  type: TYPE_NORMAL
- en: 'For help with APIs, OWASP can also help: they have published the *REST Security
    Cheat Sheet* ([https://www.owasp.org/index.php/REST\_Security\_Cheat\_Sheet](https://www.owasp.org/index.php/REST/_Security/_Cheat/_Sheet)).'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as we have already discussed in this book, there are many different
    standards for building APIs and REST is but one of them; there are, however, some
    useful generic tips that we can leverage from this guide.
  prefs: []
  type: TYPE_NORMAL
- en: Never storing session tokens in a URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JWT, which is probably the most common session token you will find used with
    APIs, encodes into a format which is URL-safe. Storing or passing the token in
    a URL, however, is not recommended, and it should always be stored in either a
    cookie or as a `POST` variable. The reason for this is that if you pass session
    tokens in a URL, these can leak into your server logs and, depending upon how
    you manage the duration of the token, if an attacker gets access to your log files,
    they may also be able to obtain full access to execute commands for your users.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting (XSS) and cross-site request forgery (CRSF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XSS and CRSF only apply when your API is going to be used from a web browser,
    such as in a single page app or a direct JavaScript call. However, to protect
    against an attacker injecting malicious JavaScript which can retrieve your session
    token, you should make sure that it is stored in a cookie which is marked as HTTP-only
    and that you only ever send them over HTTPS to stop them being captured in transit.
    In addition to this, we can add a layer of security which checks the HTTP referrer
    sent by the browser against the expected domain. While it is possible to fake
    the HTTP referrer using something like cURL, it is not possible or incredibly
    difficult to do this from JavaScript in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Insecure direct object references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are building an API, you need to ensure that you are checking the authenticated
    users can modify the object in the request. This would be performed server side;
    we do not want to give our attacker the capability to create a genuine login and
    then be able to manipulate the request to perform an action on behalf of another
    user.
  prefs: []
  type: TYPE_NORMAL
- en: The OWASP documents are regularly updated as new attacks and vulnerabilities
    are found; check the site often and keep yourself up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Authentication is the process or action of checking something to be true, such
    as: does this username pair with this password? Authorization is the function
    of specifying access rights or policy regarding a user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication is a well-understood concept; however, there are a few concepts
    we need to understand to ensure that this action cannot be compromised, such as
    never storing passwords in plain text in a datastore and preventing the hijack
    of a login session by transferring an active token to a third party. Authorization,
    however, is equally important; we discussed earlier the confused deputy problem:
    even when a user is authenticated, we must still control the actions that they
    can perform on a system. Services which operate on a principle of trust between
    themselves and do not independently validate a user''s rights are wide open to
    abuse should an attacker compromise your firewall. In this section, we will look
    at just how easy it is to solve both of these problems, providing you with the
    patterns so that your services never need to be exposed.'
  prefs: []
  type: TYPE_NORMAL
- en: Password hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A hash is one-way cryptography: you take a series of letters and numbers and
    by running them through the hashing algorithm, you get a sequence which while
    reproducible with the same original input cannot be reversed mathematically. So
    why would you use a hash instead of just encrypting the data? Firstly, hashes
    do not require any keys, and therefore they are not vulnerable to the loss of
    private keys, and they are perfect for storing data which does not need to be
    reversed. Consider passwords: your system never needs to know what the user''s
    password is, and it only needs to know that the value passed to you by the user
    matches the stored value. Hashing a password is the perfect approach to security:
    you hash the input from the user and compare this hash with the value you have
    in your data store. If the database is compromised then the attacker will not
    be able to decode the passwords. The attacker could, of course, attempt to brute
    force the password, but currently, there is not enough computing power on the
    planet to be able to decode a decent hash. Does that mean that hashes are invulnerable?
    No. In fact, many thought that MD5 hashes were irreversible; however, this algorithm
    had been compromised. It is possible to find collisions within a matter of seconds.
    There was a case back in 2011 where attackers used this vulnerability to create
    fake SSL certificates which allowed them to exploit users'' trust. Thankfully,
    we no longer use MD5 or SHA-1 for cryptographic purposes. You will still find
    it used for signatures such as in git commits where the possibilities of collision
    are offset by the speed of calculation but for security, we need to use a more
    modern algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a little seasoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a hash on its own provides a decent level of security, we can add a salt
    and a pepper. The salt is stored in the database along with the encrypted data.
    The intention behind this is to make brute forcing data more computationally expensive.
    It stops the attacker from using Rainbow tables to attack your data. Rainbow tables
    are precomputed tables of hashes, so instead of having to compute the hash with
    every attempt, you can simply look up the encrypted string in the table and return
    the original value. To counter this, we added a salt which is randomly generated
    for each value and appended to it before hashing. Even though we store this in
    the database along with the hashed value as we need to use it later to check the
    value, it stops the use of Rainbow tables as each table would have to be computed
    for every salt, and this is computationally very expensive. To further enhance
    security, we often also add a pepper, which is a precomputed value which is stored
    separately from the salt and hashed value.
  prefs: []
  type: TYPE_NORMAL
- en: Common practice is to pre-generate a list of peppers and store them in a configuration
    store. When you are first hashing a password or other value, you would select
    one of the peppers at random and append it to the value in the same way as you
    do for the salt. Then when checking a supplied value matches the hash, you would
    loop through the list of peppers and generate a hash to compare with each one.
    This adds a little computation time to checking a password in your service; however,
    not nearly as much effort as it will add to the attacker who is attempting to
    brute force your values. Let's take a look at how we can hash a value in using
    a salt and a pepper.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the source code in `hashing/hash.go`, we can create a
    hash from an input string using the following `GenerateHash` method. The `GenerateHash`
    method has the following signature and given an input string, it returns a random
    salt and the hashed string using the sha512 algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this, we can simply call the method with our string to hash and we would
    get some output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look more in depth at what this function is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we are doing, on line **25**, is retrieving a random pepper
    from the slice of peppers which is passed to the struct when we initialize it
    with `New(peppers)`. The pepper does not need to be stored in the database; this
    is purely to slow down a potential attacker by requiring them to increase their
    brute force attempts by a factor of five in our example. We can increase the number
    of peppers and as you can see from the benchmark below, even at 1,000 peppers,
    we are still able to compare a hash in 1 ms but for the additional security this
    will give you is probably not worth it. It takes 4,634 ns to generate one hash
    and due to the length of the string, we would need to generate a maximum of 6.2e19
    or 62 quintillion permutations. This is assuming 63 allowable characters and a
    password 11 characters in length. That is a pretty big number, and to generate
    that many hashes would take roughly 9 million years to brute force for a single
    CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, not all passwords are complex and many are susceptible to an attack
    known as a dictionary attack. Instead of attempting all 62 quintillion permutations,
    the dictionary attack concentrates on those which are most likely to succeed.
    The dictionaries themselves are often derived from password databases which have
    previously been exploited and since humans are somewhat predictable, we often
    use the same passwords. Because our password `HelloWorld1` is already in the dictionary
    which contains 14 million other passwords, when I attempted to break the salted
    hash using `John the Ripper`, it only took 2.4 seconds to retrieve the password.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pepper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a fine line as to what we can do to stop our users using simple passwords.
    We should always have a policy of what constitutes a good password--minimum length,
    the mixture of case, an addition of symbols, and so on--but usability can be compromised
    the more complex the password gets. Adding a pepper, however, can help to slow
    the attacker down: the pepper or peppers are known to the system but not stored
    with the password and salt. They can be hard coded into the application code,
    stored as launch configuration or stored in a secure vault which is accessed at
    runtime. In the same way, we appended the salt to the user''s password, we do
    the same thing with the pepper. Should the database tables become compromised
    due to a SQL injection attack then unless the attacker can retrieve the peppers,
    the database is useless. Of course, it is possible for the attacker to get hold
    of your peppers; however, almost everything in security is about making it difficult
    and slowing someone down.'
  prefs: []
  type: TYPE_NORMAL
- en: bcrypt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'bcrypt is another popular method of hashing passwords, it uses a variable number
    of rounds to generate the hash which both slows down the ability to brute force
    the attack and the time it takes to generate the hash. Go has an implementation
    of bcrypt which is provided by the experimental packages at [https://godoc.org/golang.org/x/crypto/bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt).
    To hash a password with bcrypt we use the `GenerateFromPassword` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `GenerateFromPassword` method returns the bcrypt hash of the password at
    the given cost. The cost is a variable which allows you to increase the security
    of the returned hash at the expense of more processing time to generate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the equality of a bcrypt hash we can not call `GenerateFromPassword`
    again with the given password and compare the output to the hash we have stored
    as `GenerateFromPassword` will create a different hash every time it is run. To
    compare equality we need to use the `CompareHashAndPassword` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `CompareHashAndPassword` method compares a bcrypt hashed password with its
    possible plain text equivalent. bcrypt is a secure method of protecting passwords
    but it is slow, let's take a look in a little more depth at the cost of generating
    hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table illustrates the approximate time it takes to generate and
    compare a hashed string using the methods we have discussed so far. Even with
    1,000 peppers, we would be looking at a processing time of approximately 1.5 ms
    to run the comparison. This might not seem a huge amount of time; however, we
    need to take these benchmarks with a pinch of salt as they are running a single
    operation where your server will be dealing with multiple requests concurrently.
    What we do know is that comparing a hash with a list of 1,000 peppers takes 10x
    longer than comparing a list of 100 and this is 10x longer than a list of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with 1,000 peppers, we would be looking at a processing time of approximately
    1.5 ms to run the comparison. This might not seem a huge amount of time; however,
    we need to take these benchmarks with a pinch of salt as they are running a single
    operation where your server will be dealing with multiple requests concurrently.
    What we do know is that comparing a hash with a list of 1,000 peppers takes 10x
    longer than comparing a list of 100 and this is 10x longer than a list of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this information, we can balance our service for speed against security;
    however, we should always lean on the more secure. To learn how Facebook manages
    hashing I recommend you take a look at Alec Muffett''s talk Facebook: *Password
    hashing and Authentication* ([https://www.youtube.com/watch?v=NQDo2e3gj1A](https://www.youtube.com/watch?v=NQDo2e3gj1A)).'
  prefs: []
  type: TYPE_NORMAL
- en: JWTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **JSON Web Token** (**JWT**) is a standard for safely passing claims or data
    attributed to a user within an environment. It is an incredibly popular standard
    and is available for just about every major language and framework, certainly
    for Go. There are two main strengths of JWT. One is a standard format for the
    claims, which makes the availability of reliable frameworks possible. The other
    is the use of asymmetric encryption, which means that because a token is signed,
    the receiver only needs the public key of the signer to validate that the token
    has indeed come from a trusted source and this allows us to lock down access to
    the private keys to an authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: Format of a JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A JWT is broken into three different parts, which are encoded as Base64-URL.
    Like standard Base64, Base64-URL substitutes characters such as `+` and `/` for
    `-` and `\_` and removes all the padding. This allows the token to be safely transferred
    in a URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a token which looks like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The three distinct parts of the token are the header, the payload, and the
    signature. The header declares the type of the encoded object and the algorithm
    for the cryptographic signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The second object payload which contains the details of the claims related
    to the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the third part is the signature, which is an optional element
    shown as follows in the decoded state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Every element in the JWT is base64URL encoded ([https://en.wikipedia.org/wiki/Base64#URL_applications](https://en.wikipedia.org/wiki/Base64#URL_applications));
    the signature represented in its binary form is the sha256 of the message in the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The format of the signature can either be symmetrical (HS256) using a shared
    secret or asymmetrical (RS256), which uses public and private keys. For JWTs,
    the best option is the asymmetrical option as for a service which needs to authenticate
    the JWT, it only requires the public part of the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can validate our JWT only using the command line. First, we need to convert
    our base64URL-encoded signature into standard base64 encoding by replacing `_`
    with `/` and `-` with `+`. We can then pipe that into the base64 command-line
    application and pass in the `-D` flag to decode the input; we then output this
    into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to validate that the signature has been signed by the correct
    key by validating it against a public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Generating JWTs with Go is very straightforward thanks to some amazing community
    packages. The package we will be using in the example code is called **jose**
    and has been created by Eric Largergren ([https://github.com/SermoDigital/jose](https://github.com/SermoDigital/jose)).
    According to the listing on `jwt.io`, this package implements all the capabilities
    defined in the standard and was an obvious choice at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the file `chapter8/jwt/jwt.go` and look at the `GenerateJWT`
    method, we can see just how simple it is to create a JWT using jose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we need to do is to generate a list of claims and to set
    an expiration; we are setting the expiration to two weeks. We can then set a list
    of claims using the `Set` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in line **39**, we can create a new JWT passing the claims and the
    signing method to the `NewJWT` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call the `Serialize` method, which has as a parameter the private
    key - in our case, an instance of `rsa.PrivateKey` - and returns us a slice of
    bytes in the encoded format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Validating a JWT with jose is as easy as it was to create the JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is to parse our JWT from a byte array into the
    `jwt` struct using the `ParseJWT` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can call the `Validate` method, passing the public key corresponding
    to the private one which signed the message and the signing method. Optionally,
    we can provide a customer validator function; the default validation will only
    check the signature and that the token has not expired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When the validation fails, an error will be returned; if the error is nil then
    the token is valid and the claims within can be trusted.
  prefs: []
  type: TYPE_NORMAL
- en: Secure messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we need to send an encrypted message, one of the best ways to do this is
    with asymmetric encryption, where we encrypt the message with publically known
    information which can be easily distributed and then decrypt it with the private
    key which is securely held by a single party.
  prefs: []
  type: TYPE_NORMAL
- en: 'The crypto packages in Go have all the features we need to secure our data.
    If we take a look at the example `chapter8/asymmetric/asymmetric.go`, the `EncryptDataWithPublicKey`
    method is a simple implementation of the `rsa` package''s public key encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is a cryptographic hash which is used as the random oracle
    to process the message before encryption. This function must be the same for encryption
    and decryption and the documentation recommends using a sha256\. The next parameter
    is a random number generator; this is used as a source of entropy to ensure that
    if you encrypt the same message twice, you do not return the same cyphertext.
    `pub` is the `rsa.PublicKey` that we would like to use to encrypt the message;
    the message itself is passed as a slice of bytes. The final parameter is optional
    and is not encrypted in the resultant cyphertext; it can be used to help the receiver
    understand information such as which key has been used to encrypt the message,
    but extreme care must be taken not to add data to the label which could compromise
    the security of the encrypted message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we are doing in this method is to check whether the message
    is shorter than the maximum permitted length for this encryption method. The maximum
    length must be no longer than public modulus minus twice the hash length minus
    a further two. Due to the mathematics involved in public key cryptography, we
    can only allow for the encryption of small messages. We will look at how we can
    work around this issue a little later on. In line **53**, we are calling another
    internal function, which simply calls the `EncryptOAEP` function in the `rsa`
    package. We then encode the data to base64 and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypting the data is as straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our implementation of the encryption method returned a base64-encoded
    string, the first thing we do before decrypting the message is to decode it back
    into its binary form. We then call the internal method `DecryptDataWithPrivateKey`;
    this is a wrapper for the method `rsa.DecryptOAEP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This method has the same parameters to the encrypt method except this time we
    are using the private key. If we recall how asymmetric encryption works, we can
    encrypt with a public key but you cannot decrypt a message with the public key.
    The private key must be used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Shared secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symmetrical encryption also has its uses: for one, it is faster and the other
    is that it can handle a message of any size. Implementing symmetrical encryption
    in Go is, as you would expect, quite straightforward: we have the excellent `crypto/aes`
    package which manages all the heavy lifting for us. Let''s look at how we could
    encrypt a message with AES. Look at the example file `symmetric/symmetric.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do on line **13** is to validate the length of the
    key. The length of the key determines the strength of the encryption; a 16-byte
    key will encrypt with AES-128, 24 bytes AES-192, and 32 bytes AES-256\. We then
    create a new **GCM** (**Galois/Counter Mode**) cipher and pass it the reference
    to our AES cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to create a nonce which is used to protect against replay attacks
    and finally we can call the `Seal` method which encrypts our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Unlike RSA public key encryption, the size of the message that AES can handle
    is pretty much unlimited; the problem, however, is that the secret must be shared
    by both the writer and the reader, which introduces the problem of distributing
    keys to both parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption works in the reverse of the encryption method, an example of which
    can be seen in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The main thing we need to note in this code block is in the `gcm.Open` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The nonce that we are going to use to decrypt the message needs to be the same
    one that was used to encrypt the message. When we called `Seal`, the slice of
    bytes returned from the method is the encrypted message and the nonce, so to retrieve
    it, we only need to calculate the size of the nonce and then split the bytes slice
    up into two parts.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric encryption with large messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed the problem with asymmetric encryption is that it
    can only be used for relatively small messages; however, the benefits of not having
    to deal with key distribution is hugely advantageous over symmetrical. There is
    a common solution to this problem; that solution is to create a random key and
    symmetrically encrypt a message then asymmetrically encrypt the key and distribute
    both parts to the receiver. Only the holder of the private key will be able to
    decrypt the symmetrical key and only once the symmetrical key has been decrypted
    can the receiver decrypt the main message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the example in `asymmetric/asymmetric.go`, we can see that we are
    doing exactly this. This function mealy wraps the two methods for symmetrical
    and asymmetrical encryption that we looked at earlier in this chapter. Decryption
    is as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important element of keeping your system secure is making sure you keep
    it up to date with all the latest security patches. This approach needs to be
    applied to your application code and your server's operating system and applications,
    and if you are using Docker, you also need to ensure that your containers are
    up to date to ensure you are free from vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Patching containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the simplest ways to keep your containers secure is to ensure that you
    build and deploy them regularly. Quite often, if a service is not under active
    development, then it may not be deployed to production for months on end. Because
    of this problem, you may be patching host-level application libraries such as
    OpenSSL but because of the application isolation that a container gives, you may
    have vulnerable binaries at a container level. The simplest way of keeping things
    up to date is to run a regular build and deploy even if the application code does
    not change. You also need to ensure that if you are using a base container in
    your Dockerfile, this is also built and updated.
  prefs: []
  type: TYPE_NORMAL
- en: Docker hub, `quay.io`, and a couple of other software as a service registries
    have the capability to automatically rebuild a container when a linked container
    changes. If you are building an image which is based on `golang:latest`, you can
    automatically trigger a build when the upstream image is pushed to the registry.
    You can also run automated security scanning, which examines the layers in your
    image and scans for any CVE vulnerabilities. It will let you know in which layer
    the vulnerability exists and quite often you will find that this is in the base
    layer, such as Ubuntu or Debian.
  prefs: []
  type: TYPE_NORMAL
- en: Software updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patching the software on your host and in your Docker image can help keep you
    safe from vulnerabilities such as Heartbleed, which was found in OpenSSL. Patching
    software updates are relatively straightforward. You can configure your host to
    automatically update itself; the other option, which I prefer, is to ensure that
    your infrastructure is automated so that you can burn it down and rebuild it.
  prefs: []
  type: TYPE_NORMAL
- en: Patching application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that the software on the host needs to be updated, you must
    also update your application code to ensure you always have the latest updates.
    Quite often, an approach of locking your application dependencies to a version
    is followed and with the vendoring support which was introduced in Go 1.5, this
    process has been growing in the community. One problem with this and one of the
    main reasons that vendoring was not present in releases prior to go 1.5 is to
    encourage you to build your application code against the latest packages and to
    fix any problems that occur with breaking API changes sooner rather than later.
    If you do use vendoring, and I am certainly not going to suggest you do not use
    it, then you should run a nightly build which updates all libraries to the latest
    version. You do not necessarily have to deploy this to production; however, if
    the tests pass then why not? If the tests fail then, even if it is a service which
    is not under active development, this should be a trigger to you to perform a
    little maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we have protected our passwords and implemented decent security, we still
    need to know when we are under threat. In the previous chapter, we introduced
    logging and logging can be a useful tool as part of your security policy. Consider
    someone attempting to brute force your application login; tracking high levels
    of authentication errors along with the source IP can be useful when you need
    to react to this threat. The IP address of the attacker can be blocked by the
    firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of log files needs to consider the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Who is performing the action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What has failed or succeeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is the action occurring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why this has failed or succeeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you can deal with the issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example contains nowhere near enough information to be useful
    and, in fact, other than letting you know there may be a failure, you might as
    well not even consume the space taken by such logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example is far better; it shows the problem in much greater depth
    and describes in detail the events that a user is taking to access the system.
    Modern log evaluation tools such as Kibana allow filtering and grouping of such
    log files, which allows you to build up a dashboard or list of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: For example, you could create a dashboard which is looking at failed attempts
    from a single IP address above a certain threshold, which could indicate a malicious
    attempt to brute force access to a system. It is often possible to set alerts
    on such events, allowing you to proactively identify a threat and block access.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned some of the attacks your service may face from
    an intruder. We, hopefully, should have an introduction on how encryption works
    and how we can leverage Go's standard package to implement these to keep our service
    safe. There is little you can do to completely protect yourself from a determined
    attacker; however, using the simple techniques described in this chapter should
    form your standard working practice. Implementing many of these techniques will
    not slow down your development cycle by any significant degree; it will, however,
    give you an edge to keep you safe.
  prefs: []
  type: TYPE_NORMAL
