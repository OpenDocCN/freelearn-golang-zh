["```go\n  7 // Message represents messages stored on the queue \n  8 type Message struct { \n  9   ID      string `json:\"id\"` \n 10   Name    string `json:\"name\"` \n 11   Payload string `json:\"payload\"` \n 12 } \n 13 \n 14 // Queue defines the interface for a message queue \n 15 type Queue interface { \n 16   Add(messageName string, payload []byte) error \n 17   AddMessage(message Message) error \n 18   StartConsuming(size int, pollInterval time.Duration, callback func(Message) error) \n 19 } \n\n```", "```go\n 26 // NewRedisQueue creates a new RedisQueue \n 27 func NewRedisQueue(connectionString string, queueName string) (*RedisQueue, error) { \n 28   connection := rmq.OpenConnection(\"my service\", \"tcp\", connectionString, 1) \n 29   taskQueue := connection.OpenQueue(queueName) \n 30 \n 31   return &RedisQueue{Queue: taskQueue, name: queueName}, nil \n 32 }  \n\n```", "```go\n 42 // AddMessage to the queue, generating a unique ID for the message before dispatch \n 43 func (r *RedisQueue) AddMessage(message Message) error { \n 44   serialNumber, _ := rand.Int(rand.Reader, serialNumberLimit) \n 45   message.ID = strconv.Itoa(time.Now().Nanosecond()) + serialNumber.String() \n 46 \n 47   payloadBytes, err := json.Marshal(message) \n 48   if err != nil { \n 49     // handle error \n 50     return err \n 51   } \n 52 \n 53   fmt.Println(\"Add event to queue:\", string(payloadBytes)) \n 54   if !r.Queue.PublishBytes(payloadBytes) { \n 55     return fmt.Errorf(\"unable to add message to the queue\") \n 56   } \n 57 \n 58   return nil \n 59 }  \n\n```", "```go\n 61 // StartConsuming consumes messages from the queue \n 62 func (r *RedisQueue) StartConsuming(size int, pollInterval time.Duration, callback func(Message) error) { \n 63   r.callback = callback \n 64   r.Queue.StartConsuming(size, pollInterval) \n 65   r.Queue.AddConsumer(\"RedisQueue_\"+r.name, r) \n 66 } \n 67 \n 68 // Consume is the internal callback for the message queue \n 69 func (r *RedisQueue) Consume(delivery rmq.Delivery) { \n 70   fmt.Println(\"Got event from queue:\", delivery.Payload()) \n 71 \n 72   message := Message{} \n 73 \n 74   if err := json.Unmarshal([]byte(delivery.Payload()), &message); err != nil { \n 75     fmt.Println(\"Error consuming event, unable to deserialise event\") \n 76     // handle error \n 77     delivery.Reject() \n 78     return \n 79   } \n 80 \n 81   if err := r.callback(message); err != nil { \n 82     delivery.Reject() \n 83     return \n 84   } \n 85 \n 86   delivery.Ack() \n 87 } \n\n```", "```go\ntype Delivery interface { \n  Payload() string \n  Ack() bool \n  Reject() bool \n  Push() bool \n} \n\n```", "```go\nfunc(Message) error \n\n```", "```go\n   16 func main() { \n   17   q, err := queue.NewRedisQueue(\"redis:6379\", \"test_queue\") \n   18   if err != nil { \n   19     log.Fatal(err) \n   20   } \n   21 \n   22   http.HandleFunc(\"/\", func(rw http.ResponseWriter, r \n        *http.Request) { \n   23     data, _ := ioutil.ReadAll(r.Body) \n   24     err := q.Add(\"new.product\", data) \n   25     if err != nil { \n   26       log.Println(err) \n   27       rw.WriteHeader(http.StatusInternalServerError) \n   28       return                                                                                                                                      \n   29     } \n   30   }) \n   31 \n   32   http.ListenAndServe(\":8080\", http.DefaultServeMux) \n   33 } \n\n```", "```go\n11 func main() { \n12   log.Println(\"Starting worker\") \n13 \n14   q, err := queue.NewRedisQueue(\"redis:6379\", \"test_queue\") \n15   if err != nil { \n16     log.Fatal(err) \n17   } \n18 \n19   q.StartConsuming(10, 100*time.Millisecond, func(message \nqueue.Message) error { \n20     log.Printf(\"Received message: %v, %v, %v\\n\", message.ID, message.Name, message.Payload) \n21 \n22     return nil // successfully processed message \n23   }) \n24 \n25   runtime.Goexit() \n26 } \n\n```", "```go\n 24 func main() { \n 25   var err error \n 26   natsClient, err = nats.Connect(\"nats://\" + *natsServer) \n 27   if err != nil { \n 28     log.Fatal(err) \n 29   } \n 30   defer natsClient.Close() \n 31 \n 32   http.DefaultServeMux.HandleFunc(\"/product\", productsHandler) \n 33 \n 34   log.Println(\"Starting product write service on port 8080\") \n 35   log.Fatal(http.ListenAndServe(\":8080\", http.DefaultServeMux)) \n 36 } \n\n```", "```go\nfunc Connect(url string, options ...Option) (*Conn,error)\n\n```", "```go\n 37 func productsHandler(rw http.ResponseWriter, r *http.Request) { \n 38   if r.Method == \"POST\" { \n 39     insertProduct(rw, r) \n 40   } \n 41 } \n 42 \n 43 func insertProduct(rw http.ResponseWriter, r *http.Request) { \n 44   log.Println(\"/insert handler called\") \n 45 \n 46   data, err := ioutil.ReadAll(r.Body) \n 47   if err != nil { \n 48     rw.WriteHeader(http.StatusBadRequest) \n 49     return \n 50   } \n 51   defer r.Body.Close() \n 52 \n 53   natsClient.Publish(\"product.inserted\", data) \n 54 } \n\n```", "```go\nfunc (nc *Conn) Publish(subjstring, data []byte)error\n\n```", "```go\n 25 func main() { \n 26   var err error \n 27   natsClient, err = nats.Connect(\"nats://\" + *natsServer) \n 28   if err != nil { \n 29     log.Fatal(err) \n 30   } \n 31   defer natsClient.Close() \n 32 \n 33   log.Println(\"Subscribing to events\") \n 34   natsClient.Subscribe(\"product.inserted\", handleMessage) \n 35 } \n 36 \n 37 func handleMessage(m *nats.Msg) { \n 38   p := product{} \n 39   err := json.Unmarshal(m.Data, &p) \n 40   if err != nil { \n 41     log.Println(\"Unable to unmarshal event object\") \n 42     return \n 43   } \n 44 \n 45   log.Printf(\"Received message: %v, %#v\", m.Subject, p) \n 46 } \n\n```", "```go\nfunc (nc *Conn) Subscribe(subjstring, cbMsgHandler) (*Subscription,error)\n\n```", "```go\nfunc (nc *Conn) QueueSubscribe(subj, queuestring, cbMsgHandler) (*Subscription,error)\n\n```", "```go\n 26 func init() { \n 27   flag.Parse() \n 28 \n 29   schema = &memdb.DBSchema{ \n 30     Tables: map[string]*memdb.TableSchema{ \n 31       \"product\": &memdb.TableSchema{ \n 32         Name: \"product\", \n 33         Indexes: map[string]*memdb.IndexSchema{ \n 34           \"id\": &memdb.IndexSchema{ \n 35             Name:    \"id\", \n 36             Unique:  true, \n 37             Indexer: &memdb.StringFieldIndex{Field: \"SKU\"}, \n 38           }, \n 39         }, \n 40       }, \n 41     }, \n 42   } \n... \n 66   natsClient, err = nats.Connect(\"nats://\" + *natsServer) \n 67   if err != nil { \n 68     log.Fatal(err) \n 69   } \n 70 } \n\n```", "```go\n 84 func insertProduct(rw http.ResponseWriter, r *http.Request) { \n 85   log.Println(\"/insert handler called\") \n 86 \n 87   p := &product{} \n 88 \n 89   data, err := ioutil.ReadAll(r.Body) \n 90   if err != nil { \n 91     rw.WriteHeader(http.StatusBadRequest) \n 92     return \n 93   } \n 94   defer r.Body.Close() \n 95 \n 96   err = json.Unmarshal(data, p) \n 97   if err != nil { \n 98     log.Println(err) \n 99     rw.WriteHeader(http.StatusBadRequest) \n100     return \n101   } \n102 \n103   txn := db.Txn(true) \n104   if err := txn.Insert(\"product\", p); err != nil { \n105     log.Println(err) \n106     rw.WriteHeader(http.StatusInternalServerError) \n107     return \n108   } \n109   txn.Commit() \n110 \n111   natsClient.Publish(\"product.inserted\", data) \n112 } \n\n```", "```go\n        type product struct { \n           Name       string `json:\"name\"` \n           SKU        string `json:\"sku\"` \n           StockCount int    `json:\"stock_count\"`                                                                                                        \n        } \n\n```", "```go\n        type product struct { \n          Name        string `json:\"name\"` \n          Code        string `json:\"code\"` \n          LastUpdated string `json:\"last_updated\"` \n        } \n\n```", "```go\ntype productInsertedEvent struct { \n  Name string `json:\"name\"` \n  SKU  string `json:\"sku\"` \n} \n\n```", "```go\n112 func productMessage(m *nats.Msg) { \n113   pie := productInsertedEvent{} \n114   err := json.Unmarshal(m.Data, &pie) \n115   if err != nil { \n116     log.Println(\"Unable to unmarshal event object\") \n117     return \n118   } \n119 \n120   p := product{}.FromProductInsertedEvent(pie) \n121 \n122   txn := db.Txn(true) \n123   if err := txn.Insert(\"product\", p); err != nil { \n124     log.Println(err) \n125     return \n126   } \n127   txn.Commit() \n128 \n129   log.Println(\"Saved product: \", p) \n130 } \n\n```"]