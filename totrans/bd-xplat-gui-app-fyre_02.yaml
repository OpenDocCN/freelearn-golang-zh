- en: '*Chapter 1*: A Brief History of GUI Toolkits and Cross-Platform Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：GUI工具包和跨平台开发简史'
- en: This book is aimed at exploring how to easily build robust and beautiful graphical
    applications that will work well across all operating systems and devices. Before
    we start looking at the details of how this is accomplished, it is important to
    consider the history of these devices and the landscape of graphical toolkits
    throughout the last 50 years. We start with a reminder of where GUI-based applications
    started and how far they have come.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在探讨如何轻松构建健壮且美观的图形应用程序，这些应用程序将在所有操作系统和设备上运行良好。在我们开始查看如何实现这一点的细节之前，考虑这些设备的历史以及过去50年图形工具包的格局非常重要。我们从回顾GUI应用程序的起点以及它们走了多远开始。
- en: In this chapter, you will be reintroduced to the **Graphical User Interface**
    (**GUI**), along with learning about toolkits that support app development and
    how they offer different approaches to cross-platform development. We will explore
    the benefits of coding a native GUI for responsive user experience and platform
    integration. Upon completion of this chapter, you should be familiar with the
    origins and challenges of graphical toolkits and the different approaches that
    have been taken during this journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将重新了解**图形用户界面**（**GUI**），同时了解支持应用程序开发的工具包以及它们如何提供不同的跨平台开发方法。我们将探讨编写本地GUI以实现响应式用户体验和平台集成的优势。完成本章后，您应该熟悉图形工具包的起源和挑战，以及在这一旅程中采取的不同方法。
- en: 'In this chapter, we''ll cover the following topics to provide a short history
    of GUI toolkits and cross-platform development:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题，以提供GUI工具包和跨平台开发的简要历史：
- en: Where GUI toolkits came from
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI工具包的来源
- en: How they have adapted (or stayed the same) over time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是如何随着时间的推移而适应（或保持不变）的
- en: Historical approaches to cross-platform development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台开发的历史方法
- en: Understanding the history of the graphical user interface
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图形用户界面的历史
- en: 'In 1973, the *Palo Alto Research Center* (*Xerox PARC*) completed the Alto
    computer, the first commercial example of a graphical desktop computer. In most
    contemporary histories, this was the first example of what we understand as the
    GUI. While the screen orientation and lack of colors make it a little peculiar
    to the modern eye, it''s clearly recognizable and includes many key components
    as well as a mouse and keyboard for interaction. While it took another 7 years
    to become generally available to the public in 1981 as the *Xerox Star*, it was
    clear that this was a dramatic step forward:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在1973年，*帕洛阿尔托研究中心*（*施乐帕洛阿尔托研究中心*）完成了Alto计算机，这是第一个图形桌面计算机的商业实例。在大多数当代历史中，这是我们所理解的GUI的第一个实例。尽管屏幕方向和缺乏颜色使其对现代眼睛来说有些奇特，但它显然是可以识别的，并且包括许多关键组件，以及用于交互的鼠标和键盘。尽管它直到1981年作为*Xerox
    Star*才对公众普遍可用，但它显然是一个巨大的进步：
- en: '![Figure 1.1 – Dynabook environment desktop (1976; Smalltalk-76 running on
    Alto). Copyright SUMIM.ST, licensed CC BY-SA 4.0](img/B16820_01_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Dynabook环境桌面（1976年；在Alto上运行的Smalltalk-76）。版权SUMIM.ST，许可CC BY-SA 4.0](img/B16820_01_01.jpg)'
- en: Figure 1.1 – Dynabook environment desktop (1976; Smalltalk-76 running on Alto).
    Copyright SUMIM.ST, licensed CC BY-SA 4.0
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Dynabook环境桌面（1976年；在Alto上运行的Smalltalk-76）。版权SUMIM.ST，许可CC BY-SA 4.0
- en: This development was a huge leap forward for the usability of computers. Up
    to this time, all interaction was through text-mode computer screens and keyboard
    or other text input devices. The graphical interface is much easier to learn for
    a novice looking to get started, and allows the quicker discovery of advanced
    features. While the command-line interface remains popular with programmers and
    other *pro users*, the GUI is the largest contributing factor to the rise of the
    desktop computer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种发展是计算机可用性的一次巨大飞跃。在此之前，所有交互都是通过文本模式的计算机屏幕和键盘或其他文本输入设备进行的。图形界面对于想要入门的新手来说更容易学习，并且允许更快地发现高级功能。尽管命令行界面仍然受到程序员和其他*专业用户*的欢迎，但GUI是桌面计算机兴起的最主要因素。
- en: Popularity of the desktop computer
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桌面计算机的普及
- en: The introduction of a user-friendly graphical environment brought about a significant
    growth in the use of desktop computers. Around the time of the Alto computer,
    there were an estimated 48,000 desktop computers around the world. By 2001, this
    number had increased dramatically to over 125,000,000 personal computers shipped
    ([https://en.wikipedia.org/wiki/History_of_personal_computers#Market_size](https://en.wikipedia.org/wiki/History_of_personal_computers#Market_size)).
    In 2002, the industry celebrated a billion computers shipped ([http://news.bbc.co.uk/1/hi/sci/tech/2077986.stm](http://news.bbc.co.uk/1/hi/sci/tech/2077986.stm)),
    though numbers have declined more recently (see the *Smartphones and mobile apps*
    section later in this chapter) and fewer than 300 million were reported shipped
    in 2018 ([https://venturebeat.com/2019/01/10/gartner-and-idc-hp-and-lenovo-shipped-the-most-pcs-in-2018-but-total-numbers-fell/](https://venturebeat.com/2019/01/10/gartner-and-idc-hp-and-lenovo-shipped-the-most-pcs-in-2018-but-total-numbers-fell/)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验友好的图形环境的引入促进了台式计算机的使用显著增长。在Alto计算机时代，全球大约有48,000台台式计算机。到2001年，这个数字急剧增加到超过12亿5千万台个人电脑发货（[https://en.wikipedia.org/wiki/History_of_personal_computers#Market_size](https://en.wikipedia.org/wiki/History_of_personal_computers#Market_size)）。2002年，行业庆祝了10亿台电脑发货（[http://news.bbc.co.uk/1/hi/sci/tech/2077986.stm](http://news.bbc.co.uk/1/hi/sci/tech/2077986.stm)），尽管最近数字有所下降（参见本章后面的*智能手机和移动应用*部分），2018年报道的发货量不到3亿台（[https://venturebeat.com/2019/01/10/gartner-and-idc-hp-and-lenovo-shipped-the-most-pcs-in-2018-but-total-numbers-fell/](https://venturebeat.com/2019/01/10/gartner-and-idc-hp-and-lenovo-shipped-the-most-pcs-in-2018-but-total-numbers-fell/)）。
- en: 'As these devices reached the hands of consumers, and hardware became more capable,
    we started to see a focus on creating attractive user interfaces as well as a
    trend to establish or match fashion trends. The following are some important versions
    of Microsoft''s Windows operating system:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些设备进入消费者手中，硬件变得更加强大，我们开始看到创建吸引人的用户界面的重点，以及建立或匹配时尚趋势的趋势。以下是一些重要的微软Windows操作系统版本：
- en: '![The copyright for all screenshots belongs to Microsoft. Each image used with
    permission'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![The copyright for all screenshots belongs to Microsoft. Each image used with
    permission](img/011.jpg)'
- en: '](img/011.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![The copyright for all screenshots belongs to Microsoft. Each image used with
    permission](img/011.jpg)'
- en: The copyright for all screenshots belongs to Microsoft. Each image used with
    permission
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有屏幕截图的版权属于微软。每个图像都是在获得许可的情况下使用的。
- en: As you can see in the previous screenshots, each major revision of the desktop
    environment brought new styles for the buttons, fonts, and other user interface
    elements. This is all controlled by the toolkit and represents an evolution in
    usability and style choices that we'll explore later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，桌面环境的每一次主要修订都为按钮、字体和其他用户界面元素带来了新的样式。这一切都由工具包控制，代表了我们在本章后面将要探讨的可用性和风格选择上的进化。
- en: 'Whilst Microsoft were progressing with their GUIs, there were also many competitors,
    some of which may appear familiar and others with their own distinct styles; for
    example, the following popular systems:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软在GUI方面取得进展时，也有许多竞争对手，其中一些可能看起来很熟悉，而另一些则有自己的独特风格；例如，以下是一些流行的系统：
- en: '![Desktop screenshots from various operating systems 1985-2015\. Each image
    has been used with the required permission under fair use policies](img/02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Desktop screenshots from various operating systems 1985-2015\. Each image
    has been used with the required permission under fair use policies](img/02.jpg)'
- en: Desktop screenshots from various operating systems 1985-2015\. Each image has
    been used with the required permission under fair use policies
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 1985-2015年各种操作系统的桌面截图。每个图像都是在公平使用政策下获得必要许可后使用的。
- en: As you can see from the preceding desktop screenshots for various operating
    systems from 1985 to 2015, there have been dramatic shifts in the look and feel,
    whilst maintaining a certain familiarity. These desktop systems are all designed
    for running multiple application windows typically centered around document editing,
    file management, and utility apps. Additional software, such as games, photo management,
    and music players, appeared over the years, but the most ubiquitous, the web browser,
    was not commonplace until the late 1990s. The addition of internet access started
    a shift to a new era of computing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从1985年到2015年各种操作系统的桌面截图中所见，外观和感觉发生了显著变化，同时保持了某种熟悉感。这些桌面系统都是为了运行多个应用程序窗口而设计的，通常围绕文档编辑、文件管理和实用程序应用。多年来，还出现了额外的软件，如游戏、照片管理和音乐播放器，但最普遍的网页浏览器直到20世纪90年代末才变得常见。互联网接入的加入开启了一个新的计算时代的转变。
- en: Moving to the web
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转向网络
- en: With the increasing availability of reliable internet connections, we started
    to see an increase in the amount of information being accessed from servers on
    the `browser wars` in your favorite search engine to know more).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着可靠互联网连接的日益普及，我们从服务器上获取的信息量开始增加，从你最喜欢的搜索引擎中的“浏览器大战”到了解更多）。
- en: 'The WWW was first proposed by Sir Tim Berners Lee in 1981 and development began
    within the CERN ([https://home.cern](https://home.cern)) project (codenamed *ENQUIRE*).
    The early web was made available to the public in 1993\. As a distributed system
    that anyone is able to add to, innovation in design was even more rapid than in
    the desktop operating systems we saw earlier. Trends in design and usability quickly
    caught up with, overtook, and started to lead traditional software development:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网最初由蒂姆·伯纳斯-李爵士在1981年提出，开发始于CERN（[https://home.cern](https://home.cern)）项目（代号*ENQUIRE*）。早期的万维网在1993年向公众开放。作为一个任何人都可以添加的分布式系统，设计创新甚至比我们之前看到的桌面操作系统还要迅速。设计和可用性的趋势迅速赶上、超越并开始引领传统的软件开发：
- en: '![Trends in website design (via Web Design Museum); copyrights belong to their
    respective owners'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![网站设计趋势（通过Web设计博物馆）；版权属于各自所有者'
- en: '](img/03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/03.jpg)'
- en: Trends in website design (via Web Design Museum); copyrights belong to their
    respective owners
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 网站设计趋势（通过Web设计博物馆）；版权属于各自所有者
- en: The web started as a project for providing access to data, born out of a frustration
    of how difficult it could be to access information on a different computer. What
    started as simple information retrieval quickly became a polished presentation
    of more complex information, and then began to become a place to submit or manipulate
    information as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网最初是一个提供数据访问的项目，源于对在不同计算机上获取信息可能多么困难的挫败感。最初只是简单的信息检索很快变成了更复杂信息的精致展示，然后开始成为提交或操作信息的地方。
- en: A simple data access platform quickly grew into much more and before long, this
    emerged as a full application platform. In fact, due to the standards-based approach
    (overseen by the **World Wide Web Consortium** (**W3C**)), this was one of the
    first truly cross-platform development opportunities. A web-based application
    would be developed and made available to all computers in one go—a big advancement
    over previous attempts to develop for multiple platforms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的数据访问平台迅速发展成为一个更全面的平台，不久之后，它就成为一个完整的应用程序平台。事实上，由于基于标准的方法（由**万维网联盟**（**W3C**）监督），这成为了第一个真正跨平台开发机会之一。一个基于网络的程序可以一次性开发并供所有计算机使用——这比之前为多个平台开发的大幅进步。
- en: An additional benefit of delivering applications through a web-based solution
    was that you could support multiple types of application accessing the underlying
    data or functionality. A web-based **API** (**Application Programming Interface**)
    that had historically powered the user-visible website could be used by other
    devices as well. This design allowed traditional software to access the same data
    as the web-based delivery systems and contributed to the development of common-place
    architectures that support a multitude of different types of software – including
    the more recent mobile-based applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基于网络的解决方案交付应用程序的额外好处是，你可以支持多种类型的应用程序访问底层数据或功能。一个历史上曾为用户可见的网站提供动力的基于网络的**API（应用程序编程接口**）也可以由其他设备使用。这种设计允许传统软件访问与基于网络的交付系统相同的数据，并有助于发展支持多种不同类型软件的通用架构——包括更近期的基于移动的应用程序。
- en: Smartphones and mobile apps
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能手机和移动应用
- en: In 2007, Apple's Steve Jobs introduced the iPhone, a fresh new design for the
    concept of mobile computing. Although portable *smartphone* devices existed for
    many years before this event, the introduction of a slick new user interface,
    touchscreen input, and large screen for displaying video and web content had a
    significant impact on the market. Competitors (existing and newly created) were
    now racing to create the best user experience that could fit in the consumers'
    pockets. Although early devices touted that you could browse any website with
    ease, developers quickly adapted the content to be better presented on these smaller
    screens—often focusing on information that mattered on the move.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在2007年，苹果的史蒂夫·乔布斯推出了iPhone，这是移动计算概念的一个全新设计。尽管在此事件之前已经存在便携式*智能手机*设备多年，但引入了一个光滑的新用户界面、触摸屏输入和用于显示视频和网页内容的大屏幕，对市场产生了重大影响。竞争对手（现有和新创建的）现在正在竞相创造最适合消费者口袋的最佳用户体验。尽管早期设备宣称可以轻松浏览任何网站，但开发者很快就将内容调整为更适合这些小屏幕的展示——通常关注移动时重要的信息。
- en: To satisfy the user demand for a more sophisticated and faster experience on
    these more limited (by hardware or internet connectivity) devices, the concept
    of a *mobile app* was born. These small pieces of software were designed specifically
    for a certain type of mobile phone (Android, iPhone, and others) and were made
    available by the platform's store or marketplace. Such software had large benefits
    over the web-based solutions that came earlier as they could be installed on the
    device, so they ran faster and were developed specifically for the given hardware,
    creating a better user experience and allowing access to the more advanced capabilities
    of each device (such as location detection, thumbprint sensors, and Bluetooth).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足用户在这些更有限的（由硬件或互联网连接性）设备上对更复杂和更快体验的需求，诞生了*移动应用程序*的概念。这些小型的软件专门为某种类型的移动电话（Android、iPhone和其他）设计，并通过平台的商店或市场提供。与之前出现的基于网络的解决方案相比，它们具有很大的优势，因为它们可以安装在设备上，所以运行得更快，并且专门为特定的硬件开发，从而创造更好的用户体验，并允许访问设备的高级功能（如位置检测、指纹传感器和蓝牙）。
- en: 'These native apps provided the ultimate user experience. The applications could
    be very fast (as they were installed on the device), adapt to the user (through
    access to local settings and data), and also interact with the operating system
    features (such as calendars, voice controls, and cutting-edge hardware sensors),
    all of which are not really possible when delivered through a web app. However,
    they came with a disadvantage for developers—not only did each platform look different,
    meaning that designs may need to be adapted, but they were also distributed separately
    and typically required different programming languages to develop. Now instead
    of reaching the whole world with a single application, a software company would
    need at least three different apps to reach their customers through their favorite
    devices:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原生应用提供了终极的用户体验。这些应用可以非常快（因为它们安装在设备上），适应用户（通过访问本地设置和数据），还可以与操作系统功能（如日历、语音控制和尖端硬件传感器）交互，所有这些在通过网页应用提供时都是不可能实现的。然而，它们对开发者来说有一个缺点——不仅每个平台看起来都不同，这意味着设计可能需要调整，而且它们是分别分发的，通常需要不同的编程语言来开发。现在，软件公司不再需要用一个单一的应用程序来覆盖整个世界，而是至少需要三个不同的应用程序来通过客户喜欢的设备接触他们的客户：
- en: '![iPhone and Android devices showing their similarities and differences'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![iPhone和Android设备展示它们的相似之处和不同之处]'
- en: '](img/04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片04.jpg]'
- en: iPhone and Android devices showing their similarities and differences
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone和Android设备展示它们的相似之处和不同之处
- en: We will come back to the challenges of developing for multiple different hardware
    platforms later, but first, we will explore the graphical toolkits that underpinned
    the various technologies we have seen in this section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后回到为多个不同的硬件平台开发时的挑战，但首先，我们将探索支撑本节中我们看到的各种技术的图形工具包。
- en: Exploring the evolution of GUI toolkits
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索GUI工具包的演变
- en: GUIs must be programmed like any other computer program, and just like libraries
    are created to provide standard components, a GUI toolkit exists to support building
    the graphical elements of an application. Many toolkits exist for different reasons—Wikipedia
    maintains a list of nearly 50 different projects, and growing, at [https://en.wikipedia.org/wiki/List_of_widget_toolkits](https://en.wikipedia.org/wiki/List_of_widget_toolkits)
    and [https://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](https://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries).
    To make sense of the huge number of options, we split them into categories, looking
    first at those built for specific operating systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面（GUIs）必须像任何其他计算机程序一样进行编程，就像库是为了提供标准组件而创建的一样，GUI工具包存在是为了支持构建应用程序的图形元素。由于存在许多不同的原因，存在许多工具包——维基百科维护着一个包含近50个不同项目的列表，并且还在增长，可以在[https://en.wikipedia.org/wiki/List_of_widget_toolkits](https://en.wikipedia.org/wiki/List_of_widget_toolkits)和[https://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](https://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries)找到。为了理解大量选项的意义，我们将它们分为类别，首先考虑那些为特定操作系统构建的工具包。
- en: Platform-specific toolkits
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定平台工具包
- en: Each graphical operating system or desktop environment has a distinct look and
    programming style, therefore a graphical toolkit was traditionally created for
    each platform. Windows had the WinAPI (as well as WinForms and foundation classes),
    Atari was programmed using GEM, and BeOS used the Be API. Applications developed
    for Apple products have used various toolkits, but since macOS X it's called Cocoa
    (with desktops using AppKit and mobile devices using UIKit). Android devices are
    programmed with their own toolkit and other mobile platforms have explored other
    options.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形操作系统或桌面环境都有其独特的外观和编程风格，因此传统上为每个平台创建了一个图形工具包。Windows有WinAPI（以及WinForms和基础类），Atari使用GEM进行编程，而BeOS使用Be
    API。为苹果产品开发的应用程序使用了各种工具包，但自从macOS X以来，它被称为Cocoa（桌面使用AppKit，移动设备使用UIKit）。Android设备使用自己的工具包，而其他移动平台也探索了其他选项。
- en: The Unix and Linux operating systems have a more complicated story. Although
    the Motif toolkit was one of the first, the fact that its design offers multiple
    choices has meant there is no one true *look* or library. In the 1980s, before
    Motif was created, there was the OpenLook project that aimed to provide a standard
    interface look and feel for Unix systems. Although there were many different designs
    and toolkits to choose from, the main contributors to Unix decided that unification
    would help it compete with Windows and other desktop platforms. And so, in 1993,
    they chose Motif for future development.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Unix和Linux操作系统的故事更为复杂。尽管Motif工具包是第一个之一，但其设计提供多种选择的事实意味着没有一种真正的*外观*或库。在1980年代，在Motif创建之前，有一个名为OpenLook的项目，旨在为Unix系统提供标准的界面外观和感觉。尽管有众多不同的设计和工具包可供选择，Unix的主要贡献者决定统一将有助于其与Windows和其他桌面平台竞争。因此，在1993年，他们选择了Motif作为未来的开发。
- en: One of the common features of desktop environment design is that it is frequently
    updated, as you could see in the screenshots of Microsoft Windows earlier in this
    chapter. Whether due to changes in fashion or advances in usability, these changes
    are expected and the Motif system did not adapt to them, and so new projects were
    created as alternatives. Later in the 90s, the GTK+ and Qt projects were started
    and provided a more modern, polished-looking user interface. Also, the Java platform
    launched with **AWT** (**Abstract Widget Toolkit**) in 1995, all of which were
    not platform-specific, opening a new world of cross-platform GUI libraries.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面环境设计的常见特征是它经常更新，正如你可以在本章前面看到的Microsoft Windows的截图中所见。无论是因为时尚的变化还是可用性的进步，这些变化都是预期的，而Motif系统没有适应这些变化，因此创建了新的项目作为替代品。在90年代后期，GTK+和Qt项目启动，提供了更现代、更精致的用户界面。此外，Java平台在1995年推出了**AWT**（**抽象窗口工具包**），所有这些都不是特定平台的，为跨平台GUI库开辟了新的世界。
- en: Cross-platform toolkits
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台工具包
- en: The toolkits mentioned in the earlier subsection were all developed for a specific
    platform. They evolved along with the operating system design and are often developed
    using the manufacturer's preferred programming language. These challenges make
    it difficult (if not impossible) to create a single app that will work on all
    platforms. For that reason, the move to create a cross-platform toolkit requires
    taking a different approach and so developers started to design a library that
    could be written independently of platform specifics in a language that could
    be compiled for any of the operating systems it supports.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中提到的工具包都是为了特定的平台开发的。它们随着操作系统设计的发展而发展，通常使用制造商首选的编程语言进行开发。这些挑战使得创建一个能在所有平台上工作的单一应用程序变得困难（如果不是不可能的话）。因此，创建跨平台工具包的举措需要采取不同的方法，因此开发者开始设计一个可以在不依赖于特定平台的情况下用任何支持的操作系统的编译语言编写的库。
- en: When GTK+ and Qt were created in the mid-1990s, they chose C and C++ (an object-based
    language derived from C), respectively. Both languages had wide adoption across
    most operating systems and were in use with some other toolkits already, keeping
    the barrier of learning low. The Java approach, however, was broader—to create
    a whole new language that would work across all of these platforms and deliver
    a graphical toolkit built on top.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代中期，当GTK+和Qt被创建时，它们分别选择了C和C++（一种从C派生出的面向对象的语言）。这两种语言在大多数操作系统上都有广泛的采用，并且已经与一些其他工具包一起使用，从而降低了学习门槛。然而，Java的方法却更为广泛——创建一种全新的语言，使其能够在所有这些平台上工作，并交付一个基于此的图形工具包。
- en: Operating system and computer manufacturers have market power to sway technologies,
    and as new languages became available, they are able to force developers in the
    same new directions (such as Apple moving to Swift, Microsoft to C#, and Google
    moving their apps to Dart). However, the large open source communities built around
    cross-platform technologies are generally loyal to the language it is built with
    and so don't typically embrace such large changes. Therefore, these projects can
    be left behind in some senses and can encourage developers to look in new directions,
    such as web technologies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统和计算机制造商拥有影响技术的市场力量，随着新语言的可用性，他们能够迫使开发者走向相同的新方向（例如，苹果转向Swift，微软转向C#，谷歌将他们的应用程序迁移到Dart）。然而，围绕跨平台技术构建的大型开源社区通常对其构建的语言忠诚，因此通常不会接受这样大的变化。因此，在这些项目中，某些方面可能会被遗弃，并鼓励开发者寻找新的方向，例如网络技术。
- en: Hybrid apps
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合应用程序
- en: As discussed earlier in the chapter, the WWW offered an attractive platform
    for delivering applications to users on multiple operating systems as well as
    providing a way to build apps once and run them on any computer. A web browser
    offers a highly customizable canvas so that, using **Cascading Style Sheets**
    (**CSS**), any **HyperText Markup Language** (**HTML**)-based application can
    be made to look like any design. This benefit brought a lot of popularity to web
    application development and even influenced some native toolkits to expand their
    theme capabilities to mimic this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，万维网为向多个操作系统的用户提供应用程序提供了一个有吸引力的平台，同时也提供了一种构建一次应用程序并在任何计算机上运行的方法。网络浏览器提供了一个高度可定制的画布，因此，使用**层叠样式表**（**CSS**），任何基于**超文本标记语言**（**HTML**）的应用程序都可以被设计成任何设计。这种好处为网络应用程序开发带来了很多人气，甚至影响了某些原生工具包扩展其主题功能以模仿这一点。
- en: Websites, as described earlier in this chapter, were designed for information
    transfer—initially for read-only, and later for sending and editing data too.
    To get from this to a fully interactive application requires additional programming
    capabilities, and for this **JavaScript** is used. In the years since its creation,
    JavaScript has grown in popularity and complexity—there are now multiple package
    managers to handle the thousands of available packages that can be used in any
    JavaScript-powered app. Of these libraries, many are graphical toolkits for handling
    application interaction and layout, much like a traditional GUI toolkit. Of these,
    the most popular are currently React, Vue.js, and JQuery, though that list changes
    regularly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，网站是为了信息传输而设计的——最初是只读的，后来也可以发送和编辑数据。要从这里过渡到完全交互式应用程序，需要额外的编程能力，而这正是**JavaScript**的作用。自其创建以来，JavaScript在流行度和复杂性方面都得到了增长——现在有多个包管理器来处理可用于任何JavaScript应用程序的数千个可用包。在这些库中，许多是用于处理应用程序交互和布局的图形工具包，就像传统的GUI工具包一样。在这些工具包中，目前最受欢迎的是React、Vue.js和JQuery，尽管这个列表经常变化。
- en: When developing such JS based web-apps, the focus is on the user interface entirely
    (the *frontend*), whereas a full application may contain business logic and algorithms
    that may be part of the server infrastructure (the *backend*) of a web application.
    Historically, these separate parts of a complex application are created using
    different programming languages. This makes sense as there are different requirements
    for each area of a large infrastructure. However, for smaller applications, or
    to reduce technical complexity, it can be useful to use the same language for
    all parts—and so Node.js was created to support the JavaScript-based backend elements
    of an application as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发此类基于JS的Web应用程序时，重点是用户界面（即*前端*），而完整的应用程序可能包含业务逻辑和算法，这些算法可能是Web应用程序的*后端*基础设施的一部分。从历史上看，这些复杂应用程序的独立部分使用不同的编程语言创建。这在大型基础设施的每个领域都有不同的要求是有意义的。然而，对于较小的应用程序或为了降低技术复杂性，使用相同的语言处理所有部分是有用的——因此创建了Node.js来支持应用程序的基于JavaScript的后端元素。
- en: Despite the benefits of distributing over the web, many companies still want
    to provide a traditional application that is downloaded and installed (the reasons
    are explored in the next section). To balance the speed of development and other
    benefits of web applications with the standard application package that developers
    are familiar with, a new breed of applications was created, nicknamed **hybrid
    apps**. These new apps are loaded in a standard container that loads the custom
    web application in a regular window like any other application on the system.
    Electron, Ionic, and React Native are all projects working in this space, offering
    a web-based app framework with varying levels of access to the system they are
    running on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过Web分发具有诸多好处，但许多公司仍然希望提供一种传统的应用程序，该应用程序可以下载并安装（原因将在下一节中探讨）。为了平衡开发速度和Web应用程序的其他优势与开发者熟悉的传统应用程序包，创造了一种新的应用程序类型，被称为**混合应用**。这些新应用在一个标准容器中加载，就像系统上的其他任何应用程序一样，在常规窗口中加载自定义Web应用程序。Electron、Ionic和React
    Native都是在这个领域工作的项目，提供基于Web的应用程序框架，具有不同级别的系统访问权限。
- en: Alongside the evolution of graphical toolkits for cross-platform development,
    we cannot ignore the ubiquity of the web browser. Although it has the benefit
    of being present on most modern computers, it may not be the right solution for
    building your product – let's take a look at how these approaches differ.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台开发图形工具包的演变过程中，我们不能忽视Web浏览器的普遍存在。尽管它有存在于大多数现代计算机上的好处，但它可能不是构建您产品的正确解决方案——让我们看看这些方法如何不同。
- en: Comparing native graphical apps to web UIs
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较原生图形应用与Web UI
- en: Despite the benefits that web-based applications can deliver, every technology
    choice means making a trade-off in some area, so let's look at a few of the common
    issues that might influence your decision of whether to build a native app or
    web-based hybrid.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于Web的应用程序可以提供诸多好处，但每个技术选择都意味着在某些领域做出权衡，因此让我们看看一些可能影响您决定是否构建原生应用程序或基于Web的混合应用程序的常见问题。
- en: Development speed versus delivery
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发速度与交付
- en: One of the main reasons to pick a web technology to build your application is
    the speed of development. The very nature of developing in this way means that
    you can live-preview your work in a web browser. The availability of browser-based
    editors also means that a design team can tweak the user interface without much
    code experience. Large portions of your web app could also be used in your hybrid
    application (or the other way round) to provide a high level of reuse and minimal
    additional work to support desktop and mobile delivery.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选择网络技术来构建你的应用程序的一个主要原因是开发速度。以这种方式开发的本性意味着你可以在网页浏览器中实时预览你的工作。基于浏览器的编辑器的可用性还意味着设计团队可以在不太多代码经验的情况下调整用户界面。你的Web应用程序的大部分内容也可以用于混合应用程序（或反之亦然），以提供高度的重用和最小的工作量来支持桌面和移动交付。
- en: The trade-off regarding speed is found at runtime—as the applications require
    a web view to run the code, there is an impact on how fast the application can
    be loaded and executed. Each time a hybrid app is loaded, it creates a small version
    of a web browser inside the window, loading the code like a web page and starting
    the execution of the bundled JavaScript. To most users, this may not be so slow
    as to be frustrating, but when compared to natively-compiled applications, there
    can be a noticeable difference. Depending on the framework chosen, it is also
    common for this model to require a lot of memory—indeed, Electron has a reputation
    for requiring a lot of RAM, with the simplest application using nearly 70 MB just
    to show 'Hello World'.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于速度的权衡在运行时被发现——因为应用程序需要网页视图来运行代码，这会影响应用程序加载和执行的速度。每次加载混合应用程序时，它都会在窗口内创建一个网页浏览器的小版本，像网页一样加载代码并开始执行捆绑的JavaScript。对于大多数用户来说，这可能不会慢到令人沮丧，但与本地编译的应用程序相比，可能会有明显的差异。根据选择的框架，这种模式通常也需要大量的内存——实际上，Electron因需要大量RAM而闻名，最简单的应用程序仅为了显示“Hello
    World”就需要近70 MB。
- en: The actual speed of execution may also be noticeably slower for applications
    built on web technologies. Due to the layers of abstraction, a web-based app will
    typically take more time and CPU cycles to perform the same operations than a
    compiled native application (though technologies such as **WebGL** and **WASM**
    (short for **Web Assembly**) are attempting to improve this). Therefore, if your
    application is likely to be CPU-intensive, or have lots of animated graphics,
    you may wish to benchmark different approaches to determine which platforms are
    capable of meeting your requirements for app responsiveness.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络技术构建的应用程序的实际执行速度也可能明显较慢。由于抽象层的存在，基于网络的程序通常需要更多的时间和CPU周期来完成与编译的本地应用程序相同的操作（尽管像**WebGL**和**WASM**（即**Web
    Assembly**）这样的技术正在尝试改善这一点）。因此，如果你的应用程序可能需要大量的CPU资源，或者有很多动画图形，你可能希望基准测试不同的方法，以确定哪些平台能够满足你对应用程序响应速度的要求。
- en: Another consideration may be automatic updates—would you like your apps to always
    be running the latest version? Some web-based toolkits offer the functionality
    to download application updates and dynamically load the new version without the
    user having to worry. This can be a large benefit, but could also be frustrating
    if your customers expect the software to work exactly the same every day until
    they opt to update it. Some people are also concerned about how applications of
    this nature may appear to *phone home*—that is, reporting back to a central server
    about how the apps are being used, and where, as part of the update process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素可能是自动更新——你是否希望你的应用程序始终运行最新版本？一些基于网络的工具包提供了下载应用程序更新并动态加载新版本的功能，而无需用户担心。这可能是一个很大的好处，但如果你的客户期望软件每天都能正常工作，直到他们选择更新它，这可能会令人沮丧。有些人也担心这种性质的应用程序可能会“回家”报告——也就是说，在更新过程中向中央服务器报告应用程序的使用情况和位置。
- en: Visual style
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉风格
- en: Another main decision point for choosing web technology-based app development
    may be the power of the presentation layer (CSS). It is possible, using a combination
    of image assets and style-sheet code, to create almost any visual style desired.
    For developers (or indeed, the designers on their team) that desire a completely
    bespoke look to their application, this could be a great fit. It is worth considering
    how your users will use the application, however, and whether a completely custom
    look will inhibit the usability in any way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 选择基于网络技术应用程序开发的另一个主要决策点可能是表现层（CSS）的强大功能。通过结合图像资源和样式表代码，几乎可以创建任何所需的视觉风格。对于希望为其应用程序提供完全定制外观的开发人员（或他们团队的设计师）来说，这可能是一个很好的选择。然而，值得考虑的是，你的用户将如何使用该应用程序，以及完全定制的样式是否会以任何方式阻碍可用性。
- en: This benefit of complete customization can become challenging if the application
    is intended to match the user interface style of the current system. As the rendering
    is infinitely flexible, developers can of course add tweaks to a style that make
    it look subtly (or substantially) different when running on certain systems. This
    type of adjustment can end up taking a surprising amount of additional effort—as
    each platform can have a different style over time. A GUI that attempts to match
    the system style but does not quite manage this is far more off-putting than the
    one that is clearly following its own style guide.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序旨在匹配当前系统的用户界面风格，这种完全定制的优势可能会变得具有挑战性。由于渲染无限灵活，开发人员当然可以在某些系统上运行时对风格进行微调，使其看起来微妙（或显著）不同。这种调整可能需要意想不到的大量额外努力——因为每个平台在一段时间后都可能具有不同的风格。试图匹配系统风格但未能做到的GUI比明显遵循其自身风格指南的GUI更具排斥性。
- en: Therefore, it is probably best to avoid hybrid apps if you desire to blend in
    with the other apps on a system. Web technologies do offer a fast-to-develop,
    adaptable platform for cross-platform applications, but there are constraints
    to this approach that should be considered as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你希望与其他系统中的应用程序融为一体，可能最好避免使用混合应用程序。网络技术确实提供了一个快速开发、适应性强的跨平台应用程序平台，但这种方法也存在一些限制，也应予以考虑。
- en: Technical constraints
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术限制
- en: Applications built with web technologies, even those built to look like system
    apps with hybrid frameworks, run in a sandbox. This means that they are limited
    in certain ways regarding access to devices and system features. The JavaScript
    APIs that grant access to underlying functionalities are constantly expanding
    to work around these constraints, but if your application would benefit from non-standard
    peripherals or integration into specific operating system features, then a web
    UI may not be the right choice for you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络技术构建的应用程序，即使是使用混合框架构建的看似系统应用程序，都在沙盒中运行。这意味着它们在访问设备和系统功能方面存在某些限制。允许访问底层功能的JavaScript
    API不断扩展以克服这些限制，但如果你的应用程序可以从非标准外围设备或集成到特定操作系统功能中受益，那么网络用户界面可能不是你的正确选择。
- en: Access to communications ports, peripheral devices not included in typical web
    APIs, and process management are some low-level elements of an application that
    would not be supported by default. Additionally, interacting with a desktop environment's
    system tray, search features, and some advanced file management may be difficult
    to access from within the JavaScript code. To attempt to bridge this gap, some
    hybrid toolkits allow native code to be written and loaded as libraries to access
    this functionality. Such extensions, however, would need to be written in the
    platform's own language (usually C or C++) and then compiled for each supported
    platform. Not only does this increase the complexity of application distribution;
    it can also detract from the single-codebase app design technique that using web
    tools offers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通信端口、不包括在典型网络API中的外围设备以及进程管理是应用程序的一些低级元素，这些元素默认情况下不会得到支持。此外，与桌面环境系统托盘、搜索功能和一些高级文件管理进行交互可能从JavaScript代码中难以访问。为了弥合这一差距，一些混合工具包允许编写和加载本地代码作为库来访问这些功能。然而，此类扩展需要用平台自己的语言（通常是C或C++）编写，然后为每个支持的平台进行编译。这不仅增加了应用程序分发的复杂性；也可能损害使用网络工具提供的单一代码库应用程序设计技术。
- en: In comparison to this, other approaches to cross-platform development typically
    provide an abstraction over all supported operating systems so that an app can
    be built just once, but where support is missing, they provide a way to get direct
    access to the underlying features. This is often in the form of a language bridge
    or a way to load system libraries from the higher-level language. This can involve
    needing to build with different programming languages, as discussed earlier, but
    with cross-platform technologies outside of the web sandbox, it does not normally
    increase the distribution complexity as much. Additionally, it is far rarer to
    find devices not supported by a native cross-platform toolkit in comparison to
    one that is based in an embedded web browser.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，其他跨平台开发方法通常提供对所有支持操作系统的抽象，这样应用程序就可以一次构建，但在支持缺失的情况下，它们提供了一种直接访问底层功能的方法。这通常以语言桥接或从高级语言中加载系统库的形式出现。这可能需要使用不同的编程语言进行构建，如前面所述，但在Web沙盒之外的跨平台技术中，这通常不会大幅增加分发复杂性。此外，与基于嵌入式Web浏览器的工具包相比，找到不支持原生跨平台工具包的设备的情况要罕见得多。
- en: If some of the constraints of web technology cross-platform development mentioned
    in this section might impact your app, or if you would prefer not to be coding
    with HTML and JavaScript, then native toolkits are probably the right approach,
    which we will look at next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本节中提到的某些Web技术跨平台开发的限制可能会影响您的应用程序，或者如果您更愿意不使用HTML和JavaScript进行编码，那么原生工具包可能是正确的选择，我们将在下一节中探讨。
- en: Options for cross-platform native toolkits
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台原生工具包的选项
- en: As indicated earlier in this chapter, the idea of a cross-platform toolkit is
    not new—in fact, they date back to the mid-1990s, barely 10 years into the history
    of GUI development. It is important to understand that even among native cross-platform
    toolkits there are distinct approaches with different benefits and drawbacks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，跨平台工具包的概念并不新颖——实际上，它们可以追溯到20世纪90年代中期，当时GUI发展的历史还不到10年。重要的是要理解，即使在原生的跨平台工具包中，也存在不同的方法，各有其优势和劣势。
- en: Visual style
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉风格
- en: Cross-platform toolkits can be divided into two distinct visual approaches—the
    desire to match the look and feel of the system at runtime versus the delivery
    of a distinct look that will be consistent across all the environments. The Qt
    and GTK+ toolkits began with their own visual style that added the ability to
    be controlled by visual themes. Over time, they developed operating system-specific
    themes that allowed them to match the design of other applications on a system.
    In contrast, the Java AWT library was created as a code-level abstraction, meaning
    that programs would use operating system widgets to render despite the application
    being written for no specific platform. Interestingly, in 1998, Sun (the creators
    of Java) introduced the Swing toolkit, which offered a whole new look and feel
    that would be consistent across all platforms. This replacement user interface
    library slowly gained popularity as AWT was phased out. In an interesting twist,
    Sun introduced operating system lookalike themes that a developer could choose
    to enable in their app (unlike in GTK+ and Qt, this was not a user preference).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台工具包可以分为两种不同的视觉方法——在运行时匹配系统外观和感觉的愿望，与提供一致外观的愿望，这种外观将在所有环境中保持一致。Qt和GTK+工具包最初都有自己的视觉风格，增加了通过视觉主题进行控制的能力。随着时间的推移，它们开发了特定操作系统的主题，使它们能够匹配系统上其他应用程序的设计。相比之下，Java
    AWT库被创建为一个代码级别的抽象，这意味着程序将使用操作系统小部件进行渲染，尽管应用程序是为没有特定平台编写的。有趣的是，在1998年，Sun（Java的创造者）推出了Swing工具包，它提供了一种全新的外观和感觉，这种外观和感觉将在所有平台上保持一致。随着AWT的逐步淘汰，这个替换用户界面库逐渐获得了人气。在有趣的反转中，Sun引入了操作系统外观类似的主题，开发者可以选择在他们的应用程序中启用（与GTK+和Qt不同，这并不是用户的首选）。
- en: Compiled versus interpreted
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译与解释
- en: The other factor that commonly defines a toolkit is the choice of programming
    language—these can be split between those that are compiled into an application
    binary versus those distributed as source code that is interpreted at runtime.
    This distinction commonly correlates with statically typed languages compared
    to dynamically typed languages, which impacts programming styles and the design
    of associated APIs. In a compiled language that uses static typing, all variables
    are defined and checked at compile time. Their types (that is, the sort of content
    they contain or refer to) are set in the definition and never change. This approach
    typically catches programming errors early and can lead to robust code, but can
    be criticized as leading to slower application development. A compiled application
    will usually work directly on the computer it is built for, meaning that it does
    not require the installation of supporting technologies alongside the application.
    To achieve this, however, the apps will typically need to be compiled for each
    supported platform—again leading to longer development times required, this time
    for distribution tasks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 定义工具包的另一个常见因素是编程语言的选择——这些可以区分编译成应用程序二进制文件的语言与作为源代码分发并在运行时解释的语言。这种区别通常与静态类型语言与动态类型语言相关联，这影响编程风格和关联API的设计。在静态类型编译语言中，所有变量都在编译时定义和检查。它们的类型（即它们包含或引用的内容类型）在定义中设置且不会改变。这种方法通常可以早期捕获编程错误，并可能导致健壮的代码，但可能会受到导致应用程序开发速度较慢的批评。编译的应用程序通常可以直接在构建它的计算机上运行，这意味着它不需要与应用程序一起安装支持技术。然而，为了实现这一点，应用程序通常需要为每个支持的平台进行编译——这再次导致开发时间更长，这次是为了分发任务。
- en: In comparison, an interpreted language is typically held up as supporting faster
    development and quicker delivery. By allowing variables to be used for different
    types of content, the source code of an application can be shorter with fewer
    complications during the programming phase. Conversely, the reduced rigor means
    that it is usually required to have a more solid test infrastructure (through
    unit tests or automated user interface testing) that can ensure the correctness
    of the software. Distributing apps in this way will require a runtime environment
    to be installed so that the code can be executed (like the embedded web browser
    we saw when discussing hybrid apps). For some operating systems, there may be
    interpreters installed already, and for others, they may have to be installed
    by the user. Interestingly, there are some compilers available for interpreted
    languages that allow them to be distributed like any other binary application,
    though with the preceding trade-off that applications must be built for each target
    platform individually.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，解释性语言通常被认为支持更快的开发和更快的交付。通过允许变量用于不同类型的内容，应用程序的源代码可以更短，在编程阶段出现的复杂性也更少。相反，这种简化的严格性意味着通常需要有一个更稳固的测试基础设施（通过单元测试或自动用户界面测试）来确保软件的正确性。以这种方式分发应用程序将需要安装运行时环境，以便代码可以执行（就像我们在讨论混合应用程序时看到的嵌入式网页浏览器）。对于某些操作系统，可能已经安装了解释器，而对于其他操作系统，可能需要用户安装。有趣的是，有一些编译器可用于解释性语言，允许它们像任何其他二进制应用程序一样分发，尽管存在先前的权衡，即应用程序必须为每个目标平台单独构建。
- en: Interpreted options
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释性选项
- en: Due to the popularity of building GUIs, each of the main interpreted languages
    has its preferred toolkit. The Java runtime includes its own graphics routines,
    which means it can include a bespoke user interface, namely Swing. More recently,
    the JavaFX library has been built on top of the same graphical code. As mentioned
    earlier, Java also includes the AWT library, which delegates to system components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建GUI的流行，每个主要的解释性语言都有自己的首选工具包。Java运行时包括自己的图形例程，这意味着它可以包含定制的用户界面，即Swing。最近，JavaFX库是在相同的图形代码之上构建的。如前所述，Java还包括AWT库，它委托给系统组件。
- en: Other popular programming language runtimes do not ship with the same graphical
    components and so they typically rely on an underlying library. TkInter is the
    standard GUI library for Python, based on the Tk library, while the Ruby language
    does not recommend a standard library. Language bindings, which allow programmers
    to create applications using an interpreted language while using an underlying
    existing widget toolkit, such as Tk, GTK+, or Qt, are very popular. Using this
    method, there are too many options available to list, but they usually have the
    same drawback of not being designed for the language and so can be less intuitive
    to program than options built specifically for the language being used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的编程语言运行时没有附带相同的图形组件，因此它们通常依赖于底层库。TkInter 是 Python 的标准 GUI 库，基于 Tk 库，而 Ruby
    语言没有推荐标准库。语言绑定允许程序员使用解释语言创建应用程序，同时使用底层的现有小部件工具包，如 Tk、GTK+ 或 Qt，这些绑定非常受欢迎。使用这种方法，可用的选项太多，无法一一列举，但它们通常有一个缺点，即不是为语言设计的，因此编程起来可能没有专门为该语言构建的选项直观。
- en: Compiled options (C-based)
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译选项（基于 C）
- en: As shown earlier in this chapter, GUI development has a long history and the
    most popular toolkits were initially designed many years ago. GTK+ and Qt are
    both exceptionally popular, but they were designed for the C and C++ languages,
    respectively. While this does not stop them from being effective choices, it can
    make them seem a little outdated to the modern programmer. Possibly due in part
    to this reason, these GUI frameworks have seen language bindings made available
    for almost every programming language that exists. However, this does mean that
    you need to know a little about how the underlying system works to be most effective
    in development. For example, memory management in a C library is a complex and
    manual task, and not one that most developers want to worry about. Additionally,
    a C++-based library will have a different threading model beneath the surface
    that may not interact well with the higher-level language methodologies.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所示，GUI 开发有着悠久的历史，最流行的工具包最初都是许多年前设计的。GTK+ 和 Qt 都非常受欢迎，但它们分别是为 C 和 C++ 语言设计的。虽然这并不妨碍它们成为有效的选择，但它们对于现代程序员来说可能显得有些过时。可能部分原因就在于此，这些
    GUI 框架已经为几乎所有的编程语言提供了语言绑定。然而，这也意味着你需要了解一些底层系统的工作原理，以便在开发中发挥最大效用。例如，C 库中的内存管理是一个复杂且需要手动完成的任务，大多数开发者都不愿意去担心。此外，基于
    C++ 的库在底层可能有一个不同的线程模型，这可能与高级语言的方法不兼容。
- en: An additional consideration for toolkits that were designed decades ago is that
    they may not be best suited for the modern landscape of graphical computing devices.
    Screens, whether on a desktop, laptop, or mobile device, now come in a wide variety
    of sizes and pixel densities. This can bring challenges if code was built assuming
    that a pixel is a certain size, as used to be true. 96 **dots per inch** (**DPI**)
    was a common assumption, meaning that something 96 pixels high would measure about
    an inch when displayed. However, based on current devices, it could be anywhere
    from an inch down to 3/16ths of an inch (only 20% of the intended size), so it
    is important to understand how this will impact your application design. Older
    toolkits are typically based on pixel measurements, where the display is simplified
    to be a certain number of pixels (1, 2, 3, or 4) to represent each source pixel's
    size (which would be 1, 4, 9, or 16 pixels to display a square). Using a toolkit
    that scales in this manner can result in pixelated output if the application does
    not adapt carefully to the device.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设计了几十年的工具包，还有一个额外的考虑因素，那就是它们可能不适合现代图形计算设备的格局。屏幕，无论是在桌面、笔记本电脑还是移动设备上，现在都有各种各样的尺寸和像素密度。如果代码是基于像素大小来构建的假设，那么这可能会带来挑战，因为以前是这样的。96
    **每英寸点数**（**DPI**）是一个常见的假设，这意味着高度为 96 像素的东西在显示时大约为一英寸。然而，根据当前设备，它可能从一英寸到 3/16
    英寸（只有预期大小的 20%）不等，因此了解这将对应用程序设计产生什么影响非常重要。较老的工具包通常基于像素测量，其中显示被简化为一定数量的像素（1、2、3
    或 4）来表示每个源像素的大小（这将是 1、4、9 或 16 像素来显示一个正方形）。如果应用程序没有仔细适应设备，使用这种方式的工具包可能会导致像素化输出。
- en: Compiled options (other languages)
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译选项（其他语言）
- en: In part due to the legacy of the older C/C++-based GUI toolkits, but also in
    part because new programming languages bring benefits over the old ones, most
    of the newer compiled languages also have a toolkit built alongside. These more
    modern toolkits typically handle today's variety of devices much more effectively
    due to their more recent design. The challenges with pixel- or bitmap-based design
    is being overcome by moving to a vector image-based design. Vector images can
    be displayed at a higher quality output on screens of any pixel density. They
    do this by defining image elements such as lines, rectangles, and curves independently
    of output pixels; they are only drawn after the number of pixels available has
    been determined, resulting in higher quality on most output devices.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 部分原因是旧有的基于C/C++的GUI工具包的遗留问题，部分原因是新的编程语言相对于旧语言带来的好处，大多数较新的编译型语言也都有与之配套的工具包。这些更现代的工具包通常由于它们较新的设计，能够更有效地处理今天各种设备。通过转向基于矢量图像的设计，像素或位图设计带来的挑战正在被克服。矢量图像可以在任何像素密度的屏幕上以更高的质量输出。它们通过独立于输出像素定义图像元素，如线条、矩形和曲线，来实现这一点；它们仅在确定可用像素数量后才会绘制，从而在大多数输出设备上产生更高的质量。
- en: As we saw earlier, an operating system manufacturer often dictates the programming
    language used, and can push for new versions or programming languages when required.
    We can see this with Apple's recent move to Swift for the latest version of their
    UIKit and AppKit frameworks (this language is intended primarily for Apple devices
    but the trend is still noteworthy). Microsoft's development platform is currently
    geared toward C#, having previously used C, C++, and Visual Basic. Google is putting
    its energy into the Dart programming language and the Flutter toolkit built on
    top.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，操作系统制造商经常规定使用的编程语言，并在需要时推动新版本或编程语言的采用。我们可以从苹果最近将其UIKit和AppKit框架的最新版本迁移到Swift这一举措中看到这一点（这种语言主要用于苹果设备，但这一趋势仍然值得关注）。微软的开发平台目前正朝着C#的方向发展，之前曾使用过C、C++和Visual
    Basic。谷歌正在将精力投入到Dart编程语言和建立在它之上的Flutter工具包中。
- en: Other languages, such as Go, do not have an official GUI toolkit or widget library.
    In these situations, we can see various projects emerge with different ways of
    addressing the gap. In Go, the most active projects are andlabs UI, Fyne, and
    Gio. The andlabs project aims to use the current system style—in fact, it wraps
    the code to display them with a simple Go API—much like Java AWT discussed earlier.
    Gio is an immediate-mode GUI toolkit that aims to provide as much control as possible
    to the application developer, requiring the app to manage the rendering and event
    processing. The Fyne project aims for an API that is simple to learn and extend,
    without needing to worry about the rendering process—this is commonly known as
    *retained mode* as the widget state is managed by the library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言，如Go，没有官方的GUI工具包或小部件库。在这些情况下，我们可以看到各种项目出现，以不同的方式填补这一空白。在Go语言中，最活跃的项目是andlabs
    UI、Fyne和Gio。andlabs项目旨在使用当前系统样式——实际上，它通过简单的Go API包装代码来显示它们，就像之前讨论的Java AWT一样。Gio是一个即时模式的GUI工具包，旨在尽可能地为应用程序开发者提供控制权，要求应用程序管理渲染和事件处理。Fyne项目旨在提供一个简单易学且易于扩展的API，无需担心渲染过程——这通常被称为*保留模式*，因为小部件状态由库管理。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the history of graphical applications and the toolkits
    that power them. We saw that over the last half-century, many things have changed,
    and yet a lot of aspects have stayed the same. Through an illustration of trends
    in graphical design and technical capability, it became clear that these technologies,
    while adapting and improving in the eyes of the end user, can be slow to embrace
    the speed of improvement that developers expect. We saw that there are many different
    approaches to supporting the creation of GUIs that work across multiple platforms,
    but also that they can have drawbacks as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了图形应用程序的历史以及推动它们发展的工具包。我们看到，在过去的半个世纪里，许多事情都发生了变化，但许多方面仍然保持不变。通过展示图形设计和技术能力的发展趋势，我们清楚地认识到，尽管这些技术在最终用户眼中正在适应和改进，但它们在拥抱开发者期望的改进速度方面可能较为缓慢。我们了解到，有众多不同的方法来支持跨平台工作的GUI创建，但同时也存在一些缺点。
- en: In the next chapter, we will learn more about the Fyne toolkit's vision and
    design, and why the project team believes this provides the easiest way to build
    robust and performant graphical apps for any platform.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地了解 Fyne 工具包的愿景和设计，以及为什么项目团队认为这为在任意平台上构建健壮且性能卓越的图形应用程序提供了最简单的方法。
