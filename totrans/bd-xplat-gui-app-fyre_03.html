<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-36"><em class="italic"><a id="_idTextAnchor036"/>Chapter 2</em>: The Future According to Fyne</h1>
			<p>The Fyne toolkit design is based on the premise that the best way to resolve many of the challenges raised in <a href="B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">A Brief History of GUI Toolkits and Cross-Platform Development</em>, is to take a fresh approach to GUI toolkit design. It aims to combine the benefits of a modern programming language, the Material Design look, and a simple API. </p>
			<p>In this chapter, we explore the background and ambition of the Fyne project, including the following:</p>
			<ul>
				<li>The vision for Fyne and its team</li>
				<li>How does a modern programming language enable a fresh approach?</li>
				<li>How does it address the complexities of cross-platform, native app development?</li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/>Technical requirements</h1>
			<p>In this chapter, we will be using examples of Go code, so you will need to install the Go compiler – refer to the instructions at <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>. We will also explore bridging to C APIs, so you will need to install a C compiler as well. The installation of C varies from system to system. You can find details in <a href="B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253"><em class="italic">Appendix A</em></a>, <em class="italic">Developer Tool Installation.</em></p>
			<p>The full source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02</a>.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>Starting with a clean slate</h1>
			<p>Through the history of GUI development, we see that the majority of the most popular toolkits are based on C or C++ language code. These projects have a substantial history, large communities, and innumerable hours of development to make them what they are today. Despite being the yardstick against which all other toolkits are measured, they have drawbacks, mostly due to the legacy of the old design decisions they are built on. In this section, we reflect on why starting from scratch creates a better experience for building cross-platform apps.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Designing for modern devices</h2>
			<p>The types of devices we <a id="_idIndexMarker050"/>use today are both vastly different and much more <a id="_idIndexMarker051"/>varied compared with the 1980s and 1990s, when the most common <a id="_idIndexMarker052"/>toolkits were being designed and built. Today, a graphical application could be running on a desktop computer, laptop or netbook, a mobile device or tablet, smart phone or watch form factor, or even a set-top box or a smart TV. These device categories all have different user interface paradigms—APIs designed for a desktop computer using a mouse and keyboard don’t always adapt well to touchscreen-based input, multiple touch hand gestures, or a remote control as the primary input device. An input API designed for modern devices will be able to provide a suitable abstraction over the low-level details to focus on the user’s intent. By using this approach, applications can better adapt to the variety of devices in consumers’ hands.</p>
			<p>Along with the variety of device sizes come a wide spectrum of screen sizes and types. Mobile phones now have larger screens than ever, but they are still relatively small. However, the number of pixels they contain is huge, creating a smooth look when held close to our faces. TVs, on the other hand, are very large, but the resolution is low due to the distance they are usually observed at. Even desktop screens have changed—the average size has increased and the screens have become wider, but the biggest change is that pixel density has gone up astronomically, with high-end displays containing ten times as many pixels as those of cheap devices. Handling this variety of output devices requires resolution-independent rendering, which is a big shift from the origins of graphical toolkits, where pixels could be assumed to be a certain size. To work around these issues, some toolkits simply use a multiplier for each output pixel. This approach manages to avoid an app becoming too difficult to read by using more pixels to display the same original resolution—but will require application updates to avoid badly pixelated rendering.</p>
			<p>With the ever-increasing complexity of smart phones, consumers now expect that applications will adapt to their location, preferences, and behaviors. Much of this is possible <a id="_idIndexMarker053"/>due to the inclusion of many sensors, each of which have platform-specific APIs. An easy-to-use <a id="_idIndexMarker054"/>abstraction over the platform specifics is part of a good modern toolkit and significantly reduces the time spent by developers in preparing their software for the different platforms.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Parallelism and web services</h2>
			<p>Computing technology has come a long way in 50 years, not just in machine rooms and server racks, but on our desks and in our pockets. It is often said that we now have more power in our pockets than we had when man first landed on the moon. In fact, it’s more like 10,000 times the <a id="_idIndexMarker055"/>amount of power if you factor in a smart phone’s capabilities. To be able to accommodate this much power requires modern programming techniques—it’s not as simple as running the same code much faster. One major factor is that a modern operating system and any application on it will be able to calculate many things at the same time – but to do so effectively requires code that understands <strong class="bold">parallel processing.</strong> To make this adjustment is straightforward; code must be split into components that are independent enough to be able to run simultaneously. Introducing this ability can mean that memory is no longer controlled by a single part of code and so unexpected outcomes can <a id="_idIndexMarker056"/>occur (often called <strong class="bold">race conditions</strong>). Working around these complications with older tools can be very complicated and error prone.</p>
			<p>Almost all GUI toolkits to date (including the latest releases by Apple and Microsoft) require that changes to the user interface or output graphics are handled by the <em class="italic">main thread</em>, a single portion of the capability of any application. This constraint requires careful coordination from an application developer and potentially limits the computing power available for the graphical components of an app.</p>
			<p>One of the most common uses for background threads in an application will be communicating with remote resources. Web services or network resources are not accessible as fast as data on the local computer or bundled with an application, and so an app must manage user input and graphical updates while handling these slower requests. The core of most graphical toolkits and APIs is focused solely on the widgets—the presentation of the interface to the user. The design of many toolkits pre-dates cloud services and web-based APIs as we know them today. Powerful web services and standardized protocols for communication vastly improve the speed of development for web-based <a id="_idIndexMarker057"/>applications. Conversely, they can make it harder for native graphical applications on the desktop, where support is lacking from the core language or standard libraries. Inclusion of these features in modern programming languages is changing this and a modern graphical toolkit should provide similar benefits to developers.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>Building for any device</h2>
			<p>While considering the hardware characteristics and connected nature of devices, we need to consider how software is deployed to them. Each operating system expects applications to be packaged and installed in a different format and often have different ways of discovering and <a id="_idIndexMarker058"/>downloading software as well. Although the C and C++ languages do work across most platforms, it can be very complicated to compile for a computer that is different to the one that you are working on. This restriction has not been a problem for desktop and laptop apps, as companies simply buy the different types of computers to run the compilation and packaging. It is, however, more complex for mobile and embedded devices, where they cannot compile their own apps from the source code.</p>
			<p>Programming languages designed more recently include the ability to build for different systems from a single development computer. Although this is something that interpreted languages had done forever, it is now possible for your compiled applications (faster with no need for pre-installed runtime environments) to be <strong class="bold">cross-compiled</strong> for any device. In addition to this capability, the GUI toolkit must support preparation of different formats of application bundles that can package up the binary assets, resources, and other metadata for distribution. It is possible to perform these tasks manually, but a well-thought-out developer experience should ensure that this is practically automatic.</p>
			<p>Additionally, many distribution platforms such as app stores and software marketplaces require a certification process that ensures authenticity of the apps it will make available. The cryptographic steps required to set this up are often lengthy and can be a hurdle to new app developers looking to make their work available. Rethinking a toolkit and the utilities it provides would allow this problem to be addressed alongside the compilation and packaging challenges.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>Best practices have moved on</h2>
			<p>A final factor that can be observed when evaluating a toolkit for developing your app might be how <a id="_idIndexMarker059"/>up to date its best practices are. It has long been thought that automated testing of graphical <a id="_idIndexMarker060"/>applications is next to impossible, an opinion that is in no small way due to the fact that <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) and <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) were not <a id="_idIndexMarker061"/>common practices when the legacy toolkits, or the programming languages they use, were designed. A developer looking to learn, or one that is in a team of professional software engineers, would probably expect such practices to be supported or even encouraged in modern tools.</p>
			<p>The C language (and many derivatives thereof) have often been criticized for the weak handling of string types. In fact, it is this very deficiency that has led to many highly visible software vulnerabilities and public data breaches. Although not all older programming languages suffer from this issue, they almost all have the restriction of only supporting simple strings using the <em class="italic">Latin alphabet</em> (although some have add-on libraries that attempt to work around this). With such a restriction, it is difficult to write an application that will easily adapt to the variety of commonplace languages that software should support in this international world. The <strong class="bold">Unicode</strong> standard <a id="_idIndexMarker062"/>is the universal approach to handling internationalized text, but this <em class="italic">multi-byte</em> (using more than a single byte to represent a letter or symbol) format can cause problems when introduced to software that was not designed to understand it. Users and developers alike now expect these complex encodings to be supported, and so the drawbacks of older toolkits continue to grow.</p>
			<p>As you can see, there are a number of challenges in developing, or working with, a graphical toolkit that could be overcome if we start from scratch. And so, the Fyne toolkit decided to do just that, but to do so required a choice as to which programming language to use. As we know, Go was picked for Fyne—in the next section, we look at why it was seen to be a good fit to overcome the challenges faced. </p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>How Go is a great fit for this challenge</h1>
			<p>In the previous section, we <a id="_idIndexMarker063"/>saw that there are many reasons why graphical toolkits are rooted in dated foundations and that even the languages they are built with could be limiting their chances of adapting. A number of manufacturers are recognizing this problem and reaching to new languages to find solutions or even avoid the challenges of the past completely. Apple is moving all development to the Swift language, although Apple-supported software is designed to run on their devices only. Other companies, such as Facebook, are finding ways to adapt more modern web-based tools to create native apps for phones and desktop.</p>
			<p>Neither the approach of a platform-specific technology nor languages derived from the interpreted internet technologies are going to be able to truly create a delightful development experience. We are looking for a development platform that results in performant and robust, cross-platform applications—the panacea of modern application development. I, the author of this book and indeed the Fyne project, believe that Go may be the language to underpin such a revolution in building cross-platform graphical applications.</p>
			<p>To quote the Go frequently asked questions on this <a id="_idIndexMarker064"/>topic, refer to <a href="https://golang.org/doc/faq">https://golang.org/doc/faq</a>.</p>
			<p class="author-quote">Go addressed these <a id="_idIndexMarker065"/>issues by attempting to combine the ease of programming of an interpreted, dynamically typed language with the efficiency and safety of a statically typed, compiled language. It also aimed to be modern, with support for networked and multicore computing.</p>
			<p>In this section, we will look at the various reasons why the Go programming language is well placed to support a new era of GUI programming.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>Simple cross-platform code</h2>
			<p>Go is a language <a id="_idIndexMarker066"/>that (like C, C++, Swift, and many others) compiles to a native binary on every platform it supports. This is important for graphical applications as it’s the best way to create the most responsive and smoothest user interfaces on mainstream computer hardware. What stands out about Go compared to other languages that are popular with GUI developers is that it manages to support a long list of operating systems while compiling, without any alterations or special adaptation, to native code on every platform. This means that a Go-based project can be built on any computer for any other computer, using the standard tools, with no need for complex build configurations or extra developer packages to be installed. At the time of writing, the platforms that Go runs on includes Windows, macOS, Linux, Solaris, and other popular Unix-based operating systems (which is essentially all desktop personal computers) along with iOS, Android, and other Linux-based mobile devices (and even tiny embedded computers via TinyGo).</p>
			<p>Go is a <em class="italic">typed</em> language, which means that every variable, constant, function parameter, and return type must have a single, defined type—leading to robust code by default. Unlike some older typed languages, Go is often able to infer a type, which helps avoid the duplication of information in the source code (in fact, one of Go’s design principles is to avoid duplication). These features help to create a language that’s fast and fun to develop with, while creating software that is as solid as the languages traditionally used for native graphical apps.</p>
			<p>In addition to being easy to learn and simple to read, the Go language comes with well communicated standards for code style, documentation, and testing. Standardization such as this makes it easy for developers to understand different projects and reduces the time required to integrate libraries and learn new APIs. As well as documenting these standards, the Go development tools include utilities that can check whether your code meets these guidelines. In many cases, they can even update your source code files to comply automatically. Quite naturally, the development environments that support Go also <a id="_idIndexMarker067"/>encourage following the guidelines, making it even easier to reduce the learning curve for anyone joining your project.</p>
			<p>As well as standard formats for source code and documentation for all APIs, the Go language and community support and encourage unit testing in apps and libraries. The compiler has built-in test functionality normally associated with <em class="italic">dynamic</em> languages that need this sort of check to ensure correctness. The inclusion of effective testing alongside an already robust language provides validation of code behavior and makes it easier for code to be changed by individuals other than those that created it. In fact, in a collection of popular Go libraries, one of the requirements for being listed is that your code meets an 80% unit test code coverage metric (see <a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a> and their contribution guidelines).</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Standard library</h2>
			<p>The standard library of a <a id="_idIndexMarker068"/>programming language is the set of APIs and features that are provided by the language runtime. C, for example, has a very small standard library—as a low-level language designed for many different types of devices, the number of features that it can support for every operating system is limited. Java, on the other hand, historically known for being heavy on memory and start up time, provides a massive standard library—including the Swing GUI described in <a href="B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">A Brief History of GUI Toolkits and Cross-Platform Development</em>. This is a trade-off that all languages need to make when deciding in favor of smaller memory or lots of built-in features.</p>
			<p>Thankfully, the Go language makes a clever balance, allowing it to comprise a large library of APIs that fully support every one of its target operating systems. To do this, it makes use of <strong class="bold">build tags</strong> that allow <a id="_idIndexMarker069"/>inclusion of only the code needed for the current (or target) operating system. This is a huge advantage for developers who want to write an efficient application for multiple operating systems without maintaining slightly different versions for each platform, or suffering slow load times or large memory requirements.</p>
			<p>The standard library included with Go includes powerful features across many areas, including cryptography, image manipulation, text handling (including Unicode), networking, concurrency, and web service integration (we will cover this in the sections to come). You can read the full documentation at <a href="https://golang.org/pkg/#stdlib">https://golang.org/pkg/#stdlib</a>.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>Concurrency</h2>
			<p>As illustrated in the <em class="italic">Parallelism and web services</em> section earlier, a modern programming <a id="_idIndexMarker070"/>language needs to handle concurrency. Unfortunately, working with the APIs to manage multithreading can add complexity and make code harder to read. The designers of Go decided <a id="_idIndexMarker071"/>that concurrency should be incorporated from the beginning, making it easy to manage many threads of execution while still avoiding the difficulty of shared memory management. GUI toolkits built on languages without this built-in awareness of concurrency have propagated the idea that graphical routines must happen on a particular thread. By starting from scratch with a better suited language, we can avoid such constraints.</p>
			<p>Go does not expose traditional threads, but instead introduces the concept of <strong class="bold">goroutines</strong>—these are <a id="_idIndexMarker072"/>akin to lightweight threads, but that are enhanced to support several thousand at the same time. It is common for applications to communicate between background processes by sharing memory, but this introduces issues <a id="_idIndexMarker073"/>known as <em class="italic">race conditions</em>, requiring more code to manage access. To avoid this, Go provides <strong class="bold">channels</strong>—a <a id="_idIndexMarker074"/>mechanism for communicating between threads of execution without causing the same problems. With this model, the language manages the safe transfer of information from one goroutine to another, keeping multithread code neat and easy to understand.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>Web services</h2>
			<p>As a modern programming <a id="_idIndexMarker075"/>language, Go comes with extensive support for HTTP clients, servers, and standard encoding handlers, including JSON and XML. For GUI developers coming from a background in C programming, this is a significant improvement—web services, and indeed remote resources, were not commonplace when the language or its toolkits were created.</p>
			<p>Thanks to language-level <a id="_idIndexMarker076"/>support for text encoding used in web communications, it is possible to load data structures directly from an HTTP request. Such convenience may be standard for web-based languages such as JavaScript and PHP, but to function in a strictly typed language without using third-party code is a rare bonus.</p>
			<p>Despite these features that make Go an excellent language for building complex applications that can be described at a high level and thoroughly tested, it is also possible to perform platform-specific requests to the operating system if required.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>High level with system access</h2>
			<p>Even with a fully featured programming language, it can be occasionally necessary to access low-level components or platform-specific APIs. Whether it is to send a notification, read data from a custom device, or simply to call a function specific to the current operating system, it will occasionally be necessary to access functionality that is not included in a programming language or its standard library. To solve this challenge, Go provides three <a id="_idIndexMarker077"/>avenues to handle the platform-specific aspects of a program—syscall, CGo, and build tags.</p>
			<h3>Build tags</h3>
			<p>In Go, it is possible to include part of your code for specific operating systems at a per-file level based on <a id="_idIndexMarker078"/>some conditional parameters called <strong class="bold">build tags</strong>. This can be <a id="_idIndexMarker079"/>helpful to adjust behavior when your app will run on certain systems, but is more beneficial in controlling the inclusion of the platform-specific use of syscall or CGo code illustrated in the next sections.</p>
			<p>Even if your app is not making specific use of operating system-specific calls, it can be helpful to make use of the conditional compilation. In simple cases, Go code can check what system an app is running on to execute slightly different code (by checking the value of <strong class="source-inline">os.GOOS</strong>, for example, a function could return different values). However, for more behavioral changes, it can be useful to put the platform-specific code into separate files that are named in a certain convention (for example, <strong class="source-inline">*_windows.go</strong> will be included when building for Microsoft Windows) or through the use of the special comment at the top of a file (such as <strong class="source-inline">// +build linux,darwin</strong> including the file when Linux or macOS is the target platform).</p>
			<h3>Syscall</h3>
			<p>One of the packages <a id="_idIndexMarker080"/>provided by Go’s standard library is <strong class="bold">syscall</strong>. This package <a id="_idIndexMarker081"/>provides a way to access the low-level, operating system-specific functionality, for example, accessing network sockets or managing desktop windows. The functionality that is available will vary based on the underlying system (the target operating system), but can be very powerful when combined with build tags. This package is used by other built-in packages, such as <strong class="source-inline">os</strong> and <strong class="source-inline">net</strong>, to provide higher-level abstractions, so double-check that the functionality you desire is not provided by another package before using syscall.</p>
			<p>A typical call into this package might be to request details of a Windows registry key, or to load a DLL (a system library on a Windows computer) to access functionality not provided by Go. On a Linux computer, you may use this functionality to read or write to specific memory areas such as connected devices, where permitted. A system call is a very complicated procedure and, where possible, it will normally be easier to call a C function instead – we see how to do that with CGo next.</p>
			<h3>CGo</h3>
			<p>If your application, or <a id="_idIndexMarker082"/>one of the libraries that you rely upon, was written with <a id="_idIndexMarker083"/>the C language (or one of its derivatives, such as C++ or Objective-C) for specific reasons and you’re not able to move it to Go, then CGo is an invaluable feature. Using this functionality, it is possible to include C code directly, or call out to other C-based functionality. It is important to use this carefully—there are some performance impacts in making the jump from one language to another—but more significantly you need to remember about memory management and threading in a way that Go would normally manage for you.</p>
			<p>The following source code shows C and Go code in the same file where we convert a Go string into a C string (or, more strictly, a <strong class="source-inline">[]byte</strong>) and pass it into a C function. As you can see, we also need to free the memory we passed into the C code once it is no longer required:</p>
			<p class="source-code">package main</p>
			<p class="source-code">/*</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">void print_hello(const char *name) {</p>
			<p class="source-code">    printf("Hello %s!\n", name);</p>
			<p class="source-code">}</p>
			<p class="source-code">*/</p>
			<p class="source-code">import "C"</p>
			<p class="source-code">import "unsafe"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    cName := C.CString("World")</p>
			<p class="source-code">    C.print_hello(cName)</p>
			<p class="source-code">    C.free(unsafe.Pointer(cName))</p>
			<p class="source-code">}</p>
			<p>The preceding code can be run just like any other Go program, as follows:</p>
			<p class="source-code"><strong class="bold">$ go run cgo.go</strong></p>
			<p class="source-code"><strong class="bold">Hello World!</strong></p>
			<p class="source-code"><strong class="bold">$</strong></p>
			<p>In the code snippet, you <a id="_idIndexMarker084"/>can see that the C code is included in a comment above the <strong class="source-inline">import "C"</strong> line. This code <a id="_idIndexMarker085"/>could be in a separate <strong class="source-inline">.c</strong> file or even within a library on the build computer (and the Go compiler will use <strong class="source-inline">pkgconfig</strong> to find the required headers). When used in combination with conditional building such as build tags in the previous code, you can see that it is possible to access platform-specific functionality or legacy code where required.</p>
			<p>This section considered the Go language and how its design is well suited to building a modern GUI toolkit. Next, we will look at how Material Design provides a great aesthetic for Fyne applications.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Looking good with Material Design</h1>
			<p>A key part of any GUI toolkit that can impact the developer’s selection and also the user appeal of the applications <a id="_idIndexMarker086"/>built is the overall design language. This choice of aesthetic can be seen in the colors, fonts, layouts, and even icon design. Some of these choices are obvious and others more subtle, but, when combined, result in a recognizable application look and feel.</p>
			<p>New cross-platform toolkits commonly create their own design, such as Java’s Swing or the GTK+ and Qt toolkits. These are often designed to look contemporary with the software of the time—you can recognize a 1990s desktop application design in those toolkits. In the current landscape, usability and design principles of mobile apps are being adapted and deployed to other areas, bringing a new age of software design to traditional applications. Because of its work in this space, the Material Design project makes a good match for application design aiming at universal cross-platform appeal.</p>
			<p>The official website for Material <a id="_idIndexMarker087"/>Design (<strong class="source-inline">https://material.io</strong>) describes material as follows:</p>
			<p class="author-quote">Material is an adaptable system of guidelines, components, and tools that support the best practices of user interface design. Backed by open source code, Material streamlines collaboration between designers and developers, and helps teams quickly build beautiful products.</p>
			<p>Google first published the Material Design guidelines in 2014 based on their earlier work on a new design language for their websites. It has since been applied to their different web properties and has also become the visual design for the Android operating system. This adaptation meant that the component designs have identified areas that work across all platforms and also where slight adaptation may be required for desktop computers, reducing the work required by Fyne or other cross-platform toolkits that use its design language.</p>
			<p>The layout and functionality of the standard components varies by platform, and implementation though clear recommendations is documented at the main website, <a href="https://material.io">https://material.io</a>. What can be more universally recognized is the color palette and iconography used in material-based apps.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Color palette</h2>
			<p>Material Design colors are oriented around a standard color palette. A primary color is used to raise the <a id="_idIndexMarker088"/>importance of certain elements, such as default buttons or focused input. A complementary secondary color is (optionally) reserved for accenting important items, such as floating buttons or selected text. The Material Design project provides a baseline color theme that can be used with any app. Developers may also choose their own primary and secondary colors to match their brand identity or preferred aesthetic. Here is the baseline color palette:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B16820_02_01.jpg" alt="Figure 2.1 – The material design ”baseline” color palette&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The material design ''baseline'' color palette</p>
			<p>The striking colors of a material theme help an application to have a clean design while conveying meaning and importance. Similarly, the material design offers a set of clean, crisp icons that should be used where possible.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>Standard icons</h2>
			<p>The material icons are designed to be <em class="italic">delightful and beautifully crafted</em> and cover the common <a id="_idIndexMarker089"/>interactions and standard items for most modern software. They cover topics such as standard hardware, file types, content operations, and user actions. As well as the standard icon set, there are repositories of community submitted add-ons that can be useful for applications that employ fewer standard operations. In the following screenshot, we can see some material design icons:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B16820_02_02.jpg" alt="Figure 2.2 – A small selection of material design icons&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – A small selection of material design icons</p>
			<p>By following the material design specification, any apps built using the Fyne toolkit will be clean and easy to use from the outset, while supporting an element of brand identity and customization.</p>
			<p>We have seen how Fyne-based apps look to the end user, but for a developer, the API design is just as important. Let’s look at how the team aim to keep that just as clean and well crafted.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Designing APIs for simplicity and maintainability</h1>
			<p>A delightful user experience is an important ambition for any application toolkit, but Fyne aims to make the experience of development a pleasure as well. To do this, the API must be planned carefully to be simple and easy to learn, but also extensible to support more complex applications. The project’s modular approach aims to support this while also being testable every step of the way.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Semantic API</h2>
			<p>An <strong class="bold">API</strong> (or <strong class="bold">Application Programming Interface</strong>) is typically <a id="_idIndexMarker090"/>defined as a set of functions and <a id="_idIndexMarker091"/>procedures that controls access to features and data. At a high level, however, the Fyne toolkit <a id="_idIndexMarker092"/>aims to deliver a <em class="italic">semantic API</em>, a set of functions that defines intent rather than features or functionality. By taking this approach, the toolkit is able to separate meaning from presentation.</p>
			<p>For example, we can consider a simple button—when there are many on a screen, you may wish for one to stand out against the other as more important. In an API that is focused on presentation or styles, you might set the button color; with the Flutter GUI toolkit, this would appear as follows:</p>
			<p class="source-code">FlatButton(color:Colors.cyan, child: Text("Tap Me"))</p>
			<p>In comparison, an API that takes a semantic approach would allow developers to indicate the expected difference through a button type or intent field, as the following Fyne snippet does:</p>
			<p class="source-code">widget.Button{Text: "Tap Me", Importance: widget.                	    HighImportance}</p>
			<p>Following this approach allows for a consistent API that describes the expected outcomes instead of features that could hint at those outcomes. It also allows the current theme to ensure a consistent visual style and avoids developer-defined code creating unreadable or unattractive graphical choices.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>Modular</h2>
			<p>When building a robust toolkit designed to work seamlessly across many different operating systems and computers, it is important to take a modular approach. Doing so ensures that no element of the library will be able to make false assumptions about other areas of the code. To accidentally expose all the inner details of a key area, such as a graphics driver, might restrict a widget to function correctly on a single operating system or in a particular graphics mode. This technique is known in <a id="_idIndexMarker093"/>software engineering as <strong class="bold">Separation of Concerns</strong>.</p>
			<p>In the Go language, modules <a id="_idIndexMarker094"/>are known as <strong class="bold">packages</strong> and they are structured hierarchically under the project root. To allow different parts of the system to communicate, a project typically defines a collection of <strong class="bold">interface</strong> types <a id="_idIndexMarker095"/>that describe the functionality, and dependencies that some code may choose to conform to. By loading code that implements these interfaces, an application or library can compose separate elements of code to create the complete solution. Each area is only aware of the declared capability that each interface publicizes and can hide all of the inner details. This allows complex software to be built and tested in smaller pieces, which is far easier to test and even to debug if something goes wrong.</p>
			<p>In Fyne, the use of packages can be seen in many areas, with the most notable being implementations of the <strong class="source-inline">Driver</strong> and <strong class="source-inline">Widget</strong> interface definitions. The use of drivers in the Fyne toolkit makes it possible for applications to run on many different types of computers without <a id="_idIndexMarker096"/>needing to know, or accidentally taking advantage of, specific details of a single device. When an application starts, the correct driver will be loaded to handle specific details of running on the current computer. As you will see in <a href="B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a>, <em class="italic">Widget Library and Themes</em>, the various widgets inside Fyne (and indeed custom ones that can be added by app developers) all implement the <strong class="source-inline">Widget</strong> interface. The behavior that all widgets must implement provides information to the driver and graphics code about how it should appear, meaning that the graphics code does not need to know any inner details of a widget to be able to draw it in an application window. This makes it possible for widget developers to avoid impacting graphics code, and indeed for other developers to add custom widgets outside the toolkit code.</p>
			<p>One other benefit of a modular approach is that code can be executed without launching in a standard application or showing any windows. This may not be a common requirement for user-facing code, but it is very important to support the efficient testing of applications.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Testable</h2>
			<p>Automated testing of graphical user interface code has long been considered one of the hardest steps of a full test suite, and this becomes even more difficult if you add smart phones or mobile devices to your supported platforms. Each operating system may require a different methodology and probably also specific code to be written and maintained in order to run the test suite. As mentioned in the previous section, the modular approach taken by the Fyne toolkit promises easier testing by not requiring applications to be displayed for the test scripts to execute.</p>
			<p>Because of its modular design, the drawing components of a Fyne-based application are a minor detail. The main logic and behavior of widgets are defined completely separately to the graphical output. This approach allows all elements to be tested through automated interactions faster and more reliably than alternative tools that load applications and then tap buttons using test runners that control the mouse and keyboard (or touchscreen) hardware. The following code snippet shows how a <strong class="source-inline">Button</strong> and <strong class="source-inline">Entry</strong> widget could be tested in a simple unit test:</p>
			<p class="source-code">func TestButton_Tapped(t *testing.T) {</p>
			<p class="source-code">    tapped := false</p>
			<p class="source-code">    button := widget.NewButton("Hi", func() {</p>
			<p class="source-code">        tapped = true</p>
			<p class="source-code">    })</p>
			<p class="source-code">    test.Tap(button)</p>
			<p class="source-code">    if !tapped {</p>
			<p class="source-code">        t.Errorf("Button was not tapped")</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">func TestEntry_Typed(t *testing.T) {</p>
			<p class="source-code">    entry := widget.NewEntry()</p>
			<p class="source-code">    test.Type(entry, "Hi")</p>
			<p class="source-code">    if entry.Text != "Hi" {</p>
			<p class="source-code">        t.Errorf("Text was not updated")</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see, these <a id="_idIndexMarker097"/>two simple unit tests (using the standard Go test structure) are able to test that the <strong class="source-inline">Button</strong> and <strong class="source-inline">Entry</strong> widgets behave as expected when standard user interactions occur. The test helpers <strong class="source-inline">Tap</strong> and <strong class="source-inline">Type</strong> are provided to perform these actions, along with various other utilities in the <strong class="source-inline">test</strong> package. By building up a test suite in this manner, you can execute thousands of GUI tests per second, without ever having to load a window or connect to a specific device. In fact, this very functionality supports true TDD for graphical applications. This approach means that application code can be designed and understood before it is implemented, leading to more robust software and better decoupling of modules, thereby allowing more developers to work on a project concurrently. </p>
			<p>The Fyne toolkit will ensure that all elements will be presented correctly on any device that your app will be distributed to. Its drivers and widgets all undergo the same testing rigor described earlier in this section. Sometimes, however, it is necessary to test the actual rendered output of a widget or screen. In this situation, the <strong class="source-inline">test</strong> package has more utilities that can aid your development. Although not visible on your screen, the Fyne test code will calculate how the output would look and can save this to an image through a <strong class="source-inline">Capture()</strong> function. The test helper <strong class="source-inline">AssertImageMatches</strong> is then able to compare this to a specific output either saved earlier or created by a designer:</p>
			<p class="source-code">func TestButton_Render(t *testing.T) { </p>
			<p class="source-code">    button := widget.NewButton("Hi", func() {}) </p>
			<p class="source-code">    window := test.NewWindow(button)</p>
			<p class="source-code">    test.AssertImageMatches(t, "button.png", window.Canvas().    	        Capture()) </p>
			<p class="source-code">}</p>
			<p>This code sample does include some details about <strong class="source-inline">Window</strong> and <strong class="source-inline">Canvas</strong> that we will cover in <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Windows, Canvas, and Drawing</em>, but you can see the overall simplicity. The code defines a widget (in this case a <strong class="source-inline">Button</strong> widget), and then adds it to a test window that is then captured and compared to a pre-existing image file. The test window is not shown on screen or even communicated to the operating system—it is loaded purely in memory to simulate the drawing process.</p>
			<p>We have seen how good modularity and testing can result in more robust applications, but this has described the toolkit design—is it possible for developers to extend the functionality for their own purposes?</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>Extensible</h2>
			<p>The core widgets of the <a id="_idIndexMarker098"/>Fyne toolkit are designed to be robust, easy to use, and well tested, but a toolkit cannot include every possible type of widget. For this reason, a toolkit also needs to be extensible, supporting the inclusion of widgets that were not defined by the core project—either as add-on libraries or by allowing applications to add their own custom user interface elements.</p>
			<p>The Fyne project allows widgets to be included in two different ways—developers can extend existing widgets (keeping the main rendering consistent, but adding new functionality) or by adding their own widgets. As described in the <em class="italic">Modular</em> section earlier, any code that implements the <strong class="source-inline">Widget</strong> interface will be interpreted as an interface component and can be used throughout any Fyne application. Later in this book, we will also see how existing widgets can be extended to add new functionality or tweak behavior to suit a particular application.</p>
			<p>Due to the interface-based design of the modular code base, there are many other ways in which a Fyne application can be extended. By implementing the <strong class="source-inline">Layout</strong> interface, an app can define its component position and sizing, or, using the URI interface, it could connect to different types of data resources (for more information, see <a href="B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Layout and File Handling</em>).</p>
			<p>As you can see, the design of a <a id="_idIndexMarker099"/>toolkit and its API is just as important as the functionality it contains. To complete this chapter, let’s review the overall vision of the Fyne project.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/>A vision of the future</h1>
			<p>The Fyne project was created in response to growing criticism of the complexity in existing graphical <a id="_idIndexMarker100"/>toolkits and application APIs and their inability to adapt to modern devices and best practices. It was designed with the aim of being easy to use, and the Go language was chosen for its <a id="_idTextAnchor058"/>powerful simplicity.</p>
			<p>The vision statement on the Fyne project wiki (<a href="https://github.com/fyne-io/fyne/wiki/Vision">https://github.com/fyne-io/fyne/wiki/Vision</a>) states the following:</p>
			<p class="author-quote">Fyne’s APIs aim to be the best for developing beautiful, usable, and lightweight applications for desktop and beyond.</p>
			<p>With more device types and platform-specific toolkits than we have seen in recent times, it is more difficult, and more expensive than ever, to deliver a great native app experience across all platforms. The Fyne toolkit is positioned as a solution to these challenges, while bringing the design and user experience learning from modern mobile apps to all devices.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Beautiful apps</h2>
			<p>Fyne aims to support the building of graphical applications that look consistent across all platforms, rather than adopting the look and feel of the operating system. Its APIs ensure that all apps provide a polished user experience and render a beautiful application GUI. Using the Material Design guidelines, a Fyne-based app will look familiar to Android users and match the aesthetic of the flat user interface in Windows 10. For operating <a id="_idIndexMarker101"/>systems where the user interface is typically in a different style, users will still be delighted by the crisp visual design, bundled icons, and clean typography.</p>
			<p>As many operating systems now offer a choice of light and dark modes, toolkits need to adapt appropriately to meet user expectations. All Fyne apps include a light and dark theme and, unless the developer overrides the setting, it will match the current system configuration. When end users change their system theme, any running Fyne apps will update to reflect configuration changes. This is shown in the following image, we see what the light and dark Fyne themes look like:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B16820_02_03_-__Combine.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Simple to learn</h2>
			<p>As well as maintaining a clean, simple design, the Fyne team wants to ensure that everyone can learn to build graphical applications. To do this, the barrier to entry needs to be low—through simple installation and setup with documentation and tutorials readily available to support even the most inexperienced developer. </p>
			<p>Developers who have not used the Go language before can start with the online tour (<a href="https://tour.golang.org/">https://tour.golang.org/</a>), and from there move to the Fyne tour, which introduces developers to the concepts of GUI development and how to get started with the project (<a href="https://tour.fyne.io/">https://tour.fyne.io/</a>). Lots more documentation is available at the main developer website, containing tips on getting started, code tutorials, and a full API reference (<a href="https://developer.fyne.io/">https://developer.fyne.io/</a>).</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Platform-agnostic</h2>
			<p>Cross-platform toolkits have various levels of complexity when building for different platforms. Some <a id="_idIndexMarker102"/>require different build processes and others will load different user interfaces, depending on the type of device. Fyne aims to be easier to use across these disparate targets and aims for <strong class="bold">platform-agnostic</strong>, meaning that the <a id="_idIndexMarker103"/>code doesn’t need to know anything about the device it is running on.</p>
			<p class="author-quote">For many start-ups, the term platform agnostic represents a kind of unattainable utopia in the world of mobile apps.</p>
			<p>This quote is from <a href="http://alleywatch.com.">http://alleywatch.com.</a></p>
			<p>The code of a Fyne-based app does not need to adapt to system specifics and can compile for any devices using the same set of tools. As we will see later in the book, it is sometimes necessary to adjust for a specific operating system or device. In these situations, there are Go and Fyne APIs available to help. For many applications, it will be possible to avoid any customization per-system and the only element of the process that varies will be the application distribution.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Distribution to all platforms</h2>
			<p>When your app is ready for release, it needs to be packaged and uploaded to a central place where users can find it. Unfortunately, every operating system uses different packaging formats, and every vendor has a different store or marketplace for apps. The <strong class="source-inline">fyne</strong> command-line tool that we <a id="_idIndexMarker104"/>will use many times throughout this book is able to create application bundles in all of the required formats. With the app bundled, it can be installed locally, shared with friends, or uploaded to a website for distribution.</p>
			<p>Most systems are now moving to an app store or marketplace model where apps are available in a manufacturer provided location with screenshots, free advertising, and a managed installation. One of the challenges here is that every store is different and the process of certifying and uploading apps is different for each platform. The Fyne tool helps with the release <a id="_idIndexMarker105"/>process as well—streamlining as much as possible and ensuring a consistent developer experience for all stores.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we have seen how designing a new graphical toolkit could overcome many of the challenges still faced by existing approaches. We explored the background and vision for Fyne, how it aims to solve these difficulties, and how it supports creating beautiful and performant apps across all popular desktop and mobile devices. We introduced Material Design and saw how it brings modern usability principles and design learnings to desktop and beyond. By using the <strong class="source-inline">fyne</strong> build tools, we saw that an app can be built and distributed for any devices or app stores without any platform-specific code.</p>
			<p>In the next chapter, we will explore the fundamentals of a Fyne application and see how its drawing capabilities allow us to build a simple game.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/>Further reading</h1>
			<p>To learn more about some of the topics introduced in this chapter, you can visit the following websites:</p>
			<ul>
				<li>Test-driven development: <a href="https://www.agilealliance.org/glossary/tdd/">https://www.agilealliance.org/glossary/tdd/</a></li>
				<li>The Go programming language: <a href="https://golang.org/">https://golang.org/</a></li>
				<li>C bindings from Go: <a href="https://golang.org/cmd/cgo/">https://golang.org/cmd/cgo/</a></li>
				<li>The Material Design system: <a href="https://material.io">https://material.io</a></li>
				<li>Fyne toolkit developer documentation: <a href="https://developer.fyne.io/">https://developer.fyne.io/</a></li>
			</ul>
		</div>
	</body></html>