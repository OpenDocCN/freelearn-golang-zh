- en: '*Chapter 2*: The Future According to Fyne'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fyne toolkit design is based on the premise that the best way to resolve
    many of the challenges raised in [*Chapter 1*](B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015),
    *A Brief History of GUI Toolkits and Cross-Platform Development*, is to take a
    fresh approach to GUI toolkit design. It aims to combine the benefits of a modern
    programming language, the Material Design look, and a simple API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we explore the background and ambition of the Fyne project,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The vision for Fyne and its team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does a modern programming language enable a fresh approach?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does it address the complexities of cross-platform, native app development?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using examples of Go code, so you will need to install
    the Go compiler – refer to the instructions at [https://golang.org/doc/install](https://golang.org/doc/install).
    We will also explore bridging to C APIs, so you will need to install a C compiler
    as well. The installation of C varies from system to system. You can find details
    in [*Appendix A*](B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253), *Developer
    Tool Installation.*
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a clean slate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through the history of GUI development, we see that the majority of the most
    popular toolkits are based on C or C++ language code. These projects have a substantial
    history, large communities, and innumerable hours of development to make them
    what they are today. Despite being the yardstick against which all other toolkits
    are measured, they have drawbacks, mostly due to the legacy of the old design
    decisions they are built on. In this section, we reflect on why starting from
    scratch creates a better experience for building cross-platform apps.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for modern devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The types of devices we use today are both vastly different and much more varied
    compared with the 1980s and 1990s, when the most common toolkits were being designed
    and built. Today, a graphical application could be running on a desktop computer,
    laptop or netbook, a mobile device or tablet, smart phone or watch form factor,
    or even a set-top box or a smart TV. These device categories all have different
    user interface paradigms—APIs designed for a desktop computer using a mouse and
    keyboard don’t always adapt well to touchscreen-based input, multiple touch hand
    gestures, or a remote control as the primary input device. An input API designed
    for modern devices will be able to provide a suitable abstraction over the low-level
    details to focus on the user’s intent. By using this approach, applications can
    better adapt to the variety of devices in consumers’ hands.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the variety of device sizes come a wide spectrum of screen sizes
    and types. Mobile phones now have larger screens than ever, but they are still
    relatively small. However, the number of pixels they contain is huge, creating
    a smooth look when held close to our faces. TVs, on the other hand, are very large,
    but the resolution is low due to the distance they are usually observed at. Even
    desktop screens have changed—the average size has increased and the screens have
    become wider, but the biggest change is that pixel density has gone up astronomically,
    with high-end displays containing ten times as many pixels as those of cheap devices.
    Handling this variety of output devices requires resolution-independent rendering,
    which is a big shift from the origins of graphical toolkits, where pixels could
    be assumed to be a certain size. To work around these issues, some toolkits simply
    use a multiplier for each output pixel. This approach manages to avoid an app
    becoming too difficult to read by using more pixels to display the same original
    resolution—but will require application updates to avoid badly pixelated rendering.
  prefs: []
  type: TYPE_NORMAL
- en: With the ever-increasing complexity of smart phones, consumers now expect that
    applications will adapt to their location, preferences, and behaviors. Much of
    this is possible due to the inclusion of many sensors, each of which have platform-specific
    APIs. An easy-to-use abstraction over the platform specifics is part of a good
    modern toolkit and significantly reduces the time spent by developers in preparing
    their software for the different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism and web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computing technology has come a long way in 50 years, not just in machine rooms
    and server racks, but on our desks and in our pockets. It is often said that we
    now have more power in our pockets than we had when man first landed on the moon.
    In fact, it’s more like 10,000 times the amount of power if you factor in a smart
    phone’s capabilities. To be able to accommodate this much power requires modern
    programming techniques—it’s not as simple as running the same code much faster.
    One major factor is that a modern operating system and any application on it will
    be able to calculate many things at the same time – but to do so effectively requires
    code that understands **parallel processing.** To make this adjustment is straightforward;
    code must be split into components that are independent enough to be able to run
    simultaneously. Introducing this ability can mean that memory is no longer controlled
    by a single part of code and so unexpected outcomes can occur (often called **race
    conditions**). Working around these complications with older tools can be very
    complicated and error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all GUI toolkits to date (including the latest releases by Apple and
    Microsoft) require that changes to the user interface or output graphics are handled
    by the *main thread*, a single portion of the capability of any application. This
    constraint requires careful coordination from an application developer and potentially
    limits the computing power available for the graphical components of an app.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses for background threads in an application will be
    communicating with remote resources. Web services or network resources are not
    accessible as fast as data on the local computer or bundled with an application,
    and so an app must manage user input and graphical updates while handling these
    slower requests. The core of most graphical toolkits and APIs is focused solely
    on the widgets—the presentation of the interface to the user. The design of many
    toolkits pre-dates cloud services and web-based APIs as we know them today. Powerful
    web services and standardized protocols for communication vastly improve the speed
    of development for web-based applications. Conversely, they can make it harder
    for native graphical applications on the desktop, where support is lacking from
    the core language or standard libraries. Inclusion of these features in modern
    programming languages is changing this and a modern graphical toolkit should provide
    similar benefits to developers.
  prefs: []
  type: TYPE_NORMAL
- en: Building for any device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While considering the hardware characteristics and connected nature of devices,
    we need to consider how software is deployed to them. Each operating system expects
    applications to be packaged and installed in a different format and often have
    different ways of discovering and downloading software as well. Although the C
    and C++ languages do work across most platforms, it can be very complicated to
    compile for a computer that is different to the one that you are working on. This
    restriction has not been a problem for desktop and laptop apps, as companies simply
    buy the different types of computers to run the compilation and packaging. It
    is, however, more complex for mobile and embedded devices, where they cannot compile
    their own apps from the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages designed more recently include the ability to build for
    different systems from a single development computer. Although this is something
    that interpreted languages had done forever, it is now possible for your compiled
    applications (faster with no need for pre-installed runtime environments) to be
    **cross-compiled** for any device. In addition to this capability, the GUI toolkit
    must support preparation of different formats of application bundles that can
    package up the binary assets, resources, and other metadata for distribution.
    It is possible to perform these tasks manually, but a well-thought-out developer
    experience should ensure that this is practically automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, many distribution platforms such as app stores and software marketplaces
    require a certification process that ensures authenticity of the apps it will
    make available. The cryptographic steps required to set this up are often lengthy
    and can be a hurdle to new app developers looking to make their work available.
    Rethinking a toolkit and the utilities it provides would allow this problem to
    be addressed alongside the compilation and packaging challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices have moved on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A final factor that can be observed when evaluating a toolkit for developing
    your app might be how up to date its best practices are. It has long been thought
    that automated testing of graphical applications is next to impossible, an opinion
    that is in no small way due to the fact that **Test-Driven Development** (**TDD**)
    and **Continuous Integration** (**CI**) were not common practices when the legacy
    toolkits, or the programming languages they use, were designed. A developer looking
    to learn, or one that is in a team of professional software engineers, would probably
    expect such practices to be supported or even encouraged in modern tools.
  prefs: []
  type: TYPE_NORMAL
- en: The C language (and many derivatives thereof) have often been criticized for
    the weak handling of string types. In fact, it is this very deficiency that has
    led to many highly visible software vulnerabilities and public data breaches.
    Although not all older programming languages suffer from this issue, they almost
    all have the restriction of only supporting simple strings using the *Latin alphabet*
    (although some have add-on libraries that attempt to work around this). With such
    a restriction, it is difficult to write an application that will easily adapt
    to the variety of commonplace languages that software should support in this international
    world. The **Unicode** standard is the universal approach to handling internationalized
    text, but this *multi-byte* (using more than a single byte to represent a letter
    or symbol) format can cause problems when introduced to software that was not
    designed to understand it. Users and developers alike now expect these complex
    encodings to be supported, and so the drawbacks of older toolkits continue to
    grow.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are a number of challenges in developing, or working with,
    a graphical toolkit that could be overcome if we start from scratch. And so, the
    Fyne toolkit decided to do just that, but to do so required a choice as to which
    programming language to use. As we know, Go was picked for Fyne—in the next section,
    we look at why it was seen to be a good fit to overcome the challenges faced.
  prefs: []
  type: TYPE_NORMAL
- en: How Go is a great fit for this challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw that there are many reasons why graphical toolkits
    are rooted in dated foundations and that even the languages they are built with
    could be limiting their chances of adapting. A number of manufacturers are recognizing
    this problem and reaching to new languages to find solutions or even avoid the
    challenges of the past completely. Apple is moving all development to the Swift
    language, although Apple-supported software is designed to run on their devices
    only. Other companies, such as Facebook, are finding ways to adapt more modern
    web-based tools to create native apps for phones and desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Neither the approach of a platform-specific technology nor languages derived
    from the interpreted internet technologies are going to be able to truly create
    a delightful development experience. We are looking for a development platform
    that results in performant and robust, cross-platform applications—the panacea
    of modern application development. I, the author of this book and indeed the Fyne
    project, believe that Go may be the language to underpin such a revolution in
    building cross-platform graphical applications.
  prefs: []
  type: TYPE_NORMAL
- en: To quote the Go frequently asked questions on this topic, refer to [https://golang.org/doc/faq](https://golang.org/doc/faq).
  prefs: []
  type: TYPE_NORMAL
- en: Go addressed these issues by attempting to combine the ease of programming of
    an interpreted, dynamically typed language with the efficiency and safety of a
    statically typed, compiled language. It also aimed to be modern, with support
    for networked and multicore computing.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the various reasons why the Go programming
    language is well placed to support a new era of GUI programming.
  prefs: []
  type: TYPE_NORMAL
- en: Simple cross-platform code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go is a language that (like C, C++, Swift, and many others) compiles to a native
    binary on every platform it supports. This is important for graphical applications
    as it’s the best way to create the most responsive and smoothest user interfaces
    on mainstream computer hardware. What stands out about Go compared to other languages
    that are popular with GUI developers is that it manages to support a long list
    of operating systems while compiling, without any alterations or special adaptation,
    to native code on every platform. This means that a Go-based project can be built
    on any computer for any other computer, using the standard tools, with no need
    for complex build configurations or extra developer packages to be installed.
    At the time of writing, the platforms that Go runs on includes Windows, macOS,
    Linux, Solaris, and other popular Unix-based operating systems (which is essentially
    all desktop personal computers) along with iOS, Android, and other Linux-based
    mobile devices (and even tiny embedded computers via TinyGo).
  prefs: []
  type: TYPE_NORMAL
- en: Go is a *typed* language, which means that every variable, constant, function
    parameter, and return type must have a single, defined type—leading to robust
    code by default. Unlike some older typed languages, Go is often able to infer
    a type, which helps avoid the duplication of information in the source code (in
    fact, one of Go’s design principles is to avoid duplication). These features help
    to create a language that’s fast and fun to develop with, while creating software
    that is as solid as the languages traditionally used for native graphical apps.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being easy to learn and simple to read, the Go language comes
    with well communicated standards for code style, documentation, and testing. Standardization
    such as this makes it easy for developers to understand different projects and
    reduces the time required to integrate libraries and learn new APIs. As well as
    documenting these standards, the Go development tools include utilities that can
    check whether your code meets these guidelines. In many cases, they can even update
    your source code files to comply automatically. Quite naturally, the development
    environments that support Go also encourage following the guidelines, making it
    even easier to reduce the learning curve for anyone joining your project.
  prefs: []
  type: TYPE_NORMAL
- en: As well as standard formats for source code and documentation for all APIs,
    the Go language and community support and encourage unit testing in apps and libraries.
    The compiler has built-in test functionality normally associated with *dynamic*
    languages that need this sort of check to ensure correctness. The inclusion of
    effective testing alongside an already robust language provides validation of
    code behavior and makes it easier for code to be changed by individuals other
    than those that created it. In fact, in a collection of popular Go libraries,
    one of the requirements for being listed is that your code meets an 80% unit test
    code coverage metric (see [https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go)
    and their contribution guidelines).
  prefs: []
  type: TYPE_NORMAL
- en: Standard library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard library of a programming language is the set of APIs and features
    that are provided by the language runtime. C, for example, has a very small standard
    library—as a low-level language designed for many different types of devices,
    the number of features that it can support for every operating system is limited.
    Java, on the other hand, historically known for being heavy on memory and start
    up time, provides a massive standard library—including the Swing GUI described
    in [*Chapter 1*](B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015), *A Brief History
    of GUI Toolkits and Cross-Platform Development*. This is a trade-off that all
    languages need to make when deciding in favor of smaller memory or lots of built-in
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the Go language makes a clever balance, allowing it to comprise
    a large library of APIs that fully support every one of its target operating systems.
    To do this, it makes use of **build tags** that allow inclusion of only the code
    needed for the current (or target) operating system. This is a huge advantage
    for developers who want to write an efficient application for multiple operating
    systems without maintaining slightly different versions for each platform, or
    suffering slow load times or large memory requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library included with Go includes powerful features across many
    areas, including cryptography, image manipulation, text handling (including Unicode),
    networking, concurrency, and web service integration (we will cover this in the
    sections to come). You can read the full documentation at [https://golang.org/pkg/#stdlib](https://golang.org/pkg/#stdlib).
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As illustrated in the *Parallelism and web services* section earlier, a modern
    programming language needs to handle concurrency. Unfortunately, working with
    the APIs to manage multithreading can add complexity and make code harder to read.
    The designers of Go decided that concurrency should be incorporated from the beginning,
    making it easy to manage many threads of execution while still avoiding the difficulty
    of shared memory management. GUI toolkits built on languages without this built-in
    awareness of concurrency have propagated the idea that graphical routines must
    happen on a particular thread. By starting from scratch with a better suited language,
    we can avoid such constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Go does not expose traditional threads, but instead introduces the concept of
    **goroutines**—these are akin to lightweight threads, but that are enhanced to
    support several thousand at the same time. It is common for applications to communicate
    between background processes by sharing memory, but this introduces issues known
    as *race conditions*, requiring more code to manage access. To avoid this, Go
    provides **channels**—a mechanism for communicating between threads of execution
    without causing the same problems. With this model, the language manages the safe
    transfer of information from one goroutine to another, keeping multithread code
    neat and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a modern programming language, Go comes with extensive support for HTTP clients,
    servers, and standard encoding handlers, including JSON and XML. For GUI developers
    coming from a background in C programming, this is a significant improvement—web
    services, and indeed remote resources, were not commonplace when the language
    or its toolkits were created.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to language-level support for text encoding used in web communications,
    it is possible to load data structures directly from an HTTP request. Such convenience
    may be standard for web-based languages such as JavaScript and PHP, but to function
    in a strictly typed language without using third-party code is a rare bonus.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these features that make Go an excellent language for building complex
    applications that can be described at a high level and thoroughly tested, it is
    also possible to perform platform-specific requests to the operating system if
    required.
  prefs: []
  type: TYPE_NORMAL
- en: High level with system access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even with a fully featured programming language, it can be occasionally necessary
    to access low-level components or platform-specific APIs. Whether it is to send
    a notification, read data from a custom device, or simply to call a function specific
    to the current operating system, it will occasionally be necessary to access functionality
    that is not included in a programming language or its standard library. To solve
    this challenge, Go provides three avenues to handle the platform-specific aspects
    of a program—syscall, CGo, and build tags.
  prefs: []
  type: TYPE_NORMAL
- en: Build tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go, it is possible to include part of your code for specific operating systems
    at a per-file level based on some conditional parameters called **build tags**.
    This can be helpful to adjust behavior when your app will run on certain systems,
    but is more beneficial in controlling the inclusion of the platform-specific use
    of syscall or CGo code illustrated in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Even if your app is not making specific use of operating system-specific calls,
    it can be helpful to make use of the conditional compilation. In simple cases,
    Go code can check what system an app is running on to execute slightly different
    code (by checking the value of `os.GOOS`, for example, a function could return
    different values). However, for more behavioral changes, it can be useful to put
    the platform-specific code into separate files that are named in a certain convention
    (for example, `*_windows.go` will be included when building for Microsoft Windows)
    or through the use of the special comment at the top of a file (such as `// +build
    linux,darwin` including the file when Linux or macOS is the target platform).
  prefs: []
  type: TYPE_NORMAL
- en: Syscall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the packages provided by Go’s standard library is `os` and `net`, to
    provide higher-level abstractions, so double-check that the functionality you
    desire is not provided by another package before using syscall.
  prefs: []
  type: TYPE_NORMAL
- en: A typical call into this package might be to request details of a Windows registry
    key, or to load a DLL (a system library on a Windows computer) to access functionality
    not provided by Go. On a Linux computer, you may use this functionality to read
    or write to specific memory areas such as connected devices, where permitted.
    A system call is a very complicated procedure and, where possible, it will normally
    be easier to call a C function instead – we see how to do that with CGo next.
  prefs: []
  type: TYPE_NORMAL
- en: CGo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your application, or one of the libraries that you rely upon, was written
    with the C language (or one of its derivatives, such as C++ or Objective-C) for
    specific reasons and you’re not able to move it to Go, then CGo is an invaluable
    feature. Using this functionality, it is possible to include C code directly,
    or call out to other C-based functionality. It is important to use this carefully—there
    are some performance impacts in making the jump from one language to another—but
    more significantly you need to remember about memory management and threading
    in a way that Go would normally manage for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following source code shows C and Go code in the same file where we convert
    a Go string into a C string (or, more strictly, a `[]byte`) and pass it into a
    C function. As you can see, we also need to free the memory we passed into the
    C code once it is no longer required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be run just like any other Go program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, you can see that the C code is included in a comment above
    the `import "C"` line. This code could be in a separate `.c` file or even within
    a library on the build computer (and the Go compiler will use `pkgconfig` to find
    the required headers). When used in combination with conditional building such
    as build tags in the previous code, you can see that it is possible to access
    platform-specific functionality or legacy code where required.
  prefs: []
  type: TYPE_NORMAL
- en: This section considered the Go language and how its design is well suited to
    building a modern GUI toolkit. Next, we will look at how Material Design provides
    a great aesthetic for Fyne applications.
  prefs: []
  type: TYPE_NORMAL
- en: Looking good with Material Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key part of any GUI toolkit that can impact the developer’s selection and
    also the user appeal of the applications built is the overall design language.
    This choice of aesthetic can be seen in the colors, fonts, layouts, and even icon
    design. Some of these choices are obvious and others more subtle, but, when combined,
    result in a recognizable application look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: New cross-platform toolkits commonly create their own design, such as Java’s
    Swing or the GTK+ and Qt toolkits. These are often designed to look contemporary
    with the software of the time—you can recognize a 1990s desktop application design
    in those toolkits. In the current landscape, usability and design principles of
    mobile apps are being adapted and deployed to other areas, bringing a new age
    of software design to traditional applications. Because of its work in this space,
    the Material Design project makes a good match for application design aiming at
    universal cross-platform appeal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official website for Material Design (`https://material.io`) describes
    material as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Material is an adaptable system of guidelines, components, and tools that support
    the best practices of user interface design. Backed by open source code, Material
    streamlines collaboration between designers and developers, and helps teams quickly
    build beautiful products.
  prefs: []
  type: TYPE_NORMAL
- en: Google first published the Material Design guidelines in 2014 based on their
    earlier work on a new design language for their websites. It has since been applied
    to their different web properties and has also become the visual design for the
    Android operating system. This adaptation meant that the component designs have
    identified areas that work across all platforms and also where slight adaptation
    may be required for desktop computers, reducing the work required by Fyne or other
    cross-platform toolkits that use its design language.
  prefs: []
  type: TYPE_NORMAL
- en: The layout and functionality of the standard components varies by platform,
    and implementation though clear recommendations is documented at the main website,
    [https://material.io](https://material.io). What can be more universally recognized
    is the color palette and iconography used in material-based apps.
  prefs: []
  type: TYPE_NORMAL
- en: Color palette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Material Design colors are oriented around a standard color palette. A primary
    color is used to raise the importance of certain elements, such as default buttons
    or focused input. A complementary secondary color is (optionally) reserved for
    accenting important items, such as floating buttons or selected text. The Material
    Design project provides a baseline color theme that can be used with any app.
    Developers may also choose their own primary and secondary colors to match their
    brand identity or preferred aesthetic. Here is the baseline color palette:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The material design ”baseline” color palette'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16820_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The material design ''baseline'' color palette
  prefs: []
  type: TYPE_NORMAL
- en: The striking colors of a material theme help an application to have a clean
    design while conveying meaning and importance. Similarly, the material design
    offers a set of clean, crisp icons that should be used where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Standard icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The material icons are designed to be *delightful and beautifully crafted*
    and cover the common interactions and standard items for most modern software.
    They cover topics such as standard hardware, file types, content operations, and
    user actions. As well as the standard icon set, there are repositories of community
    submitted add-ons that can be useful for applications that employ fewer standard
    operations. In the following screenshot, we can see some material design icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – A small selection of material design icons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16820_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – A small selection of material design icons
  prefs: []
  type: TYPE_NORMAL
- en: By following the material design specification, any apps built using the Fyne
    toolkit will be clean and easy to use from the outset, while supporting an element
    of brand identity and customization.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how Fyne-based apps look to the end user, but for a developer,
    the API design is just as important. Let’s look at how the team aim to keep that
    just as clean and well crafted.
  prefs: []
  type: TYPE_NORMAL
- en: Designing APIs for simplicity and maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A delightful user experience is an important ambition for any application toolkit,
    but Fyne aims to make the experience of development a pleasure as well. To do
    this, the API must be planned carefully to be simple and easy to learn, but also
    extensible to support more complex applications. The project’s modular approach
    aims to support this while also being testable every step of the way.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **API** (or **Application Programming Interface**) is typically defined as
    a set of functions and procedures that controls access to features and data. At
    a high level, however, the Fyne toolkit aims to deliver a *semantic API*, a set
    of functions that defines intent rather than features or functionality. By taking
    this approach, the toolkit is able to separate meaning from presentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can consider a simple button—when there are many on a screen,
    you may wish for one to stand out against the other as more important. In an API
    that is focused on presentation or styles, you might set the button color; with
    the Flutter GUI toolkit, this would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In comparison, an API that takes a semantic approach would allow developers
    to indicate the expected difference through a button type or intent field, as
    the following Fyne snippet does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Following this approach allows for a consistent API that describes the expected
    outcomes instead of features that could hint at those outcomes. It also allows
    the current theme to ensure a consistent visual style and avoids developer-defined
    code creating unreadable or unattractive graphical choices.
  prefs: []
  type: TYPE_NORMAL
- en: Modular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building a robust toolkit designed to work seamlessly across many different
    operating systems and computers, it is important to take a modular approach. Doing
    so ensures that no element of the library will be able to make false assumptions
    about other areas of the code. To accidentally expose all the inner details of
    a key area, such as a graphics driver, might restrict a widget to function correctly
    on a single operating system or in a particular graphics mode. This technique
    is known in software engineering as **Separation of Concerns**.
  prefs: []
  type: TYPE_NORMAL
- en: In the Go language, modules are known as **packages** and they are structured
    hierarchically under the project root. To allow different parts of the system
    to communicate, a project typically defines a collection of **interface** types
    that describe the functionality, and dependencies that some code may choose to
    conform to. By loading code that implements these interfaces, an application or
    library can compose separate elements of code to create the complete solution.
    Each area is only aware of the declared capability that each interface publicizes
    and can hide all of the inner details. This allows complex software to be built
    and tested in smaller pieces, which is far easier to test and even to debug if
    something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In Fyne, the use of packages can be seen in many areas, with the most notable
    being implementations of the `Driver` and `Widget` interface definitions. The
    use of drivers in the Fyne toolkit makes it possible for applications to run on
    many different types of computers without needing to know, or accidentally taking
    advantage of, specific details of a single device. When an application starts,
    the correct driver will be loaded to handle specific details of running on the
    current computer. As you will see in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*, the various widgets inside Fyne (and indeed custom
    ones that can be added by app developers) all implement the `Widget` interface.
    The behavior that all widgets must implement provides information to the driver
    and graphics code about how it should appear, meaning that the graphics code does
    not need to know any inner details of a widget to be able to draw it in an application
    window. This makes it possible for widget developers to avoid impacting graphics
    code, and indeed for other developers to add custom widgets outside the toolkit
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One other benefit of a modular approach is that code can be executed without
    launching in a standard application or showing any windows. This may not be a
    common requirement for user-facing code, but it is very important to support the
    efficient testing of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automated testing of graphical user interface code has long been considered
    one of the hardest steps of a full test suite, and this becomes even more difficult
    if you add smart phones or mobile devices to your supported platforms. Each operating
    system may require a different methodology and probably also specific code to
    be written and maintained in order to run the test suite. As mentioned in the
    previous section, the modular approach taken by the Fyne toolkit promises easier
    testing by not requiring applications to be displayed for the test scripts to
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of its modular design, the drawing components of a Fyne-based application
    are a minor detail. The main logic and behavior of widgets are defined completely
    separately to the graphical output. This approach allows all elements to be tested
    through automated interactions faster and more reliably than alternative tools
    that load applications and then tap buttons using test runners that control the
    mouse and keyboard (or touchscreen) hardware. The following code snippet shows
    how a `Button` and `Entry` widget could be tested in a simple unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these two simple unit tests (using the standard Go test structure)
    are able to test that the `Button` and `Entry` widgets behave as expected when
    standard user interactions occur. The test helpers `Tap` and `Type` are provided
    to perform these actions, along with various other utilities in the `test` package.
    By building up a test suite in this manner, you can execute thousands of GUI tests
    per second, without ever having to load a window or connect to a specific device.
    In fact, this very functionality supports true TDD for graphical applications.
    This approach means that application code can be designed and understood before
    it is implemented, leading to more robust software and better decoupling of modules,
    thereby allowing more developers to work on a project concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fyne toolkit will ensure that all elements will be presented correctly
    on any device that your app will be distributed to. Its drivers and widgets all
    undergo the same testing rigor described earlier in this section. Sometimes, however,
    it is necessary to test the actual rendered output of a widget or screen. In this
    situation, the `test` package has more utilities that can aid your development.
    Although not visible on your screen, the Fyne test code will calculate how the
    output would look and can save this to an image through a `Capture()` function.
    The test helper `AssertImageMatches` is then able to compare this to a specific
    output either saved earlier or created by a designer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code sample does include some details about `Window` and `Canvas` that
    we will cover in [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*, but you can see the overall simplicity. The code
    defines a widget (in this case a `Button` widget), and then adds it to a test
    window that is then captured and compared to a pre-existing image file. The test
    window is not shown on screen or even communicated to the operating system—it
    is loaded purely in memory to simulate the drawing process.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how good modularity and testing can result in more robust applications,
    but this has described the toolkit design—is it possible for developers to extend
    the functionality for their own purposes?
  prefs: []
  type: TYPE_NORMAL
- en: Extensible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core widgets of the Fyne toolkit are designed to be robust, easy to use,
    and well tested, but a toolkit cannot include every possible type of widget. For
    this reason, a toolkit also needs to be extensible, supporting the inclusion of
    widgets that were not defined by the core project—either as add-on libraries or
    by allowing applications to add their own custom user interface elements.
  prefs: []
  type: TYPE_NORMAL
- en: The Fyne project allows widgets to be included in two different ways—developers
    can extend existing widgets (keeping the main rendering consistent, but adding
    new functionality) or by adding their own widgets. As described in the *Modular*
    section earlier, any code that implements the `Widget` interface will be interpreted
    as an interface component and can be used throughout any Fyne application. Later
    in this book, we will also see how existing widgets can be extended to add new
    functionality or tweak behavior to suit a particular application.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the interface-based design of the modular code base, there are many other
    ways in which a Fyne application can be extended. By implementing the `Layout`
    interface, an app can define its component position and sizing, or, using the
    URI interface, it could connect to different types of data resources (for more
    information, see [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the design of a toolkit and its API is just as important as
    the functionality it contains. To complete this chapter, let’s review the overall
    vision of the Fyne project.
  prefs: []
  type: TYPE_NORMAL
- en: A vision of the future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fyne project was created in response to growing criticism of the complexity
    in existing graphical toolkits and application APIs and their inability to adapt
    to modern devices and best practices. It was designed with the aim of being easy
    to use, and the Go language was chosen for its powerful simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vision statement on the Fyne project wiki ([https://github.com/fyne-io/fyne/wiki/Vision](https://github.com/fyne-io/fyne/wiki/Vision))
    states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fyne’s APIs aim to be the best for developing beautiful, usable, and lightweight
    applications for desktop and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: With more device types and platform-specific toolkits than we have seen in recent
    times, it is more difficult, and more expensive than ever, to deliver a great
    native app experience across all platforms. The Fyne toolkit is positioned as
    a solution to these challenges, while bringing the design and user experience
    learning from modern mobile apps to all devices.
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fyne aims to support the building of graphical applications that look consistent
    across all platforms, rather than adopting the look and feel of the operating
    system. Its APIs ensure that all apps provide a polished user experience and render
    a beautiful application GUI. Using the Material Design guidelines, a Fyne-based
    app will look familiar to Android users and match the aesthetic of the flat user
    interface in Windows 10\. For operating systems where the user interface is typically
    in a different style, users will still be delighted by the crisp visual design,
    bundled icons, and clean typography.
  prefs: []
  type: TYPE_NORMAL
- en: 'As many operating systems now offer a choice of light and dark modes, toolkits
    need to adapt appropriately to meet user expectations. All Fyne apps include a
    light and dark theme and, unless the developer overrides the setting, it will
    match the current system configuration. When end users change their system theme,
    any running Fyne apps will update to reflect configuration changes. This is shown
    in the following image, we see what the light and dark Fyne themes look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16820_02_03_-__Combine.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple to learn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as maintaining a clean, simple design, the Fyne team wants to ensure
    that everyone can learn to build graphical applications. To do this, the barrier
    to entry needs to be low—through simple installation and setup with documentation
    and tutorials readily available to support even the most inexperienced developer.
  prefs: []
  type: TYPE_NORMAL
- en: Developers who have not used the Go language before can start with the online
    tour ([https://tour.golang.org/](https://tour.golang.org/)), and from there move
    to the Fyne tour, which introduces developers to the concepts of GUI development
    and how to get started with the project ([https://tour.fyne.io/](https://tour.fyne.io/)).
    Lots more documentation is available at the main developer website, containing
    tips on getting started, code tutorials, and a full API reference ([https://developer.fyne.io/](https://developer.fyne.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: Platform-agnostic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cross-platform toolkits have various levels of complexity when building for
    different platforms. Some require different build processes and others will load
    different user interfaces, depending on the type of device. Fyne aims to be easier
    to use across these disparate targets and aims for **platform-agnostic**, meaning
    that the code doesn’t need to know anything about the device it is running on.
  prefs: []
  type: TYPE_NORMAL
- en: For many start-ups, the term platform agnostic represents a kind of unattainable
    utopia in the world of mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: This quote is from [http://alleywatch.com.](http://alleywatch.com.)
  prefs: []
  type: TYPE_NORMAL
- en: The code of a Fyne-based app does not need to adapt to system specifics and
    can compile for any devices using the same set of tools. As we will see later
    in the book, it is sometimes necessary to adjust for a specific operating system
    or device. In these situations, there are Go and Fyne APIs available to help.
    For many applications, it will be possible to avoid any customization per-system
    and the only element of the process that varies will be the application distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution to all platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your app is ready for release, it needs to be packaged and uploaded to
    a central place where users can find it. Unfortunately, every operating system
    uses different packaging formats, and every vendor has a different store or marketplace
    for apps. The `fyne` command-line tool that we will use many times throughout
    this book is able to create application bundles in all of the required formats.
    With the app bundled, it can be installed locally, shared with friends, or uploaded
    to a website for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Most systems are now moving to an app store or marketplace model where apps
    are available in a manufacturer provided location with screenshots, free advertising,
    and a managed installation. One of the challenges here is that every store is
    different and the process of certifying and uploading apps is different for each
    platform. The Fyne tool helps with the release process as well—streamlining as
    much as possible and ensuring a consistent developer experience for all stores.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how designing a new graphical toolkit could overcome
    many of the challenges still faced by existing approaches. We explored the background
    and vision for Fyne, how it aims to solve these difficulties, and how it supports
    creating beautiful and performant apps across all popular desktop and mobile devices.
    We introduced Material Design and saw how it brings modern usability principles
    and design learnings to desktop and beyond. By using the `fyne` build tools, we
    saw that an app can be built and distributed for any devices or app stores without
    any platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the fundamentals of a Fyne application
    and see how its drawing capabilities allow us to build a simple game.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about some of the topics introduced in this chapter, you can
    visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test-driven development: [https://www.agilealliance.org/glossary/tdd/](https://www.agilealliance.org/glossary/tdd/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Go programming language: [https://golang.org/](https://golang.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C bindings from Go: [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Material Design system: [https://material.io](https://material.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fyne toolkit developer documentation: [https://developer.fyne.io/](https://developer.fyne.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
