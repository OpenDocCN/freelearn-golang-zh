<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-65"><em class="italic"><a id="_idTextAnchor066"/>Chapter 3</em>: Window, Canvas, and Drawing</h1>
			<p>We have explored the basics of graphical application development and seen how starting with a new design in a modern language can lead to easier development. From this point on, we will be looking in more detail at how the Fyne toolkit aims to provide an easy-to-use API for building cross-platform applications for all developers.</p>
			<p>In this chapter, we will investigate the structure of a Fyne application, how it draws objects, and how they can be scaled and manipulated—as well as animated—in a container. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>How Fyne applications are structured and how to start making your first app</li>
				<li>Exploring the canvas package and the types of objects that can be drawn</li>
				<li>How scalable elements create a clean user interface</li>
				<li>Working with bitmaps and pixel rendering</li>
				<li>Animation of elements and properties</li>
			</ul>
			<p>By the end of this chapter, you will know how these features combine to create a graphical application, which will be demonstrated with a simple game.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/>Technical requirements</h1>
			<p>In this chapter, we will be writing our first Fyne code, including building a complete application. To do this, you will need to have the <strong class="bold">Go</strong> compiler installed, as well as a code editor application. You can download Go from the home page at <a href="https://golang.org/dl/">https://golang.org/dl/</a>. The choice of code editor is normally a matter of user preference, but Microsoft's <em class="italic">Visual Studio Code</em> and JetBrain's <em class="italic">GoLand</em> applications are both highly recommended.</p>
			<p>As Fyne uses some operating system APIs internally, you will also need to have a <strong class="bold">C</strong> compiler installed. Developers on Linux will probably already have one; macOS users can simply install <em class="italic">Xcode</em> from the Mac App Store. Windows-based developers will need to install a compiler, such as <em class="italic">MSYS2</em>, <em class="italic">TDM-GCC</em>, or <em class="italic">Cygwin</em>—more details can be found in <a href="B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253"><em class="italic">Appendix A</em></a><em class="italic"> – Developer Tool Installation</em>.</p>
			<p>The full source code for this chapter can be found in the book's GitHub repository at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03</a>.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Anatomy of a Fyne application</h1>
			<p>As we saw in <a href="B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">The Future According to Fyne</em>, the toolkit took the opportunity to start from<a id="_idIndexMarker106"/> scratch, throwing away the old and sometimes confusing constraints of previous toolkits. As a result, the APIs need to define everything involved in building a graphical application. In this section, we will explore the main concepts in running a Fyne-based application and producing visible components on screen, starting with the application itself.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Application</h2>
			<p>The application, defined<a id="_idIndexMarker107"/> in the <strong class="source-inline">fyne.App</strong> interface, models the capabilities of a Fyne-based application. Each app using Fyne will typically create and run a single <strong class="source-inline">fyne.App</strong> instance from within their <strong class="source-inline">main()</strong> function. Because of the way that graphical applications work, they must be started from the main function and not through a goroutine or other background thread.</p>
			<p>To create an app instance, we make use of the <strong class="source-inline">app</strong> package within Fyne, which can be imported using <strong class="source-inline">fyne.io/fyne/app</strong>. This package contains all of the logic and driver setup code that allows an app to understand the platform it is running on and configure itself appropriately. The function that we call is named <strong class="source-inline">New()</strong> and it will return the app instance that we will use throughout our code. To run the application, we would then call <strong class="source-inline">Run()</strong> and the application will start.</p>
			<p>With this knowledge, we could run our first Fyne app; however, it would be difficult to know if it was working without asking it to display something first! And so, we shall now learn how to display a window before running the first example.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Window</h2>
			<p>A <strong class="bold">window</strong> defines <a id="_idIndexMarker108"/>the area on the screen that your application controls. In a desktop environment, this will typically be shown inside a window border that matches the rest of the applications installed. You will normally be able to move and resize the window and<a id="_idIndexMarker109"/> close it when you are done.</p>
			<p>On mobile and other devices, this concept can be a little less well defined. For example, on Android and iOS smart phones, the application window will take up the whole screen and will not show window borders. To switch applications, you would use a gesture defined by the operating system or press a standard button, and other applications will appear, allowing you to move around. In addition to this, tablet computers—iPadOS, Android, or Windows, for example—will allow applications to be displayed in a portion of the screen, probably separated by a divider that allows the user to change how much space is used.</p>
			<p>In all of these different presentation modes the content that is displayed is still modeled by the <strong class="source-inline">fyne.Window</strong> interface. </p>
			<p>To show content on the screen, we will need to create a new window and show it. Once a window is defined, we can run an application to see the results. Let's work through the code for our first application!</p>
			<ol>
				<li>We open a new file, <strong class="source-inline">main.go</strong>, and define it to be in the package <strong class="source-inline">main</strong>:<p class="source-code">package main</p></li>
				<li>We then need to add any imports—in this case, we are just using the <strong class="source-inline">app</strong> package, so the following will be sufficient:<p class="source-code">import "fyne.io/fyne/app"</p></li>
				<li>To define a runnable program, we create a <strong class="source-inline">main()</strong> method. Into this function, we will create a new application instance using the <strong class="source-inline">New()</strong> function we saw earlier:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Also, in this method, we call <strong class="source-inline">NewWindow(string)</strong> (defined on <strong class="source-inline">fyne.App</strong>), which allows us to create the window to display. We pass it a single string parameter that sets a title (which is used if the operating system shows titles in the window border or app switcher, for example). Place the following code where <strong class="source-inline">...</strong> appeared in the previous snippet:<p class="source-code">    w := a.NewWindow("Hello")</p></li>
				<li>Once we have created a window, we can show it using the <strong class="source-inline">Show()</strong> function. After showing the window, we also need to call the <strong class="source-inline">Run()</strong> function on the application. As it is common to do both at the same time, there is a helper function <strong class="source-inline">ShowAndRun()</strong>, which we can use when showing the first window in an application:<p class="source-code">    w.ShowAndRun()</p></li>
				<li>With this code in place, we <a id="_idIndexMarker110"/>can save the file and run its contents like any other Go application:<p class="source-code"><strong class="bold">Chapter03/window$ go run main.go</strong></p></li>
				<li>You should see a window appear on screen. Depending on your operating system, this may be a very small window, as we have not added any content. The following screenshot was taken on a macOS computer after resizing the empty window:</li>
			</ol>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_3.1_B16820.jpg" alt="Figure 3.1 – Our first window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Our first window</p>
			<p>As you can see from the window in <em class="italic">Figure 3.1</em>, there is no content to the window, as we did not set any. The background of the window is not just black (or random colors from old graphics memory)—how can this be? The reason is that the window contains a <strong class="source-inline">Canvas</strong>, which is what manages the content we draw.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>Canvas</h2>
			<p>The content of every <strong class="source-inline">fyne.Window</strong> is a <strong class="source-inline">fyne.Canvas</strong>. Although the way that the canvas works <a id="_idIndexMarker111"/>internally is dependent upon the current system and some complex code within Fyne's internal driver packages, it will look exactly the same to developers and our <a id="_idIndexMarker112"/>application's end users. This platform-independent rendering canvas is responsible for all of the draw operations that come together to create a graphical output and eventually complete application interfaces.</p>
			<p>Inside every canvas is at least one <strong class="source-inline">fyne.CanvasObject</strong>. These objects, as we will see in the <em class="italic">Understanding CanvasObject and the canvas package</em> section, define the types of operations that can be drawn to the canvas. To set the content of our window we can use <strong class="source-inline">Window.SetContent(fyne.CanvasObject)</strong>. This function passes the content down to the canvas, telling it to draw this object, and also resizes the window to be large enough to display it.</p>
			<p>Of course, this only sets the content to be a single element; we will normally want to include many, and this is what the <strong class="source-inline">Container</strong> type provides.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Container</h2>
			<p>The <strong class="source-inline">fyne.Container</strong> extends <a id="_idIndexMarker113"/>the simple <strong class="source-inline">fyne.CanvasObject</strong> type to include<a id="_idIndexMarker114"/> managing multiple child objects. A container is responsible for controlling the size and position of each element it contains. <em class="italic">Figure 3.2</em> shows how the <strong class="bold">Canvas</strong> contains one container that positions three <strong class="bold">CanvasObject</strong> elements in a stack on the left and an additional <strong class="bold">Container</strong> to the right. This second container is responsible for three further elements, which it lays out in a row:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_3.3_B16820.jpg" alt="Figure 3.2 – A Canvas with various Container and CanvasObject elements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – A Canvas with various Container and CanvasObject elements</p>
			<p>Containers typically delegate <a id="_idIndexMarker115"/>the work of positioning child objects to a <strong class="source-inline">fyne.Layout</strong>. These layout algorithms will be explored further in <a href="B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a><em class="italic">, Layout and File Handling</em>. In the current chapter, we will use containers without layouts—these are called <em class="italic">manual layouts</em> and are invoked using <strong class="source-inline">container.NewWithoutLayout(elements)</strong>, where<a id="_idIndexMarker116"/> the <strong class="source-inline">elements</strong> parameter is a list of <strong class="source-inline">fyne.CanvasObject</strong> types that the container will present. We will explore manual layouts further in the <em class="italic">Combining elements</em> section.</p>
			<p>Now that we have seen how the application is defined and how it handles the presentation of graphical elements, we should see what drawing capabilities Fyne supports, and how to use them.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/>Understanding CanvasObject and the canvas package</h1>
			<p>The <strong class="source-inline">CanvasObject</strong> definition<a id="_idIndexMarker117"/> is just a Go interface that describes an element that can be positioned, sized, and added to a Fyne canvas. The type does not contain any information about how to draw—this information is provided by <em class="italic">concrete types</em> within<a id="_idIndexMarker118"/> the <strong class="source-inline">canvas</strong> package. These types define well-understood graphical primitives, such as <strong class="source-inline">Text</strong> and <strong class="source-inline">Line</strong>.</p>
			<p>Before learning how to use these elements, we shall see how they look in the Fyne demo app.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>Canvas demo</h2>
			<p>Before we look at how to <a id="_idIndexMarker119"/>write code that will display shapes in our window, we should look at a demo of these features in action. Using the built-in Fyne demo application, we can see what the <strong class="source-inline">canvas</strong> package supports. If you have not already done so, you can install and run the demo application using the following commands:</p>
			<p class="source-code">$ go get fyne.io/fyne/cmd/fyne_demo</p>
			<p class="source-code">$ ~/go/bin/fyne_demo</p>
			<p>While running the demo, tap on the <strong class="bold">Canvas</strong> item on the left navigation panel. You should see the following screen:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_3.7_B16820.jpg" alt="Figure 3.3 - The fyne_demo application showing various canvas primitives&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 - The fyne_demo application showing various canvas primitives</p>
			<p>The window shown in <em class="italic">Figure 3.3</em> demonstrates some of the canvas types known to Fyne. Those drawn here are named in the following list in order (left to right, from the top row and then the bottom):</p>
			<ul>
				<li>Image</li>
				<li>Rectangle</li>
				<li>Line</li>
				<li>Circle</li>
				<li>Text</li>
				<li>Raster</li>
				<li>Linear Gradient</li>
				<li>Radial Gradient</li>
			</ul>
			<p>Each of these elements can be included in our application, as we will explore next.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Adding objects to our window</h2>
			<p>Each element <a id="_idIndexMarker120"/>in the previous demo figure, as well as any new items that <a id="_idIndexMarker121"/>are subsequently added to the <strong class="source-inline">canvas</strong> package, can be created directly using their <strong class="source-inline">NewXxx()</strong> constructor function. The object returned from this can then be passed directly to the window or a container of objects.</p>
			<p>To demonstrate this, let's add some text content to the empty window. After adding <strong class="source-inline">image/color</strong> and <strong class="source-inline">fyne.io/fyne/canvas</strong> to the previously used <strong class="source-inline">import</strong> statements, we can change the main function to the following:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    a := app.New()</p>
			<p class="source-code">    w := a.NewWindow("Hello")</p>
			<p class="source-code">    w.SetContent(canvas.NewText("This works!", </p>
			<p class="source-code">        color.Black))</p>
			<p class="source-code">    w.ShowAndRun()</p>
			<p class="source-code">}</p>
			<p>As you can see, this change adds just one line—the <strong class="source-inline">canvas.NewText</strong> that is passed to <strong class="source-inline">w.SetContent</strong>. The text constructor function takes two parameters, the text to display and the color to use. If you run this code, you will see that the window now contains the text <strong class="bold">This works!</strong>, and is sized just right for this to be displayed:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_3.9_B16820.jpg" alt="Figure 3.4 – Displaying text content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Displaying text content</p>
			<p>As you can see here, showing<a id="_idIndexMarker122"/> a canvas element is as simple as knowing which content <a id="_idIndexMarker123"/>you would like to display. Let's look at a slightly more complicated example using multiple canvas elements in a container.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Combining elements</h2>
			<p>To show how we can use a <a id="_idIndexMarker124"/>container to display multiple items and create a more appealing output, we shall replicate a road sign using a <strong class="source-inline">canvas.Circle</strong> and <strong class="source-inline">canvas.Rectangle</strong> element inside a <strong class="source-inline">fyne.Container</strong>. Let's see how to go about this:</p>
			<ol>
				<li value="1">Firstly, we will create a new function for this code, named <strong class="source-inline">makeSign()</strong>. It should return <strong class="source-inline">a fyne.CanvasObject</strong> (which all graphical elements implement). The rest of our code will go into this function:<p class="source-code">func makeSign() fyne.CanvasObject {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Then we will create the background for a sign using <strong class="source-inline">canvas.NewCircle()</strong>, saving a reference to it so that we can use it later. The color that we pass is bright red—<strong class="source-inline">255</strong> (the maximum) for red channel. Green and blue values are <strong class="source-inline">0</strong>, and the alpha channel (how opaque the color appears) is also set at maximum, so it is fully visible:<p class="source-code">    bg := canvas.NewCircle(color.NRGBA{255, 0, 0, 255})</p></li>
				<li>Then we add a white border to this circle. The <strong class="source-inline">StrokeWidth</strong> property controls how wide the border is (defaults to <strong class="source-inline">0</strong> or hidden) and we set <strong class="source-inline">StrokeColor</strong> to white for an outer circle of white:<p class="source-code">    bg.StrokeColor = color.White</p><p class="source-code">    bg.StrokeWidth = 5</p></li>
				<li>Next, we will draw the <a id="_idIndexMarker125"/>bar across the center; this is simply a white rectangle:<p class="source-code">    bar := canvas.NewRectangle(color.White)</p></li>
				<li>To combine these two elements, we define a container. It is important to pass the parameters with the circle (<strong class="source-inline">bg</strong>) first and rectangle (<strong class="source-inline">bar</strong>) second, as they will be drawn in this order:<p class="source-code">    c := container.New(bg, bar)</p></li>
				<li>Next, we must position these elements. We will specify that the sign is <strong class="source-inline">100</strong> x <strong class="source-inline">100</strong>. Because it has a border, we will inset it from the sides by <strong class="source-inline">10</strong> x <strong class="source-inline">10</strong> so that it is centered within a window sized 120 x 120:<p class="source-code">    bg.Resize(fyne.NewSize(100, 100))</p><p class="source-code">    bg.Move(fyne.NewPos(10, 10))</p></li>
				<li>To position the <strong class="source-inline">bar</strong>, we will make it <strong class="source-inline">80</strong> x <strong class="source-inline">20</strong>. To position it over the 60, 60 central spot, we move it to <strong class="source-inline">20</strong>, <strong class="source-inline">50</strong>:<p class="source-code">    bar.Resize(fyne.NewSize(80, 20))</p><p class="source-code">    bar.Move(fyne.NewPos(20, 50))</p><p>With this code in place, we end the function by returning the container we have made:</p><p class="source-code">    return c</p></li>
			</ol>
			<p>This completes the definition of our sign. To display it, we call the <strong class="source-inline">makeSign()</strong> function and pass it to <strong class="source-inline">SetContent()</strong>. We can also turn off the default padding on the window, as our content is not reaching the edge of our container. Because we are using a manual layout, we also need to resize the window to show the items we have positioned:</p>
			<p class="source-code">    w.SetContent(makeSign())</p>
			<p class="source-code">    w.SetPadded(false)</p>
			<p class="source-code">    w.Resize(fyne.NewSize(120, 120))</p>
			<p>With this code in place, you <a id="_idIndexMarker126"/>can run the application in the usual way, but this time we shall force the dark theme so that our white border stands out (we will look at themes in more detail in <a href="B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a>, <em class="italic">Widget Library and Themes</em>):</p>
			<p class="source-code">Chapter03/canvas$ FYNE_THEME=dark go run main.go</p>
			<p>You should see the following window with the sign crisp against a darker-colored background:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.5_B16820.jpg" alt="Figure 3.5 – Our road sign, created from a circle and rectangle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Our road sign, created from a circle and rectangle</p>
			<p class="callout-heading">Note: manual layouts do not automatically resize</p>
			<p class="callout">When using a manual layout, as explored in this example, it will not resize when the window changes size. This functionality is provided by using a layout algorithm, which we will explore in <a href="B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Layout and File Handling</em>.</p>
			<p>In this section, we explored the canvas elements and how to draw them. They created crisp, clean output, but we did not explore how that works. In the next section, we look at what scalable rendering is and how it creates such high-quality output.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>Scalable drawing primitives</h1>
			<p>As you probably realized from the<a id="_idIndexMarker127"/> previous example, all the items that we have rendered so far are vector graphics. This means that they are described by lines, curves, and high-level parameters instead of a collection of pixels. Because of this, these components are called <strong class="bold">scalable</strong> (like<a id="_idIndexMarker128"/> in <strong class="bold">scalable vector graphics</strong> (<strong class="bold">SVG</strong>) files), meaning that they can be drawn at any scale. The Fyne toolkit is a scalable toolkit, which means that a Fyne application can be drawn at any scale and render at a high quality.</p>
			<p>Let's look at the text component in more detail, for example. We define a simple text component as before:</p>
			<p class="source-code">w.SetContent(canvas.NewText("Text", color.Black))</p>
			<p>We can then place that line of code into the standard <strong class="source-inline">main()</strong> function that we wrote in the first section of this chapter, <em class="italic">Anatomy of a Fyne application</em>, and then run it. The output will be as expected—drawing text at the normal size—but if we override the preferred scale using <strong class="source-inline">FYNE_SCALE</strong>, we can see how the application would look if the user wanted much larger text:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.13_B16820.jpg" alt="Figure 3.6 – canvas.Text rendered with FYNE_SCALE=1 (left) and 3.5 (right)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – canvas.Text rendered with FYNE_SCALE=1 (left) and 3.5 (right)</p>
			<p>Scaling a Fyne application<a id="_idIndexMarker129"/> in this way will not just change the font size, but will scale up every element of the user interface. This includes all standard graphics, widgets, and layouts. The standard themes also provide a set of icons (which we will explore more in <a href="B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a>,<em class="italic"> Widget Library and Themes</em>), which are also scalable. We can see this by using a theme resource and the icon widget type:</p>
			<p class="source-code">w.SetContent(widget.NewIcon(theme.ContentCopyIcon()))</p>
			<p>By adding the preceding line to the same <strong class="source-inline">main</strong> function, we can see how icons will scale to match the text demonstrated in the previous figure:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.15_B16820.jpg" alt="Figure 3.7 – widget.Icon rendered with FYNE_SCALE=1 (left) and 3.5 (right)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – widget.Icon rendered with FYNE_SCALE=1 (left) and 3.5 (right)</p>
			<p>The size and position of elements will be scaled according to the canvas scale. We can now see how this coordinate system works.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>Coordinate system</h2>
			<p>As you saw in the <em class="italic">Combining elements</em> section earlier, it is sometimes necessary to position or resize elements within a user interface. Doing so for a scalable output can be a little complicated, as we are not measuring content using pixels. And so, Fyne uses a device-independent coordinate system<a id="_idIndexMarker130"/> that Android developers may be familiar with.</p>
			<p>A 1 x 1 size in Fyne (written as <strong class="source-inline">fyne.NewSize(1, 1)</strong>) may represent more than (or fewer than) 1 output pixel. If the scale was 3 (as it is for many modern smart phones), then the 1 x 1 square will likely use nine output pixels. As the toolkit is designed for scalable output, the result will not be a <em class="italic">pixelated </em>output, like it could be with older graphical toolkits that simply multiply the size of each pixel. The rendered output will continue to look crisp, as we saw in <em class="italic">Figure 3.6</em> and <em class="italic">Figure 3.7</em>.</p>
			<p>A fully scalable user interface has huge benefits when working with display devices of varying pixel densities, and it allows users to choose a preferred zoom level for all application components. However, sometimes we need to work with nonscalable elements, such as bitmap (pixel based) images, or our application may need to use every pixel available for high-definition graphical output. We will explore this in the next section.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/>Pixel output – rendering images</h1>
			<p>For the reasons outlined in<a id="_idIndexMarker131"/> the previous section, it is recommended that you use scalable graphics (normally SVG files) for icons and other image-based components of user interfaces. It will sometimes be<a id="_idIndexMarker132"/> necessary to work with bitmap graphics (those defined by a collection of pixels rather than graphical features). If you are loading and managing images, or if you want to display detailed graphical elements using every pixel available, then this section contains important information about how to proceed.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Images</h2>
			<p>Image content<a id="_idIndexMarker133"/> in Fyne defines graphical content that will normally stretch or shrink to the space that is allocated to it. Loading a bitmap image (which has dimensions that are defined by the number of pixels) into a scalable output may not provide the expected outcome. The rendered output of a size defined in pixels will vary depending on the scale of the output device or user preferences. For this reason, Fyne does not normally set a minimum size for images that are being loaded.</p>
			<p>Images can be loaded from files, resources, data streams, and more. Each file should have a unique name (or path), which makes it possible for performance improvements through caching. Loading an image from the filesystem should be done through the Fyne <strong class="source-inline">storage</strong> API to avoid any platform-specific code or assumptions (this is explored in detail in <a href="B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Layout and File Handling</em>). You can use <strong class="source-inline">storage.NewFileURI</strong> to get the reference to a file path if that is needed. For example, to load an image from a file path, you would call the following:</p>
			<p class="source-code">img := canvas.NewImageFromURI(storage.NewFileURI(path))</p>
			<p>To define how a loaded image should be displayed in your app, you can set the <strong class="source-inline">ImageFill</strong> field in your <strong class="source-inline">canvas.Image</strong> object. It will be one of the following values:</p>
			<ul>
				<li><strong class="source-inline">canvas.ImageFillStretch</strong>: The default value. This will adjust the image dimensions up or down to match the image <a id="_idIndexMarker134"/>object size, adjusting the <strong class="bold">aspect ratio</strong> (the ratio of width to height values), which can cause images to look squashed or stretched.</li>
				<li><strong class="source-inline">canvas.ImageFillContain</strong>: This fill option will retain the aspect ratio so that the image is not distorted and draws it as the largest size possible that can fit within the image size. This will usually leave a space on two of the edges so that the image is centered in the available space.</li>
				<li><strong class="source-inline">canvas.ImageFillOriginal</strong>: In original fill mode, the image will display using one output pixel for each pixel in the image. Although this seems desirable, it is important to note that it's visible size will vary based on the device because of the variation of pixel density. Using this value will also ensure that sufficient space will be reserved to draw the required number of pixels. If it is likely that the image will be larger than the space available, be sure to wrap it in a scroll container (discussed in <a href="B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a><em class="italic">, Widget Library and Themes</em>).</li>
			</ul>
			<p>As mentioned in the fill modes, the output size of an image cannot be known by looking at the image file, and so your application will probably need to specify how large the image should be. Normally, this will be controlled by a layout—images would be expanded according to the type of layout. Another way to do this is to call <strong class="source-inline">SetMinSize()</strong> to ensure that the image never gets smaller than a specified (pixel independent) value. If you have used <strong class="source-inline">ImageFillOriginal</strong>, then this step will have been completed automatically.</p>
			<p>If small images are <a id="_idIndexMarker135"/>used, but they occupy a large space, they may appear <em class="italic">pixelated</em>, depending on how far they have been scaled. It is recommended that you use images that contain sufficient pixels/detail so that they will be scaled down (shown smaller) when displayed instead of scaling them up; however, if you want the output to look pixelated (or retro), you can specify that a pixel-based scaling should be used to enhance this look:</p>
			<p class="source-code">Image.ScaleMode = canvas.ImageScalePixels</p>
			<p>Note that the pixelated output described here does not apply if the image file was <strong class="source-inline">.svg</strong>. When a scalable image file is loaded, it will always be redrawn to the size requested, ensuring a high-quality output each time.</p>
			<p>Images are not the only way to draw bitmap content; we can also include more dynamically created pixel content using the <strong class="source-inline">Raster</strong> type.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>Raster</h2>
			<p>In some cases, an application may wish to display content using every available pixel so that high detail can be displayed, such as when showing wave forms or a 3D render. In these situations, we use the <strong class="source-inline">Raster</strong> widget. This is designed to show pixel-based output that is calculated dynamically instead of being loaded from a file.</p>
			<p>A raster output<a id="_idIndexMarker136"/> will dynamically determine the content to display based on the number of pixels available in the space it occupies. Each time the space resizes, the widget will be asked to redraw itself. These requests for content are handled by generator functions. </p>
			<p>In this example, we will explore how to display a checkerboard pattern:</p>
			<ol>
				<li value="1">Firstly, we <a id="_idIndexMarker137"/>declare a generator function—this will take the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong> parameter of the pixel requested and the width and height parameter of the overall area (in pixels), and return a color value, as shown here:<p class="source-code">func generate(x, y, w, h int) color.Color {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>We then want to determine which color our pixel is. The following calculation will return white if the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong> coordinate is in a 20 x 20 pixel square at the top left or any odd-numbered square along the row, and then the opposite squares on the following row. For these pixels, we specify a white color:<p class="source-code">    if (x/20)%2 == (y/20)%2 {</p><p class="source-code">        return color.White</p><p class="source-code">    }</p></li>
				<li>And for any other pixel, we will return black instead:<p class="source-code">    return color.Black</p></li>
				<li>With the generator function defined, we can create a new <strong class="source-inline">raster</strong> widget that will use it to color the output pixels:<p class="source-code">w.SetContent(canvas.NewRasterWithPixels(generate))</p></li>
				<li>By reusing the same application launch code in the previous examples, we can load the app and display its window:<p class="source-code"><strong class="bold">Chapter03/raster$ go run main.go</strong></p></li>
				<li>This will display the result shown in the following figures:</li>
			</ol>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.17_B16820.jpg" alt="Figure 3.8 - canvas.Raster rendered with FYNE_SCALE=1 (left) and 3.5 (right)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 - canvas.Raster rendered with <strong class="source-inline">FYNE_SCALE=1</strong> (left) and <strong class="source-inline">3.5</strong> (right)</p>
			<p>Whether you change the scale or resize the window, you will see that the pattern repeats at the same size, always using squares that are 20 pixels wide and high. Before we complete this section, we should also look at how gradients are handled on the canvas.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor082"/>Gradient</h2>
			<p>As we saw in <em class="italic">Figure 3.3</em>, the Fyne <a id="_idIndexMarker138"/>canvas is also capable of displaying gradients. Much like the raster in the previous section, a gradient will display using all the available pixels for the best output possible for each device. Adding a gradient, however, is much simpler than managing raster content.</p>
			<p>There are two types of gradient: linear and radial. </p>
			<h3>Linear gradient</h3>
			<p>A <strong class="source-inline">LinearGradient</strong> displays <a id="_idIndexMarker139"/>an even transition from one color to another and is<a id="_idIndexMarker140"/> normally presented as horizontal or vertical. A vertical gradient changes color from the start at the top of the area and the end color at the bottom; each row of pixels will have the same color, creating a gradient area that transitions from top to bottom. A horizontal gradient performs the same operation, but with the start color at the left of the area and the end at the right, which means that each column of pixels will have the same color.</p>
			<p>For example, the following lines would create a horizontal vertical gradient respectively from white to black using the provided convenience constructors:</p>
			<p class="source-code">canvas.NewHorizontalGradient(color.White, color.Black)</p>
			<p class="source-code">canvas.NewVerticalGradient(color.White, color.Black)</p>
			<p>By passing<a id="_idIndexMarker141"/> each of these to <strong class="source-inline">Window.SetContent</strong>, as we have done with other <a id="_idIndexMarker142"/>examples, you can see the following result, with a horizontal gradient on the left and a vertical gradient on the right:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.19_B16820.jpg" alt="Figure 3.9 – Horizontal and vertical gradients&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Horizontal and vertical gradients</p>
			<p>It is also possible to specify the exact angle of a linear gradient. The <strong class="source-inline">NewLinearGradient</strong> constructor takes a third parameter, the angle in degrees to orient. The vertical gradient is at <strong class="source-inline">0</strong> degrees and the horizontal is <strong class="source-inline">270</strong> degrees (equivalent to a <strong class="source-inline">90</strong>-degree counter-clockwise rotation). So, the usage of the horizontal gradient helper could also have been written as follows:</p>
			<p class="source-code">canvas.NewLinearGradient(color.White, color.Black, 270)</p>
			<p>Sometimes, however, a gradient that forms a curve is required; for this, we use a radial gradient.</p>
			<h3>Radial gradient</h3>
			<p>A radial gradient<a id="_idIndexMarker143"/> is one where the start color is at the center of the area (although this can be offset using <strong class="source-inline">CenterOffsetX</strong> and <strong class="source-inline">CenterOffsetY</strong>) and progresses to the end <a id="_idIndexMarker144"/>color at the edge of the area. The gradient is drawn such that the end color fully appears within the bounds on the horizontal and vertical lines from the center of the gradient. This means that the corners of the area this gradient occupies will be outside of the gradient calculation; for this reason, it can be useful for the end color to be <strong class="source-inline">color.Transparent</strong>. We set up a gradient similar to the <strong class="source-inline">LinearGradient</strong> example from white to black, as follows:</p>
			<p class="source-code">canvas.NewRadialGradient(color.White, color.Black)</p>
			<p>This code will result in the following image when placed in the contents of a window:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_3.21_B16820.jpg" alt="Figure 3.10 – A radial gradient transitioning from white to black&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – A radial gradient transitioning from white to black</p>
			<p>We have seen the various ways that we can output content, but it is also possible to animate it so that your application appears more interactive. We will see how to do this in the next section.</p>
			<p>Animation of the draw properties</p>
			<p>The Fyne <strong class="source-inline">canvas</strong> package also<a id="_idIndexMarker145"/> includes the facility to handle the animation of objects and properties. Using these APIs will help you to manage smooth transitions for a better user experience.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>Animating a transition</h2>
			<p>An animation in Fyne, at its very<a id="_idIndexMarker146"/> basic level, is a function that will be called for every graphical frame that it runs. Once it is started, it will run as long as the <strong class="source-inline">Duration</strong> field specifies. A basic animation can be created using the following:</p>
			<p class="source-code">anim := fyne.NewAnimation(time.Duration, func(float32))</p>
			<p>The animation that is returned from this constructor function can be started by calling <strong class="source-inline">anim.Start()</strong>. When the animation is started, its end time will be calculated based on the duration of time that passes. The callback that is passed in will be executed each time the graphics are updated. The <strong class="source-inline">float32</strong> parameter to this function will be <strong class="source-inline">0.0</strong> when it starts and <strong class="source-inline">1.0</strong> immediately before it ends; each intermediate call will have a value between these two.</p>
			<p>To provide a more concrete illustration, we can set up a position animation. This is one of the helpful animations provided by the <strong class="source-inline">canvas</strong> package. It, like many others, takes two additional parameters: the <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong> value of the animation. In this case, it expects a <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong> <strong class="source-inline">fyne.Position</strong>. Note that that the <strong class="source-inline">callback</strong> function will provide the current position value instead of a <strong class="source-inline">float32</strong> <em class="italic">offset</em> parameter. We create a new position animation that will run for one second:</p>
			<p class="source-code">start := fyne.NewPos(10, 10)</p>
			<p class="source-code">end := fyne.NewPos(90, 10)</p>
			<p class="source-code">anim := canvas.NewPositionAnimation(start, end,</p>
			<p class="source-code">    time.Second, callback)</p>
			<p>The <strong class="source-inline">callback</strong> function is responsible for applying the position value to a graphical object. In this case, we will create a text object that will move across the window:</p>
			<p class="source-code">text := canvas.NewText("Hi", color.Black)</p>
			<p class="source-code">callback := func(p fyne.Position) {</p>
			<p class="source-code">    text.Move(p)</p>
			<p class="source-code">    canvas.Refresh(text)</p>
			<p class="source-code">}</p>
			<p>We then simply start this<a id="_idIndexMarker147"/> animation using the <strong class="source-inline">Start()</strong> method:</p>
			<p class="source-code">anim.Start()</p>
			<p>These animations will run just once, but they can also be asked to loop.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor084"/>Looping animations</h2>
			<p>Any animation<a id="_idIndexMarker148"/> can be set to repeat—this means that after the time duration lapses, it will start again at the beginning. To request this behavior, set the <strong class="source-inline">RepeatCount</strong> field on the <strong class="source-inline">Animation</strong> struct to <strong class="source-inline">fyne.AnimationRepeatForever</strong>:</p>
			<p class="source-code">anim.RepeatCount = fyne.AnimationRepeatForever</p>
			<p>Setting <strong class="source-inline">RepeatCount</strong> to any number above <strong class="source-inline">0</strong> will specify how many times this animation should repeat. </p>
			<p class="source-code">anim.Start()</p>
			<p>After a repeating animation is started, it will run until it is manually stopped (using <strong class="source-inline">Animation.Stop()</strong>) or the number of repeats specified in <strong class="source-inline">RepeatCount</strong> is reached.</p>
			<p>There are many more animation APIs that can be used to control graphics and transitions. You can find more<a id="_idIndexMarker149"/> by looking for <strong class="source-inline">NewXxxAnimation()</strong> constructor functions in the <strong class="source-inline">canvas</strong> package.</p>
			<p>Now that we have explored the graphical capabilities of the Fyne toolkit, we will put it together in a small game application.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/>Implementing a simple game</h1>
			<p>In the first <a id="_idIndexMarker150"/>example application of this book, we will see how the canvas elements come together by building the graphical elements of a <em class="italic">snake game</em> (for a history of this game, see the Wikipedia entry at <a href="https://en.wikipedia.org/wiki/Snake_(video_game_genre)">https://en.wikipedia.org/wiki/Snake_(video_game_genre)</a>. The main element of this game is a snake character that the user will control as it moves around the screen. We will build the snake from a row of rectangles and add animation elements to bring it to life. Let's start by drawing the initial screen.</p>
			<p>Drawing a snake on screen</p>
			<p>To start the work of <a id="_idIndexMarker151"/>displaying the game canvas, we will see create a simple snake that consists of a row of 10 green squares. Let's begin:</p>
			<ol>
				<li value="1">Firstly, we will create a setup function that will build the game screen. We will call this function <strong class="source-inline">setupGame</strong> and create an empty list that we will populate. The return from this method is a container with no layout so that we can later use a manual layout for the visual elements:<p class="source-code">func setupGame() *fyne.Container {</p><p class="source-code">     var segments []fyne.CanvasObject</p><p class="source-code">     ...</p><p class="source-code">     return container.NewWithoutLayout(segments...)</p><p class="source-code">}</p></li>
				<li>To set up the graphical elements, we will iterate through a loop of 10 elements (<strong class="source-inline">i</strong> from <strong class="source-inline">0</strong> to <strong class="source-inline">9</strong>) and make a new <strong class="source-inline">Rectangle</strong> for each position. The elements are all created 10 x 10 in size and placed one above the other using the <strong class="source-inline">Move</strong> function. We will add them all to the segment slice created previously. This completes our setup code:<p class="source-code">    for i := 0; i &lt; 10; i++ {</p><p class="source-code">         r := canvas.NewRectangle(&amp;color.RGBA{G: 0x66, </p><p class="source-code">             A: 0xff})</p><p class="source-code">         r.Resize(fyne.NewSize(10, 10))</p><p class="source-code">         r.Move(fyne.NewPos(90, float32(50+i*10)))</p><p class="source-code">         segments = append(segments, r)</p><p class="source-code">    }</p><p>The preceding color<a id="_idIndexMarker152"/> specification is using a hexadecimal format, where <strong class="source-inline">0xff</strong> is the maximum for a channel and a missing channel (like red and blue in this code) defaults to <strong class="source-inline">0</strong>. The result is a green of medium brightness.</p></li>
				<li>With the graphical setup code, we can wrap this in the usual application load code, this time passing the result of <strong class="source-inline">setupGame()</strong> to the <strong class="source-inline">SetContent</strong> function. As this game will<a id="_idIndexMarker153"/> not have dynamic sizing, we will call <strong class="source-inline">SetFixedSize(true)</strong> so that the window cannot be resized:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("Snake")</p><p class="source-code">    w.SetContent(setupGame())</p><p class="source-code">    w.Resize(fyne.NewSize(200, 200))</p><p class="source-code">    w.SetFixedSize(true)</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>Now we can build and run the code in the usual way:<p class="source-code"><strong class="bold">Chapter03/example$ go run main.go</strong></p></li>
				<li>You will see the following result:</li>
			</ol>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_3.23_B16820.jpg" alt="Figure 3.11 – A simple snake drawn in the window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – A simple snake drawn in the window</p>
			<p>Next, we will bring the <a id="_idIndexMarker154"/>snake to life with some simple movement code.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Adding a timer to move the snake</h2>
			<p>The next step is to add <a id="_idIndexMarker155"/>some motion to the game. We will start with a simple timer that repositions the snake on screen:</p>
			<ol>
				<li value="1">To help manage the game state, we will define a new type to store the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong> value of each snake segment, named <strong class="source-inline">snakePart</strong>. We then make a slice that contains all of the elements, and this is what we will update as the snake moves around the screen. We will also define the game variable that we will use to refresh the screen when needed:<p class="source-code">type snakePart struct {</p><p class="source-code">    x, y float32</p><p class="source-code">}</p><p class="source-code">var (</p><p class="source-code">    snakeParts []snakePart</p><p class="source-code">    game       *fyne.Container</p><p class="source-code">)</p></li>
				<li>Inside <strong class="source-inline">setupGame</strong>, we need to create the representation of snake segments, one for each of the rectangles we created before. Adding the following lines to the loop will set up the state:<p class="source-code">        seg := snakePart{9, float32(5 + i)}</p><p class="source-code">        snakeParts = append(snakeParts, seg)</p></li>
				<li>To make sure that the game refreshes each time we move the snake, we need to move the rectangles and call <strong class="source-inline">Refresh()</strong>. We create a new function that will update the rectangles that we created earlier based on updated snake section information. We call this <strong class="source-inline">refreshGame()</strong>:<p class="source-code">func refreshGame() {</p><p class="source-code">    for i, seg := range snakeParts {</p><p class="source-code">        rect := game.Objects[i]</p><p class="source-code">        rect.Move(fyne.NewPos(seg.x*10, seg.y*10))</p><p class="source-code">    }</p><p class="source-code">    game.Refresh()</p><p class="source-code">}</p></li>
				<li>To run the main<a id="_idIndexMarker156"/> game loop, we need one more function that will use a timer to move the snake. We call this function <strong class="source-inline">runGame</strong>. This code waits 250 milliseconds and then moves the snake forward. To move it, we copy the position of each element from that of the element that is one segment further forward, working from the tail to the head. Lastly, the code moves the head to a new position, in this case further up the screen (by using <strong class="source-inline">snakeParts[0].y--</strong>). Refer to the following function:<p class="source-code">func runGame() {</p><p class="source-code">    for {</p><p class="source-code">        time.Sleep(time.Millisecond * 250)</p><p class="source-code">        for i := len(snakeParts) - 1; i &gt;= 1; i-- {</p><p class="source-code">            snakeParts[i] = snakeParts[i-1]</p><p class="source-code">        }</p><p class="source-code">        snakeParts[0].y--</p><p class="source-code">        refreshGame()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>To start the game timer, we need to update the <strong class="source-inline">main()</strong> function. It must assign the <strong class="source-inline">game</strong> variable so that we can refresh it later, and it will start a new goroutine executing the <strong class="source-inline">runGame</strong> code. We do this by changing the <strong class="source-inline">SetContent</strong> and <strong class="source-inline">ShowAndRun</strong> calls to read as follows:<p class="source-code">    game = setupGame()</p><p class="source-code">    w.SetContent(game)</p><p class="source-code">    go runGame()</p><p class="source-code">    w.ShowAndRun()</p></li>
				<li>Running the updated code will initially show the same screen, but the green shape will then move up the screen until it leaves the window:<p class="source-code"><strong class="bold">Chapter03/example$ go run main.go</strong></p></li>
			</ol>
			<p>With the draw and basic<a id="_idIndexMarker157"/> movement code in place, we want to be able to control the game, which we will look at next.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>Using keys to control direction</h2>
			<p>To control the<a id="_idIndexMarker158"/> snake's direction, we will need to handle some keyboard events. Unfortunately, this will be specific to desktop or mobile devices with a hardware keyboard; to add touchscreen controls would require using widgets (such as a button) that we will not explore until <a href="B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a><em class="italic">, Widget Library and Themes</em>:</p>
			<ol>
				<li value="1">To start with, we define a new type (<strong class="source-inline">moveType</strong>) that will be used to describe the next direction in which to move. We use the Go built-in instruction <strong class="source-inline">iota</strong>, which is similar to <strong class="source-inline">enum</strong> in other languages. The <strong class="source-inline">move</strong> variable is then defined to hold the next move direction:<p class="source-code">type moveType int</p><p class="source-code">const (</p><p class="source-code">    moveUp moveType = iota</p><p class="source-code">    moveDown</p><p class="source-code">    moveLeft</p><p class="source-code">    moveRight</p><p class="source-code">)</p><p class="source-code">var move = moveUp</p></li>
				<li>Next, we will <a id="_idIndexMarker159"/>translate from key events to the movement type that we just defined. Create a new <strong class="source-inline">keyTyped</strong> function as follows that will perform the keyboard mapping:<p class="source-code">func keyTyped(e *fyne.KeyEvent) {</p><p class="source-code">    switch e.Name {</p><p class="source-code">    case fyne.KeyUp:</p><p class="source-code">        move = moveUp</p><p class="source-code">    case fyne.KeyDown:</p><p class="source-code">        move = moveDown</p><p class="source-code">    case fyne.KeyLeft:</p><p class="source-code">        move = moveLeft</p><p class="source-code">    case fyne.KeyRight:</p><p class="source-code">        move = moveRight</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>For the key events to be triggered, we must specify that this key handler should be used for the current window. We do this using the <strong class="source-inline">SetOnKeyTyped()</strong> function on the window's canvas:<p class="source-code">w.Canvas().SetOnTypedKey(keyTyped)</p></li>
				<li>To make the snake move according to these events, we need to update the <strong class="source-inline">runGame()</strong> function to apply the correct movement. In place of the line <strong class="source-inline">snakeParts[0].y--</strong> (just before <strong class="source-inline">refreshGame()</strong>), we add the following code that will position the head for each new move:<p class="source-code">        switch move {</p><p class="source-code">        case moveUp:</p><p class="source-code">            snakeParts[0].y--</p><p class="source-code">        case moveDown:</p><p class="source-code">            snakeParts[0].y++</p><p class="source-code">        case moveLeft:</p><p class="source-code">            snakeParts[0].x--</p><p class="source-code">        case moveRight:</p><p class="source-code">            snakeParts[0].x++</p><p class="source-code">        }</p><p class="source-code">        refreshGame()</p></li>
				<li>We can now run the updated code sample to test the keyboard handling:<p class="source-code"><strong class="bold">Chapter03/example$ go run main.go</strong></p></li>
				<li>After the app <a id="_idIndexMarker160"/>loads and you press the left and then down keys, you should see something like the following:</li>
			</ol>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.25_B16820.jpg" alt="Figure 3.12 – The snake can move around the screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – The snake can move around the screen</p>
			<p>Although this is now technically an<a id="_idIndexMarker161"/> animated game, we can make it smoother. Using the animation API will allow us to draw smoother movements.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>Animating the movement</h2>
			<p>The motion created by our run<a id="_idIndexMarker162"/> loop in the previous section provides the motion that the game is based on, but it is not very smooth. In this last section, we will improve the motion by using the animation API. We will create a new rectangle for the head segment that will move ahead of the snake animation and also move the tail to its new position smoothly. The rest of the elements can remain fixed. Let's see how this is done:</p>
			<ol>
				<li value="1">We first define a new rectangle that represents the moving head segment:<p class="source-code">var head *canvas.Rectangle</p></li>
				<li>We set this up by adding the following code to the <strong class="source-inline">setupGame</strong> function:<p class="source-code">    head = canvas.NewRectangle(&amp;color.RGBA{G: 0x66, A: </p><p class="source-code">        0xff})</p><p class="source-code">    head.Resize(fyne.NewSize(10, 10))</p><p class="source-code">    head.Move(fyne.NewPos(snakeParts[0].x*10,</p><p class="source-code">        snakeParts[0].y*10))</p><p class="source-code">    segments = append(segments, head)</p></li>
				<li>To start drawing the head in front of the current body position, we add the following code to the top of the <strong class="source-inline">runGame</strong> function so that the next segment is calculated in the movement before the snake reaches that position:<p class="source-code">    nextPart := snakePart{snakeParts[0].x, </p><p class="source-code">        snakeParts[0].y - 1}</p></li>
				<li>We set up our animations inside the <strong class="source-inline">for</strong> loop in the <strong class="source-inline">runGame</strong> function, before the timer pause. Firstly, we calculate where the head is and then its new position and set up a new animation to make that transition:<p class="source-code">    oldPos := fyne.NewPos(snakeParts[0].x*10,</p><p class="source-code">        snakeParts[0].y*10)</p><p class="source-code">    newPos := fyne.NewPos(nextPart.x*10, next</p><p class="source-code">        Part.y*10)</p><p class="source-code">    canvas.NewPositionAnimation(oldPos, newPos,</p><p class="source-code">        time.Millisecond*250, func(p fyne.Position) {</p><p class="source-code">        head.Move(p)</p><p class="source-code">        canvas.Refresh(head)</p><p class="source-code">    }).Start()</p></li>
				<li>We also create <a id="_idIndexMarker163"/>another animation to transition the tail to its new position, as follows:<p class="source-code">    end := len(snakeParts) - 1</p><p class="source-code">    canvas.NewPositionAnimation(</p><p class="source-code">        fyne.NewPos(snakeParts[end].x*10,</p><p class="source-code">            snakeParts[end].y*10),</p><p class="source-code">        fyne.NewPos(snakeParts[end-1].x*10,</p><p class="source-code">            snakeParts[end-1].y*10),</p><p class="source-code">        time.Millisecond*250,</p><p class="source-code">        func(p fyne.Position) {</p><p class="source-code">            tail := game.Objects[end]</p><p class="source-code">            tail.Move(p)</p><p class="source-code">            canvas.Refresh(tail)</p><p class="source-code">        }).Start()</p></li>
				<li>After the <strong class="source-inline">time.Sleep</strong> in our game loop, we need to use the new <strong class="source-inline">nextPart</strong> variable to set up the new head position, as follows:<p class="source-code">    snakeParts[0] = nextPart</p><p class="source-code">    refreshGame()</p></li>
				<li>After the refresh line, we need to update the movement calculations to set up <strong class="source-inline">nextPart</strong> ready for the next movement:<p class="source-code">    switch move {</p><p class="source-code">    case moveUp:</p><p class="source-code">        nextPart = snakePart{nextPart.x, </p><p class="source-code">            nextPart.y - 1}</p><p class="source-code">    case moveDown:</p><p class="source-code">        nextPart = snakePart{nextPart.x, </p><p class="source-code">            nextPart.y + 1}</p><p class="source-code">    case moveLeft:</p><p class="source-code">        nextPart = snakePart{nextPart.x - 1, </p><p class="source-code">            nextPart.y}</p><p class="source-code">    case moveRight:</p><p class="source-code">        nextPart = snakePart{nextPart.x + 1, </p><p class="source-code">            nextPart.y}</p><p class="source-code">    }</p></li>
				<li>Run the updated code and you will see this behavior, but with a smooth transition along the path:<p class="source-code"><strong class="bold">Chapter03/example$ go run main.go</strong></p></li>
			</ol>
			<p>For the complete<a id="_idIndexMarker164"/> code for this example, you can use the book's GitHub repository at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example</a>.</p>
			<p>Although many more features could be added to this example, we have explored all the application and canvas operations required to build a full game.</p>
			<p>Summary</p>
			<p>In this chapter, we started our journey with the Fyne toolkit, exploring how it is organized and how a Fyne application operates. We saw how it uses vector graphics to create a high-quality output at any resolution, allowing it to scale well over desktop computers, smart phones, and more.</p>
			<p>We explored the features of the canvas package and saw how it can be used to draw individual elements to the screen. By combining these graphical primitives using <strong class="source-inline">fyne.Container</strong>, we were able to draw more complex output to our window. We also saw how the animation APIs can be used to display transitions of an object's size, position, and other properties.</p>
			<p>To bring this knowledge together, we built a small snake game that displayed elements to the screen and animated them based on user input. Although we could add many more features and graphical polish to this game, we will move on to other topics. </p>
			<p>In the next chapter, we will explore how layout algorithms can manage the contents of a window and the best practices of file handling that are needed to build an image browser application.</p>
		</div>
	</body></html>