- en: '*Chapter 3*: Window, Canvas, and Drawing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored the basics of graphical application development and seen how
    starting with a new design in a modern language can lead to easier development.
    From this point on, we will be looking in more detail at how the Fyne toolkit
    aims to provide an easy-to-use API for building cross-platform applications for
    all developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will investigate the structure of a Fyne application, how
    it draws objects, and how they can be scaled and manipulated—as well as animated—in
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Fyne applications are structured and how to start making your first app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the canvas package and the types of objects that can be drawn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How scalable elements create a clean user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with bitmaps and pixel rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation of elements and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how these features combine to create
    a graphical application, which will be demonstrated with a simple game.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be writing our first Fyne code, including building
    a complete application. To do this, you will need to have the **Go** compiler
    installed, as well as a code editor application. You can download Go from the
    home page at [https://golang.org/dl/](https://golang.org/dl/). The choice of code
    editor is normally a matter of user preference, but Microsoft's *Visual Studio
    Code* and JetBrain's *GoLand* applications are both highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: As Fyne uses some operating system APIs internally, you will also need to have
    a **C** compiler installed. Developers on Linux will probably already have one;
    macOS users can simply install *Xcode* from the Mac App Store. Windows-based developers
    will need to install a compiler, such as *MSYS2*, *TDM-GCC*, or *Cygwin*—more
    details can be found in [*Appendix A*](B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253)
    *– Developer Tool Installation*.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this chapter can be found in the book's GitHub repository
    at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Fyne application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036),
    *The Future According to Fyne*, the toolkit took the opportunity to start from
    scratch, throwing away the old and sometimes confusing constraints of previous
    toolkits. As a result, the APIs need to define everything involved in building
    a graphical application. In this section, we will explore the main concepts in
    running a Fyne-based application and producing visible components on screen, starting
    with the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application, defined in the `fyne.App` interface, models the capabilities
    of a Fyne-based application. Each app using Fyne will typically create and run
    a single `fyne.App` instance from within their `main()` function. Because of the
    way that graphical applications work, they must be started from the main function
    and not through a goroutine or other background thread.
  prefs: []
  type: TYPE_NORMAL
- en: To create an app instance, we make use of the `app` package within Fyne, which
    can be imported using `fyne.io/fyne/app`. This package contains all of the logic
    and driver setup code that allows an app to understand the platform it is running
    on and configure itself appropriately. The function that we call is named `New()`
    and it will return the app instance that we will use throughout our code. To run
    the application, we would then call `Run()` and the application will start.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we could run our first Fyne app; however, it would be difficult
    to know if it was working without asking it to display something first! And so,
    we shall now learn how to display a window before running the first example.
  prefs: []
  type: TYPE_NORMAL
- en: Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **window** defines the area on the screen that your application controls.
    In a desktop environment, this will typically be shown inside a window border
    that matches the rest of the applications installed. You will normally be able
    to move and resize the window and close it when you are done.
  prefs: []
  type: TYPE_NORMAL
- en: On mobile and other devices, this concept can be a little less well defined.
    For example, on Android and iOS smart phones, the application window will take
    up the whole screen and will not show window borders. To switch applications,
    you would use a gesture defined by the operating system or press a standard button,
    and other applications will appear, allowing you to move around. In addition to
    this, tablet computers—iPadOS, Android, or Windows, for example—will allow applications
    to be displayed in a portion of the screen, probably separated by a divider that
    allows the user to change how much space is used.
  prefs: []
  type: TYPE_NORMAL
- en: In all of these different presentation modes the content that is displayed is
    still modeled by the `fyne.Window` interface.
  prefs: []
  type: TYPE_NORMAL
- en: To show content on the screen, we will need to create a new window and show
    it. Once a window is defined, we can run an application to see the results. Let's
    work through the code for our first application!
  prefs: []
  type: TYPE_NORMAL
- en: 'We open a new file, `main.go`, and define it to be in the package `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then need to add any imports—in this case, we are just using the `app` package,
    so the following will be sufficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To define a runnable program, we create a `main()` method. Into this function,
    we will create a new application instance using the `New()` function we saw earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, in this method, we call `NewWindow(string)` (defined on `fyne.App`),
    which allows us to create the window to display. We pass it a single string parameter
    that sets a title (which is used if the operating system shows titles in the window
    border or app switcher, for example). Place the following code where `...` appeared
    in the previous snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have created a window, we can show it using the `Show()` function.
    After showing the window, we also need to call the `Run()` function on the application.
    As it is common to do both at the same time, there is a helper function `ShowAndRun()`,
    which we can use when showing the first window in an application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this code in place, we can save the file and run its contents like any
    other Go application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a window appear on screen. Depending on your operating system,
    this may be a very small window, as we have not added any content. The following
    screenshot was taken on a macOS computer after resizing the empty window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Our first window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Our first window
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the window in *Figure 3.1*, there is no content to the window,
    as we did not set any. The background of the window is not just black (or random
    colors from old graphics memory)—how can this be? The reason is that the window
    contains a `Canvas`, which is what manages the content we draw.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The content of every `fyne.Window` is a `fyne.Canvas`. Although the way that
    the canvas works internally is dependent upon the current system and some complex
    code within Fyne's internal driver packages, it will look exactly the same to
    developers and our application's end users. This platform-independent rendering
    canvas is responsible for all of the draw operations that come together to create
    a graphical output and eventually complete application interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Inside every canvas is at least one `fyne.CanvasObject`. These objects, as we
    will see in the *Understanding CanvasObject and the canvas package* section, define
    the types of operations that can be drawn to the canvas. To set the content of
    our window we can use `Window.SetContent(fyne.CanvasObject)`. This function passes
    the content down to the canvas, telling it to draw this object, and also resizes
    the window to be large enough to display it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this only sets the content to be a single element; we will normally
    want to include many, and this is what the `Container` type provides.
  prefs: []
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fyne.Container` extends the simple `fyne.CanvasObject` type to include
    managing multiple child objects. A container is responsible for controlling the
    size and position of each element it contains. *Figure 3.2* shows how the **Canvas**
    contains one container that positions three **CanvasObject** elements in a stack
    on the left and an additional **Container** to the right. This second container
    is responsible for three further elements, which it lays out in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A Canvas with various Container and CanvasObject elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – A Canvas with various Container and CanvasObject elements
  prefs: []
  type: TYPE_NORMAL
- en: Containers typically delegate the work of positioning child objects to a `fyne.Layout`.
    These layout algorithms will be explored further in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)*,
    Layout and File Handling*. In the current chapter, we will use containers without
    layouts—these are called *manual layouts* and are invoked using `container.NewWithoutLayout(elements)`,
    where the `elements` parameter is a list of `fyne.CanvasObject` types that the
    container will present. We will explore manual layouts further in the *Combining
    elements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how the application is defined and how it handles the
    presentation of graphical elements, we should see what drawing capabilities Fyne
    supports, and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CanvasObject and the canvas package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CanvasObject` definition is just a Go interface that describes an element
    that can be positioned, sized, and added to a Fyne canvas. The type does not contain
    any information about how to draw—this information is provided by *concrete types*
    within the `canvas` package. These types define well-understood graphical primitives,
    such as `Text` and `Line`.
  prefs: []
  type: TYPE_NORMAL
- en: Before learning how to use these elements, we shall see how they look in the
    Fyne demo app.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at how to write code that will display shapes in our window,
    we should look at a demo of these features in action. Using the built-in Fyne
    demo application, we can see what the `canvas` package supports. If you have not
    already done so, you can install and run the demo application using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While running the demo, tap on the **Canvas** item on the left navigation panel.
    You should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 - The fyne_demo application showing various canvas primitives'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 - The fyne_demo application showing various canvas primitives
  prefs: []
  type: TYPE_NORMAL
- en: 'The window shown in *Figure 3.3* demonstrates some of the canvas types known
    to Fyne. Those drawn here are named in the following list in order (left to right,
    from the top row and then the bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear Gradient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radial Gradient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these elements can be included in our application, as we will explore
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding objects to our window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each element in the previous demo figure, as well as any new items that are
    subsequently added to the `canvas` package, can be created directly using their
    `NewXxx()` constructor function. The object returned from this can then be passed
    directly to the window or a container of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s add some text content to the empty window. After
    adding `image/color` and `fyne.io/fyne/canvas` to the previously used `import`
    statements, we can change the main function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this change adds just one line—the `canvas.NewText` that is
    passed to `w.SetContent`. The text constructor function takes two parameters,
    the text to display and the color to use. If you run this code, you will see that
    the window now contains the text **This works!**, and is sized just right for
    this to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Displaying text content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Displaying text content
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, showing a canvas element is as simple as knowing which
    content you would like to display. Let's look at a slightly more complicated example
    using multiple canvas elements in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Combining elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To show how we can use a container to display multiple items and create a more
    appealing output, we shall replicate a road sign using a `canvas.Circle` and `canvas.Rectangle`
    element inside a `fyne.Container`. Let''s see how to go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we will create a new function for this code, named `makeSign()`. It
    should return `a fyne.CanvasObject` (which all graphical elements implement).
    The rest of our code will go into this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we will create the background for a sign using `canvas.NewCircle()`, saving
    a reference to it so that we can use it later. The color that we pass is bright
    red—`255` (the maximum) for red channel. Green and blue values are `0`, and the
    alpha channel (how opaque the color appears) is also set at maximum, so it is
    fully visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we add a white border to this circle. The `StrokeWidth` property controls
    how wide the border is (defaults to `0` or hidden) and we set `StrokeColor` to
    white for an outer circle of white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will draw the bar across the center; this is simply a white rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To combine these two elements, we define a container. It is important to pass
    the parameters with the circle (`bg`) first and rectangle (`bar`) second, as they
    will be drawn in this order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must position these elements. We will specify that the sign is `100`
    x `100`. Because it has a border, we will inset it from the sides by `10` x `10`
    so that it is centered within a window sized 120 x 120:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To position the `bar`, we will make it `80` x `20`. To position it over the
    60, 60 central spot, we move it to `20`, `50`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this code in place, we end the function by returning the container we
    have made:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This completes the definition of our sign. To display it, we call the `makeSign()`
    function and pass it to `SetContent()`. We can also turn off the default padding
    on the window, as our content is not reaching the edge of our container. Because
    we are using a manual layout, we also need to resize the window to show the items
    we have positioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code in place, you can run the application in the usual way, but
    this time we shall force the dark theme so that our white border stands out (we
    will look at themes in more detail in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following window with the sign crisp against a darker-colored
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Our road sign, created from a circle and rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Our road sign, created from a circle and rectangle
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: manual layouts do not automatically resize'
  prefs: []
  type: TYPE_NORMAL
- en: When using a manual layout, as explored in this example, it will not resize
    when the window changes size. This functionality is provided by using a layout
    algorithm, which we will explore in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the canvas elements and how to draw them. They
    created crisp, clean output, but we did not explore how that works. In the next
    section, we look at what scalable rendering is and how it creates such high-quality
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable drawing primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably realized from the previous example, all the items that we have
    rendered so far are vector graphics. This means that they are described by lines,
    curves, and high-level parameters instead of a collection of pixels. Because of
    this, these components are called **scalable** (like in **scalable vector graphics**
    (**SVG**) files), meaning that they can be drawn at any scale. The Fyne toolkit
    is a scalable toolkit, which means that a Fyne application can be drawn at any
    scale and render at a high quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the text component in more detail, for example. We define a
    simple text component as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then place that line of code into the standard `main()` function that
    we wrote in the first section of this chapter, *Anatomy of a Fyne application*,
    and then run it. The output will be as expected—drawing text at the normal size—but
    if we override the preferred scale using `FYNE_SCALE`, we can see how the application
    would look if the user wanted much larger text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – canvas.Text rendered with FYNE_SCALE=1 (left) and 3.5 (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – canvas.Text rendered with FYNE_SCALE=1 (left) and 3.5 (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaling a Fyne application in this way will not just change the font size,
    but will scale up every element of the user interface. This includes all standard
    graphics, widgets, and layouts. The standard themes also provide a set of icons
    (which we will explore more in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*), which are also scalable. We can see this by using
    a theme resource and the icon widget type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the preceding line to the same `main` function, we can see how icons
    will scale to match the text demonstrated in the previous figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – widget.Icon rendered with FYNE_SCALE=1 (left) and 3.5 (right)](img/Figure_3.15_B16820.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – widget.Icon rendered with FYNE_SCALE=1 (left) and 3.5 (right)
  prefs: []
  type: TYPE_NORMAL
- en: The size and position of elements will be scaled according to the canvas scale.
    We can now see how this coordinate system works.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the *Combining elements* section earlier, it is sometimes necessary
    to position or resize elements within a user interface. Doing so for a scalable
    output can be a little complicated, as we are not measuring content using pixels.
    And so, Fyne uses a device-independent coordinate system that Android developers
    may be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: A 1 x 1 size in Fyne (written as `fyne.NewSize(1, 1)`) may represent more than
    (or fewer than) 1 output pixel. If the scale was 3 (as it is for many modern smart
    phones), then the 1 x 1 square will likely use nine output pixels. As the toolkit
    is designed for scalable output, the result will not be a *pixelated* output,
    like it could be with older graphical toolkits that simply multiply the size of
    each pixel. The rendered output will continue to look crisp, as we saw in *Figure
    3.6* and *Figure 3.7*.
  prefs: []
  type: TYPE_NORMAL
- en: A fully scalable user interface has huge benefits when working with display
    devices of varying pixel densities, and it allows users to choose a preferred
    zoom level for all application components. However, sometimes we need to work
    with nonscalable elements, such as bitmap (pixel based) images, or our application
    may need to use every pixel available for high-definition graphical output. We
    will explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel output – rendering images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the reasons outlined in the previous section, it is recommended that you
    use scalable graphics (normally SVG files) for icons and other image-based components
    of user interfaces. It will sometimes be necessary to work with bitmap graphics
    (those defined by a collection of pixels rather than graphical features). If you
    are loading and managing images, or if you want to display detailed graphical
    elements using every pixel available, then this section contains important information
    about how to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Image content in Fyne defines graphical content that will normally stretch or
    shrink to the space that is allocated to it. Loading a bitmap image (which has
    dimensions that are defined by the number of pixels) into a scalable output may
    not provide the expected outcome. The rendered output of a size defined in pixels
    will vary depending on the scale of the output device or user preferences. For
    this reason, Fyne does not normally set a minimum size for images that are being
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Images can be loaded from files, resources, data streams, and more. Each file
    should have a unique name (or path), which makes it possible for performance improvements
    through caching. Loading an image from the filesystem should be done through the
    Fyne `storage` API to avoid any platform-specific code or assumptions (this is
    explored in detail in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*). You can use `storage.NewFileURI` to get the reference
    to a file path if that is needed. For example, to load an image from a file path,
    you would call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To define how a loaded image should be displayed in your app, you can set the
    `ImageFill` field in your `canvas.Image` object. It will be one of the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas.ImageFillStretch`: The default value. This will adjust the image dimensions
    up or down to match the image object size, adjusting the **aspect ratio** (the
    ratio of width to height values), which can cause images to look squashed or stretched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canvas.ImageFillContain`: This fill option will retain the aspect ratio so
    that the image is not distorted and draws it as the largest size possible that
    can fit within the image size. This will usually leave a space on two of the edges
    so that the image is centered in the available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canvas.ImageFillOriginal`: In original fill mode, the image will display using
    one output pixel for each pixel in the image. Although this seems desirable, it
    is important to note that it''s visible size will vary based on the device because
    of the variation of pixel density. Using this value will also ensure that sufficient
    space will be reserved to draw the required number of pixels. If it is likely
    that the image will be larger than the space available, be sure to wrap it in
    a scroll container (discussed in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)*,
    Widget Library and Themes*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in the fill modes, the output size of an image cannot be known
    by looking at the image file, and so your application will probably need to specify
    how large the image should be. Normally, this will be controlled by a layout—images
    would be expanded according to the type of layout. Another way to do this is to
    call `SetMinSize()` to ensure that the image never gets smaller than a specified
    (pixel independent) value. If you have used `ImageFillOriginal`, then this step
    will have been completed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'If small images are used, but they occupy a large space, they may appear *pixelated*,
    depending on how far they have been scaled. It is recommended that you use images
    that contain sufficient pixels/detail so that they will be scaled down (shown
    smaller) when displayed instead of scaling them up; however, if you want the output
    to look pixelated (or retro), you can specify that a pixel-based scaling should
    be used to enhance this look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the pixelated output described here does not apply if the image file
    was `.svg`. When a scalable image file is loaded, it will always be redrawn to
    the size requested, ensuring a high-quality output each time.
  prefs: []
  type: TYPE_NORMAL
- en: Images are not the only way to draw bitmap content; we can also include more
    dynamically created pixel content using the `Raster` type.
  prefs: []
  type: TYPE_NORMAL
- en: Raster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, an application may wish to display content using every available
    pixel so that high detail can be displayed, such as when showing wave forms or
    a 3D render. In these situations, we use the `Raster` widget. This is designed
    to show pixel-based output that is calculated dynamically instead of being loaded
    from a file.
  prefs: []
  type: TYPE_NORMAL
- en: A raster output will dynamically determine the content to display based on the
    number of pixels available in the space it occupies. Each time the space resizes,
    the widget will be asked to redraw itself. These requests for content are handled
    by generator functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will explore how to display a checkerboard pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we declare a generator function—this will take the `x`, `y` parameter
    of the pixel requested and the width and height parameter of the overall area
    (in pixels), and return a color value, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then want to determine which color our pixel is. The following calculation
    will return white if the `x`, `y` coordinate is in a 20 x 20 pixel square at the
    top left or any odd-numbered square along the row, and then the opposite squares
    on the following row. For these pixels, we specify a white color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And for any other pixel, we will return black instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the generator function defined, we can create a new `raster` widget that
    will use it to color the output pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By reusing the same application launch code in the previous examples, we can
    load the app and display its window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the result shown in the following figures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 - canvas.Raster rendered with FYNE_SCALE=1 (left) and 3.5 (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 - canvas.Raster rendered with `FYNE_SCALE=1` (left) and `3.5` (right)
  prefs: []
  type: TYPE_NORMAL
- en: Whether you change the scale or resize the window, you will see that the pattern
    repeats at the same size, always using squares that are 20 pixels wide and high.
    Before we complete this section, we should also look at how gradients are handled
    on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Gradient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in *Figure 3.3*, the Fyne canvas is also capable of displaying gradients.
    Much like the raster in the previous section, a gradient will display using all
    the available pixels for the best output possible for each device. Adding a gradient,
    however, is much simpler than managing raster content.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of gradient: linear and radial.'
  prefs: []
  type: TYPE_NORMAL
- en: Linear gradient
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `LinearGradient` displays an even transition from one color to another and
    is normally presented as horizontal or vertical. A vertical gradient changes color
    from the start at the top of the area and the end color at the bottom; each row
    of pixels will have the same color, creating a gradient area that transitions
    from top to bottom. A horizontal gradient performs the same operation, but with
    the start color at the left of the area and the end at the right, which means
    that each column of pixels will have the same color.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following lines would create a horizontal vertical gradient
    respectively from white to black using the provided convenience constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing each of these to `Window.SetContent`, as we have done with other
    examples, you can see the following result, with a horizontal gradient on the
    left and a vertical gradient on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Horizontal and vertical gradients'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Horizontal and vertical gradients
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to specify the exact angle of a linear gradient. The `NewLinearGradient`
    constructor takes a third parameter, the angle in degrees to orient. The vertical
    gradient is at `0` degrees and the horizontal is `270` degrees (equivalent to
    a `90`-degree counter-clockwise rotation). So, the usage of the horizontal gradient
    helper could also have been written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, however, a gradient that forms a curve is required; for this, we
    use a radial gradient.
  prefs: []
  type: TYPE_NORMAL
- en: Radial gradient
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A radial gradient is one where the start color is at the center of the area
    (although this can be offset using `CenterOffsetX` and `CenterOffsetY`) and progresses
    to the end color at the edge of the area. The gradient is drawn such that the
    end color fully appears within the bounds on the horizontal and vertical lines
    from the center of the gradient. This means that the corners of the area this
    gradient occupies will be outside of the gradient calculation; for this reason,
    it can be useful for the end color to be `color.Transparent`. We set up a gradient
    similar to the `LinearGradient` example from white to black, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will result in the following image when placed in the contents of
    a window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – A radial gradient transitioning from white to black'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.21_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – A radial gradient transitioning from white to black
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the various ways that we can output content, but it is also possible
    to animate it so that your application appears more interactive. We will see how
    to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Animation of the draw properties
  prefs: []
  type: TYPE_NORMAL
- en: The Fyne `canvas` package also includes the facility to handle the animation
    of objects and properties. Using these APIs will help you to manage smooth transitions
    for a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An animation in Fyne, at its very basic level, is a function that will be called
    for every graphical frame that it runs. Once it is started, it will run as long
    as the `Duration` field specifies. A basic animation can be created using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The animation that is returned from this constructor function can be started
    by calling `anim.Start()`. When the animation is started, its end time will be
    calculated based on the duration of time that passes. The callback that is passed
    in will be executed each time the graphics are updated. The `float32` parameter
    to this function will be `0.0` when it starts and `1.0` immediately before it
    ends; each intermediate call will have a value between these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a more concrete illustration, we can set up a position animation.
    This is one of the helpful animations provided by the `canvas` package. It, like
    many others, takes two additional parameters: the `start` and `end` value of the
    animation. In this case, it expects a `start` and `end` `fyne.Position`. Note
    that that the `callback` function will provide the current position value instead
    of a `float32` *offset* parameter. We create a new position animation that will
    run for one second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `callback` function is responsible for applying the position value to a
    graphical object. In this case, we will create a text object that will move across
    the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then simply start this animation using the `Start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These animations will run just once, but they can also be asked to loop.
  prefs: []
  type: TYPE_NORMAL
- en: Looping animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any animation can be set to repeat—this means that after the time duration
    lapses, it will start again at the beginning. To request this behavior, set the
    `RepeatCount` field on the `Animation` struct to `fyne.AnimationRepeatForever`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Setting `RepeatCount` to any number above `0` will specify how many times this
    animation should repeat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After a repeating animation is started, it will run until it is manually stopped
    (using `Animation.Stop()`) or the number of repeats specified in `RepeatCount`
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more animation APIs that can be used to control graphics and
    transitions. You can find more by looking for `NewXxxAnimation()` constructor
    functions in the `canvas` package.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the graphical capabilities of the Fyne toolkit, we
    will put it together in a small game application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first example application of this book, we will see how the canvas elements
    come together by building the graphical elements of a *snake game* (for a history
    of this game, see the Wikipedia entry at [https://en.wikipedia.org/wiki/Snake_(video_game_genre)](https://en.wikipedia.org/wiki/Snake_(video_game_genre)).
    The main element of this game is a snake character that the user will control
    as it moves around the screen. We will build the snake from a row of rectangles
    and add animation elements to bring it to life. Let's start by drawing the initial
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a snake on screen
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the work of displaying the game canvas, we will see create a simple
    snake that consists of a row of 10 green squares. Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we will create a setup function that will build the game screen. We
    will call this function `setupGame` and create an empty list that we will populate.
    The return from this method is a container with no layout so that we can later
    use a manual layout for the visual elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set up the graphical elements, we will iterate through a loop of 10 elements
    (`i` from `0` to `9`) and make a new `Rectangle` for each position. The elements
    are all created 10 x 10 in size and placed one above the other using the `Move`
    function. We will add them all to the segment slice created previously. This completes
    our setup code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding color specification is using a hexadecimal format, where `0xff`
    is the maximum for a channel and a missing channel (like red and blue in this
    code) defaults to `0`. The result is a green of medium brightness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the graphical setup code, we can wrap this in the usual application load
    code, this time passing the result of `setupGame()` to the `SetContent` function.
    As this game will not have dynamic sizing, we will call `SetFixedSize(true)` so
    that the window cannot be resized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can build and run the code in the usual way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – A simple snake drawn in the window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.23_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – A simple snake drawn in the window
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will bring the snake to life with some simple movement code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a timer to move the snake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to add some motion to the game. We will start with a simple
    timer that repositions the snake on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To help manage the game state, we will define a new type to store the `x`,
    `y` value of each snake segment, named `snakePart`. We then make a slice that
    contains all of the elements, and this is what we will update as the snake moves
    around the screen. We will also define the game variable that we will use to refresh
    the screen when needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `setupGame`, we need to create the representation of snake segments,
    one for each of the rectangles we created before. Adding the following lines to
    the loop will set up the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make sure that the game refreshes each time we move the snake, we need to
    move the rectangles and call `Refresh()`. We create a new function that will update
    the rectangles that we created earlier based on updated snake section information.
    We call this `refreshGame()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the main game loop, we need one more function that will use a timer
    to move the snake. We call this function `runGame`. This code waits 250 milliseconds
    and then moves the snake forward. To move it, we copy the position of each element
    from that of the element that is one segment further forward, working from the
    tail to the head. Lastly, the code moves the head to a new position, in this case
    further up the screen (by using `snakeParts[0].y--`). Refer to the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To start the game timer, we need to update the `main()` function. It must assign
    the `game` variable so that we can refresh it later, and it will start a new goroutine
    executing the `runGame` code. We do this by changing the `SetContent` and `ShowAndRun`
    calls to read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the updated code will initially show the same screen, but the green
    shape will then move up the screen until it leaves the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the draw and basic movement code in place, we want to be able to control
    the game, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Using keys to control direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To control the snake''s direction, we will need to handle some keyboard events.
    Unfortunately, this will be specific to desktop or mobile devices with a hardware
    keyboard; to add touchscreen controls would require using widgets (such as a button)
    that we will not explore until [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)*,
    Widget Library and Themes*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we define a new type (`moveType`) that will be used to describe
    the next direction in which to move. We use the Go built-in instruction `iota`,
    which is similar to `enum` in other languages. The `move` variable is then defined
    to hold the next move direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will translate from key events to the movement type that we just defined.
    Create a new `keyTyped` function as follows that will perform the keyboard mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the key events to be triggered, we must specify that this key handler should
    be used for the current window. We do this using the `SetOnKeyTyped()` function
    on the window''s canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the snake move according to these events, we need to update the `runGame()`
    function to apply the correct movement. In place of the line `snakeParts[0].y--`
    (just before `refreshGame()`), we add the following code that will position the
    head for each new move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run the updated code sample to test the keyboard handling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the app loads and you press the left and then down keys, you should see
    something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The snake can move around the screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.25_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – The snake can move around the screen
  prefs: []
  type: TYPE_NORMAL
- en: Although this is now technically an animated game, we can make it smoother.
    Using the animation API will allow us to draw smoother movements.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The motion created by our run loop in the previous section provides the motion
    that the game is based on, but it is not very smooth. In this last section, we
    will improve the motion by using the animation API. We will create a new rectangle
    for the head segment that will move ahead of the snake animation and also move
    the tail to its new position smoothly. The rest of the elements can remain fixed.
    Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define a new rectangle that represents the moving head segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set this up by adding the following code to the `setupGame` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To start drawing the head in front of the current body position, we add the
    following code to the top of the `runGame` function so that the next segment is
    calculated in the movement before the snake reaches that position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set up our animations inside the `for` loop in the `runGame` function, before
    the timer pause. Firstly, we calculate where the head is and then its new position
    and set up a new animation to make that transition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also create another animation to transition the tail to its new position,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `time.Sleep` in our game loop, we need to use the new `nextPart`
    variable to set up the new head position, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the refresh line, we need to update the movement calculations to set
    up `nextPart` ready for the next movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the updated code and you will see this behavior, but with a smooth transition
    along the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the complete code for this example, you can use the book's GitHub repository
    at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example).
  prefs: []
  type: TYPE_NORMAL
- en: Although many more features could be added to this example, we have explored
    all the application and canvas operations required to build a full game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we started our journey with the Fyne toolkit, exploring how
    it is organized and how a Fyne application operates. We saw how it uses vector
    graphics to create a high-quality output at any resolution, allowing it to scale
    well over desktop computers, smart phones, and more.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the features of the canvas package and saw how it can be used to
    draw individual elements to the screen. By combining these graphical primitives
    using `fyne.Container`, we were able to draw more complex output to our window.
    We also saw how the animation APIs can be used to display transitions of an object's
    size, position, and other properties.
  prefs: []
  type: TYPE_NORMAL
- en: To bring this knowledge together, we built a small snake game that displayed
    elements to the screen and animated them based on user input. Although we could
    add many more features and graphical polish to this game, we will move on to other
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how layout algorithms can manage the contents
    of a window and the best practices of file handling that are needed to build an
    image browser application.
  prefs: []
  type: TYPE_NORMAL
