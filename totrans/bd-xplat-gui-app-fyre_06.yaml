- en: '*Chapter 4*: Layout and File Handling'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：布局和文件处理'
- en: 'In the previous chapter, we learned how the main drawing aspects of the Fyne
    toolkit are organized and how an application can work directly with `CanvasObject`
    items on a window canvas. This was sufficient information to set up a small game,
    but once applications add the presentation of lots of information or require user
    input and workflows, they typically require more complex user interface designs.
    In this chapter, we look at how an application user interface is structured, covering
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Fyne工具包的主要绘图方面是如何组织的，以及一个应用程序如何可以直接在窗口画布上与`CanvasObject`项目交互。这些信息足以设置一个小游戏，但一旦应用程序需要展示大量信息或需要用户输入和工作流程，它们通常需要更复杂的用户界面设计。在本章中，我们将探讨应用程序用户界面的结构，包括以下内容：
- en: Arranging a `Container` item using built-in layout algorithms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置布局算法排列`Container`项目
- en: Creating custom layout algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义布局算法
- en: Handling files in a way that works across all platforms, desktop, and mobile
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以跨所有平台（桌面和移动）的方式处理文件
- en: With this knowledge, we will build an application for browsing photographs.
    Let's get started!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些知识，我们将构建一个用于浏览照片的应用程序。让我们开始吧！
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*, which is to have the Fyne toolkit installed. For
    more information, please refer to the previous chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与[*第三章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)“Windows、Canvas和绘图”相同，即需要安装Fyne工具包。有关更多信息，请参阅上一章。
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter04](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter04](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter04)找到。
- en: Laying out containers
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局容器
- en: As we saw in the previous chapter, a Fyne canvas is made up of `CanvasObject`,
    `Container`, and `Widget` items (although `Container` and `Widget` items are both
    `CanvasObject` items as well!). To be able to display multiple elements, we must
    use the `Container` type, which groups a number of `CanvasObject` items (which
    can also be `Widget` items or additional `Container` items). To manage the size
    and position of each item inside a container, we use an implementation of `Layout`,
    which is passed to the container at creation using the `container.New(layout,
    items)` constructor function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章所见，Fyne画布由`CanvasObject`、`Container`和`Widget`项目组成（尽管`Container`和`Widget`项目本身也是`CanvasObject`项目！）。为了能够显示多个元素，我们必须使用`Container`类型，它将多个`CanvasObject`项目（这些项目也可以是`Widget`项目或额外的`Container`项目）组合在一起。为了管理容器内每个项目的尺寸和位置，我们使用`Layout`的实现，该实现通过`container.New(layout,
    items)`构造函数在创建容器时传递给容器。
- en: There are many ways that an application may want to lay out its components and
    in this section we will explore the different ways that can be achieved. Layouts
    are not always required, however, and so first we will look at when you might
    not need to use a layout and how to handle size and placement manually instead.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能有多种方式来布局其组件，在本节中，我们将探讨实现这些不同方式的方法。然而，布局并不总是必需的，因此我们首先将探讨在什么情况下可能不需要使用布局，以及如何手动处理尺寸和位置。
- en: Manual layout
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动布局
- en: Before we explore layout algorithms, it is possible to manage a container without
    the use of a layout—this is called `container.NewWithoutLayout(items)`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索布局算法之前，可以不使用布局来管理容器——这被称为`container.NewWithoutLayout(items)`。
- en: When using a container without a layout, the developer must position and size
    all elements within the container manually, using the `Move()` and `Resize()`
    methods. In this mode, the developer is responsible for adapting the positions
    and sizes to the current size of the container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用没有布局的容器时，开发者必须手动使用`Move()`和`Resize()`方法定位和调整容器内所有元素的尺寸。在这种模式下，开发者负责根据容器的当前尺寸调整位置和尺寸。
- en: 'Let''s take a look at the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code we just saw sets up a `Rectangle` item and a `Circle` item inside
    a container, resizes them to be around half their size, and then positions them
    to have a small amount of overlap. You can see from the following figure that
    the elements are drawn in the order that they are passed to the container:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码设置了一个`Rectangle`项目和一个`Circle`项目，在容器内部调整它们的大小到大约一半，然后将它们定位以有少量重叠。您可以从以下图中看到，元素是按照它们传递给容器的顺序绘制的：
- en: '![Figure 4.1 – Manual layout in a container'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1 – Manual layout in a container'
- en: '](img/Figure_4.1_B16820.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.1_B16820.jpg]'
- en: Figure 4.1 – Manual layout in a container
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 容器中的手动布局
- en: Once set, these sizes and positions will not change unless we add more code
    to modify their positions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置，这些大小和位置将不会改变，除非我们添加更多代码来修改它们的位置。
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that there is no resized event published, so if you want to automatically
    adjust when the container is resized, you should consider building a custom layout,
    described under *Providing a custom layout* later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有发布任何调整大小的事件，因此如果您想自动调整容器大小，您应该考虑构建一个自定义布局，这在本章后面的*提供自定义布局*部分有描述。
- en: Using a layout manager
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用布局管理器
- en: 'In essence, a layout manager is the same as the manual move and resize code
    we just saw, with the difference that it operates on a list of `CanvasObject`
    items (those that are the children of `Container`). A layout manager has two responsibilities:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，布局管理器与我们在前面看到的手动移动和调整大小代码相同，不同之处在于它操作的是`CanvasObject`项目列表（那些是`Container`的子项）。布局管理器有两个职责：
- en: To control the size and position of each element
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要控制每个元素的大小和位置
- en: To determine the minimum size that the container should accept
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定容器应接受的最小大小
- en: When a `Container` item is resized, the layout that it is using will be asked
    to reposition all the child components. A layout algorithm may choose to scale
    elements according to the new size or to reposition the elements. Alternatively,
    it may decide to flow elements or adapt the layout according to whether the available
    space is taller or wider. In this way, setting a layout on a container can provide
    a responsive user interface based on screen size or even device orientation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Container`项目被调整大小时，它所使用的布局将被要求重新定位所有子组件。布局算法可以选择根据新大小缩放元素，或者重新定位元素。或者，它可能决定根据可用空间是更高还是更宽来流动元素或调整布局。通过这种方式，在容器上设置布局可以提供基于屏幕大小甚至设备方向的响应式用户界面。
- en: When we lay out interface components, it is common to wish to separate elements
    by inserting some clear space. This is called *padding* and in Fyne, you can find
    the standard padding size using the `theme.Padding()`function. You can find more
    about the `theme` package in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*. The standard layouts listed in the next section all
    include the standard padding between elements. Note that typically, a container
    layout will not use padding on the outside edge as that will be provided by the
    parent container, or the window canvas for top-level containers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们布局界面组件时，通常希望通过插入一些清晰的空间来分隔元素。这被称为*填充*，在Fyne中，您可以使用`theme.Padding()`函数找到标准填充大小。您可以在[*第五章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)，*小部件库和主题*中找到更多关于`theme`包的信息。下一节中列出的标准布局都包括元素之间的标准填充。请注意，通常，容器布局不会在外侧使用填充，因为这将由父容器或顶级容器的窗口画布提供。
- en: 'Containers using a layout can be created using the `container.New` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布局的容器可以使用`container.New`函数创建：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When using a container with a layout, it is not usually required to call `Resize`
    as we did before because it will be initially sized to at least the minimum size.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用具有布局的容器时，通常不需要调用`Resize`，就像我们之前做的那样，因为它将初始大小设置为至少最小大小。
- en: Hidden objects
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏的对象
- en: 'One additional consideration when selecting a layout, or writing layout code
    yourself, is that objects may not always be visible. A `CanvasObject` item may
    be hidden for two reasons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择布局或自己编写布局代码时，还需要考虑的一个额外因素是对象可能并不总是可见的。一个`CanvasObject`项目可能因为以下两个原因而隐藏：
- en: A developer called `Hide()` on that object.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个开发者对该对象调用了`Hide()`方法。
- en: It is inside a `Container` item that has similarly had `Hide()` invoked.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它位于一个同样调用了`Hide()`的`Container`项目内部。
- en: Typically, a layout algorithm will skip hidden elements when calculating the
    minimum size or laying out elements. Each of the standard layouts we will see
    next will skip hidden elements rather than leaving empty space where those items
    would otherwise have appeared.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，布局算法在计算最小尺寸或布局元素时将跳过隐藏的元素。我们接下来将要看到的每个标准布局都将跳过隐藏的元素，而不是在那些项目本应出现的地方留下空白空间。
- en: We have seen how layouts work in arranging the components of an application.
    To make building complex user interfaces as simple as possible, there are standard
    layouts available that cover most common user interface arrangements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了布局是如何在安排应用程序组件中起作用的。为了使构建复杂用户界面尽可能简单，有标准布局可供使用，这些布局涵盖了大多数常见的用户界面排列。
- en: Standard layouts
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准布局
- en: 'As there are many standard layout algorithms, the Fyne toolkit includes a collection
    of standard implementations in the `layout` package. By importing this package,
    you can apply these layouts to any `Container` in your application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有许多标准布局算法，Fyne工具包在`layout`包中包含了一系列标准实现。通过导入此包，您可以将这些布局应用于应用程序中的任何`Container`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each of the layouts is examined in detail in this section. Although a container
    can only have a single layout, there is no limit to the number of containers you
    can have nested inside each other, and so we look at combining different layouts
    at the end of this section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将详细检查每个布局。尽管容器只能有一个布局，但嵌套在彼此内部的容器数量没有限制，因此我们将在本节末尾探讨不同布局的组合。
- en: MaxLayout
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MaxLayout
- en: '**MaxLayout** (or **maximum layout**) is the simplest of all the built-in layout
    algorithms. Its purpose is to ensure that all child elements of a container take
    up the full space of that container:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**MaxLayout**（或**最大布局**）是所有内置布局算法中最简单的一个。其目的是确保容器中的所有子元素都占用该容器的全部空间：'
- en: '![Figure 4.2 – MaxLayout in a container'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – MaxLayout在容器中'
- en: '](img/max-light_4.2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/max-light_4.2.jpg)'
- en: Figure 4.2 – MaxLayout in a container
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – MaxLayout在容器中
- en: 'This is most commonly used to align one element over another, such as a text
    item over a background color rectangle. When using this layout, it is important
    to list the container elements in the correct order; each will be drawn over the
    other, and so the last item in the list will be drawn on top:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于将一个元素放置在另一个元素之上，例如文本项在背景色矩形之上。当使用此布局时，列出容器元素的正确顺序很重要；每个元素都将覆盖另一个元素，因此列表中的最后一个项目将绘制在最上面：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: CenterLayout
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CenterLayout
- en: '**CenterLayout** can be helpful when an item of a specified minimum size should
    be centered within the available space, both horizontally and vertically:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**CenterLayout**在需要将指定最小尺寸的项在可用空间中水平和垂直居中时非常有用：'
- en: '![Figure 4.3 – CenterLayout adding space around items'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – CenterLayout在项目周围添加空间'
- en: '](img/Figure_4.3_B16820.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B16820.jpg)'
- en: Figure 4.3 – CenterLayout adding space around items
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – CenterLayout在项目周围添加空间
- en: 'As with `MaxLayout`, each element within the container will be drawn on top
    of the previous one, but the size will be set as the minimum for each of the elements
    instead of filling the available space:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与`MaxLayout`类似，容器内的每个元素都将绘制在之前元素的上方，但大小将设置为每个元素的最小值，而不是填充可用空间：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: PaddedLayout
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PaddedLayout
- en: '**PaddedLayout** helps when you wish to inset content by the theme-defined
    padding value. The content element will be centered in the container by the standard
    padding on all sides, as shown in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**PaddedLayout**有助于您通过主题定义的填充值插入内容。内容元素将通过所有侧面的标准填充在容器中居中，如图所示：'
- en: '![Figure 4.4 – PaddedLayout adding a small space around items'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – PaddedLayout在项目周围添加小空间'
- en: '](img/padded-light_4.4.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/padded-light_4.4.jpg)'
- en: Figure 4.4 – PaddedLayout adding a small space around items
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – PaddedLayout在项目周围添加小空间
- en: 'As with `MaxLayout`, each element within the container will be drawn on top
    of the previous one, all with the same size, but in this case slightly smaller
    than the container:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与`MaxLayout`类似，容器内的每个元素都将绘制在之前元素的上方，所有元素大小相同，但在此情况下略小于容器：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: BoxLayout
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BoxLayout
- en: 'The box layout has two varieties, `HBoxLayout` (horizontal—for arranging items
    in a row) and `VBoxLayout` (vertical—for arranging items in a list). Each of the
    box layouts follows a similar algorithm: it creates a linear flow of elements
    where they are packed (horizontally or vertically) while maintaining a consistent
    height or width.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 框布局有两种类型，`HBoxLayout`（水平布局——用于按行排列项目）和`VBoxLayout`（垂直布局——用于按列表排列项目）。每个框布局都遵循类似的算法：它创建一个线性流，其中元素被打包（水平或垂直），同时保持一致的高度或宽度。
- en: 'Items listed in a horizontal box will have the width set to each item''s minimum,
    but will share the same height, which is the maximum of all the elements'' minimum
    height:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 水平框中列出的项目将宽度设置为每个元素的最小值，但将共享相同的高度，这是所有元素最小高度的最大值：
- en: '![Figure 4.5 – HBoxLayout aligning three elements in a row'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – HBoxLayout 在一行中对齐三个元素'
- en: '](img/Figure_4.5_B16820.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B16820.jpg)'
- en: Figure 4.5 – HBoxLayout aligning three elements in a row
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – HBoxLayout 在一行中对齐三个元素
- en: 'Items in a vertical box all have the same width (the largest of all the minimum
    widths), while shrinking to each element''s minimum height:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直框中的所有项目都具有相同的宽度（所有最小宽度中的最大值），同时缩小到每个元素的最小高度：
- en: '![Figure 4.6 – VBoxLayout stacking elements in a column'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – VBoxLayout 在列中堆叠元素'
- en: '](img/Figure_4.6_B16820.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.6_B16820.jpg)'
- en: Figure 4.6 – VBoxLayout stacking elements in a column
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – VBoxLayout 在列中堆叠元素
- en: 'This approach allows items of differing sizes to appear uniform without wasting
    any space in the container. The syntax for each of these is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许不同大小的项目看起来统一，同时不会在容器中浪费任何空间。每个这些的语法如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: FormLayout
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FormLayout
- en: '**FormLayout** is used by the form widget, but it can be useful on its own
    when you wish to label items in a container. There should be an even number of
    elements added; the first of each pair will be on the left, being as narrow as
    the component allows. The remaining horizontal space will be taken up by the second
    of each pair:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**FormLayout**由表单小部件使用，但当你希望在容器中为项目添加标签时，它也可以单独使用。应该添加偶数个元素；每对中的第一个将位于左侧，尽可能窄。剩余的水平空间将由每对中的第二个占据：'
- en: '![Figure 4.7 – FormLayout pairing items for labeling'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – FormLayout 配对项目进行标签'
- en: '](img/form-light_4.7.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/form-light_4.7.jpg)'
- en: Figure 4.7 – FormLayout pairing items for labeling
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – FormLayout 配对项目进行标签
- en: 'Here''s an example of using `FormLayout` (assuming an even number of parameters
    to be added):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`FormLayout`的例子（假设要添加的参数数量是偶数）：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: GridLayout
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GridLayout
- en: The basic **GridLayout** is designed to divide a container into as many equal
    spaces as the number of child elements in the container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的**GridLayout**旨在将容器划分为与容器中子元素数量相等的等空间。
- en: 'For a container with two columns and three child items, a second row will be
    created but not completely filled:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有两列和三个子元素容器的例子，将创建第二行，但不会完全填满：
- en: '![Figure 4.8 – Three elements in a two-column GridLayout'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 两列 GridLayout 中的三个元素'
- en: '](img/Figure_4.8_B16820.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B16820.jpg)'
- en: Figure 4.8 – Three elements in a two-column GridLayout
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 两列 GridLayout 中的三个元素
- en: 'When creating a grid layout, the developer will specify the number of columns
    or rows to use, and the items will be arranged accordingly. At the end of each
    row or column, the layout will wrap and create a new one. The number of rows (or
    columns) will depend upon the number of elements. For example, let''s take the
    following illustration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建网格布局时，开发者将指定要使用的列数或行数，项目将相应地排列。在每一行或每一列的末尾，布局将换行并创建一个新的布局。行数（或列数）将取决于元素的数量。例如，让我们看一下以下插图：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The grid layout has an additional mode that can help to adapt to different
    output devices. It is common on mobile devices to show items in a single column
    when held in portrait or a single row in landscape orientation. To enable this,
    use `NewAdaptiveGridLayout`; the parameter to this constructor represents the
    number of rows you wish to have in vertical arrangement or columns when horizontal.
    This layout will rearrange its `Container` when a mobile device is rotated, as
    seen here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局有一个额外的模式，可以帮助适应不同的输出设备。在移动设备中，当纵向持有时，通常在单列中显示项目；当横向持有时，在单行中显示。要启用此功能，请使用`NewAdaptiveGridLayout`；此构造函数的参数表示您希望在垂直排列中拥有的行数或水平排列时的列数。当移动设备旋转时，此布局将重新排列其`Container`，如下所示：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: GridWrapLayout
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GridWrapLayout
- en: Another variant of using a grid is when you would like elements to automatically
    flow to new rows as a container is resized (for example, a file manager or list
    of image thumbnails). For this scenario, Fyne provides a grid wrap layout. In
    a wrapped grid in which every child element will be resized to the specified size,
    they will then be arranged in a row until the next item does not fit, at which
    point a new row will be created for further elements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格的另一种变体是当你希望元素在容器大小调整时自动流动到新行（例如，文件管理器或图像缩略图列表）。在这种情况下，Fyne提供了一个网格包裹布局。在一个包裹的网格中，每个子元素都会调整到指定的大小，然后它们将按行排列，直到下一个项目无法适应，此时将为后续元素创建一个新行。
- en: 'For example, here is a grid wrap container that is wider than three items of
    the specified size:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个比指定大小三项更宽的网格包裹容器：
- en: '![Figure 4.9 – Fixed elements in GridWrapLayout'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 – GridWrapLayout中的固定元素'
- en: '](img/Figure_4.9_B16820.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B16820.jpg)'
- en: Figure 4.9 – Fixed elements in GridWrapLayout
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – GridWrapLayout中的固定元素
- en: GridWrapLayout and MinSize
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: GridWrapLayout和MinSize
- en: It is important to note that this layout, unlike all the others, will not check
    each item's `MinSize`. The developer should thus be careful to ensure that it
    is large enough, or that elements included will truncate their elements (such
    as text) to avoid overflow.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这种布局与其他所有布局不同，它不会检查每个项目的`MinSize`。因此，开发者应小心确保它足够大，或者包含的元素将截断其元素（如文本）以避免溢出。
- en: 'Here is an example using a grid wrap layout:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用网格包裹布局的示例：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: BorderLayout
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BorderLayout
- en: 'The most commonly used layout in arranging an application is probably **BorderLayout**.
    This layout algorithm will arrange specified elements at the top, bottom, left,
    and right edges of a container. The top and bottom items will be resized to their
    minimum height but stretched horizontally, and items on the left and right will
    be squashed to their minimum width and expanded vertically. Any elements in the
    container that are not specified as belonging to one of the edges will be sized
    to fill the available space inside the borders. This is commonly used to position
    toolbars at the top, footers at the bottom, and file lists on the left. Any edges
    you wish to leave blank should have nil instead:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排应用程序布局中最常用的布局可能是**BorderLayout**。这种布局算法将指定元素排列在容器的顶部、底部、左侧和右侧边缘。顶部和底部的项目将调整到最小高度，但水平拉伸，左侧和右侧的项目将压缩到最小宽度并垂直扩展。容器中未指定属于任何边缘的任何元素将调整大小以填充边框内的可用空间。这通常用于将工具栏放置在顶部，页脚放置在底部，以及文件列表放置在左侧。任何你希望留空的边缘应使用nil代替：
- en: '![Figure 4.10 – BorderLayout with top and left areas set'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 – 设置了顶部和左侧区域的BorderLayout'
- en: '](img/Figure_4.10_B16820.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B16820.jpg)'
- en: Figure 4.10 – BorderLayout with top and left areas set
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 设置了顶部和左侧区域的BorderLayout
- en: BorderLayout parameters
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: BorderLayout参数
- en: Note that for `BorderLayout`, some elements must be specified twice—the layout
    parameters specify where an element should be positioned, but the list of items
    to the container control what will be visible. If you find an item not appearing,
    be sure that it is specified in both places.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于`BorderLayout`，某些元素必须指定两次——布局参数指定元素应放置的位置，但项目列表控制容器中将显示什么。如果你发现某个项目没有显示，请确保它在两个地方都进行了指定。
- en: 'The following code shows how to set up a border container with `header` at
    the top and `files` positioned to the left of `content`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何设置带有`header`在顶部并将`files`定位在`content`左侧的边框容器：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Combining layouts
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合布局
- en: 'To build more complicated application structures, it will be necessary to use
    multiple layouts within your user interface. As each container has a single layout,
    we achieve this by nesting different containers. This can be done as many times
    as required. For example, take a look at the following figure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的应用程序结构，你将需要在用户界面中使用多个布局。由于每个容器只有一个布局，我们通过嵌套不同的容器来实现这一点。这可以按需多次进行。例如，看看以下图示：
- en: '![Figure 4.11 – Multiple containers with different layouts'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 – 具有不同布局的多个容器'
- en: '](img/Figure_4.11_B16820.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B16820.jpg)'
- en: Figure 4.11 – Multiple containers with different layouts
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 具有不同布局的多个容器
- en: 'For the previous illustration, we have used a container with `VBoxLayout` for
    the left panel, `HBoxLayout` for the top, and `GridWrapLayout` for the central
    container, all inside `BorderLayout`, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的插图，我们使用了一个容器，其中左侧面板使用`VBoxLayout`，顶部使用`HBoxLayout`，中央容器使用`GridWrapLayout`，所有这些都位于`BorderLayout`内部，如下所示：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using the container package
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器包
- en: All of the preceding examples use a built-in `Layout` type to configure the
    contents of `fyne.Container`. To help manage more complex layout configurations
    (we will see more in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*), there are many helpful constructor functions in
    the `container` package. For example, instead of `container.New(layout.NewBorderLayout(…)…)`
    we could use `container.NewBorder(...)`, which can lead to clearer code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前例都使用了内置的 `Layout` 类型来配置 `fyne.Container` 的内容。为了帮助管理更复杂的布局配置（我们将在 [*第五章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)，*小部件库和主题*）中看到更多），`container`
    包中有很多有用的构造函数。例如，我们可以使用 `container.NewBorder(...)` 而不是 `container.New(layout.NewBorderLayout(…)…)`，这可以使代码更清晰。
- en: Providing a custom layout
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 提供自定义布局
- en: If the standard layouts, or a combination of them, do not accommodate the needs
    of your user interface, it is possible to build a custom layout and pass that
    into a container instead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准布局或它们的组合无法满足你的用户界面需求，你可以构建一个自定义布局并将其传递给容器。
- en: 'Any type that implements the `fyne.Layout` interface can be used as a `Container`
    layout. This interface has just two methods that need to be implemented, as shown
    here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了 `fyne.Layout` 接口的数据类型都可以用作 `Container` 布局。这个接口只需要实现两个方法，如下所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this interface codifies the earlier description that a layout
    manager will need to determine the minimum size of a container as well as handling
    the positioning of each element in a container. As the contents of a container
    can change from time to time, it is possible that the slice of `CanvasObject`
    elements passed to `Layout` or `MinSize` may change. Hence, a custom layout should
    avoid caching references to individual elements. In certain situations (such as
    `BorderLayout`, which we saw earlier), the layout may explicitly hold an object
    reference. If your layout works in this way, it is important to remember that
    the item may not exist within the slice of objects to lay out.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个接口将早期描述的布局管理器需要确定容器的最小尺寸以及处理容器中每个元素的定位进行了编码。由于容器的内容可能会随时改变，因此传递给 `Layout`
    或 `MinSize` 的 `CanvasObject` 元素切片可能会改变。因此，自定义布局应避免缓存对单个元素的引用。在某些情况下（例如我们之前看到的
    `BorderLayout`），布局可能会明确持有对象引用。如果你的布局以这种方式工作，重要的是要记住，项目可能不在布局的对象切片中存在。
- en: Most layouts should also skip hidden elements when calculating the minimum size
    or layout. There are some exceptions, however, particularly if elements are likely
    to be shown and hidden regularly. For example, a tab-based layout that shows only
    one content element at a time could cause windows to expand if hidden elements
    are larger than the ones that are currently visible. In this situation, it will
    be good for the user if layouts consider hidden elements in the `MinSize` code,
    even if they are not positioned in `Layout`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数布局在计算最小尺寸或布局时也应跳过隐藏元素。然而，有一些例外，尤其是如果元素可能会经常显示和隐藏。例如，一次只显示一个内容元素的基于标签的布局，如果隐藏的元素比当前可见的元素大，可能会导致窗口扩展。在这种情况下，如果布局在
    `MinSize` 代码中考虑隐藏元素，即使它们没有在 `Layout` 中定位，这对用户来说也是有益的。
- en: 'We shall create a short example of writing a custom layout:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个编写自定义布局的简短示例：
- en: 'This type, named `diagonal`, will position items of a container in a diagonal
    line from the top left down to the bottom right. We first implement `MinSize()`
    to return the sum of all visible objects (so that there is space to display them
    all in a diagonal line):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类型，命名为 `diagonal`，将容器中的项目定位在对角线上，从左上角到右下角。我们首先实现 `MinSize()` 来返回所有可见对象的总和（这样就有空间以对角线显示它们）：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then add the `Layout()` method, which is responsible for actually positioning
    each object. In this version, we simply declare a `topLeft` variable and position
    each visible object, adding to the value each time we have positioned and sized
    an element:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加 `Layout()` 方法，它负责实际定位每个对象。在这个版本中，我们简单地声明一个 `topLeft` 变量，并定位每个可见对象，每次定位和调整元素大小时都会向该值添加：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To apply this layout to a container, you would simply use the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此布局应用于容器，你只需使用以下方法：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s what we get:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果是：
- en: '![Figure 4.12 – Simple diagonal layout'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 简单的对角线布局'
- en: '](img/Figure_4.12_B16820.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.12_B16820.jpg](img/Figure_4.12_B16820.jpg)'
- en: Figure 4.12 – Simple diagonal layout
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 简单的对角线布局
- en: 'The example we saw sets up a static layout. The minimum size set for each item
    sets up the minimum size for `Container`, which no longer expands. An improved
    version of this layout would calculate the amount of extra space (the difference
    between the container''s `MinSize()` and the `size` argument passed into the `Layout()`
    function). An updated version of the `Layout()` function looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的例子设置了一个静态布局。为每个项目设置的最低大小确定了`Container`的最低大小，它不再扩展。这个布局的改进版本将计算额外空间（容器`MinSize()`与传递给`Layout()`函数的`size`参数之间的差异）。更新后的`Layout()`函数看起来如下所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s what we get after running the code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，我们得到以下结果：
- en: '![Figure 4.13 – Diagonal layout expanding to fill space'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.13 – 对角布局扩展以填充空间'
- en: '](img/Figure_4.13_B16820.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.13_B16820.jpg](img/Figure_4.13_B16820.jpg)'
- en: Figure 4.13 – Diagonal layout expanding to fill space
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.13 – 对角布局扩展以填充空间
- en: 'With this more advanced code, we no longer need to control the container with
    a minimum size for all items (though items would normally have a minimum size).
    In fact, we could just resize the container (or the app window) instead, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个更高级的代码，我们不再需要为所有项目使用最低大小来控制容器（尽管项目通常会有一个最低大小）。实际上，我们可以只调整容器的大小（或应用程序窗口）如下所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have explored the basics of how to lay out an application, we can
    start to look at bringing this together in a real application. The example that
    we will explore is an image browsing app that will lay out images and their metadata.
    However, before we can do this, we need to learn about file handling in a cross-platform
    context. If app developers assume users will have a filesystem or structure that
    matches their development system, it may not work on other devices, so understanding
    how to do this well is essential for ensuring that apps work well across all devices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何布局应用程序的基础知识，我们可以开始考虑在一个真实的应用程序中实现这一点。我们将要探索的例子是一个图像浏览应用程序，它将布局图像及其元数据。然而，在我们能够做到这一点之前，我们需要了解跨平台环境下的文件处理。如果应用程序开发者假设用户将有一个与他们的开发系统匹配的文件系统或结构，那么在其他设备上可能不起作用，因此了解如何做好这一点对于确保应用程序在所有设备上都能良好运行是至关重要的。
- en: Cross-platform file handling
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台文件处理
- en: The Go standard library has excellent support for file handling across its supported
    platforms. The `os` package allows access to the filesystem (files and directories)
    and utility packages such as `filepath` that help to parse and manage locations
    using the current operating system's semantics. While these operations are likely
    useful on most devices, they do not extend as well to non-desktop devices where
    a traditional filesystem is not what the end user is presented with.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库在其支持的平台上对文件处理提供了出色的支持。`os`包允许访问文件系统（文件和目录），以及如`filepath`之类的实用程序包，这些包有助于使用当前操作系统的语义解析和管理位置。虽然这些操作在大多数设备上可能很有用，但它们并不很好地扩展到非桌面设备，在这些设备上，传统的文件系统并不是最终用户所面对的。
- en: Consider mobile devices, for example. Both iOS and Android have a traditional
    filesystem internally, but the filesystem is not completely available to the device
    user, nor is it the only source of file data. An application will typically only
    have access to its own sandbox directory—reading and writing files outside of
    this space is not permitted—and on iOS, you may even need to request special permissions
    before accessing it. In addition to that, users now expect to be able to open
    data from other sources. For example, a file-sharing application such as Dropbox
    could provide a source of files that a user may wish to pass into your application,
    but this data is not accessible using standard file handling.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以移动设备为例。iOS和Android在内部都有传统的文件系统，但文件系统并不完全对设备用户开放，也不是文件数据的唯一来源。应用程序通常只能访问其自己的沙盒目录——不允许在此空间外读取和写入文件——在iOS上，您甚至可能需要请求特殊权限才能访问它。除此之外，用户现在还期望能够从其他来源打开数据。例如，像Dropbox这样的文件共享应用程序可能为用户提供文件来源，用户可能希望将其传递到您的应用程序中，但使用标准文件处理无法访问这些数据。
- en: For these reasons, the Fyne toolkit includes a simple storage abstraction that
    allows your application to handle data from any source, while managing permissions
    and security considerations for you. This interaction uses the concept of a **URI**
    to replace traditional file paths, allowing apps to operate without direct access
    to files and directories.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，Fyne工具包包括一个简单的存储抽象，允许您的应用程序处理来自任何来源的数据，同时为您管理权限和安全考虑。这种交互使用**URI**的概念来替换传统的文件路径，允许应用程序在没有直接访问文件和目录的情况下运行。
- en: URI
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URI
- en: At the core of the file handling abstraction is `fyne.URI` (here `http://` or
    `https://`. A URI may represent a filesystem object (where it would start with
    `file://`), a data stream from another app (where it may begin `content://`),
    or a remote resource (such as `sftp://` for a Secure File Transfer Protocol connection).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件处理抽象的核心是`fyne.URI`（此处为`http://`或`https://`。URI可能表示文件系统对象（它将以`file://`开头），来自另一个应用程序的数据流（它可能以`content://`开头），或远程资源（例如，`sftp://`用于安全文件传输协议连接）。
- en: 'Like the `os.File` type, `fyne.URI` is a reference to a resource, though it
    does not keep that resource open, so it may be passed around your application
    without issues. The underlying string representation of this URI can be accessed
    using the `String()` method. Use this if you wish to store the URI reference for
    later use, for example, in a configuration file or database. If you have a URI
    string representation, the original URI object can be accessed using utilities
    in the `storage` package, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与`os.File`类型类似，`fyne.URI`是对资源的引用，尽管它不会保持该资源打开，因此可以在应用程序中传递而不会出现问题。可以使用`String()`方法访问此URI的底层字符串表示。如果你希望将URI引用存储起来以供以后使用，例如在配置文件或数据库中，请使用此方法。如果你有一个URI字符串表示，可以使用`storage`包中的实用工具访问原始URI对象，如下所示：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Reading and writing
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入
- en: 'Accessing files when you are not certain where they are stored is a little
    more complicated than the traditional `os.Open()`; however, the Fyne `storage`
    package provides functionality to handle this. The two main functions for data
    access are `OpenFileFromURI` and `SaveFileToURI`, as shown in this excerpt from
    the package:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定文件存储在哪里时访问文件比传统的`os.Open()`要复杂一些；然而，Fyne的`storage`包提供了处理这种功能的方法。数据访问的两个主要函数是`OpenFileFromURI`和`SaveFileToURI`，如包中的摘录所示：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each of these functions take a URI (as described in the preceding code) for
    the location and returns `URIReadCloser` or `URIWriteCloser` on success and `error`
    if the operation failed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都接受一个URI（如前述代码所述）作为位置，在操作成功时返回`URIReadCloser`或`URIWriteCloser`，如果操作失败则返回`error`。
- en: As suggested by their names, these return types implement `io.ReadCloser` and
    `io.WriteCloser` with the addition of a `URI()` function to query the original
    resource identifier. You may not recognize these `io` interfaces, but you will
    have used them through `os.File`. This similarity means that you can use `URIReadCloser`
    in many places where you would have passed a file for a read operation, or `URIWriteCloser`
    if you were writing data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，这些返回类型实现了带有`URI()`函数的`io.ReadCloser`和`io.WriteCloser`，以查询原始资源标识符。你可能不认识这些`io`接口，但你可能已经通过`os.File`使用过它们。这种相似性意味着你可以在许多需要传递文件进行读取操作的地方使用`URIReadCloser`，或者在写入数据时使用`URIWriteCloser`。
- en: 'If you are processing the read or write operations yourself, it is important
    to remember to call `Close()` upon completion (as with any `io.Closer` stream).
    This is most commonly ensured by calling `defer reader.Close()` after checking
    for any error. The following code shows a simple example of reading a file from
    a URI:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自行处理读取或写入操作，记得在完成后调用`Close()`方法（就像任何`io.Closer`流一样）。这通常通过在检查任何错误后调用`defer
    reader.Close()`来确保。以下代码展示了从URI读取文件的简单示例：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: User file selection
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户文件选择
- en: 'The most common way for an application to open a file, at least initially,
    would be to prompt the user to choose the file they wish to open. The standard
    file-open dialog is available to provide this feature. An application can call
    `dialog.ShowFileOpen`, which will ask the user to select a file (with optional
    file filters). The chosen file will be returned through a callback function as
    `URIReadCloser`, as described earlier. If you wish to store a reference to the
    chosen file, you can use the `URI()` method to return the identifier. The following
    code shows this in action:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序打开文件的最常见方式，至少最初，是提示用户选择他们希望打开的文件。标准的文件打开对话框可用于提供此功能。应用程序可以调用`dialog.ShowFileOpen`，这将要求用户选择一个文件（可选的文件过滤器）。所选文件将通过回调函数以`URIReadCloser`的形式返回，如前所述。如果你希望存储所选文件的引用，可以使用`URI()`方法返回标识符。以下代码展示了这一操作：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similarly, there is `dialog.ShowFileSave` to start a file-write workflow such
    as the common *Save As* feature. For more information on the dialog package, see
    the *Dialogs* section in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有 `dialog.ShowFileSave` 来启动文件写入工作流程，例如常见的 *另存为* 功能。有关对话框包的更多信息，请参阅 [*第
    5 章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119) 的 *对话框* 部分，*小部件库和主题*。
- en: ListableURI
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ListableURI
- en: In some applications, it may be necessary to open a resource that contains other
    resources (just like a directory of files). For these situations, there is another
    type, `fyne.ListableURI`, which provides a `List()` method that returns a slice
    of `URI` items. This can be used in combination with `dialog.ShowDirectoryOpen`,
    which will return the user's selected location as `ListableURI`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，可能需要打开包含其他资源的资源（就像文件目录一样）。对于这些情况，还有一个类型，`fyne.ListableURI`，它提供了一个返回
    `URI` 项切片的 `List()` 方法。这可以与 `dialog.ShowDirectoryOpen` 结合使用，它将返回用户选择的 `ListableURI`
    位置。
- en: 'Let''s take a look at an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see in this example, once the user has made their selection, `ListableURI`
    is passed to our code. We can then iterate through the URI of each item inside
    the directory or collection using `range List()`. If you already have the name
    of a directory, then you can use `storage.ListerForURI(storage.NewFileURI(dirPath))`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，一旦用户做出选择，`ListableURI` 就会被传递到我们的代码中。然后我们可以使用 `range List()` 遍历目录或集合中每个项目的
    URI。如果您已经有了目录的名称，则可以使用 `storage.ListerForURI(storage.NewFileURI(dirPath))`。
- en: Let's put layouts and file handling into action. We will now build a simple
    image browsing application using all that we've seen till now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将布局和文件处理付诸实践。现在，我们将构建一个简单的图像浏览应用程序，使用到目前为止我们所看到的一切。
- en: Implementing an image browser application
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现图像浏览器应用程序
- en: This application will load a directory that contains some images, provide a
    summary of the content in a status bar at the bottom of the window, and use most
    of the space to show each image. The images will be loaded as thumbnails (smaller
    versions of the images) and we will display the image information under each thumbnail.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将加载包含一些图像的目录，在窗口底部的状态栏中提供内容摘要，并使用大部分空间来显示每个图像。图像将以缩略图（图像的小版本）形式加载，我们将在每个缩略图下方显示图像信息。
- en: Creating the layout
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建布局
- en: 'To start this example, we will create the layout of the application and the
    image items that will display in the central grid. Let''s understand each of these
    actions in detail:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个示例，我们将创建应用程序的布局以及将在中央网格中显示的图像项。让我们详细理解这些操作：
- en: 'First, we set up the image items. We wish to have the image name underneath
    the image. While this could be positioned manually, the items will be more responsive
    to changes in size if we use `BorderLayout`. We will create a `canvas.Text` element
    in the `bottom` position and use `canvas.Rectangle` to represent the image that
    we will load later:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们设置图像项。我们希望图像名称位于图像下方。虽然这可以通过手动定位实现，但如果使用 `BorderLayout`，项目对尺寸变化的响应将更加灵活。我们将在
    `bottom` 位置创建一个 `canvas.Text` 元素，并使用 `canvas.Rectangle` 来表示我们稍后要加载的图像：
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For the main application, we need to create the grid to contain image thumbnails
    as well as the status panel, which will be positioned later on. For the image
    grid, we will use `GridWrapLayout`. This version of a grid layout sizes all elements
    to a specified size and as the available space increases, the number of visible
    items will also increase. In this case, the user could increase the window size
    to see more images.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于主应用程序，我们需要创建一个网格来包含图像缩略图以及稍后定位的状态面板。对于图像网格，我们将使用 `GridWrapLayout`。这种网格布局将所有元素的大小调整为指定的尺寸，并且随着可用空间的增加，可见项目的数量也会增加。在这种情况下，用户可以通过增加窗口大小来看到更多图像。
- en: 'As we have not yet loaded the directory, we will fake the number of items (hardcoded
    to three by iterating over `{1, 2, 3}`). We create a list of items, calling `makeImageItem`
    for each one. This list is then passed to `NewGridWrap` after the `size` parameter
    (which is the size used for each item—a behavior specific to the grid wrap layout):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们尚未加载目录，我们将伪造项目数量（通过遍历 `{1, 2, 3}` 硬编码为三个）。我们为每个项目调用 `makeImageItem` 创建一个项目列表。然后，在
    `size` 参数（每个项目使用的尺寸——这是网格包装布局特有的行为）之后，将此列表传递给 `NewGridWrap`。
- en: '[PRE25]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To start, we will just create a text placeholder for the status for the purpose
    of laying out the app:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将只为状态创建一个文本占位符，用于布局应用程序：
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And finally, we will create a new container once again using `BorderLayout`
    to arrange the status bar beneath the rest of the content. By placing the image
    grid in the central space of `BorderLayout`, it will fill any available space
    as desired:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将再次使用 `BorderLayout` 创建一个新的容器来安排状态栏在其余内容下方。通过将图像网格放置在 `BorderLayout` 的中央空间，它将填充任何可用空间：
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To complete the application, we just need a short `main()` function that loads
    the Fyne application and creates a window, and we will resize it to larger than
    the minimum size so that the image grid layout will expand to multiple columns:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成应用程序，我们只需要一个简短的 `main()` 函数来加载 Fyne 应用程序并创建一个窗口，然后我们将将其调整到大于最小尺寸，以便图像网格布局可以扩展到多列：
- en: '[PRE28]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All we have to do now is run the combined code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在要做的就是运行组合代码：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running this will show the following window, ready for some real data and images
    to be loaded:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码将显示以下窗口，准备加载一些真实数据和图像：
- en: '![Figure 4.14 – The basic layout of our photos app'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 我们照片应用的基本布局'
- en: '](img/Figure_4.14_B16820.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B16820.jpg)'
- en: Figure 4.14 – The basic layout of our photos app
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 我们照片应用的基本布局
- en: Listing a directory
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出目录
- en: 'Before we can load images, we need to establish which directory we are loading
    when the application starts. Let''s take a look at the steps to do just that:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够加载图像之前，我们需要确定应用程序启动时加载的是哪个目录。让我们看看完成这一点的步骤：
- en: From the `main()` function, we will call a new `startDirectory` (that parses
    the app flags or falls back to the current working directory) and pass this into
    the `makeUI()` function. The directory path is converted to `ListableURI` by calling
    `ListerForURI` and `NewFileURI:`
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `main()` 函数中，我们将调用一个新的 `startDirectory`（解析应用标志或回退到当前工作目录）并将其传递给 `makeUI()`
    函数。目录路径通过调用 `ListerForURI` 和 `NewFileURI:` 转换为 `ListableURI`：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once `ListableURI` is passed into `makeUI`, we can use this `dir.List()` and
    filter it for image files before ranging over the URIs. A new function, `filterImages`,
    will take the directory list and return a slice of image URIs. To do this, a small
    `isImage()` function will help to filter:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `ListableURI` 被传递到 `makeUI`，我们就可以使用 `dir.List()` 并在遍历 URIs 之前过滤图像文件。一个新的函数
    `filterImages` 将接受目录列表并返回图像 URI 的切片。为此，一个小的 `isImage()` 函数将帮助过滤：
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With a slice of `fyne.URI` representing the images, we can update the status
    and image grid creation functions as well as updating the image label to use `URI.Name()`
    under each image placeholder:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代表图像的 `fyne.URI` 切片，我们可以更新状态和图像网格创建函数，以及更新图像标签以在每个图像占位符下使用 `URI.Name()`：
- en: '[PRE32]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Loading the images
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载图像
- en: 'Let''s now look at the steps to load images into our application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下将图像加载到我们应用程序中的步骤：
- en: 'To start with, we create a simple image load method that accepts a URI and
    returns `*canvas.Image`. The new `loadImage` function will then be used instead
    of the placeholder rectangle:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的图像加载方法，它接受一个 URI 并返回 `*canvas.Image`。然后，新的 `loadImage` 函数将用于代替占位符矩形：
- en: '[PRE33]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `makeImage` function should be updated to pass the `URI` item as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makeImage` 函数应该更新为按照以下方式传递 `URI` 项目：'
- en: '[PRE34]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then the line that creates the image inside the `makeImageItem` function as
    a rectangle can be replaced with the image created:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以将 `makeImageItem` 函数内部创建图像的线条替换为创建的图像：
- en: '[PRE35]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `loadImage` function, before returning `canvas.Image`, we changed `FillMode`
    from the default (`canvas.ImageFillStretch`) to `canvas.ImageFillContain` so that
    the image aspect ratio will be respected and the images will fit within the available
    space:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `loadImage` 函数中，在返回 `canvas.Image` 之前，我们将 `FillMode` 从默认值（`canvas.ImageFillStretch`）更改为
    `canvas.ImageFillContain`，这样图像的宽高比将被尊重，并且图像将适合可用空间：
- en: '![Figure 4.15 – Images and names loaded into the layout'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – 加载到布局中的图像和名称'
- en: '](img/Figure_4.15_B16820.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B16820.jpg)'
- en: Figure 4.15 – Images and names loaded into the layout
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 加载到布局中的图像和名称
- en: This code works as expected, as we can see in the figure, but it can be slow.
    We are loading the images before continuing with the user interface load. This
    does not make for a good user experience, so let's improve this situation by using
    background image loading.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按预期工作，如图所示，但它可能比较慢。我们在继续用户界面加载之前就加载了图像。这并不利于用户体验，所以让我们通过使用后台图像加载来改善这种情况。
- en: Loading the app faster
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速应用加载
- en: To avoid image sizes slowing down the loading of our user interface, we need
    to complete the construction of the application UI before the images load. This
    is called asynchronous (or background) loading and can be powerful if your app
    needs to use large amounts of resources.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免图像大小减慢用户界面的加载速度，我们需要在图像加载之前完成应用程序 UI 的构建。这被称为异步（或后台）加载，如果您的应用程序需要使用大量资源，这可能非常强大。
- en: The easiest way to load all the images in the background would be to start many
    goroutines. But, when displaying a large directory, that could become very slow
    indeed. Instead, we will use a single image load goroutine that will process one
    image at a time. (As an exercise, if you are feeling adventurous, you could expand
    this to process eight or more images at a time.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台加载所有图像的最简单方法就是启动许多 goroutine。但是，当显示大目录时，这可能会变得非常慢。相反，我们将使用单个图像加载 goroutine，一次处理一张图像。（作为一个练习，如果你感到好奇，你可以将其扩展到一次处理八张或更多的图像。）
- en: 'Let''s now take a look at how to do this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何做到这一点：
- en: 'To track the image loads, we will create a new type called `bgImageLoad` that
    will reference the URI of the image to load and the `*canvas.Image` item that
    it should be loaded into. We additionally need to create a channel (we''ll name
    it `loads`) that will enqueue the items to load. We buffer this at `1024` items,
    which represents a large directory—an implementation to handle unbounded numbers
    of files might need us to be a little smarter:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪图像加载，我们将创建一个新的类型 `bgImageLoad`，它将引用要加载的图像的 URI 以及它应该加载到的 `*canvas.Image`
    项目。我们还需要创建一个通道（我们将它命名为 `loads`），它将排队要加载的项目。我们在 `1024` 项处缓冲它，这代表了一个大目录——处理无界文件数量的实现可能需要我们更聪明一些：
- en: '[PRE36]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When loading images in this updated version, we will create an empty Fyne `*canvas.Image`
    that will later have the image loaded. We then queue the details of this image
    `URI`, for loading once the goroutine is able to process it:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载此更新版本的图像时，我们将创建一个空的 Fyne `*canvas.Image`，稍后将在其中加载图像。然后我们排队此图像 `URI` 的详细信息，以便在
    goroutine 能够处理它时加载：
- en: '[PRE37]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We move the image load code to a new `doLoadImage` function that will run in
    the background. In this version, we want to do all of the slow parts of image
    loading; so, we load and decode the image, convert it to a Go in-memory image
    to display, and leave the user interface much more responsive to updates, resizing,
    and so on.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将图像加载代码移动到新的 `doLoadImage` 函数中，该函数将在后台运行。在这个版本中，我们想要做所有图像加载的慢速部分；因此，我们加载并解码图像，将其转换为用于显示的内存中的图像，并让用户界面对更新、调整大小等更加响应。
- en: 'The new function, `doLoadImages`, will range over all the items being added
    to the channel and call `doLoadImage` to load them one at a time. The image load
    code will refresh the image `CanvasObject` after loading the raw data, so each
    item appears as it is loaded:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的函数 `doLoadImages` 将遍历所有添加到通道中的项目，并逐个调用 `doLoadImage` 来加载它们。图像加载代码将在加载原始数据后刷新图像
    `CanvasObject`，因此每个项目都会在加载时出现：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To make sure that the images are loaded, we launch `doLoadImages` as a goroutine
    within the `main()` function:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保图像已加载，我们在 `main()` 函数中启动 `doLoadImages` 作为 goroutine：
- en: '[PRE39]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, in the preceding code, we referenced `scaleImage`. This means that
    each image we display is a smaller version of the full-sized image. This is necessary
    when the directory we browse contains very large images. The toolkit will attempt
    to paint very large images quite small, which can be very slow. Instead, we reduce
    the size of our images to fit inside the space available in each grid cell. We
    used larger numbers (twice the cell size) so that high-density displays still
    give a good-looking result.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在前面提到的代码中，我们引用了 `scaleImage`。这意味着我们显示的每一张图像都是全尺寸图像的小版本。当浏览的目录包含非常大的图像时，这是必要的。工具包将尝试将非常大的图像画得很小，这可能会非常慢。相反，我们将图像的大小减小，以适应每个网格单元中可用的空间。我们使用了较大的数字（单元格大小的两倍），这样高密度显示仍然可以给出良好的效果。
- en: 'The following code snippet makes use of the helpful `github.com/nfnt/resize`
    package to scale images. Although the `image` package in Go is often helpful,
    it does not contain efficient scaling routines. We use this library and request
    `Lanczos3` interpolation, which provides a balance between speed and quality when
    downscaling images:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段使用了有用的 `github.com/nfnt/resize` 包来缩放图像。尽管 Go 中的 `image` 包通常很有帮助，但它不包含高效的缩放例程。我们使用这个库并请求
    `Lanczos3` 插值，这在上采样图像时提供了速度和质量之间的平衡：
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `resize.Thumbnail` function creates a smaller image that fits within the
    stated size, which is ideal for our purpose so we can avoid worrying about aspect
    ratios and calculations.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`resize.Thumbnail`函数创建一个适合指定大小的小图像，这对于我们的目的非常理想，因此我们可以避免担心宽高比和计算。'
- en: 'Using the updated code will create a quick-to-load and responsive user interface
    for even large directories containing very large images. There we have it: resizing,
    which could have been slow when using full-sized images, is now much faster!'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的代码将为即使是包含非常大的图像的大目录创建快速加载和响应式的用户界面。这就是我们想要的：当使用全尺寸图像时可能较慢的调整大小操作，现在变得更快了！
- en: Creating a custom layout for the image elements
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为图像元素创建自定义布局
- en: The space taken up by labels in this example could be a bit wasted, so let's
    make a custom layout that writes the text over the bottom edge of each image.
    We will use a semi-transparent background to make the text more readable and a
    small gradient to blend from the text background to the image.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，标签所占用的空间可能有点浪费，因此让我们创建一个自定义布局，该布局将文本写入每个图像的底部边缘。我们将使用半透明背景使文本更易于阅读，并使用小渐变从文本背景到图像进行混合。
- en: 'To build a custom layout, we need to define a type (`itemLayout` in this case)
    that implements the `MinSize` and `Layout` functions from the `fyne.Layout` interface.
    As the background, gradient, and text all have special positions, we will save
    a reference to these canvas objects so that they can be arranged later:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建自定义布局，我们需要定义一个类型（在本例中为`itemLayout`），该类型实现了`fyne.Layout`接口中的`MinSize`和`Layout`函数。由于背景、渐变和文本都有特殊的位置，我们将保存对这些画布对象的引用，以便稍后进行排列：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code will ensure that each of the elements of our container is positioned
    in the correct place. `text` and `bg` are bottom aligned with `gradient` positioned
    above the text background. Any other element (in this case, our image thumbnail)
    will be positioned at the fill size that the layout is asked to fill.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将确保我们的容器中的每个元素都定位在正确的位置。`text`和`bg`与`gradient`底部对齐，而任何其他元素（在本例中为我们的图像缩略图）将定位在布局请求填充的填充大小。
- en: 'To use this layout, we update the `makeImageItem` function to use `&itemLayout`
    as the container layout. Into this constructor, we pass a new `canvas.Rectangle`
    and `canvas.Gradient` to be used for the effect described previously. It is important
    to pass the image before the text background and pass the text element last to
    `NewContainerWithLayout`, as this sets up the order that these elements will be
    drawn:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此布局，我们更新`makeImageItem`函数，使其使用`&itemLayout`作为容器布局。在这个构造函数中，我们传递一个新的`canvas.Rectangle`和`canvas.Gradient`，用于实现之前描述的效果。在将图像传递给文本背景之前，并将文本元素最后传递给`NewContainerWithLayout`，这是设置这些元素绘制顺序的重要步骤：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With these changes, we can run the code once more and see how our new layout
    makes each image preview larger in the same amount of space, while giving the
    application a little flair:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改后，我们可以再次运行代码，看看我们的新布局如何使每个图像预览在相同的空间内更大，同时给应用程序增添一点风采：
- en: '![Figure 4.16 – Custom layout for images and their labels'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.16 – 自定义图像及其标签的布局'
- en: '](img/Figure_4.16_B16820.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.16 – 自定义图像及其标签的布局](img/Figure_4.16_B16820.jpg)'
- en: Figure 4.16 – Custom layout for images and their labels
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.16 – 自定义图像及其标签的布局
- en: 'Last of all, you may have noticed that directories with many images will force
    the window to expand, and so you may want to add scrolling to the grid container.
    To do so, we will use one of the helpers from the container package mentioned
    earlier, adding `container.Scroll` around the image grid container. It just requires
    replacing the `content` creation line of the `makeUI` function with this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能已经注意到，包含许多图像的目录会强制窗口扩展，因此你可能希望向网格容器添加滚动。为此，我们将使用之前提到的容器包中的一个辅助工具，在图像网格容器周围添加`container.Scroll`。这只需要将`makeUI`函数的`content`创建行替换为以下内容：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Changing a directory
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改目录
- en: In addition to loading a specified directory, we may wish to allow users to
    open a different directory once the application is open. To add this functionality,
    we will use the `SetMainMenu` function on `Window`, which sets up a structure
    to populate a menu bar.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加载指定的目录外，我们可能希望在应用程序打开后允许用户打开不同的目录。为此，我们将使用`Window`上的`SetMainMenu`函数，该函数设置了一个结构来填充菜单栏。
- en: 'Using the `NewMainMenu`, `NewMenu`, and `NewMenuItem` helper functions in the
    `fyne` package, we set up a structure that defines the `chooseDirectory` when
    clicked (we also pass in the current window so we can show a dialog from that
    function). The following code gets added to the `main()` function just before
    `Window.ShowAndRun()`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fyne`包中的`NewMainMenu`、`NewMenu`和`NewMenuItem`辅助函数，我们设置了一个结构，定义了点击时`chooseDirectory`的行为（我们也传递了当前窗口，以便可以从该函数中显示对话框）。以下代码被添加到`main()`函数中，在`Window.ShowAndRun()`之前：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To support this menu operation, we need to create the `chooseDirectory` function.
    This will call `dialog.ShowDirectoryOpen`, which asks the user to select a directory
    on their computer. This functions much like the `ShowFileOpen` call we explored
    before, with the exception that the parameter returned in the callback is `ListableURI`
    instead of `URIReadCloser`. Using this parameter (after checking for any error),
    we can call `makeUI` with this new location and update our whole application''s
    user interface:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个菜单操作，我们需要创建`chooseDirectory`函数。这将调用`dialog.ShowDirectoryOpen`，提示用户在他们的电脑上选择一个目录。这个功能与之前我们探索的`ShowFileOpen`调用类似，只是回调中返回的参数是`ListableURI`而不是`URIReadCloser`。使用这个参数（在检查任何错误之后），我们可以调用`makeUI`并使用这个新位置来更新我们整个应用程序的用户界面：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we were building a more complex application, then simply calling `Window.SetContent`
    would not be the most efficient approach. In that situation, we would save a reference
    to the main `fyne.Container` and update just the image grid instead of the entire
    application. However, the final version of our application should look like the
    following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在构建一个更复杂的应用程序，那么仅仅调用`Window.SetContent`并不是最高效的方法。在这种情况下，我们会保存对主`fyne.Container`的引用，并只更新图像网格而不是整个应用程序。然而，我们应用程序的最终版本应该看起来像以下截图：
- en: '![Figure 4.17 – Adding a main menu'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17 – 添加主菜单'
- en: '](img/Figure_4.17_B16820.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B16820.jpg)'
- en: Figure 4.17 – Adding a main menu
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – 添加主菜单
- en: 'Note that when running on macOS, the default behavior is to show menus in the
    desktop menu bar—this can be overridden using the `no_native_menus` build tag,
    as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在macOS上运行时，默认行为是在桌面菜单栏中显示菜单——这可以通过使用`no_native_menus`构建标签来覆盖，如下所示：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter stepped through the details of how layouts work, the details of
    all the built-in layouts in the toolkit, and when to use them. We also saw how
    simple it is to combine multiple layouts and created our own custom layout to
    add a bit of flair to our image browsing application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了布局的工作原理，工具包中所有内置布局的详细信息以及何时使用它们。我们还看到了如何轻松地组合多个布局，并创建了我们自己的自定义布局，为我们的图片浏览应用程序增添了一些风采。
- en: We also explored how to adapt file handling code to work across all platforms
    using the `URI` and `ListableURI` types. Using this knowledge, our image browsing
    application is now compatible with all desktop and mobile platforms. With this
    knowledge of how to lay out applications and avoid assumptions about a traditional
    filesystem, you can now ensure that your apps will function correctly on any supported
    platforms, mobile, desktop, and beyond.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何使用`URI`和`ListableURI`类型来调整文件处理代码以跨所有平台工作。利用这些知识，我们的图片浏览应用程序现在与所有桌面和移动平台兼容。通过了解如何布局应用程序并避免对传统文件系统的假设，你现在可以确保你的应用程序在任何支持的平台上都能正确运行，包括移动、桌面以及更多。
- en: While we have created a complete application using just canvas primitives and
    layouts, it is possible to build much more complex applications using the `widget`
    package, which we will look at in the next chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只使用画布原语和布局创建了一个完整的应用程序，但使用`widget`包可以构建更复杂的应用程序，我们将在下一章中探讨。
