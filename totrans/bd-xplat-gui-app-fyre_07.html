<html><head></head><body>
		<div id="_idContainer092">
			<h1 id="_idParaDest-118"><em class="italic"><a id="_idTextAnchor119"/>Chapter 5</em>: Widget Library and Themes</h1>
			<p>A large part of the Fyne toolkit is its library of standard widgets, which provides simple visual elements, manages user input, and handles application workflows. These widgets handle how information and user input is displayed, as well as container options for organizing the user interface and managing standard workflows. The themes that come with the Fyne toolkit support both light and dark versions, both of which support user color preferences while adapting all the user interface elements so that they look great in both modes.</p>
			<p>In this chapter, we’re going to explore the widgets available in the Fyne toolkit and how to use them. We will be covering the following topics:</p>
			<ul>
				<li>Exploring the design of the Fyne Widget API</li>
				<li>Introducing the basic widgets</li>
				<li>Grouping with the collection widgets</li>
				<li>Adding structure with container widgets</li>
				<li>Using common dialogs</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with all the Fyne widgets and how the theme capabilities work to control their appearance. By combining widgets and containers, you will have built your first complete Fyne-based graphical user interface.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Technical requirements</h1>
			<p>This chapter has the same requirements as <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Windows, Canvas, and Drawing</em> – that is, you must have the Fyne toolkit installed and a Go and C compiler working. For more information, please refer to the previous chapter.</p>
			<p>The full source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05</a>.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Exploring the design of the Widget API</h1>
			<p>As <a id="_idIndexMarker240"/>we described in <a href="B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">The Future According to Fyne</em>, its APIs are designed to convey semantic meaning rather than a list of features. This is followed on by the Widget definition, whereby we add APIs that describe behavior and hide the details of rendering. The interface that all widgets must implement is simply an extension of the basic <strong class="source-inline">CanvasObject</strong> object (introduced in <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Window, Canvas, and Drawing</em>), which adds a <strong class="source-inline">CreateRenderer()</strong> method. It is defined in the source code as follows:</p>
			<p class="source-code">// Widget defines the standard behaviors of any widget.</p>
			<p class="source-code">// This extends the CanvasObject - a widget behaves in </p>
			<p class="source-code">// the same basic way but will encapsulate many child</p>
			<p class="source-code">// objects to create the rendered widget.</p>
			<p class="source-code">type Widget interface {</p>
			<p class="source-code">        CanvasObject</p>
			<p class="source-code">        CreateRenderer() WidgetRenderer</p>
			<p class="source-code">}</p>
			<p>The new <strong class="source-inline">CreateRenderer()</strong> method is used by Fyne to determine how the widget should look. There is no public API for accessing the current renderer – instead, state is set in a <strong class="source-inline">Widget</strong> and each renderer will refresh its output to match this state. This design strongly encourages APIs to focus on behavior and intent rather than directly manipulating the graphical output (which could quickly lead to inconsistent or unusable applications).</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>Focus on behavior</h2>
			<p>By enforcing <a id="_idIndexMarker241"/>a separation between widget state and its visual representation, each <strong class="source-inline">Widget</strong> is forced to expose an API that describes behavior or intent instead of visual attributes or internal details. This is important for continuing the design principle of a semantic API, which leads to a more concise API focused on expected outcomes over graphical tweaks.</p>
			<p>Commonly, changes in state will need to be reflected by a <strong class="source-inline">WidgetRender</strong> updating in some way. How the graphical representation will change is controlled by the renderer, and it is triggered by calling <strong class="source-inline">Widget.Refresh()</strong>. This refresh is normally handled by the widget code; for example, the <strong class="source-inline">Button.SetText()</strong> function’s code is as follows:</p>
			<p class="source-code">// SetText allows the button label to be changed</p>
			<p class="source-code">func (b *Button) SetText(text string) {</p>
			<p class="source-code">    b.Text = text</p>
			<p class="source-code">    b.Refresh()</p>
			<p class="source-code">}</p>
			<p>The call to <strong class="source-inline">Refresh()</strong> queues a request asking for the widget rendering to be updated, which<a id="_idIndexMarker242"/> will result in graphical updates in the next update of the screen. On some widgets, calling the <strong class="source-inline">Refresh</strong> function can cause a lot of calculations. If you have lots of changes to apply to a widget, you may not wish it to refresh after every line. To help with this, there is also a direct field access approach that ensures it doesn’t need to be called as often.</p>
			<p>Methods versus field access</p>
			<p>As discussed in the<a id="_idIndexMarker243"/> previous section, refreshing a widget, especially a complex one, can be time-consuming, and if many updates must be performed, the user may notice a slight delay. If a developer wishes to update multiple aspects of a widget, then it is possible (though perhaps unlikely) that one change may be applied before a visual redraw and the others happen just after. Although another draw will occur, it may be noticeable that they did not change together. Consider the following code:</p>
			<p class="source-code">func updateMyButton(b *widget.Button) {</p>
			<p class="source-code">    b.SetText("sometext")</p>
			<p class="source-code">    b.SetIcon(someResource)</p>
			<p class="source-code">}</p>
			<p>When using method-based updates, the <strong class="source-inline">SetText()</strong> and <strong class="source-inline">SetIcon()</strong> calls will refresh the widget, possibly causing the slight delay mentioned previously. It is recommended to call <strong class="source-inline">Refresh()</strong> only when needed; to make this possible, a developer can access the widget state directly and refresh the object manually. This is known as <strong class="bold">field-based access</strong> as <a id="_idIndexMarker244"/>we directly change the exported fields of a widget. For example, we could rewrite the preceding code like so:</p>
			<p class="source-code">func updateMyButton(b *widget.Button) {</p>
			<p class="source-code">    b.Text = "sometext"</p>
			<p class="source-code">    b.Icon = someResource</p>
			<p class="source-code">    b.Refresh()</p>
			<p class="source-code">}</p>
			<p>By taking this approach, we ensure that <strong class="source-inline">Refresh()</strong> is called just once so that both changed elements will redraw at the same time. This offers a smoother result for the user and will lead to lower CPU<a id="_idIndexMarker245"/> usage as well.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Rendering a widget </h2>
			<p>The <strong class="source-inline">CreateRenderer()</strong> method <a id="_idIndexMarker246"/>mentioned earlier will return a new renderer instance that defines how the widget will be presented on-screen. The toolkit is responsible for calling this method and it will cache the result while the widget is visible. Developers should not call this directly as the result will have no connection to what is displayed.</p>
			<p>The exact lifetime of a renderer varies and is a combination of the widget’s visibility, its parent’s visibility, and whether the window is currently shown. The <strong class="source-inline">WidgetRenderer</strong> definition for a widget may be unloaded during its application life cycle. A new instance will be requested if the widget becomes visible again at a later date. If a renderer is no longer needed, then its <strong class="source-inline">Destroy()</strong> method will be called. The full definition of a widget renderer is as follows and has been taken from the API documentation:</p>
			<p class="source-code">// WidgetRenderer defines the behavior of a widget’s</p>
			<p class="source-code">// implementation. This is returned from a widget’s main</p>
			<p class="source-code">// object through the CreateRenderer() function.</p>
			<p class="source-code">type WidgetRenderer interface {</p>
			<p class="source-code">    Layout(Size)</p>
			<p class="source-code">    MinSize() Size</p>
			<p class="source-code">    Refresh()</p>
			<p class="source-code">    Objects() []CanvasObject</p>
			<p class="source-code">    Destroy()</p>
			<p class="source-code">}</p>
			<p>The first two methods in the <strong class="source-inline">WidgetRenderer</strong> definition (<strong class="source-inline">Layout()</strong> and <strong class="source-inline">MinSize()</strong>) should be familiar from <a href="B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Layout and File Handling</em> – they define a container layout. In this instance, the container is this widget and the objects that are being controlled are the visual components used to render the widget – they are returned from the <strong class="source-inline">Objects()</strong> method. The <strong class="source-inline">Refresh()</strong> method of a <strong class="source-inline">WidgetRenderer</strong> is called internally when a visible widget needs to be redrawn.</p>
			<p>The <strong class="source-inline">Objects()</strong> method call returns a list of each <strong class="source-inline">CanvasObject</strong> required to render the widget it describes. This is a slice of items from the <strong class="source-inline">canvas</strong> package such as <strong class="source-inline">Text</strong>, <strong class="source-inline">Rectangle</strong>, and <strong class="source-inline">Line</strong>. These items will be arranged using the layout methods described previously to create the final widget presentations. It is important that the color of each element match, or blend with, the current theme. When the <strong class="source-inline">Refresh()</strong> function is called, it may be in <a id="_idIndexMarker247"/>response to a theme change, so any custom values should be updated accordingly in that code.</p>
			<p>Now that we know how widgets work, let’s look at what is built into the toolkit.</p>
			<p>Introducing the basic widgets</p>
			<p>The most used <a id="_idIndexMarker248"/>package in Fyne (or any GUI toolkit) is likely the <strong class="source-inline">widget</strong> package. This contains all the standard widgets that will be useful to most graphical apps. The collection is split into basic widgets (for simple data display or user input) and collection widgets (<strong class="source-inline">List</strong>, <strong class="source-inline">Table</strong>, and <strong class="source-inline">Tree</strong>) that are used to display large or more complex data. In this section, we’ll step through the basic widgets in alphabetical order to see how they look and how to add them to an app.</p>
			<p>Accordion</p>
			<p>The accordion widget<a id="_idIndexMarker249"/> is used to fit large amounts of content into a<a id="_idIndexMarker250"/> small area by showing and hiding items so that only one of the child elements is visible at a time. Each item has a header button that is used to show or hide the content below it. This can be seen in the following image, which shows an accordion widget in the light and the dark themes:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_5.1_B16820.jpg" alt="Figure 5.1 – An accordion widget with item B expanded, shown in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – An accordion widget with item B expanded, shown in the light and dark themes</p>
			<p>To create an <strong class="source-inline">Accordion</strong> widget, you must pass a list of <strong class="source-inline">AccordionItem</strong> objects that specify the title and details for each element in the accordion. You can also optionally specify the <strong class="source-inline">Open</strong> value, which, if set to <strong class="source-inline">true</strong>, will show the content by default. The following<a id="_idIndexMarker251"/> code block <a id="_idIndexMarker252"/>was used to create the previous <strong class="source-inline">Accordion</strong> images:</p>
			<p class="source-code">acc := widget.NewAccordion(</p>
			<p class="source-code">    widget.NewAccordionItem("A", widget.NewLabel("Hidden")),</p>
			<p class="source-code">    widget.NewAccordionItem("B", widget.NewLabel("Shown         	        item")),</p>
			<p class="source-code">    widget.NewAccordionItem("C", widget.NewLabel("End")),</p>
			<p class="source-code">)</p>
			<p class="source-code">acc.Items[1].Open = true</p>
			<p>By default, an <strong class="source-inline">Accordion</strong> widget shows only one item at a time. To allow any number of items to be shown, you can set the <strong class="source-inline">MultiOpen</strong> field to <strong class="source-inline">true</strong>.</p>
			<p>Button</p>
			<p>The <strong class="source-inline">Button</strong> widget<a id="_idIndexMarker253"/> provides a standard press button that can be activated by <a id="_idIndexMarker254"/>clicking it with a mouse (or by using the tap gesture on a touch screen). A button can contain text or icon content, or both. The <strong class="source-inline">Button</strong> constructor function also takes an anonymous <strong class="source-inline">func</strong> that is executed when the button is tapped.</p>
			<p>You can create a button using the <strong class="source-inline">widget.NewButton</strong> or <strong class="source-inline">widget.NewButtonWithIcon</strong> constructor functions. It is recommended to use the built-in theme icons where possible (for more information, please see the <em class="italic">Themes</em> section later in this chapter), as follows:</p>
			<p class="source-code">widget.NewButtonWithIcon("Cancel", theme.CancelIcon(), func() {})</p>
			<p>The button in each theme is shown in the following image:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_5.2_B16820.jpg" alt="Figure 5.2 – A button with its icon shown in light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – A button with its icon shown in light and dark themes</p>
			<p>Most buttons have the<a id="_idIndexMarker255"/> same look, but if you need one to stand out, you can set it to have a high importance style by setting <strong class="source-inline">Button.Importance = widget.HighImportance</strong>, as shown in the following image:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_5.3_B16820.jpg" alt="Figure 5.3 – A high importance button in both light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – A high importance button in both light and dark themes</p>
			<p>The color used to represent high<a id="_idIndexMarker256"/> importance widgets will vary based on the theme and can even be set by the user. Another possible value for <strong class="source-inline">Button.Importance</strong> is <strong class="source-inline">widget.LowImportance</strong>, which reduces the visual impact of the display, for example, by removing the shadow shown in the previous two images.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Card</h2>
			<p>When<a id="_idIndexMarker257"/> the elements<a id="_idIndexMarker258"/> of the user interface relate to each other, it can be useful to group them together. This can be helpful when a group of items should be titled or where many different data elements want a larger preview than a simple list. A collection of <strong class="source-inline">Card</strong> widgets may be added to a <strong class="source-inline">Container</strong> with a grid layout to arrange similar items that display different content (such as search results or a preview of media items).</p>
			<p>A card widget can be <a id="_idIndexMarker259"/>created using the <strong class="source-inline">NewCard</strong> constructor function, which takes a title and subtitle string, as well as a <strong class="source-inline">CanvasObject</strong> content parameter. You can also specify the <strong class="source-inline">Image</strong> field after constructing or by creating the struct manually, as shown in<a id="_idIndexMarker260"/> the following code block:</p>
			<p class="source-code">widget.NewCard("Card Title", "Subtitle",</p>
			<p class="source-code">    widget.NewLabel("Content"))</p>
			<p class="source-code">&amp;widget.Card(Title: "Card Title",</p>
			<p class="source-code">    Subtitle: "Subtitle",</p>
			<p class="source-code">    Image: canvas.NewImageFromResource(theme.FyneIcon()))</p>
			<p>You can see the preceding code utilizing the light and dark themes in the following image:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_5.4_B16820.jpg" alt="Figure 5.4 – The card widget showing its titles and an image in light and dark modes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The card widget showing its titles and an image in light and dark modes</p>
			<p>All the fields that were used in the preceding code are optional. An empty string for either of the titles will remove it from the display, and a nil image or content removes it as well (you can see the missing content in the previous image).</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor125"/>Check</h2>
			<p>Checkbox<a id="_idIndexMarker261"/> functionality is provided by the <strong class="source-inline">Check</strong> widget. It has two states: checked and unchecked (the default). The constructor takes a callback function, <strong class="source-inline">func(bool)</strong>, that will be <a id="_idIndexMarker262"/>called whenever the checked state changes, passing the current state (<strong class="source-inline">true</strong> means checked). The code for this is as follows:</p>
			<p class="source-code">widget.NewCheck("Check", func(bool) {})</p>
			<p>You can also manually set the checked state by calling the <strong class="source-inline">SetChecked</strong> method and passing <strong class="source-inline">true</strong> (or <strong class="source-inline">false</strong> to change it back to unchecked):</p>
			<p class="source-code">check.SetChecked(true)</p>
			<p>The different checked states, one in each theme, are shown in the following image:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_5.5_B16820.jpg" alt="Figure 5.5 – A light theme checkbox checked, and a dark theme checkbox unchecked&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – A light theme checkbox checked, and a dark theme checkbox unchecked</p>
			<p>The checked indicator will adapt to the current theme, just like the text does.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>Entry</h2>
			<p>Text input is primarily added <a id="_idIndexMarker263"/>through the <strong class="source-inline">Entry</strong> widget, which provides free text entry. A content hint<a id="_idIndexMarker264"/> can be added to a field by setting a <strong class="source-inline">Placeholder</strong>, and the text content can be set directly with the <strong class="source-inline">Text</strong> field or the <strong class="source-inline">SetText()</strong> method. Entries can be created with one of the following constructors. The first is a normal text field, the second is a password entry, and the third is used for multiline input (defaults to 3 lines):</p>
			<p class="source-code">widget.NewEntry()</p>
			<p class="source-code">widget.NewPasswordEntry()</p>
			<p class="source-code">widget.NewMultilineEntry()</p>
			<p>The following image shows the standard and password entry widgets using the default themes:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_5.6_B16820.jpg" alt="Figure 5.6 – Entry and PasswordEntry widgets in light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Entry and PasswordEntry widgets in light and dark themes</p>
			<p>The entry widget also supports validation, which can be used to give the user feedback on the current text. The different states can be seen in the following image:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_5.7_B16820.jpg" alt="Figure 5.7 – Validation status of success and failure using the light theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Validation status of success and failure using the light theme</p>
			<p>While typing, an entry<a id="_idIndexMarker265"/> with a validator set will provide positive feedback when the content is <a id="_idIndexMarker266"/>valid. Invalid content will show a warning when the user stops editing the input.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>FileIcon</h2>
			<p>In addition to using static<a id="_idIndexMarker267"/> icons (see the Icon section, later in this section), the toolkit can display appropriate icons for different types of files. The <strong class="source-inline">FileIcon</strong> widget<a id="_idIndexMarker268"/> was created to make this common task much easier, by loading one of the standard icon resources and showing the file extension inside it. The icon matches the size of the standard <strong class="source-inline">widget.Icon</strong> and its image and text will be updated to reflect the specified URI. <strong class="source-inline">FileIcon</strong> widgets can be created by specifying the URI of a file resource, as follows:</p>
			<p class="source-code">file := storage.NewFileURI("images/myimage.png")</p>
			<p class="source-code">widget.NewFileIcon(file)</p>
			<p>The preceding code will be rendered as follows, depending on the current theme:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_5.8_B16820.jpg" alt="Figure 5.8 – The Fileicon widget showing the symbol and extension of a PNG image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – The Fileicon widget showing the symbol and extension of a PNG image</p>
			<p><strong class="source-inline">FileIcon</strong> widgets will vary their appearance, setting icons appropriate for the file type.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/>Form</h2>
			<p>The form widget<a id="_idIndexMarker269"/> is useful for labeling and laying out various input elements. Each<a id="_idIndexMarker270"/> row of a form typically contains an input element with a label next to it. If the form has an <strong class="source-inline">OnSubmit</strong> or <strong class="source-inline">OnCancel</strong> function set, then it will automatically generate an additional row containing the appropriate action buttons.</p>
			<p>You can create a form by passing a list of <strong class="source-inline">FormItem</strong> objects into the <strong class="source-inline">NewForm()</strong> constructor function, as follows:</p>
			<p class="source-code">form := widget.NewForm(</p>
			<p class="source-code">    widget.NewFormItem("Username", widget.NewEntry()),</p>
			<p class="source-code">    widget.NewFormItem("Password", widget.NewPasswordEntry()),</p>
			<p class="source-code">)</p>
			<p class="source-code">form.OnCancel = func() {</p>
			<p class="source-code">    fmt.Println("Cancelled")</p>
			<p class="source-code">}</p>
			<p class="source-code">form.OnSubmit = func() {</p>
			<p class="source-code">    fmt.Println("Form submitted")</p>
			<p class="source-code">}</p>
			<p>You can also call <strong class="source-inline">Form.Append()</strong> to add elements later. The form will look as follows, depending on the current theme:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_5.9_B16820.jpg" alt="Figure 5.9 – A login form shown in light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – A login form shown in light and dark themes</p>
			<p>An additional benefit of <a id="_idIndexMarker271"/>grouping input elements into a form is that it can help ensure that only validated<a id="_idIndexMarker272"/> input is submitted. If any of the widgets have a validator set, then the form will only allow submission once all the validators have passed.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>Hyperlink</h2>
			<p>In some situations, it can be helpful to provide a tappable URL string that opens a web page in the user’s browser. For this<a id="_idIndexMarker273"/> use case, there is a <strong class="source-inline">Hyperlink</strong> widget<a id="_idIndexMarker274"/> that accepts a <strong class="source-inline">URL</strong> parameter for the page to open when it’s tapped. To create a hyperlink widget, we may need to parse a URL, as shown in the following code snippet:</p>
			<p class="source-code">href, _ := url.Parse("https://fyne.io")</p>
			<p class="source-code">widget.NewHyperlink("fyne.io", href)</p>
			<p>The widget looks as follows:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_5.10_B16820.jpg" alt="Figure 5.10 – A hyperlink widget using the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – A hyperlink widget using the light and dark themes</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Icon</h2>
			<p>Although you can add a <strong class="source-inline">canvas.Image</strong> to a user interface directly, it can sometimes be useful to have a consistent size. The <strong class="source-inline">Icon</strong> widget<a id="_idIndexMarker275"/> provides this, loading a standard <a id="_idIndexMarker276"/>resource and setting its minimum size to the theme-defined icon size. The icon will also update to match the current theme. We can create an icon that shows the standard paste image using the following code:</p>
			<p class="source-code">widget.NewIcon(theme.ContentPasteIcon())</p>
			<p>The preceding code will be rendered as follows, depending on the current theme:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_5.11_B16820.jpg" alt="Figure 5.11 – The icon widget showing the paste icon in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – The icon widget showing the paste icon in the light and dark themes</p>
			<p>Next, we move on to the label widget.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Label</h2>
			<p>Displaying text is normally <a id="_idIndexMarker277"/>recommended using the <strong class="source-inline">Label</strong> widget. It is possible to use <strong class="source-inline">canvas.Text</strong> but, as we saw in <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Windows, Canvas, and Drawing</em>, those elements use a <a id="_idIndexMarker278"/>developer-defined color – in most user interfaces, it is preferable for the text to match the current theme, which is what the <strong class="source-inline">Label</strong> widget takes care of:</p>
			<p class="source-code">widget.NewLabel("Text label")</p>
			<p>The label widget in each theme looks as follows:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_5.12_B16820.jpg" alt="Figure 5.12 – A text label in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – A text label in the light and dark themes</p>
			<p>This widget also supports additional text formatting such as newline, word wrap, and truncation. A string containing <a id="_idIndexMarker279"/>the newline character (<strong class="source-inline">\n</strong>) will be broken into a second line and be fully visible, whereas<a id="_idIndexMarker280"/> setting <strong class="source-inline">Label.Wrapping = fyne.TextWrapWord</strong> (or <strong class="source-inline">fyne.TextWrapBreak</strong>) will automatically add new lines when the widget’s width requires it. Setting the value to <strong class="source-inline">fyne.TextWrapTruncate</strong> will simply remove overflowing text from the display.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Pop-up menu</h2>
			<p>The <strong class="source-inline">PopUpMenu</strong> widget<a id="_idIndexMarker281"/> is helpful for displaying context menus or allowing a<a id="_idIndexMarker282"/> user to choose from options where a built-in widget is not providing the desired functionality. To create a menu in this way, you need a <strong class="source-inline">fyne.Menu</strong> data structure that describes the options available (this is the same structure we used in <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Windows, Canvas, and Drawing</em>, for the main menu). In this case, the title of the menu can be empty as it will not be displayed.</p>
			<p>Once the menu has been defined, the <strong class="source-inline">ShowPopUpMenuAtPosition</strong> utility function is the easiest way to display this to the user. This function takes an absolute position in the window and displays the menu in the top-left corner. As with other pop-up elements, this can be dismissed by tapping outside of the content shown, thereby returning the user to the previous state. You can use the following code to do this:</p>
			<p class="source-code">menu := fyne.NewMenu("", fyne.NewMenuItem("An item", func() {}))</p>
			<p class="source-code">pos := fyne.NewPosition(20, 20)</p>
			<p class="source-code">widget.ShowPopUpMenuAtPosition(menu, myWindow.Canvas(), pos)</p>
			<p>The preceding code will create a new menu over the current content of the window. The result will look as follows:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_5.13_B16820.jpg" alt="Figure 5.13 – PopUpMenu shown in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – PopUpMenu shown in the light and dark themes</p>
			<p>It is also possible to use the <strong class="source-inline">Menu</strong> widget directly here. The <strong class="source-inline">widget.NewMenu</strong> constructor function can <a id="_idIndexMarker283"/>be used to render a menu without it creating an overlay <a id="_idIndexMarker284"/>like <strong class="source-inline">PopUpMenu</strong> does.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>ProgressBar</h2>
			<p>If an application needs to indicate that a process will take some time to perform, then you can use the <strong class="source-inline">ProgressBar</strong> widget. There are<a id="_idIndexMarker285"/> two variations: <strong class="source-inline">widget.ProgressBar</strong> and <strong class="source-inline">widget.ProgressBarInfinite</strong>. A regular progress bar shows a<a id="_idIndexMarker286"/> current <strong class="source-inline">Value</strong> ranging from <strong class="source-inline">Min</strong> to <strong class="source-inline">Max</strong> (default <em class="italic">0</em> to <em class="italic">1</em>), and the developer is responsible for setting the value as the process progresses. When using the infinite progress bar, there is no intrinsic value, so the output renders an animation that indicates an activity (a change in the value) for an undefined duration. We can create a progress bar using one of the following lines:</p>
			<p class="source-code">bar1 := widget.NewProgressBar()</p>
			<p class="source-code">bar2 := widget.NewProgressBarInfinite()</p>
			<p>These two versions of the progress bar look as follows, with <strong class="source-inline">bar1</strong> on the left and <strong class="source-inline">bar2</strong> on the right:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_5.14_B16820.jpg" alt="Figure 5.14 – The standard and infinite progress bars shown with light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – The standard and infinite progress bars shown with light and dark themes</p>
			<p>If you wish to add a different<a id="_idIndexMarker287"/> text overlay for the regular progress widget, then you can <a id="_idIndexMarker288"/>use the <strong class="source-inline">TextFormatter</strong> field, setting a function which returns a string value. This can be formatted based on the widget’s state or something different such as the <strong class="source-inline">loading...</strong> string.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>RadioGroup</h2>
			<p>The radio group widget is the most common<a id="_idIndexMarker289"/> way of requesting user input. The outcome is similar to the <strong class="source-inline">Select</strong> widget (discussed next), but the options are all visible. The <strong class="source-inline">RadioGroup</strong> widget<a id="_idIndexMarker290"/> can be created by specifying a slice of string values that will be listed as options. The second parameter is a callback that will execute each time the selection is changed, passing the new value into the function:</p>
			<p class="source-code">widget.NewRadioGroup([]string{"Item 1", "Item 2"}, func(s string) {</p>
			<p class="source-code">    fmt.Println("Selected", s)</p>
			<p class="source-code">})</p>
			<p>The radio group widget looks as follows in the different themes:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_5.15_B16820.jpg" alt="Figure 5.15– A radio group with two options, top selected, in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15– A radio group with two options, top selected, in the light and dark themes</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Select</h2>
			<p>Like the preceding <strong class="source-inline">RadioGroup</strong> widget, the <strong class="source-inline">Select</strong> widget<a id="_idIndexMarker291"/> allows the user to choose one item from a list. It is <a id="_idIndexMarker292"/>more common to use <strong class="source-inline">Select</strong> when the list of options is long or the space that’s available is small. This widget appears as a button showing the current value. When tapped, this will show a popup menu that lists the options that are available:</p>
			<p class="source-code">widget.NewSelect([]string{"Item 1", "Item 2"}, func(s string) {</p>
			<p class="source-code">    fmt.Println("Selected", s)</p>
			<p class="source-code">})</p>
			<p>The <strong class="source-inline">Select</strong> widget <a id="_idIndexMarker293"/>looks as follows<a id="_idIndexMarker294"/> in the different themes:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_5.16_B16820.jpg" alt="Figure 5.16 – The select widget shown in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – The select widget shown in the light and dark themes</p>
			<p>Next is the <strong class="source-inline">SelectEntry</strong> widget.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/>SelectEntry</h2>
			<p><strong class="source-inline">SelectEntry</strong> is <a id="_idIndexMarker295"/>much like the <strong class="source-inline">Select</strong> widget described previously, except that it <a id="_idIndexMarker296"/>allows user-defined options as well. This can be done by presenting an <strong class="source-inline">Entry</strong> widget with a select-style drop-down icon that lists the specified options. Because the current value can change on every keystroke, the callback for this widget is configured like <strong class="source-inline">Entry</strong> rather than <strong class="source-inline">Select</strong> – it is not passed as a select change function in the constructor but can instead be set on the <strong class="source-inline">OnChanged</strong> field of the widget:</p>
			<p class="source-code">widget.NewSelectEntry([]string{"Item 1", "Item 2"})</p>
			<p>The <strong class="source-inline">SelectEntry</strong> widget looks as follows:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_5.17_B16820.jpg" alt="Figure 5.17 – The SelectEntry widget before input is added in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – The SelectEntry widget before input is added in the light and dark themes</p>
			<p>Next is the <strong class="source-inline">Slider</strong> widget.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Slider</h2>
			<p>The <strong class="source-inline">Slider</strong> widget<a id="_idIndexMarker297"/> can be used for inputting a number within a range, particularly when <a id="_idIndexMarker298"/>the exact number may not be known to the user. This can be useful, for example, when specifying brightness or volume – the number is not important to the end user, but it has a clear range from <strong class="source-inline">Min</strong> to <strong class="source-inline">Max</strong>. </p>
			<p>A <strong class="source-inline">Slider</strong> widget can be created by specifying <strong class="source-inline">Min</strong> and <strong class="source-inline">Max</strong> values through the constructor. Its default value will be set to the minimum, and this can be changed by setting <strong class="source-inline">Slider.Value</strong>. It is also possible to specify a <strong class="source-inline">Step</strong> value, which defines the distance between each valid value. Without a defined step, any floating-point value between the minimum and maximum will be allowed. By specifying <strong class="source-inline">Step</strong>, you could, for example, accept only integer values. In this mode, the user may see the slider "jump" from one valid value to another as they slide the widget:</p>
			<p class="source-code">widget.NewSlider(0, 100)</p>
			<p>The preceding code will create a simple slider widget set to the minimum value, as shown in the following image:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_5.18_B16820.jpg" alt="Figure 5.18 – The Slider widget shown at its minimum in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – The Slider widget shown at its minimum in the light and dark themes</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>TextGrid</h2>
			<p>Although the <strong class="source-inline">Label</strong> widget (described earlier) does provide some text formatting, there are some applications that require styles to be applied per-character. For syntax highlighting in a code editor or for showing error rows indicated on a console output, there is the <strong class="source-inline">TextGrid</strong> widget.</p>
			<p>Inside a <strong class="source-inline">TextGrid</strong> widget<a id="_idIndexMarker299"/>, the content is split into each rune of the string representation, and<a id="_idIndexMarker300"/> each rune has a <strong class="source-inline">TextGridStyle</strong> applied to it. This style allows the foreground and background color to be specified for each character or cell of the grid. Additionally, each row of the grid can have a style specified. This style will be used for any cell that does not have its own style specified. If a cell has a character and a row style available, the two will be combined so that the foreground color that’s been set on the cell will adopt a background color from the row; that is, unless the character style specifies both.</p>
			<p>Despite the styles that allow specific colors to be set, there are a number of semantic style definitions that allow code to annotate intent instead of absolute colors. One of the most commonly used styles is <strong class="source-inline">TextGridStyleWhitespace</strong> that uses the theme definition to show characters in a muted color. Using the built-in styles, a developer can delegate to the current theme to define colors for each intent.</p>
			<p>The <strong class="source-inline">TextGrid</strong> widget also<a id="_idIndexMarker301"/> provides common functionality for technical text displays, including <strong class="source-inline">ShowLineNumbers</strong>, which displays the line number at the beginning of each<a id="_idIndexMarker302"/> row. Also, <strong class="source-inline">ShowWhitespace</strong> can be set to true for a visual indicator of otherwise invisible spacing characters such as tab, space, and newline. The following code example illustrates some of the ways you can control text in a <strong class="source-inline">TextGrid</strong>:</p>
			<p class="source-code">grid := widget.NewTextGridFromString(</p>
			<p class="source-code">    "TextGrid\n  Content  ")</p>
			<p class="source-code">grid.SetStyleRange(0, 4, 0, 7,</p>
			<p class="source-code">    &amp;widget.CustomTextGridStyle{BGColor:</p>
			<p class="source-code">        &amp;color.NRGBA{R: 64, G: 64, B: 192, A: 128}})</p>
			<p class="source-code">grid.Rows[1].Style = &amp;widget.CustomTextGridStyle{BGColor:</p>
			<p class="source-code">        &amp;color.NRGBA{R: 64, G: 192, B: 64, A: 128}}</p>
			<p class="source-code">grid.ShowLineNumbers = true</p>
			<p class="source-code">grid.ShowWhitespace = true</p>
			<p>The following image shows the result of the preceding code. Here, we can see that a background style has been applied to all the cells used in the 4 letters of <em class="italic">Grid</em> and that a row style has been applied to the second row (index 1). They also have line numbers and the whitespace options turned on:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_5.19_B16820.jpg" alt="Figure 5.19 – Styled content presented using TextGrid in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – Styled content presented using TextGrid in the light and dark themes</p>
			<p>The style for a cell can be assigned using the <strong class="source-inline">SetStyle</strong> method. However, when the style needs to be applied to many runes, developers can use the more efficient <strong class="source-inline">SetStyleRange</strong> utility<a id="_idIndexMarker303"/> method. The <strong class="source-inline">SetRowStyle</strong> method can assist in setting row styles, as<a id="_idIndexMarker304"/> shown in the previous image.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Toolbar</h2>
			<p>If there are lots of regularly<a id="_idIndexMarker305"/> accessed features in an application, the <strong class="source-inline">Toolbar</strong> widget can be an efficient way to present these options. The main elements of a toolbar <a id="_idIndexMarker306"/>are the <strong class="source-inline">ToolbarAction</strong> items, which are simple icons that, when tapped, execute a function parameter that’s been passed to <strong class="source-inline">NewToolbarAction</strong>. To group action elements, you can use <strong class="source-inline">ToolbarSeparator</strong>, which creates a visual divider between the item on its left and right. Additionally, a gap can be created between actions using the <strong class="source-inline">ToolbarSpacer</strong> type. This will expand, causing the elements after it to be right aligned. Using one spacer will show items before it on the left and items after it on the right. Using two will mean that the elements between the spacers will be central in the toolbar.</p>
			<p>To construct a toolbar containing four action elements and a separator, we can use the following code:</p>
			<p class="source-code">widget.NewToolbar(</p>
			<p class="source-code">     widget.NewToolbarAction(theme.MailComposeIcon(),</p>
			<p class="source-code">         func() {}),</p>
			<p class="source-code">     widget.NewToolbarSeparator(),</p>
			<p class="source-code">     widget.NewToolbarSpacer(),</p>
			<p class="source-code">     widget.NewToolbarAction(theme.ContentCutIcon(),</p>
			<p class="source-code">         func() {}),</p>
			<p class="source-code">     widget.NewToolbarAction(theme.ContentCopyIcon(),</p>
			<p class="source-code">         func() {}),</p>
			<p class="source-code">     widget.NewToolbarAction(theme.ContentPasteIcon(),</p>
			<p class="source-code">         func() {}),</p>
			<p class="source-code">)</p>
			<p>The preceding code snippet results in the following. The following image shows it in both the light and dark themes:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_5.20_B16820.jpg" alt="Figure 5.20 – Toolbar widget with some possible icons in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – Toolbar widget with some possible icons in the light and dark themes</p>
			<p>The widgets that we have<a id="_idIndexMarker307"/> explored so far are fairly standard and can be created with simple constructors, or through initializing the struct directly. Some of these take a callback function that <a id="_idIndexMarker308"/>can be used to inform us when an action has occurred. </p>
			<p>In the next section, we’ll look at some more complex widgets that are designed to manage thousands of sub-widgets. To do so, we will learn how they make use of more function parameters to query large datasets and efficiently display a subset of the data.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor140"/>Grouping with the collection widgets</h1>
			<p>In this section, we will look at <a id="_idIndexMarker309"/>widgets that are designed to efficiently contain main widgets. Some of the widgets mentioned in the previous section do this, such as <strong class="source-inline">Form</strong> and <strong class="source-inline">Toolbar</strong>, but <strong class="bold">collection widgets</strong> support thousands of items (though they’re not all visible at one time). These widgets are commonly used for <a id="_idIndexMarker310"/>displaying a huge numbers of options or navigating complex datasets.</p>
			<p>Due to the requirement that collection widgets only show large amounts of data, they are designed to only show a small portion of the possible widget at a time. To do this, and to maintain great performance, they have a caching mechanism that makes their API a little more complex than the widgets we have seen previously.</p>
			<p>Callbacks</p>
			<p>Each of these <a id="_idIndexMarker311"/>widgets relies on a number of callback functions. The first of these functions will provide information on the dimensions of the data that the widget will display (for a more complete discussion on data, see <a href="B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Binding and Storage</em>). The second of these is responsible for creating visual elements that will be displayed later, while the third will load an item from the data into a previously created element. </p>
			<p>Caching</p>
			<p>The key to the<a id="_idIndexMarker312"/> performance of collection widgets is how they cache the graphical elements that repeat within them. The template objects referenced in collection widget constructors will be reused as the user scrolls the widget to maintain performance and keep up with the user actions.</p>
			<p>The <strong class="source-inline">List</strong> widget (and other collection widgets) maintains an internal cache of recently used template elements that will have new data applied in preparation for the next rows becoming visible. It is the job of the application developer to optimize data retrieval so that any items that are close to those that are already visible will load quickly. We will see these concepts in use as we explore the various collection widgets that are available to us. First, we will look at the List widget.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/>List</h2>
			<p>The <strong class="source-inline">List</strong> widget is used <a id="_idIndexMarker313"/>to display a vertical list of items where each item has a similar look. The relevant data can be loaded once the widget has been created, so it can be helpful if the data is slow to load or complex to display. The widget will only load and display the elements that are visible, thereby displaying the elements of a large dataset quickly.</p>
			<h3>Callbacks</h3>
			<p>Each of the collection widgets uses <a id="_idIndexMarker314"/>callback functions to understand the data, load a template item, and update it when the data is loaded. Let’s look at these in more detail:</p>
			<ul>
				<li>Understanding the data – the <strong class="source-inline">Length</strong> callback: The first callback function for <strong class="source-inline">List</strong> is the <strong class="source-inline">length</strong> callback, which returns the number of items in the data. This tells the widget how many rows it will need to manage. If more items are added to the dataset, this value can be updated, and next time the list refreshes, it will adjust accordingly.</li>
				<li>Loading a template – the <strong class="source-inline">CreateItem</strong> callback: The second callback function is used to generate a reusable graphical element that will load data. This is called<a id="_idIndexMarker315"/> a <strong class="bold">template</strong> item. The return value of this function is a <strong class="source-inline">CanvasObject</strong> and can be any type of <strong class="source-inline">Widget</strong>, <strong class="source-inline">Container</strong>, or item from the <strong class="source-inline">canvas</strong> package. The widget will call this function as many times as there are items visible on the screen. At this stage, they should contain just placeholder values. For example, in the images that follow, each row contains an icon and a label, so the returned template would probably be a container with a horizontal box layout, along with a default icon and placeholder text in the label. Although the user will never see the placeholder values, they are important as the size of a template configures the <strong class="source-inline">List</strong> component. The height of a template item will be used for the height of every row so that when it’s multiplied by the result of the previous length, the callback will determine the overall scroll height of the list component. Additionally, the template width will specify the minimum width for the <strong class="source-inline">List</strong> component.</li>
				<li>Filling the template<a id="_idIndexMarker316"/> with data – the <strong class="source-inline">UpdateItem</strong> callback: Callback three is used to apply data to a template cell. It receives two parameters: the index of the data item to use and the <strong class="source-inline">CanvasObject</strong> template that we configured earlier. The purpose of this callback is to configure the item with the data that should be used at the specified index. The template that’s used will be identical to the return object of the second parameter so that it can be cast appropriately.</li>
			</ul>
			<p>Each collection widget has variations of the pattern described previously, as we will see in the <em class="italic">Table</em> and <em class="italic">Tree</em> sections later in this chapter.</p>
			<h3>Selection</h3>
			<p>One additional feature <a id="_idIndexMarker317"/>of the collection widgets is that they allow an element to be selected (by being tapped). In the list interface, the selected element is indicated by a marker at the leading edge, as shown in the preceding image. To be notified when an item is selected, you can set a <strong class="source-inline">func(ListItemID)</strong> callback on the <strong class="source-inline">OnSelected</strong> field, which will notify you of which item from the dataset was selected. The basic code for creating a list is as follows:</p>
			<p class="source-code">widget.NewList(</p>
			<p class="source-code">    func() int { return 3 },</p>
			<p class="source-code">    func() fyne.CanvasObject {</p>
			<p class="source-code">        icon := widget.NewIcon(theme.FileIcon())</p>
			<p class="source-code">        label := widget.NewLabel("List item x")</p>
			<p class="source-code">        return container.NewHBox(icon, label)</p>
			<p class="source-code">    },</p>
			<p class="source-code">    func(index ListItemID, template fyne.CanvasObject) {</p>
			<p class="source-code">        cont := template.(*fyne.Container)</p>
			<p class="source-code">        label := cont.Objects[1].(*widget.Label)</p>
			<p class="source-code">        label.SetText(fmt.Sprintf("List item %v", index))</p>
			<p class="source-code">    })</p>
			<p>The code sample will <a id="_idIndexMarker318"/>generate the following output, once the second item has been tapped:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_5.21_B16820.jpg" alt="Figure 5.21 – List collection widget with an item selected in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – List collection widget with an item selected in the light and dark themes</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>Table</h2>
			<p>The <strong class="source-inline">Table</strong> widget<a id="_idIndexMarker319"/> is a two-dimensional version of the <strong class="source-inline">List</strong> widget and is designed for showing large datasets with row and column aspects. It uses the same system for caching and callbacks as the <strong class="source-inline">List</strong> and <strong class="source-inline">Tree</strong> widgets.</p>
			<h3>Callbacks</h3>
			<p>The <strong class="source-inline">Table</strong> widget’s callbacks <a id="_idIndexMarker320"/>are similar to those for <strong class="source-inline">List</strong>, but the data identifiers pass a row and column <strong class="source-inline">int</strong> to index the data structure. This means that the <strong class="source-inline">Length</strong> callback now returns <strong class="source-inline">(int, int)</strong>.</p>
			<p>The callback that sets up new graphical templates in the <strong class="source-inline">Table</strong> version (called <strong class="source-inline">CreateCell</strong>) takes no parameters and just returns a <strong class="source-inline">fyne.CanvasObject</strong> that will be cached for use in the display. This template is used to determine the default size of all cells, so make sure that it has a sensible minimum size. As with <strong class="source-inline">List</strong>, the element you return here will not be presented to the user but will be used for measurements and configuring the overall layout.</p>
			<p>The last required callback is <strong class="source-inline">UpdateCell</strong> and is used to apply data to a template element. In the <strong class="source-inline">Table</strong> widget, this function passes a data identifier (<strong class="source-inline">TableCellID</strong>, which contains a <strong class="source-inline">Row</strong> and <strong class="source-inline">Col</strong> int) that indexes the data to apply, as well as the <strong class="source-inline">CanvasObject</strong> template. Developers should fill in the template with the appropriate data specified by the identifier. As with other collection widgets, it is recommended, where possible, to load<a id="_idIndexMarker321"/> related data so that when the user scrolls or expands an element, any data that takes a long time to load is ready to be displayed.</p>
			<h3>Selection</h3>
			<p>The <strong class="source-inline">Table</strong> widget<a id="_idIndexMarker322"/> supports a selected cell, as is indicated by a marker at the leading edge and header, as shown in the following image. To be notified of when an item has been selected, you can set the <strong class="source-inline">func(TableCellID)</strong> callback on the <strong class="source-inline">OnSelected</strong> field. This will notify you of which item from the dataset was selected by passing the identifying row and column. The basic code for creating a new table is as follows:</p>
			<p class="source-code">widget.NewTable(</p>
			<p class="source-code">    func() (int, int) { return 3, 3 },</p>
			<p class="source-code">    func() fyne.CanvasObject {</p>
			<p class="source-code">        return widget.NewLabel("Cell 0, 0")</p>
			<p class="source-code">    },</p>
			<p class="source-code">    func(id TableCellID, template fyne.CanvasObject) {</p>
			<p class="source-code">        label := template.(*widget.Label)</p>
			<p class="source-code">        label.SetText(fmt.Sprintf("Cell %d, %d", id.Row+1,      	            id.Col+1))</p>
			<p class="source-code">    })</p>
			<p>The preceding code will generate the following output, assuming cell 2, 1 is tapped to gain selection:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_5.22_B16820.jpg" alt="Figure 5.22 – Table collection widget showing selection in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22 – Table collection widget showing selection in the light and dark themes</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Tree</h2>
			<p>The <strong class="source-inline">Tree</strong> widget<a id="_idIndexMarker323"/> is very similar to the <strong class="source-inline">List</strong> widget, but with the added feature that each element can expand to show other items. This expansion is used to show a hierarchy, such as directories and files, categories and items, or other data with a parent-child relationship present.</p>
			<h3>Callbacks</h3>
			<p>The <strong class="source-inline">Tree</strong> widget’s <a id="_idIndexMarker324"/>callbacks are similar to <strong class="source-inline">List</strong> and <strong class="source-inline">Table</strong>, but its more complex data structure means that the simple <strong class="source-inline">Length</strong> callback is replaced by <strong class="source-inline">ChildUIDs</strong> and <strong class="source-inline">IsBranch</strong>. The first of these callbacks will return a slice of <strong class="source-inline">TreeNodeID</strong> values (regular strings can be used) that contain the unique identifier for each item that exists under the specified node (passed in as a unique <strong class="source-inline">TreeNodeID</strong>). The second is called for each element while passing the unique ID. It should return <strong class="source-inline">true</strong> if it can container further nodes, or <strong class="source-inline">false</strong> otherwise.</p>
			<p>The callback that sets up new graphical templates in the <strong class="source-inline">Tree</strong> version (called <strong class="source-inline">CreateNode</strong>) takes a bool parameter that represents if this is a branch (<strong class="source-inline">true</strong>, can expand) or a leaf (<strong class="source-inline">false</strong>, this is the end of the tree). This is useful if you want to use a different style for the branch and leaf elements within your tree. As with <strong class="source-inline">List</strong>, the element you return here will not be presented to the user but will be used for measurements and configuring the overall layout.</p>
			<p>The last required callback is <strong class="source-inline">UpdateNode</strong>. This is used to apply data to a template element. In the <strong class="source-inline">Tree</strong> widget, this function passes the unique <strong class="source-inline">TreeNodeID</strong> identifier, a <strong class="source-inline">bool</strong> representing whether this is a branch or leaf template, and the <strong class="source-inline">CanvasObject</strong> template. Developers should fill in this template with the appropriate data specified by the identifier. As with other collection widgets, it is recommended, where possible, to load related data so that when the user scrolls or expands an element, data that loads slowly is ready to be displayed.</p>
			<p>Additionally, regarding the<a id="_idIndexMarker325"/> callbacks that are required to manage content, the <strong class="source-inline">Tree</strong> widget allows developers to set the <strong class="source-inline">OnBranchOpened</strong> and <strong class="source-inline">OnBranchClosed</strong> callbacks so that they can track changes in the state of the tree. Both functions are of the <strong class="source-inline">func(TreeNodeID)</strong> type, where the parameter is the unique identifier of the data item.</p>
			<h3>Selection</h3>
			<p>The <strong class="source-inline">Tree</strong> widget also <a id="_idIndexMarker326"/>supports selected nodes. This is indicated by a marker at the leading edge, as shown in the following image. To be notified of when an item has been selected, you can set the <strong class="source-inline">func(TreeNodeID)</strong> callback on the <strong class="source-inline">OnSelected</strong> field. This will notify you of which item of the dataset was selected, while passing the unique identifier. The basic code required to show a tree is as follows. The first callback is returning the unique IDs of the children at each level:</p>
			<p class="source-code">     func(uid TreeNodeID) []string { </p>
			<p class="source-code">         switch uid {</p>
			<p class="source-code">         case "":</p>
			<p class="source-code">             return []string{"cars", "trains"}</p>
			<p class="source-code">         case "cars":</p>
			<p class="source-code">             return []string{"ford", "tesla"}</p>
			<p class="source-code">         case "trains":</p>
			<p class="source-code">             return []string{"rocket", "tgv"}</p>
			<p class="source-code">         }</p>
			<p class="source-code">     return ""</p>
			<p class="source-code">     },</p>
			<p class="source-code">     func(uid TreeNodeID) bool {</p>
			<p class="source-code">         return uid == "" || uid == "cars" || uid == "trains"</p>
			<p class="source-code">     },</p>
			<p class="source-code">     func(_ bool) fyne.CanvasObject {</p>
			<p class="source-code">         return widget.NewLabel("Template")</p>
			<p class="source-code">     },</p>
			<p class="source-code">     func(uid TreeNodeID, _ bool, template fyne.CanvasObject) {</p>
			<p class="source-code">         label := template.(*widget.Label)</p>
			<p class="source-code">         label.SetText(strings.Title(uid))</p>
			<p class="source-code">     })</p>
			<p>The preceding code will<a id="_idIndexMarker327"/> display a tree in the app. Once the second element has been expanded, this tree will look as follows:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_5.23_B16820.jpg" alt="Figure 5.23 – Tree widget with the branch expanded, shown in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23 – Tree widget with the branch expanded, shown in the light and dark themes</p>
			<p>The three collection widgets shown in this section provide useful functionality for presenting large or complex data. The API is a little more complex than the standard widgets, but this allows massive datasets to be presented to users; for example, by scrolling through thousands of records from a database or showing parts of a large file tree.</p>
			<p>There’s a selection of container widgets that we can use to build out more complex user interface designs and navigate through applications. We will discover these in the following section.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor144"/>Adding structure with container widgets</h1>
			<p>In <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Window, Canvas, and Drawing</em>, we learned how a <strong class="source-inline">Container</strong> is used to group multiple objects <a id="_idIndexMarker328"/>within a canvas. Using the layouts we explored in <a href="B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Layout and File Handling</em>, it is possible to automatically <a id="_idIndexMarker329"/>arrange each <strong class="source-inline">CanvasObject</strong> according to certain rules. However, sometimes, an application would like items to appear and disappear according to user interaction, or to have visual attributes beyond their size and position. Container widgets can provide these richer behaviors. These structural widgets can be found in the <strong class="source-inline">container</strong> package and include scrolling, grouping, and variations of hiding and showing content. Let’s explore each of these options (in alphabetical order).</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/>AppTabs</h2>
			<p>The <strong class="source-inline">AppTabs</strong> container<a id="_idIndexMarker330"/> is used for controlling large areas of an application where the content should be switched out based on the current activity. For example, this may be<a id="_idIndexMarker331"/> used to fit lots of graphical elements into a small application user interface when only sub-sections are useful at one time.</p>
			<p>Each tab in a tab container can contain text and/or an icon (whichever combination is used should be consistent for all items). Each tab has an associated <strong class="source-inline">CanvasObject</strong> (usually a container) that will be shown when the tab is selected. These are created using <strong class="source-inline">TabItem</strong> objects that have been passed to the <strong class="source-inline">NewAppTabs</strong> constructor function. To create two tabs with icons and labels, you would use the following code:</p>
			<p class="source-code">container.NewAppTabs(</p>
			<p class="source-code">     container.NewTabItemWithIcon("Tab1", theme.HomeIcon(),      	         tab1Screen),</p>
			<p class="source-code">     container.NewTabItemWithIcon("Tab2", theme.MailSendIcon(),  	         tab2Screen))</p>
			<p>The preceding code will render as one of the following containers:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_5.24_B16820.jpg" alt="Figure 5.24 – Two tabs with text and icons in an AppTabs widget using the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24 – Two tabs with text and icons in an AppTabs widget using the light and dark themes</p>
			<p>The preceding image shows the tabs in their default orientation. However, the tab container can show tabs on any one of the four edges. The <strong class="source-inline">SetTabLocation()</strong> function takes one of the <strong class="source-inline">TabLocation</strong> types; that is, <strong class="source-inline">TabLocationTop</strong>, <strong class="source-inline">TabLocationBottom</strong>, <strong class="source-inline">TabLocationLeading</strong> (normally the left-hand side) or <strong class="source-inline">TabLocationTrailing</strong> (after content – normally on the right-hand side). The following image shows how the <a id="_idIndexMarker332"/>tab’s location can change the icon’s layout:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_5.25_B16820.jpg" alt="Figure 5.25 – Tab containers at the bottom, with leading and trailing locations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25 – Tab containers at the bottom, with leading and trailing locations</p>
			<p>When running the <a id="_idIndexMarker333"/>application on a mobile device, it is expected for tabs to be on the top or bottom in portrait mode. Therefore, the locations will adapt appropriately – the leading setting will show the tabs at the top, while the trailing setting will stets the tabs at the bottom. If the mobile device is rotated, then the tabs will move to the left or right edge – leaving more space for content. In landscape mode, any tabs that have requested the top position will be shown on the leading (left-hand side) edge; the bottom setting will move to the trailing (right-hand side) edge. </p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor146"/>Scroll</h2>
			<p>Most of the widgets that<a id="_idIndexMarker334"/> need to scroll content include the functionality to do so. However, if you want to add scrolling capabilities to your content, you can use the <strong class="source-inline">Scroll</strong> container. By wrapping<a id="_idIndexMarker335"/> some other element in a scroll container, you add scrollbars on the horizontal and vertical dimensions. The constructor function for scrolling in both the horizontal and vertical dimensions is <strong class="source-inline">container.NewScroll()</strong>. You can also call <strong class="source-inline">NewHScroll()</strong> if you would only like to scroll horizontally, or <strong class="source-inline">NewVScroll()</strong> if you would only like to scroll vertically. The following image shows full scrolling on simple label content:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_5.26_B16820.jpg" alt="Figure 5.26 – Scroll container showing a scrollbar and shadow in the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.26 – Scroll container showing a scrollbar and shadow in the light and dark themes</p>
			<p>As you can see, the minimum size <a id="_idIndexMarker336"/>for a scroll container becomes very small – just 32x32. If <a id="_idIndexMarker337"/>you use the horizontal scroller, then its minimum height will fit the content, while if you use the vertical scroller (such as a list), then the width will adapt to fit the content.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Split</h2>
			<p>The <strong class="source-inline">Split</strong> container provides <a id="_idIndexMarker338"/>us with a neat way to separate two parts of our application <a id="_idIndexMarker339"/>when we would like our users to be able to change the amount of space available for each section. This can be split horizontally or vertically. A horizontal split container displays two elements side by side with a split bar between them. The vertical split will stack elements one above the other with a split bar in-between:</p>
			<p class="source-code">right := container.NewVSplit(</p>
			<p class="source-code">    widget.NewLabel("Top"), widget.NewLabel("Bottom"))</p>
			<p class="source-code">container.NewHSplit(widget.NewLabel("Line1/nLine2"), right)</p>
			<p>In the following image, you can see a horizontal split container with <strong class="source-inline">Line1\nLine2</strong> on the left-hand (leading) side and a vertical split containing <strong class="source-inline">Top</strong> and <strong class="source-inline">Bottom</strong> on the right-hand (trailing) side:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">In horizontal mode, the leading position (first parameter) is normally on the left, while in vertical mode, it will be on the top.</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_5.27_B16820.jpg" alt="Figure 5.27 – The Split widget in horizontal and vertical modes using the light and dark themes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.27 – The Split widget in horizontal and vertical modes using the light and dark themes</p>
			<p>The split container allows the bar to be dragged to change the size allocated to each side of the split. The container’s minimum size will be the sum of the two contents (plus the split) and unless it is in a parent container with more space, the bar will not be draggable. When there is more space available, then dragging the bar will change where the extra space is allocated.</p>
			<p>Developers can also manually <a id="_idIndexMarker340"/>specify the proportion directly using the <strong class="source-inline">Offset</strong> field. A value<a id="_idIndexMarker341"/> of <strong class="source-inline">0.0</strong> means that the split should be as far left (or up) as possible, while a value of <strong class="source-inline">1.0</strong> means it should be fully right (or bottom aligned). This value can be queried during app runtime if you want to save the user’s preference.</p>
			<p>As well as composing standard widgets together to form a clear and logical user interface, it is sometimes useful to display temporary information or request user input. For cases where developers or designers do not want to include this in their main interface, there is a package of standard popup dialog boxes we can use. We will explore this next.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Using common dialogs</h1>
			<p>During the user’s journey of an <a id="_idIndexMarker342"/>application, you will often need to interrupt the flow to present information, ask the user for confirmation, or to pick a file or other input element. For this purpose, toolkits usually provide dialog windows, and Fyne does the same. Instead of opening a new window, the dialogs will appear over existing content in the current window (which works well across all platforms as not all manage multiple window applications well).</p>
			<p>Each dialog has its own constructor function (of the <strong class="source-inline">dialog.NewXxx()</strong> form) that create the dialog to be shown later using <strong class="source-inline">Show()</strong>. They also provide a helper function to create and show it (of the <strong class="source-inline">dialog.ShowXxx()</strong> form). The last parameter of all these functions is the window that they should be displayed in. All the dialogs also support setting a callback when the dialog closes. This can be configured using the <strong class="source-inline">SetOnClosed()</strong> method.</p>
			<p>In this section, we looked at the<a id="_idIndexMarker343"/> different dialog helpers that are available (in alphabetical order) before learning how to build a custom dialog for an application. Although, these will load in the current application theme, we only showed one image for each example.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor149"/>ColorPicker</h2>
			<p>Fyne provides a standard <a id="_idIndexMarker344"/>dialog for picking a color within applications. This feature will <a id="_idIndexMarker345"/>present a selection of standard colors, a list of recently selected colors, and also an advanced area where specific colors can be chosen <a id="_idIndexMarker346"/>through value sliders, editing the channel <a id="_idIndexMarker347"/>values in <strong class="bold">Red</strong>, <strong class="bold">Green</strong>, and <strong class="bold">Blue</strong> (<strong class="bold">RGB</strong>) or <strong class="bold">Hue</strong>, <strong class="bold">Saturation</strong>, and <strong class="bold">Lightness</strong> (<strong class="bold">HSL</strong>), or by entering the RGB hex color notation directly.</p>
			<p>The color picker can be created by calling <strong class="source-inline">dialog.NewColorPicker()</strong> and then using <strong class="source-inline">Show()</strong> or simply calling <strong class="source-inline">dialog.ShowColorPicker()</strong>. The parameters of the constructor are the title and message to be shown at the top, a callback function for when the color is selected, and the parent window to display within it:</p>
			<p class="source-code">dialog.ShowColorPicker("Pick a Color", "",</p>
			<p class="source-code">    func(value color.Color) {</p>
			<p class="source-code">       fmt.Println("Chose:", value)</p>
			<p class="source-code">    },</p>
			<p class="source-code">    win)</p>
			<p>The preceding code will load up the picker, as follows:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_5.28_B16820.jpg" alt="Figure 5.28 – The simple color picker dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.28 – The simple color picker dialog</p>
			<p>The previous image shows the<a id="_idIndexMarker348"/> default simple color picker. Advanced features are available if you want your <a id="_idIndexMarker349"/>developers to have more control.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor150"/>Confirmation</h2>
			<p>The confirmation dialog<a id="_idIndexMarker350"/> allows you to ask a user to confirm an action. As well as <a id="_idIndexMarker351"/>providing the title and content for this confirmation, developers can pass a callback function that will be called when the user makes their decision, with the parameter being false for a negative answer or true for a confirmed one. Like all dialogs, the last parameter is the parent window:</p>
			<p class="source-code">dialog.ShowConfirm("Please Confirm", "Are you sure..?",</p>
			<p class="source-code">     func(value bool) {</p>
			<p class="source-code">         fmt.Println("Chose:", value)</p>
			<p class="source-code">     }, win)</p>
			<p>The confirmation dialog will look as follows if the light theme is currently loaded:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_5.29_B16820.jpg" alt="Figure 5.29 – A confirmation dialog using the light theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.29 – A confirmation dialog using the light theme</p>
			<p>It’s important to <a id="_idIndexMarker352"/>remember that showing a dialog does not stop the code that loaded it. The<a id="_idIndexMarker353"/> user’s decision will be communicated through the callback; the rest of your code will continue uninterrupted.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>File selection</h2>
			<p>As we saw in <a href="B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Layout and File Handling</em>, the <strong class="source-inline">dialog</strong> package can help with file selection – choosing which file to open or where to save content. Opening the <strong class="bold">Open File</strong> or <strong class="bold">Save File</strong> dialog <a id="_idIndexMarker354"/>follows the pattern of the other<a id="_idIndexMarker355"/> dialog widgets. In this case, the callback function will take a <strong class="source-inline">fyne.URIReadCloser</strong> or <strong class="source-inline">fyne.URIWriteCloser</strong> type and an error since these operations can fail for a number of reasons:</p>
			<p class="source-code">dialog.ShowFileOpen(func(read fyne.URIReadCloser, err error) {</p>
			<p class="source-code">     fmt.Println("User chose:", read.URI().String(), err) </p>
			<p class="source-code">}, win) {</p>
			<p>The Open File dialog looks as follows:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_5.30_B16820.jpg" alt="Figure 5.30 – The file dialog is used for choosing a file to open or save&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.30 – The file dialog is used for choosing a file to open or save</p>
			<p>The file dialogs will<a id="_idIndexMarker356"/> default to showing the user’s home directory. This can be changed by calling the <strong class="source-inline">SetLocation</strong> method. As this is a cross-platform API, the starting<a id="_idIndexMarker357"/> location is a <strong class="source-inline">URI</strong> rather than a <strong class="source-inline">string</strong> path. This also means that the file dialog can be used to show the contents of remote file systems and other sources of file data. </p>
			<p>In a similar way, applications can ask where to write a file to use the <strong class="source-inline">dialog.ShowFileSave</strong> method. It is also possible to prompt for folder selection instead of files, using <strong class="source-inline">dialog.ShowFolderOpen</strong>.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Form</h2>
			<p>The <strong class="source-inline">Form</strong> dialog extends <a id="_idIndexMarker358"/>the simple premise of a confirmation by requesting a value to be input, in<a id="_idIndexMarker359"/> addition to confirming the result. The <strong class="source-inline">Form</strong> dialog can contain various widgets in the same way that the <strong class="source-inline">Form</strong> widget did in the <em class="italic">Introducing the basic widgets</em> section. The constructor function is similar to the confirm dialog, but it accepts an additional slice of <strong class="source-inline">*widget.FormItem</strong> values to specify the content:</p>
			<p class="source-code">dialog.ShowForm( "Form Input", "Enter", "Cancel",</p>
			<p class="source-code">     []*widget.FormItem{</p>
			<p class="source-code">         widget.NewFormItem("Enter a string...", widget.          	             NewEntry())},</p>
			<p class="source-code">     func(bool) {}, win)</p>
			<p>The result will be a <a id="_idIndexMarker360"/>dialog with an <strong class="source-inline">widget.Entry</strong> field, as shown in the following<a id="_idIndexMarker361"/> image:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_5.31_B16820.jpg" alt="Figure 5.31 – Asking a user for an input value using the Entry dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.31 – Asking a user for an input value using the Entry dialog</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Information</h2>
			<p>In a command-line application, information will commonly be written to standard output or standard error (normally for error messages). However, graphical applications will normally not be run from the command line, so messages that the user should see will need to be presented differently. The dialog package can help with this task as well.</p>
			<p>An information dialog <a id="_idIndexMarker362"/>box can be used to present a standard message when its<a id="_idIndexMarker363"/> importance is high enough that the user should be interrupted to take a look at it. The <strong class="source-inline">dialog.ShowInformation</strong> function is called to present this dialog and it takes a title and message parameter. If the information to present is an error, then the <strong class="source-inline">dialog.ShowError</strong> helper function can be used as it takes an error type and the information is extracted to be displayed:</p>
			<p class="source-code">dialog.ShowInformation("Some Information",</p>
			<p class="source-code">    "This is a thing to know", win)</p>
			<p class="source-code">err := errors.New("a dummy error message")</p>
			<p class="source-code">dialog.ShowError(err, win)</p>
			<p>The information dialog box will be presented like so:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_5.32_B16820.jpg" alt="Figure 5.32 – An information dialog box in the light theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.32 – An information dialog box in the light theme</p>
			<p>After these, we move to the custom dialogs.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor154"/>Custom dialogs</h1>
			<p>Although the <a id="_idIndexMarker364"/>preceding dialogs should cover most of the reasons why you may wish to interrupt the user flow with a pop-up dialog, your app may have additional requirements. To support this, you can insert any content into a custom dialog so that the overall layout is consistent.</p>
			<p>To construct a custom dialog, a new parameter and its content must be passed to the constructor function. Any Fyne widget or <strong class="source-inline">CanvasObject</strong> can be used in a custom dialog, which includes containers to provide more complex content. To illustrate this, we will use a <strong class="source-inline">TextGrid</strong> component:</p>
			<p class="source-code">content := widget.NewTextGrid()</p>
			<p class="source-code">content.SetText("Custom content")</p>
			<p class="source-code">content.SetStyleRange(0, 7, 0, 14,</p>
			<p class="source-code">    widget.TextGridStyleWhitespace)</p>
			<p class="source-code">dialog.ShowCustom("Custom Dialog", "Cancel", content, win)</p>
			<p>The preceding code will generate a custom dialog, as shown here:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_5.33_B16820.jpg" alt="Figure 5.33 – A dialog showing custom content (a TextGrid)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.33 – A dialog showing custom content (a TextGrid)</p>
			<p>There is <a id="_idIndexMarker365"/>also a <strong class="source-inline">ShowCustomConfirm()</strong> version, which provides the <strong class="bold">OK</strong> and <strong class="bold">Cancel</strong> options. This behaves in the same way as the custom dialog shown in the previous image, except takes an additional <strong class="source-inline">func(bool)</strong> callback to inform the developer of which button was tapped.</p>
			<p>By exploring various widgets and dialogs, we have seen what the standard theme looks like and that light and dark versions are available. Next, we will look at what a theme consists of and how they can be managed and customized.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/>Understanding themes</h1>
			<p>The themes <a id="_idIndexMarker366"/>within the Fyne toolkit implement the color palette, iconography, and size/padding values of the Material Design look and feel. The design of the theme API aims to ensure that applications feel consistent and deliver a good user experience while allowing developers to convey an identity and customization. All Fyne applications can be displayed in light or dark mode using built-in themes. We will look at these in detail next.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Built-in themes</h2>
			<p>Since more and more operating<a id="_idIndexMarker367"/> systems are supporting light versus dark desktop coloring, the Fyne theme specification supports both light and dark variants. By default, every app will ship with a built-in theme that provides both light and dark variants. This theme was illustrated extensively in the <em class="italic">Introducing the basic widgets</em> section earlier in this chapter, but to see how this all comes together, take a look at the following screenshot of a Fyne demo application that showcases widgets:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_5.34_B16820.jpg" alt="Figure 5.34 – A collection of widgets in a default theme – light variant&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.34 – A collection of widgets in a default theme – light variant</p>
			<p>The previous <a id="_idIndexMarker368"/>screenshot shows the widget demo in the light theme. The following screenshot shows the same but with the built-in dark theme:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_5.35_B16820.jpg" alt="Figure 5.35 – Various widgets using the dark theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.35 – Various widgets using the dark theme</p>
			<p>As you can see, the <a id="_idIndexMarker369"/>main color being used (the primary color – blue, in this case) has been chosen as it contrasts well with the background colors of both the light and dark themes. When using this model, themes can vary the primary color while continuing to support both light and dark user preferences.</p>
			<p>On most operating systems, Fyne will automatically pick the theme variant that best matches the current user’s preferences. There are ways that the user can choose a specific version, as we’ll see in the next section.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>User settings</h2>
			<p>As we mentioned<a id="_idIndexMarker370"/> earlier, Fyne-based applications will normally detect the user’s preference for either the light or dark theme and load it accordingly. It is possible to set a preference for which theme is loaded by using the Fyne settings application or by using environment variables.</p>
			<p>The <strong class="bold">fyne_settings</strong> application, which<a id="_idIndexMarker371"/> can configure all Fyne-based applications, can be run to manage the user’s settings. This includes their theme variant (light or dark), as well as what primary color they will use. Any changes that are made using this interface will be saved for the future and will immediately apply to all open applications. You can also find the <strong class="bold">Settings</strong> panel from the <strong class="bold">Settings</strong> menu within <strong class="bold">fyne_demo</strong>:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_5.36_B16820.jpg" alt="Figure 5.36 – The fyne_settings application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.36 – The fyne_settings application</p>
			<p>Using environment variables can be useful if you wish to temporarily apply a theme, or if you would like one app to use a different theme. The <strong class="source-inline">FYNE_THEME</strong> environment variable can be set to <em class="italic">light</em> or <em class="italic">dark</em> to specify which variant should be used. You can similarly override the default interface scaling that’s available using the <strong class="source-inline">FYNE_SCALE</strong> environment variable. Here, <strong class="source-inline">1.0</strong> is the standard to use; smaller numbers load smaller content, while larger numbers load larger content.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Included icons</h2>
			<p>As could be seen in some of the<a id="_idIndexMarker372"/> widgets earlier in this chapter (for example, <strong class="source-inline">Button</strong> and <strong class="source-inline">AppTabs</strong>), the theme package includes many icons from the material design collection (the full official set can be found at <a href="https://material.io/resources/icons/">https://material.io/resources/icons/</a>).</p>
			<p>Because all the elements of Fyne-based apps are designed to scale appropriately for different types of display and user preferences, the images should be vector-based rather than bitmap-based. This means that when displaying at very small or large sizes, the exact pixels to display will be calculated for optimal display instead of multiplying (or reducing) the number of pixels from the original image.</p>
			<p>Thankfully, the material design images are available in vector formats and the built-in icons are<a id="_idIndexMarker373"/> all in <strong class="bold">scalable vector graphics</strong> (<strong class="bold">SVG</strong>) format. This also means that icons can easily be adapted for various colors as the app runs, thus ensuring that they can adapt to the primary color and current theme:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_5.37_B16820.jpg" alt="Figure 5.37 – A selection of material design icons&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.37 – A selection of material design icons</p>
			<p>Because the icon set is freely available and very popular, it is easy to download additional icons and add them to your application, knowing that they will fit the toolkit’s overall aesthetic.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Application override</h2>
			<p>Developers of <a id="_idIndexMarker374"/>applications that wish to deviate from the default (or user-selected) theme are also catered for in the Fyne theme API. Be careful before specifying a theme for your application – it may feel like a surprise to your app users. To use one of the built-in themes but override the user or system setting regarding whether the light or dark variant is used, you can call <strong class="source-inline">SetTheme()</strong> on the current <strong class="source-inline">App</strong> instance, as follows:</p>
			<p class="source-code">fyne.CurrentApp().Settings().SetTheme(theme.DarkTheme())</p>
			<p>Alternatively, to force the application to use the built-in light theme, use the following code:</p>
			<p class="source-code">fyne.CurrentApp().Settings().SetTheme(theme.LightTheme())</p>
			<p>This API is more commonly used to set up a custom application theme. The details of creating a custom theme will be covered in <a href="B16820_07_Final_JM_ePub.xhtml#_idTextAnchor193"><em class="italic">Chapter 7</em></a>, <em class="italic">Building Custom Widgets and Themes</em>. Once you have created a theme, it can be loaded using the <strong class="source-inline">SetTheme()</strong> function, which will apply it to the current app. The following screenshot shows a custom theme that deviates from the standard styles:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/Figure_5.38_B16820.jpg" alt="Figure 5.38 – A BBC Micro Emulator GUI based on Fyne&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.38 – A BBC Micro Emulator GUI based on Fyne</p>
			<p>Now that we have explored the details of the main widgets and theme capabilities of the Fyne toolkit, let’s build a simple app that brings many of them together.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Implementing a task list application</h1>
			<p>To explore<a id="_idIndexMarker375"/> some of the widgets listed in the previous sections and how they can be brought together into a simple application, we will build a small task list. This application will show a list of tasks based on complete or incomplete state and allow the user to edit the details of each item.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>Designing the GUI</h2>
			<p>First, we will<a id="_idIndexMarker376"/> piece together a basic user interface for the task application. It will contain a list of tasks on the left-hand side of the app and a collection of components that edit a task on the right-hand side. Above this, we will add a toolbar for other actions. Let’s get started:</p>
			<ol>
				<li>The list of tasks will be a <strong class="source-inline">List</strong> widget that notifies the user when an item has been selected. The <strong class="source-inline">List</strong> widget will contain static content for this mock-up. Here, we will tell the list that there are a set number of items (for example, <strong class="source-inline">5</strong>) so that it creates the correct number of items to display. We create a new check item each time the list calls the <strong class="source-inline">CreateItem</strong> callback. For now, we will leave the third (<strong class="source-inline">UpdateItem</strong>) method empty so that it just displays templates values. This code will be created in a simple <strong class="source-inline">makeUI</strong> method, as shown here:<p class="source-code">func makeUI() fyne.CanvasObject {</p><p class="source-code">    todos := widget.NewList(func() int {</p><p class="source-code">            return 5</p><p class="source-code">        },</p><p class="source-code">        func() fyne.CanvasObject {</p><p class="source-code">            return widget.NewCheck("TODO Item x",          	                func(bool) {})</p><p class="source-code">        },</p><p class="source-code">        func(int, fyne.CanvasObject) {})</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Next, we will create the widgets that will allow us to edit a task item. Let’s create a <strong class="source-inline">Form</strong> widget that will hold the items we need and provide labels as well. We will create a new row for each item using <strong class="source-inline">widget.NewFormItem</strong>, passing the <strong class="source-inline">string</strong> label and the widget’s content as parameters. These are all standard widgets, but the callbacks we are passing are empty at the moment. We will return to these widgets later to complete their functionality. The following code <a id="_idIndexMarker377"/>goes inside the <strong class="source-inline">makeUI</strong> function we started in the previous segment:<p class="source-code">    details := widget.NewForm(</p><p class="source-code">        widget.NewFormItem("Title", widget.NewEntry()),</p><p class="source-code">        widget.NewFormItem("Description",</p><p class="source-code">            widget.NewMultiLineEntry()),</p><p class="source-code">        widget.NewFormItem("Category",</p><p class="source-code">            widget.NewSelect([]string{"Home"},</p><p class="source-code">                func(string) {})),</p><p class="source-code">        widget.NewFormItem("Priority", </p><p class="source-code">            widget.NewRadioGroup([]string{"Low", "Mid",    	                "High"}, </p><p class="source-code">                func(string){})),</p><p class="source-code">        widget.NewFormItem("Due", widget.NewEntry()),</p><p class="source-code">        widget.NewFormItem("Completion",</p><p class="source-code">            widget.NewSlider(0, 100)),</p><p class="source-code">    )</p></li>
				<li>The last component that we will add to the interface is a toolbar that will provide access to the add task function. To do so, we will create a <strong class="source-inline">widget.Toolbar</strong> using the <strong class="source-inline">ToolbarAction</strong> item:<p class="source-code">    toolbar := widget.NewToolbar(</p><p class="source-code">        widget.NewToolbarAction(theme.ContentAddIcon(),</p><p class="source-code">            func() {}),</p><p class="source-code">    )</p></li>
				<li>To bring these interface elements together, we will create a new container using the <strong class="source-inline">Border</strong> layout. The toolbar will be set as the top item and the task items will be on the left of the container. Our form will take up the remaining space by being passed as a component that’s not specified as being on a border. This container will be returned from the <strong class="source-inline">makeUI</strong> function so that it can be used to display our application window:<p class="source-code">return container.NewBorder(</p><p class="source-code">    toolbar, nil, todos, nil, details)</p></li>
				<li>To run our<a id="_idIndexMarker378"/> application, all we need to do is add the usual launcher code, which creates a window and sets our content. We do not need to specify a size for this window as the contents will naturally condense down to a sensible minimum size:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("TODO List")</p><p class="source-code">    w.SetContent(makeUI())</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>Running all the code we’ve created so far will give us a good impression of what the application will look like:<p class="source-code"><strong class="bold">Chapter05$ go run .</strong></p></li>
			</ol>
			<p>When using the Fyne light theme (by going through the user preferences options or by setting <strong class="source-inline">FYNE_THEME="light"</strong>), the application should look as follows:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/Figure_5.39_B16820.jpg" alt="Figure 5.39 – Our task list GUI skeleton&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.39 – Our task list GUI skeleton</p>
			<p>Before we can<a id="_idIndexMarker379"/> complete the functionality of this application, we need to define a data structure that will hold information about the tasks we are editing.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor162"/>Defining the data</h2>
			<p>For our application to<a id="_idIndexMarker380"/> function correctly, we will need to create a data structure that will manage the information we are editing. Let’s get started:</p>
			<ol>
				<li value="1">First, we must define a <strong class="source-inline">task</strong> data structure – this simply lists the various fields that match the inputs in the design we made in the previous section. Different fields will be stored in different types – for example, the <strong class="source-inline">Entry</strong> widget maps to <strong class="source-inline">string</strong> and our checkbox maps to <strong class="source-inline">bool</strong>. We will add the following code to a new file called <strong class="source-inline">data.go</strong>:<p class="source-code">type task struct {</p><p class="source-code">    title, description string</p><p class="source-code">    done               bool</p><p class="source-code">    category           string</p><p class="source-code">    priority           int</p><p class="source-code">    due                *time.Time</p><p class="source-code">    completion         float64</p><p class="source-code">}</p><p>As you can see, we have used <strong class="source-inline">float64</strong> for the value of our completion <strong class="source-inline">Slider</strong> and that we will be converting the date entry into <strong class="source-inline">time.Time</strong> format.</p></li>
				<li>Since we will be <a id="_idIndexMarker381"/>storing many tasks, we could simply create a slice of task pointers, but by defining a new type, we can associate certain functions with others that will be useful later. The type just wraps the <strong class="source-inline">[]*task</strong> slice, which will store the data:<p class="source-code">type taskList struct {</p><p class="source-code">    tasks []*task</p><p class="source-code">}</p></li>
				<li>Since we will be displaying the list of tasks based on the <strong class="source-inline">done</strong> state, we should add two helper methods that return these sub-lists based on the value of that field:<p class="source-code">func (l *taskList) remaining() []*task {</p><p class="source-code">    var items []*task</p><p class="source-code">    for _, task := range l.tasks {</p><p class="source-code">        if !task.done {</p><p class="source-code">            items = append(items, task)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    return items</p><p class="source-code">}</p><p class="source-code">func (l *taskList) done() []*task {</p><p class="source-code">    var items []*task</p><p class="source-code">    for _, task := range l.tasks {</p><p class="source-code">        if task.done {</p><p class="source-code">            items = append(items, task)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    return items</p><p class="source-code">}</p></li>
				<li>We will also define<a id="_idIndexMarker382"/> some constants that help in managing the different priority levels in our data. Refer to the following code snippet: <p class="source-code">const (</p><p class="source-code">    lowPriority  = 0</p><p class="source-code">    midPriority  = 1</p><p class="source-code">    highPriority = 2</p><p class="source-code">) </p></li>
				<li>When writing data handling code, it’s important to write tests as well. If you add these before connecting to the user interface, then bugs can surface sooner. This means that when we add graphical tests, any issues that are found should relate to a mistake in our user interface code. Create a new file called <strong class="source-inline">data_test.go</strong> and the following tests:<p class="source-code">func TestTaskList_Remaining(t *testing.T) {</p><p class="source-code">    item := &amp;task{title: "Remain"}</p><p class="source-code">    list := &amp;taskList{tasks: []*task{item}}</p><p class="source-code">    remain := list.remaining()</p><p class="source-code">    assert.Equal(t, 1, len(remain))</p><p class="source-code">    done := list.done()</p><p class="source-code">    assert.Equal(t, 0, len(done))</p><p class="source-code">}</p><p class="source-code">func TestTaskList_Done(t *testing.T) {</p><p class="source-code">    item := &amp;task{title: "Done", done: true}</p><p class="source-code">    list := &amp;taskList{tasks: []*task{item}}</p><p class="source-code">    remain := list.remaining()</p><p class="source-code">    assert.Equal(t, 0, len(remain))</p><p class="source-code">    done := list.done()</p><p class="source-code">    assert.Equal(t, 1, len(done))</p><p class="source-code">}</p><p>More tests can be added to this project – you can find them in the code repository for this book, inside the <strong class="source-inline">Chapter05</strong> folder, at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05</a>.</p></li>
				<li>We have not <a id="_idIndexMarker383"/>explored data storage in this chapter, so we will just be keeping the task list in memory. You will find out more about data and preference storage in <a href="B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Binding and Storage</em>. Since our data will be reset each time the application is run, we should create another function that populates a data structure with some content that will be loaded when the app starts, as follows:<p class="source-code">func dummyData() *taskList {</p><p class="source-code">     return &amp;taskList{</p><p class="source-code">         tasks: []*task{</p><p class="source-code">             {title: "Nearly done",</p><p class="source-code">                 description: `You can tick my checkbox</p><p class="source-code">and I will be marked as</p><p class="source-code">done and disappear`},</p><p class="source-code">             {title: "Functions",</p><p class="source-code">                 description: `Tap the plus icon above to</p><p class="source-code">add a new task, or tap the minus</p><p class="source-code">icon to remove this one`},</p><p class="source-code">         }}</p><p class="source-code">}</p></li>
			</ol>
			<p>Now that we have defined the data structure and basic functions, we can connect it to the user interface and complete the functionality.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>Selecting tasks</h2>
			<p>The simplest way to<a id="_idIndexMarker384"/> update a widget’s content is to keep a reference regarding the instance once it has been constructed. We will be doing this for a number of elements, so we should create a new type that will handle the various elements of the user interface. Creating this struct means that we can avoid lots of global variables, which should help keep the code neat. Let’s get started:</p>
			<ol>
				<li value="1">Create a new struct and name it <strong class="source-inline">taskApp</strong>, as follows:<p class="source-code">type taskApp struct {</p><p class="source-code">    data    *taskList</p><p class="source-code">    visible []*task</p><p class="source-code">    tasks *widget.List</p><p class="source-code">    // more will be added here</p><p class="source-code">}</p><p>The type includes a reference to the <strong class="source-inline">*taskList</strong> data structure, which will hold our date, and defines a slice of <strong class="source-inline">*task</strong> types that represents the tasks that are currently visible (the result of calling <strong class="source-inline">taskList.remaining()</strong> or <strong class="source-inline">taskList.done()</strong>).</p></li>
				<li>Now, we can make our <strong class="source-inline">makeUI</strong> function a method of the <strong class="source-inline">taskApp</strong> type so that its signature becomes <strong class="source-inline">func (a *taskApp) makeUI() fyne.CanvasObject</strong>. Doing this gives us access to the data structure we defined earlier through <strong class="source-inline">a.data</strong>. We will, however, use the task list stored in <strong class="source-inline">visible</strong> to populate our list as it may contain completed or incomplete items, depending on its current state.</li>
				<li>The code that sets up the list widget can now be updated with the following code. We store its reference in <strong class="source-inline">a.tasks</strong> instead of the original <strong class="source-inline">todos</strong> variable (so that we can reference it later); don’t forget to change the <strong class="source-inline">todos</strong> reference returned from <strong class="source-inline">makeUI</strong> to use <strong class="source-inline">a.tasks</strong> as well. The result of our <strong class="source-inline">Length</strong> callback function simply returns the number of items in the <strong class="source-inline">a.visible</strong> slice. Although the <strong class="source-inline">CreateItem</strong> callback (the middle parameter) does not need to change, we do provide an implementation for the final callback; that is, <strong class="source-inline">UpdateItem</strong>. This new function obtains the task from the specified index (<strong class="source-inline">i</strong>) and uses <strong class="source-inline">task.title</strong> to set the text of the <strong class="source-inline">Check</strong> widget:<p class="source-code">    a.tasks = widget.NewList(func() int {</p><p class="source-code">        return len(a.visible)</p><p class="source-code">    },</p><p class="source-code">    func() fyne.CanvasObject {</p><p class="source-code">        return widget.NewCheck("TODO item x", func(bool) {})</p><p class="source-code">    },</p><p class="source-code">    func(i int, c fyne.CanvasObject) {</p><p class="source-code">        check := c.(*widget.Check)</p><p class="source-code">        check.Text = a.visible[i].title</p><p class="source-code">        check.Refresh()</p><p class="source-code">    })</p></li>
				<li>To see these <a id="_idIndexMarker385"/>changes in action, we need to set up the data source. For this, we must add a line that will create our dummy data and construct the new <strong class="source-inline">taskApp</strong> struct just before the call to <strong class="source-inline">SetContent</strong>, as follows:<p class="source-code">    data := dummyData()</p><p class="source-code">    tasks:= taskApp{data: data, visible: data.             	        remaining()}</p><p class="source-code">    w.SetContent(tasks.makeUI())</p></li>
			</ol>
			<p>Performing these code alterations will update the app so that it reflects the task titles in the main list, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/Figure_5.40_B16820.jpg" alt="Figure 5.40 – Showing real task titles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.40 – Showing real task titles</p>
			<p>Next, we need to fill in the details on the right-hand side of the window. </p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>Filling in the details</h2>
			<p>To populate the <a id="_idIndexMarker386"/>data area of the app, we will need to keep track of the current task and the widgets that it should fill. Let’s get started:</p>
			<ol>
				<li value="1">To do this, we will add a <strong class="source-inline">current</strong> field to the <strong class="source-inline">taskApp</strong> structure. After that, we need to save a reference to each of the input elements that we added for the initial layout tests, which will require more fields in <strong class="source-inline">taskApp</strong>:<p class="source-code">type taskApp struct {</p><p class="source-code">    data    *taskList</p><p class="source-code">    visible []*task</p><p class="source-code">    current *task</p><p class="source-code">    tasks                   *widget.List</p><p class="source-code">    title, description, due *widget.Entry</p><p class="source-code">    category                *widget.Select</p><p class="source-code">    priority                *widget.Radio</p><p class="source-code">    completion              *widget.Slider</p><p class="source-code">}</p></li>
				<li>With these in place, we<a id="_idIndexMarker387"/> can complete the replacement for the <strong class="source-inline">details</strong> setup within <strong class="source-inline">makeUI</strong> so that it looks as follows:<p class="source-code">    a.title = widget.NewEntry()</p><p class="source-code">    a.description = widget.NewMultiLineEntry()</p><p class="source-code">    a.category = widget.NewSelect([]string{"Home"},</p><p class="source-code">        func(string) {})</p><p class="source-code">    a.priority = widget.NewRadio(</p><p class="source-code">        []string{"Low", "Mid", "High"}, func(string) {})</p><p class="source-code">    a.due = widget.NewEntry()</p><p class="source-code">    a.completion = widget.NewSlider(0, 100)</p><p class="source-code">    details := widget.NewForm(</p><p class="source-code">        widget.NewFormItem("Title", a.title),</p><p class="source-code">        widget.NewFormItem("Description", a.description),</p><p class="source-code">        widget.NewFormItem("Category", a.category),</p><p class="source-code">        widget.NewFormItem("Priority", a.priority),</p><p class="source-code">        widget.NewFormItem("Due", a.due),</p><p class="source-code">        widget.NewFormItem("Completion", a.completion),</p><p class="source-code">    )</p></li>
				<li>Once this setup code is complete, we can add a new function called <strong class="source-inline">setTask</strong>. This will be used to update the current task and refresh the detail elements we created in the previous code block:<p class="source-code">func (a *taskApp) setTask(t *task) {</p><p class="source-code">    a.current = t</p><p class="source-code">    a.title.SetText(t.title)</p><p class="source-code">    a.description.SetText(t.description)</p><p class="source-code">    a.category.SetSelected(t.category)</p><p class="source-code">    if t.priority == midPriority {</p><p class="source-code">        a.priority.SetSelected("Mid")</p><p class="source-code">    } else if t.priority == highPriority {</p><p class="source-code">        a.priority.SetSelected("High")</p><p class="source-code">    } else {</p><p class="source-code">        a.priority.SetSelected("Low")</p><p class="source-code">    }</p><p class="source-code">    a.due.SetText(formatDate(t.due))</p><p class="source-code">    a.completion.Value = t.completion</p><p class="source-code">    a.completion.Refresh()</p><p class="source-code">}</p></li>
				<li>To support that code, we <a id="_idIndexMarker388"/>will also define the <strong class="source-inline">formatDate</strong> function, which converts our date into a string value. This will return an empty string if the optional <strong class="source-inline">date</strong> is <strong class="source-inline">nil</strong>, or format it using the <strong class="source-inline">dateFormat</strong> constant otherwise:<p class="source-code">const dateFormat = "02 Jan 06 15:04"</p><p class="source-code">func formatDate(date *time.Time) string {</p><p class="source-code">    if date == nil {</p><p class="source-code">        return ""</p><p class="source-code">    }</p><p class="source-code">    return date.Format(dateFormat)</p><p class="source-code">}</p></li>
				<li>With this code in place, we can set the first task to be presented on the display. Of course, we should check if there are any tasks before assuming that an item can be shown. The following code is updated in the <strong class="source-inline">main</strong> function:<p class="source-code">    w.SetContent(ui.makeUI())</p><p class="source-code">    if len(data.remaining()) &gt; 0 {</p><p class="source-code">        ui.setTask(data.remaining()[0])</p><p class="source-code">    }</p></li>
				<li>The last piece of code we need in order to update our user interface as the user browses is <strong class="source-inline">List.OnSelected</strong>. This will allow us to update the details that are displayed when the list is<a id="_idIndexMarker389"/> tapped. Simply add the following line once you’ve created our <strong class="source-inline">List</strong>, which is set to load from <strong class="source-inline">a.tasks</strong>:<p class="source-code">    a.tasks.OnSelected = func(id int) {</p><p class="source-code">        a.setTask(a.visible[id])</p><p class="source-code">    }</p></li>
			</ol>
			<p>With all the code in place, we have a complete application, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_5.41_B16820.jpg" alt="Figure 5.41 – Complete user interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.41 – Complete user interface</p>
			<p>All the code shown previously will work with the current theme, which means we can see the same content when we’re using the standard dark theme:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_5.42_B16820.jpg" alt="Figure 5.42 – The tasks user interface in the standard dark theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">
Figure 5.42 – The tasks user interface in the standard dark theme</p>
			<p>Next, we will handle how details are saved when the user edits any data.</p>
			<p>Editing content</p>
			<p>When each of the <a id="_idIndexMarker390"/>input widgets are edited, we should update the dataset. This is trivial for most inputs as we can just set the <strong class="source-inline">OnChanged</strong> callback so that we’re notified when the data changes. Let’s get started:</p>
			<ol>
				<li value="1">In each callback, we must ensure that a task is currently selected (in case all the tasks have been deleted) and then set the appropriate field. The callback for <strong class="source-inline">Title</strong> is as follows. Note that we also call <strong class="source-inline">Refresh()</strong> on the task list as the title change should be reflected in the list:<p class="source-code">    a.title.OnChanged = func(text string) {</p><p class="source-code">        if a.current == nil {</p><p class="source-code">            return</p><p class="source-code">        }</p><p class="source-code">        a.current.title = text</p><p class="source-code">        a.tasks.Refresh() // refresh list of titles</p><p class="source-code">    }</p><p>Most of the other callbacks are similar, so they have been omitted from this description – the full code is available in this book’s GitHub repository.</p></li>
				<li>The priority callback update is a little more complex as we are converting a choice of string representations into a number field. Note that the callback is a function that’s been passed to the constructor:<p class="source-code">    a.priority = widget.NewRadio([]string{"Low", "Mid", "High"}, func(pri string) {</p><p class="source-code">        if a.current == nil {</p><p class="source-code">            return</p><p class="source-code">        }</p><p class="source-code">        if pri == "Mid" {</p><p class="source-code">            a.current.priority = midPriority</p><p class="source-code">        } else if pri == "High" {</p><p class="source-code">            a.current.priority = highPriority</p><p class="source-code">        } else {</p><p class="source-code">            a.current.priority = lowPriority</p><p class="source-code">        }</p><p class="source-code">    })</p></li>
				<li>Lastly, we will look<a id="_idIndexMarker391"/> at the input widget as we should add validation for the date format. To do this, we set the <strong class="source-inline">Validator</strong> callback to provide the user with feedback about the input state. First, we must create a new validator that can check the date format, which simply has a <strong class="source-inline">Validate(string)</strong> <strong class="source-inline">error</strong> function signature (meaning it implements <strong class="source-inline">fyne.StringValidator</strong>):<p class="source-code">func dateValidator(text string) error {</p><p class="source-code">    _, err := time.Parse(dateFormat, text)</p><p class="source-code">    return err</p><p class="source-code">}</p></li>
				<li>With the validator in place, we simply set it as the <strong class="source-inline">OnChanged</strong> callback. In this callback, we need to reparse the date to get the appropriate date for the input (we skip this if the input is empty):<p class="source-code">    a.due.Validator = dateValidator</p><p class="source-code">    a.due.OnChanged = func(str string) {</p><p class="source-code">        if a.current == nil {</p><p class="source-code">            return</p><p class="source-code">        }</p><p class="source-code">        if str == "" {</p><p class="source-code">            a.current.due = nil</p><p class="source-code">        } else {</p><p class="source-code">            date, err := time.Parse(dateFormat, str)</p><p class="source-code">            if err != nil {</p><p class="source-code">                a.current.due = &amp;date</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
			</ol>
			<p>This is all the code we <a id="_idIndexMarker392"/>need for presenting and editing tasks. Next, we’ll learn how to mark tasks as complete and keep the list updated.</p>
			<p>Marking tasks as complete</p>
			<p>The next piece of<a id="_idIndexMarker393"/> functionality we will add is the ability to mark a task as complete. Let’s get started:</p>
			<ol>
				<li value="1">Because we are within the list, we need to set the callback within the <strong class="source-inline">UpdateItem</strong> callback to <strong class="source-inline">List</strong> to be able to mark the correct item as done:<p class="source-code">            check.OnChanged = func(done bool) {</p><p class="source-code">                a.visible[i].done = done</p><p class="source-code">                a.refreshData()</p><p class="source-code">            }</p></li>
				<li>Here, we need to make use of a helpful <strong class="source-inline">refreshData()</strong> function that updates the data list (by re-calculating what remains) and then asks the <strong class="source-inline">task</strong> widget to refresh:<p class="source-code">func (a *taskApp) refreshData() {</p><p class="source-code">    // hide done</p><p class="source-code">    a.visible = a.data.remaining()</p><p class="source-code">    a.tasks.Refresh()</p><p class="source-code">}</p><p>At this point, it functions correctly. However, upon clicking the <strong class="source-inline">Check</strong> text, it marks a task as done instead of selecting it for editing. To improve this, we can move the text <a id="_idIndexMarker394"/>component to a separate <strong class="source-inline">Label</strong> widget that will allow the mouse clicks through to the list selection logic.</p></li>
				<li>To do this, we will return a <strong class="source-inline">Check</strong> and a <strong class="source-inline">Label</strong> by using <strong class="source-inline">container.NewHBox</strong> in the template function. When applying content in the update callback, we need to extract the widgets from the <strong class="source-inline">Container.Objects[]</strong> field. Otherwise, the code is similar to what it was earlier. The final list implementation is as follows:<p class="source-code">    a.tasks = widget.NewList(</p><p class="source-code">        func() int {</p><p class="source-code">            return len(a.visible)</p><p class="source-code">        },</p><p class="source-code">        func() fyne.CanvasObject {</p><p class="source-code">            return container.NewHBox(widget.NewCheck("",</p><p class="source-code">                func(bool) {}),</p><p class="source-code">                widget.NewLabel("TODO Item x"))</p><p class="source-code">        },</p><p class="source-code">        func(i int, c fyne.CanvasObject) {</p><p class="source-code">            task := a.visible[i]</p><p class="source-code">            box := c.(*fyne.Container)</p><p class="source-code">            check := box.Objects[0].(*widget.Check)</p><p class="source-code">            check.Checked = task.done</p><p class="source-code">            check.OnChanged = func(done bool) {</p><p class="source-code">                task.done = done</p><p class="source-code">                a.refreshData()</p><p class="source-code">            }</p><p class="source-code">            label := box.Objects[1].(*widget.Label)</p><p class="source-code">            label.SetText(task.title)</p><p class="source-code">        })</p></li>
			</ol>
			<p>Finally, we will<a id="_idIndexMarker395"/> implement the <strong class="source-inline">add</strong> button in the toolbar.</p>
			<p>Creating a new task</p>
			<p>In this section, we will<a id="_idIndexMarker396"/> update the data code so that we can add new tasks. Let’s get started:</p>
			<ol>
				<li value="1">First, we will create a new <strong class="source-inline">add()</strong> function with a <strong class="source-inline">task</strong> parameter and prepend it to the top of the list:<p class="source-code">func (l *taskList) add(t *task) {</p><p class="source-code">    l.tasks = append([]*task{t}, l.tasks...)</p><p class="source-code">}</p></li>
				<li>Because data functions are usually easy to test, we will add another unit test inside <strong class="source-inline">data_test.go</strong>:<p class="source-code">func TestTaskList_Add(t *testing.T) {</p><p class="source-code">    list := &amp;taskList{}</p><p class="source-code">    list.add(&amp;task{title: "First"})</p><p class="source-code">    assert.Equal(t, 1, len(list.tasks))</p><p class="source-code">    list.add(&amp;task{title: "Next"})</p><p class="source-code">    assert.Equal(t, 2, len(list.tasks))</p><p class="source-code">    assert.Equal(t, "Next", list.tasks[0].title)</p><p class="source-code">}</p><p>Unit testing the whole user interface is highly advisable but outside the scope of this example – we will return to this topic in <a href="B16820_08_Final_JM_ePub.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Project Structure and Best Practices.</em> </p></li>
				<li>To complete the add task functionality, we must fill in the callback in the <strong class="source-inline">NewToolbarAction()</strong> function that we called when we first set up the user interface. This code simply creates a new <strong class="source-inline">task</strong> with the title <strong class="source-inline">New task</strong>, adds it to the data, and then<a id="_idIndexMarker397"/> reuses the same <strong class="source-inline">refreshData()</strong> function that we created for hiding completed tasks:<p class="source-code">widget.NewToolbarAction(theme.ContentAddIcon(),</p><p class="source-code">     func() {</p><p class="source-code">         task := &amp;task{title: "New task"}</p><p class="source-code">         a.data.add(task)</p><p class="source-code">         a.refreshData()</p><p class="source-code">     }),</p></li>
			</ol>
			<p>The preceding code concludes our tasks app example. There is more functionality that we could add, but we’ll leave that as an exercise for you to complete.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we learned how the Fyne Widget API is designed and looked at a list of standard widgets. We saw how containers and collection widgets can help us organize and manage user interface components. The dialog package was also explored to show how we can use it with our applications in order to implement standard components for common activities.</p>
			<p>We also saw how themes are implemented within the toolkit and how they apply to all the widget components. This chapter demonstrated the light and dark variants of the standard theme and showed that applications can provide their own themes for a custom look and feel.</p>
			<p>By building a task tracking application, we saw how many of the built-in widgets are used, how to lay them out in various containers, and how user interactions can be tracked to manage some in-memory data. In the next chapter, we will look at data binding and storage APIs, which can help us manage more complex data requirements.</p>
		</div>
	</body></html>