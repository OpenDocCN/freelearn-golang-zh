- en: '*Chapter 5*: Widget Library and Themes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 5 章*：小部件库和主题'
- en: A large part of the Fyne toolkit is its library of standard widgets, which provides
    simple visual elements, manages user input, and handles application workflows.
    These widgets handle how information and user input is displayed, as well as container
    options for organizing the user interface and managing standard workflows. The
    themes that come with the Fyne toolkit support both light and dark versions, both
    of which support user color preferences while adapting all the user interface
    elements so that they look great in both modes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 工具包的大部分是它的标准小部件库，它提供简单的视觉元素，管理用户输入，并处理应用程序工作流程。这些小部件处理信息和用户输入的显示方式，以及用于组织用户界面和管理标准工作流程的容器选项。Fyne
    工具包附带的主题支持浅色和深色版本，两者都支持用户颜色偏好，同时适应所有用户界面元素，使其在两种模式下都看起来很棒。
- en: 'In this chapter, we’re going to explore the widgets available in the Fyne toolkit
    and how to use them. We will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Fyne 工具包中可用的所有小部件以及如何使用它们。我们将涵盖以下主题：
- en: Exploring the design of the Fyne Widget API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Fyne Widget API 的设计
- en: Introducing the basic widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍基本小部件
- en: Grouping with the collection widgets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合小部件进行分组
- en: Adding structure with container widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器小部件添加结构
- en: Using common dialogs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常用对话框
- en: By the end of this chapter, you will be familiar with all the Fyne widgets and
    how the theme capabilities work to control their appearance. By combining widgets
    and containers, you will have built your first complete Fyne-based graphical user
    interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉所有 Fyne 小部件以及主题功能如何控制它们的外观。通过组合小部件和容器，你将构建你的第一个基于 Fyne 的完整图形用户界面。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing* – that is, you must have the Fyne toolkit installed
    and a Go and C compiler working. For more information, please refer to the previous
    chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与 [*第 3 章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)，“窗口、画布和绘图”相同
    - 即，你必须安装 Fyne 工具包并有一个工作的 Go 和 C 编译器。有关更多信息，请参阅上一章。
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05)找到。
- en: Exploring the design of the Widget API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Widget API 的设计
- en: 'As we described in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036),
    *The Future According to Fyne*, its APIs are designed to convey semantic meaning
    rather than a list of features. This is followed on by the Widget definition,
    whereby we add APIs that describe behavior and hide the details of rendering.
    The interface that all widgets must implement is simply an extension of the basic
    `CanvasObject` object (introduced in [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Window, Canvas, and Drawing*), which adds a `CreateRenderer()` method. It is
    defined in the source code as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 2 章*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036)，“根据 Fyne 的未来”中描述的，其
    API 被设计用来传达语义意义，而不是功能列表。随后是 Widget 定义，我们添加了描述行为的 API 并隐藏了渲染的细节。所有小部件都必须实现的接口仅仅是基本
    `CanvasObject` 对象（在第 [*第 3 章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)，“窗口、画布和绘图”中介绍）的扩展，它添加了一个
    `CreateRenderer()` 方法。它在源代码中定义如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The new `CreateRenderer()` method is used by Fyne to determine how the widget
    should look. There is no public API for accessing the current renderer – instead,
    state is set in a `Widget` and each renderer will refresh its output to match
    this state. This design strongly encourages APIs to focus on behavior and intent
    rather than directly manipulating the graphical output (which could quickly lead
    to inconsistent or unusable applications).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 使用新的 `CreateRenderer()` 方法来确定小部件的外观。没有公共 API 可以访问当前渲染器 - 相反，状态是在 `Widget`
    中设置的，每个渲染器都会刷新其输出以匹配此状态。这种设计强烈鼓励 API 专注于行为和意图，而不是直接操作图形输出（这可能导致不一致或无法使用的应用程序）。
- en: Focus on behavior
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专注于行为
- en: By enforcing a separation between widget state and its visual representation,
    each `Widget` is forced to expose an API that describes behavior or intent instead
    of visual attributes or internal details. This is important for continuing the
    design principle of a semantic API, which leads to a more concise API focused
    on expected outcomes over graphical tweaks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在组件状态和其视觉表示之间强制分离，每个`Widget`被迫公开一个API，该API描述了行为或意图，而不是视觉属性或内部细节。这对于继续语义API的设计原则很重要，这导致了一个更简洁的API，该API专注于预期结果而不是图形调整。
- en: 'Commonly, changes in state will need to be reflected by a `WidgetRender` updating
    in some way. How the graphical representation will change is controlled by the
    renderer, and it is triggered by calling `Widget.Refresh()`. This refresh is normally
    handled by the widget code; for example, the `Button.SetText()` function’s code
    is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，状态的变化需要通过某种方式的`WidgetRender`更新来反映。图形表示如何变化由渲染器控制，并且通过调用`Widget.Refresh()`来触发。这种刷新通常由小部件代码处理；例如，`Button.SetText()`函数的代码如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The call to `Refresh()` queues a request asking for the widget rendering to
    be updated, which will result in graphical updates in the next update of the screen.
    On some widgets, calling the `Refresh` function can cause a lot of calculations.
    If you have lots of changes to apply to a widget, you may not wish it to refresh
    after every line. To help with this, there is also a direct field access approach
    that ensures it doesn’t need to be called as often.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Refresh()`调用将排队一个请求，要求更新小部件的渲染，这将导致下一次屏幕更新时的图形更新。在某些小部件上，调用`Refresh`函数可能会引起大量的计算。如果你有很多更改要应用到小部件上，你可能不希望它在每一行后都刷新。为了帮助解决这个问题，也存在一种直接的字段访问方法，确保它不需要频繁调用。'
- en: Methods versus field access
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与字段访问
- en: 'As discussed in the previous section, refreshing a widget, especially a complex
    one, can be time-consuming, and if many updates must be performed, the user may
    notice a slight delay. If a developer wishes to update multiple aspects of a widget,
    then it is possible (though perhaps unlikely) that one change may be applied before
    a visual redraw and the others happen just after. Although another draw will occur,
    it may be noticeable that they did not change together. Consider the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，刷新小部件，尤其是复杂的小部件，可能很耗时，如果必须执行许多更新，用户可能会注意到轻微的延迟。如果开发者希望更新小部件的多个方面，那么（尽管可能性不大）可能一个更改会在视觉重绘之前应用，而其他更改则发生在之后。尽管将发生另一次绘制，但可能会注意到它们没有一起改变。考虑以下代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When using method-based updates, the `SetText()` and `SetIcon()` calls will
    refresh the widget, possibly causing the slight delay mentioned previously. It
    is recommended to call `Refresh()` only when needed; to make this possible, a
    developer can access the widget state directly and refresh the object manually.
    This is known as **field-based access** as we directly change the exported fields
    of a widget. For example, we could rewrite the preceding code like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于方法更新时，`SetText()`和`SetIcon()`调用将刷新小部件，可能会引起之前提到的轻微延迟。建议仅在需要时调用`Refresh()`；为了实现这一点，开发者可以直接访问小部件状态并手动刷新对象。这被称为**基于字段的访问**，因为我们直接更改小部件导出的字段。例如，我们可以将前面的代码重写如下：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By taking this approach, we ensure that `Refresh()` is called just once so that
    both changed elements will redraw at the same time. This offers a smoother result
    for the user and will lead to lower CPU usage as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这种方法，我们确保`Refresh()`只被调用一次，这样所有更改的元素将同时重新绘制。这为用户提供了更平滑的结果，并且将导致更低的CPU使用率。
- en: Rendering a widget
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染小部件
- en: The `CreateRenderer()` method mentioned earlier will return a new renderer instance
    that defines how the widget will be presented on-screen. The toolkit is responsible
    for calling this method and it will cache the result while the widget is visible.
    Developers should not call this directly as the result will have no connection
    to what is displayed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的`CreateRenderer()`方法将返回一个新的渲染器实例，该实例定义了小部件如何在屏幕上呈现。工具包负责调用此方法，并且当小部件可见时，它将缓存结果。开发者不应直接调用此方法，因为结果将与显示的内容没有关联。
- en: 'The exact lifetime of a renderer varies and is a combination of the widget’s
    visibility, its parent’s visibility, and whether the window is currently shown.
    The `WidgetRenderer` definition for a widget may be unloaded during its application
    life cycle. A new instance will be requested if the widget becomes visible again
    at a later date. If a renderer is no longer needed, then its `Destroy()` method
    will be called. The full definition of a widget renderer is as follows and has
    been taken from the API documentation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器的确切生命周期是变化的，它是小部件的可见性、其父级的可见性以及窗口当前是否显示的组合。小部件的 `WidgetRenderer` 定义在其应用程序生命周期中可能被卸载。如果小部件在以后日期再次变得可见，将请求一个新的实例。如果不再需要渲染器，则将调用其
    `Destroy()` 方法。小部件渲染器的完整定义如下，并已从 API 文档中提取：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first two methods in the `WidgetRenderer` definition (`Layout()` and `MinSize()`)
    should be familiar from [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling* – they define a container layout. In this instance,
    the container is this widget and the objects that are being controlled are the
    visual components used to render the widget – they are returned from the `Objects()`
    method. The `Refresh()` method of a `WidgetRenderer` is called internally when
    a visible widget needs to be redrawn.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WidgetRenderer` 定义中的前两种方法（`Layout()` 和 `MinSize()`）应该来自 [*第 4 章*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)，*布局和文件处理*
    – 它们定义了一个容器布局。在这种情况下，容器是这个小部件，被控制的对象是用于渲染小部件的视觉组件 – 它们是从 `Objects()` 方法返回的。当需要重新绘制可见小部件时，会内部调用
    `WidgetRenderer` 的 `Refresh()` 方法。
- en: The `Objects()` method call returns a list of each `CanvasObject` required to
    render the widget it describes. This is a slice of items from the `canvas` package
    such as `Text`, `Rectangle`, and `Line`. These items will be arranged using the
    layout methods described previously to create the final widget presentations.
    It is important that the color of each element match, or blend with, the current
    theme. When the `Refresh()` function is called, it may be in response to a theme
    change, so any custom values should be updated accordingly in that code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objects()` 方法的调用返回一个列表，其中包含渲染它所描述的小部件所需的每个 `CanvasObject`。这是从 `canvas` 包（如
    `Text`、`Rectangle` 和 `Line`）中的项目切片。这些项目将使用之前描述的布局方法进行排列，以创建最终的小部件展示。每个元素的颜色匹配或与当前主题融合是很重要的。当调用
    `Refresh()` 函数时，它可能是对主题更改的响应，因此在该代码中应相应地更新任何自定义值。'
- en: Now that we know how widgets work, let’s look at what is built into the toolkit.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了小部件的工作原理，让我们看看工具包中内置了什么。
- en: Introducing the basic widgets
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍基本小部件
- en: The most used package in Fyne (or any GUI toolkit) is likely the `widget` package.
    This contains all the standard widgets that will be useful to most graphical apps.
    The collection is split into basic widgets (for simple data display or user input)
    and collection widgets (`List`, `Table`, and `Tree`) that are used to display
    large or more complex data. In this section, we’ll step through the basic widgets
    in alphabetical order to see how they look and how to add them to an app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fyne（或任何 GUI 工具包）中最常用的包可能是 `widget` 包。它包含所有对大多数图形应用程序有用的标准小部件。该集合分为基本小部件（用于简单的数据显示或用户输入）和集合小部件（`List`、`Table`
    和 `Tree`），用于显示大量或更复杂的数据。在本节中，我们将按字母顺序逐步查看基本小部件，以了解它们的样式以及如何将它们添加到应用程序中。
- en: Accordion
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 手风琴
- en: 'The accordion widget is used to fit large amounts of content into a small area
    by showing and hiding items so that only one of the child elements is visible
    at a time. Each item has a header button that is used to show or hide the content
    below it. This can be seen in the following image, which shows an accordion widget
    in the light and the dark themes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 手风琴小部件用于通过显示和隐藏项目来将大量内容适应到小区域，这样每次只能看到一个子元素。每个项目都有一个标题按钮，用于显示或隐藏其下的内容。这可以在以下图像中看到，它显示了浅色和深色主题中的手风琴小部件：
- en: '![Figure 5.1 – An accordion widget with item B expanded, shown in the light
    and dark themes'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 一个展开项目 B 的手风琴小部件，显示在浅色和深色主题中'
- en: '](img/Figure_5.1_B16820.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B16820.jpg)'
- en: Figure 5.1 – An accordion widget with item B expanded, shown in the light and
    dark themes
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 一个展开项目 B 的手风琴小部件，显示在浅色和深色主题中
- en: 'To create an `Accordion` widget, you must pass a list of `AccordionItem` objects
    that specify the title and details for each element in the accordion. You can
    also optionally specify the `Open` value, which, if set to `true`, will show the
    content by default. The following code block was used to create the previous `Accordion`
    images:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Accordion`小部件，您必须传递一个`AccordionItem`对象列表，该列表指定了折叠中每个元素的标题和详细信息。您还可以可选地指定`Open`值，如果设置为`true`，则默认显示内容。用于创建前面`Accordion`图像的代码块如下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, an `Accordion` widget shows only one item at a time. To allow any
    number of items to be shown, you can set the `MultiOpen` field to `true`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Accordion`小部件一次只显示一个项目。要允许显示任意数量的项目，可以将`MultiOpen`字段设置为`true`。
- en: Button
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮
- en: The `Button` widget provides a standard press button that can be activated by
    clicking it with a mouse (or by using the tap gesture on a touch screen). A button
    can contain text or icon content, or both. The `Button` constructor function also
    takes an anonymous `func` that is executed when the button is tapped.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`小部件提供了一个标准的按下按钮，可以通过鼠标点击（或在触摸屏上使用轻触手势）来激活。按钮可以包含文本或图标内容，或两者兼而有之。`Button`构造函数还接受一个匿名`func`，当按钮被轻触时执行。'
- en: 'You can create a button using the `widget.NewButton` or `widget.NewButtonWithIcon`
    constructor functions. It is recommended to use the built-in theme icons where
    possible (for more information, please see the *Themes* section later in this
    chapter), as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`widget.NewButton`或`widget.NewButtonWithIcon`构造函数来创建一个按钮。建议尽可能使用内置的主题图标（有关更多信息，请参阅本章后面的*主题*部分），如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The button in each theme is shown in the following image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题中的按钮如图所示：
- en: '![Figure 5.2 – A button with its icon shown in light and dark themes'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 在亮暗主题中显示其图标的按钮'
- en: '](img/Figure_5.2_B16820.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.2_B16820.jpg]'
- en: Figure 5.2 – A button with its icon shown in light and dark themes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 在亮暗主题中显示其图标的按钮
- en: 'Most buttons have the same look, but if you need one to stand out, you can
    set it to have a high importance style by setting `Button.Importance = widget.HighImportance`,
    as shown in the following image:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数按钮外观相同，但如果您需要让某个按钮突出，可以通过设置`Button.Importance = widget.HighImportance`来将其设置为高重要性样式，如图所示：
- en: '![Figure 5.3 – A high importance button in both light and dark themes'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 在亮暗主题中的高重要性按钮'
- en: '](img/Figure_5.3_B16820.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.3_B16820.jpg]'
- en: Figure 5.3 – A high importance button in both light and dark themes
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 在亮暗主题中的高重要性按钮
- en: The color used to represent high importance widgets will vary based on the theme
    and can even be set by the user. Another possible value for `Button.Importance`
    is `widget.LowImportance`, which reduces the visual impact of the display, for
    example, by removing the shadow shown in the previous two images.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示高重要性小部件的颜色将根据主题而变化，甚至可以由用户设置。`Button.Importance`的另一个可能值是`widget.LowImportance`，这会减少显示的视觉影响，例如，通过移除前面两个图像中显示的阴影。
- en: Card
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡片
- en: When the elements of the user interface relate to each other, it can be useful
    to group them together. This can be helpful when a group of items should be titled
    or where many different data elements want a larger preview than a simple list.
    A collection of `Card` widgets may be added to a `Container` with a grid layout
    to arrange similar items that display different content (such as search results
    or a preview of media items).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户界面的元素相互关联时，将它们分组在一起可能很有用。当一组项目需要标题或当许多不同的数据元素想要比简单列表更大的预览时，这很有帮助。可以将一组`Card`小部件添加到具有网格布局的`Container`中，以安排显示不同内容（如搜索结果或媒体项目的预览）的类似项目。
- en: 'A card widget can be created using the `NewCard` constructor function, which
    takes a title and subtitle string, as well as a `CanvasObject` content parameter.
    You can also specify the `Image` field after constructing or by creating the struct
    manually, as shown in the following code block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`NewCard`构造函数创建一个卡片小部件，该函数接受一个标题和副标题字符串，以及一个`CanvasObject`内容参数。您还可以在构建后或通过手动创建结构体来指定`Image`字段，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see the preceding code utilizing the light and dark themes in the following
    image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下图像中看到前面代码使用亮暗主题：
- en: '![Figure 5.4 – The card widget showing its titles and an image in light and
    dark modes'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 卡片小部件在亮暗模式下的标题和图像'
- en: '](img/Figure_5.4_B16820.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.4_B16820.jpg]'
- en: Figure 5.4 – The card widget showing its titles and an image in light and dark
    modes
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 卡片小部件在亮暗模式下的标题和图像
- en: All the fields that were used in the preceding code are optional. An empty string
    for either of the titles will remove it from the display, and a nil image or content
    removes it as well (you can see the missing content in the previous image).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的所有字段都是可选的。对于任何标题的空字符串都将将其从显示中移除，以及空图像或内容也将将其移除（你可以在前面的图像中看到缺失的内容）。
- en: Check
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复选
- en: 'Checkbox functionality is provided by the `Check` widget. It has two states:
    checked and unchecked (the default). The constructor takes a callback function,
    `func(bool)`, that will be called whenever the checked state changes, passing
    the current state (`true` means checked). The code for this is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框功能由`Check`小部件提供。它有两个状态：选中状态和未选中状态（默认）。构造函数接受一个回调函数`func(bool)`，该函数将在选中状态更改时被调用，传递当前状态（`true`表示选中）。此代码如下：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also manually set the checked state by calling the `SetChecked` method
    and passing `true` (or `false` to change it back to unchecked):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过调用`SetChecked`方法并传递`true`（或传递`false`以将其更改回未选中）来手动设置选中状态：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The different checked states, one in each theme, are shown in the following
    image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中显示了每个主题中不同的选中状态：
- en: '![Figure 5.5 – A light theme checkbox checked, and a dark theme checkbox unchecked'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – 亮色主题的复选框被选中，而暗色主题的复选框未被选中'
- en: '](img/Figure_5.5_B16820.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.5_B16820.jpg]'
- en: Figure 5.5 – A light theme checkbox checked, and a dark theme checkbox unchecked
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 亮色主题的复选框被选中，而暗色主题的复选框未被选中
- en: The checked indicator will adapt to the current theme, just like the text does.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 选中指示器将适应当前主题，就像文本一样。
- en: Entry
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条目
- en: 'Text input is primarily added through the `Entry` widget, which provides free
    text entry. A content hint can be added to a field by setting a `Placeholder`,
    and the text content can be set directly with the `Text` field or the `SetText()`
    method. Entries can be created with one of the following constructors. The first
    is a normal text field, the second is a password entry, and the third is used
    for multiline input (defaults to 3 lines):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输入主要通过`Entry`小部件添加，它提供自由文本输入。可以通过设置`Placeholder`向字段添加内容提示，并且可以直接使用`Text`字段或`SetText()`方法设置文本内容。可以使用以下构造函数之一创建条目。第一个是普通文本字段，第二个是密码输入，第三个用于多行输入（默认为3行）：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following image shows the standard and password entry widgets using the
    default themes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用默认主题的标准和密码输入小部件：
- en: '![Figure 5.6 – Entry and PasswordEntry widgets in light and dark themes'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.6 – 亮色和暗色主题下的Entry和PasswordEntry小部件'
- en: '](img/Figure_5.6_B16820.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.6_B16820.jpg]'
- en: Figure 5.6 – Entry and PasswordEntry widgets in light and dark themes
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 亮色和暗色主题下的Entry和PasswordEntry小部件
- en: 'The entry widget also supports validation, which can be used to give the user
    feedback on the current text. The different states can be seen in the following
    image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 条目小部件还支持验证，可用于向用户提供关于当前文本的反馈。不同的状态可以在以下图像中看到：
- en: '![Figure 5.7 – Validation status of success and failure using the light theme'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.7 – 使用亮色主题的成功和失败验证状态'
- en: '](img/Figure_5.7_B16820.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.7_B16820.jpg]'
- en: Figure 5.7 – Validation status of success and failure using the light theme
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 使用亮色主题的成功和失败验证状态
- en: While typing, an entry with a validator set will provide positive feedback when
    the content is valid. Invalid content will show a warning when the user stops
    editing the input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入时，当内容有效时，具有验证器集的条目将提供正面反馈。当用户停止编辑输入时，无效内容将显示警告。
- en: FileIcon
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件图标
- en: 'In addition to using static icons (see the Icon section, later in this section),
    the toolkit can display appropriate icons for different types of files. The `FileIcon`
    widget was created to make this common task much easier, by loading one of the
    standard icon resources and showing the file extension inside it. The icon matches
    the size of the standard `widget.Icon` and its image and text will be updated
    to reflect the specified URI. `FileIcon` widgets can be created by specifying
    the URI of a file resource, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用静态图标（参见本节后面的图标部分）之外，工具包还可以显示不同类型文件的适当图标。`FileIcon`小部件被创建出来，通过加载标准图标资源并在其中显示文件扩展名，使这项常见任务变得更容易。图标的大小与标准的`widget.Icon`相匹配，其图像和文本将更新以反映指定的URI。可以通过指定文件资源的URI来创建`FileIcon`小部件，如下所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will be rendered as follows, depending on the current theme:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将根据当前主题渲染如下：
- en: '![Figure 5.8 – The Fileicon widget showing the symbol and extension of a PNG
    image'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.8 – 显示PNG图像符号和扩展名的Fileicon小部件'
- en: '](img/Figure_5.8_B16820.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.8_B16820.jpg)'
- en: Figure 5.8 – The Fileicon widget showing the symbol and extension of a PNG image
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 显示 PNG 图像符号和扩展的 Fileicon 小部件
- en: '`FileIcon` widgets will vary their appearance, setting icons appropriate for
    the file type.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileIcon` 小部件将根据文件类型变化其外观，设置合适的图标。'
- en: Form
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单
- en: The form widget is useful for labeling and laying out various input elements.
    Each row of a form typically contains an input element with a label next to it.
    If the form has an `OnSubmit` or `OnCancel` function set, then it will automatically
    generate an additional row containing the appropriate action buttons.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表单小部件用于标记和布局各种输入元素。表单的每一行通常包含一个带有标签的输入元素。如果表单设置了 `OnSubmit` 或 `OnCancel` 函数，那么它将自动生成一个包含相应操作按钮的额外行。
- en: 'You can create a form by passing a list of `FormItem` objects into the `NewForm()`
    constructor function, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将 `FormItem` 对象的列表传递给 `NewForm()` 构造函数来创建一个表单，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also call `Form.Append()` to add elements later. The form will look
    as follows, depending on the current theme:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以调用 `Form.Append()` 来稍后添加元素。表单的外观将根据当前主题如下所示：
- en: '![Figure 5.9 – A login form shown in light and dark themes'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – 在浅色和深色主题中显示的登录表单'
- en: '](img/Figure_5.9_B16820.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.9_B16820.jpg)'
- en: Figure 5.9 – A login form shown in light and dark themes
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 在浅色和深色主题中显示的登录表单
- en: An additional benefit of grouping input elements into a form is that it can
    help ensure that only validated input is submitted. If any of the widgets have
    a validator set, then the form will only allow submission once all the validators
    have passed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入元素分组到表单中还有一个额外的好处，那就是它可以帮助确保只有经过验证的输入才会被提交。如果任何小部件设置了验证器，那么表单将只允许在所有验证器都通过后提交。
- en: Hyperlink
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超链接
- en: 'In some situations, it can be helpful to provide a tappable URL string that
    opens a web page in the user’s browser. For this use case, there is a `Hyperlink`
    widget that accepts a `URL` parameter for the page to open when it’s tapped. To
    create a hyperlink widget, we may need to parse a URL, as shown in the following
    code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，提供可点击的 URL 字符串以在用户的浏览器中打开网页可能会有所帮助。为此用例，有一个 `Hyperlink` 小部件，它接受一个 `URL`
    参数，当它被点击时打开页面。要创建超链接小部件，我们可能需要解析一个 URL，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The widget looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的外观如下：
- en: '![Figure 5.10 – A hyperlink widget using the light and dark themes'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 使用浅色和深色主题的超链接小部件'
- en: '](img/Figure_5.10_B16820.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B16820.jpg)'
- en: Figure 5.10 – A hyperlink widget using the light and dark themes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 使用浅色和深色主题的超链接小部件
- en: Icon
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图标
- en: 'Although you can add a `canvas.Image` to a user interface directly, it can
    sometimes be useful to have a consistent size. The `Icon` widget provides this,
    loading a standard resource and setting its minimum size to the theme-defined
    icon size. The icon will also update to match the current theme. We can create
    an icon that shows the standard paste image using the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以直接将 `canvas.Image` 添加到用户界面中，但有时保持一致的大小可能很有用。`Icon` 小部件提供了这一点，加载标准资源并将其最小尺寸设置为主题定义的图标大小。图标还将更新以匹配当前主题。我们可以使用以下代码创建一个显示标准粘贴图像的图标：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code will be rendered as follows, depending on the current theme:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将根据当前主题进行渲染：
- en: '![Figure 5.11 – The icon widget showing the paste icon in the light and dark
    themes'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – 在浅色和深色主题中显示粘贴图标的图标小部件'
- en: '](img/Figure_5.11_B16820.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B16820.jpg)'
- en: Figure 5.11 – The icon widget showing the paste icon in the light and dark themes
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 在浅色和深色主题中显示粘贴图标的图标小部件
- en: Next, we move on to the label widget.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续介绍标签小部件。
- en: Label
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: 'Displaying text is normally recommended using the `Label` widget. It is possible
    to use `canvas.Text` but, as we saw in [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*, those elements use a developer-defined color –
    in most user interfaces, it is preferable for the text to match the current theme,
    which is what the `Label` widget takes care of:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议使用 `Label` 小部件来显示文本。虽然可以使用 `canvas.Text`，但正如我们在 [*第 3 章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)
    中看到的，*Windows、Canvas 和绘图*，这些元素使用开发者定义的颜色 – 在大多数用户界面中，文本匹配当前主题更可取，这正是 `Label` 小部件所处理的：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The label widget in each theme looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题中的标签小部件看起来如下：
- en: '![Figure 5.12 – A text label in the light and dark themes'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 在浅色和深色主题中的文本标签'
- en: '](img/Figure_5.12_B16820.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B16820.jpg)'
- en: Figure 5.12 – A text label in the light and dark themes
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 浅色和深色主题中的文本标签
- en: This widget also supports additional text formatting such as newline, word wrap,
    and truncation. A string containing the newline character (`\n`) will be broken
    into a second line and be fully visible, whereas setting `Label.Wrapping = fyne.TextWrapWord`
    (or `fyne.TextWrapBreak`) will automatically add new lines when the widget’s width
    requires it. Setting the value to `fyne.TextWrapTruncate` will simply remove overflowing
    text from the display.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件还支持额外的文本格式化，如换行、自动换行和截断。包含换行符（`\n`）的字符串将被拆分为第二行并完全可见，而将`Label.Wrapping`设置为`fyne.TextWrapWord`（或`fyne.TextWrapBreak`）将自动在小部件宽度需要时添加新行。将值设置为`fyne.TextWrapTruncate`将简单地从显示中移除溢出的文本。
- en: Pop-up menu
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出菜单
- en: The `PopUpMenu` widget is helpful for displaying context menus or allowing a
    user to choose from options where a built-in widget is not providing the desired
    functionality. To create a menu in this way, you need a `fyne.Menu` data structure
    that describes the options available (this is the same structure we used in [*Chapter
    3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066), *Windows, Canvas, and Drawing*,
    for the main menu). In this case, the title of the menu can be empty as it will
    not be displayed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`PopUpMenu`小部件对于显示上下文菜单或允许用户在内置小部件无法提供所需功能时从选项中选择非常有用。要以这种方式创建菜单，你需要一个`fyne.Menu`数据结构来描述可用的选项（这是我们用于[*第3章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)，*窗口、画布和绘图*，主菜单的相同结构）。在这种情况下，菜单的标题可以是空的，因为它将不会显示。'
- en: 'Once the menu has been defined, the `ShowPopUpMenuAtPosition` utility function
    is the easiest way to display this to the user. This function takes an absolute
    position in the window and displays the menu in the top-left corner. As with other
    pop-up elements, this can be dismissed by tapping outside of the content shown,
    thereby returning the user to the previous state. You can use the following code
    to do this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了菜单，`ShowPopUpMenuAtPosition`实用函数就是向用户显示此菜单的最简单方法。此函数接受窗口中的绝对位置并在左上角显示菜单。与其他弹出元素一样，可以通过在显示的内容外轻触来关闭它，从而将用户返回到之前的状态。你可以使用以下代码来完成此操作：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code will create a new menu over the current content of the window.
    The result will look as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在窗口当前内容上方创建一个新菜单。结果如下所示：
- en: '![Figure 5.13 – PopUpMenu shown in the light and dark themes'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.13 – PopUpMenu shown in the light and dark themes](img/Figure_5.13_B16820.jpg)'
- en: '](img/Figure_5.13_B16820.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.13_B16820.jpg](img/Figure_5.13_B16820.jpg)'
- en: Figure 5.13 – PopUpMenu shown in the light and dark themes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 在浅色和深色主题中显示的PopUpMenu
- en: It is also possible to use the `Menu` widget directly here. The `widget.NewMenu`
    constructor function can be used to render a menu without it creating an overlay
    like `PopUpMenu` does.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接在这里使用`Menu`小部件。可以使用`widget.NewMenu`构造函数渲染菜单，而不会像`PopUpMenu`那样创建覆盖层。
- en: ProgressBar
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProgressBar
- en: 'If an application needs to indicate that a process will take some time to perform,
    then you can use the `ProgressBar` widget. There are two variations: `widget.ProgressBar`
    and `widget.ProgressBarInfinite`. A regular progress bar shows a current `Value`
    ranging from `Min` to `Max` (default *0* to *1*), and the developer is responsible
    for setting the value as the process progresses. When using the infinite progress
    bar, there is no intrinsic value, so the output renders an animation that indicates
    an activity (a change in the value) for an undefined duration. We can create a
    progress bar using one of the following lines:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序需要指示一个过程将需要一些时间来执行，那么你可以使用`ProgressBar`小部件。有两种变体：`widget.ProgressBar`和`widget.ProgressBarInfinite`。常规进度条显示从`Min`到`Max`（默认*0*到*1*）的当前`Value`，开发者负责在过程进行时设置值。当使用无限进度条时，没有内在值，因此输出渲染一个动画，表示活动（值的改变）在未定义的时间内。我们可以使用以下任一行来创建进度条：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These two versions of the progress bar look as follows, with `bar1` on the
    left and `bar2` on the right:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本的进度条看起来如下，左侧是`bar1`，右侧是`bar2`：
- en: '![Figure 5.14 – The standard and infinite progress bars shown with light and
    dark themes'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.14 – The standard and infinite progress bars shown with light and
    dark themes](img/Figure_5.14_B16820.jpg)'
- en: '](img/Figure_5.14_B16820.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.14_B16820.jpg](img/Figure_5.14_B16820.jpg)'
- en: Figure 5.14 – The standard and infinite progress bars shown with light and dark
    themes
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 在浅色和深色主题中显示的标准和无限进度条
- en: If you wish to add a different text overlay for the regular progress widget,
    then you can use the `TextFormatter` field, setting a function which returns a
    string value. This can be formatted based on the widget’s state or something different
    such as the `loading...` string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望为常规进度小部件添加不同的文本叠加，则可以使用`TextFormatter`字段，设置一个返回字符串值的函数。这可以根据小部件的状态或类似`加载中...`的字符串进行格式化。
- en: RadioGroup
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单选按钮组
- en: 'The radio group widget is the most common way of requesting user input. The
    outcome is similar to the `Select` widget (discussed next), but the options are
    all visible. The `RadioGroup` widget can be created by specifying a slice of string
    values that will be listed as options. The second parameter is a callback that
    will execute each time the selection is changed, passing the new value into the
    function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮组小部件是请求用户输入的最常见方式。结果与下一个讨论的`选择`小部件类似，但所有选项都是可见的。`RadioGroup`小部件可以通过指定将作为选项列出的字符串值片段来创建。第二个参数是一个回调函数，每次选择改变时都会执行，将新值传递给函数：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The radio group widget looks as follows in the different themes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮组小部件在不同主题中的外观如下：
- en: '![Figure 5.15– A radio group with two options, top selected, in the light and
    dark themes'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15 – 在浅色和深色主题中显示的带有两个选项的单选按钮组，顶部被选中]'
- en: '](img/Figure_5.15_B16820.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.15 – B16820.jpg]'
- en: Figure 5.15– A radio group with two options, top selected, in the light and
    dark themes
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15– 在浅色和深色主题中显示的带有两个选项的单选按钮组，顶部被选中
- en: Select
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: 'Like the preceding `RadioGroup` widget, the `Select` widget allows the user
    to choose one item from a list. It is more common to use `Select` when the list
    of options is long or the space that’s available is small. This widget appears
    as a button showing the current value. When tapped, this will show a popup menu
    that lists the options that are available:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的`单选按钮组`小部件类似，`选择`小部件允许用户从列表中选择一个项目。当选项列表很长或可用空间较小的时候，更常用`选择`。此小部件以显示当前值的按钮形式出现。当触摸时，将显示一个弹出菜单，列出可用的选项：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Select` widget looks as follows in the different themes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`选择`小部件在不同主题中的外观如下：'
- en: '![Figure 5.16 – The select widget shown in the light and dark themes'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – 在浅色和深色主题中显示的选择小部件]'
- en: '](img/Figure_5.16_B16820.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.16 – B16820.jpg]'
- en: Figure 5.16 – The select widget shown in the light and dark themes
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 在浅色和深色主题中显示的选择小部件
- en: Next is the `SelectEntry` widget.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`选择条目`小部件。
- en: SelectEntry
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择条目
- en: '`SelectEntry` is much like the `Select` widget described previously, except
    that it allows user-defined options as well. This can be done by presenting an
    `Entry` widget with a select-style drop-down icon that lists the specified options.
    Because the current value can change on every keystroke, the callback for this
    widget is configured like `Entry` rather than `Select` – it is not passed as a
    select change function in the constructor but can instead be set on the `OnChanged`
    field of the widget:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`选择条目`与之前描述的`选择`小部件类似，不同之处在于它还允许用户定义选项。这可以通过提供一个带有选择样式下拉图标的`Entry`小部件来实现，该图标列出指定的选项。因为当前值可以在每次按键时改变，所以此小部件的回调配置与`Entry`类似，而不是`选择`——它不是作为构造函数中的选择更改函数传递，而是可以在小部件的`OnChanged`字段上设置：'
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `SelectEntry` widget looks as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`选择条目`小部件的外观如下：'
- en: '![Figure 5.17 – The SelectEntry widget before input is added in the light and
    dark themes'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – 在浅色和深色主题中添加输入前的选择条目小部件]'
- en: '](img/Figure_5.17_B16820.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.17 – B16820.jpg]'
- en: Figure 5.17 – The SelectEntry widget before input is added in the light and
    dark themes
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 在浅色和深色主题中添加输入前的选择条目小部件
- en: Next is the `Slider` widget.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`滑动条`小部件。
- en: Slider
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动条
- en: The `Slider` widget can be used for inputting a number within a range, particularly
    when the exact number may not be known to the user. This can be useful, for example,
    when specifying brightness or volume – the number is not important to the end
    user, but it has a clear range from `Min` to `Max`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`滑动条`小部件可用于在范围内输入一个数字，尤其是在用户可能不知道确切数字时。例如，当指定亮度或音量时，这可能很有用——数字对最终用户来说并不重要，但它有一个从`最小值`到`最大值`的明确范围。'
- en: 'A `Slider` widget can be created by specifying `Min` and `Max` values through
    the constructor. Its default value will be set to the minimum, and this can be
    changed by setting `Slider.Value`. It is also possible to specify a `Step` value,
    which defines the distance between each valid value. Without a defined step, any
    floating-point value between the minimum and maximum will be allowed. By specifying
    `Step`, you could, for example, accept only integer values. In this mode, the
    user may see the slider "jump" from one valid value to another as they slide the
    widget:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过构造函数指定`Min`和`Max`值来创建`Slider`小部件。它的默认值将被设置为最小值，并且可以通过设置`Slider.Value`来更改。还可能指定一个`Step`值，它定义了每个有效值之间的距离。如果没有定义步长，则允许在最小值和最大值之间的任何浮点值。通过指定`Step`，例如，您可以只接受整数值。在这种模式下，当用户滑动小部件时，滑块可能会从一个有效值跳到另一个有效值：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code will create a simple slider widget set to the minimum value,
    as shown in the following image:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建一个简单的滑动条小部件，设置为最小值，如下面的图像所示：
- en: '![Figure 5.18 – The Slider widget shown at its minimum in the light and dark
    themes'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18 – 在浅色和深色主题中显示的滑动条小部件在最小值时的样子'
- en: '](img/Figure_5.18_B16820.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.18_B16820.jpg)'
- en: Figure 5.18 – The Slider widget shown at its minimum in the light and dark themes
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – 在浅色和深色主题中显示的滑动条小部件在最小值时的样子
- en: TextGrid
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextGrid
- en: Although the `Label` widget (described earlier) does provide some text formatting,
    there are some applications that require styles to be applied per-character. For
    syntax highlighting in a code editor or for showing error rows indicated on a
    console output, there is the `TextGrid` widget.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面提到的`Label`小部件提供了一些文本格式化功能，但有些应用程序需要按字符应用样式。对于代码编辑器中的语法高亮显示或显示在控制台输出上的错误行，有`TextGrid`小部件。
- en: Inside a `TextGrid` widget, the content is split into each rune of the string
    representation, and each rune has a `TextGridStyle` applied to it. This style
    allows the foreground and background color to be specified for each character
    or cell of the grid. Additionally, each row of the grid can have a style specified.
    This style will be used for any cell that does not have its own style specified.
    If a cell has a character and a row style available, the two will be combined
    so that the foreground color that’s been set on the cell will adopt a background
    color from the row; that is, unless the character style specifies both.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TextGrid`小部件内部，内容被分割成字符串表示中的每个字符，并且每个字符都应用了一个`TextGridStyle`。这种样式允许为每个字符或网格中的单元格指定前景和背景颜色。此外，网格的每一行都可以指定一个样式。这个样式将用于任何没有指定自己样式的单元格。如果一个单元格有字符和行样式可用，这两个样式将会合并，使得单元格上设置的前景色将采用行的背景色；除非字符样式指定了两者。
- en: Despite the styles that allow specific colors to be set, there are a number
    of semantic style definitions that allow code to annotate intent instead of absolute
    colors. One of the most commonly used styles is `TextGridStyleWhitespace` that
    uses the theme definition to show characters in a muted color. Using the built-in
    styles, a developer can delegate to the current theme to define colors for each
    intent.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管允许设置特定颜色的样式存在，但还有许多语义样式定义允许代码注释意图而不是绝对颜色。最常用的样式之一是`TextGridStyleWhitespace`，它使用主题定义以柔和的颜色显示字符。使用内置样式，开发者可以将颜色定义委托给当前主题，为每个意图定义颜色。
- en: 'The `TextGrid` widget also provides common functionality for technical text
    displays, including `ShowLineNumbers`, which displays the line number at the beginning
    of each row. Also, `ShowWhitespace` can be set to true for a visual indicator
    of otherwise invisible spacing characters such as tab, space, and newline. The
    following code example illustrates some of the ways you can control text in a
    `TextGrid`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextGrid`小部件还提供了技术文本显示的常用功能，包括`ShowLineNumbers`，它会在每一行的开头显示行号。`ShowWhitespace`也可以设置为true，以在视觉上指示其他不可见的空白字符，如制表符、空格和换行符。以下代码示例说明了您可以在`TextGrid`中控制文本的一些方法：'
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following image shows the result of the preceding code. Here, we can see
    that a background style has been applied to all the cells used in the 4 letters
    of *Grid* and that a row style has been applied to the second row (index 1). They
    also have line numbers and the whitespace options turned on:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像显示了前面代码的结果。在这里，我们可以看到背景样式已经应用于*Grid*中使用的4个字母的所有单元格，并且第二行（索引1）应用了行样式。它们还启用了行号和空白选项：
- en: '![Figure 5.19 – Styled content presented using TextGrid in the light and dark
    themes'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 使用 TextGrid 在浅色和深色主题下展示的样式化内容'
- en: '](img/Figure_5.19_B16820.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.19_B16820.jpg]'
- en: Figure 5.19 – Styled content presented using TextGrid in the light and dark
    themes
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 使用 TextGrid 在浅色和深色主题下展示的样式化内容
- en: The style for a cell can be assigned using the `SetStyle` method. However, when
    the style needs to be applied to many runes, developers can use the more efficient
    `SetStyleRange` utility method. The `SetRowStyle` method can assist in setting
    row styles, as shown in the previous image.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `SetStyle` 方法为单元格分配样式。然而，当需要将样式应用于许多符文时，开发者可以使用更高效的 `SetStyleRange` 工具方法。`SetRowStyle`
    方法可以帮助设置行样式，如前图所示。
- en: Toolbar
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具栏
- en: If there are lots of regularly accessed features in an application, the `Toolbar`
    widget can be an efficient way to present these options. The main elements of
    a toolbar are the `ToolbarAction` items, which are simple icons that, when tapped,
    execute a function parameter that’s been passed to `NewToolbarAction`. To group
    action elements, you can use `ToolbarSeparator`, which creates a visual divider
    between the item on its left and right. Additionally, a gap can be created between
    actions using the `ToolbarSpacer` type. This will expand, causing the elements
    after it to be right aligned. Using one spacer will show items before it on the
    left and items after it on the right. Using two will mean that the elements between
    the spacers will be central in the toolbar.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序中有许多经常访问的功能，`Toolbar` 小部件可以是一种高效展示这些选项的方法。工具栏的主要元素是 `ToolbarAction` 项目，它们是简单的图标，当点击时，会执行传递给
    `NewToolbarAction` 的函数参数。要分组操作元素，可以使用 `ToolbarSeparator`，它在其左右两侧创建一个视觉分隔符。此外，可以使用
    `ToolbarSpacer` 类型在操作之间创建一个间隙。这将扩展，导致其后的元素右对齐。使用一个空格将显示其左侧的项和其右侧的项。使用两个空格意味着空格之间的元素将在工具栏中居中。
- en: 'To construct a toolbar containing four action elements and a separator, we
    can use the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建包含四个操作元素和一个分隔符的工具栏，我们可以使用以下代码：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code snippet results in the following. The following image shows
    it in both the light and dark themes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段会产生以下结果。以下图像展示了它在浅色和深色主题下的样子：
- en: '![Figure 5.20 – Toolbar widget with some possible icons in the light and dark
    themes'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.20 – 在浅色和深色主题下具有一些可能图标的工具栏小部件'
- en: '](img/Figure_5.20_B16820.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.20_B16820.jpg]'
- en: Figure 5.20 – Toolbar widget with some possible icons in the light and dark
    themes
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 在浅色和深色主题下具有一些可能图标的工具栏小部件
- en: The widgets that we have explored so far are fairly standard and can be created
    with simple constructors, or through initializing the struct directly. Some of
    these take a callback function that can be used to inform us when an action has
    occurred.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所探讨的小部件相当标准，可以通过简单的构造函数创建，或者通过直接初始化结构体。其中一些需要回调函数，该函数可以用来通知我们何时发生了动作。
- en: In the next section, we’ll look at some more complex widgets that are designed
    to manage thousands of sub-widgets. To do so, we will learn how they make use
    of more function parameters to query large datasets and efficiently display a
    subset of the data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一些更复杂的小部件，这些小部件旨在管理数千个子小部件。为此，我们将学习它们如何使用更多的函数参数查询大型数据集并高效地显示数据子集。
- en: Grouping with the collection widgets
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合小部件进行分组
- en: In this section, we will look at widgets that are designed to efficiently contain
    main widgets. Some of the widgets mentioned in the previous section do this, such
    as `Form` and `Toolbar`, but **collection widgets** support thousands of items
    (though they’re not all visible at one time). These widgets are commonly used
    for displaying a huge numbers of options or navigating complex datasets.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看旨在高效包含主要小部件的小部件。上一节中提到的某些小部件也执行此操作，例如 `Form` 和 `Toolbar`，但**集合小部件**可以支持数千个项目（尽管它们并不是一次性都可见）。这些小部件通常用于显示大量选项或导航复杂的数据集。
- en: Due to the requirement that collection widgets only show large amounts of data,
    they are designed to only show a small portion of the possible widget at a time.
    To do this, and to maintain great performance, they have a caching mechanism that
    makes their API a little more complex than the widgets we have seen previously.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合小部件只显示大量数据的要求，它们被设计成一次只显示可能小部件的一小部分。为此，并保持出色的性能，它们有一个缓存机制，这使得它们的 API 比我们之前看到的小部件要复杂一些。
- en: Callbacks
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数
- en: Each of these widgets relies on a number of callback functions. The first of
    these functions will provide information on the dimensions of the data that the
    widget will display (for a more complete discussion on data, see [*Chapter 6*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166),
    *Data Binding and Storage*). The second of these is responsible for creating visual
    elements that will be displayed later, while the third will load an item from
    the data into a previously created element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小部件中的每一个都依赖于多个回调函数。这些函数中的第一个将提供有关小部件将要显示的数据维度（有关数据的更完整讨论，请参阅[*第6章*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166)，*数据绑定和存储*)的信息。第二个负责创建稍后将要显示的视觉元素，而第三个将数据中的项加载到先前创建的元素中。
- en: Caching
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存
- en: The key to the performance of collection widgets is how they cache the graphical
    elements that repeat within them. The template objects referenced in collection
    widget constructors will be reused as the user scrolls the widget to maintain
    performance and keep up with the user actions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 集合小部件的性能关键在于它们如何缓存其中的重复图形元素。在集合小部件构造函数中引用的模板对象将在用户滚动小部件时被重用，以保持性能并跟上用户操作。
- en: The `List` widget (and other collection widgets) maintains an internal cache
    of recently used template elements that will have new data applied in preparation
    for the next rows becoming visible. It is the job of the application developer
    to optimize data retrieval so that any items that are close to those that are
    already visible will load quickly. We will see these concepts in use as we explore
    the various collection widgets that are available to us. First, we will look at
    the List widget.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`列表`小部件（以及其他集合小部件）维护一个最近使用的模板元素的内部缓存，这些元素将在下一行变为可见之前应用新数据。优化数据检索以使任何接近已可见项的项能够快速加载是应用程序开发者的工作。当我们探索可用的各种集合小部件时，我们将看到这些概念的应用。首先，我们将查看列表小部件。'
- en: List
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: The `List` widget is used to display a vertical list of items where each item
    has a similar look. The relevant data can be loaded once the widget has been created,
    so it can be helpful if the data is slow to load or complex to display. The widget
    will only load and display the elements that are visible, thereby displaying the
    elements of a large dataset quickly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`列表`小部件用于显示具有相似外观的垂直项目列表。一旦创建小部件，就可以加载相关数据，因此如果数据加载缓慢或显示复杂，这可能很有帮助。小部件将只加载和显示可见的元素，从而快速显示大型数据集的元素。'
- en: Callbacks
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调
- en: 'Each of the collection widgets uses callback functions to understand the data,
    load a template item, and update it when the data is loaded. Let’s look at these
    in more detail:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合小部件都使用回调函数来理解数据、加载模板项并在数据加载时更新它。让我们更详细地看看这些：
- en: 'Understanding the data – the `Length` callback: The first callback function
    for `List` is the `length` callback, which returns the number of items in the
    data. This tells the widget how many rows it will need to manage. If more items
    are added to the dataset, this value can be updated, and next time the list refreshes,
    it will adjust accordingly.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据 - `长度`回调：`列表`的第一个回调函数是`长度`回调，它返回数据中的项目数量。这告诉小部件它需要管理多少行。如果数据集中添加了更多项，此值可以更新，并且下次列表刷新时，它将相应地调整。
- en: 'Loading a template – the `CreateItem` callback: The second callback function
    is used to generate a reusable graphical element that will load data. This is
    called a `CanvasObject` and can be any type of `Widget`, `Container`, or item
    from the `canvas` package. The widget will call this function as many times as
    there are items visible on the screen. At this stage, they should contain just
    placeholder values. For example, in the images that follow, each row contains
    an icon and a label, so the returned template would probably be a container with
    a horizontal box layout, along with a default icon and placeholder text in the
    label. Although the user will never see the placeholder values, they are important
    as the size of a template configures the `List` component. The height of a template
    item will be used for the height of every row so that when it’s multiplied by
    the result of the previous length, the callback will determine the overall scroll
    height of the list component. Additionally, the template width will specify the
    minimum width for the `List` component.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载模板 – `CreateItem` 回调：第二个回调函数用于生成一个可重复使用的图形元素，用于加载数据。这被称为 `CanvasObject`，可以是任何类型的
    `Widget`、`Container` 或来自 `canvas` 包的项。小部件将根据屏幕上可见的项数多次调用此函数。在这个阶段，它们应该只包含占位符值。例如，在下面的图像中，每一行包含一个图标和一个标签，因此返回的模板可能是一个具有水平框布局的容器，以及默认图标和标签中的占位符文本。尽管用户永远不会看到占位符值，但它们很重要，因为模板的大小配置了
    `List` 组件。模板项的高度将用于每一行的高度，以便当它乘以前一个长度的结果时，回调将确定列表组件的整体滚动高度。此外，模板宽度将指定 `List` 组件的最小宽度。
- en: 'Filling the template with data – the `UpdateItem` callback: Callback three
    is used to apply data to a template cell. It receives two parameters: the index
    of the data item to use and the `CanvasObject` template that we configured earlier.
    The purpose of this callback is to configure the item with the data that should
    be used at the specified index. The template that’s used will be identical to
    the return object of the second parameter so that it can be cast appropriately.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用数据填充模板 – `UpdateItem` 回调：回调三是用于将数据应用于模板单元格。它接收两个参数：要使用的数据项的索引和之前配置的 `CanvasObject`
    模板。此回调的目的是使用在指定索引处应使用的数据配置项。所使用的模板将与第二个参数的返回对象相同，以便可以适当地进行类型转换。
- en: Each collection widget has variations of the pattern described previously, as
    we will see in the *Table* and *Tree* sections later in this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合小部件都有之前描述的模式的变体，正如我们将在本章后面的 *表格* 和 *树* 部分中看到的那样。
- en: Selection
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择
- en: 'One additional feature of the collection widgets is that they allow an element
    to be selected (by being tapped). In the list interface, the selected element
    is indicated by a marker at the leading edge, as shown in the preceding image.
    To be notified when an item is selected, you can set a `func(ListItemID)` callback
    on the `OnSelected` field, which will notify you of which item from the dataset
    was selected. The basic code for creating a list is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 集合小部件的一个额外功能是它们允许选择一个元素（通过点击）。在列表界面中，所选元素通过前导边缘的标记表示，如前图所示。要通知何时选择了一个项，你可以在
    `OnSelected` 字段上设置一个 `func(ListItemID)` 回调，这将通知你哪个数据集中的项被选中。创建列表的基本代码如下：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code sample will generate the following output, once the second item has
    been tapped:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例将在第二次点击后生成以下输出：
- en: '![Figure 5.21 – List collection widget with an item selected in the light and
    dark themes'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.21 – 在浅色和深色主题中选中的列表集合小部件]'
- en: '](img/Figure_5.21_B16820.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.21 – B16820.jpg](img/Figure_5.21_B16820.jpg)'
- en: Figure 5.21 – List collection widget with an item selected in the light and
    dark themes
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 在浅色和深色主题中选中的列表集合小部件
- en: Table
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格
- en: The `Table` widget is a two-dimensional version of the `List` widget and is
    designed for showing large datasets with row and column aspects. It uses the same
    system for caching and callbacks as the `List` and `Tree` widgets.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table` 小部件是 `List` 小部件的二维版本，旨在显示具有行和列维度的大型数据集。它使用与 `List` 和 `Tree` 小部件相同的缓存和回调系统。'
- en: Callbacks
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调
- en: The `Table` widget’s callbacks are similar to those for `List`, but the data
    identifiers pass a row and column `int` to index the data structure. This means
    that the `Length` callback now returns `(int, int)`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table` 小部件的回调与 `List` 的回调类似，但数据标识符传递一个行和列 `int` 来索引数据结构。这意味着 `Length` 回调现在返回
    `(int, int)`。'
- en: The callback that sets up new graphical templates in the `Table` version (called
    `CreateCell`) takes no parameters and just returns a `fyne.CanvasObject` that
    will be cached for use in the display. This template is used to determine the
    default size of all cells, so make sure that it has a sensible minimum size. As
    with `List`, the element you return here will not be presented to the user but
    will be used for measurements and configuring the overall layout.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Table`版本中设置新图形模板的回调（称为`CreateCell`）不接收任何参数，仅返回一个`fyne.CanvasObject`，该对象将被缓存以用于显示。此模板用于确定所有单元格的默认大小，因此请确保它有一个合理的最小尺寸。与`List`一样，您在此返回的元素将不会呈现给用户，但将用于测量和配置整体布局。
- en: The last required callback is `UpdateCell` and is used to apply data to a template
    element. In the `Table` widget, this function passes a data identifier (`TableCellID`,
    which contains a `Row` and `Col` int) that indexes the data to apply, as well
    as the `CanvasObject` template. Developers should fill in the template with the
    appropriate data specified by the identifier. As with other collection widgets,
    it is recommended, where possible, to load related data so that when the user
    scrolls or expands an element, any data that takes a long time to load is ready
    to be displayed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后必需的回调是`UpdateCell`，用于将数据应用于模板元素。在`Table`小部件中，此函数传递一个数据标识符（`TableCellID`，其中包含一个`Row`和`Col`整型），它索引要应用的数据，以及`CanvasObject`模板。开发人员应在模板中填充由标识符指定的适当数据。与其他集合小部件一样，建议尽可能加载相关数据，以便当用户滚动或展开元素时，任何需要很长时间才能加载的数据都准备好显示。
- en: Selection
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择
- en: 'The `Table` widget supports a selected cell, as is indicated by a marker at
    the leading edge and header, as shown in the following image. To be notified of
    when an item has been selected, you can set the `func(TableCellID)` callback on
    the `OnSelected` field. This will notify you of which item from the dataset was
    selected by passing the identifying row and column. The basic code for creating
    a new table is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`小部件支持选择单元格，如以下图像所示，在首部和边框处有标记。要通知何时选择了项目，可以在`OnSelected`字段上设置`func(TableCellID)`回调。这将通过传递标识行和列来通知您选择了数据集中的哪个项目。创建新表格的基本代码如下：'
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code will generate the following output, assuming cell 2, 1 is
    tapped to gain selection:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设单元格 2, 1 被点击以获得选择，前面的代码将生成以下输出：
- en: '![Figure 5.22 – Table collection widget showing selection in the light and
    dark themes'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.22 – 表格集合小部件在浅色和深色主题下的选择'
- en: '](img/Figure_5.22_B16820.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.22_B16820.jpg)'
- en: Figure 5.22 – Table collection widget showing selection in the light and dark
    themes
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 表格集合小部件在浅色和深色主题下的选择
- en: Tree
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树形结构
- en: The `Tree` widget is very similar to the `List` widget, but with the added feature
    that each element can expand to show other items. This expansion is used to show
    a hierarchy, such as directories and files, categories and items, or other data
    with a parent-child relationship present.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tree`小部件与`List`小部件非常相似，但增加了每个元素可以展开以显示其他项目的功能。这种展开用于显示层次结构，例如目录和文件、类别和项目，或者具有父子关系的其他数据。'
- en: Callbacks
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调
- en: The `Tree` widget’s callbacks are similar to `List` and `Table`, but its more
    complex data structure means that the simple `Length` callback is replaced by
    `ChildUIDs` and `IsBranch`. The first of these callbacks will return a slice of
    `TreeNodeID` values (regular strings can be used) that contain the unique identifier
    for each item that exists under the specified node (passed in as a unique `TreeNodeID`).
    The second is called for each element while passing the unique ID. It should return
    `true` if it can container further nodes, or `false` otherwise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tree`小部件的回调与`List`和`Table`类似，但由于其更复杂的数据结构，简单的`Length`回调被`ChildUIDs`和`IsBranch`所取代。第一个回调将返回一个`TreeNodeID`值（可以使用常规字符串）的切片，这些值包含指定节点（作为唯一的`TreeNodeID`传入）下存在的每个项目的唯一标识符。第二个回调在传递唯一ID时对每个元素进行调用。如果它可以包含更多节点，则应返回`true`，否则返回`false`。'
- en: The callback that sets up new graphical templates in the `Tree` version (called
    `CreateNode`) takes a bool parameter that represents if this is a branch (`true`,
    can expand) or a leaf (`false`, this is the end of the tree). This is useful if
    you want to use a different style for the branch and leaf elements within your
    tree. As with `List`, the element you return here will not be presented to the
    user but will be used for measurements and configuring the overall layout.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The last required callback is `UpdateNode`. This is used to apply data to a
    template element. In the `Tree` widget, this function passes the unique `TreeNodeID`
    identifier, a `bool` representing whether this is a branch or leaf template, and
    the `CanvasObject` template. Developers should fill in this template with the
    appropriate data specified by the identifier. As with other collection widgets,
    it is recommended, where possible, to load related data so that when the user
    scrolls or expands an element, data that loads slowly is ready to be displayed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, regarding the callbacks that are required to manage content, the
    `Tree` widget allows developers to set the `OnBranchOpened` and `OnBranchClosed`
    callbacks so that they can track changes in the state of the tree. Both functions
    are of the `func(TreeNodeID)` type, where the parameter is the unique identifier
    of the data item.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Tree` widget also supports selected nodes. This is indicated by a marker
    at the leading edge, as shown in the following image. To be notified of when an
    item has been selected, you can set the `func(TreeNodeID)` callback on the `OnSelected`
    field. This will notify you of which item of the dataset was selected, while passing
    the unique identifier. The basic code required to show a tree is as follows. The
    first callback is returning the unique IDs of the children at each level:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code will display a tree in the app. Once the second element
    has been expanded, this tree will look as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Tree widget with the branch expanded, shown in the light and
    dark themes'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B16820.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Tree widget with the branch expanded, shown in the light and dark
    themes
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The three collection widgets shown in this section provide useful functionality
    for presenting large or complex data. The API is a little more complex than the
    standard widgets, but this allows massive datasets to be presented to users; for
    example, by scrolling through thousands of records from a database or showing
    parts of a large file tree.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: There’s a selection of container widgets that we can use to build out more complex
    user interface designs and navigate through applications. We will discover these
    in the following section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Adding structure with container widgets
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066), *Window, Canvas,
    and Drawing*, we learned how a `Container` is used to group multiple objects within
    a canvas. Using the layouts we explored in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*, it is possible to automatically arrange each `CanvasObject`
    according to certain rules. However, sometimes, an application would like items
    to appear and disappear according to user interaction, or to have visual attributes
    beyond their size and position. Container widgets can provide these richer behaviors.
    These structural widgets can be found in the `container` package and include scrolling,
    grouping, and variations of hiding and showing content. Let’s explore each of
    these options (in alphabetical order).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)，“窗口、画布和绘图”中，我们学习了如何使用
    `Container` 在画布内组合多个对象。使用我们在[*第4章*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)“布局和文件处理”中探索的布局，可以自动根据某些规则排列每个
    `CanvasObject`。然而，有时应用程序可能希望项目根据用户交互出现和消失，或者具有超出其大小和位置之外的可视属性。容器小部件可以提供这些更丰富的行为。这些结构小部件可以在
    `container` 包中找到，包括滚动、分组以及隐藏和显示内容的变体。让我们按字母顺序探索每个选项（选项）。
- en: AppTabs
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppTabs
- en: The `AppTabs` container is used for controlling large areas of an application
    where the content should be switched out based on the current activity. For example,
    this may be used to fit lots of graphical elements into a small application user
    interface when only sub-sections are useful at one time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppTabs` 容器用于控制应用程序的大面积区域，其中内容应根据当前活动进行切换。例如，这可以用于将许多图形元素放入一个小应用程序用户界面中，当一次只有子部分有用时。'
- en: 'Each tab in a tab container can contain text and/or an icon (whichever combination
    is used should be consistent for all items). Each tab has an associated `CanvasObject`
    (usually a container) that will be shown when the tab is selected. These are created
    using `TabItem` objects that have been passed to the `NewAppTabs` constructor
    function. To create two tabs with icons and labels, you would use the following
    code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 标签容器中的每个标签可以包含文本和/或图标（无论使用哪种组合，所有项目都应保持一致）。每个标签都有一个相关的 `CanvasObject`（通常是一个容器），当标签被选中时将显示。这些是通过传递给
    `NewAppTabs` 构造函数的 `TabItem` 对象创建的。要创建带有图标和标签的两个标签，您将使用以下代码：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code will render as one of the following containers:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将渲染为以下容器之一：
- en: '![Figure 5.24 – Two tabs with text and icons in an AppTabs widget using the
    light and dark themes'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24 – 在AppTabs小部件中使用亮色和暗色主题的带有文本和图标的两个标签页'
- en: '](img/Figure_5.24_B16820.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.24_B16820.jpg)'
- en: Figure 5.24 – Two tabs with text and icons in an AppTabs widget using the light
    and dark themes
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 – 在AppTabs小部件中使用亮色和暗色主题的带有文本和图标的两个标签页
- en: 'The preceding image shows the tabs in their default orientation. However, the
    tab container can show tabs on any one of the four edges. The `SetTabLocation()`
    function takes one of the `TabLocation` types; that is, `TabLocationTop`, `TabLocationBottom`,
    `TabLocationLeading` (normally the left-hand side) or `TabLocationTrailing` (after
    content – normally on the right-hand side). The following image shows how the
    tab’s location can change the icon’s layout:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片显示了标签页的默认方向。然而，标签容器可以在四个边缘中的任何一个显示标签。`SetTabLocation()` 函数接受 `TabLocation`
    类型中的一个；即，`TabLocationTop`、`TabLocationBottom`、`TabLocationLeading`（通常是左侧）或 `TabLocationTrailing`（在内容之后
    – 通常在右侧）。下面的图片显示了标签的位置如何改变图标布局：
- en: '![Figure 5.25 – Tab containers at the bottom, with leading and trailing locations'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25 – 底部的标签容器，具有左侧和右侧位置'
- en: '](img/Figure_5.25_B16820.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.25_B16820.jpg)'
- en: Figure 5.25 – Tab containers at the bottom, with leading and trailing locations
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25 – 底部的标签容器，具有左侧和右侧位置
- en: When running the application on a mobile device, it is expected for tabs to
    be on the top or bottom in portrait mode. Therefore, the locations will adapt
    appropriately – the leading setting will show the tabs at the top, while the trailing
    setting will stets the tabs at the bottom. If the mobile device is rotated, then
    the tabs will move to the left or right edge – leaving more space for content.
    In landscape mode, any tabs that have requested the top position will be shown
    on the leading (left-hand side) edge; the bottom setting will move to the trailing
    (right-hand side) edge.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当在移动设备上运行应用程序时，在纵向模式下，预期标签位于顶部或底部。因此，位置将相应地适应 – 前导设置将在顶部显示标签，而跟随设置将标签设置在底部。如果设备旋转，则标签将移动到左侧或右侧边缘
    – 为内容留出更多空间。在横向模式下，任何请求顶部位置的标签将显示在前导（左侧）边缘；底部设置将移动到跟随（右侧）边缘。
- en: Scroll
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动
- en: 'Most of the widgets that need to scroll content include the functionality to
    do so. However, if you want to add scrolling capabilities to your content, you
    can use the `Scroll` container. By wrapping some other element in a scroll container,
    you add scrollbars on the horizontal and vertical dimensions. The constructor
    function for scrolling in both the horizontal and vertical dimensions is `container.NewScroll()`.
    You can also call `NewHScroll()` if you would only like to scroll horizontally,
    or `NewVScroll()` if you would only like to scroll vertically. The following image
    shows full scrolling on simple label content:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数需要滚动内容的部件都包含此功能。然而，如果您想为内容添加滚动功能，可以使用 `Scroll` 容器。通过将其他元素包裹在滚动容器中，您可以在水平和垂直维度上添加滚动条。在水平和垂直维度上滚动的构造函数是
    `container.NewScroll()`。如果您只想水平滚动，也可以调用 `NewHScroll()`，或者如果您只想垂直滚动（例如列表），则可以调用
    `NewVScroll()`。以下图像显示了简单标签内容的完整滚动：
- en: '![Figure 5.26 – Scroll container showing a scrollbar and shadow in the light
    and dark themes'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.26 – 在浅色和深色主题下显示滚动条和阴影的滚动容器](img/Figure_5.26_B16820.jpg)'
- en: '](img/Figure_5.26_B16820.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.26_B16820.jpg)'
- en: Figure 5.26 – Scroll container showing a scrollbar and shadow in the light and
    dark themes
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 在浅色和深色主题下显示滚动条和阴影的滚动容器
- en: As you can see, the minimum size for a scroll container becomes very small –
    just 32x32\. If you use the horizontal scroller, then its minimum height will
    fit the content, while if you use the vertical scroller (such as a list), then
    the width will adapt to fit the content.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，滚动容器的最小尺寸变得非常小 – 只有 32x32。如果您使用水平滚动条，则其最小高度将适合内容，而如果您使用垂直滚动条（如列表），则宽度将适应以适合内容。
- en: Split
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割
- en: 'The `Split` container provides us with a neat way to separate two parts of
    our application when we would like our users to be able to change the amount of
    space available for each section. This can be split horizontally or vertically.
    A horizontal split container displays two elements side by side with a split bar
    between them. The vertical split will stack elements one above the other with
    a split bar in-between:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Split` 容器为我们提供了一种整洁的方式来分隔应用程序的两个部分，当用户能够改变每个部分可用的空间量时。这可以是水平分割或垂直分割。水平分割容器显示两个元素并排，它们之间有一个分割栏。垂直分割将元素堆叠在一起，中间有一个分割栏：'
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the following image, you can see a horizontal split container with `Line1\nLine2`
    on the left-hand (leading) side and a vertical split containing `Top` and `Bottom`
    on the right-hand (trailing) side:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，您可以看到左侧（前导）侧有 `Line1\nLine2` 的水平分割容器，右侧（跟随）侧有一个包含 `Top` 和 `Bottom` 的垂直分割：
- en: Note
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In horizontal mode, the leading position (first parameter) is normally on the
    left, while in vertical mode, it will be on the top.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在水平模式下，前导位置（第一个参数）通常是左侧，而在垂直模式下，它将在顶部。
- en: '![Figure 5.27 – The Split widget in horizontal and vertical modes using the
    light and dark themes'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.27 – 使用浅色和深色主题的水平模式和垂直模式下的 Split 小部件](img/Figure_5.27_B16820.jpg)'
- en: '](img/Figure_5.27_B16820.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.27_B16820.jpg)'
- en: Figure 5.27 – The Split widget in horizontal and vertical modes using the light
    and dark themes
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 使用浅色和深色主题的水平模式和垂直模式下的 Split 小部件
- en: The split container allows the bar to be dragged to change the size allocated
    to each side of the split. The container’s minimum size will be the sum of the
    two contents (plus the split) and unless it is in a parent container with more
    space, the bar will not be draggable. When there is more space available, then
    dragging the bar will change where the extra space is allocated.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 分割容器允许拖动条来改变分配给分割每侧的大小。容器的最小大小将是两个内容（加上分割）的总和，除非它位于具有更多空间的父容器中，否则条将不可拖动。当有更多空间可用时，拖动条将改变额外空间分配的位置。
- en: Developers can also manually specify the proportion directly using the `Offset`
    field. A value of `0.0` means that the split should be as far left (or up) as
    possible, while a value of `1.0` means it should be fully right (or bottom aligned).
    This value can be queried during app runtime if you want to save the user’s preference.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者还可以通过`Offset`字段直接手动指定比例。`0.0`的值表示分割应尽可能靠左（或向上），而`1.0`的值表示应完全靠右（或底部对齐）。如果想要保存用户的偏好设置，可以在应用程序运行时查询此值。
- en: As well as composing standard widgets together to form a clear and logical user
    interface, it is sometimes useful to display temporary information or request
    user input. For cases where developers or designers do not want to include this
    in their main interface, there is a package of standard popup dialog boxes we
    can use. We will explore this next.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将标准小部件组合在一起以形成清晰和逻辑的用户界面外，有时显示临时信息或请求用户输入也是有用的。对于开发人员或设计师不希望在主界面中包含这些情况，我们可以使用一组标准弹出对话框。我们将在下一节中探讨这一点。
- en: Using common dialogs
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常用对话框
- en: During the user’s journey of an application, you will often need to interrupt
    the flow to present information, ask the user for confirmation, or to pick a file
    or other input element. For this purpose, toolkits usually provide dialog windows,
    and Fyne does the same. Instead of opening a new window, the dialogs will appear
    over existing content in the current window (which works well across all platforms
    as not all manage multiple window applications well).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户使用应用程序的过程中，你经常会需要中断流程来展示信息、请求用户确认，或者选择文件或其他输入元素。为此目的，工具包通常提供对话框窗口，Fyne也是如此。与打开新窗口不同，对话框将出现在当前窗口的现有内容之上（这在所有平台上都工作得很好，因为并非所有平台都能很好地管理多个窗口应用程序）。
- en: Each dialog has its own constructor function (of the `dialog.NewXxx()` form)
    that create the dialog to be shown later using `Show()`. They also provide a helper
    function to create and show it (of the `dialog.ShowXxx()` form). The last parameter
    of all these functions is the window that they should be displayed in. All the
    dialogs also support setting a callback when the dialog closes. This can be configured
    using the `SetOnClosed()` method.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对话框都有自己的构造函数（`dialog.NewXxx()`形式），用于创建稍后通过`Show()`显示的对话框。它们还提供了一个辅助函数来创建并显示它（`dialog.ShowXxx()`形式）。所有这些函数的最后一个参数是它们应该显示的窗口。所有对话框也支持在对话框关闭时设置回调。这可以通过`SetOnClosed()`方法进行配置。
- en: In this section, we looked at the different dialog helpers that are available
    (in alphabetical order) before learning how to build a custom dialog for an application.
    Although, these will load in the current application theme, we only showed one
    image for each example.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在学习如何为应用程序构建自定义对话框之前，查看了一下可用的不同对话框辅助工具（按字母顺序排列）。尽管这些工具将加载当前应用程序主题，但我们只为每个示例展示了一张图片。
- en: ColorPicker
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ColorPicker
- en: Fyne provides a standard dialog for picking a color within applications. This
    feature will present a selection of standard colors, a list of recently selected
    colors, and also an advanced area where specific colors can be chosen through
    value sliders, editing the channel values in **Red**, **Green**, and **Blue**
    (**RGB**) or **Hue**, **Saturation**, and **Lightness** (**HSL**), or by entering
    the RGB hex color notation directly.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne为应用程序提供了一种标准对话框，用于选择颜色。此功能将展示一组标准颜色、最近选择的颜色列表，以及一个高级区域，可以通过值滑块选择特定颜色，编辑**红**、**绿**和**蓝**（**RGB**）或**色调**、**饱和度**和**亮度**（**HSL**）的通道值，或者直接输入RGB十六进制颜色表示法。
- en: 'The color picker can be created by calling `dialog.NewColorPicker()` and then
    using `Show()` or simply calling `dialog.ShowColorPicker()`. The parameters of
    the constructor are the title and message to be shown at the top, a callback function
    for when the color is selected, and the parent window to display within it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`dialog.NewColorPicker()`然后使用`Show()`或简单地调用`dialog.ShowColorPicker()`来创建颜色选择器。构造函数的参数是要在顶部显示的标题和消息，一个用于颜色选择的回调函数，以及要显示其中的父窗口：
- en: '[PRE29]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code will load up the picker, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将加载选择器，如下所示：
- en: '![Figure 5.28 – The simple color picker dialog'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.28 – 简单颜色选择器对话框'
- en: '](img/Figure_5.28_B16820.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.28_B16820.jpg)'
- en: Figure 5.28 – The simple color picker dialog
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28 – 简单颜色选择器对话框
- en: The previous image shows the default simple color picker. Advanced features
    are available if you want your developers to have more control.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片显示了默认的简单颜色选择器。如果您希望开发者有更多的控制权，则可以提供高级功能。
- en: Confirmation
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认
- en: 'The confirmation dialog allows you to ask a user to confirm an action. As well
    as providing the title and content for this confirmation, developers can pass
    a callback function that will be called when the user makes their decision, with
    the parameter being false for a negative answer or true for a confirmed one. Like
    all dialogs, the last parameter is the parent window:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确认对话框允许您要求用户确认一个操作。除了提供此确认的标题和内容外，开发者还可以传递一个回调函数，当用户做出决定时将被调用，参数为false表示否定回答，为true表示确认。像所有对话框一样，最后一个参数是父窗口：
- en: '[PRE30]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The confirmation dialog will look as follows if the light theme is currently
    loaded:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前加载了浅色主题，确认对话框将如下所示：
- en: '![Figure 5.29 – A confirmation dialog using the light theme'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.29 – 使用浅色主题的确认对话框'
- en: '](img/Figure_5.29_B16820.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.29_B16820.jpg)'
- en: Figure 5.29 – A confirmation dialog using the light theme
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29 – 使用浅色主题的确认对话框
- en: It’s important to remember that showing a dialog does not stop the code that
    loaded it. The user’s decision will be communicated through the callback; the
    rest of your code will continue uninterrupted.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，显示对话框并不会停止加载它的代码。用户的决定将通过回调来传达；其余的代码将继续不间断地执行。
- en: File selection
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件选择
- en: 'As we saw in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*, the `dialog` package can help with file selection
    – choosing which file to open or where to save content. Opening the `fyne.URIReadCloser`
    or `fyne.URIWriteCloser` type and an error since these operations can fail for
    a number of reasons:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第4章*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)，“布局和文件处理”中看到的，`dialog`包可以帮助进行文件选择——选择要打开的文件或保存内容的位置。打开`fyne.URIReadCloser`或`fyne.URIWriteCloser`类型时可能会出现错误，因为这些操作可能因多种原因而失败：
- en: '[PRE31]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Open File dialog looks as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件对话框如下所示：
- en: '![Figure 5.30 – The file dialog is used for choosing a file to open or save'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.30 – 使用文件对话框选择要打开或保存的文件'
- en: '](img/Figure_5.30_B16820.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.30_B16820.jpg)'
- en: Figure 5.30 – The file dialog is used for choosing a file to open or save
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30 – 使用文件对话框选择要打开或保存的文件
- en: The file dialogs will default to showing the user’s home directory. This can
    be changed by calling the `SetLocation` method. As this is a cross-platform API,
    the starting location is a `URI` rather than a `string` path. This also means
    that the file dialog can be used to show the contents of remote file systems and
    other sources of file data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对话框默认显示用户的主目录。这可以通过调用`SetLocation`方法来更改。由于这是一个跨平台API，起始位置是一个`URI`而不是字符串路径。这也意味着文件对话框可以用来显示远程文件系统和其他文件数据源的内容。
- en: In a similar way, applications can ask where to write a file to use the `dialog.ShowFileSave`
    method. It is also possible to prompt for folder selection instead of files, using
    `dialog.ShowFolderOpen`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，应用程序可以使用`dialog.ShowFileSave`方法询问写入文件的位置。也可以使用`dialog.ShowFolderOpen`来提示文件夹选择而不是文件。
- en: Form
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单
- en: 'The `Form` dialog extends the simple premise of a confirmation by requesting
    a value to be input, in addition to confirming the result. The `Form` dialog can
    contain various widgets in the same way that the `Form` widget did in the *Introducing
    the basic widgets* section. The constructor function is similar to the confirm
    dialog, but it accepts an additional slice of `*widget.FormItem` values to specify
    the content:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 对话框通过请求输入值来扩展确认的简单前提，除了确认结果外。`Form` 对话框可以包含各种小部件，就像在 *介绍基本小部件* 部分中的
    `Form` 小部件一样。构造函数与确认对话框类似，但它接受一个额外的 `*widget.FormItem` 值切片来指定内容：'
- en: '[PRE32]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result will be a dialog with an `widget.Entry` field, as shown in the following
    image:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个包含 `widget.Entry` 字段的对话框，如下面的图像所示：
- en: '![Figure 5.31 – Asking a user for an input value using the Entry dialog'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.31 – 使用 Entry 对话框请求用户输入值'
- en: '](img/Figure_5.31_B16820.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.31_B16820.jpg]'
- en: Figure 5.31 – Asking a user for an input value using the Entry dialog
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 使用 Entry 对话框请求用户输入值
- en: Information
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息
- en: In a command-line application, information will commonly be written to standard
    output or standard error (normally for error messages). However, graphical applications
    will normally not be run from the command line, so messages that the user should
    see will need to be presented differently. The dialog package can help with this
    task as well.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行应用程序中，信息通常会写入标准输出或标准错误（通常用于错误消息）。然而，图形应用程序通常不会从命令行运行，因此用户应该看到的消息需要以不同的方式呈现。对话框包可以帮助完成这项任务。
- en: 'An information dialog box can be used to present a standard message when its
    importance is high enough that the user should be interrupted to take a look at
    it. The `dialog.ShowInformation` function is called to present this dialog and
    it takes a title and message parameter. If the information to present is an error,
    then the `dialog.ShowError` helper function can be used as it takes an error type
    and the information is extracted to be displayed:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 信息对话框可以用于在信息的重要性足够高，以至于用户应该被打断查看时呈现标准消息。调用 `dialog.ShowInformation` 函数来呈现此对话框，并接受标题和消息参数。如果要呈现的信息是错误，则可以使用
    `dialog.ShowError` 辅助函数，因为它接受错误类型，并将信息提取出来以显示：
- en: '[PRE33]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The information dialog box will be presented like so:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 信息对话框将呈现如下：
- en: '![Figure 5.32 – An information dialog box in the light theme'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.32 – 浅色主题下的信息对话框'
- en: '](img/Figure_5.32_B16820.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.32_B16820.jpg]'
- en: Figure 5.32 – An information dialog box in the light theme
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32 – 浅色主题下的信息对话框
- en: After these, we move to the custom dialogs.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些之后，我们将转向自定义对话框。
- en: Custom dialogs
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义对话框
- en: Although the preceding dialogs should cover most of the reasons why you may
    wish to interrupt the user flow with a pop-up dialog, your app may have additional
    requirements. To support this, you can insert any content into a custom dialog
    so that the overall layout is consistent.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的对话框应该涵盖了您可能希望使用弹出对话框中断用户流程的大部分原因，但您的应用程序可能还有其他要求。为了支持这一点，您可以将任何内容插入到自定义对话框中，以确保整体布局一致。
- en: 'To construct a custom dialog, a new parameter and its content must be passed
    to the constructor function. Any Fyne widget or `CanvasObject` can be used in
    a custom dialog, which includes containers to provide more complex content. To
    illustrate this, we will use a `TextGrid` component:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个自定义对话框，必须将一个新的参数及其内容传递给构造函数。任何 Fyne 小部件或 `CanvasObject` 都可以用于自定义对话框，这包括容器以提供更复杂的内容。为了说明这一点，我们将使用
    `TextGrid` 组件：
- en: '[PRE34]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code will generate a custom dialog, as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成一个自定义对话框，如下所示：
- en: '![Figure 5.33 – A dialog showing custom content (a TextGrid)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.33 – 显示自定义内容（一个 TextGrid）'
- en: '](img/Figure_5.33_B16820.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.33_B16820.jpg]'
- en: Figure 5.33 – A dialog showing custom content (a TextGrid)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33 – 显示自定义内容（一个 TextGrid）
- en: There is also a `ShowCustomConfirm()` version, which provides the `func(bool)`
    callback to inform the developer of which button was tapped.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `ShowCustomConfirm()` 版本，它提供了一个 `func(bool)` 回调，以通知开发者哪个按钮被点击。
- en: By exploring various widgets and dialogs, we have seen what the standard theme
    looks like and that light and dark versions are available. Next, we will look
    at what a theme consists of and how they can be managed and customized.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索各种小部件和对话框，我们已经看到了标准主题的外观，以及提供了浅色和深色版本。接下来，我们将探讨主题由什么组成以及如何管理和自定义它们。
- en: Understanding themes
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解主题
- en: The themes within the Fyne toolkit implement the color palette, iconography,
    and size/padding values of the Material Design look and feel. The design of the
    theme API aims to ensure that applications feel consistent and deliver a good
    user experience while allowing developers to convey an identity and customization.
    All Fyne applications can be displayed in light or dark mode using built-in themes.
    We will look at these in detail next.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Built-in themes
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since more and more operating systems are supporting light versus dark desktop
    coloring, the Fyne theme specification supports both light and dark variants.
    By default, every app will ship with a built-in theme that provides both light
    and dark variants. This theme was illustrated extensively in the *Introducing
    the basic widgets* section earlier in this chapter, but to see how this all comes
    together, take a look at the following screenshot of a Fyne demo application that
    showcases widgets:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – A collection of widgets in a default theme – light variant'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.34_B16820.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.34 – A collection of widgets in a default theme – light variant
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous screenshot shows the widget demo in the light theme. The following
    screenshot shows the same but with the built-in dark theme:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – Various widgets using the dark theme'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.35_B16820.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.35 – Various widgets using the dark theme
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the main color being used (the primary color – blue, in this
    case) has been chosen as it contrasts well with the background colors of both
    the light and dark themes. When using this model, themes can vary the primary
    color while continuing to support both light and dark user preferences.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: On most operating systems, Fyne will automatically pick the theme variant that
    best matches the current user’s preferences. There are ways that the user can
    choose a specific version, as we’ll see in the next section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: User settings
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, Fyne-based applications will normally detect the user’s
    preference for either the light or dark theme and load it accordingly. It is possible
    to set a preference for which theme is loaded by using the Fyne settings application
    or by using environment variables.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'The **fyne_settings** application, which can configure all Fyne-based applications,
    can be run to manage the user’s settings. This includes their theme variant (light
    or dark), as well as what primary color they will use. Any changes that are made
    using this interface will be saved for the future and will immediately apply to
    all open applications. You can also find the **Settings** panel from the **Settings**
    menu within **fyne_demo**:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.36 – The fyne_settings application'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.36_B16820.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.36 – The fyne_settings application
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables can be useful if you wish to temporarily apply a
    theme, or if you would like one app to use a different theme. The `FYNE_THEME`
    environment variable can be set to *light* or *dark* to specify which variant
    should be used. You can similarly override the default interface scaling that’s
    available using the `FYNE_SCALE` environment variable. Here, `1.0` is the standard
    to use; smaller numbers load smaller content, while larger numbers load larger
    content.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Included icons
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As could be seen in some of the widgets earlier in this chapter (for example,
    `Button` and `AppTabs`), the theme package includes many icons from the material
    design collection (the full official set can be found at [https://material.io/resources/icons/](https://material.io/resources/icons/)).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Because all the elements of Fyne-based apps are designed to scale appropriately
    for different types of display and user preferences, the images should be vector-based
    rather than bitmap-based. This means that when displaying at very small or large
    sizes, the exact pixels to display will be calculated for optimal display instead
    of multiplying (or reducing) the number of pixels from the original image.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the material design images are available in vector formats and
    the built-in icons are all in **scalable vector graphics** (**SVG**) format. This
    also means that icons can easily be adapted for various colors as the app runs,
    thus ensuring that they can adapt to the primary color and current theme:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37 – A selection of material design icons'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.37_B16820.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.37 – A selection of material design icons
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Because the icon set is freely available and very popular, it is easy to download
    additional icons and add them to your application, knowing that they will fit
    the toolkit’s overall aesthetic.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Application override
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers of applications that wish to deviate from the default (or user-selected)
    theme are also catered for in the Fyne theme API. Be careful before specifying
    a theme for your application – it may feel like a surprise to your app users.
    To use one of the built-in themes but override the user or system setting regarding
    whether the light or dark variant is used, you can call `SetTheme()` on the current
    `App` instance, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, to force the application to use the built-in light theme, use
    the following code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This API is more commonly used to set up a custom application theme. The details
    of creating a custom theme will be covered in [*Chapter 7*](B16820_07_Final_JM_ePub.xhtml#_idTextAnchor193),
    *Building Custom Widgets and Themes*. Once you have created a theme, it can be
    loaded using the `SetTheme()` function, which will apply it to the current app.
    The following screenshot shows a custom theme that deviates from the standard
    styles:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.38 – A BBC Micro Emulator GUI based on Fyne'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.38_B16820.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.38 – A BBC Micro Emulator GUI based on Fyne
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the details of the main widgets and theme capabilities
    of the Fyne toolkit, let’s build a simple app that brings many of them together.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a task list application
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore some of the widgets listed in the previous sections and how they
    can be brought together into a simple application, we will build a small task
    list. This application will show a list of tasks based on complete or incomplete
    state and allow the user to edit the details of each item.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Designing the GUI
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will piece together a basic user interface for the task application.
    It will contain a list of tasks on the left-hand side of the app and a collection
    of components that edit a task on the right-hand side. Above this, we will add
    a toolbar for other actions. Let’s get started:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of tasks will be a `List` widget that notifies the user when an item
    has been selected. The `List` widget will contain static content for this mock-up.
    Here, we will tell the list that there are a set number of items (for example,
    `5`) so that it creates the correct number of items to display. We create a new
    check item each time the list calls the `CreateItem` callback. For now, we will
    leave the third (`UpdateItem`) method empty so that it just displays templates
    values. This code will be created in a simple `makeUI` method, as shown here:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we will create the widgets that will allow us to edit a task item. Let’s
    create a `Form` widget that will hold the items we need and provide labels as
    well. We will create a new row for each item using `widget.NewFormItem`, passing
    the `string` label and the widget’s content as parameters. These are all standard
    widgets, but the callbacks we are passing are empty at the moment. We will return
    to these widgets later to complete their functionality. The following code goes
    inside the `makeUI` function we started in the previous segment:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The last component that we will add to the interface is a toolbar that will
    provide access to the add task function. To do so, we will create a `widget.Toolbar`
    using the `ToolbarAction` item:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To bring these interface elements together, we will create a new container
    using the `Border` layout. The toolbar will be set as the top item and the task
    items will be on the left of the container. Our form will take up the remaining
    space by being passed as a component that’s not specified as being on a border.
    This container will be returned from the `makeUI` function so that it can be used
    to display our application window:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To run our application, all we need to do is add the usual launcher code, which
    creates a window and sets our content. We do not need to specify a size for this
    window as the contents will naturally condense down to a sensible minimum size:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running all the code we’ve created so far will give us a good impression of
    what the application will look like:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When using the Fyne light theme (by going through the user preferences options
    or by setting `FYNE_THEME="light"`), the application should look as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.39 – Our task list GUI skeleton'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.39_B16820.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.39 – Our task list GUI skeleton
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Before we can complete the functionality of this application, we need to define
    a data structure that will hold information about the tasks we are editing.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our application to function correctly, we will need to create a data structure
    that will manage the information we are editing. Let’s get started:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define a `task` data structure – this simply lists the various
    fields that match the inputs in the design we made in the previous section. Different
    fields will be stored in different types – for example, the `Entry` widget maps
    to `string` and our checkbox maps to `bool`. We will add the following code to
    a new file called `data.go`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, we have used `float64` for the value of our completion `Slider`
    and that we will be converting the date entry into `time.Time` format.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we will be storing many tasks, we could simply create a slice of task
    pointers, but by defining a new type, we can associate certain functions with
    others that will be useful later. The type just wraps the `[]*task` slice, which
    will store the data:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since we will be displaying the list of tasks based on the `done` state, we
    should add two helper methods that return these sub-lists based on the value of
    that field:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will also define some constants that help in managing the different priority
    levels in our data. Refer to the following code snippet:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When writing data handling code, it’s important to write tests as well. If
    you add these before connecting to the user interface, then bugs can surface sooner.
    This means that when we add graphical tests, any issues that are found should
    relate to a mistake in our user interface code. Create a new file called `data_test.go`
    and the following tests:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: More tests can be added to this project – you can find them in the code repository
    for this book, inside the `Chapter05` folder, at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05).
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have not explored data storage in this chapter, so we will just be keeping
    the task list in memory. You will find out more about data and preference storage
    in [*Chapter 6*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166), *Data Binding
    and Storage*. Since our data will be reset each time the application is run, we
    should create another function that populates a data structure with some content
    that will be loaded when the app starts, as follows:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have defined the data structure and basic functions, we can connect
    it to the user interface and complete the functionality.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Selecting tasks
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to update a widget’s content is to keep a reference regarding
    the instance once it has been constructed. We will be doing this for a number
    of elements, so we should create a new type that will handle the various elements
    of the user interface. Creating this struct means that we can avoid lots of global
    variables, which should help keep the code neat. Let’s get started:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new struct and name it `taskApp`, as follows:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The type includes a reference to the `*taskList` data structure, which will
    hold our date, and defines a slice of `*task` types that represents the tasks
    that are currently visible (the result of calling `taskList.remaining()` or `taskList.done()`).
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we can make our `makeUI` function a method of the `taskApp` type so that
    its signature becomes `func (a *taskApp) makeUI() fyne.CanvasObject`. Doing this
    gives us access to the data structure we defined earlier through `a.data`. We
    will, however, use the task list stored in `visible` to populate our list as it
    may contain completed or incomplete items, depending on its current state.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code that sets up the list widget can now be updated with the following
    code. We store its reference in `a.tasks` instead of the original `todos` variable
    (so that we can reference it later); don’t forget to change the `todos` reference
    returned from `makeUI` to use `a.tasks` as well. The result of our `Length` callback
    function simply returns the number of items in the `a.visible` slice. Although
    the `CreateItem` callback (the middle parameter) does not need to change, we do
    provide an implementation for the final callback; that is, `UpdateItem`. This
    new function obtains the task from the specified index (`i`) and uses `task.title`
    to set the text of the `Check` widget:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To see these changes in action, we need to set up the data source. For this,
    we must add a line that will create our dummy data and construct the new `taskApp`
    struct just before the call to `SetContent`, as follows:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Performing these code alterations will update the app so that it reflects the
    task titles in the main list, as shown in the following screenshot:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40 – Showing real task titles'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.40_B16820.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.40 – Showing real task titles
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to fill in the details on the right-hand side of the window.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Filling in the details
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To populate the data area of the app, we will need to keep track of the current
    task and the widgets that it should fill. Let’s get started:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will add a `current` field to the `taskApp` structure. After
    that, we need to save a reference to each of the input elements that we added
    for the initial layout tests, which will require more fields in `taskApp`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With these in place, we can complete the replacement for the `details` setup
    within `makeUI` so that it looks as follows:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once this setup code is complete, we can add a new function called `setTask`.
    This will be used to update the current task and refresh the detail elements we
    created in the previous code block:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To support that code, we will also define the `formatDate` function, which
    converts our date into a string value. This will return an empty string if the
    optional `date` is `nil`, or format it using the `dateFormat` constant otherwise:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With this code in place, we can set the first task to be presented on the display.
    Of course, we should check if there are any tasks before assuming that an item
    can be shown. The following code is updated in the `main` function:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The last piece of code we need in order to update our user interface as the
    user browses is `List.OnSelected`. This will allow us to update the details that
    are displayed when the list is tapped. Simply add the following line once you’ve
    created our `List`, which is set to load from `a.tasks`:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With all the code in place, we have a complete application, as shown in the
    following screenshot:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.41 – Complete user interface'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.41_B16820.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.41 – Complete user interface
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code shown previously will work with the current theme, which means
    we can see the same content when we’re using the standard dark theme:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.42 – The tasks user interface in the standard dark theme'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.42_B16820.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.42 – The tasks user interface in the standard dark theme
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will handle how details are saved when the user edits any data.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Editing content
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'When each of the input widgets are edited, we should update the dataset. This
    is trivial for most inputs as we can just set the `OnChanged` callback so that
    we’re notified when the data changes. Let’s get started:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'In each callback, we must ensure that a task is currently selected (in case
    all the tasks have been deleted) and then set the appropriate field. The callback
    for `Title` is as follows. Note that we also call `Refresh()` on the task list
    as the title change should be reflected in the list:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Most of the other callbacks are similar, so they have been omitted from this
    description – the full code is available in this book’s GitHub repository.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The priority callback update is a little more complex as we are converting
    a choice of string representations into a number field. Note that the callback
    is a function that’s been passed to the constructor:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Lastly, we will look at the input widget as we should add validation for the
    date format. To do this, we set the `Validator` callback to provide the user with
    feedback about the input state. First, we must create a new validator that can
    check the date format, which simply has a `Validate(string)` `error` function
    signature (meaning it implements `fyne.StringValidator`):'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With the validator in place, we simply set it as the `OnChanged` callback.
    In this callback, we need to reparse the date to get the appropriate date for
    the input (we skip this if the input is empty):'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is all the code we need for presenting and editing tasks. Next, we’ll learn
    how to mark tasks as complete and keep the list updated.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Marking tasks as complete
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of functionality we will add is the ability to mark a task as
    complete. Let’s get started:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are within the list, we need to set the callback within the `UpdateItem`
    callback to `List` to be able to mark the correct item as done:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, we need to make use of a helpful `refreshData()` function that updates
    the data list (by re-calculating what remains) and then asks the `task` widget
    to refresh:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: At this point, it functions correctly. However, upon clicking the `Check` text,
    it marks a task as done instead of selecting it for editing. To improve this,
    we can move the text component to a separate `Label` widget that will allow the
    mouse clicks through to the list selection logic.
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, we will return a `Check` and a `Label` by using `container.NewHBox`
    in the template function. When applying content in the update callback, we need
    to extract the widgets from the `Container.Objects[]` field. Otherwise, the code
    is similar to what it was earlier. The final list implementation is as follows:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Finally, we will implement the `add` button in the toolbar.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new task
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will update the data code so that we can add new tasks.
    Let’s get started:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new `add()` function with a `task` parameter and prepend
    it to the top of the list:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Because data functions are usually easy to test, we will add another unit test
    inside `data_test.go`:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Unit testing the whole user interface is highly advisable but outside the scope
    of this example – we will return to this topic in [*Chapter 8*](B16820_08_Final_JM_ePub.xhtml#_idTextAnchor205),
    *Project Structure and Best Practices.*
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To complete the add task functionality, we must fill in the callback in the
    `NewToolbarAction()` function that we called when we first set up the user interface.
    This code simply creates a new `task` with the title `New task`, adds it to the
    data, and then reuses the same `refreshData()` function that we created for hiding
    completed tasks:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding code concludes our tasks app example. There is more functionality
    that we could add, but we’ll leave that as an exercise for you to complete.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how the Fyne Widget API is designed and looked at
    a list of standard widgets. We saw how containers and collection widgets can help
    us organize and manage user interface components. The dialog package was also
    explored to show how we can use it with our applications in order to implement
    standard components for common activities.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how themes are implemented within the toolkit and how they apply
    to all the widget components. This chapter demonstrated the light and dark variants
    of the standard theme and showed that applications can provide their own themes
    for a custom look and feel.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: By building a task tracking application, we saw how many of the built-in widgets
    are used, how to lay them out in various containers, and how user interactions
    can be tracked to manage some in-memory data. In the next chapter, we will look
    at data binding and storage APIs, which can help us manage more complex data requirements.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
