- en: '*Chapter 5*: Widget Library and Themes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A large part of the Fyne toolkit is its library of standard widgets, which provides
    simple visual elements, manages user input, and handles application workflows.
    These widgets handle how information and user input is displayed, as well as container
    options for organizing the user interface and managing standard workflows. The
    themes that come with the Fyne toolkit support both light and dark versions, both
    of which support user color preferences while adapting all the user interface
    elements so that they look great in both modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to explore the widgets available in the Fyne toolkit
    and how to use them. We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the design of the Fyne Widget API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the basic widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping with the collection widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding structure with container widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using common dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with all the Fyne widgets and
    how the theme capabilities work to control their appearance. By combining widgets
    and containers, you will have built your first complete Fyne-based graphical user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing* – that is, you must have the Fyne toolkit installed
    and a Go and C compiler working. For more information, please refer to the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the design of the Widget API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we described in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036),
    *The Future According to Fyne*, its APIs are designed to convey semantic meaning
    rather than a list of features. This is followed on by the Widget definition,
    whereby we add APIs that describe behavior and hide the details of rendering.
    The interface that all widgets must implement is simply an extension of the basic
    `CanvasObject` object (introduced in [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Window, Canvas, and Drawing*), which adds a `CreateRenderer()` method. It is
    defined in the source code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The new `CreateRenderer()` method is used by Fyne to determine how the widget
    should look. There is no public API for accessing the current renderer – instead,
    state is set in a `Widget` and each renderer will refresh its output to match
    this state. This design strongly encourages APIs to focus on behavior and intent
    rather than directly manipulating the graphical output (which could quickly lead
    to inconsistent or unusable applications).
  prefs: []
  type: TYPE_NORMAL
- en: Focus on behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By enforcing a separation between widget state and its visual representation,
    each `Widget` is forced to expose an API that describes behavior or intent instead
    of visual attributes or internal details. This is important for continuing the
    design principle of a semantic API, which leads to a more concise API focused
    on expected outcomes over graphical tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commonly, changes in state will need to be reflected by a `WidgetRender` updating
    in some way. How the graphical representation will change is controlled by the
    renderer, and it is triggered by calling `Widget.Refresh()`. This refresh is normally
    handled by the widget code; for example, the `Button.SetText()` function’s code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The call to `Refresh()` queues a request asking for the widget rendering to
    be updated, which will result in graphical updates in the next update of the screen.
    On some widgets, calling the `Refresh` function can cause a lot of calculations.
    If you have lots of changes to apply to a widget, you may not wish it to refresh
    after every line. To help with this, there is also a direct field access approach
    that ensures it doesn’t need to be called as often.
  prefs: []
  type: TYPE_NORMAL
- en: Methods versus field access
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in the previous section, refreshing a widget, especially a complex
    one, can be time-consuming, and if many updates must be performed, the user may
    notice a slight delay. If a developer wishes to update multiple aspects of a widget,
    then it is possible (though perhaps unlikely) that one change may be applied before
    a visual redraw and the others happen just after. Although another draw will occur,
    it may be noticeable that they did not change together. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When using method-based updates, the `SetText()` and `SetIcon()` calls will
    refresh the widget, possibly causing the slight delay mentioned previously. It
    is recommended to call `Refresh()` only when needed; to make this possible, a
    developer can access the widget state directly and refresh the object manually.
    This is known as **field-based access** as we directly change the exported fields
    of a widget. For example, we could rewrite the preceding code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By taking this approach, we ensure that `Refresh()` is called just once so that
    both changed elements will redraw at the same time. This offers a smoother result
    for the user and will lead to lower CPU usage as well.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CreateRenderer()` method mentioned earlier will return a new renderer instance
    that defines how the widget will be presented on-screen. The toolkit is responsible
    for calling this method and it will cache the result while the widget is visible.
    Developers should not call this directly as the result will have no connection
    to what is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact lifetime of a renderer varies and is a combination of the widget’s
    visibility, its parent’s visibility, and whether the window is currently shown.
    The `WidgetRenderer` definition for a widget may be unloaded during its application
    life cycle. A new instance will be requested if the widget becomes visible again
    at a later date. If a renderer is no longer needed, then its `Destroy()` method
    will be called. The full definition of a widget renderer is as follows and has
    been taken from the API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first two methods in the `WidgetRenderer` definition (`Layout()` and `MinSize()`)
    should be familiar from [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling* – they define a container layout. In this instance,
    the container is this widget and the objects that are being controlled are the
    visual components used to render the widget – they are returned from the `Objects()`
    method. The `Refresh()` method of a `WidgetRenderer` is called internally when
    a visible widget needs to be redrawn.
  prefs: []
  type: TYPE_NORMAL
- en: The `Objects()` method call returns a list of each `CanvasObject` required to
    render the widget it describes. This is a slice of items from the `canvas` package
    such as `Text`, `Rectangle`, and `Line`. These items will be arranged using the
    layout methods described previously to create the final widget presentations.
    It is important that the color of each element match, or blend with, the current
    theme. When the `Refresh()` function is called, it may be in response to a theme
    change, so any custom values should be updated accordingly in that code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how widgets work, let’s look at what is built into the toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the basic widgets
  prefs: []
  type: TYPE_NORMAL
- en: The most used package in Fyne (or any GUI toolkit) is likely the `widget` package.
    This contains all the standard widgets that will be useful to most graphical apps.
    The collection is split into basic widgets (for simple data display or user input)
    and collection widgets (`List`, `Table`, and `Tree`) that are used to display
    large or more complex data. In this section, we’ll step through the basic widgets
    in alphabetical order to see how they look and how to add them to an app.
  prefs: []
  type: TYPE_NORMAL
- en: Accordion
  prefs: []
  type: TYPE_NORMAL
- en: 'The accordion widget is used to fit large amounts of content into a small area
    by showing and hiding items so that only one of the child elements is visible
    at a time. Each item has a header button that is used to show or hide the content
    below it. This can be seen in the following image, which shows an accordion widget
    in the light and the dark themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – An accordion widget with item B expanded, shown in the light
    and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – An accordion widget with item B expanded, shown in the light and
    dark themes
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an `Accordion` widget, you must pass a list of `AccordionItem` objects
    that specify the title and details for each element in the accordion. You can
    also optionally specify the `Open` value, which, if set to `true`, will show the
    content by default. The following code block was used to create the previous `Accordion`
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By default, an `Accordion` widget shows only one item at a time. To allow any
    number of items to be shown, you can set the `MultiOpen` field to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Button
  prefs: []
  type: TYPE_NORMAL
- en: The `Button` widget provides a standard press button that can be activated by
    clicking it with a mouse (or by using the tap gesture on a touch screen). A button
    can contain text or icon content, or both. The `Button` constructor function also
    takes an anonymous `func` that is executed when the button is tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a button using the `widget.NewButton` or `widget.NewButtonWithIcon`
    constructor functions. It is recommended to use the built-in theme icons where
    possible (for more information, please see the *Themes* section later in this
    chapter), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The button in each theme is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A button with its icon shown in light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – A button with its icon shown in light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: 'Most buttons have the same look, but if you need one to stand out, you can
    set it to have a high importance style by setting `Button.Importance = widget.HighImportance`,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A high importance button in both light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A high importance button in both light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: The color used to represent high importance widgets will vary based on the theme
    and can even be set by the user. Another possible value for `Button.Importance`
    is `widget.LowImportance`, which reduces the visual impact of the display, for
    example, by removing the shadow shown in the previous two images.
  prefs: []
  type: TYPE_NORMAL
- en: Card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the elements of the user interface relate to each other, it can be useful
    to group them together. This can be helpful when a group of items should be titled
    or where many different data elements want a larger preview than a simple list.
    A collection of `Card` widgets may be added to a `Container` with a grid layout
    to arrange similar items that display different content (such as search results
    or a preview of media items).
  prefs: []
  type: TYPE_NORMAL
- en: 'A card widget can be created using the `NewCard` constructor function, which
    takes a title and subtitle string, as well as a `CanvasObject` content parameter.
    You can also specify the `Image` field after constructing or by creating the struct
    manually, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the preceding code utilizing the light and dark themes in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The card widget showing its titles and an image in light and
    dark modes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – The card widget showing its titles and an image in light and dark
    modes
  prefs: []
  type: TYPE_NORMAL
- en: All the fields that were used in the preceding code are optional. An empty string
    for either of the titles will remove it from the display, and a nil image or content
    removes it as well (you can see the missing content in the previous image).
  prefs: []
  type: TYPE_NORMAL
- en: Check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checkbox functionality is provided by the `Check` widget. It has two states:
    checked and unchecked (the default). The constructor takes a callback function,
    `func(bool)`, that will be called whenever the checked state changes, passing
    the current state (`true` means checked). The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also manually set the checked state by calling the `SetChecked` method
    and passing `true` (or `false` to change it back to unchecked):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The different checked states, one in each theme, are shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A light theme checkbox checked, and a dark theme checkbox unchecked'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – A light theme checkbox checked, and a dark theme checkbox unchecked
  prefs: []
  type: TYPE_NORMAL
- en: The checked indicator will adapt to the current theme, just like the text does.
  prefs: []
  type: TYPE_NORMAL
- en: Entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Text input is primarily added through the `Entry` widget, which provides free
    text entry. A content hint can be added to a field by setting a `Placeholder`,
    and the text content can be set directly with the `Text` field or the `SetText()`
    method. Entries can be created with one of the following constructors. The first
    is a normal text field, the second is a password entry, and the third is used
    for multiline input (defaults to 3 lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the standard and password entry widgets using the
    default themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Entry and PasswordEntry widgets in light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Entry and PasswordEntry widgets in light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry widget also supports validation, which can be used to give the user
    feedback on the current text. The different states can be seen in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Validation status of success and failure using the light theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.7_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Validation status of success and failure using the light theme
  prefs: []
  type: TYPE_NORMAL
- en: While typing, an entry with a validator set will provide positive feedback when
    the content is valid. Invalid content will show a warning when the user stops
    editing the input.
  prefs: []
  type: TYPE_NORMAL
- en: FileIcon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to using static icons (see the Icon section, later in this section),
    the toolkit can display appropriate icons for different types of files. The `FileIcon`
    widget was created to make this common task much easier, by loading one of the
    standard icon resources and showing the file extension inside it. The icon matches
    the size of the standard `widget.Icon` and its image and text will be updated
    to reflect the specified URI. `FileIcon` widgets can be created by specifying
    the URI of a file resource, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be rendered as follows, depending on the current theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The Fileicon widget showing the symbol and extension of a PNG
    image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.8_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – The Fileicon widget showing the symbol and extension of a PNG image
  prefs: []
  type: TYPE_NORMAL
- en: '`FileIcon` widgets will vary their appearance, setting icons appropriate for
    the file type.'
  prefs: []
  type: TYPE_NORMAL
- en: Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The form widget is useful for labeling and laying out various input elements.
    Each row of a form typically contains an input element with a label next to it.
    If the form has an `OnSubmit` or `OnCancel` function set, then it will automatically
    generate an additional row containing the appropriate action buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a form by passing a list of `FormItem` objects into the `NewForm()`
    constructor function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also call `Form.Append()` to add elements later. The form will look
    as follows, depending on the current theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – A login form shown in light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.9_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – A login form shown in light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: An additional benefit of grouping input elements into a form is that it can
    help ensure that only validated input is submitted. If any of the widgets have
    a validator set, then the form will only allow submission once all the validators
    have passed.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperlink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some situations, it can be helpful to provide a tappable URL string that
    opens a web page in the user’s browser. For this use case, there is a `Hyperlink`
    widget that accepts a `URL` parameter for the page to open when it’s tapped. To
    create a hyperlink widget, we may need to parse a URL, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The widget looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – A hyperlink widget using the light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – A hyperlink widget using the light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: Icon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although you can add a `canvas.Image` to a user interface directly, it can
    sometimes be useful to have a consistent size. The `Icon` widget provides this,
    loading a standard resource and setting its minimum size to the theme-defined
    icon size. The icon will also update to match the current theme. We can create
    an icon that shows the standard paste image using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be rendered as follows, depending on the current theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The icon widget showing the paste icon in the light and dark
    themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – The icon widget showing the paste icon in the light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move on to the label widget.
  prefs: []
  type: TYPE_NORMAL
- en: Label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Displaying text is normally recommended using the `Label` widget. It is possible
    to use `canvas.Text` but, as we saw in [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*, those elements use a developer-defined color –
    in most user interfaces, it is preferable for the text to match the current theme,
    which is what the `Label` widget takes care of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The label widget in each theme looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – A text label in the light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – A text label in the light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: This widget also supports additional text formatting such as newline, word wrap,
    and truncation. A string containing the newline character (`\n`) will be broken
    into a second line and be fully visible, whereas setting `Label.Wrapping = fyne.TextWrapWord`
    (or `fyne.TextWrapBreak`) will automatically add new lines when the widget’s width
    requires it. Setting the value to `fyne.TextWrapTruncate` will simply remove overflowing
    text from the display.
  prefs: []
  type: TYPE_NORMAL
- en: Pop-up menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PopUpMenu` widget is helpful for displaying context menus or allowing a
    user to choose from options where a built-in widget is not providing the desired
    functionality. To create a menu in this way, you need a `fyne.Menu` data structure
    that describes the options available (this is the same structure we used in [*Chapter
    3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066), *Windows, Canvas, and Drawing*,
    for the main menu). In this case, the title of the menu can be empty as it will
    not be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the menu has been defined, the `ShowPopUpMenuAtPosition` utility function
    is the easiest way to display this to the user. This function takes an absolute
    position in the window and displays the menu in the top-left corner. As with other
    pop-up elements, this can be dismissed by tapping outside of the content shown,
    thereby returning the user to the previous state. You can use the following code
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a new menu over the current content of the window.
    The result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – PopUpMenu shown in the light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – PopUpMenu shown in the light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use the `Menu` widget directly here. The `widget.NewMenu`
    constructor function can be used to render a menu without it creating an overlay
    like `PopUpMenu` does.
  prefs: []
  type: TYPE_NORMAL
- en: ProgressBar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If an application needs to indicate that a process will take some time to perform,
    then you can use the `ProgressBar` widget. There are two variations: `widget.ProgressBar`
    and `widget.ProgressBarInfinite`. A regular progress bar shows a current `Value`
    ranging from `Min` to `Max` (default *0* to *1*), and the developer is responsible
    for setting the value as the process progresses. When using the infinite progress
    bar, there is no intrinsic value, so the output renders an animation that indicates
    an activity (a change in the value) for an undefined duration. We can create a
    progress bar using one of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'These two versions of the progress bar look as follows, with `bar1` on the
    left and `bar2` on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The standard and infinite progress bars shown with light and
    dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – The standard and infinite progress bars shown with light and dark
    themes
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to add a different text overlay for the regular progress widget,
    then you can use the `TextFormatter` field, setting a function which returns a
    string value. This can be formatted based on the widget’s state or something different
    such as the `loading...` string.
  prefs: []
  type: TYPE_NORMAL
- en: RadioGroup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The radio group widget is the most common way of requesting user input. The
    outcome is similar to the `Select` widget (discussed next), but the options are
    all visible. The `RadioGroup` widget can be created by specifying a slice of string
    values that will be listed as options. The second parameter is a callback that
    will execute each time the selection is changed, passing the new value into the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The radio group widget looks as follows in the different themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15– A radio group with two options, top selected, in the light and
    dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15– A radio group with two options, top selected, in the light and
    dark themes
  prefs: []
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the preceding `RadioGroup` widget, the `Select` widget allows the user
    to choose one item from a list. It is more common to use `Select` when the list
    of options is long or the space that’s available is small. This widget appears
    as a button showing the current value. When tapped, this will show a popup menu
    that lists the options that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Select` widget looks as follows in the different themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The select widget shown in the light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – The select widget shown in the light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `SelectEntry` widget.
  prefs: []
  type: TYPE_NORMAL
- en: SelectEntry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SelectEntry` is much like the `Select` widget described previously, except
    that it allows user-defined options as well. This can be done by presenting an
    `Entry` widget with a select-style drop-down icon that lists the specified options.
    Because the current value can change on every keystroke, the callback for this
    widget is configured like `Entry` rather than `Select` – it is not passed as a
    select change function in the constructor but can instead be set on the `OnChanged`
    field of the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SelectEntry` widget looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – The SelectEntry widget before input is added in the light and
    dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – The SelectEntry widget before input is added in the light and
    dark themes
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `Slider` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Slider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Slider` widget can be used for inputting a number within a range, particularly
    when the exact number may not be known to the user. This can be useful, for example,
    when specifying brightness or volume – the number is not important to the end
    user, but it has a clear range from `Min` to `Max`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Slider` widget can be created by specifying `Min` and `Max` values through
    the constructor. Its default value will be set to the minimum, and this can be
    changed by setting `Slider.Value`. It is also possible to specify a `Step` value,
    which defines the distance between each valid value. Without a defined step, any
    floating-point value between the minimum and maximum will be allowed. By specifying
    `Step`, you could, for example, accept only integer values. In this mode, the
    user may see the slider "jump" from one valid value to another as they slide the
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a simple slider widget set to the minimum value,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – The Slider widget shown at its minimum in the light and dark
    themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.18_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – The Slider widget shown at its minimum in the light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: TextGrid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the `Label` widget (described earlier) does provide some text formatting,
    there are some applications that require styles to be applied per-character. For
    syntax highlighting in a code editor or for showing error rows indicated on a
    console output, there is the `TextGrid` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a `TextGrid` widget, the content is split into each rune of the string
    representation, and each rune has a `TextGridStyle` applied to it. This style
    allows the foreground and background color to be specified for each character
    or cell of the grid. Additionally, each row of the grid can have a style specified.
    This style will be used for any cell that does not have its own style specified.
    If a cell has a character and a row style available, the two will be combined
    so that the foreground color that’s been set on the cell will adopt a background
    color from the row; that is, unless the character style specifies both.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the styles that allow specific colors to be set, there are a number
    of semantic style definitions that allow code to annotate intent instead of absolute
    colors. One of the most commonly used styles is `TextGridStyleWhitespace` that
    uses the theme definition to show characters in a muted color. Using the built-in
    styles, a developer can delegate to the current theme to define colors for each
    intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextGrid` widget also provides common functionality for technical text
    displays, including `ShowLineNumbers`, which displays the line number at the beginning
    of each row. Also, `ShowWhitespace` can be set to true for a visual indicator
    of otherwise invisible spacing characters such as tab, space, and newline. The
    following code example illustrates some of the ways you can control text in a
    `TextGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the result of the preceding code. Here, we can see
    that a background style has been applied to all the cells used in the 4 letters
    of *Grid* and that a row style has been applied to the second row (index 1). They
    also have line numbers and the whitespace options turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Styled content presented using TextGrid in the light and dark
    themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Styled content presented using TextGrid in the light and dark
    themes
  prefs: []
  type: TYPE_NORMAL
- en: The style for a cell can be assigned using the `SetStyle` method. However, when
    the style needs to be applied to many runes, developers can use the more efficient
    `SetStyleRange` utility method. The `SetRowStyle` method can assist in setting
    row styles, as shown in the previous image.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are lots of regularly accessed features in an application, the `Toolbar`
    widget can be an efficient way to present these options. The main elements of
    a toolbar are the `ToolbarAction` items, which are simple icons that, when tapped,
    execute a function parameter that’s been passed to `NewToolbarAction`. To group
    action elements, you can use `ToolbarSeparator`, which creates a visual divider
    between the item on its left and right. Additionally, a gap can be created between
    actions using the `ToolbarSpacer` type. This will expand, causing the elements
    after it to be right aligned. Using one spacer will show items before it on the
    left and items after it on the right. Using two will mean that the elements between
    the spacers will be central in the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct a toolbar containing four action elements and a separator, we
    can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet results in the following. The following image shows
    it in both the light and dark themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Toolbar widget with some possible icons in the light and dark
    themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Toolbar widget with some possible icons in the light and dark
    themes
  prefs: []
  type: TYPE_NORMAL
- en: The widgets that we have explored so far are fairly standard and can be created
    with simple constructors, or through initializing the struct directly. Some of
    these take a callback function that can be used to inform us when an action has
    occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at some more complex widgets that are designed
    to manage thousands of sub-widgets. To do so, we will learn how they make use
    of more function parameters to query large datasets and efficiently display a
    subset of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping with the collection widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at widgets that are designed to efficiently contain
    main widgets. Some of the widgets mentioned in the previous section do this, such
    as `Form` and `Toolbar`, but **collection widgets** support thousands of items
    (though they’re not all visible at one time). These widgets are commonly used
    for displaying a huge numbers of options or navigating complex datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the requirement that collection widgets only show large amounts of data,
    they are designed to only show a small portion of the possible widget at a time.
    To do this, and to maintain great performance, they have a caching mechanism that
    makes their API a little more complex than the widgets we have seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs: []
  type: TYPE_NORMAL
- en: Each of these widgets relies on a number of callback functions. The first of
    these functions will provide information on the dimensions of the data that the
    widget will display (for a more complete discussion on data, see [*Chapter 6*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166),
    *Data Binding and Storage*). The second of these is responsible for creating visual
    elements that will be displayed later, while the third will load an item from
    the data into a previously created element.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs: []
  type: TYPE_NORMAL
- en: The key to the performance of collection widgets is how they cache the graphical
    elements that repeat within them. The template objects referenced in collection
    widget constructors will be reused as the user scrolls the widget to maintain
    performance and keep up with the user actions.
  prefs: []
  type: TYPE_NORMAL
- en: The `List` widget (and other collection widgets) maintains an internal cache
    of recently used template elements that will have new data applied in preparation
    for the next rows becoming visible. It is the job of the application developer
    to optimize data retrieval so that any items that are close to those that are
    already visible will load quickly. We will see these concepts in use as we explore
    the various collection widgets that are available to us. First, we will look at
    the List widget.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `List` widget is used to display a vertical list of items where each item
    has a similar look. The relevant data can be loaded once the widget has been created,
    so it can be helpful if the data is slow to load or complex to display. The widget
    will only load and display the elements that are visible, thereby displaying the
    elements of a large dataset quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each of the collection widgets uses callback functions to understand the data,
    load a template item, and update it when the data is loaded. Let’s look at these
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the data – the `Length` callback: The first callback function
    for `List` is the `length` callback, which returns the number of items in the
    data. This tells the widget how many rows it will need to manage. If more items
    are added to the dataset, this value can be updated, and next time the list refreshes,
    it will adjust accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loading a template – the `CreateItem` callback: The second callback function
    is used to generate a reusable graphical element that will load data. This is
    called a `CanvasObject` and can be any type of `Widget`, `Container`, or item
    from the `canvas` package. The widget will call this function as many times as
    there are items visible on the screen. At this stage, they should contain just
    placeholder values. For example, in the images that follow, each row contains
    an icon and a label, so the returned template would probably be a container with
    a horizontal box layout, along with a default icon and placeholder text in the
    label. Although the user will never see the placeholder values, they are important
    as the size of a template configures the `List` component. The height of a template
    item will be used for the height of every row so that when it’s multiplied by
    the result of the previous length, the callback will determine the overall scroll
    height of the list component. Additionally, the template width will specify the
    minimum width for the `List` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filling the template with data – the `UpdateItem` callback: Callback three
    is used to apply data to a template cell. It receives two parameters: the index
    of the data item to use and the `CanvasObject` template that we configured earlier.
    The purpose of this callback is to configure the item with the data that should
    be used at the specified index. The template that’s used will be identical to
    the return object of the second parameter so that it can be cast appropriately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each collection widget has variations of the pattern described previously, as
    we will see in the *Table* and *Tree* sections later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One additional feature of the collection widgets is that they allow an element
    to be selected (by being tapped). In the list interface, the selected element
    is indicated by a marker at the leading edge, as shown in the preceding image.
    To be notified when an item is selected, you can set a `func(ListItemID)` callback
    on the `OnSelected` field, which will notify you of which item from the dataset
    was selected. The basic code for creating a list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The code sample will generate the following output, once the second item has
    been tapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – List collection widget with an item selected in the light and
    dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.21_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.21 – List collection widget with an item selected in the light and
    dark themes
  prefs: []
  type: TYPE_NORMAL
- en: Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Table` widget is a two-dimensional version of the `List` widget and is
    designed for showing large datasets with row and column aspects. It uses the same
    system for caching and callbacks as the `List` and `Tree` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Table` widget’s callbacks are similar to those for `List`, but the data
    identifiers pass a row and column `int` to index the data structure. This means
    that the `Length` callback now returns `(int, int)`.
  prefs: []
  type: TYPE_NORMAL
- en: The callback that sets up new graphical templates in the `Table` version (called
    `CreateCell`) takes no parameters and just returns a `fyne.CanvasObject` that
    will be cached for use in the display. This template is used to determine the
    default size of all cells, so make sure that it has a sensible minimum size. As
    with `List`, the element you return here will not be presented to the user but
    will be used for measurements and configuring the overall layout.
  prefs: []
  type: TYPE_NORMAL
- en: The last required callback is `UpdateCell` and is used to apply data to a template
    element. In the `Table` widget, this function passes a data identifier (`TableCellID`,
    which contains a `Row` and `Col` int) that indexes the data to apply, as well
    as the `CanvasObject` template. Developers should fill in the template with the
    appropriate data specified by the identifier. As with other collection widgets,
    it is recommended, where possible, to load related data so that when the user
    scrolls or expands an element, any data that takes a long time to load is ready
    to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Table` widget supports a selected cell, as is indicated by a marker at
    the leading edge and header, as shown in the following image. To be notified of
    when an item has been selected, you can set the `func(TableCellID)` callback on
    the `OnSelected` field. This will notify you of which item from the dataset was
    selected by passing the identifying row and column. The basic code for creating
    a new table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the following output, assuming cell 2, 1 is
    tapped to gain selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Table collection widget showing selection in the light and
    dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.22_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.22 – Table collection widget showing selection in the light and dark
    themes
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Tree` widget is very similar to the `List` widget, but with the added feature
    that each element can expand to show other items. This expansion is used to show
    a hierarchy, such as directories and files, categories and items, or other data
    with a parent-child relationship present.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Tree` widget’s callbacks are similar to `List` and `Table`, but its more
    complex data structure means that the simple `Length` callback is replaced by
    `ChildUIDs` and `IsBranch`. The first of these callbacks will return a slice of
    `TreeNodeID` values (regular strings can be used) that contain the unique identifier
    for each item that exists under the specified node (passed in as a unique `TreeNodeID`).
    The second is called for each element while passing the unique ID. It should return
    `true` if it can container further nodes, or `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The callback that sets up new graphical templates in the `Tree` version (called
    `CreateNode`) takes a bool parameter that represents if this is a branch (`true`,
    can expand) or a leaf (`false`, this is the end of the tree). This is useful if
    you want to use a different style for the branch and leaf elements within your
    tree. As with `List`, the element you return here will not be presented to the
    user but will be used for measurements and configuring the overall layout.
  prefs: []
  type: TYPE_NORMAL
- en: The last required callback is `UpdateNode`. This is used to apply data to a
    template element. In the `Tree` widget, this function passes the unique `TreeNodeID`
    identifier, a `bool` representing whether this is a branch or leaf template, and
    the `CanvasObject` template. Developers should fill in this template with the
    appropriate data specified by the identifier. As with other collection widgets,
    it is recommended, where possible, to load related data so that when the user
    scrolls or expands an element, data that loads slowly is ready to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, regarding the callbacks that are required to manage content, the
    `Tree` widget allows developers to set the `OnBranchOpened` and `OnBranchClosed`
    callbacks so that they can track changes in the state of the tree. Both functions
    are of the `func(TreeNodeID)` type, where the parameter is the unique identifier
    of the data item.
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Tree` widget also supports selected nodes. This is indicated by a marker
    at the leading edge, as shown in the following image. To be notified of when an
    item has been selected, you can set the `func(TreeNodeID)` callback on the `OnSelected`
    field. This will notify you of which item of the dataset was selected, while passing
    the unique identifier. The basic code required to show a tree is as follows. The
    first callback is returning the unique IDs of the children at each level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display a tree in the app. Once the second element
    has been expanded, this tree will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Tree widget with the branch expanded, shown in the light and
    dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Tree widget with the branch expanded, shown in the light and dark
    themes
  prefs: []
  type: TYPE_NORMAL
- en: The three collection widgets shown in this section provide useful functionality
    for presenting large or complex data. The API is a little more complex than the
    standard widgets, but this allows massive datasets to be presented to users; for
    example, by scrolling through thousands of records from a database or showing
    parts of a large file tree.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a selection of container widgets that we can use to build out more complex
    user interface designs and navigate through applications. We will discover these
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding structure with container widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066), *Window, Canvas,
    and Drawing*, we learned how a `Container` is used to group multiple objects within
    a canvas. Using the layouts we explored in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*, it is possible to automatically arrange each `CanvasObject`
    according to certain rules. However, sometimes, an application would like items
    to appear and disappear according to user interaction, or to have visual attributes
    beyond their size and position. Container widgets can provide these richer behaviors.
    These structural widgets can be found in the `container` package and include scrolling,
    grouping, and variations of hiding and showing content. Let’s explore each of
    these options (in alphabetical order).
  prefs: []
  type: TYPE_NORMAL
- en: AppTabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AppTabs` container is used for controlling large areas of an application
    where the content should be switched out based on the current activity. For example,
    this may be used to fit lots of graphical elements into a small application user
    interface when only sub-sections are useful at one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each tab in a tab container can contain text and/or an icon (whichever combination
    is used should be consistent for all items). Each tab has an associated `CanvasObject`
    (usually a container) that will be shown when the tab is selected. These are created
    using `TabItem` objects that have been passed to the `NewAppTabs` constructor
    function. To create two tabs with icons and labels, you would use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will render as one of the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Two tabs with text and icons in an AppTabs widget using the
    light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.24_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.24 – Two tabs with text and icons in an AppTabs widget using the light
    and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding image shows the tabs in their default orientation. However, the
    tab container can show tabs on any one of the four edges. The `SetTabLocation()`
    function takes one of the `TabLocation` types; that is, `TabLocationTop`, `TabLocationBottom`,
    `TabLocationLeading` (normally the left-hand side) or `TabLocationTrailing` (after
    content – normally on the right-hand side). The following image shows how the
    tab’s location can change the icon’s layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Tab containers at the bottom, with leading and trailing locations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.25_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.25 – Tab containers at the bottom, with leading and trailing locations
  prefs: []
  type: TYPE_NORMAL
- en: When running the application on a mobile device, it is expected for tabs to
    be on the top or bottom in portrait mode. Therefore, the locations will adapt
    appropriately – the leading setting will show the tabs at the top, while the trailing
    setting will stets the tabs at the bottom. If the mobile device is rotated, then
    the tabs will move to the left or right edge – leaving more space for content.
    In landscape mode, any tabs that have requested the top position will be shown
    on the leading (left-hand side) edge; the bottom setting will move to the trailing
    (right-hand side) edge.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the widgets that need to scroll content include the functionality to
    do so. However, if you want to add scrolling capabilities to your content, you
    can use the `Scroll` container. By wrapping some other element in a scroll container,
    you add scrollbars on the horizontal and vertical dimensions. The constructor
    function for scrolling in both the horizontal and vertical dimensions is `container.NewScroll()`.
    You can also call `NewHScroll()` if you would only like to scroll horizontally,
    or `NewVScroll()` if you would only like to scroll vertically. The following image
    shows full scrolling on simple label content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Scroll container showing a scrollbar and shadow in the light
    and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.26_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.26 – Scroll container showing a scrollbar and shadow in the light and
    dark themes
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the minimum size for a scroll container becomes very small –
    just 32x32\. If you use the horizontal scroller, then its minimum height will
    fit the content, while if you use the vertical scroller (such as a list), then
    the width will adapt to fit the content.
  prefs: []
  type: TYPE_NORMAL
- en: Split
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Split` container provides us with a neat way to separate two parts of
    our application when we would like our users to be able to change the amount of
    space available for each section. This can be split horizontally or vertically.
    A horizontal split container displays two elements side by side with a split bar
    between them. The vertical split will stack elements one above the other with
    a split bar in-between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following image, you can see a horizontal split container with `Line1\nLine2`
    on the left-hand (leading) side and a vertical split containing `Top` and `Bottom`
    on the right-hand (trailing) side:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In horizontal mode, the leading position (first parameter) is normally on the
    left, while in vertical mode, it will be on the top.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – The Split widget in horizontal and vertical modes using the
    light and dark themes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.27_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.27 – The Split widget in horizontal and vertical modes using the light
    and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: The split container allows the bar to be dragged to change the size allocated
    to each side of the split. The container’s minimum size will be the sum of the
    two contents (plus the split) and unless it is in a parent container with more
    space, the bar will not be draggable. When there is more space available, then
    dragging the bar will change where the extra space is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can also manually specify the proportion directly using the `Offset`
    field. A value of `0.0` means that the split should be as far left (or up) as
    possible, while a value of `1.0` means it should be fully right (or bottom aligned).
    This value can be queried during app runtime if you want to save the user’s preference.
  prefs: []
  type: TYPE_NORMAL
- en: As well as composing standard widgets together to form a clear and logical user
    interface, it is sometimes useful to display temporary information or request
    user input. For cases where developers or designers do not want to include this
    in their main interface, there is a package of standard popup dialog boxes we
    can use. We will explore this next.
  prefs: []
  type: TYPE_NORMAL
- en: Using common dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the user’s journey of an application, you will often need to interrupt
    the flow to present information, ask the user for confirmation, or to pick a file
    or other input element. For this purpose, toolkits usually provide dialog windows,
    and Fyne does the same. Instead of opening a new window, the dialogs will appear
    over existing content in the current window (which works well across all platforms
    as not all manage multiple window applications well).
  prefs: []
  type: TYPE_NORMAL
- en: Each dialog has its own constructor function (of the `dialog.NewXxx()` form)
    that create the dialog to be shown later using `Show()`. They also provide a helper
    function to create and show it (of the `dialog.ShowXxx()` form). The last parameter
    of all these functions is the window that they should be displayed in. All the
    dialogs also support setting a callback when the dialog closes. This can be configured
    using the `SetOnClosed()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the different dialog helpers that are available
    (in alphabetical order) before learning how to build a custom dialog for an application.
    Although, these will load in the current application theme, we only showed one
    image for each example.
  prefs: []
  type: TYPE_NORMAL
- en: ColorPicker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fyne provides a standard dialog for picking a color within applications. This
    feature will present a selection of standard colors, a list of recently selected
    colors, and also an advanced area where specific colors can be chosen through
    value sliders, editing the channel values in **Red**, **Green**, and **Blue**
    (**RGB**) or **Hue**, **Saturation**, and **Lightness** (**HSL**), or by entering
    the RGB hex color notation directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The color picker can be created by calling `dialog.NewColorPicker()` and then
    using `Show()` or simply calling `dialog.ShowColorPicker()`. The parameters of
    the constructor are the title and message to be shown at the top, a callback function
    for when the color is selected, and the parent window to display within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will load up the picker, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – The simple color picker dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.28_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.28 – The simple color picker dialog
  prefs: []
  type: TYPE_NORMAL
- en: The previous image shows the default simple color picker. Advanced features
    are available if you want your developers to have more control.
  prefs: []
  type: TYPE_NORMAL
- en: Confirmation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The confirmation dialog allows you to ask a user to confirm an action. As well
    as providing the title and content for this confirmation, developers can pass
    a callback function that will be called when the user makes their decision, with
    the parameter being false for a negative answer or true for a confirmed one. Like
    all dialogs, the last parameter is the parent window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The confirmation dialog will look as follows if the light theme is currently
    loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – A confirmation dialog using the light theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.29_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.29 – A confirmation dialog using the light theme
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to remember that showing a dialog does not stop the code that
    loaded it. The user’s decision will be communicated through the callback; the
    rest of your code will continue uninterrupted.
  prefs: []
  type: TYPE_NORMAL
- en: File selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*, the `dialog` package can help with file selection
    – choosing which file to open or where to save content. Opening the `fyne.URIReadCloser`
    or `fyne.URIWriteCloser` type and an error since these operations can fail for
    a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The Open File dialog looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – The file dialog is used for choosing a file to open or save'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.30_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.30 – The file dialog is used for choosing a file to open or save
  prefs: []
  type: TYPE_NORMAL
- en: The file dialogs will default to showing the user’s home directory. This can
    be changed by calling the `SetLocation` method. As this is a cross-platform API,
    the starting location is a `URI` rather than a `string` path. This also means
    that the file dialog can be used to show the contents of remote file systems and
    other sources of file data.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, applications can ask where to write a file to use the `dialog.ShowFileSave`
    method. It is also possible to prompt for folder selection instead of files, using
    `dialog.ShowFolderOpen`.
  prefs: []
  type: TYPE_NORMAL
- en: Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Form` dialog extends the simple premise of a confirmation by requesting
    a value to be input, in addition to confirming the result. The `Form` dialog can
    contain various widgets in the same way that the `Form` widget did in the *Introducing
    the basic widgets* section. The constructor function is similar to the confirm
    dialog, but it accepts an additional slice of `*widget.FormItem` values to specify
    the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be a dialog with an `widget.Entry` field, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – Asking a user for an input value using the Entry dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.31_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.31 – Asking a user for an input value using the Entry dialog
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a command-line application, information will commonly be written to standard
    output or standard error (normally for error messages). However, graphical applications
    will normally not be run from the command line, so messages that the user should
    see will need to be presented differently. The dialog package can help with this
    task as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'An information dialog box can be used to present a standard message when its
    importance is high enough that the user should be interrupted to take a look at
    it. The `dialog.ShowInformation` function is called to present this dialog and
    it takes a title and message parameter. If the information to present is an error,
    then the `dialog.ShowError` helper function can be used as it takes an error type
    and the information is extracted to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The information dialog box will be presented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32 – An information dialog box in the light theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.32_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.32 – An information dialog box in the light theme
  prefs: []
  type: TYPE_NORMAL
- en: After these, we move to the custom dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Custom dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the preceding dialogs should cover most of the reasons why you may
    wish to interrupt the user flow with a pop-up dialog, your app may have additional
    requirements. To support this, you can insert any content into a custom dialog
    so that the overall layout is consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct a custom dialog, a new parameter and its content must be passed
    to the constructor function. Any Fyne widget or `CanvasObject` can be used in
    a custom dialog, which includes containers to provide more complex content. To
    illustrate this, we will use a `TextGrid` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate a custom dialog, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33 – A dialog showing custom content (a TextGrid)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.33_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.33 – A dialog showing custom content (a TextGrid)
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `ShowCustomConfirm()` version, which provides the `func(bool)`
    callback to inform the developer of which button was tapped.
  prefs: []
  type: TYPE_NORMAL
- en: By exploring various widgets and dialogs, we have seen what the standard theme
    looks like and that light and dark versions are available. Next, we will look
    at what a theme consists of and how they can be managed and customized.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The themes within the Fyne toolkit implement the color palette, iconography,
    and size/padding values of the Material Design look and feel. The design of the
    theme API aims to ensure that applications feel consistent and deliver a good
    user experience while allowing developers to convey an identity and customization.
    All Fyne applications can be displayed in light or dark mode using built-in themes.
    We will look at these in detail next.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since more and more operating systems are supporting light versus dark desktop
    coloring, the Fyne theme specification supports both light and dark variants.
    By default, every app will ship with a built-in theme that provides both light
    and dark variants. This theme was illustrated extensively in the *Introducing
    the basic widgets* section earlier in this chapter, but to see how this all comes
    together, take a look at the following screenshot of a Fyne demo application that
    showcases widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – A collection of widgets in a default theme – light variant'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.34_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.34 – A collection of widgets in a default theme – light variant
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous screenshot shows the widget demo in the light theme. The following
    screenshot shows the same but with the built-in dark theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – Various widgets using the dark theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.35_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.35 – Various widgets using the dark theme
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the main color being used (the primary color – blue, in this
    case) has been chosen as it contrasts well with the background colors of both
    the light and dark themes. When using this model, themes can vary the primary
    color while continuing to support both light and dark user preferences.
  prefs: []
  type: TYPE_NORMAL
- en: On most operating systems, Fyne will automatically pick the theme variant that
    best matches the current user’s preferences. There are ways that the user can
    choose a specific version, as we’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: User settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, Fyne-based applications will normally detect the user’s
    preference for either the light or dark theme and load it accordingly. It is possible
    to set a preference for which theme is loaded by using the Fyne settings application
    or by using environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **fyne_settings** application, which can configure all Fyne-based applications,
    can be run to manage the user’s settings. This includes their theme variant (light
    or dark), as well as what primary color they will use. Any changes that are made
    using this interface will be saved for the future and will immediately apply to
    all open applications. You can also find the **Settings** panel from the **Settings**
    menu within **fyne_demo**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.36 – The fyne_settings application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.36_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.36 – The fyne_settings application
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables can be useful if you wish to temporarily apply a
    theme, or if you would like one app to use a different theme. The `FYNE_THEME`
    environment variable can be set to *light* or *dark* to specify which variant
    should be used. You can similarly override the default interface scaling that’s
    available using the `FYNE_SCALE` environment variable. Here, `1.0` is the standard
    to use; smaller numbers load smaller content, while larger numbers load larger
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Included icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As could be seen in some of the widgets earlier in this chapter (for example,
    `Button` and `AppTabs`), the theme package includes many icons from the material
    design collection (the full official set can be found at [https://material.io/resources/icons/](https://material.io/resources/icons/)).
  prefs: []
  type: TYPE_NORMAL
- en: Because all the elements of Fyne-based apps are designed to scale appropriately
    for different types of display and user preferences, the images should be vector-based
    rather than bitmap-based. This means that when displaying at very small or large
    sizes, the exact pixels to display will be calculated for optimal display instead
    of multiplying (or reducing) the number of pixels from the original image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the material design images are available in vector formats and
    the built-in icons are all in **scalable vector graphics** (**SVG**) format. This
    also means that icons can easily be adapted for various colors as the app runs,
    thus ensuring that they can adapt to the primary color and current theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37 – A selection of material design icons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.37_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.37 – A selection of material design icons
  prefs: []
  type: TYPE_NORMAL
- en: Because the icon set is freely available and very popular, it is easy to download
    additional icons and add them to your application, knowing that they will fit
    the toolkit’s overall aesthetic.
  prefs: []
  type: TYPE_NORMAL
- en: Application override
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers of applications that wish to deviate from the default (or user-selected)
    theme are also catered for in the Fyne theme API. Be careful before specifying
    a theme for your application – it may feel like a surprise to your app users.
    To use one of the built-in themes but override the user or system setting regarding
    whether the light or dark variant is used, you can call `SetTheme()` on the current
    `App` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, to force the application to use the built-in light theme, use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This API is more commonly used to set up a custom application theme. The details
    of creating a custom theme will be covered in [*Chapter 7*](B16820_07_Final_JM_ePub.xhtml#_idTextAnchor193),
    *Building Custom Widgets and Themes*. Once you have created a theme, it can be
    loaded using the `SetTheme()` function, which will apply it to the current app.
    The following screenshot shows a custom theme that deviates from the standard
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.38 – A BBC Micro Emulator GUI based on Fyne'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.38_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.38 – A BBC Micro Emulator GUI based on Fyne
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the details of the main widgets and theme capabilities
    of the Fyne toolkit, let’s build a simple app that brings many of them together.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a task list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore some of the widgets listed in the previous sections and how they
    can be brought together into a simple application, we will build a small task
    list. This application will show a list of tasks based on complete or incomplete
    state and allow the user to edit the details of each item.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the GUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will piece together a basic user interface for the task application.
    It will contain a list of tasks on the left-hand side of the app and a collection
    of components that edit a task on the right-hand side. Above this, we will add
    a toolbar for other actions. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of tasks will be a `List` widget that notifies the user when an item
    has been selected. The `List` widget will contain static content for this mock-up.
    Here, we will tell the list that there are a set number of items (for example,
    `5`) so that it creates the correct number of items to display. We create a new
    check item each time the list calls the `CreateItem` callback. For now, we will
    leave the third (`UpdateItem`) method empty so that it just displays templates
    values. This code will be created in a simple `makeUI` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the widgets that will allow us to edit a task item. Let’s
    create a `Form` widget that will hold the items we need and provide labels as
    well. We will create a new row for each item using `widget.NewFormItem`, passing
    the `string` label and the widget’s content as parameters. These are all standard
    widgets, but the callbacks we are passing are empty at the moment. We will return
    to these widgets later to complete their functionality. The following code goes
    inside the `makeUI` function we started in the previous segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last component that we will add to the interface is a toolbar that will
    provide access to the add task function. To do so, we will create a `widget.Toolbar`
    using the `ToolbarAction` item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To bring these interface elements together, we will create a new container
    using the `Border` layout. The toolbar will be set as the top item and the task
    items will be on the left of the container. Our form will take up the remaining
    space by being passed as a component that’s not specified as being on a border.
    This container will be returned from the `makeUI` function so that it can be used
    to display our application window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run our application, all we need to do is add the usual launcher code, which
    creates a window and sets our content. We do not need to specify a size for this
    window as the contents will naturally condense down to a sensible minimum size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running all the code we’ve created so far will give us a good impression of
    what the application will look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using the Fyne light theme (by going through the user preferences options
    or by setting `FYNE_THEME="light"`), the application should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.39 – Our task list GUI skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.39_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.39 – Our task list GUI skeleton
  prefs: []
  type: TYPE_NORMAL
- en: Before we can complete the functionality of this application, we need to define
    a data structure that will hold information about the tasks we are editing.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our application to function correctly, we will need to create a data structure
    that will manage the information we are editing. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define a `task` data structure – this simply lists the various
    fields that match the inputs in the design we made in the previous section. Different
    fields will be stored in different types – for example, the `Entry` widget maps
    to `string` and our checkbox maps to `bool`. We will add the following code to
    a new file called `data.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have used `float64` for the value of our completion `Slider`
    and that we will be converting the date entry into `time.Time` format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we will be storing many tasks, we could simply create a slice of task
    pointers, but by defining a new type, we can associate certain functions with
    others that will be useful later. The type just wraps the `[]*task` slice, which
    will store the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we will be displaying the list of tasks based on the `done` state, we
    should add two helper methods that return these sub-lists based on the value of
    that field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also define some constants that help in managing the different priority
    levels in our data. Refer to the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When writing data handling code, it’s important to write tests as well. If
    you add these before connecting to the user interface, then bugs can surface sooner.
    This means that when we add graphical tests, any issues that are found should
    relate to a mistake in our user interface code. Create a new file called `data_test.go`
    and the following tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: More tests can be added to this project – you can find them in the code repository
    for this book, inside the `Chapter05` folder, at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter05).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have not explored data storage in this chapter, so we will just be keeping
    the task list in memory. You will find out more about data and preference storage
    in [*Chapter 6*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166), *Data Binding
    and Storage*. Since our data will be reset each time the application is run, we
    should create another function that populates a data structure with some content
    that will be loaded when the app starts, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have defined the data structure and basic functions, we can connect
    it to the user interface and complete the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to update a widget’s content is to keep a reference regarding
    the instance once it has been constructed. We will be doing this for a number
    of elements, so we should create a new type that will handle the various elements
    of the user interface. Creating this struct means that we can avoid lots of global
    variables, which should help keep the code neat. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new struct and name it `taskApp`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type includes a reference to the `*taskList` data structure, which will
    hold our date, and defines a slice of `*task` types that represents the tasks
    that are currently visible (the result of calling `taskList.remaining()` or `taskList.done()`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we can make our `makeUI` function a method of the `taskApp` type so that
    its signature becomes `func (a *taskApp) makeUI() fyne.CanvasObject`. Doing this
    gives us access to the data structure we defined earlier through `a.data`. We
    will, however, use the task list stored in `visible` to populate our list as it
    may contain completed or incomplete items, depending on its current state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code that sets up the list widget can now be updated with the following
    code. We store its reference in `a.tasks` instead of the original `todos` variable
    (so that we can reference it later); don’t forget to change the `todos` reference
    returned from `makeUI` to use `a.tasks` as well. The result of our `Length` callback
    function simply returns the number of items in the `a.visible` slice. Although
    the `CreateItem` callback (the middle parameter) does not need to change, we do
    provide an implementation for the final callback; that is, `UpdateItem`. This
    new function obtains the task from the specified index (`i`) and uses `task.title`
    to set the text of the `Check` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see these changes in action, we need to set up the data source. For this,
    we must add a line that will create our dummy data and construct the new `taskApp`
    struct just before the call to `SetContent`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Performing these code alterations will update the app so that it reflects the
    task titles in the main list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40 – Showing real task titles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.40_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.40 – Showing real task titles
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to fill in the details on the right-hand side of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Filling in the details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To populate the data area of the app, we will need to keep track of the current
    task and the widgets that it should fill. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will add a `current` field to the `taskApp` structure. After
    that, we need to save a reference to each of the input elements that we added
    for the initial layout tests, which will require more fields in `taskApp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With these in place, we can complete the replacement for the `details` setup
    within `makeUI` so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this setup code is complete, we can add a new function called `setTask`.
    This will be used to update the current task and refresh the detail elements we
    created in the previous code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To support that code, we will also define the `formatDate` function, which
    converts our date into a string value. This will return an empty string if the
    optional `date` is `nil`, or format it using the `dateFormat` constant otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this code in place, we can set the first task to be presented on the display.
    Of course, we should check if there are any tasks before assuming that an item
    can be shown. The following code is updated in the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last piece of code we need in order to update our user interface as the
    user browses is `List.OnSelected`. This will allow us to update the details that
    are displayed when the list is tapped. Simply add the following line once you’ve
    created our `List`, which is set to load from `a.tasks`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With all the code in place, we have a complete application, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.41 – Complete user interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.41_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.41 – Complete user interface
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code shown previously will work with the current theme, which means
    we can see the same content when we’re using the standard dark theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.42 – The tasks user interface in the standard dark theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.42_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.42 – The tasks user interface in the standard dark theme
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will handle how details are saved when the user edits any data.
  prefs: []
  type: TYPE_NORMAL
- en: Editing content
  prefs: []
  type: TYPE_NORMAL
- en: 'When each of the input widgets are edited, we should update the dataset. This
    is trivial for most inputs as we can just set the `OnChanged` callback so that
    we’re notified when the data changes. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In each callback, we must ensure that a task is currently selected (in case
    all the tasks have been deleted) and then set the appropriate field. The callback
    for `Title` is as follows. Note that we also call `Refresh()` on the task list
    as the title change should be reflected in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of the other callbacks are similar, so they have been omitted from this
    description – the full code is available in this book’s GitHub repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The priority callback update is a little more complex as we are converting
    a choice of string representations into a number field. Note that the callback
    is a function that’s been passed to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will look at the input widget as we should add validation for the
    date format. To do this, we set the `Validator` callback to provide the user with
    feedback about the input state. First, we must create a new validator that can
    check the date format, which simply has a `Validate(string)` `error` function
    signature (meaning it implements `fyne.StringValidator`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the validator in place, we simply set it as the `OnChanged` callback.
    In this callback, we need to reparse the date to get the appropriate date for
    the input (we skip this if the input is empty):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is all the code we need for presenting and editing tasks. Next, we’ll learn
    how to mark tasks as complete and keep the list updated.
  prefs: []
  type: TYPE_NORMAL
- en: Marking tasks as complete
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of functionality we will add is the ability to mark a task as
    complete. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are within the list, we need to set the callback within the `UpdateItem`
    callback to `List` to be able to mark the correct item as done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we need to make use of a helpful `refreshData()` function that updates
    the data list (by re-calculating what remains) and then asks the `task` widget
    to refresh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, it functions correctly. However, upon clicking the `Check` text,
    it marks a task as done instead of selecting it for editing. To improve this,
    we can move the text component to a separate `Label` widget that will allow the
    mouse clicks through to the list selection logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, we will return a `Check` and a `Label` by using `container.NewHBox`
    in the template function. When applying content in the update callback, we need
    to extract the widgets from the `Container.Objects[]` field. Otherwise, the code
    is similar to what it was earlier. The final list implementation is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we will implement the `add` button in the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new task
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will update the data code so that we can add new tasks.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new `add()` function with a `task` parameter and prepend
    it to the top of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because data functions are usually easy to test, we will add another unit test
    inside `data_test.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unit testing the whole user interface is highly advisable but outside the scope
    of this example – we will return to this topic in [*Chapter 8*](B16820_08_Final_JM_ePub.xhtml#_idTextAnchor205),
    *Project Structure and Best Practices.*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To complete the add task functionality, we must fill in the callback in the
    `NewToolbarAction()` function that we called when we first set up the user interface.
    This code simply creates a new `task` with the title `New task`, adds it to the
    data, and then reuses the same `refreshData()` function that we created for hiding
    completed tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code concludes our tasks app example. There is more functionality
    that we could add, but we’ll leave that as an exercise for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how the Fyne Widget API is designed and looked at
    a list of standard widgets. We saw how containers and collection widgets can help
    us organize and manage user interface components. The dialog package was also
    explored to show how we can use it with our applications in order to implement
    standard components for common activities.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how themes are implemented within the toolkit and how they apply
    to all the widget components. This chapter demonstrated the light and dark variants
    of the standard theme and showed that applications can provide their own themes
    for a custom look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: By building a task tracking application, we saw how many of the built-in widgets
    are used, how to lay them out in various containers, and how user interactions
    can be tracked to manage some in-memory data. In the next chapter, we will look
    at data binding and storage APIs, which can help us manage more complex data requirements.
  prefs: []
  type: TYPE_NORMAL
