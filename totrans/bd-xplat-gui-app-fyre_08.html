<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-165"><em class="italic"><a id="_idTextAnchor166"/>Chapter 6</em>: Data Binding and Storage</h1>
			<p>In the previous chapter, we learned that widgets can be controlled manually by application code. As we start looking at more complex applications, it's common for developers to want to display or manipulate a dynamic data source. The Fyne toolkit provides data and storage APIs that automate a lot of this work. </p>
			<p>In this chapter, we're going to explore the ways that data is handled within the Fyne toolkit. We will cover the following topics:</p>
			<ul>
				<li>Binding data to widgets</li>
				<li>Adapting data types for display</li>
				<li>Binding complex data types</li>
				<li>Storing data using the Preferences API</li>
			</ul>
			<p>By the end of the chapter, we will know how to make use of the data binding and storage APIs to create an app that helps track water consumption. It will store information on the local device and use APIs to explore how to minimize the coding required to manage data.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Technical requirements</h1>
			<p>This chapter has the same requirements as <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Windows, Canvas, and Drawing</em>, in that you must have the Fyne toolkit installed and a Go and C compiler working. For more information, please refer to the previous chapter.</p>
			<p>The full source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06</a>.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Binding data to widgets</h1>
			<p>When we <a id="_idIndexMarker398"/>explored widgets in <a href="B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a>, <em class="italic">Widget Library and Themes</em>, we <a id="_idIndexMarker399"/>saw how information can be gathered and presented. Each widget we looked at was configured manually, and accessing data that the user entered (such as with the <strong class="source-inline">Entry</strong> widget) required code to query the widget's state. The <strong class="source-inline">fyne.io/fyne/data/binding</strong> package provides functionality that supports automatically connecting widgets to data sources to handle this more efficiently.</p>
			<p>In the following sections, we will explore what data binding is, why it is so useful, and how it is designed within the Fyne APIs.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Understanding data binding</h2>
			<p>There are many different <a id="_idIndexMarker400"/>approaches to data binding, and definitions can vary, depending on the toolkit that you are working with. In general, data binding allows the component of a graphical interface to have its display controlled by a separate data source. Moreover, it ensures that the graphical representation is always up to date with changes, and that user actioned changes within the user interface are synchronized back to the original data. </p>
			<p>You can see how .NET approaches its implementation at <a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview">https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview</a>. Android also provides similar functionality, which is documented at <a href="https://developer.android.com/topic/libraries/data-binding">https://developer.android.com/topic/libraries/data-binding</a>.</p>
			<p>Despite the various approaches taken by each toolkit, the basics of any successful data binding are that the graphical output is automatically updated based on the state of a separate data object. This is known as <strong class="bold">unidirectional</strong> binding, often known as a <em class="italic">one-way data flow</em>. This is sufficient for data display when the information comes from an external source. However, it is not sufficient if your application will be modifying the data. Complete data binding (<strong class="bold">two-way</strong> or <strong class="bold">bidirectional</strong>) ensures that as well as keeping presented data up to date, it will also update the source data if the user alters the presentation through some interactive widget.</p>
			<p>All the data binding that's done in the Fyne toolkit is bidirectional, meaning that each connection that's made can read or write the data it is connected to. Widgets that are only used for display purposes will not make use of the ability to write the data, but an input widget such as an entry or a slider will push data changes out to connected bindings. There's an underlying data source for each data binding. We will look at what data types are supported in the next section.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>Supported data types</h2>
			<p>Just like the main Go language, all the values in the Fyne data API are strongly typed – this means that a data binding has a specific type of value. Each value matches a primitive Go type, ensuring that the compiler can check that these values are used in the correct way.</p>
			<p>At the time of writing, the Fyne data<a id="_idIndexMarker401"/> binding supports the following types:</p>
			<ul>
				<li><strong class="source-inline">Bool</strong>: A boolean value can be <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. This type uses a <strong class="source-inline">bool</strong> for its internal storage.</li>
				<li><strong class="source-inline">Float</strong>: A floating-point number value, this uses the <strong class="source-inline">float64</strong> type for internal storage.</li>
				<li><strong class="source-inline">Int</strong>: A whole number value with positive and negative numbers, stored using the <strong class="source-inline">int</strong> type.</li>
				<li><strong class="source-inline">Rune</strong>: A representation of a single unicode character, backed by the <strong class="source-inline">rune</strong> type.</li>
				<li><strong class="source-inline">String</strong>: A bindable version of the Go <strong class="source-inline">string</strong> type.</li>
				<li><strong class="source-inline">List</strong>: A mapping similar to <strong class="source-inline">slice</strong> or <strong class="source-inline">array</strong> that can contain a collection of a single type, indexed by an <strong class="source-inline">int</strong> offset.</li>
				<li><strong class="source-inline">Map</strong>: A bindable version of the <strong class="source-inline">map</strong> primitive that can hold many types indexed by a <strong class="source-inline">string</strong> key.</li>
				<li><strong class="source-inline">Struct</strong>: A data binding similar to <strong class="source-inline">map</strong> where the keys represent exported elements of a developer defined <strong class="source-inline">struct</strong> type.</li>
			</ul>
			<p>The value type you use may be determined by the source data, or (if you are not bound to an existing data source) the output widgets you use. We will explore widget connections later in this section, but it is useful to know that we can convert types where needed. We will explore this later in the <em class="italic">Adapting data types for display</em> section.</p>
			<p>When you have more complex data, such as a list or struct, you can still use the data binding API but with more advanced types, as discussed later in the <em class="italic">Binding complex data types</em> section. </p>
			<p>Now that we've learned what data types are available, let's look at how to read and write data through a binding.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Creating, reading, and writing bound data</h2>
			<p>Each of the basic data<a id="_idIndexMarker402"/> types provided by the binding API (<strong class="source-inline">Bool</strong>, <strong class="source-inline">Float</strong>, <strong class="source-inline">Int</strong>, <strong class="source-inline">Rune</strong>, and <strong class="source-inline">String</strong>) provide <a id="_idIndexMarker403"/>two constructors: one that creates a new variable from<a id="_idIndexMarker404"/> the Go zero value (using the <strong class="source-inline">New...()</strong> name), and another that binds to an existing variable (named <strong class="source-inline">Bind...()</strong>). It also provides <strong class="source-inline">Get()</strong> and <strong class="source-inline">Set()</strong> functions to manage data access. We'll explore these in detail next while using the <strong class="source-inline">Float</strong> type as an example.</p>
			<h3>NewFloat() Float</h3>
			<p>Creating a data binding using<a id="_idIndexMarker405"/> the <strong class="source-inline">New...</strong> constructor function will create a new piece of data with a standard value of zero. The returned object implements the <strong class="source-inline">DataItem</strong> interface, which enables binding. We'll look at this in more detail in the <em class="italic">Listening for changes</em> section, later in this chapter.</p>
			<h3>BindFloat(*float64) Float</h3>
			<p>The <strong class="source-inline">Bind...</strong> constructor function <a id="_idIndexMarker406"/>creates a bindable data item using a pointer to the primitive value. Using this function, we can set default values that are non-zero. Additionally, the original variable can still be used to get and set the data in places where data binding is not supported. In the following code, we are creating a new data binding to a floating-point value that defaults to <strong class="source-inline">0.5</strong>:</p>
			<p class="source-code">f := 0.5</p>
			<p class="source-code">data := binding.BindFloat(&amp;f)</p>
			<p>The <strong class="source-inline">data</strong> variable that was returned is a new data binding of the <strong class="source-inline">Float</strong> type initialized to  <strong class="source-inline">0.5</strong>. If this binding is changed, it will <a id="_idIndexMarker407"/>write the new value back into the <strong class="source-inline">f</strong> variable.</p>
			<p class="callout-heading">Keeping Up to Date with Source Variables</p>
			<p class="callout">If you are binding to variables that exist outside the data binding constructor, such as in the previous example, it will also cause changes from the binding to update the original variable. If, however, you update the variable directly, it is important to inform the data binding. Call <strong class="source-inline">data.Reload()</strong> to notify the data binding that the value has changed, so that it can propagate the change event.</p>
			<h3>Get() (float64, error)</h3>
			<p>To get the current state of a <a id="_idIndexMarker408"/>data binding, simply call <strong class="source-inline">Get()</strong>. It will return the contents in one of Go's primitive data types. For a <strong class="source-inline">Float</strong> binding, this will be <strong class="source-inline">float64</strong>. If an error occurred when you accessed this value, then an error will be returned in the second parameter. Though unlikely at this stage, you will see how bindings can be combined to create more complex scenarios. There is no additional action as a result of this call.</p>
			<h3>Set(float64) error</h3>
			<p>To update the value of a binding, you<a id="_idIndexMarker409"/> must call its <strong class="source-inline">Set(val)</strong> function while passing the new value (as with the <strong class="source-inline">Get()</strong> return value, this is a primitive data type). As a result of the value changing (if the new value is different to the current state), the data binding will notify all the code that is registered with it. If an error occurred when you were setting the value, the binding notifications will not be triggered, and the error will be returned.</p>
			<p>Next, we'll look at how to request updates for changes that are occurring.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>Listening for changes</h2>
			<p>One of the key concepts in data binding<a id="_idIndexMarker410"/> is that when a value changes, any item that is bound to it will update automatically. To do this, we need a mechanism that will notify us about changes. Before we learn how widgets do this automatically, we shall explore the implementation of this so that we can create our own code that stays up to date through data binding.</p>
			<h3>Using the DataItem interface to add a listener</h3>
			<p>The core <a id="_idIndexMarker411"/>functionality of any data binding is the <strong class="source-inline">DataItem</strong> interface. Each of the binding data types shown earlier (in the <em class="italic">Supported data types</em> section) also implements this interface. The definition of <strong class="source-inline">DataItem</strong> allows us to add and remove listeners. These listeners are informed whenever a data item changes:</p>
			<p class="source-code">type DataItem interface {</p>
			<p class="source-code">    AddListener(DataListener)</p>
			<p class="source-code">    RemoveListener(DataListener)</p>
			<p class="source-code">}</p>
			<p>The definition shows how listeners are added and removed from any data item; this is how widgets can be informed of when data changes.</p>
			<p class="callout-heading">Current Values</p>
			<p class="callout">When adding a listener to a <strong class="source-inline">DataItem</strong>, it will immediately be called with the current value stored. This enables any widget or program fragment that uses binding to be initialized correctly without additional code.</p>
			<p>In this section, we saw that listeners are of the <strong class="source-inline">DataListener</strong> type. We shall explore what this type is in more detail in the next section.</p>
			<h3>Creating a DataListener</h3>
			<p>Each <a id="_idIndexMarker412"/>listener of a <strong class="source-inline">DataItem</strong> must implement the <strong class="source-inline">DataListener</strong> interface. By constructing a type that conforms to this definition, we can add, and later remove, the listener from the data items we depend on. It is defined as follows:</p>
			<p class="source-code">type DataListener interface {</p>
			<p class="source-code">    DataChanged()</p>
			<p class="source-code">}</p>
			<p>As you can see, a single function is defined by the interface, <strong class="source-inline">DataChanged()</strong>. In most situations, the code that's using this will want to simply provide the function directly. For situations such as these, we can use a helpful constructor function that takes a simple function <a id="_idIndexMarker413"/>and returns an instance of a <strong class="source-inline">DataListener</strong>. The resulting listener can be used as a parameter of the <strong class="source-inline">AddListener</strong> and <strong class="source-inline">RemoveListener</strong> functions. It will call the function that was specified when the data is updated:</p>
			<p class="source-code">func NewDataListener(fn func()) DataListener</p>
			<p>Using this knowledge, we can create a very simple data binding and watch for changes in its value. All we need to do is use one of the data binding constructors and call <strong class="source-inline">AddListener</strong>, passing the listener we created:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     val := binding.NewString()</p>
			<p class="source-code">     callback := binding.NewDataListener(func() {</p>
			<p class="source-code">         str, _ := val.Get()</p>
			<p class="source-code">         fmt.Println("String changed to:", str)</p>
			<p class="source-code">     })</p>
			<p class="source-code">     val.AddListener(callback)</p>
			<p class="source-code">}</p>
			<p>By running the preceding code, you will see that the callback is fired immediately with the current string value (in this case, the zero string, <strong class="source-inline">""</strong>). </p>
			<p>Depending on your computer speed, you may need to put a time delay at the end of the <strong class="source-inline">main()</strong> function as the application could exit before the data binding is processed (for example, <strong class="source-inline">time.Sleep(time.Millisecond*100)</strong>):</p>
			<p class="source-code">Chapter06$ go run listen.go </p>
			<p class="source-code">String changed to:</p>
			<p>As shown in the preceding code, it is simple to create a data binding and be notified when the data changes. We could also trigger a change by calling <strong class="source-inline">val.Set("new data")</strong>, and the callback would trigger again.</p>
			<p>Despite the <a id="_idIndexMarker414"/>preceding code being useful, the main usage for data bindings in Fyne is to connect widgets to data without having to write code that will copy information and watch for changes. Next, we'll learn how standard widgets operate with data bindings.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>Using data with standard widgets</h2>
			<p>As we saw in the<a id="_idIndexMarker415"/> previous section, the data binding API allows <a id="_idIndexMarker416"/>us to create values that provide notifications when their content changes. As you might expect, the widgets provided in the Fyne toolkit understand bindings and can connect to them to display or update data. Let's explore how this can be set up:</p>
			<ol>
				<li>We start by opening a new file in <strong class="source-inline">package main</strong> and creating a <strong class="source-inline">makeUI()</strong> function, as we have done previously. This time, we'll start the method by declaring a new floating-point number as our data binding. Using <strong class="source-inline">NewFloat()</strong> will create a new binding that defaults to the zero value of <strong class="source-inline">0.0</strong>:<p class="source-code">func makeUI() fyne.CanvasObject {</p><p class="source-code">    f := binding.NewFloat()</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Next, we will create a <strong class="source-inline">ProgressBar</strong> widget that is bound to this data source. This progress bar simply displays a value that<a id="_idIndexMarker417"/> is a <strong class="bold">one-way binding</strong> – it only reads the data. To connect the bar to the <strong class="source-inline">Float</strong> data type we just created, we must use the <strong class="source-inline">NewProgressBarWithData()</strong> constructor function:<p class="source-code">    prog := widget.NewProgressBarWithData(f)</p></li>
				<li>To manipulate the data binding, we also want to <a id="_idIndexMarker418"/>include a <strong class="bold">two-way binding</strong> widget. For this example, we will use a <strong class="source-inline">Slider</strong>. As you saw in <em class="italic">, Widget Library and Themes</em>, this widget will display a value, using its current position, and allows the value to be changed by sliding. To set up this connection, we will use <strong class="source-inline">NewSliderWithData()</strong>, which takes additional parameters; that is, the permitted minimum and maximum values that can be sent into the data binding. We must then set the <strong class="source-inline">Slider.Step</strong> value (the gap between each step on the slider) to <strong class="source-inline">0.01</strong> so that we can cause fine-grained data changes:<p class="source-code">    slide := widget.NewSliderWithData(0, 1, f)</p><p class="source-code">    slide.Step = 0.01</p></li>
				<li>In addition to the<a id="_idIndexMarker419"/> preceding one-way and two-way bindings, we <a id="_idIndexMarker420"/>can also use a version of one-way binding that is <em class="italic">write-only</em>. We do not need to connect the data to the widget in the same way we connected the last two widgets here (because there is no need for a listener for data changes). Instead, we can simply create a <strong class="source-inline">Button</strong> that will write to the data binding when tapped. We'll use the familiar <strong class="source-inline">NewButton()</strong> constructor function here and pass in the tapped handler, which will set the value to <strong class="source-inline">0.5</strong>:<p class="source-code">    btn := widget.NewButton("Set to 0.5", func() {</p><p class="source-code">        _ = f.Set(0.5)</p><p class="source-code">    })</p></li>
				<li>The final line in our <strong class="source-inline">makeUI</strong> function will be returning the container that packs these elements in. In this case, we will use <strong class="source-inline">container.NewVBox</strong>, which aligns each element on top of the others:<p class="source-code">    return container.NewVBox(prog, slide, btn)</p></li>
				<li>To complete this example, we just need to create the usual <strong class="source-inline">main()</strong> function that creates a new <strong class="source-inline">App</strong> instance and open a window titled <strong class="source-inline">Widget Binding</strong>. The content from our <strong class="source-inline">makeUI</strong> function will be added and the relevant window will appear. Refer to the following code:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("Widget Binding")</p><p class="source-code">    w.SetContent(makeUI())</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>You can now run this example to see how these widgets behave when they're all bound to the same data source:<p class="source-code"><strong class="bold">Chapter06$ go run widget.go</strong></p></li>
				<li>When the <a id="_idIndexMarker421"/>application appears, the slider and progress <a id="_idIndexMarker422"/>bar will be at the zero position. By dragging the slider, you will update the float that the slider and progress bar are bound to. As a result, you will notice that the progress bar moves. If you press the <strong class="bold">Set to</strong> <strong class="bold">0.5</strong> button, it will set the value to <strong class="bold">0.5</strong>, and the other widgets will both update to the halfway position, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_6.1_B16820.jpg" alt="Figure 6.1 - Data bindings set to 0.5&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 - Data bindings set to 0.5</p>
			<p>In this section, we have seen the benefits of data binding for handling dynamic data, as well as the constraints of a strongly-typed API. Next, we will look at how to convert between types so that the data can be adapted for use in a wider variety of widgets.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor174"/>Adapting data types for display</h1>
			<p>In the example we worked<a id="_idIndexMarker423"/> through in the previous section, we learned that it's possible to bind the same value to different widgets since both <strong class="source-inline">Slider</strong> and <strong class="source-inline">ProgressBar</strong> expect a <strong class="source-inline">Float</strong> value for their data. However, it is not always the case that these data types will align perfectly. Sometimes, we will need to perform conversions to connect to the widgets we wish to use. In this section, we will explore how to do so, starting with how we can include a label in the preceding example.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>Formatting types into strings</h2>
			<p>In many <a id="_idIndexMarker424"/>applications, it is common to use a <strong class="source-inline">Label</strong> or other string-based <a id="_idIndexMarker425"/>display to contain information in another format, such as an <strong class="source-inline">int</strong> or <strong class="source-inline">float64</strong>. With data bindings, this is no different, so the <strong class="source-inline">binding</strong> package provides conversion functions that can make this adaptation easy.</p>
			<p>To follow on from the previous example, we could include a <strong class="source-inline">Label</strong> that displays the <strong class="source-inline">float64</strong> value, but to do so, we would need a <strong class="source-inline">String</strong> binding rather than a <strong class="source-inline">Float</strong>. To obtain this, we can use the <strong class="source-inline">FloatToString</strong> function in the binding package. Like all binding conversion functions, this takes a single parameter, the source binding, and returns a new binding that is of the correct type:</p>
			<p class="source-code">strBind := binding.FloatToString(f)</p>
			<p class="source-code">label := widget.NewLabelWithData(strBind)</p>
			<p>Using the string binding we just obtained, we can then create a <strong class="source-inline">Label</strong>, as shown in the previous code fragment. This approach will render the value using a default format. In the case of a <strong class="source-inline">Float</strong> binding, this will use the <strong class="source-inline">"%f"</strong> format string, which is similar to <strong class="source-inline">fmt.Printf</strong> in terms of usage. If we want to specify our own format, perhaps with some leading text, we can do so using the <strong class="source-inline">ToStringWithFormat</strong> notation instead:</p>
			<p class="source-code">strBind := binding.FloatToStringWithFormat(f,</p>
			<p class="source-code">    "Value is: %0.2f")</p>
			<p class="source-code">label := widget.NewLabelWithData(strBind)</p>
			<p>When using this updated code, the output label will contain text such as <strong class="source-inline">Value</strong> <strong class="source-inline">is:</strong> <strong class="source-inline">0.50</strong>, which is probably more meaningful to the users of your app. When specifying a format, be sure to include the appropriate format string for the source type, such as <strong class="source-inline">%f</strong> for <strong class="source-inline">Float</strong> or <strong class="source-inline">%d</strong> for <strong class="source-inline">Int</strong>.</p>
			<p>Although <a id="_idIndexMarker426"/>displaying a value that is not a string is by far the most <a id="_idIndexMarker427"/>common conversion requirement, we may need to access a variable of some number type that is stored in a string. We'll explore this next.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/>Parsing values from the string type</h2>
			<p>In some <a id="_idIndexMarker428"/>cases, the data you are working with may not be in <a id="_idIndexMarker429"/>the desired format for the widgets you wish to use. When managing the conversion manually, you can do this as part of your own code – simply extract the data, convert it, and then supply the parsed information to your widget. However, with data binding, we want to keep a direct connection to the source data, which means conversion needs to happen within the chain of data binding.</p>
			<p>Just like in the previous section, there are convenience methods that can help with this as well; they typically contain the phrase <strong class="source-inline">StringTo</strong> in their name. Let's work with an example that has a <strong class="source-inline">string</strong> value that contains an <strong class="source-inline">int</strong> number. We don't want to include manual code in the conversion, so we need to include a conversion in the chain, as illustrated here:</p>
			<p class="source-code">val := "5"</p>
			<p class="source-code">strBind := binding.BindString(&amp;val)</p>
			<p class="source-code">intBind := binding.StringToInt(strBind)</p>
			<p>As a result of this code, we have <strong class="source-inline">binding.Int</strong> that is reading the underling <strong class="source-inline">string</strong> data source and can now be used where a widget requires an <strong class="source-inline">Int</strong> as its data source.</p>
			<p>This is a trivial example. Normally, when a number is stored as a string, it is because the value has some non-number element to it, such as a percentage that will include the trailing <strong class="source-inline">%</strong> symbol. When there is extra formatting in the string, we can still achieve the same outcome by using the <strong class="source-inline">StringToIntWithFormat</strong> version of the conversion, as follows:</p>
			<p class="source-code">val := "5%" </p>
			<p class="source-code">strBind := binding.BindString(&amp;val) </p>
			<p class="source-code">intBind := binding.StringToIntWithFormat(strBind, "%d%%")</p>
			<p>Notice that, in the<a id="_idIndexMarker430"/> format string, we needed to use a double percent to <a id="_idIndexMarker431"/>capture the percent symbol (<strong class="source-inline">%%</strong>). This is due to how the format strings work, but otherwise, this example is quite straightforward. Calling <strong class="source-inline">intBind.Get()</strong> will return <strong class="source-inline">5</strong> (with no error), and if the <strong class="source-inline">strBind</strong> value were to be changed to <strong class="source-inline">25%</strong>, then <strong class="source-inline">IntBind.Get()</strong> would return <strong class="source-inline">25</strong>, as expected.</p>
			<p>In this section, we managed to use data binding conversion functions to change source data into a different type of data so that it can be used in our user interface. Next, we will learn how to make sure that changes in the output (for a two-way binding) are propagated to the original data.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/>Propagating changes through conversions</h2>
			<p>In the examples provided<a id="_idIndexMarker432"/> in the preceding section, we looked at complex chains of data binding so that we can convert source data for display purposes. This makes it much easier to use a variety of widgets connected to data binding without needing to write complex conversion code. However, we need to ensure that changes in the presented data are pushed back to the data source.</p>
			<p>The great news here is that the conversions demonstrated in the <em class="italic">Formatting types into string</em> and <em class="italic">Parsing values from the string type</em> sections are full two-way data bindings. This means that we do not need to add any further code to propagate changes in the data. If an <strong class="source-inline">IntToString</strong> connection is made, then changes to the source <strong class="source-inline">Int</strong> will not only result in new values in the output <strong class="source-inline">String</strong>, but calling <strong class="source-inline">Set()</strong> on our <strong class="source-inline">String</strong> will cause a parsed integer to be pushed back to the original <strong class="source-inline">Int</strong> binding. This will depend on the string <a id="_idIndexMarker433"/>being correctly formatted, of course – setting an invalid value will not propagate a change it will return an error instead.</p>
			<p>The types we've explored in this section are used by standard widgets to display and manage dynamic data. In many applications, however, we have more complex data. In the next section, we will explore how to bind such data to our apps.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor178"/>Binding complex data types</h1>
			<p>The types that we have <a id="_idIndexMarker434"/>used in our data binding exploration so far have been limited to mappings of the Go primitive types. This means that they represent simple variables with a single element. For many applications, it will be necessary to display more complex data, such as lists, maps, or even custom structs. In this section, we will look at how that can be done, starting with the <strong class="source-inline">DataList</strong> type.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Using lists of data</h2>
			<p>Whether you wish to use <a id="_idIndexMarker435"/>data bindings to present data to a <strong class="source-inline">widget.List</strong> or a <strong class="source-inline">widget.RadioGroup</strong>, or if you are modeling your data with bindings that will be passed to your own widgets, the concept of a data list will be important. The data binding API defines <strong class="source-inline">DataList</strong> as a binding that provides additional <strong class="source-inline">Length</strong> and <strong class="source-inline">GetItem(int)</strong> functions, as follows:</p>
			<p class="source-code">type DataList interface {</p>
			<p class="source-code">    DataItem</p>
			<p class="source-code">    GetItem(int) DataItem</p>
			<p class="source-code">    Length() int</p>
			<p class="source-code">}</p>
			<p>This generic definition means that a list can encapsulate a data type – the <strong class="source-inline">DataItem</strong> instance returned by <strong class="source-inline">GetItem()</strong> could be a <strong class="source-inline">String</strong>, <strong class="source-inline">Int</strong>, or even another <strong class="source-inline">DataList</strong>. You can implement a <strong class="source-inline">DataList</strong> using the previous interface or you can use one of the type-based lists provided by Fyne. The <strong class="source-inline">Length</strong> method will always return the number of items in this list, while <strong class="source-inline">GetItem</strong> can be used to access the data binding at the specified index (as lists are ordered).</p>
			<p>Changes in the list's length (through <strong class="source-inline">append</strong>, <strong class="source-inline">insert</strong>, or <strong class="source-inline">remove</strong>) will trigger a callback on any listeners that are registered on the <strong class="source-inline">DataList</strong>. If the value of one of the items changes, it will trigger the change listener on the individual item rather than the containing list. Because of this, we can be clever about minimizing the impact of UI changes when a<a id="_idIndexMarker436"/> listener calls our code. We'll see how this process works in the following sections when we use a <strong class="source-inline">StringList</strong> to manage many items presented in a <strong class="source-inline">List</strong> widget.</p>
			<h3>Creating a list</h3>
			<p>Although a list<a id="_idIndexMarker437"/> can contain items of many different types, they will usually have all items of the same type, such as <strong class="source-inline">String</strong> or <strong class="source-inline">Float</strong>. For this purpose, there are helpful constructor functions, such as <strong class="source-inline">NewFloatList</strong> and <strong class="source-inline">BindStringList</strong>. You can build a new list with no content using the <strong class="source-inline">New...List</strong> methods, or you can bind to an existing slice in your Go code using <strong class="source-inline">Bind...List</strong> functions. For example, an empty string list might look as follows:</p>
			<p class="source-code">strings := binding.NewStringList()</p>
			<p class="source-code">fmt.Println("String list length:", strings.Length())</p>
			<p class="source-code">strings.Append("astring")</p>
			<p class="source-code">fmt.Println("String list length:", strings.Length())</p>
			<p class="source-code">val, _ := strings.GetValue(0)</p>
			<p class="source-code">fmt.Println("String at 0:", val)</p>
			<p>Running this code will display the following output:</p>
			<p class="source-code"><strong class="bold">String list length: 0</strong></p>
			<p class="source-code"><strong class="bold">String list length: 1</strong></p>
			<p class="source-code"><strong class="bold">String at 0: astring</strong></p>
			<p>Here, you can see that the standard lists provide additional <strong class="source-inline">GetValue</strong> and <strong class="source-inline">SetValue</strong> methods, to access values just like the standard singular bindings. There are also matching <strong class="source-inline">Get</strong> and <strong class="source-inline">Set</strong> methods that allow you to change the whole list. This allows us to use the primitive types to access and apply data when the list type is known. We can also do the same using a slice for storage that the data binds to:</p>
			<p class="source-code">src := []string{"one"}</p>
			<p class="source-code">strings := binding.BindStringList(&amp;src) </p>
			<p class="source-code">fmt.Println("String list length:", strings.Length()) </p>
			<p class="source-code">strings.Append("astring") </p>
			<p class="source-code">fmt.Println("String list length:", strings.Length()) </p>
			<p class="source-code">val, _ := strings.GetValue(0)</p>
			<p class="source-code">fmt.Println("String at 0:", val)</p>
			<p>Running this code <a id="_idIndexMarker438"/>will result in the following output:</p>
			<p class="source-code"><strong class="bold">String list length: 1</strong></p>
			<p class="source-code"><strong class="bold">String list length: 2</strong></p>
			<p class="source-code"><strong class="bold">String at 0: one</strong></p>
			<p>Now that we have created a list binding, we can use it to display data in a widget that uses <strong class="source-inline">DataList</strong> bindings, such as <strong class="source-inline">widget.List</strong>.</p>
			<h3>Displaying a list</h3>
			<p>The most common<a id="_idIndexMarker439"/> way we will typically use a data list is through the <strong class="source-inline">List</strong> widget. When using a data binding to manage a list widget, it will automatically add rows that match the length of the data. It will grow or shrink when the length changes. Additionally, the data items in the list can be bound to the items in the list, meaning that if a data value is updated, the list will automatically update. Refer to the following code:</p>
			<p class="source-code">l := widget.NewListWithData(strings,</p>
			<p class="source-code">     func() fyne.CanvasObject {</p>
			<p class="source-code">         return widget.NewLabel("placeholder")</p>
			<p class="source-code">     },</p>
			<p class="source-code">     func(item binding.DataItem, obj fyne.CanvasObject) {</p>
			<p class="source-code">         text := obj.(*widget.Label)</p>
			<p class="source-code">         text.Bind(item.(binding.String))</p>
			<p class="source-code">     })</p>
			<p>As you can see, we use the <strong class="source-inline">NewListWithData</strong> constructor function to set data binding in the <strong class="source-inline">List</strong> widget. The first parameter, <strong class="source-inline">DataList</strong>, replaces the <strong class="source-inline">Length</strong> function, which is used in a regular <strong class="source-inline">List</strong> constructor. The second parameter, the function that sets up template items, remains the same. The callback in the last parameter for updating items is similar to a regular list, except the first parameter is now a <strong class="source-inline">DataItem</strong> instead of a <strong class="source-inline">ListItemID</strong>. We can keep the <strong class="source-inline">Text</strong> value of <strong class="source-inline">Label</strong> up to date by calling <strong class="source-inline">Bind()</strong> and passing the <strong class="source-inline">DataItem</strong> once it has been cast to the <strong class="source-inline">binding.String</strong> strong type. Applying a binding in this manner will implement the standard API, so we don't have to worry about how caching will impact this functionality.</p>
			<p>Managing lists with different types is possible, as long as you are careful when casting <strong class="source-inline">DataItem</strong> to the correct binding type on each access. Doing this is outside the scope of this chapter. In the next section, you will learn how the technique can be applied as a map of data, which <a id="_idIndexMarker440"/>typically contains many different types of values.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>Using data maps</h2>
			<p>Maps of data in the context<a id="_idIndexMarker441"/> of data binding are much like the Go <strong class="source-inline">map</strong> type, where <strong class="source-inline">string</strong> keys map to <strong class="source-inline">DataItem</strong> types; for example, <strong class="source-inline">map[string]binding.DataItem</strong>. The <strong class="source-inline">DataMap</strong> definition is similar to <strong class="source-inline">DataList</strong>, except that it uses <strong class="source-inline">string</strong> keys to identify child elements instead of an <strong class="source-inline">int</strong> ID. Instead of the <strong class="source-inline">Length()</strong> method, which returns how long the list is, it requires a <strong class="source-inline">Keys()</strong> function, which returns a string slice containing all of the keys present in the dataset. To find the number of items present in the data, you can simply call <strong class="source-inline">len(DataMap.Keys())</strong>:</p>
			<p class="source-code">type DataMap interface {</p>
			<p class="source-code">     DataItem</p>
			<p class="source-code">     GetItem(string) (DataItem, error)</p>
			<p class="source-code">     Keys() []string</p>
			<p class="source-code">}</p>
			<p>When an item is added or removed from <strong class="source-inline">DataMap</strong>, its listeners are fired. If the value of one of the items changes, it will trigger the change listener on the individual item rather than all of the DataMap listeners (as with items in a list, as mentioned in the previous section). Because maps normally have many different types of data in them, creating one using the standard API is a little different to creating a list, as we will see now. Of course, any type that implements the <strong class="source-inline">DataMap</strong> interface can be used in map data binding, but it is normally easier to use the provided implementations.</p>
			<p>We will explore how <strong class="source-inline">DataMap</strong> can be used in the following sections by creating one and setting its values before describing how they could be used for display.</p>
			<h3>Creating a data map</h3>
			<p><strong class="source-inline">DataMap</strong>, unlike <strong class="source-inline">DataList</strong>, does not have type-specific implementations within Fyne. Since maps <a id="_idIndexMarker442"/>normally contain many different types, there is only one map implementation that maps <strong class="source-inline">string</strong> keys to <strong class="source-inline">interface{}</strong> values. This can be created as a new map in memory, or by binding to an existing <strong class="source-inline">map</strong> with the <strong class="source-inline">map[string]interface{}</strong> type signature. First, let's look at creating a new map; the following code creates a new map using the <strong class="source-inline">binding.NewUntypedMap()</strong> constructor function and adds some values:</p>
			<p class="source-code">values := binding.NewUntypedMap()</p>
			<p class="source-code">fmt.Println("Map size:", len(values.Keys())) </p>
			<p class="source-code">"_ = values.SetValue("akey", 5)</p>
			<p class="source-code">fmt.Println("Map size:", len(values.Keys())) </p>
			<p class="source-code">val, _ := values.GetValue("akey")</p>
			<p class="source-code">fmt.Println("Value at akey:", val)</p>
			<p>Executing the preceding code will produce the following output:</p>
			<p class="source-code"><strong class="bold">Map size: 0</strong></p>
			<p class="source-code"><strong class="bold">Map size: 1 </strong></p>
			<p class="source-code"><strong class="bold">Value at akey: 5</strong></p>
			<p>We can do the same again but using an existing data source by making use of <strong class="source-inline">binding.BindUntypedMap()</strong> instead, as follows:</p>
			<p class="source-code">src := map[string]interface{}{"akey": "before"}</p>
			<p class="source-code">values := binding.BindUntypedMap(&amp;src)</p>
			<p class="source-code">fmt.Println("Map size:", len(values.Keys()))</p>
			<p class="source-code">_ = values.SetValue("newkey", 5)</p>
			<p class="source-code">fmt.Println("Map size:", len(values.Keys()))</p>
			<p class="source-code">val, _ := values.GetValue("akey")</p>
			<p class="source-code">fmt.Println("Value at akey:", val) </p>
			<p>Executing the preceding code<a id="_idIndexMarker443"/> will produce the following output: </p>
			<p class="source-code"><strong class="bold">Map size: 1</strong></p>
			<p class="source-code"><strong class="bold">Map size: 2</strong></p>
			<p class="source-code"><strong class="bold">Value at akey: before</strong></p>
			<p>The preceding samples do not check for data types, but if you are sure of the type for a key, you can perform type assertions like with a list. For example <strong class="source-inline">values.GetItem("key").(Float)</strong> would return a float data binding to the float64 stored at the specified key. Let us now look at how this can be used for display.</p>
			<h3>Displaying a map</h3>
			<p>At the time of writing, there are no<a id="_idIndexMarker444"/> built-in widgets that make use of the <strong class="source-inline">DataMap</strong> binding type. Its main usage is to allow your application to maintain many data bindings in a single binding type. </p>
			<p>It is expected that both the <strong class="source-inline">Form</strong> and <strong class="source-inline">Table</strong> widgets will add support for data binding in the near future. You can check out the latest API updates on the developer website at <a href="https://developer.fyne.io/api/widget.html">https://developer.fyne.io/api/widget.html</a>.</p>
			<p>Before we leave this section, we will explore one last trick – mapping a custom <strong class="source-inline">struct</strong> to a <strong class="source-inline">DataMap</strong>.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>Mapping structs to a data binding</h2>
			<p>When populating<a id="_idIndexMarker445"/> data in a <strong class="source-inline">DataMap</strong>, one of the common ways to do so<a id="_idIndexMarker446"/> would be by using a <strong class="source-inline">struct</strong> type. In this situation, there are a set of fields where a name maps to a value (as we've seen many times in this book already). As you can see, this definition matches nicely to the maps that we saw in the previous section. To save a lot of manual code, the data binding API provides a simple way to automatically create a <strong class="source-inline">DataMap</strong> from an existing struct variable.</p>
			<p>Just like any other <strong class="source-inline">binding.Bind...</strong> method, we pass a pointer to the variable and it returns the bound data type. In this case, the Fyne code will use the names of each <strong class="source-inline">struct</strong> field as the keys of the map, and the values will be set to the variables of the struct. To be able to bind a field in a <strong class="source-inline">struct</strong>, it must be an exported field (the name must start with an uppercase letter). The following code demonstrates this principle:</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">     Name string</p>
			<p class="source-code">     Age int</p>
			<p class="source-code">}</p>
			<p class="source-code">src := person{Name: "John Doe", Age: 21}</p>
			<p class="source-code">values := binding.BindStruct(&amp;src)</p>
			<p class="source-code">fmt.Println("Map size:", len(values.Keys()))</p>
			<p class="source-code">name, _ := values.GetValue("Name")</p>
			<p class="source-code">fmt.Println("Value for Name:", name)</p>
			<p class="source-code">age, _ := values.GetValue("Age")</p>
			<p class="source-code">fmt.Println("Value for Age:", age)</p>
			<p>Running the preceding code will produce the following output:</p>
			<p class="source-code"><strong class="bold">Map size: 2 </strong></p>
			<p class="source-code"><strong class="bold">Value for name: John Doe </strong></p>
			<p class="source-code"><strong class="bold">Value for age: 21</strong></p>
			<p>As you can see, the <a id="_idIndexMarker447"/>keys and values all work as expected, but with the<a id="_idIndexMarker448"/> benefit that widgets can observe changes that have been made to the data and keep their display updated.</p>
			<p>Now that we have explored how data bindings can easily handle how dynamic data is displayed, we shall look at how to store user-generated data using the Preferences API.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>Storing data using the Preferences API</h1>
			<p>It is a common <a id="_idIndexMarker449"/>requirement for applications to store many pieces<a id="_idIndexMarker450"/> of information, such as user configuration options, current input field contents, and a history of opened files. Using files to store this information would require additional code to format the information for storage; using a database would require additional servers or dependencies for an application. To help with this, Fyne provides a <strong class="bold">Preferences</strong> API, similar to those used by iOS and Android developers.</p>
			<p>Data that is stored as Fyne preferences can be accessed by any code in an application using a specific string identifier, known as a <strong class="bold">key</strong>. Each <strong class="bold">value</strong> that is stored has a specific type, so developers do not have to handle any conversion or type checking. Any time that this data changes, it will be saved for future use.</p>
			<p>In this section, we'll learn how to manage data using the Preferences API and see how we can avoid having to manually manage user data.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>Get and set values</h2>
			<p>Each supported type (see the following section) provides functions so that we can get and set data of that <a id="_idIndexMarker451"/>type. We will explore this using a string. To read or write<a id="_idIndexMarker452"/> data using a string, we can use the <strong class="source-inline">String()</strong> function; to write a value, we can use <strong class="source-inline">SetString()</strong>.</p>
			<p>To gain access to the preferences, we can use <strong class="source-inline">App.Preferences()</strong>. If you do not have access to the <strong class="source-inline">App</strong> instance that loaded the application, you can use <strong class="source-inline">fyne.CurrentApp().Preferences()</strong> instead, which will return the same reference. There is an additional requirement, however – each application must declare a unique identifier for use in storage. To do this, we must change the <strong class="source-inline">app.New()</strong> constructor function to <strong class="source-inline">app.NewWithID()</strong>, passing <a id="_idIndexMarker453"/>a suitable unique identifier. Typically, the unique ID will be in reverse DNS format, and must match the identifier you will use during distribution (see <a href="B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219"><em class="italic">Chapter 9</em></a>, <em class="italic">Bundling Resources and Preparing for Release,</em> for more details). For example, you can use <strong class="source-inline">com.example.myapp</strong> for testing purposes.</p>
			<p>The following code snippet sets up an application with a (relatively) unique identifier and accesses the standard preferences:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    a := app.NewWithID("com.example.preferences")</p>
			<p class="source-code">    key := "demokey"</p>
			<p class="source-code">    a.Preferences().SetString(key, "somevalue")</p>
			<p class="source-code">    val := a.Preferences().String(key)</p>
			<p class="source-code">    fmt.Println("Value is:", val)</p>
			<p class="source-code">}</p>
			<p>We can insert the <a id="_idIndexMarker454"/>preceding code into the usual <strong class="source-inline">main()</strong> function (for a more complete listing, please go to the <em class="italic">Implementing a water consumption tracker</em> section). Notice that we used a single <strong class="source-inline">string</strong> value for the key – this helps us avoid making mistakes if typing  out the key for each access. Running it will produce the following output:</p>
			<p class="source-code"><strong class="bold">Value is: somevalue</strong></p>
			<p>This quick example demonstrates string access, but there are other types we can use as well. We'll look at some of these in the next section.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor184"/>Supported types</h2>
			<p>It's possible to store any type of <a id="_idIndexMarker455"/>data using just the string methods illustrated, but the API is designed to help us avoid the complexities of formatting and parsing data in that way. Due to this, there are different types supported by the Fyne preferences code. At the time of writing, the supported types are as follows:</p>
			<ul>
				<li><strong class="source-inline">bool</strong>: Stores a simple<a id="_idIndexMarker456"/> boolean (<strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>) value.</li>
				<li><strong class="source-inline">float</strong>: Numbers that need a floating-point value can be stored using a <strong class="source-inline">float</strong>.</li>
				<li><strong class="source-inline">int</strong>: For whole numbers, use the <strong class="source-inline">int</strong> functions.</li>
				<li><strong class="source-inline">string</strong>: As we used previously, a simple <strong class="source-inline">string</strong> value.</li>
			</ul>
			<p>Each of these types follow the same naming convention that we saw in the previous code. For example, you could set an integer using <strong class="source-inline">SetInt()</strong> or get a boolean value using <strong class="source-inline">Bool()</strong>.</p>
			<p>By using Go semantics, the values that are returned will have zero values if no item was previously stored. It is possible to set different defaults using fallback values.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>Fallback values</h2>
			<p>For situations where the default value of a property should not be the standard zero value (defined by Go), each <strong class="source-inline">Get...</strong> function has a <strong class="source-inline">WithFallback</strong> version; for example, <strong class="source-inline">StringWithFallback()</strong>.</p>
			<p>If we change the code in the previous<a id="_idIndexMarker457"/> example so that it just uses the get and fallback methods, we can see how they work:</p>
			<p class="source-code">    key := "anotherkey"</p>
			<p class="source-code">    val := a.Preferences().String(key)</p>
			<p class="source-code">    fmt.Println("Value is:", val)</p>
			<p class="source-code">    val = a.Preferences().StringWithFallback(key, "missing")</p>
			<p class="source-code">    fmt.Println("Value is:", val)</p>
			<p>Running this version of the code will produce the following output:</p>
			<p class="source-code"><strong class="bold">Value is: </strong></p>
			<p class="source-code"><strong class="bold">Value is: missing</strong></p>
			<p>With these methods, we can<a id="_idIndexMarker458"/> handle data with sensible defaults and save changes for future runs of the application. Sometimes, we will need to remove old data; we can do that too.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor186"/>Removing old data</h2>
			<p>Storing data for users is important, but<a id="_idIndexMarker459"/> so is the ability to delete it when requested. To do so, the Preferences API provides one final method, <strong class="source-inline">RemoveValue</strong>, that will do just that. </p>
			<p>By adding the following code to the end of our previous example, the values that were set will be cleaned out, meaning that on the next run, you will see the default values if the application is started a second time:</p>
			<p class="source-code">    fmt.Println("Removing")</p>
			<p class="source-code">    a.Preferences().RemoveValue(key)</p>
			<p class="source-code">    val = a.Preferences().String(key)</p>
			<p class="source-code">    fmt.Println("Value is:", val)</p>
			<p>The preceding code also prints out the value once it has completed, ensuring that the item has been removed from the preferences. Running all the code from this section together will produce the following output:</p>
			<p class="source-code"><strong class="bold">Chapter06$ go run preferences.go</strong></p>
			<p class="source-code"><strong class="bold">Value is: </strong></p>
			<p class="source-code"><strong class="bold">Value is: missing</strong></p>
			<p class="source-code"><strong class="bold">Value is: somevalue</strong></p>
			<p class="source-code"><strong class="bold">Removing</strong></p>
			<p class="source-code"><strong class="bold">Value is:</strong></p>
			<p>With that, we have seen how we can trivially store and access elements of data to be used in our apps. However, the Preferences API becomes even more powerful when we combine it with the data binding API we saw at the beginning of this chapter.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Binding to preferences</h2>
			<p>With the <strong class="source-inline">binding</strong> package, which <a id="_idIndexMarker460"/>we focused on earlier in this chapter, we can create data bindings that are connected to preference storage instead of regular variables. This provides us with the huge benefit that any time the setting of a value is triggered, it will be stored, and when the application is started again, the previous value will be loaded.</p>
			<p>To access this functionality, we can use the functions whose names start with <strong class="source-inline">BindPreference</strong>, such as <strong class="source-inline">BindPreferenceString()</strong>. There is one function for each of the types supported by the Preference API, as listed earlier in this section. Each of these methods accepts a string parameter, which is the key string that we used in the previous code excerpts. Code that wishes to continue using the Preferences API can continue to do so as before, but using these data bindings ensures that new values are pushed directly to the widget that the binding is connected to. The bindings that are returned from a preferences bind use the same types as other data binding APIs, so you can get the <strong class="source-inline">string</strong> value of a<a id="_idIndexMarker461"/> preference item through its binding using <strong class="source-inline">Get()</strong>, as you might expect:</p>
			<p class="source-code">data := binding.BindPreferenceString("demokey",                  	    a.Preferences())</p>
			<p class="source-code">val, _ = data.Get()</p>
			<p class="source-code">fmt.Println("Bound value:", val)</p>
			<p>The preceding code will access the same preferences value but through the data binding framework, making it easy to keep widgets up to date with user preferences. The output will be as follows:</p>
			<p class="source-code"><strong class="bold">Chapter06$ go run preferences.go</strong></p>
			<p class="source-code"><strong class="bold">Bound value: somevalue</strong></p>
			<p>These bindings can also be chained, as with the earlier definitions, which means you can obtain a <strong class="source-inline">String</strong> binding to a preference value that is an integer by doing the following:</p>
			<p class="source-code">binding.IntToString(binding.BindPreferenceInt("mykey", p))</p>
			<p>It is also possible to have multiple widgets, connected to multiple data bindings, all read and write the same preference value. If you use the same key to create many bindings to a preference, then they will all stay up to date when the value changes. We will see this in action in the example that follows.</p>
			<p>With that, we have explored the data binding and Preference APIs and how they can, individually or together, vastly reduce the amount of code required to manage data in an application. Let's utilize this knowledge and implement an example application that can help us track our daily water consumption.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor188"/>Implementing a water consumption tracker</h1>
			<p>The<a id="_idIndexMarker462"/> APIs that we have explored in this chapter can be helpful for most applications. To learn how we can add preference storage to a simple application, we will explore another example project. This time, we will create a tracker that can track water consumption over 1 week.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/>Constructing the user interface</h2>
			<p>Before we start <a id="_idIndexMarker463"/>working with data binding APIs, we will construct the basic user interface. The aim is to put today's total in large text at the top of a window, with the date below. We will follow this with the controls to add water to the current total. Under this, we will add another section that shows the values for the current week. Let's get started:</p>
			<ol>
				<li value="1">We will start, as usual, by defining a <strong class="source-inline">makeUI</strong> function, which builds the user interface. To start, we will define the large label that will be used to show the total by setting the font to <strong class="source-inline">42</strong> points, center aligning it, and using the <strong class="source-inline">theme</strong> primary color:<p class="source-code">func makeUI() fyne.CanvasObject {</p><p class="source-code">    label := canvas.NewText("0ml", theme.PrimaryColor())</p><p class="source-code">    label.TextSize = 42</p><p class="source-code">    label.Alignment = fyne.TextAlignCenter</p></li>
				<li>Now, we need to create another, regular label for the date to be displayed:<p class="source-code">    date := widget.NewLabel("Mon 9 Nov 2020")</p><p class="source-code">    date.Alignment = fyne.TextAlignCenter</p></li>
				<li>The next few elements add controls, that support adding a value to the current water consumption. This could be a button that simply adds a specific number (for example, <em class="italic">250 ml</em>), but to be more flexible, we will allow the user to specify an amount. To do this, we will create an <strong class="source-inline">Entry</strong> field that is pre-filled with <strong class="source-inline">250</strong>. Then, we will add a helper <strong class="source-inline">ml</strong> label after it and define a new button, labeled <strong class="source-inline">Add</strong>, that will action this later:<p class="source-code">    amount := widget.NewEntry()</p><p class="source-code">    amount.SetText("250")</p><p class="source-code">    input := container.NewBorder(nil, nil,</p><p class="source-code">        nil, widget.NewLabel("ml"), amount)</p><p class="source-code">    add := widget.NewButton("Add", func() {})</p></li>
				<li>Before creating the <a id="_idIndexMarker464"/>history layout we define a helpful <strong class="source-inline">historyLabel</strong> function. This will create a new label that simply contains <strong class="source-inline">0ml</strong> and aligns it to the right. The data here will be added later.<p class="source-code">func historyLabel() fyne.CanvasObject {</p><p class="source-code">    num := widget.NewLabel("0ml")</p><p class="source-code">    num.Alignment = fyne.TextAlignTrailing</p><p class="source-code">    return num</p><p class="source-code">} </p></li>
				<li>The last content element we'll add is the history information. In this case, we can construct this using a grid container with two columns. On the left, we will show the day of the week, while on the right, we will show a label for the value:<p class="source-code">    history := container.NewGridWithColumns(2,</p><p class="source-code">        widget.NewLabel("Monday"), historyLabel(),</p><p class="source-code">        widget.NewLabel("Tuesday"), historyLabel(),</p><p class="source-code">        widget.NewLabel("Wednesday"), historyLabel(),</p><p class="source-code">        widget.NewLabel("Thursday"), historyLabel(),</p><p class="source-code">        widget.NewLabel("Friday"), historyLabel(),</p><p class="source-code">        widget.NewLabel("Saturday"), historyLabel(),</p><p class="source-code">        widget.NewLabel("Sunday"), historyLabel(),</p><p class="source-code">    )</p></li>
				<li>To return the result of our interface building from this function, we can create a new vertical box. Inside this box, we must stack the total <strong class="source-inline">label</strong>, <strong class="source-inline">date</strong>, a horizontal grid that aligns the <strong class="source-inline">input</strong> and the <strong class="source-inline">add</strong> button, and lastly a <strong class="source-inline">Card</strong> widget containing the history content, along with a header.<p class="source-code">    return container.NewVBox(label, date,</p><p class="source-code">        container.NewGridWithColumns(2, input, add),</p><p class="source-code">        widget.NewCard("History", "Totals this week",</p><p class="source-code">            history))</p><p class="source-code">}</p></li>
				<li>For this example to run, we <a id="_idIndexMarker465"/>must create the typical <strong class="source-inline">main()</strong> function. This time, we want it to create a window titled <strong class="source-inline">Water Tracker</strong> and set the <strong class="source-inline">makeUI()</strong> return to the content before showing it:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("Water Tracker")</p><p class="source-code">    w.SetContent(makeUI())</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>We can now run this example in the usual way from the command line:<p class="source-code"><strong class="bold">Chapter06/example$ go run main.go</strong></p></li>
			</ol>
			<p>Running the preceding command should result in the following interface appearing (when using the light theme):</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Figure_6.2_B16820.jpg" alt="Figure 6.2 – The empty user interface"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – The empty user interface</p>
			<p>This interface looks suitable, but it does not do anything yet. In the next section, we'll start creating some functionality<a id="_idIndexMarker466"/> by binding the <strong class="source-inline">total</strong> label to a value that can be incremented using the <strong class="bold">Add</strong> button.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>Binding data to the UI</h2>
			<p>To start <a id="_idIndexMarker467"/>making the user interface functional, we will use data binding so that the header section of the app manages a single integer value representing how much water has been consumed in a day. Follow these steps:</p>
			<ol>
				<li value="1">First, we need to declare a new binding variable that is of the <strong class="source-inline">binding.Int</strong> type. We must add the following line to the beginning of our <strong class="source-inline">makeUI</strong> function:<p class="source-code">    total := binding.NewInt()</p></li>
				<li>Next, we will add an implementation of the button tap handling. To action the number increment, we must replace the old <strong class="source-inline">func() {}</strong> function with the following function:<p class="source-code">    func() {</p><p class="source-code">         inc, err := strconv.Atoi(amount.Text)</p><p class="source-code">         if err != nil {</p><p class="source-code">             log.Println("Failed to parse integer:" +</p><p class="source-code">                 amount.Text)</p><p class="source-code">             return</p><p class="source-code">         }</p><p class="source-code">         current, _ = total.Get()</p><p class="source-code">         _ = total.Set(current + inc)</p><p class="source-code">    }</p><p>This will parse an integer<a id="_idIndexMarker468"/> from the <strong class="source-inline">amount.</strong> <strong class="source-inline">Text</strong> field and add it to the total. It does this by calling <strong class="source-inline">Get()</strong>, which finds the current value, and then <strong class="source-inline">Set()</strong>, with the increment applied.</p></li>
				<li>Next, we want to display the integer value in a label, with <strong class="bold">ml</strong> (milliliters) added to the end. To do this, we can add a conversion that formats an integer for presentation. The following line creates a new <strong class="source-inline">String</strong> binding that is based on the <strong class="source-inline">Int</strong> function we already created:<p class="source-code">    totalStr := binding.IntToStringWithFormat(total,  	        "%dml")</p></li>
				<li>Now that we have used <strong class="source-inline">canvas.Text</strong> to define our large, colored text, we must bind these values. However, there isn't a helpful <strong class="source-inline">WithData</strong> constructor function for this, so we must apply the binding values manually. Let's create a new <strong class="source-inline">DataListener</strong> that will be called when the values change. Inside the callback, we set the text and request a refresh:<p class="source-code">    totalStr.AddListener(binding.NewDataListener(</p><p class="source-code">         func() { </p><p class="source-code">             label.Text, _ = totalStr.Get() </p><p class="source-code">             label.Refresh() </p><p class="source-code">         }))</p></li>
				<li>With these changes made, we can run the app to see the changes in action:<p class="source-code"><strong class="bold">Chapter06/example$ go run main.go</strong></p></li>
			</ol>
			<p>The user interface looks the same when it is loaded, but when we tap the <strong class="bold">Add</strong> button, the total value will update, increasing by the number by the value in the entry field:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_6.3_B16820.jpg" alt="Figure 6.3 – Showing a bound value"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Showing a bound value</p>
			<p>If you quit this version of the <a id="_idIndexMarker469"/>app and open it again, you will notice that the value is forgotten. We can fix this by using the Preferences API, which we will do now.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>Storing with preferences</h2>
			<p>To remember values<a id="_idIndexMarker470"/> between application launches, we can make use of the Preferences API. This allows us to store values without needing to manage file access or databases. In this section, we will connect our data binding to the Preferences API so that it will automatically remember the data when it changes. Follow these steps:</p>
			<ol>
				<li value="1">To be able to store preferences, we need to allocate a key for each data item. In this example, each number is the total for a day, so we will use the date to identify the stored item. We need a new function, <strong class="source-inline">dateKey</strong>, that will format a string from any given time:<p class="source-code">func dateKey(t time.Time) string {</p><p class="source-code">    return t.Format("2006-01-02") // YYYY-MM-DD</p><p class="source-code">}</p></li>
				<li>To be able to use the Preference API, we need to make sure that our application has a unique identifier. To do this, we will use <strong class="source-inline">app.NewWithID</strong> instead of <strong class="source-inline">app.New</strong>. The ID should be globally unique. Then, we need to retrieve the application <strong class="source-inline">Preferences</strong> instance and pass it into our <strong class="source-inline">makeUI</strong> function so that it can be used in the bindings:<p class="source-code">a := app.NewWithID("com.example.watertracker")</p><p class="source-code">pref := a.Preferences()</p><p class="source-code">w.SetContent(makeUI(pref)</p></li>
				<li>Next, we will update the <strong class="source-inline">Int</strong> binding so that it can access preferences instead of creating a new value in memory. We will update <strong class="source-inline">makeUI</strong> so that it accepts a preferences instance and then change our binding creation so that it uses <strong class="source-inline">BindPreferenceInt</strong>. This <a id="_idIndexMarker471"/>constructor requires the key of the value it needs to access (which is generated by the <strong class="source-inline">dateKey</strong> function we created) and the preferences instance to use:<p class="source-code">func makeUI(p fyne.Preferences) fyne.CanvasObject {</p><p class="source-code">total := binding.BindPreferenceInt(</p><p class="source-code">    dateKey(time.Now()), p)</p></li>
				<li>Since we are completing the top section of our app, we should also set the correct date. Simply change the label constructor so that it passes a formatted date string, like so:<p class="source-code">date := widget.NewLabel(time.Now().Format(</p><p class="source-code">    "Mon Jan 2 2006"))</p></li>
			</ol>
			<p>If you run the app again, you will see the same interface (with a corrected date display). If you add some value to today's total and then restart the app, you will notice that the value is remembered.</p>
			<p>With that, we have completed the basic functionality of our app, but the history fields are still blank. Building on the<a id="_idIndexMarker472"/> previous functionality, we can show the stored values from previous days.</p>
			<p>Adding history</p>
			<p>With the main data binding code <a id="_idIndexMarker473"/>working, we can add similar functionality to the history panel. We will access a preferences value for each day of the week and update the <strong class="source-inline">historyLabel</strong> function to access it. Let's see how:</p>
			<ol>
				<li value="1">The most complex part of the history panel is date handling. We will need to find out what date represents the beginning of the week. Since the time of day does not normally matter (daylight savings are not accounted for in this code), we can just manipulate the date portion. Using <strong class="source-inline">Time.Weekday()</strong>, we can find what day of the week it is and go from there. Go's <strong class="source-inline">time</strong> package expects Sunday to be the first day of the week, so we need to handle this special case by subtracting 6 days to find Monday. For all others, we subtract the length of the days (<strong class="source-inline">24 * time.Hour</strong>) since Monday. The following code will allow us to find the date for our first history element:<p class="source-code">func dateForMonday() time.Time {</p><p class="source-code">    day := time.Now().Weekday()</p><p class="source-code">    if day == time.Sunday {</p><p class="source-code">        return time.Now().Add(-1 * time.Hour * 24 * 6)</p><p class="source-code">    }</p><p class="source-code">    daysSinceMonday := time.Duration(day - 1)</p><p class="source-code">    dayLength := time.Hour * 24</p><p class="source-code">    return time.Now().Add(-1 * dayLength *</p><p class="source-code">        daysSinceMonday) // Monday is day 1</p><p class="source-code">}</p></li>
				<li>Next, we must update the <strong class="source-inline">historyLabel</strong> function, adding the date of the day in question, along with a reference to the preferences to use. From this, we can generate our <strong class="source-inline">dateKey</strong>, as we did for the total storage, and bind an <strong class="source-inline">Int</strong> value to the preferences. Then, we create another string conversion using the same format, but in this instance, we<a id="_idIndexMarker474"/> can simply use the <strong class="source-inline">NewLabelWithData</strong> constructor function:<p class="source-code">func historyLabel(date time.Time, p fyne.Preferences) fyne.CanvasObject {</p><p class="source-code">    data := binding.BindPreferenceInt(dateKey(date), p)</p><p class="source-code">    str := binding.IntToStringWithFormat(data, "%dml")</p><p class="source-code">    num := widget.NewLabelWithData(str)</p><p class="source-code">    num.Alignment = fyne.TextAlignTrailing</p><p class="source-code">    return num</p><p class="source-code">}</p></li>
				<li>Now, we can update the details of our history panel. First, we calculate the date for the Monday at the beginning of the current week, and then set a helper for the day's length, which is not part of the Go <strong class="source-inline">time</strong> package. For each history element, we pass the date for each day by incrementing by a number of days since the start of the week:<p class="source-code">weekStart := dateForMonday()</p><p class="source-code">dayLength := time.Hour * 24</p><p class="source-code">history := container.NewGridWithColumns(2,</p><p class="source-code">    widget.NewLabel("Monday"),</p><p class="source-code">        historyLabel(weekStart, p),</p><p class="source-code">    widget.NewLabel("Tuesday"),</p><p class="source-code">        historyLabel(weekStart.Add(dayLength), p),</p><p class="source-code">    widget.NewLabel("Wednesday"),</p><p class="source-code">        historyLabel(weekStart.Add(dayLength*2), p),</p><p class="source-code">    widget.NewLabel("Thursday"),</p><p class="source-code">        historyLabel(weekStart.Add(dayLength*3), p),</p><p class="source-code">    widget.NewLabel("Friday"),</p><p class="source-code">        historyLabel(weekStart.Add(dayLength*4), p),</p><p class="source-code">    widget.NewLabel("Saturday"),</p><p class="source-code">        historyLabel(weekStart.Add(dayLength*5), p),</p><p class="source-code">    widget.NewLabel("Sunday"),</p><p class="source-code">        historyLabel(weekStart.Add(dayLength*6), p),</p><p class="source-code">)</p></li>
				<li>By running this final version of the app, we will see that it updates today's value in the history panel:<p class="source-code"><strong class="bold">Chapter06/example$ go run main.go</strong></p></li>
			</ol>
			<p>The updated code will load the same<a id="_idIndexMarker475"/> interface that we had previously, but now, you will see that pressing <strong class="bold">Add</strong> will update the current day in the history panel as well:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/Figure_6.4_B16820.jpg" alt="Figure 6.4 – Our completed water tracker app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Our completed water tracker app</p>
			<p>You will see the history on this <a id="_idIndexMarker476"/>app build up over a week, as indicated in the preceding screenshot. If you want to edit the data, you can modify the preferences file directly. The preferences file's location varies, depending on your operating system. More information is available at <a href="https://developer.fyne.io/tutorial/preferences-api">https://developer.fyne.io/tutorial/preferences-api</a>.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor192"/>Summary</h1>
			<p>In this chapter, we have looked at the various APIs available within Fyne for managing and storing data. We explored the concept of data binding and saw how it can help keep a user interface up to date, while at the same time reduce the amount of code we need to write.</p>
			<p>We then looked at the Preferences API, which allows us to persist user data between application launches. When combined with the data binding code, this came with no additional complexity. By utilizing these features, we implemented an example application that manages data for tracking water consumption and stored it on our local device, ready to use the next day.</p>
			<p>With that, we have covered the most common standard widgets and functionality in the Fyne toolkit. Sometimes, an application may require widgets or features that are not included. To support this, the toolkit allows us to extend the built-in components. We will explore this in the next chapter.</p>
		</div>
	</body></html>