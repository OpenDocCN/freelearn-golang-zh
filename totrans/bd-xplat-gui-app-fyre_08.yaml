- en: '*Chapter 6*: Data Binding and Storage'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：数据绑定和存储'
- en: In the previous chapter, we learned that widgets can be controlled manually
    by application code. As we start looking at more complex applications, it's common
    for developers to want to display or manipulate a dynamic data source. The Fyne
    toolkit provides data and storage APIs that automate a lot of this work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到小部件可以通过应用程序代码手动控制。当我们开始查看更复杂的应用程序时，开发者通常希望显示或操作动态数据源。Fyne 工具包提供了数据和存储
    API，可以自动化很多这项工作。
- en: 'In this chapter, we''re going to explore the ways that data is handled within
    the Fyne toolkit. We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在 Fyne 工具包内处理数据的方式。我们将涵盖以下主题：
- en: Binding data to widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据绑定到小部件
- en: Adapting data types for display
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配数据类型以显示
- en: Binding complex data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定复杂的数据类型
- en: Storing data using the Preferences API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Preferences API 存储数据
- en: By the end of the chapter, we will know how to make use of the data binding
    and storage APIs to create an app that helps track water consumption. It will
    store information on the local device and use APIs to explore how to minimize
    the coding required to manage data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将知道如何利用数据绑定和存储 API 创建一个帮助跟踪水消耗的应用程序。它将在本地设备上存储信息，并使用 API 探索如何最小化管理数据所需的编码。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*, in that you must have the Fyne toolkit installed
    and a Go and C compiler working. For more information, please refer to the previous
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与[*第 3 章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)，“Windows、Canvas
    和绘图”相同，即您必须安装 Fyne 工具包并确保 Go 和 C 编译器正常工作。更多信息，请参阅上一章。
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06)找到。
- en: Binding data to widgets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据绑定到小部件
- en: When we explored widgets in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*, we saw how information can be gathered and presented.
    Each widget we looked at was configured manually, and accessing data that the
    user entered (such as with the `Entry` widget) required code to query the widget's
    state. The `fyne.io/fyne/data/binding` package provides functionality that supports
    automatically connecting widgets to data sources to handle this more efficiently.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第 5 章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)，“小部件库和主题”中探讨小部件时，我们看到了如何收集和展示信息。我们查看的每个小部件都是手动配置的，访问用户输入的数据（例如使用
    `Entry` 小部件）需要查询小部件的状态的代码。`fyne.io/fyne/data/binding` 包提供了支持自动将小部件连接到数据源以更高效地处理这些操作的功能。
- en: In the following sections, we will explore what data binding is, why it is so
    useful, and how it is designed within the Fyne APIs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将探讨数据绑定是什么，为什么它如此有用，以及它是如何在 Fyne API 中设计的。
- en: Understanding data binding
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数据绑定
- en: There are many different approaches to data binding, and definitions can vary,
    depending on the toolkit that you are working with. In general, data binding allows
    the component of a graphical interface to have its display controlled by a separate
    data source. Moreover, it ensures that the graphical representation is always
    up to date with changes, and that user actioned changes within the user interface
    are synchronized back to the original data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定有许多不同的方法，定义可能因您所使用的工具包而异。一般来说，数据绑定允许图形界面组件的显示由独立的数据源控制。此外，它确保图形表示始终与更改保持最新，并且用户界面中的用户操作更改会同步回原始数据。
- en: You can see how .NET approaches its implementation at [https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview).
    Android also provides similar functionality, which is documented at [https://developer.android.com/topic/libraries/data-binding](https://developer.android.com/topic/libraries/data-binding).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview)中看到
    .NET 的实现方法。Android 也提供了类似的功能，相关文档可在[https://developer.android.com/topic/libraries/data-binding](https://developer.android.com/topic/libraries/data-binding)找到。
- en: Despite the various approaches taken by each toolkit, the basics of any successful
    data binding are that the graphical output is automatically updated based on the
    state of a separate data object. This is known as **unidirectional** binding,
    often known as a *one-way data flow*. This is sufficient for data display when
    the information comes from an external source. However, it is not sufficient if
    your application will be modifying the data. Complete data binding (**two-way**
    or **bidirectional**) ensures that as well as keeping presented data up to date,
    it will also update the source data if the user alters the presentation through
    some interactive widget.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个工具包都采取了不同的方法，但任何成功的数据绑定的基本原理都是基于独立数据对象的状态自动更新图形输出。这被称为 **单向** 绑定，通常称为 *单向数据流*。当信息来自外部源时，这对于数据显示是足够的。然而，如果你的应用程序将修改数据，则这并不足够。完整的数据绑定（**双向**
    或 **双向**）确保在保持显示数据更新的同时，如果用户通过某些交互式小部件更改了表示，它也会更新源数据。
- en: All the data binding that's done in the Fyne toolkit is bidirectional, meaning
    that each connection that's made can read or write the data it is connected to.
    Widgets that are only used for display purposes will not make use of the ability
    to write the data, but an input widget such as an entry or a slider will push
    data changes out to connected bindings. There's an underlying data source for
    each data binding. We will look at what data types are supported in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fyne 工具包中完成的所有数据绑定都是双向的，这意味着每个建立的连接都可以读取或写入其连接到的数据。仅用于显示目的的小部件将不会使用写入数据的能力，但输入小部件，如输入框或滑块，会将数据更改推送到连接的绑定。每个数据绑定都有一个底层的数据源。我们将在下一节中查看支持的数据类型。
- en: Supported data types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的数据类型
- en: Just like the main Go language, all the values in the Fyne data API are strongly
    typed – this means that a data binding has a specific type of value. Each value
    matches a primitive Go type, ensuring that the compiler can check that these values
    are used in the correct way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像主要的 Go 语言一样，Fyne 数据 API 中的所有值都是强类型的——这意味着数据绑定具有特定的值类型。每个值都匹配一个原始 Go 类型，确保编译器可以检查这些值是否以正确的方式使用。
- en: 'At the time of writing, the Fyne data binding supports the following types:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Fyne 数据绑定支持以下类型：
- en: '`Bool`: A boolean value can be `true` or `false`. This type uses a `bool` for
    its internal storage.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bool`: 布尔值可以是 `true` 或 `false`。此类型使用 `bool` 作为其内部存储。'
- en: '`Float`: A floating-point number value, this uses the `float64` type for internal
    storage.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float`: 浮点数值，这使用 `float64` 类型进行内部存储。'
- en: '`Int`: A whole number value with positive and negative numbers, stored using
    the `int` type.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`: 带有正数和负数的整数值，使用 `int` 类型存储。'
- en: '`Rune`: A representation of a single unicode character, backed by the `rune`
    type.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rune`: 单个 Unicode 字符的表示，由 `rune` 类型支持。'
- en: '`String`: A bindable version of the Go `string` type.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`: Go `string` 类型的可绑定版本。'
- en: '`List`: A mapping similar to `slice` or `array` that can contain a collection
    of a single type, indexed by an `int` offset.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`: 与 `slice` 或 `array` 类似的映射，可以包含一个由 `int` 偏移量索引的单个类型的集合。'
- en: '`Map`: A bindable version of the `map` primitive that can hold many types indexed
    by a `string` key.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`: `map` 原始类型的可绑定版本，可以按 `string` 键索引存储多种类型。'
- en: '`Struct`: A data binding similar to `map` where the keys represent exported
    elements of a developer defined `struct` type.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Struct`: 与 `map` 类似的数据绑定，其中键代表开发者定义的 `struct` 类型的导出元素。'
- en: The value type you use may be determined by the source data, or (if you are
    not bound to an existing data source) the output widgets you use. We will explore
    widget connections later in this section, but it is useful to know that we can
    convert types where needed. We will explore this later in the *Adapting data types
    for display* section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的值类型可能由源数据决定，或者（如果你没有绑定到现有的数据源）你使用的输出小部件。我们将在本节的后面部分探讨小部件连接，但了解我们可以在需要时转换类型是有用的。我们将在
    *适应显示数据类型* 部分后面探讨这一点。
- en: When you have more complex data, such as a list or struct, you can still use
    the data binding API but with more advanced types, as discussed later in the *Binding
    complex data types* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有更复杂的数据，例如列表或结构体时，你仍然可以使用数据绑定 API，但需要更高级的类型，这将在后面的 *绑定复杂数据类型* 部分讨论。
- en: Now that we've learned what data types are available, let's look at how to read
    and write data through a binding.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可用的数据类型，让我们看看如何通过绑定来读取和写入数据。
- en: Creating, reading, and writing bound data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建、读取和写入绑定数据
- en: 'Each of the basic data types provided by the binding API (`Bool`, `Float`,
    `Int`, `Rune`, and `String`) provide two constructors: one that creates a new
    variable from the Go zero value (using the `New...()` name), and another that
    binds to an existing variable (named `Bind...()`). It also provides `Get()` and
    `Set()` functions to manage data access. We''ll explore these in detail next while
    using the `Float` type as an example.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定 API 提供的基本数据类型（`Bool`、`Float`、`Int`、`Rune` 和 `String`）都提供了两个构造函数：一个用于从 Go
    的零值创建新变量（使用 `New...()` 名称），另一个用于绑定到现有变量（命名为 `Bind...()`）。它还提供了 `Get()` 和 `Set()`
    函数来管理数据访问。我们将使用 `Float` 类型作为示例，在下一部分详细探讨这些内容。
- en: NewFloat() Float
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NewFloat() Float
- en: Creating a data binding using the `New...` constructor function will create
    a new piece of data with a standard value of zero. The returned object implements
    the `DataItem` interface, which enables binding. We'll look at this in more detail
    in the *Listening for changes* section, later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `New...` 构造函数创建数据绑定将创建一个具有零值标准的新数据项。返回的对象实现了 `DataItem` 接口，从而实现了绑定。我们将在本章后面的
    *监听变化* 部分更详细地探讨这一点。
- en: BindFloat(*float64) Float
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BindFloat(*float64) Float
- en: 'The `Bind...` constructor function creates a bindable data item using a pointer
    to the primitive value. Using this function, we can set default values that are
    non-zero. Additionally, the original variable can still be used to get and set
    the data in places where data binding is not supported. In the following code,
    we are creating a new data binding to a floating-point value that defaults to
    `0.5`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind...` 构造函数使用原始值的指针创建一个可绑定数据项。使用此函数，我们可以设置非零的默认值。此外，原始变量仍可用于在不支持数据绑定的地方获取和设置数据。在以下代码中，我们正在创建一个新的数据绑定到默认值为
    `0.5` 的浮点值：'
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `data` variable that was returned is a new data binding of the `Float` type
    initialized to `0.5`. If this binding is changed, it will write the new value
    back into the `f` variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `data` 变量是一个新的 `Float` 类型数据绑定，初始化为 `0.5`。如果此绑定被更改，它将新值写回 `f` 变量。
- en: Keeping Up to Date with Source Variables
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 保持与源变量的同步
- en: If you are binding to variables that exist outside the data binding constructor,
    such as in the previous example, it will also cause changes from the binding to
    update the original variable. If, however, you update the variable directly, it
    is important to inform the data binding. Call `data.Reload()` to notify the data
    binding that the value has changed, so that it can propagate the change event.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在绑定到数据绑定构造函数外部存在的变量，例如在之前的示例中，它也会导致绑定中的更改更新原始变量。然而，如果你直接更新变量，则必须通知数据绑定。调用
    `data.Reload()` 通知数据绑定值已更改，以便它可以传播更改事件。
- en: Get() (float64, error)
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Get() (float64, error)
- en: To get the current state of a data binding, simply call `Get()`. It will return
    the contents in one of Go's primitive data types. For a `Float` binding, this
    will be `float64`. If an error occurred when you accessed this value, then an
    error will be returned in the second parameter. Though unlikely at this stage,
    you will see how bindings can be combined to create more complex scenarios. There
    is no additional action as a result of this call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数据绑定的当前状态，只需调用 `Get()`。它将返回 Go 的原始数据类型之一的内容。对于 `Float` 绑定，这将是一个 `float64`。如果你访问此值时发生错误，则第二个参数将返回错误。虽然在这个阶段不太可能发生，但你将看到如何组合绑定来创建更复杂的情况。此调用不会产生任何额外操作。
- en: Set(float64) error
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Set(float64) error
- en: To update the value of a binding, you must call its `Set(val)` function while
    passing the new value (as with the `Get()` return value, this is a primitive data
    type). As a result of the value changing (if the new value is different to the
    current state), the data binding will notify all the code that is registered with
    it. If an error occurred when you were setting the value, the binding notifications
    will not be triggered, and the error will be returned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新绑定的值，你必须调用其 `Set(val)` 函数，同时传递新值（与 `Get()` 返回值一样，这是一个原始数据类型）。由于值已更改（如果新值与当前状态不同），数据绑定将通知所有已注册的代码。如果你设置值时发生错误，则不会触发绑定通知，并将返回错误。
- en: Next, we'll look at how to request updates for changes that are occurring.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何请求对正在发生的变化的更新。
- en: Listening for changes
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听变化
- en: One of the key concepts in data binding is that when a value changes, any item
    that is bound to it will update automatically. To do this, we need a mechanism
    that will notify us about changes. Before we learn how widgets do this automatically,
    we shall explore the implementation of this so that we can create our own code
    that stays up to date through data binding.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定中的一个关键概念是，当值发生变化时，任何绑定到它的项目将自动更新。为此，我们需要一个机制来通知我们变化。在我们学习小部件如何自动执行此操作之前，我们将探讨此实现的实现，以便我们可以创建自己的代码，通过数据绑定保持最新。
- en: Using the DataItem interface to add a listener
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`DataItem`接口添加监听器
- en: 'The core functionality of any data binding is the `DataItem` interface. Each
    of the binding data types shown earlier (in the *Supported data types* section)
    also implements this interface. The definition of `DataItem` allows us to add
    and remove listeners. These listeners are informed whenever a data item changes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据绑定的核心功能是`DataItem`接口。前面显示的每个绑定数据类型（在*支持的数据类型*部分）也实现了此接口。`DataItem`的定义允许我们添加和移除监听器。每当数据项发生变化时，这些监听器都会收到通知：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The definition shows how listeners are added and removed from any data item;
    this is how widgets can be informed of when data changes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 定义显示了如何向任何数据项添加和移除监听器；这就是小部件如何得知数据何时发生变化。
- en: Current Values
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当前值
- en: When adding a listener to a `DataItem`, it will immediately be called with the
    current value stored. This enables any widget or program fragment that uses binding
    to be initialized correctly without additional code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当向`DataItem`添加监听器时，它将立即调用当前存储的值。这使得任何使用绑定的小部件或程序片段可以正确初始化，而无需额外的代码。
- en: In this section, we saw that listeners are of the `DataListener` type. We shall
    explore what this type is in more detail in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到监听器是`DataListener`类型。我们将在下一节中更详细地探讨此类型。
- en: Creating a DataListener
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个`DataListener`
- en: 'Each listener of a `DataItem` must implement the `DataListener` interface.
    By constructing a type that conforms to this definition, we can add, and later
    remove, the listener from the data items we depend on. It is defined as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`DataItem`的监听者都必须实现`DataListener`接口。通过构造一个符合此定义的类型，我们可以向我们所依赖的数据项中添加监听器，并在之后移除。它被定义为如下：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, a single function is defined by the interface, `DataChanged()`.
    In most situations, the code that''s using this will want to simply provide the
    function directly. For situations such as these, we can use a helpful constructor
    function that takes a simple function and returns an instance of a `DataListener`.
    The resulting listener can be used as a parameter of the `AddListener` and `RemoveListener`
    functions. It will call the function that was specified when the data is updated:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，接口定义了一个单一的功能，`DataChanged()`。在大多数情况下，使用此代码的代码将只想直接提供该函数。对于这些情况，我们可以使用一个有用的构造函数，它接受一个简单的函数并返回一个`DataListener`的实例。生成的监听器可以用作`AddListener`和`RemoveListener`函数的参数。当数据更新时，它将调用指定的函数：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using this knowledge, we can create a very simple data binding and watch for
    changes in its value. All we need to do is use one of the data binding constructors
    and call `AddListener`, passing the listener we created:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些知识，我们可以创建一个非常简单的数据绑定并监视其值的变化。我们所需做的只是使用数据绑定构造函数之一，并调用`AddListener`，传递我们创建的监听器：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By running the preceding code, you will see that the callback is fired immediately
    with the current string value (in this case, the zero string, `""`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的代码，你会看到回调立即被触发，使用当前的字符串值（在这种情况下，空字符串，`""`）。
- en: 'Depending on your computer speed, you may need to put a time delay at the end
    of the `main()` function as the application could exit before the data binding
    is processed (for example, `time.Sleep(time.Millisecond*100)`):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的计算机速度，你可能在`main()`函数的末尾需要设置一个时间延迟，因为应用程序可能在数据绑定处理之前退出（例如，`time.Sleep(time.Millisecond*100)`）：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the preceding code, it is simple to create a data binding and be
    notified when the data changes. We could also trigger a change by calling `val.Set("new
    data")`, and the callback would trigger again.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，创建数据绑定并在数据更改时接收通知非常简单。我们也可以通过调用`val.Set("new data")`来触发更改，回调将再次触发。
- en: Despite the preceding code being useful, the main usage for data bindings in
    Fyne is to connect widgets to data without having to write code that will copy
    information and watch for changes. Next, we'll learn how standard widgets operate
    with data bindings.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码很有用，但在 Fyne 中数据绑定的主要用途是连接小部件到数据，而无需编写将复制信息并监视更改的代码。接下来，我们将学习标准小部件如何与数据绑定一起操作。
- en: Using data with standard widgets
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准小部件的数据
- en: 'As we saw in the previous section, the data binding API allows us to create
    values that provide notifications when their content changes. As you might expect,
    the widgets provided in the Fyne toolkit understand bindings and can connect to
    them to display or update data. Let''s explore how this can be set up:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中所看到的，数据绑定 API 允许我们创建在内容更改时提供通知的值。正如你所期望的，Fyne 工具包中提供的 widgets 理解绑定，并且可以连接到它们以显示或更新数据。让我们探索如何设置它：
- en: 'We start by opening a new file in `package main` and creating a `makeUI()`
    function, as we have done previously. This time, we''ll start the method by declaring
    a new floating-point number as our data binding. Using `NewFloat()` will create
    a new binding that defaults to the zero value of `0.0`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在 `package main` 中打开一个新文件，并创建一个 `makeUI()` 函数，就像我们之前做的那样。这次，我们将通过声明一个新的浮点数作为我们的数据绑定来开始这个方法。使用
    `NewFloat()` 将创建一个新的绑定，默认值为 `0.0`：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will create a `ProgressBar` widget that is bound to this data source.
    This progress bar simply displays a value that is a `Float` data type we just
    created, we must use the `NewProgressBarWithData()` constructor function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个绑定到这个数据源的 `ProgressBar` 小部件。这个进度条简单地显示一个值，它是我们刚刚创建的 `Float` 数据类型，我们必须使用
    `NewProgressBarWithData()` 构造函数：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To manipulate the data binding, we also want to include a `Slider`. As you
    saw in *, Widget Library and Themes*, this widget will display a value, using
    its current position, and allows the value to be changed by sliding. To set up
    this connection, we will use `NewSliderWithData()`, which takes additional parameters;
    that is, the permitted minimum and maximum values that can be sent into the data
    binding. We must then set the `Slider.Step` value (the gap between each step on
    the slider) to `0.01` so that we can cause fine-grained data changes:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了操作数据绑定，我们还想包括一个 `Slider`。正如你在 *小部件库和主题* 中所看到的，这个小部件将显示一个值，使用其当前位置，并允许通过滑动来更改值。为了建立这种连接，我们将使用
    `NewSliderWithData()`，它接受额外的参数；即可以发送到数据绑定的允许的最小和最大值。然后我们必须设置 `Slider.Step` 值（滑块上每个步骤之间的间隔）为
    `0.01`，以便我们可以引起精细粒度的数据变化：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition to the preceding one-way and two-way bindings, we can also use
    a version of one-way binding that is *write-only*. We do not need to connect the
    data to the widget in the same way we connected the last two widgets here (because
    there is no need for a listener for data changes). Instead, we can simply create
    a `Button` that will write to the data binding when tapped. We''ll use the familiar
    `NewButton()` constructor function here and pass in the tapped handler, which
    will set the value to `0.5`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了前面的一对一和双向绑定之外，我们还可以使用一种只写的一对一绑定的版本。我们不需要以与这里连接最后两个小部件相同的方式将数据连接到小部件（因为没有必要为数据更改设置监听器）。相反，我们可以简单地创建一个
    `Button`，当被点击时将写入数据绑定。在这里，我们将使用熟悉的 `NewButton()` 构造函数，并传递一个点击处理程序，该处理程序将值设置为 `0.5`：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final line in our `makeUI` function will be returning the container that
    packs these elements in. In this case, we will use `container.NewVBox`, which
    aligns each element on top of the others:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `makeUI` 函数中的最后一行将返回一个容器，该容器将这些元素打包。在这种情况下，我们将使用 `container.NewVBox`，它将每个元素对齐在彼此的顶部：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To complete this example, we just need to create the usual `main()` function
    that creates a new `App` instance and open a window titled `Widget Binding`. The
    content from our `makeUI` function will be added and the relevant window will
    appear. Refer to the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个示例，我们只需要创建一个常规的 `main()` 函数，该函数创建一个新的 `App` 实例并打开一个标题为 `Widget Binding`
    的窗口。我们的 `makeUI` 函数中的内容将被添加，并且相应的窗口将出现。请参考以下代码：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can now run this example to see how these widgets behave when they''re
    all bound to the same data source:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行这个示例来查看这些小部件在所有绑定到同一数据源时的行为：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the application appears, the slider and progress bar will be at the zero
    position. By dragging the slider, you will update the float that the slider and
    progress bar are bound to. As a result, you will notice that the progress bar
    moves. If you press the **Set to** **0.5** button, it will set the value to **0.5**,
    and the other widgets will both update to the halfway position, as shown in the
    following screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序出现时，滑块和进度条将位于零位置。通过拖动滑块，你将更新滑块和进度条所绑定到的浮点数。结果，你会注意到进度条在移动。如果你按下**设置为**
    **0.5**按钮，它将值设置为**0.5**，其他小部件也将更新到中间位置，如以下截图所示：
- en: '![Figure 6.1 - Data bindings set to 0.5'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.1 - 数据绑定设置为0.5]'
- en: '](img/Figure_6.1_B16820.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.1 - B16820.jpg](img/Figure_6.1_B16820.jpg)'
- en: Figure 6.1 - Data bindings set to 0.5
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 数据绑定设置为0.5
- en: In this section, we have seen the benefits of data binding for handling dynamic
    data, as well as the constraints of a strongly-typed API. Next, we will look at
    how to convert between types so that the data can be adapted for use in a wider
    variety of widgets.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了数据绑定在处理动态数据时的好处，以及强类型API的约束。接下来，我们将探讨如何在不同类型之间进行转换，以便数据能够适应更广泛的各种小部件的使用。
- en: Adapting data types for display
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应显示数据类型
- en: In the example we worked through in the previous section, we learned that it's
    possible to bind the same value to different widgets since both `Slider` and `ProgressBar`
    expect a `Float` value for their data. However, it is not always the case that
    these data types will align perfectly. Sometimes, we will need to perform conversions
    to connect to the widgets we wish to use. In this section, we will explore how
    to do so, starting with how we can include a label in the preceding example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们讨论的示例中，我们了解到可以将相同的值绑定到不同的小部件上，因为`Slider`和`ProgressBar`都期望它们的数据为`Float`类型。然而，这些数据类型并不总是完美匹配。有时，我们需要进行转换以连接到我们希望使用的小部件。在本节中，我们将探讨如何进行转换，从如何在先前的示例中包含一个标签开始。
- en: Formatting types into strings
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类型格式化为字符串
- en: In many applications, it is common to use a `Label` or other string-based display
    to contain information in another format, such as an `int` or `float64`. With
    data bindings, this is no different, so the `binding` package provides conversion
    functions that can make this adaptation easy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，使用`Label`或其他基于字符串的显示来包含其他格式的信息是很常见的，例如`int`或`float64`。使用数据绑定，这并无不同，因此`binding`包提供了可以简化这种适应的转换函数。
- en: 'To follow on from the previous example, we could include a `Label` that displays
    the `float64` value, but to do so, we would need a `String` binding rather than
    a `Float`. To obtain this, we can use the `FloatToString` function in the binding
    package. Like all binding conversion functions, this takes a single parameter,
    the source binding, and returns a new binding that is of the correct type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了延续先前的示例，我们可以包含一个显示`float64`值的`Label`，但要做到这一点，我们需要一个`String`绑定而不是`Float`。为了获得这个，我们可以使用绑定包中的`FloatToString`函数。像所有绑定转换函数一样，它接受一个参数，即源绑定，并返回一个正确类型的新绑定：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the string binding we just obtained, we can then create a `Label`, as
    shown in the previous code fragment. This approach will render the value using
    a default format. In the case of a `Float` binding, this will use the `"%f"` format
    string, which is similar to `fmt.Printf` in terms of usage. If we want to specify
    our own format, perhaps with some leading text, we can do so using the `ToStringWithFormat`
    notation instead:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚刚获得的字符串绑定，我们可以创建一个`Label`，如前一个代码片段所示。这种方法将使用默认格式渲染值。对于`Float`绑定，这将使用`"%f"`格式字符串，在用法上类似于`fmt.Printf`。如果我们想指定自己的格式，可能包括一些前导文本，我们可以使用`ToStringWithFormat`表示法来做到这一点：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When using this updated code, the output label will contain text such as `Value`
    `is:` `0.50`, which is probably more meaningful to the users of your app. When
    specifying a format, be sure to include the appropriate format string for the
    source type, such as `%f` for `Float` or `%d` for `Int`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此更新后的代码时，输出标签将包含类似于`Value` `is:` `0.50`的文本，这对你应用的用户来说可能更有意义。在指定格式时，请确保包含源类型的适当格式字符串，例如`Float`类型的`%f`或`Int`类型的`%d`。
- en: Although displaying a value that is not a string is by far the most common conversion
    requirement, we may need to access a variable of some number type that is stored
    in a string. We'll explore this next.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然显示非字符串类型的值是迄今为止最常见的转换需求，但我们可能需要访问存储在字符串中的某些数字类型的变量。我们将在下一节中探讨这一点。
- en: Parsing values from the string type
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从字符串类型解析值
- en: In some cases, the data you are working with may not be in the desired format
    for the widgets you wish to use. When managing the conversion manually, you can
    do this as part of your own code – simply extract the data, convert it, and then
    supply the parsed information to your widget. However, with data binding, we want
    to keep a direct connection to the source data, which means conversion needs to
    happen within the chain of data binding.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你正在处理的数据可能不是你希望用于小部件的所需格式。当手动管理转换时，你可以将其作为你自己的代码的一部分来完成——简单地提取数据，转换它，然后将解析后的信息提供给小部件。然而，在使用数据绑定时，我们希望保持与源数据的直接连接，这意味着转换需要在数据绑定的链中发生。
- en: 'Just like in the previous section, there are convenience methods that can help
    with this as well; they typically contain the phrase `StringTo` in their name.
    Let''s work with an example that has a `string` value that contains an `int` number.
    We don''t want to include manual code in the conversion, so we need to include
    a conversion in the chain, as illustrated here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一节中一样，也有一些方便的方法可以帮助你完成这项工作；它们的名字通常包含短语 `StringTo`。让我们通过一个例子来操作，这个例子中有一个包含
    `int` 数字的 `string` 值。我们不希望在转换中包含手动代码，因此我们需要在链中包含一个转换，如下所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As a result of this code, we have `binding.Int` that is reading the underling
    `string` data source and can now be used where a widget requires an `Int` as its
    data source.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了 `binding.Int`，它正在读取底层的 `string` 数据源，现在可以在需要 `Int` 作为数据源的小部件中使用。
- en: 'This is a trivial example. Normally, when a number is stored as a string, it
    is because the value has some non-number element to it, such as a percentage that
    will include the trailing `%` symbol. When there is extra formatting in the string,
    we can still achieve the same outcome by using the `StringToIntWithFormat` version
    of the conversion, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子。通常，当数字以字符串形式存储时，是因为该值包含一些非数字元素，例如一个包含尾随 `%` 符号的百分比。当字符串中有额外的格式化时，我们仍然可以通过使用转换的
    `StringToIntWithFormat` 版本来达到相同的结果，如下所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that, in the format string, we needed to use a double percent to capture
    the percent symbol (`%%`). This is due to how the format strings work, but otherwise,
    this example is quite straightforward. Calling `intBind.Get()` will return `5`
    (with no error), and if the `strBind` value were to be changed to `25%`, then
    `IntBind.Get()` would return `25`, as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在格式字符串中，我们需要使用两个百分号来捕获百分号符号（`%%`）。这是由于格式字符串的工作方式，但除此之外，这个例子相当简单。调用 `intBind.Get()`
    将返回 `5`（没有错误），如果 `strBind` 的值改为 `25%`，那么 `IntBind.Get()` 将返回 `25`，正如预期的那样。
- en: In this section, we managed to use data binding conversion functions to change
    source data into a different type of data so that it can be used in our user interface.
    Next, we will learn how to make sure that changes in the output (for a two-way
    binding) are propagated to the original data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们成功地使用了数据绑定转换函数将源数据转换为另一种类型的数据，以便在用户界面中使用。接下来，我们将学习如何确保输出（对于双向绑定）的变化传播到原始数据。
- en: Propagating changes through conversions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过转换传播变化
- en: In the examples provided in the preceding section, we looked at complex chains
    of data binding so that we can convert source data for display purposes. This
    makes it much easier to use a variety of widgets connected to data binding without
    needing to write complex conversion code. However, we need to ensure that changes
    in the presented data are pushed back to the data source.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节提供的示例中，我们查看复杂的数据绑定链，以便将源数据转换为显示目的。这使得在不需要编写复杂转换代码的情况下使用各种与数据绑定连接的小部件变得容易得多。然而，我们需要确保呈现的数据中的变化被推回到数据源。
- en: The great news here is that the conversions demonstrated in the *Formatting
    types into string* and *Parsing values from the string type* sections are full
    two-way data bindings. This means that we do not need to add any further code
    to propagate changes in the data. If an `IntToString` connection is made, then
    changes to the source `Int` will not only result in new values in the output `String`,
    but calling `Set()` on our `String` will cause a parsed integer to be pushed back
    to the original `Int` binding. This will depend on the string being correctly
    formatted, of course – setting an invalid value will not propagate a change it
    will return an error instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，在*将类型格式化为字符串*和*从字符串类型解析值*部分中展示的转换是全双工数据绑定。这意味着我们不需要添加任何额外的代码来传播数据的变化。如果建立了`IntToString`连接，那么源`Int`的变化不仅会在输出`String`中产生新的值，而且对`String`调用`Set()`将导致解析后的整数被推回到原始的`Int`绑定。当然，这取决于字符串是否正确格式化，设置无效值将不会传播变化，而是返回错误。
- en: The types we've explored in this section are used by standard widgets to display
    and manage dynamic data. In many applications, however, we have more complex data.
    In the next section, we will explore how to bind such data to our apps.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们探索的类型被标准小部件用于显示和管理动态数据。然而，在许多应用程序中，我们拥有更复杂的数据。在下一节中，我们将探讨如何将此类数据绑定到我们的应用程序中。
- en: Binding complex data types
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定复杂的数据类型
- en: The types that we have used in our data binding exploration so far have been
    limited to mappings of the Go primitive types. This means that they represent
    simple variables with a single element. For many applications, it will be necessary
    to display more complex data, such as lists, maps, or even custom structs. In
    this section, we will look at how that can be done, starting with the `DataList`
    type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据绑定探索中使用的类型到目前为止仅限于Go原始类型的映射。这意味着它们代表具有单个元素的简单变量。对于许多应用程序，显示更复杂的数据，如列表、映射或自定义结构体将是必要的。在本节中，我们将探讨如何实现这一点，从`DataList`类型开始。
- en: Using lists of data
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据列表
- en: 'Whether you wish to use data bindings to present data to a `widget.List` or
    a `widget.RadioGroup`, or if you are modeling your data with bindings that will
    be passed to your own widgets, the concept of a data list will be important. The
    data binding API defines `DataList` as a binding that provides additional `Length`
    and `GetItem(int)` functions, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是想使用数据绑定将数据呈现给`widget.List`或`widget.RadioGroup`，还是您正在使用将传递给您的自定义小部件的绑定来建模数据，数据列表的概念都将很重要。数据绑定API将`DataList`定义为一个提供额外`Length`和`GetItem(int)`函数的绑定，如下所示：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This generic definition means that a list can encapsulate a data type – the
    `DataItem` instance returned by `GetItem()` could be a `String`, `Int`, or even
    another `DataList`. You can implement a `DataList` using the previous interface
    or you can use one of the type-based lists provided by Fyne. The `Length` method
    will always return the number of items in this list, while `GetItem` can be used
    to access the data binding at the specified index (as lists are ordered).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用定义意味着列表可以封装一个数据类型——`GetItem()`返回的`DataItem`实例可以是`String`、`Int`，甚至是另一个`DataList`。你可以使用之前的接口实现`DataList`，或者可以使用Fyne提供的基于类型的列表之一。`Length`方法将始终返回列表中的项目数量，而`GetItem`可以用来访问指定索引处的数据绑定（因为列表是有序的）。
- en: Changes in the list's length (through `append`, `insert`, or `remove`) will
    trigger a callback on any listeners that are registered on the `DataList`. If
    the value of one of the items changes, it will trigger the change listener on
    the individual item rather than the containing list. Because of this, we can be
    clever about minimizing the impact of UI changes when a listener calls our code.
    We'll see how this process works in the following sections when we use a `StringList`
    to manage many items presented in a `List` widget.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表长度的变化（通过`append`、`insert`或`remove`）将在注册在`DataList`上的任何监听器上触发回调。如果列表中某个项目的值发生变化，它将触发单个项目的更改监听器，而不是包含该列表。正因为如此，当监听器调用我们的代码时，我们可以巧妙地最小化UI变化的影响。在接下来的章节中，我们将使用`StringList`来管理在`List`小部件中展示的多个项目时，我们将看到这个过程是如何工作的。
- en: Creating a list
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个列表
- en: 'Although a list can contain items of many different types, they will usually
    have all items of the same type, such as `String` or `Float`. For this purpose,
    there are helpful constructor functions, such as `NewFloatList` and `BindStringList`.
    You can build a new list with no content using the `New...List` methods, or you
    can bind to an existing slice in your Go code using `Bind...List` functions. For
    example, an empty string list might look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管列表可以包含许多不同类型的项，但它们通常都会包含相同类型的所有项，例如 `String` 或 `Float`。为此，有一些有用的构造函数，例如 `NewFloatList`
    和 `BindStringList`。您可以使用 `New...List` 方法创建一个没有任何内容的空列表，或者您可以使用 `Bind...List` 函数将绑定到
    Go 代码中的现有切片。例如，一个空字符串列表可能看起来如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running this code will display the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将显示以下输出：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, you can see that the standard lists provide additional `GetValue` and
    `SetValue` methods, to access values just like the standard singular bindings.
    There are also matching `Get` and `Set` methods that allow you to change the whole
    list. This allows us to use the primitive types to access and apply data when
    the list type is known. We can also do the same using a slice for storage that
    the data binds to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到标准列表提供了额外的 `GetValue` 和 `SetValue` 方法，以便像标准单一绑定一样访问值。还有匹配的 `Get` 和
    `Set` 方法，允许您更改整个列表。这使我们能够使用原始类型在已知列表类型时访问和操作数据。我们还可以使用数据绑定的存储切片以相同的方式进行操作：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running this code will result in the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have created a list binding, we can use it to display data in a
    widget that uses `DataList` bindings, such as `widget.List`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个列表绑定，我们可以使用它来在使用 `DataList` 绑定的小部件中显示数据，例如 `widget.List`。
- en: Displaying a list
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示列表
- en: 'The most common way we will typically use a data list is through the `List`
    widget. When using a data binding to manage a list widget, it will automatically
    add rows that match the length of the data. It will grow or shrink when the length
    changes. Additionally, the data items in the list can be bound to the items in
    the list, meaning that if a data value is updated, the list will automatically
    update. Refer to the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用数据列表的最常见方式是通过 `List` 小部件。当使用数据绑定来管理列表小部件时，它将自动添加与数据长度相匹配的行。当长度变化时，它会增长或缩小。此外，列表中的数据项可以绑定到列表中的项，这意味着如果数据值被更新，列表将自动更新。请参考以下代码：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, we use the `NewListWithData` constructor function to set data
    binding in the `List` widget. The first parameter, `DataList`, replaces the `Length`
    function, which is used in a regular `List` constructor. The second parameter,
    the function that sets up template items, remains the same. The callback in the
    last parameter for updating items is similar to a regular list, except the first
    parameter is now a `DataItem` instead of a `ListItemID`. We can keep the `Text`
    value of `Label` up to date by calling `Bind()` and passing the `DataItem` once
    it has been cast to the `binding.String` strong type. Applying a binding in this
    manner will implement the standard API, so we don't have to worry about how caching
    will impact this functionality.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 `NewListWithData` 构造函数在 `List` 小部件中设置数据绑定。第一个参数 `DataList` 替换了在常规
    `List` 构造函数中使用的 `Length` 函数。第二个参数，设置模板项的函数保持不变。最后一个参数的回调用于更新项，与常规列表类似，但第一个参数现在是一个
    `DataItem` 而不是 `ListItemID`。我们可以通过调用 `Bind()` 并传递已转换为 `binding.String` 强类型的 `DataItem`
    来保持 `Label` 的 `Text` 值最新。以这种方式应用绑定将实现标准 API，因此我们不必担心缓存如何影响此功能。
- en: Managing lists with different types is possible, as long as you are careful
    when casting `DataItem` to the correct binding type on each access. Doing this
    is outside the scope of this chapter. In the next section, you will learn how
    the technique can be applied as a map of data, which typically contains many different
    types of values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 管理不同类型的列表是可能的，只要你在每次访问时小心地将 `DataItem` 转换为正确的绑定类型。这超出了本章的范围。在下一节中，你将了解如何将这种技术应用于数据映射，它通常包含许多不同类型的值。
- en: Using data maps
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据映射
- en: 'Maps of data in the context of data binding are much like the Go `map` type,
    where `string` keys map to `DataItem` types; for example, `map[string]binding.DataItem`.
    The `DataMap` definition is similar to `DataList`, except that it uses `string`
    keys to identify child elements instead of an `int` ID. Instead of the `Length()`
    method, which returns how long the list is, it requires a `Keys()` function, which
    returns a string slice containing all of the keys present in the dataset. To find
    the number of items present in the data, you can simply call `len(DataMap.Keys())`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据绑定的上下文中，数据映射与 Go 的 `map` 类型非常相似，其中 `string` 键映射到 `DataItem` 类型；例如，`map[string]binding.DataItem`。`DataMap`
    的定义与 `DataList` 类似，但它使用 `string` 键来标识子元素，而不是使用 `int` ID。它不使用返回列表长度的 `Length()`
    方法，而是需要一个 `Keys()` 函数，该函数返回一个包含数据集中所有键的字符串切片。要找到数据中的项目数量，你可以简单地调用 `len(DataMap.Keys())`：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When an item is added or removed from `DataMap`, its listeners are fired. If
    the value of one of the items changes, it will trigger the change listener on
    the individual item rather than all of the DataMap listeners (as with items in
    a list, as mentioned in the previous section). Because maps normally have many
    different types of data in them, creating one using the standard API is a little
    different to creating a list, as we will see now. Of course, any type that implements
    the `DataMap` interface can be used in map data binding, but it is normally easier
    to use the provided implementations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当向 `DataMap` 添加或从其中移除项目时，其监听器将被触发。如果某个项目的值发生变化，它将触发单个项目的更改监听器，而不是所有 DataMap
    监听器（如前一小节中提到的列表中的项目）。由于映射通常包含许多不同类型的数据，因此使用标准 API 创建映射与创建列表略有不同，我们现在将看到这一点。当然，任何实现了
    `DataMap` 接口类型的都可以用于映射数据绑定，但通常使用提供的实现会更简单。
- en: We will explore how `DataMap` can be used in the following sections by creating
    one and setting its values before describing how they could be used for display.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过创建一个 `DataMap` 并设置其值来探索如何使用它，然后再描述它们如何用于显示。
- en: Creating a data map
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据映射
- en: '`DataMap`, unlike `DataList`, does not have type-specific implementations within
    Fyne. Since maps normally contain many different types, there is only one map
    implementation that maps `string` keys to `interface{}` values. This can be created
    as a new map in memory, or by binding to an existing `map` with the `map[string]interface{}`
    type signature. First, let''s look at creating a new map; the following code creates
    a new map using the `binding.NewUntypedMap()` constructor function and adds some
    values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `DataList` 不同，`DataMap` 在 Fyne 中没有特定类型的实现。由于映射通常包含许多不同类型的数据，因此只有一个映射实现将 `string`
    键映射到 `interface{}` 值。这可以通过在内存中创建一个新的映射，或者通过使用 `map[string]interface{}` 类型签名绑定到现有的
    `map` 来创建。首先，让我们看看如何创建一个新的映射；以下代码使用 `binding.NewUntypedMap()` 构造函数创建一个新的映射并添加一些值：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Executing the preceding code will produce the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码将产生以下输出：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can do the same again but using an existing data source by making use of
    `binding.BindUntypedMap()` instead, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次执行相同的操作，但这次通过使用现有的数据源，利用 `binding.BindUntypedMap()` 来实现，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Executing the preceding code will produce the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码将产生以下输出：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding samples do not check for data types, but if you are sure of the
    type for a key, you can perform type assertions like with a list. For example
    `values.GetItem("key").(Float)` would return a float data binding to the float64
    stored at the specified key. Let us now look at how this can be used for display.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例没有检查数据类型，但如果你确定一个键的类型，你可以执行类似于列表中的类型断言。例如 `values.GetItem("key").(Float)`
    会返回一个与存储在指定键处的 float64 类型的 float 数据绑定。现在让我们看看如何使用它来显示。
- en: Displaying a map
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示映射
- en: At the time of writing, there are no built-in widgets that make use of the `DataMap`
    binding type. Its main usage is to allow your application to maintain many data
    bindings in a single binding type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，没有内置的小部件使用 `DataMap` 绑定类型。它主要的作用是允许你的应用程序在单个绑定类型中维护多个数据绑定。
- en: It is expected that both the `Form` and `Table` widgets will add support for
    data binding in the near future. You can check out the latest API updates on the
    developer website at [https://developer.fyne.io/api/widget.html](https://developer.fyne.io/api/widget.html).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 预计 `Form` 和 `Table` 小部件将在不久的将来添加对数据绑定的支持。你可以在开发者网站上查看最新的 API 更新，网址为 [https://developer.fyne.io/api/widget.html](https://developer.fyne.io/api/widget.html)。
- en: Before we leave this section, we will explore one last trick – mapping a custom
    `struct` to a `DataMap`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开本节之前，我们将探索一个最后的技巧——将自定义 `struct` 映射到 `DataMap`。
- en: Mapping structs to a data binding
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将结构体映射到数据绑定
- en: When populating data in a `DataMap`, one of the common ways to do so would be
    by using a `struct` type. In this situation, there are a set of fields where a
    name maps to a value (as we've seen many times in this book already). As you can
    see, this definition matches nicely to the maps that we saw in the previous section.
    To save a lot of manual code, the data binding API provides a simple way to automatically
    create a `DataMap` from an existing struct variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充 `DataMap` 中的数据时，常见的方法之一是使用 `struct` 类型。在这种情况下，有一组字段，其中名称映射到值（正如我们在本书中已经多次看到的）。正如你所看到的，这个定义与我们在上一节中看到的映射非常匹配。为了节省大量的手动代码，数据绑定
    API 提供了一种简单的方法，可以从现有的结构变量自动创建 `DataMap`。
- en: 'Just like any other `binding.Bind...` method, we pass a pointer to the variable
    and it returns the bound data type. In this case, the Fyne code will use the names
    of each `struct` field as the keys of the map, and the values will be set to the
    variables of the struct. To be able to bind a field in a `struct`, it must be
    an exported field (the name must start with an uppercase letter). The following
    code demonstrates this principle:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他的 `binding.Bind...` 方法一样，我们传递一个变量的指针，它返回绑定后的数据类型。在这种情况下，Fyne 代码将使用每个 `struct`
    字段的名称作为映射的键，值将被设置为该 `struct` 的变量。为了能够在一个 `struct` 中绑定一个字段，它必须是一个导出字段（名称必须以大写字母开头）。以下代码演示了这一原则：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the preceding code will produce the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将产生以下输出：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the keys and values all work as expected, but with the benefit
    that widgets can observe changes that have been made to the data and keep their
    display updated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，键和值都按预期工作，但有一个好处，即小部件可以观察对数据的更改并保持其显示更新。
- en: Now that we have explored how data bindings can easily handle how dynamic data
    is displayed, we shall look at how to store user-generated data using the Preferences
    API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了数据绑定如何轻松处理动态数据的显示方式，我们将看看如何使用 Preferences API 存储用户生成数据。
- en: Storing data using the Preferences API
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Preferences API 存储数据
- en: It is a common requirement for applications to store many pieces of information,
    such as user configuration options, current input field contents, and a history
    of opened files. Using files to store this information would require additional
    code to format the information for storage; using a database would require additional
    servers or dependencies for an application. To help with this, Fyne provides a
    **Preferences** API, similar to those used by iOS and Android developers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序来说，存储大量信息是一个常见的需求，例如用户配置选项、当前输入字段的内容以及打开文件的历史记录。使用文件来存储这些信息将需要额外的代码来格式化信息以便存储；使用数据库将需要额外的服务器或应用程序的依赖项。为了帮助解决这个问题，Fyne
    提供了一个类似于 iOS 和 Android 开发者使用的 **Preferences** API。
- en: Data that is stored as Fyne preferences can be accessed by any code in an application
    using a specific string identifier, known as a **key**. Each **value** that is
    stored has a specific type, so developers do not have to handle any conversion
    or type checking. Any time that this data changes, it will be saved for future
    use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 存储为 Fyne 预设的数据可以通过任何使用特定字符串标识符（称为 **键**）的应用程序代码访问。每个存储的 **值** 都有特定的类型，因此开发者不需要处理任何转换或类型检查。任何时间数据发生变化，它都会被保存以供将来使用。
- en: In this section, we'll learn how to manage data using the Preferences API and
    see how we can avoid having to manually manage user data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Preferences API 管理数据，并了解我们如何避免手动管理用户数据。
- en: Get and set values
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和设置值
- en: Each supported type (see the following section) provides functions so that we
    can get and set data of that type. We will explore this using a string. To read
    or write data using a string, we can use the `String()` function; to write a value,
    we can use `SetString()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个支持的类型（见下一节）都提供了函数，以便我们可以获取和设置该类型的数据。我们将通过使用字符串来探索这一点。要使用字符串读取或写入数据，我们可以使用
    `String()` 函数；要写入一个值，我们可以使用 `SetString()`。
- en: To gain access to the preferences, we can use `App.Preferences()`. If you do
    not have access to the `App` instance that loaded the application, you can use
    `fyne.CurrentApp().Preferences()` instead, which will return the same reference.
    There is an additional requirement, however – each application must declare a
    unique identifier for use in storage. To do this, we must change the `app.New()`
    constructor function to `app.NewWithID()`, passing a suitable unique identifier.
    Typically, the unique ID will be in reverse DNS format, and must match the identifier
    you will use during distribution (see [*Chapter 9*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219),
    *Bundling Resources and Preparing for Release,* for more details). For example,
    you can use `com.example.myapp` for testing purposes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问首选项，我们可以使用`App.Preferences()`。如果您无法访问加载应用程序的`App`实例，可以使用`fyne.CurrentApp().Preferences()`代替，它将返回相同的引用。然而，还有一个额外要求——每个应用程序必须声明一个唯一的标识符，用于存储。为此，我们必须将`app.New()`构造函数更改为`app.NewWithID()`，传递一个合适的唯一标识符。通常，唯一ID将是反向DNS格式，并且必须与您在分发时使用的标识符匹配（有关更多详细信息，请参阅[*第9章*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219)，*打包资源和准备发布*）。例如，您可以使用`com.example.myapp`进行测试目的。
- en: 'The following code snippet sets up an application with a (relatively) unique
    identifier and accesses the standard preferences:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段设置了一个具有（相对）唯一标识符的应用程序并访问标准首选项：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can insert the preceding code into the usual `main()` function (for a more
    complete listing, please go to the *Implementing a water consumption tracker*
    section). Notice that we used a single `string` value for the key – this helps
    us avoid making mistakes if typing out the key for each access. Running it will
    produce the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的代码插入到常规的`main()`函数中（对于更完整的列表，请参阅*实现水消耗跟踪器*部分）。请注意，我们使用单个`string`值作为键——这有助于我们避免在每次访问时输入键时出错。运行它将产生以下输出：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This quick example demonstrates string access, but there are other types we
    can use as well. We'll look at some of these in the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快速示例演示了字符串访问，但我们还可以使用其他类型。我们将在下一节中查看其中的一些。
- en: Supported types
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的类型
- en: 'It''s possible to store any type of data using just the string methods illustrated,
    but the API is designed to help us avoid the complexities of formatting and parsing
    data in that way. Due to this, there are different types supported by the Fyne
    preferences code. At the time of writing, the supported types are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所展示的字符串方法，可以存储任何类型的数据，但API旨在帮助我们避免以这种方式格式化和解析数据的复杂性。因此，Fyne首选项代码支持不同类型。在撰写本文时，支持的类型如下：
- en: '`bool`: Stores a simple boolean (`true` or `false`) value.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：存储简单的布尔值（`true`或`false`）。'
- en: '`float`: Numbers that need a floating-point value can be stored using a `float`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：需要浮点数值的数字可以使用`float`存储。'
- en: '`int`: For whole numbers, use the `int` functions.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：对于整数，使用`int`函数。'
- en: '`string`: As we used previously, a simple `string` value.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：正如我们之前所使用的，简单的`string`值。'
- en: Each of these types follow the same naming convention that we saw in the previous
    code. For example, you could set an integer using `SetInt()` or get a boolean
    value using `Bool()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型遵循我们在前面的代码中看到的相同命名约定。例如，您可以使用`SetInt()`设置整数或使用`Bool()`获取布尔值。
- en: By using Go semantics, the values that are returned will have zero values if
    no item was previously stored. It is possible to set different defaults using
    fallback values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Go语义，如果没有之前存储任何项，返回的值将具有零值。使用回退值可以设置不同的默认值。
- en: Fallback values
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回退值
- en: For situations where the default value of a property should not be the standard
    zero value (defined by Go), each `Get...` function has a `WithFallback` version;
    for example, `StringWithFallback()`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些属性默认值不应是Go定义的标准零值（0）的情况，每个`Get...`函数都有一个`WithFallback`版本；例如，`StringWithFallback()`。
- en: 'If we change the code in the previous example so that it just uses the get
    and fallback methods, we can see how they work:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的示例中的代码更改为仅使用获取和回退方法，我们可以看到它们是如何工作的：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running this version of the code will produce the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此版本的代码将产生以下输出：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With these methods, we can handle data with sensible defaults and save changes
    for future runs of the application. Sometimes, we will need to remove old data;
    we can do that too.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，我们可以处理具有合理默认值的数据，并保存应用程序未来运行的更改。有时，我们可能需要删除旧数据；我们也可以做到这一点。
- en: Removing old data
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除旧数据
- en: Storing data for users is important, but so is the ability to delete it when
    requested. To do so, the Preferences API provides one final method, `RemoveValue`,
    that will do just that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 存储用户数据很重要，但能够在请求时删除它也同样重要。为此，首选项API提供了一个名为`RemoveValue`的最终方法，它将执行此操作。
- en: 'By adding the following code to the end of our previous example, the values
    that were set will be cleaned out, meaning that on the next run, you will see
    the default values if the application is started a second time:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下代码添加到我们之前的示例末尾，设置的值将被清除，这意味着在下次运行时，如果应用再次启动，你将看到默认值：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code also prints out the value once it has completed, ensuring
    that the item has been removed from the preferences. Running all the code from
    this section together will produce the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在完成时也会打印出值，确保项目已被从首选项中移除。将本节中的所有代码一起运行将产生以下输出：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With that, we have seen how we can trivially store and access elements of data
    to be used in our apps. However, the Preferences API becomes even more powerful
    when we combine it with the data binding API we saw at the beginning of this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到了如何轻松地存储和访问在应用中使用的数据元素。然而，当我们将它与我们本章开头看到的绑定数据API结合使用时，首选项API变得更加强大。
- en: Binding to preferences
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首选项绑定
- en: With the `binding` package, which we focused on earlier in this chapter, we
    can create data bindings that are connected to preference storage instead of regular
    variables. This provides us with the huge benefit that any time the setting of
    a value is triggered, it will be stored, and when the application is started again,
    the previous value will be loaded.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们关注的`binding`包中，我们可以创建连接到首选项存储而不是常规变量的数据绑定。这为我们提供了巨大的好处，即每次值设置触发时，它都会被存储，当应用再次启动时，将加载之前的值。
- en: 'To access this functionality, we can use the functions whose names start with
    `BindPreference`, such as `BindPreferenceString()`. There is one function for
    each of the types supported by the Preference API, as listed earlier in this section.
    Each of these methods accepts a string parameter, which is the key string that
    we used in the previous code excerpts. Code that wishes to continue using the
    Preferences API can continue to do so as before, but using these data bindings
    ensures that new values are pushed directly to the widget that the binding is
    connected to. The bindings that are returned from a preferences bind use the same
    types as other data binding APIs, so you can get the `string` value of a preference
    item through its binding using `Get()`, as you might expect:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此功能，我们可以使用以`BindPreference`开头命名的函数，例如`BindPreferenceString()`。本节前面列出了支持的首选项API的每种类型都有一个函数。这些方法都接受一个字符串参数，这是我们之前代码片段中使用的键字符串。希望继续使用首选项API的代码可以像以前一样继续使用，但使用这些数据绑定确保新值直接推送到绑定连接的小部件。从首选项绑定返回的绑定使用与其他数据绑定API相同的类型，因此你可以通过`Get()`方法获取首选项项的`string`值，正如你所期望的那样：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code will access the same preferences value but through the data
    binding framework, making it easy to keep widgets up to date with user preferences.
    The output will be as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将通过数据绑定框架访问相同的首选项值，这使得保持小部件与用户首选项同步变得容易。输出将如下所示：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These bindings can also be chained, as with the earlier definitions, which
    means you can obtain a `String` binding to a preference value that is an integer
    by doing the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定也可以像之前的定义一样链式连接，这意味着你可以通过以下方式获取一个整数首选项值的`String`绑定：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is also possible to have multiple widgets, connected to multiple data bindings,
    all read and write the same preference value. If you use the same key to create
    many bindings to a preference, then they will all stay up to date when the value
    changes. We will see this in action in the example that follows.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在多个小部件，连接到多个数据绑定，所有这些小部件都读取和写入相同的首选项值。如果你使用相同的键为多个绑定创建首选项，那么当值发生变化时，它们都将保持最新。我们将在下面的示例中看到这一点。
- en: With that, we have explored the data binding and Preference APIs and how they
    can, individually or together, vastly reduce the amount of code required to manage
    data in an application. Let's utilize this knowledge and implement an example
    application that can help us track our daily water consumption.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a water consumption tracker
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The APIs that we have explored in this chapter can be helpful for most applications.
    To learn how we can add preference storage to a simple application, we will explore
    another example project. This time, we will create a tracker that can track water
    consumption over 1 week.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the user interface
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start working with data binding APIs, we will construct the basic
    user interface. The aim is to put today''s total in large text at the top of a
    window, with the date below. We will follow this with the controls to add water
    to the current total. Under this, we will add another section that shows the values
    for the current week. Let''s get started:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start, as usual, by defining a `makeUI` function, which builds the
    user interface. To start, we will define the large label that will be used to
    show the total by setting the font to `42` points, center aligning it, and using
    the `theme` primary color:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need to create another, regular label for the date to be displayed:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next few elements add controls, that support adding a value to the current
    water consumption. This could be a button that simply adds a specific number (for
    example, *250 ml*), but to be more flexible, we will allow the user to specify
    an amount. To do this, we will create an `Entry` field that is pre-filled with
    `250`. Then, we will add a helper `ml` label after it and define a new button,
    labeled `Add`, that will action this later:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Before creating the history layout we define a helpful `historyLabel` function.
    This will create a new label that simply contains `0ml` and aligns it to the right.
    The data here will be added later.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The last content element we''ll add is the history information. In this case,
    we can construct this using a grid container with two columns. On the left, we
    will show the day of the week, while on the right, we will show a label for the
    value:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To return the result of our interface building from this function, we can create
    a new vertical box. Inside this box, we must stack the total `label`, `date`,
    a horizontal grid that aligns the `input` and the `add` button, and lastly a `Card`
    widget containing the history content, along with a header.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For this example to run, we must create the typical `main()` function. This
    time, we want it to create a window titled `Water Tracker` and set the `makeUI()`
    return to the content before showing it:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can now run this example in the usual way from the command line:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Running the preceding command should result in the following interface appearing
    (when using the light theme):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The empty user interface](img/Figure_6.2_B16820.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The empty user interface
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: This interface looks suitable, but it does not do anything yet. In the next
    section, we'll start creating some functionality by binding the `total` label
    to a value that can be incremented using the **Add** button.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Binding data to the UI
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start making the user interface functional, we will use data binding so
    that the header section of the app manages a single integer value representing
    how much water has been consumed in a day. Follow these steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to declare a new binding variable that is of the `binding.Int`
    type. We must add the following line to the beginning of our `makeUI` function:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we will add an implementation of the button tap handling. To action the
    number increment, we must replace the old `func() {}` function with the following
    function:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will parse an integer from the `amount.` `Text` field and add it to the
    total. It does this by calling `Get()`, which finds the current value, and then
    `Set()`, with the increment applied.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we want to display the integer value in a label, with `String` binding
    that is based on the `Int` function we already created:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we have used `canvas.Text` to define our large, colored text, we must
    bind these values. However, there isn''t a helpful `WithData` constructor function
    for this, so we must apply the binding values manually. Let''s create a new `DataListener`
    that will be called when the values change. Inside the callback, we set the text
    and request a refresh:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With these changes made, we can run the app to see the changes in action:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The user interface looks the same when it is loaded, but when we tap the **Add**
    button, the total value will update, increasing by the number by the value in
    the entry field:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Showing a bound value](img/Figure_6.3_B16820.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Showing a bound value
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If you quit this version of the app and open it again, you will notice that
    the value is forgotten. We can fix this by using the Preferences API, which we
    will do now.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Storing with preferences
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remember values between application launches, we can make use of the Preferences
    API. This allows us to store values without needing to manage file access or databases.
    In this section, we will connect our data binding to the Preferences API so that
    it will automatically remember the data when it changes. Follow these steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to store preferences, we need to allocate a key for each data item.
    In this example, each number is the total for a day, so we will use the date to
    identify the stored item. We need a new function, `dateKey`, that will format
    a string from any given time:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To be able to use the Preference API, we need to make sure that our application
    has a unique identifier. To do this, we will use `app.NewWithID` instead of `app.New`.
    The ID should be globally unique. Then, we need to retrieve the application `Preferences`
    instance and pass it into our `makeUI` function so that it can be used in the
    bindings:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we will update the `Int` binding so that it can access preferences instead
    of creating a new value in memory. We will update `makeUI` so that it accepts
    a preferences instance and then change our binding creation so that it uses `BindPreferenceInt`.
    This constructor requires the key of the value it needs to access (which is generated
    by the `dateKey` function we created) and the preferences instance to use:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Since we are completing the top section of our app, we should also set the
    correct date. Simply change the label constructor so that it passes a formatted
    date string, like so:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you run the app again, you will see the same interface (with a corrected
    date display). If you add some value to today's total and then restart the app,
    you will notice that the value is remembered.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have completed the basic functionality of our app, but the history
    fields are still blank. Building on the previous functionality, we can show the
    stored values from previous days.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Adding history
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'With the main data binding code working, we can add similar functionality to
    the history panel. We will access a preferences value for each day of the week
    and update the `historyLabel` function to access it. Let''s see how:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The most complex part of the history panel is date handling. We will need to
    find out what date represents the beginning of the week. Since the time of day
    does not normally matter (daylight savings are not accounted for in this code),
    we can just manipulate the date portion. Using `Time.Weekday()`, we can find what
    day of the week it is and go from there. Go''s `time` package expects Sunday to
    be the first day of the week, so we need to handle this special case by subtracting
    6 days to find Monday. For all others, we subtract the length of the days (`24
    * time.Hour`) since Monday. The following code will allow us to find the date
    for our first history element:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we must update the `historyLabel` function, adding the date of the day
    in question, along with a reference to the preferences to use. From this, we can
    generate our `dateKey`, as we did for the total storage, and bind an `Int` value
    to the preferences. Then, we create another string conversion using the same format,
    but in this instance, we can simply use the `NewLabelWithData` constructor function:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can update the details of our history panel. First, we calculate the
    date for the Monday at the beginning of the current week, and then set a helper
    for the day''s length, which is not part of the Go `time` package. For each history
    element, we pass the date for each day by incrementing by a number of days since
    the start of the week:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'By running this final version of the app, we will see that it updates today''s
    value in the history panel:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The updated code will load the same interface that we had previously, but now,
    you will see that pressing **Add** will update the current day in the history
    panel as well:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Our completed water tracker app'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B16820.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Our completed water tracker app
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: You will see the history on this app build up over a week, as indicated in the
    preceding screenshot. If you want to edit the data, you can modify the preferences
    file directly. The preferences file's location varies, depending on your operating
    system. More information is available at [https://developer.fyne.io/tutorial/preferences-api](https://developer.fyne.io/tutorial/preferences-api).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the various APIs available within Fyne for
    managing and storing data. We explored the concept of data binding and saw how
    it can help keep a user interface up to date, while at the same time reduce the
    amount of code we need to write.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the Preferences API, which allows us to persist user data
    between application launches. When combined with the data binding code, this came
    with no additional complexity. By utilizing these features, we implemented an
    example application that manages data for tracking water consumption and stored
    it on our local device, ready to use the next day.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have covered the most common standard widgets and functionality
    in the Fyne toolkit. Sometimes, an application may require widgets or features
    that are not included. To support this, the toolkit allows us to extend the built-in
    components. We will explore this in the next chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
