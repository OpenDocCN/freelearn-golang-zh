- en: '*Chapter 6*: Data Binding and Storage'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned that widgets can be controlled manually
    by application code. As we start looking at more complex applications, it's common
    for developers to want to display or manipulate a dynamic data source. The Fyne
    toolkit provides data and storage APIs that automate a lot of this work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to explore the ways that data is handled within
    the Fyne toolkit. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Binding data to widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting data types for display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding complex data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data using the Preferences API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we will know how to make use of the data binding
    and storage APIs to create an app that helps track water consumption. It will
    store information on the local device and use APIs to explore how to minimize
    the coding required to manage data.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*, in that you must have the Fyne toolkit installed
    and a Go and C compiler working. For more information, please refer to the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Binding data to widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we explored widgets in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*, we saw how information can be gathered and presented.
    Each widget we looked at was configured manually, and accessing data that the
    user entered (such as with the `Entry` widget) required code to query the widget's
    state. The `fyne.io/fyne/data/binding` package provides functionality that supports
    automatically connecting widgets to data sources to handle this more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will explore what data binding is, why it is so
    useful, and how it is designed within the Fyne APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different approaches to data binding, and definitions can vary,
    depending on the toolkit that you are working with. In general, data binding allows
    the component of a graphical interface to have its display controlled by a separate
    data source. Moreover, it ensures that the graphical representation is always
    up to date with changes, and that user actioned changes within the user interface
    are synchronized back to the original data.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how .NET approaches its implementation at [https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview).
    Android also provides similar functionality, which is documented at [https://developer.android.com/topic/libraries/data-binding](https://developer.android.com/topic/libraries/data-binding).
  prefs: []
  type: TYPE_NORMAL
- en: Despite the various approaches taken by each toolkit, the basics of any successful
    data binding are that the graphical output is automatically updated based on the
    state of a separate data object. This is known as **unidirectional** binding,
    often known as a *one-way data flow*. This is sufficient for data display when
    the information comes from an external source. However, it is not sufficient if
    your application will be modifying the data. Complete data binding (**two-way**
    or **bidirectional**) ensures that as well as keeping presented data up to date,
    it will also update the source data if the user alters the presentation through
    some interactive widget.
  prefs: []
  type: TYPE_NORMAL
- en: All the data binding that's done in the Fyne toolkit is bidirectional, meaning
    that each connection that's made can read or write the data it is connected to.
    Widgets that are only used for display purposes will not make use of the ability
    to write the data, but an input widget such as an entry or a slider will push
    data changes out to connected bindings. There's an underlying data source for
    each data binding. We will look at what data types are supported in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Supported data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the main Go language, all the values in the Fyne data API are strongly
    typed â€“ this means that a data binding has a specific type of value. Each value
    matches a primitive Go type, ensuring that the compiler can check that these values
    are used in the correct way.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the Fyne data binding supports the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bool`: A boolean value can be `true` or `false`. This type uses a `bool` for
    its internal storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`: A floating-point number value, this uses the `float64` type for internal
    storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int`: A whole number value with positive and negative numbers, stored using
    the `int` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rune`: A representation of a single unicode character, backed by the `rune`
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`: A bindable version of the Go `string` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`: A mapping similar to `slice` or `array` that can contain a collection
    of a single type, indexed by an `int` offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`: A bindable version of the `map` primitive that can hold many types indexed
    by a `string` key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Struct`: A data binding similar to `map` where the keys represent exported
    elements of a developer defined `struct` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value type you use may be determined by the source data, or (if you are
    not bound to an existing data source) the output widgets you use. We will explore
    widget connections later in this section, but it is useful to know that we can
    convert types where needed. We will explore this later in the *Adapting data types
    for display* section.
  prefs: []
  type: TYPE_NORMAL
- en: When you have more complex data, such as a list or struct, you can still use
    the data binding API but with more advanced types, as discussed later in the *Binding
    complex data types* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned what data types are available, let's look at how to read
    and write data through a binding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, reading, and writing bound data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the basic data types provided by the binding API (`Bool`, `Float`,
    `Int`, `Rune`, and `String`) provide two constructors: one that creates a new
    variable from the Go zero value (using the `New...()` name), and another that
    binds to an existing variable (named `Bind...()`). It also provides `Get()` and
    `Set()` functions to manage data access. We''ll explore these in detail next while
    using the `Float` type as an example.'
  prefs: []
  type: TYPE_NORMAL
- en: NewFloat() Float
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a data binding using the `New...` constructor function will create
    a new piece of data with a standard value of zero. The returned object implements
    the `DataItem` interface, which enables binding. We'll look at this in more detail
    in the *Listening for changes* section, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: BindFloat(*float64) Float
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Bind...` constructor function creates a bindable data item using a pointer
    to the primitive value. Using this function, we can set default values that are
    non-zero. Additionally, the original variable can still be used to get and set
    the data in places where data binding is not supported. In the following code,
    we are creating a new data binding to a floating-point value that defaults to
    `0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `data` variable that was returned is a new data binding of the `Float` type
    initialized to `0.5`. If this binding is changed, it will write the new value
    back into the `f` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Up to Date with Source Variables
  prefs: []
  type: TYPE_NORMAL
- en: If you are binding to variables that exist outside the data binding constructor,
    such as in the previous example, it will also cause changes from the binding to
    update the original variable. If, however, you update the variable directly, it
    is important to inform the data binding. Call `data.Reload()` to notify the data
    binding that the value has changed, so that it can propagate the change event.
  prefs: []
  type: TYPE_NORMAL
- en: Get() (float64, error)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the current state of a data binding, simply call `Get()`. It will return
    the contents in one of Go's primitive data types. For a `Float` binding, this
    will be `float64`. If an error occurred when you accessed this value, then an
    error will be returned in the second parameter. Though unlikely at this stage,
    you will see how bindings can be combined to create more complex scenarios. There
    is no additional action as a result of this call.
  prefs: []
  type: TYPE_NORMAL
- en: Set(float64) error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To update the value of a binding, you must call its `Set(val)` function while
    passing the new value (as with the `Get()` return value, this is a primitive data
    type). As a result of the value changing (if the new value is different to the
    current state), the data binding will notify all the code that is registered with
    it. If an error occurred when you were setting the value, the binding notifications
    will not be triggered, and the error will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at how to request updates for changes that are occurring.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key concepts in data binding is that when a value changes, any item
    that is bound to it will update automatically. To do this, we need a mechanism
    that will notify us about changes. Before we learn how widgets do this automatically,
    we shall explore the implementation of this so that we can create our own code
    that stays up to date through data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DataItem interface to add a listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The core functionality of any data binding is the `DataItem` interface. Each
    of the binding data types shown earlier (in the *Supported data types* section)
    also implements this interface. The definition of `DataItem` allows us to add
    and remove listeners. These listeners are informed whenever a data item changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The definition shows how listeners are added and removed from any data item;
    this is how widgets can be informed of when data changes.
  prefs: []
  type: TYPE_NORMAL
- en: Current Values
  prefs: []
  type: TYPE_NORMAL
- en: When adding a listener to a `DataItem`, it will immediately be called with the
    current value stored. This enables any widget or program fragment that uses binding
    to be initialized correctly without additional code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw that listeners are of the `DataListener` type. We shall
    explore what this type is in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DataListener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each listener of a `DataItem` must implement the `DataListener` interface.
    By constructing a type that conforms to this definition, we can add, and later
    remove, the listener from the data items we depend on. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a single function is defined by the interface, `DataChanged()`.
    In most situations, the code that''s using this will want to simply provide the
    function directly. For situations such as these, we can use a helpful constructor
    function that takes a simple function and returns an instance of a `DataListener`.
    The resulting listener can be used as a parameter of the `AddListener` and `RemoveListener`
    functions. It will call the function that was specified when the data is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this knowledge, we can create a very simple data binding and watch for
    changes in its value. All we need to do is use one of the data binding constructors
    and call `AddListener`, passing the listener we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By running the preceding code, you will see that the callback is fired immediately
    with the current string value (in this case, the zero string, `""`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your computer speed, you may need to put a time delay at the end
    of the `main()` function as the application could exit before the data binding
    is processed (for example, `time.Sleep(time.Millisecond*100)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, it is simple to create a data binding and be
    notified when the data changes. We could also trigger a change by calling `val.Set("new
    data")`, and the callback would trigger again.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the preceding code being useful, the main usage for data bindings in
    Fyne is to connect widgets to data without having to write code that will copy
    information and watch for changes. Next, we'll learn how standard widgets operate
    with data bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Using data with standard widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous section, the data binding API allows us to create
    values that provide notifications when their content changes. As you might expect,
    the widgets provided in the Fyne toolkit understand bindings and can connect to
    them to display or update data. Let''s explore how this can be set up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by opening a new file in `package main` and creating a `makeUI()`
    function, as we have done previously. This time, we''ll start the method by declaring
    a new floating-point number as our data binding. Using `NewFloat()` will create
    a new binding that defaults to the zero value of `0.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a `ProgressBar` widget that is bound to this data source.
    This progress bar simply displays a value that is a `Float` data type we just
    created, we must use the `NewProgressBarWithData()` constructor function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To manipulate the data binding, we also want to include a `Slider`. As you
    saw in *, Widget Library and Themes*, this widget will display a value, using
    its current position, and allows the value to be changed by sliding. To set up
    this connection, we will use `NewSliderWithData()`, which takes additional parameters;
    that is, the permitted minimum and maximum values that can be sent into the data
    binding. We must then set the `Slider.Step` value (the gap between each step on
    the slider) to `0.01` so that we can cause fine-grained data changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition to the preceding one-way and two-way bindings, we can also use
    a version of one-way binding that is *write-only*. We do not need to connect the
    data to the widget in the same way we connected the last two widgets here (because
    there is no need for a listener for data changes). Instead, we can simply create
    a `Button` that will write to the data binding when tapped. We''ll use the familiar
    `NewButton()` constructor function here and pass in the tapped handler, which
    will set the value to `0.5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final line in our `makeUI` function will be returning the container that
    packs these elements in. In this case, we will use `container.NewVBox`, which
    aligns each element on top of the others:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete this example, we just need to create the usual `main()` function
    that creates a new `App` instance and open a window titled `Widget Binding`. The
    content from our `makeUI` function will be added and the relevant window will
    appear. Refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now run this example to see how these widgets behave when they''re
    all bound to the same data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the application appears, the slider and progress bar will be at the zero
    position. By dragging the slider, you will update the float that the slider and
    progress bar are bound to. As a result, you will notice that the progress bar
    moves. If you press the **Set to** **0.5** button, it will set the value to **0.5**,
    and the other widgets will both update to the halfway position, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 - Data bindings set to 0.5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 - Data bindings set to 0.5
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen the benefits of data binding for handling dynamic
    data, as well as the constraints of a strongly-typed API. Next, we will look at
    how to convert between types so that the data can be adapted for use in a wider
    variety of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting data types for display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the example we worked through in the previous section, we learned that it's
    possible to bind the same value to different widgets since both `Slider` and `ProgressBar`
    expect a `Float` value for their data. However, it is not always the case that
    these data types will align perfectly. Sometimes, we will need to perform conversions
    to connect to the widgets we wish to use. In this section, we will explore how
    to do so, starting with how we can include a label in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting types into strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many applications, it is common to use a `Label` or other string-based display
    to contain information in another format, such as an `int` or `float64`. With
    data bindings, this is no different, so the `binding` package provides conversion
    functions that can make this adaptation easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow on from the previous example, we could include a `Label` that displays
    the `float64` value, but to do so, we would need a `String` binding rather than
    a `Float`. To obtain this, we can use the `FloatToString` function in the binding
    package. Like all binding conversion functions, this takes a single parameter,
    the source binding, and returns a new binding that is of the correct type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the string binding we just obtained, we can then create a `Label`, as
    shown in the previous code fragment. This approach will render the value using
    a default format. In the case of a `Float` binding, this will use the `"%f"` format
    string, which is similar to `fmt.Printf` in terms of usage. If we want to specify
    our own format, perhaps with some leading text, we can do so using the `ToStringWithFormat`
    notation instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When using this updated code, the output label will contain text such as `Value`
    `is:` `0.50`, which is probably more meaningful to the users of your app. When
    specifying a format, be sure to include the appropriate format string for the
    source type, such as `%f` for `Float` or `%d` for `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: Although displaying a value that is not a string is by far the most common conversion
    requirement, we may need to access a variable of some number type that is stored
    in a string. We'll explore this next.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing values from the string type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, the data you are working with may not be in the desired format
    for the widgets you wish to use. When managing the conversion manually, you can
    do this as part of your own code â€“ simply extract the data, convert it, and then
    supply the parsed information to your widget. However, with data binding, we want
    to keep a direct connection to the source data, which means conversion needs to
    happen within the chain of data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the previous section, there are convenience methods that can help
    with this as well; they typically contain the phrase `StringTo` in their name.
    Let''s work with an example that has a `string` value that contains an `int` number.
    We don''t want to include manual code in the conversion, so we need to include
    a conversion in the chain, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As a result of this code, we have `binding.Int` that is reading the underling
    `string` data source and can now be used where a widget requires an `Int` as its
    data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a trivial example. Normally, when a number is stored as a string, it
    is because the value has some non-number element to it, such as a percentage that
    will include the trailing `%` symbol. When there is extra formatting in the string,
    we can still achieve the same outcome by using the `StringToIntWithFormat` version
    of the conversion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, in the format string, we needed to use a double percent to capture
    the percent symbol (`%%`). This is due to how the format strings work, but otherwise,
    this example is quite straightforward. Calling `intBind.Get()` will return `5`
    (with no error), and if the `strBind` value were to be changed to `25%`, then
    `IntBind.Get()` would return `25`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we managed to use data binding conversion functions to change
    source data into a different type of data so that it can be used in our user interface.
    Next, we will learn how to make sure that changes in the output (for a two-way
    binding) are propagated to the original data.
  prefs: []
  type: TYPE_NORMAL
- en: Propagating changes through conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples provided in the preceding section, we looked at complex chains
    of data binding so that we can convert source data for display purposes. This
    makes it much easier to use a variety of widgets connected to data binding without
    needing to write complex conversion code. However, we need to ensure that changes
    in the presented data are pushed back to the data source.
  prefs: []
  type: TYPE_NORMAL
- en: The great news here is that the conversions demonstrated in the *Formatting
    types into string* and *Parsing values from the string type* sections are full
    two-way data bindings. This means that we do not need to add any further code
    to propagate changes in the data. If an `IntToString` connection is made, then
    changes to the source `Int` will not only result in new values in the output `String`,
    but calling `Set()` on our `String` will cause a parsed integer to be pushed back
    to the original `Int` binding. This will depend on the string being correctly
    formatted, of course â€“ setting an invalid value will not propagate a change it
    will return an error instead.
  prefs: []
  type: TYPE_NORMAL
- en: The types we've explored in this section are used by standard widgets to display
    and manage dynamic data. In many applications, however, we have more complex data.
    In the next section, we will explore how to bind such data to our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Binding complex data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The types that we have used in our data binding exploration so far have been
    limited to mappings of the Go primitive types. This means that they represent
    simple variables with a single element. For many applications, it will be necessary
    to display more complex data, such as lists, maps, or even custom structs. In
    this section, we will look at how that can be done, starting with the `DataList`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Using lists of data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whether you wish to use data bindings to present data to a `widget.List` or
    a `widget.RadioGroup`, or if you are modeling your data with bindings that will
    be passed to your own widgets, the concept of a data list will be important. The
    data binding API defines `DataList` as a binding that provides additional `Length`
    and `GetItem(int)` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This generic definition means that a list can encapsulate a data type â€“ the
    `DataItem` instance returned by `GetItem()` could be a `String`, `Int`, or even
    another `DataList`. You can implement a `DataList` using the previous interface
    or you can use one of the type-based lists provided by Fyne. The `Length` method
    will always return the number of items in this list, while `GetItem` can be used
    to access the data binding at the specified index (as lists are ordered).
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the list's length (through `append`, `insert`, or `remove`) will
    trigger a callback on any listeners that are registered on the `DataList`. If
    the value of one of the items changes, it will trigger the change listener on
    the individual item rather than the containing list. Because of this, we can be
    clever about minimizing the impact of UI changes when a listener calls our code.
    We'll see how this process works in the following sections when we use a `StringList`
    to manage many items presented in a `List` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although a list can contain items of many different types, they will usually
    have all items of the same type, such as `String` or `Float`. For this purpose,
    there are helpful constructor functions, such as `NewFloatList` and `BindStringList`.
    You can build a new list with no content using the `New...List` methods, or you
    can bind to an existing slice in your Go code using `Bind...List` functions. For
    example, an empty string list might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that the standard lists provide additional `GetValue` and
    `SetValue` methods, to access values just like the standard singular bindings.
    There are also matching `Get` and `Set` methods that allow you to change the whole
    list. This allows us to use the primitive types to access and apply data when
    the list type is known. We can also do the same using a slice for storage that
    the data binds to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created a list binding, we can use it to display data in a
    widget that uses `DataList` bindings, such as `widget.List`.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common way we will typically use a data list is through the `List`
    widget. When using a data binding to manage a list widget, it will automatically
    add rows that match the length of the data. It will grow or shrink when the length
    changes. Additionally, the data items in the list can be bound to the items in
    the list, meaning that if a data value is updated, the list will automatically
    update. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `NewListWithData` constructor function to set data
    binding in the `List` widget. The first parameter, `DataList`, replaces the `Length`
    function, which is used in a regular `List` constructor. The second parameter,
    the function that sets up template items, remains the same. The callback in the
    last parameter for updating items is similar to a regular list, except the first
    parameter is now a `DataItem` instead of a `ListItemID`. We can keep the `Text`
    value of `Label` up to date by calling `Bind()` and passing the `DataItem` once
    it has been cast to the `binding.String` strong type. Applying a binding in this
    manner will implement the standard API, so we don't have to worry about how caching
    will impact this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Managing lists with different types is possible, as long as you are careful
    when casting `DataItem` to the correct binding type on each access. Doing this
    is outside the scope of this chapter. In the next section, you will learn how
    the technique can be applied as a map of data, which typically contains many different
    types of values.
  prefs: []
  type: TYPE_NORMAL
- en: Using data maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maps of data in the context of data binding are much like the Go `map` type,
    where `string` keys map to `DataItem` types; for example, `map[string]binding.DataItem`.
    The `DataMap` definition is similar to `DataList`, except that it uses `string`
    keys to identify child elements instead of an `int` ID. Instead of the `Length()`
    method, which returns how long the list is, it requires a `Keys()` function, which
    returns a string slice containing all of the keys present in the dataset. To find
    the number of items present in the data, you can simply call `len(DataMap.Keys())`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When an item is added or removed from `DataMap`, its listeners are fired. If
    the value of one of the items changes, it will trigger the change listener on
    the individual item rather than all of the DataMap listeners (as with items in
    a list, as mentioned in the previous section). Because maps normally have many
    different types of data in them, creating one using the standard API is a little
    different to creating a list, as we will see now. Of course, any type that implements
    the `DataMap` interface can be used in map data binding, but it is normally easier
    to use the provided implementations.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore how `DataMap` can be used in the following sections by creating
    one and setting its values before describing how they could be used for display.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DataMap`, unlike `DataList`, does not have type-specific implementations within
    Fyne. Since maps normally contain many different types, there is only one map
    implementation that maps `string` keys to `interface{}` values. This can be created
    as a new map in memory, or by binding to an existing `map` with the `map[string]interface{}`
    type signature. First, let''s look at creating a new map; the following code creates
    a new map using the `binding.NewUntypedMap()` constructor function and adds some
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same again but using an existing data source by making use of
    `binding.BindUntypedMap()` instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding samples do not check for data types, but if you are sure of the
    type for a key, you can perform type assertions like with a list. For example
    `values.GetItem("key").(Float)` would return a float data binding to the float64
    stored at the specified key. Let us now look at how this can be used for display.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, there are no built-in widgets that make use of the `DataMap`
    binding type. Its main usage is to allow your application to maintain many data
    bindings in a single binding type.
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that both the `Form` and `Table` widgets will add support for
    data binding in the near future. You can check out the latest API updates on the
    developer website at [https://developer.fyne.io/api/widget.html](https://developer.fyne.io/api/widget.html).
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave this section, we will explore one last trick â€“ mapping a custom
    `struct` to a `DataMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping structs to a data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When populating data in a `DataMap`, one of the common ways to do so would be
    by using a `struct` type. In this situation, there are a set of fields where a
    name maps to a value (as we've seen many times in this book already). As you can
    see, this definition matches nicely to the maps that we saw in the previous section.
    To save a lot of manual code, the data binding API provides a simple way to automatically
    create a `DataMap` from an existing struct variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other `binding.Bind...` method, we pass a pointer to the variable
    and it returns the bound data type. In this case, the Fyne code will use the names
    of each `struct` field as the keys of the map, and the values will be set to the
    variables of the struct. To be able to bind a field in a `struct`, it must be
    an exported field (the name must start with an uppercase letter). The following
    code demonstrates this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the keys and values all work as expected, but with the benefit
    that widgets can observe changes that have been made to the data and keep their
    display updated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored how data bindings can easily handle how dynamic data
    is displayed, we shall look at how to store user-generated data using the Preferences
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data using the Preferences API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common requirement for applications to store many pieces of information,
    such as user configuration options, current input field contents, and a history
    of opened files. Using files to store this information would require additional
    code to format the information for storage; using a database would require additional
    servers or dependencies for an application. To help with this, Fyne provides a
    **Preferences** API, similar to those used by iOS and Android developers.
  prefs: []
  type: TYPE_NORMAL
- en: Data that is stored as Fyne preferences can be accessed by any code in an application
    using a specific string identifier, known as a **key**. Each **value** that is
    stored has a specific type, so developers do not have to handle any conversion
    or type checking. Any time that this data changes, it will be saved for future
    use.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll learn how to manage data using the Preferences API and
    see how we can avoid having to manually manage user data.
  prefs: []
  type: TYPE_NORMAL
- en: Get and set values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each supported type (see the following section) provides functions so that we
    can get and set data of that type. We will explore this using a string. To read
    or write data using a string, we can use the `String()` function; to write a value,
    we can use `SetString()`.
  prefs: []
  type: TYPE_NORMAL
- en: To gain access to the preferences, we can use `App.Preferences()`. If you do
    not have access to the `App` instance that loaded the application, you can use
    `fyne.CurrentApp().Preferences()` instead, which will return the same reference.
    There is an additional requirement, however â€“ each application must declare a
    unique identifier for use in storage. To do this, we must change the `app.New()`
    constructor function to `app.NewWithID()`, passing a suitable unique identifier.
    Typically, the unique ID will be in reverse DNS format, and must match the identifier
    you will use during distribution (see [*Chapter 9*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219),
    *Bundling Resources and Preparing for Release,* for more details). For example,
    you can use `com.example.myapp` for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet sets up an application with a (relatively) unique
    identifier and accesses the standard preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can insert the preceding code into the usual `main()` function (for a more
    complete listing, please go to the *Implementing a water consumption tracker*
    section). Notice that we used a single `string` value for the key â€“ this helps
    us avoid making mistakes if typing out the key for each access. Running it will
    produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This quick example demonstrates string access, but there are other types we
    can use as well. We'll look at some of these in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Supported types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s possible to store any type of data using just the string methods illustrated,
    but the API is designed to help us avoid the complexities of formatting and parsing
    data in that way. Due to this, there are different types supported by the Fyne
    preferences code. At the time of writing, the supported types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`: Stores a simple boolean (`true` or `false`) value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: Numbers that need a floating-point value can be stored using a `float`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: For whole numbers, use the `int` functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: As we used previously, a simple `string` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these types follow the same naming convention that we saw in the previous
    code. For example, you could set an integer using `SetInt()` or get a boolean
    value using `Bool()`.
  prefs: []
  type: TYPE_NORMAL
- en: By using Go semantics, the values that are returned will have zero values if
    no item was previously stored. It is possible to set different defaults using
    fallback values.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For situations where the default value of a property should not be the standard
    zero value (defined by Go), each `Get...` function has a `WithFallback` version;
    for example, `StringWithFallback()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the code in the previous example so that it just uses the get
    and fallback methods, we can see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this version of the code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With these methods, we can handle data with sensible defaults and save changes
    for future runs of the application. Sometimes, we will need to remove old data;
    we can do that too.
  prefs: []
  type: TYPE_NORMAL
- en: Removing old data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing data for users is important, but so is the ability to delete it when
    requested. To do so, the Preferences API provides one final method, `RemoveValue`,
    that will do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding the following code to the end of our previous example, the values
    that were set will be cleaned out, meaning that on the next run, you will see
    the default values if the application is started a second time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code also prints out the value once it has completed, ensuring
    that the item has been removed from the preferences. Running all the code from
    this section together will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have seen how we can trivially store and access elements of data
    to be used in our apps. However, the Preferences API becomes even more powerful
    when we combine it with the data binding API we saw at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `binding` package, which we focused on earlier in this chapter, we
    can create data bindings that are connected to preference storage instead of regular
    variables. This provides us with the huge benefit that any time the setting of
    a value is triggered, it will be stored, and when the application is started again,
    the previous value will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access this functionality, we can use the functions whose names start with
    `BindPreference`, such as `BindPreferenceString()`. There is one function for
    each of the types supported by the Preference API, as listed earlier in this section.
    Each of these methods accepts a string parameter, which is the key string that
    we used in the previous code excerpts. Code that wishes to continue using the
    Preferences API can continue to do so as before, but using these data bindings
    ensures that new values are pushed directly to the widget that the binding is
    connected to. The bindings that are returned from a preferences bind use the same
    types as other data binding APIs, so you can get the `string` value of a preference
    item through its binding using `Get()`, as you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will access the same preferences value but through the data
    binding framework, making it easy to keep widgets up to date with user preferences.
    The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These bindings can also be chained, as with the earlier definitions, which
    means you can obtain a `String` binding to a preference value that is an integer
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to have multiple widgets, connected to multiple data bindings,
    all read and write the same preference value. If you use the same key to create
    many bindings to a preference, then they will all stay up to date when the value
    changes. We will see this in action in the example that follows.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have explored the data binding and Preference APIs and how they
    can, individually or together, vastly reduce the amount of code required to manage
    data in an application. Let's utilize this knowledge and implement an example
    application that can help us track our daily water consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a water consumption tracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The APIs that we have explored in this chapter can be helpful for most applications.
    To learn how we can add preference storage to a simple application, we will explore
    another example project. This time, we will create a tracker that can track water
    consumption over 1 week.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start working with data binding APIs, we will construct the basic
    user interface. The aim is to put today''s total in large text at the top of a
    window, with the date below. We will follow this with the controls to add water
    to the current total. Under this, we will add another section that shows the values
    for the current week. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start, as usual, by defining a `makeUI` function, which builds the
    user interface. To start, we will define the large label that will be used to
    show the total by setting the font to `42` points, center aligning it, and using
    the `theme` primary color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create another, regular label for the date to be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next few elements add controls, that support adding a value to the current
    water consumption. This could be a button that simply adds a specific number (for
    example, *250 ml*), but to be more flexible, we will allow the user to specify
    an amount. To do this, we will create an `Entry` field that is pre-filled with
    `250`. Then, we will add a helper `ml` label after it and define a new button,
    labeled `Add`, that will action this later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before creating the history layout we define a helpful `historyLabel` function.
    This will create a new label that simply contains `0ml` and aligns it to the right.
    The data here will be added later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last content element we''ll add is the history information. In this case,
    we can construct this using a grid container with two columns. On the left, we
    will show the day of the week, while on the right, we will show a label for the
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To return the result of our interface building from this function, we can create
    a new vertical box. Inside this box, we must stack the total `label`, `date`,
    a horizontal grid that aligns the `input` and the `add` button, and lastly a `Card`
    widget containing the history content, along with a header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this example to run, we must create the typical `main()` function. This
    time, we want it to create a window titled `Water Tracker` and set the `makeUI()`
    return to the content before showing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run this example in the usual way from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding command should result in the following interface appearing
    (when using the light theme):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 â€“ The empty user interface](img/Figure_6.2_B16820.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 â€“ The empty user interface
  prefs: []
  type: TYPE_NORMAL
- en: This interface looks suitable, but it does not do anything yet. In the next
    section, we'll start creating some functionality by binding the `total` label
    to a value that can be incremented using the **Add** button.
  prefs: []
  type: TYPE_NORMAL
- en: Binding data to the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start making the user interface functional, we will use data binding so
    that the header section of the app manages a single integer value representing
    how much water has been consumed in a day. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to declare a new binding variable that is of the `binding.Int`
    type. We must add the following line to the beginning of our `makeUI` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add an implementation of the button tap handling. To action the
    number increment, we must replace the old `func() {}` function with the following
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will parse an integer from the `amount.` `Text` field and add it to the
    total. It does this by calling `Get()`, which finds the current value, and then
    `Set()`, with the increment applied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we want to display the integer value in a label, with `String` binding
    that is based on the `Int` function we already created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have used `canvas.Text` to define our large, colored text, we must
    bind these values. However, there isn''t a helpful `WithData` constructor function
    for this, so we must apply the binding values manually. Let''s create a new `DataListener`
    that will be called when the values change. Inside the callback, we set the text
    and request a refresh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With these changes made, we can run the app to see the changes in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The user interface looks the same when it is loaded, but when we tap the **Add**
    button, the total value will update, increasing by the number by the value in
    the entry field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 â€“ Showing a bound value](img/Figure_6.3_B16820.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 â€“ Showing a bound value
  prefs: []
  type: TYPE_NORMAL
- en: If you quit this version of the app and open it again, you will notice that
    the value is forgotten. We can fix this by using the Preferences API, which we
    will do now.
  prefs: []
  type: TYPE_NORMAL
- en: Storing with preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remember values between application launches, we can make use of the Preferences
    API. This allows us to store values without needing to manage file access or databases.
    In this section, we will connect our data binding to the Preferences API so that
    it will automatically remember the data when it changes. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to store preferences, we need to allocate a key for each data item.
    In this example, each number is the total for a day, so we will use the date to
    identify the stored item. We need a new function, `dateKey`, that will format
    a string from any given time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be able to use the Preference API, we need to make sure that our application
    has a unique identifier. To do this, we will use `app.NewWithID` instead of `app.New`.
    The ID should be globally unique. Then, we need to retrieve the application `Preferences`
    instance and pass it into our `makeUI` function so that it can be used in the
    bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will update the `Int` binding so that it can access preferences instead
    of creating a new value in memory. We will update `makeUI` so that it accepts
    a preferences instance and then change our binding creation so that it uses `BindPreferenceInt`.
    This constructor requires the key of the value it needs to access (which is generated
    by the `dateKey` function we created) and the preferences instance to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are completing the top section of our app, we should also set the
    correct date. Simply change the label constructor so that it passes a formatted
    date string, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the app again, you will see the same interface (with a corrected
    date display). If you add some value to today's total and then restart the app,
    you will notice that the value is remembered.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have completed the basic functionality of our app, but the history
    fields are still blank. Building on the previous functionality, we can show the
    stored values from previous days.
  prefs: []
  type: TYPE_NORMAL
- en: Adding history
  prefs: []
  type: TYPE_NORMAL
- en: 'With the main data binding code working, we can add similar functionality to
    the history panel. We will access a preferences value for each day of the week
    and update the `historyLabel` function to access it. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most complex part of the history panel is date handling. We will need to
    find out what date represents the beginning of the week. Since the time of day
    does not normally matter (daylight savings are not accounted for in this code),
    we can just manipulate the date portion. Using `Time.Weekday()`, we can find what
    day of the week it is and go from there. Go''s `time` package expects Sunday to
    be the first day of the week, so we need to handle this special case by subtracting
    6 days to find Monday. For all others, we subtract the length of the days (`24
    * time.Hour`) since Monday. The following code will allow us to find the date
    for our first history element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must update the `historyLabel` function, adding the date of the day
    in question, along with a reference to the preferences to use. From this, we can
    generate our `dateKey`, as we did for the total storage, and bind an `Int` value
    to the preferences. Then, we create another string conversion using the same format,
    but in this instance, we can simply use the `NewLabelWithData` constructor function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can update the details of our history panel. First, we calculate the
    date for the Monday at the beginning of the current week, and then set a helper
    for the day''s length, which is not part of the Go `time` package. For each history
    element, we pass the date for each day by incrementing by a number of days since
    the start of the week:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By running this final version of the app, we will see that it updates today''s
    value in the history panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The updated code will load the same interface that we had previously, but now,
    you will see that pressing **Add** will update the current day in the history
    panel as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 â€“ Our completed water tracker app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 â€“ Our completed water tracker app
  prefs: []
  type: TYPE_NORMAL
- en: You will see the history on this app build up over a week, as indicated in the
    preceding screenshot. If you want to edit the data, you can modify the preferences
    file directly. The preferences file's location varies, depending on your operating
    system. More information is available at [https://developer.fyne.io/tutorial/preferences-api](https://developer.fyne.io/tutorial/preferences-api).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the various APIs available within Fyne for
    managing and storing data. We explored the concept of data binding and saw how
    it can help keep a user interface up to date, while at the same time reduce the
    amount of code we need to write.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the Preferences API, which allows us to persist user data
    between application launches. When combined with the data binding code, this came
    with no additional complexity. By utilizing these features, we implemented an
    example application that manages data for tracking water consumption and stored
    it on our local device, ready to use the next day.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have covered the most common standard widgets and functionality
    in the Fyne toolkit. Sometimes, an application may require widgets or features
    that are not included. To support this, the toolkit allows us to extend the built-in
    components. We will explore this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
