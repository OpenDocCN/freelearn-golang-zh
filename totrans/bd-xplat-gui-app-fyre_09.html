<html><head></head><body>
		<div id="_idContainer106">
			<h1 id="_idParaDest-192"><em class="italic"><a id="_idTextAnchor193"/>Chapter 7</em>: Building Custom Widgets and Themes</h1>
			<p>Over the course of the previous chapters, we have seen a lot of functionality that comes as part of the Fyne toolkit. Many applications will, however, benefit from components or functionality that are not included as standard. To be able to support an easy-to-use toolkit API and at the same time support additional functionality, the Fyne toolkit provides the ability to use custom code alongside regular widgets. </p>
			<p>In this chapter, we will explore how custom data can be used in a Fyne app, and how custom styling can be added using code or by loading custom themes. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Extending existing widgets</li>
				<li>Creating a component from scratch</li>
				<li>Adding a custom theme</li>
			</ul>
			<p>At the end of the chapter, we will see how to make use of the custom widget and theme capabilities to create an app that presents a conversation history that could be used for various instant messenger protocols. It will demonstrate how a new widget can complement the standard set, and also how a custom theme can add some individuality to an application.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor194"/>Technical requirements</h1>
			<p>This chapter has the same requirements as <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Windows, Canvas, and Drawing</em>: you will need to have the Fyne toolkit installed and a working Go and C compiler. For more information, please refer to the previous chapter.</p>
			<p>The full source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07</a>.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor195"/>Extending existing widgets</h1>
			<p>The <a id="_idIndexMarker477"/>standard widgets that we explored in <a href="B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a>, <em class="italic">Widget Library and Themes,</em> all have minimal APIs to define commonly required functionality. To support the addition of more advanced functionality, each Fyne widget can be extended by application developers. In this section, we will see how widgets can be enhanced by overriding their existing functionality or adding new behavior.</p>
			<p>As we can see in the following diagram, extended widgets, as well as custom widgets, can be included in a container alongside standard widgets and canvas objects:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/Figure_7.1_B16820.jpg" alt="Figure 7.1 – Extended and custom widgets can be used alongside standard elements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Extended and custom widgets can be used alongside standard elements</p>
			<p>An extended widget will embed an existing widget and provide replacement, or enhanced, functionality around it. Custom widgets, which we will see later in this chapter, implement the complete <strong class="source-inline">Widget</strong> interface, and so are not constrained by the designs of a standard widget.</p>
			<p>Building custom widgets offers more flexibility; however, it requires a lot more code. Instead, we will start by learning how to extend existing widgets to add our own functionality. Once we have understood how to extend existing widgets, we will learn more about custom components in the <em class="italic">Creating a component from scratch</em> section.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor196"/>Overriding widget functions</h2>
			<p>The first <a id="_idIndexMarker478"/>way that we will explore how to extend an existing widget is by overriding some of its functionality. This is normally accomplished by embedding a widget and creating a method of the same signature that Fyne would call into it, essentially replacing the built-in method with our own. When taking this approach, it is common to want the original functionality to execute after we have processed our override. To do this, our extended widget can call the original method from our own method. </p>
			<p>To illustrate this, we will create an extended <strong class="source-inline">Entry</strong> widget that performs an action when the <strong class="bold">Return</strong> key is pressed. We call this <strong class="source-inline">submitEntry</strong>, and will enter the code in <strong class="source-inline">submitentry.go</strong>, as follows:</p>
			<ol>
				<li>We first create a new struct that will define our custom type, naming it <strong class="source-inline">submitEntry</strong>. Inside it, we add an anonymous field, <strong class="source-inline">widget.Entry</strong>, which means that we will inherit all the fields and functionality of an <strong class="source-inline">Entry</strong> widget. Note that this is not a pointer:<p class="source-code">type submitEntry struct {</p><p class="source-code">    widget.Entry</p><p class="source-code">}</p></li>
				<li>Next, we create a constructor function, <strong class="source-inline">newSubmitEntry</strong>. This step is not strictly required, but it is essential that we call <strong class="source-inline">ExtendBaseWidget()</strong>, and so a function like this is usually the best approach. We need to pass the new widget as a parameter to <strong class="source-inline">ExtendBaseWidget</strong> so that the toolkit code knows that we are providing a replacement to the embedded widget:<p class="source-code">func newSubmitEntry() *submitEntry {</p><p class="source-code">    e := &amp;submitEntry{}</p><p class="source-code">    e.ExtendBaseWidget(e)</p><p class="source-code">    return e</p><p class="source-code">}</p></li>
				<li>We can then add our own, overriding, functionality. In this case, we replace the <strong class="source-inline">TypedKey</strong> method, which is called when a key (physical or virtual) has been tapped to trigger an event. If we wanted to intercept characters, we would use <strong class="source-inline">TypedRune</strong>. In our method, we check whether the key is <strong class="source-inline">KeyReturn</strong>, and if it is, we take a custom action. If any other key is pressed, we call the <strong class="source-inline">TypedKey</strong> function of the embedded <strong class="source-inline">Entry</strong> widget (passing the same <strong class="source-inline">KeyEvent</strong>), which ensures that our widget continues to function as a text entry:<p class="source-code">func (s *submitEntry) TypedKey(k *fyne.KeyEvent) {</p><p class="source-code">    if k.Name == fyne.KeyReturn {</p><p class="source-code">        log.Println("Submit data", s.Text)</p><p class="source-code">        s.SetText("")</p><p class="source-code">        return</p><p class="source-code">    }</p><p class="source-code">    s.Entry.TypedKey(k)</p><p class="source-code">}</p></li>
				<li>Lastly, we <a id="_idIndexMarker479"/>create the usual <strong class="source-inline">main</strong> function. In this case, we simply set the content to our new <strong class="source-inline">submitEntry</strong> widget:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("Submit Entry")</p><p class="source-code">    w.SetContent(newSubmitEntry())</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>We can now run the sample with the <strong class="source-inline">go run</strong> command:<p class="source-code"><strong class="bold">Chapter07$ go run submitentry.go</strong></p></li>
			</ol>
			<p>You will see a window containing what looks like a regular entry widget, but if you hit the <strong class="bold">Return</strong> key when typing, you will see a log message in the console and the content will clear:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/Figure_7.2_B16820.jpg" alt="Figure 7.2 – The submitEntry struct looks like a regular widget.Entry&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – The submitEntry struct looks like a regular widget.Entry</p>
			<p>We have seen how to override an existing function of a widget, but it is also possible to add new features, as we will see when we learn how to make a tappable icon in the next section.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Adding new behavior</h2>
			<p>The <a id="_idIndexMarker480"/>second way that developers can extend existing widgets is to add new functionality by implementing new handlers around an embedded type. In this example, we will create a tappable icon. This extended <strong class="source-inline">widget.Icon</strong> will behave like a button with a single icon, but it does not include the border or tap animations of a regular button (which may not be desired in some situations). We start this example by creating <strong class="source-inline">tapicon.go</strong> and proceeding as described:</p>
			<ol>
				<li value="1">Once again, we start with a custom struct that embeds the existing widget, this time a <strong class="source-inline">widget.Icon</strong>. As before, this should not be a pointer type. In this struct, we will also include a <strong class="source-inline">func()</strong> to store the callback that should be run when the icon is tapped:<p class="source-code">type tapIcon struct {</p><p class="source-code">    widget.Icon</p><p class="source-code">    tap func()</p><p class="source-code">}</p></li>
				<li>We create a constructor function again, primarily to ensure that <strong class="source-inline">ExtendBaseWidget</strong> is called. Into this we will pass a <strong class="source-inline">fyne.Resource</strong>, which specifies the icon to show, and a <strong class="source-inline">func()</strong>, which will be used to call when the icon is tapped. The resource is passed into the original icon as it will still handle the rendering:<p class="source-code">func newTapIcon(res fyne.Resource, fn func()) *tapIcon {</p><p class="source-code">     i := &amp;tapIcon{tap: fn}</p><p class="source-code">     i.Resource = res</p><p class="source-code">     i.ExtendBaseWidget(i)</p><p class="source-code">     return i</p><p class="source-code">}</p></li>
				<li>To add the<a id="_idIndexMarker481"/> tapped functionality, all we need to do is implement the <strong class="source-inline">fyne.Tappable</strong> interface, which requires a single method, <strong class="source-inline">Tapped()</strong>, taking a <strong class="source-inline">*PointEvent</strong> parameter. We simply execute the callback that was saved earlier inside this function, as long as one was set:<p class="source-code">func (t *tapIcon) Tapped(_ *fyne.PointEvent) {</p><p class="source-code">     if t.tap == nil {</p><p class="source-code">         return</p><p class="source-code">     }</p><p class="source-code">     t.tap()</p><p class="source-code">}</p></li>
				<li>For this demonstration, we will create a basic user interface that holds three of our <strong class="source-inline">tapIcon</strong> instances, simulating the home, back, and next navigation items from an app. To do this, we create a new <strong class="source-inline">makeUI</strong> function that aligns them in a horizontal box:<p class="source-code">func makeUI() fyne.CanvasObject {</p><p class="source-code">    return container.NewHBox(</p><p class="source-code">        newTapIcon(theme.HomeIcon(), func() {</p><p class="source-code">            log.Println("Go home")</p><p class="source-code">        }),</p><p class="source-code">        newTapIcon(theme.NavigateBackIcon(), func() {</p><p class="source-code">            log.Println("Go back")</p><p class="source-code">        }),</p><p class="source-code">        newTapIcon(theme.NavigateNextIcon(), func() {</p><p class="source-code">            log.Println("Go forward")</p><p class="source-code">        }),</p><p class="source-code">    )</p><p class="source-code">}</p></li>
				<li>To complete this example, we create a new <strong class="source-inline">main</strong> function that will set the window content to the result of a <strong class="source-inline">makeUI()</strong> call:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("Navigate")</p><p class="source-code">    w.SetContent(makeUI())</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>We can now run <a id="_idIndexMarker482"/>this whole example to see the resulting widgets in action:<p class="source-code"><strong class="bold">Chapter07$ go run tapicon.go</strong></p><p>When the application runs, you will see a window like the following that renders the icons. You can tap them and see the log output appearing when you do so. We have just recreated button widgets without the additional borders, padding, and tap animations:</p></li>
			</ol>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/Figure_7.3_B16820.jpg" alt="Figure 7.3 – The tappable icons in a horizontal box&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – The tappable icons in a horizontal box</p>
			<p>We have explored<a id="_idIndexMarker483"/> some different ways to extend existing widgets, but sometimes we want to create something completely new. In these situations, it is possible to build a widget from scratch, which we will do next.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor198"/>Creating a component from scratch</h1>
			<p>Instead of building a <a id="_idIndexMarker484"/>new component by extending an existing widget, as we did in the previous section, we could build one from scratch. Any component that implements the <strong class="source-inline">fyne.Widget</strong> interface can be used as a widget in a Fyne application. To ease development, there is a <strong class="source-inline">widget.BaseWidget</strong> definition that we can inherit from. Let's start by defining the behavior of a new widget—the three-state checkbox.</p>
			<p>Defining widget behavior</p>
			<p>The API of a Fyne widget is based <a id="_idIndexMarker485"/>on behavior rather than how it looks. To begin our widget development, we will therefore define the states that our three-state checkbox can take and how a user can interact with it. We will create <strong class="source-inline">threestate.go</strong> and start coding:</p>
			<ol>
				<li value="1">Firstly, we must define a new type, <strong class="source-inline">CheckState</strong>, which will hold the three different states of our new checkbox widget. As we are building a reusable component, it is a good idea to export the types that are required, such as <strong class="source-inline">CheckState</strong> and the various states it defines. The usage of <strong class="source-inline">iota</strong> defines the first index and the following states will increment from that value:<p class="source-code">type CheckState int</p><p class="source-code">const (</p><p class="source-code">    CheckOff CheckState = iota</p><p class="source-code">    CheckOn</p><p class="source-code">    CheckIndeterminate</p><p class="source-code">)</p></li>
				<li>We then define the <a id="_idIndexMarker486"/>core of the new component, calling it <strong class="source-inline">ThreeStateCheck,</strong> and setting it to inherit the basic widget behavior from <strong class="source-inline">widget.BaseWidget</strong>. Using <strong class="source-inline">BaseWidget</strong> is optional but it saves some coding. We add a field named <strong class="source-inline">State</strong> that will hold the current state of the check widget:<p class="source-code">type ThreeStateCheck struct {</p><p class="source-code">    widget.BaseWidget</p><p class="source-code">    State CheckState</p><p class="source-code">}</p></li>
				<li>Next, we create a constructor  function for this new type. As with previous examples, we need to call <strong class="source-inline">ExtendBaseWidget</strong>; in this case, the basic functionality that we have inherited is set up correctly:<p class="source-code">func NewThreeStateCheck() *ThreeStateCheck {</p><p class="source-code">    c := &amp;ThreeStateCheck{}</p><p class="source-code">    c.ExtendBaseWidget(c)</p><p class="source-code">    return c</p><p class="source-code">}</p></li>
				<li>The last behavior element of this type is its ability to respond to tap events. We set up a <strong class="source-inline">Tapped</strong> handler, just as we did with the tappable icon in the previous section. This time, we will rotate the three states of this widget, wrapping to <strong class="source-inline">CheckOff</strong> if the previous state was <strong class="source-inline">CheckIndeterminate</strong>:<p class="source-code">func (c *ThreeStateCheck) Tapped(_ *fyne.PointEvent) {</p><p class="source-code">    if c.State == CheckIndeterminate {</p><p class="source-code">        c.State = CheckOff</p><p class="source-code">    } else {</p><p class="source-code">        c.State++</p><p class="source-code">    }</p><p class="source-code">    c.Refresh()</p><p class="source-code">}</p></li>
			</ol>
			<p>That is all that we need<a id="_idIndexMarker487"/> to write to define the behavior of this new widget. However, because it is a new component (instead of an extension of an existing widget), we must also define how it will be rendered, which we will do next.</p>
			<p>Implementing rendering details</p>
			<p>For a new <a id="_idIndexMarker488"/>widget to be complete, it must also define how it will be rendered. This requires a new type that implements <strong class="source-inline">fyne.WidgetRenderer</strong>, as we will implement ahead. This new type must be returned from a <strong class="source-inline">CreateRenderer</strong> function on the widget implementation as well, as you will see in the code ahead. This renderer will use one of three checkbox icons—two are built into the Fyne theme and the third we will provide in this code base. Note that extra resources like this should be bundled for distribution, which will be discussed in detail in <a href="B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219"><em class="italic">Chapter 9</em></a>, <em class="italic">Bundling Resources and Preparing for Release,</em> in the <em class="italic">Bundling assets</em> section:</p>
			<ol>
				<li value="1">To start the renderer definition, we create a new type named <strong class="source-inline">threeStateRender</strong>; this should not be exported, as renderer details are private. This will hold a reference to the <strong class="source-inline">ThreeStateCheck</strong> that it is rendering, as well as a <strong class="source-inline">canvas.Image</strong> that will display one of the three icons used for our check widget:<p class="source-code">type threeStateRender struct {</p><p class="source-code">    check *ThreeStateCheck</p><p class="source-code">    img   *canvas.Image</p><p class="source-code">}</p></li>
				<li>Just as if we were defining a layout for a container, we need to define how elements of a widget renderer are sized and positioned. In this example, we will simply specify that our<a id="_idIndexMarker489"/> checkbox icons should be set to <strong class="source-inline">theme.IconInlineSize</strong> to be consistent with other widgets. We define this as our <strong class="source-inline">MinSize</strong> and use the same value to size our widget when it is asked to define a <strong class="source-inline">Layout</strong>:<p class="source-code">func (t *threeStateRender) MinSize() fyne.Size {</p><p class="source-code">    return fyne.NewSize(theme.IconInlineSize(),</p><p class="source-code">       theme.IconInlineSize())</p><p class="source-code">}</p><p class="source-code">func (t *threeStateRender) Layout(_ fyne.Size) {</p><p class="source-code">    t.img.Resize(t.MinSize())</p><p class="source-code">}</p></li>
				<li>To complete our renderer, we must also define the additional methods: the <strong class="source-inline">Destroy</strong> (called when this renderer is no longer needed), <strong class="source-inline">Objects</strong> (which returns the list of graphical elements), and <strong class="source-inline">Refresh</strong> (which is called if a state changes) methods. These methods are relatively simple—most are empty, and the <strong class="source-inline">Refresh</strong> method simply calls a new <strong class="source-inline">updateImage</strong> method, which is defined in the next step:<p class="source-code">func (t *threeStateRender) Destroy() {</p><p class="source-code">}</p><p class="source-code">func (t *threeStateRender) Objects() []fyne.CanvasObject {</p><p class="source-code">    return []fyne.CanvasObject{t.img}</p><p class="source-code">}</p><p class="source-code">func (t *threeStateRender) Refresh() {</p><p class="source-code">    t.updateImage()</p><p class="source-code">}</p></li>
				<li>The key to<a id="_idIndexMarker490"/> ensuring that the widget is up to date is the selection of the right image for the current state. We do this in a new <strong class="source-inline">updateImage</strong> method, described in the following code: <p class="source-code">func (t *threeStateRender) updateImage() {</p><p class="source-code">    switch t.check.State {</p><p class="source-code">    case CheckOn:</p><p class="source-code">         t.img.Resource = theme.CheckButtonCheckedIcon()</p><p class="source-code">    case CheckIndeterminate:</p><p class="source-code">         res, _ := fyne.LoadResourceFromPath(</p><p class="source-code">             "indeterminate_check_box-24px.svg")</p><p class="source-code">         t.img.Resource = theme.NewThemedResource(res)</p><p class="source-code">    default:</p><p class="source-code">         t.img.Resource = theme.CheckButtonIcon()</p><p class="source-code">    }</p><p class="source-code">    t.img.Refresh()</p><p class="source-code">}</p><p>It simply checks the state and picks a resource to display. In the normal states, we can use built-in icons from the theme, but for our new indeterminate state, we must load our own resource. As we noted earlier in this section, the asset should be bundled, but we will explore this in more detail in <a href="B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219"><em class="italic">Chapter 9</em></a>, <em class="italic">Bundling Resources and Preparing for Release</em>.</p></li>
				<li>The last part of writing a <strong class="source-inline">WidgetRenderer</strong> is to return it from the <strong class="source-inline">CreateRenderer</strong> method defined on the widget that we have created: <p class="source-code">func (c *ThreeStateCheck) CreateRenderer()</p><p class="source-code">    fyne.WidgetRenderer {</p><p class="source-code">        r := &amp;threeStateRender{check: c, img: </p><p class="source-code">            &amp;canvas.Image{}}</p><p class="source-code">        r.updateImage()</p><p class="source-code">        return r</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we set<a id="_idIndexMarker491"/> up the renderer and pass it a <strong class="source-inline">canvas.Image</strong> instance that it can use to display. We then call the <strong class="source-inline">updateImage</strong> method that we defined earlier to ensure that the initial state is rendered correctly:</p>
			<ol>
				<li value="1">To be able to run this demo, all we need to do is add the usual <strong class="source-inline">main</strong> function. This time, we will set the content to a single three-state checkbox using <strong class="source-inline">NewThreeStateCheck()</strong>:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("Three State")</p><p class="source-code">    w.SetContent(NewThreeStateCheck())</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>We can now run the code as usual with the <strong class="source-inline">go run</strong> command:<p class="source-code"><strong class="bold">Chapter07$ go run threestate.go </strong></p></li>
			</ol>
			<p>Running the application will display the first window in Figure 7.4. Tapping the icon will rotate the checkbox through the three states that are illustrated:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/Figure_7.4_B16820.jpg" alt="Figure 7.4 – The three states of our custom checkbox&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – The three states of our custom checkbox</p>
			<p>We have now explored the various ways to extend widgets to add new behavior and to create completely new components. As you can see from the figures in the chapter so far, they all look similar because they respect the current theme. In the next section, we will see how to make application-wide style changes using a custom theme.</p>
			<p>Adding a custom theme</p>
			<p>To bring some individual <a id="_idIndexMarker492"/>style or brand identity to an application, it can be useful to define a custom theme. This is a powerful feature, but should be used carefully. The selection of colors can significantly impact the readability of text elements and icons. Additionally, users of Fyne applications are allowed to choose between light and dark modes, so it is important that your theme reflects this choice where possible.</p>
			<p>There are two ways that developers can create a custom theme—either by defining a new theme from scratch by implementing the <strong class="source-inline">Theme</strong> interface, or by inheriting from the standard theme. Each have their own benefits, and so we will explore both, starting with looking at creating a brand new theme.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/>Implementing the theme interface</h2>
			<p>All themes in <a id="_idIndexMarker493"/>Fyne are provided by implementing the <strong class="source-inline">fyne.Theme</strong> interface (much like any widget will implement <strong class="source-inline">fyne.Widget</strong>). The interface requires us to provide four methods that are used to look up the details of a theme. These methods are as follows:</p>
			<p class="source-code">type Theme interface {</p>
			<p class="source-code">     Color(ThemeColorName, ThemeVariant) color.Color</p>
			<p class="source-code">     Font(TextStyle) Resource</p>
			<p class="source-code">     Icon(ThemeIconName) Resource</p>
			<p class="source-code">     Size(ThemeSizeName) float32</p>
			<p class="source-code">}</p>
			<p>As you can guess, these methods return the color, size, icon, and fonts provided by a theme. The four signatures vary, but the meanings are as follows:</p>
			<ul>
				<li><strong class="source-inline">Color</strong>: The color lookup uses two parameters: the first is the name of the requested color (which we will explore more later) and the second is <strong class="source-inline">ThemeVariant</strong>. At the time of writing, there are two variants: <strong class="source-inline">theme.VariantLight</strong> and <strong class="source-inline">theme.VariantDark</strong>. This allows a theme to adapt to light and dark mode, although doing so is optional.</li>
				<li><strong class="source-inline">Size</strong>: This lookup takes only the size name parameter. It is one of the <strong class="source-inline">ThemeSizeName</strong> constants, such as <strong class="source-inline">theme.SizeNamePadding</strong> or <strong class="source-inline">theme.SizeNameText</strong>.</li>
				<li><strong class="source-inline">Font</strong>: This lookup takes <strong class="source-inline">TextStyle</strong> as its lookup parameter. A theme can choose which font to return for the various styles, such as <strong class="source-inline">TextStyle{Bold: true}</strong> for bold. The theme should also check the <strong class="source-inline">Italic</strong> and <strong class="source-inline">Monospaced</strong> fields. Other options may be added in future releases.</li>
				<li><strong class="source-inline">Icon</strong>: The final<a id="_idIndexMarker494"/> method allows a theme to provide custom icons if desired. The parameter is the name of the icon resource and the returned resource can be an image in PNG, JPEG, or SVG format. It is normally advisable for you to use <strong class="source-inline">theme.NewThemedResource</strong> if returning an SVG file so that it will adapt to the theme variant.</li>
			</ul>
			<p>The <strong class="source-inline">Color</strong> method is the most complex of these, as it is expected (but not required) to return different values depending on the <strong class="source-inline">ThemeVariant</strong> passed in. Most theme colors would likely change if the user switched from light to dark mode; you can see this in the standard theme. However, not all do. As the user is able to pick their preferred primary color, it is common to keep this consistent between modes.</p>
			<p>To manage the various values for <strong class="source-inline">ThemeColourName</strong> and <strong class="source-inline">ThemeSizeName</strong>, the <strong class="source-inline">theme</strong> package provides collections of constants, named <strong class="source-inline">theme.ColorNameXxx</strong>, <strong class="source-inline">theme.SizeNameXxx,</strong> and <strong class="source-inline">theme.IconNameXxx</strong>. A complete theme should return a suitable value for each of these constants. At the time of writing, the size constants are <strong class="source-inline">SizeNamePadding</strong>, <strong class="source-inline">SizeNameScrollBar</strong>, <strong class="source-inline">SizeNameScrollBarSmall</strong>, <strong class="source-inline">SizeNameText</strong>, and <strong class="source-inline">SizeNameInlineIcon</strong>.</p>
			<p>The list of colors is far longer, and will probably grow as new theming capabilities are added. The list currently required is as follows:</p>
			<ul>
				<li><strong class="source-inline">ColorNameBackground</strong></li>
				<li><strong class="source-inline">ColorNameButton</strong></li>
				<li><strong class="source-inline">ColorNameDisabledButton</strong></li>
				<li><strong class="source-inline">ColorNameDisabled</strong></li>
				<li><strong class="source-inline">ColorNameFocus</strong></li>
				<li><strong class="source-inline">ColorNameForeground</strong></li>
				<li><strong class="source-inline">ColorNameHover</strong></li>
				<li><strong class="source-inline">ColorNamePlaceHolder</strong></li>
				<li><strong class="source-inline">ColorNamePrimary</strong></li>
				<li><strong class="source-inline">ColorNameScrollBar</strong></li>
				<li><strong class="source-inline">ColorNameShadow</strong></li>
			</ul>
			<p>Although it is <a id="_idIndexMarker495"/>recommended that you implement a return value (that adapts to the requested variant) for each of the colors and sizes listed, there may be new items added over time that your theme may not know about. To help adapt to these situations, it is possible to specify that the theme extends the built-in one (which will always have a suitable color available). We will look at this next.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Providing customizations to the standard theme</h2>
			<p>In some cases, an <a id="_idIndexMarker496"/>application developer may wish to only<a id="_idIndexMarker497"/> modify certain color elements of a theme, such as introducing their own primary color to match their company branding. To support this, you can implement a partial theme and ask that it delegate any items that are not defined to the default theme that ships as part of Fyne. To do this, you can partially implement a theme and call out to <strong class="source-inline">theme.DefaultTheme()</strong> methods to provide the standard values. This could also be used to change the font in an application, for example, while leaving the colors as standard.</p>
			<p>Let's look at a simple theme customization that wants to use a monospaced font for all text and wants that text to be orange. We will start in a new file, <strong class="source-inline">theme.go</strong>, and begin as follows:</p>
			<ol>
				<li value="1">To implement the <strong class="source-inline">Theme</strong> interface, we need to define a new type. We will use an empty <strong class="source-inline">struct</strong> for now:<p class="source-code">type myTheme struct {</p><p class="source-code">}</p></li>
				<li>To always use a monospace font, we can implement the <strong class="source-inline">Font</strong> function and return the default font resource for any request:<p class="source-code">func (t *myTheme) Font(fyne.TextStyle) fyne.Resource {</p><p class="source-code">    return theme.DefaultTextMonospaceFont()</p><p class="source-code">}</p></li>
				<li>We then <a id="_idIndexMarker498"/>want to specify that the text <a id="_idIndexMarker499"/>should be an orange color. To do this, we implement the <strong class="source-inline">Color</strong> method and return this custom value when the name is <strong class="source-inline">Colors.Text</strong>. We can ignore the <strong class="source-inline">ThemeVariant</strong> parameter as we are not providing different values for light and dark. By delegating to <strong class="source-inline">theme.DefaultTheme()</strong> for all other colors, we will specify that the default theme values should be used:<p class="source-code">func (t *myTheme) Color(n fyne.ThemeColorName, v fyne.ThemeVariant) color.Color {</p><p class="source-code">     if n == theme.ColorNameForeground {</p><p class="source-code">         return &amp;color.NRGBA{0xff, 0xc1, 0x07, 0xff}</p><p class="source-code">     }</p><p class="source-code">     return theme.DefaultTheme().Color(n, v)</p><p class="source-code">}</p></li>
				<li>We do not have any size considerations, but we must implement the method. We simply return the value from the default theme so that the current sizes will be used:<p class="source-code">func (t *myTheme) Size(n fyne.ThemeSizeName) int {</p><p class="source-code">    return theme.DefaultTheme().Size(n)</p><p class="source-code">}</p></li>
				<li>Similarly, we need to provide an empty <strong class="source-inline">Icon</strong> function that will return the default theme icon.<p class="source-code">func (t *myTheme) Icon(n fyne.ThemeIconName)</p><p class="source-code">    fyne.Resource {</p><p class="source-code">    return theme.DefaultTheme().Icon(n)</p><p class="source-code">}</p></li>
				<li>To be able to<a id="_idIndexMarker500"/> demonstrate the theme, we <a id="_idIndexMarker501"/>create a simple interface with a <strong class="source-inline">Label</strong>, <strong class="source-inline">Entry</strong>, and <strong class="source-inline">Button</strong>. The following <strong class="source-inline">makeUI</strong> function returns these elements in a vertical box:<p class="source-code">func makeUI() fyne.CanvasObject {</p><p class="source-code">    return container.NewVBox(</p><p class="source-code">        widget.NewLabel("Hello there"),</p><p class="source-code">        widget.NewEntry(),</p><p class="source-code">        widget.NewButton("Tap me", func() {}),</p><p class="source-code">    )</p><p class="source-code">}</p></li>
				<li>Lastly, we create a <strong class="source-inline">main</strong> function that loads and runs our app. Note that this time we call <strong class="source-inline">App.Settings().SetTheme</strong>, which will set a new theme to be used, as shown in the following code:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    a.Settings().SetTheme(&amp;myTheme{})</p><p class="source-code">    w := a.NewWindow("Theme")</p><p class="source-code">    w.SetContent(makeUI())</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>We can now run this app in the usual way, or specify the dark theme as follows:<p class="source-code"><strong class="bold">Chapter07$ FYNE_THEME=dark go run theme.go</strong></p></li>
			</ol>
			<p>And now we<a id="_idIndexMarker502"/> can see the result of our custom<a id="_idIndexMarker503"/> theme. All text is monospaced and of a bright orange color!</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/Figure_7.5_B16820.jpg" alt="Figure 7.5 – Using a custom theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Using a custom theme</p>
			<p>Now that we have seen how app-specific themes and custom widgets can add to a Fyne application interface, we will bring it together in an example application. This time, we will build a chat app interface.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/>Implementing a chat app user interface</h1>
			<p>A common <a id="_idIndexMarker504"/>example of graphical applications, especially in a mobile context, is the messaging app. Although there are many messaging apps now, they often share the design of colored textboxes scrolling back through time. They are also either left or right aligned (with some padding for emphasis) to show incoming messages as distinct from outgoing. In this example, we will implement the message <a id="_idIndexMarker505"/>component to show text in this way and apply a custom theme to give the app an identity.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>Creating a message widget</h2>
			<p>We start with the<a id="_idIndexMarker506"/> message widget that is used to display a single message. Each message will have a body of text and the name of the person who sent the message. Using the sender name, we can determine whether the message is outgoing. To begin, we define a custom <strong class="source-inline">Widget</strong> type that will hold this data in a new file, <strong class="source-inline">message.go</strong>:</p>
			<ol>
				<li value="1">To create a custom widget, we define a new type, named <strong class="source-inline">message</strong>, that extends <strong class="source-inline">widget.BaseWidget</strong>. We add to this our own fields, <strong class="source-inline">text</strong> and <strong class="source-inline">from</strong>, which will hold our widget state:<p class="source-code">type message struct {</p><p class="source-code">    widget.BaseWidget</p><p class="source-code">    text, from string</p><p class="source-code">}</p></li>
				<li>We will also make use of some constant values in this example—<strong class="source-inline">myName</strong> is the name that we will use for outgoing messages. Obviously, in a real app this would be a user setting. <strong class="source-inline">messageIndent</strong> is a value that determines how much left or right space will appear in our message output to align the incoming and outgoing messages:<p class="source-code">const (</p><p class="source-code">    myName        = "Me"</p><p class="source-code">    messageIndent = 20</p><p class="source-code">)</p></li>
				<li>As with our examples earlier in this chapter, we create a helpful constructor function that sets up the custom widget and ensures that <strong class="source-inline">ExtendBaseWidget</strong> is called:<p class="source-code">func newMessage(text, name string) *message {</p><p class="source-code">    m := &amp;message{text: text, from: name}</p><p class="source-code">    m.ExtendBaseWidget(m)</p><p class="source-code">    return m</p><p class="source-code">}</p></li>
				<li>Most of the work in our custom message widget relates to its positioning and style, so its renderer is where we have to do most of the work. We start this by defining a custom renderer type, <strong class="source-inline">messageRender</strong>. There is no standard renderer type to extend, but we will want to save a reference to the <strong class="source-inline">message</strong> widget that it is rendering (in case we need to read its state). We also add <strong class="source-inline">Rectangle</strong> for the background and <strong class="source-inline">Label</strong> that will display our text:<p class="source-code">type messageRender struct {</p><p class="source-code">    msg *message</p><p class="source-code">    bg  *canvas.Rectangle</p><p class="source-code">    txt *widget.Label</p><p class="source-code">}</p></li>
				<li>An important <a id="_idIndexMarker507"/>part of <strong class="source-inline">Widget</strong> (or any <strong class="source-inline">CanvasObject</strong>) is to know its minimum size. This determines how layouts will pack the content on screen. Our size is complicated by the use of wrapped text—the available width will alter the height. We create a helper method, <strong class="source-inline">messageMinSize</strong>, that will return the actual minimum size for an available width, from which we subtract <strong class="source-inline">messageIndent</strong> to create the gap in the resulting display (making it clearer which messages are incoming compared to outgoing):<p class="source-code">func (r *messageRender) messageMinSize(s fyne.Size)</p><p class="source-code">    fyne.Size {</p><p class="source-code">    fitSize := s.Subtract(fyne.NewSize(messageIndent,</p><p class="source-code">        0))</p><p class="source-code">    r.txt.Resize(fitSize.Max(r.txt.MinSize()))</p><p class="source-code">    return r.txt.MinSize()</p><p class="source-code">}</p></li>
				<li>Now that we know the space required for the text, we can implement the <strong class="source-inline">MinSize</strong> method. We add <strong class="source-inline">messageIndent</strong> to the width so that the horizontal space is reserved:<p class="source-code">func (r *messageRender) MinSize() fyne.Size {  </p><p class="source-code">    itemSize := r.messageMinSize(r.msg.Size())  </p><p class="source-code">    return itemSize.Add(fyne.NewSize(messageIndent, 0)) </p><p class="source-code">}</p></li>
				<li>The main logic <a id="_idIndexMarker508"/>for our renderer is the <strong class="source-inline">Layout</strong> method. It must size and position the text and background rectangles within the <strong class="source-inline">Widget</strong>. All positions are relative to our widget's top-left position: <p class="source-code">func (r *messageRender) Layout(s fyne.Size) {</p><p class="source-code">    itemSize := r.messageMinSize(s)</p><p class="source-code">    itemSize = itemSize.Max(fyne.NewSize(</p><p class="source-code">        s.Width-messageIndent, s.Height))</p><p class="source-code">    bgPos := fyne.NewPos(0, 0)</p><p class="source-code">    if r.msg.from == myName {</p><p class="source-code">        r.txt.Alignment = fyne.TextAlignTrailing</p><p class="source-code">        r.bg.FillColor = theme.PrimaryColorNamed(</p><p class="source-code">            theme.ColorBlue)</p><p class="source-code">        bgPos = fyne.NewPos(s.Width-itemSize.Width, 0)</p><p class="source-code">    } else {</p><p class="source-code">        r.txt.Alignment = fyne.TextAlignLeading</p><p class="source-code">        r.bg.FillColor = theme.PrimaryColorNamed(</p><p class="source-code">            theme.ColorGreen)</p><p class="source-code">    }</p><p class="source-code">    r.txt.Move(bgPos)</p><p class="source-code">    r.bg.Resize(itemSize)</p><p class="source-code">    r.bg.Move(bgPos)</p><p class="source-code">}</p><p>After calculating the full size of the text content plus padding, we set up the graphical details of this component. If it is an outgoing message, we right-align the content and set it to a <strong class="source-inline">blue</strong> color; otherwise, we make it green. The calculated sizes and positions are then applied to the elements.</p></li>
				<li>To complete the renderer, we must implement the remaining methods. These are mostly empty because this example does not use dynamic data. The <strong class="source-inline">Objects</strong> method<a id="_idIndexMarker509"/> returns each of the elements included in the order they should be drawn, so the background must be before the text:<p class="source-code">func (r *messageRender) BackgroundColor() color.Color {</p><p class="source-code">    return color.Transparent</p><p class="source-code">}</p><p class="source-code">func (r *messageRender) Destroy() {</p><p class="source-code">}</p><p class="source-code">func (r *messageRender) Objects() []fyne.CanvasObject {</p><p class="source-code">    return []fyne.CanvasObject{r.bg, r.txt}</p><p class="source-code">}</p><p class="source-code">func (r *messageRender) Refresh() { </p><p class="source-code">}</p></li>
				<li>The last function to complete this widget is the method that links <strong class="source-inline">Widget</strong> with <strong class="source-inline">WidgetRenderer</strong>. We pass in the canvas objects that will be drawn to save us from recreating them later:<p class="source-code">func (m *message) CreateRenderer() fyne.WidgetRenderer {</p><p class="source-code">    text := widget.NewLabel(m.text)</p><p class="source-code">    text.Wrapping = fyne.TextWrapWord</p><p class="source-code">    return &amp;messageRender{msg: m,</p><p class="source-code">        bg: &amp;canvas.Rectangle{}, txt: text}</p><p class="source-code">}</p></li>
			</ol>
			<p>This completes the<a id="_idIndexMarker510"/> custom component, but before we can test it, we need to create the user interface that will use them. We start by making a list of message widgets.</p>
			<p>Listing messages</p>
			<p>To create the rest of the<a id="_idIndexMarker511"/> user interface, we will create a new file, <strong class="source-inline">main.go</strong>, and add the standard components. Firstly, we create a list of messages:</p>
			<ol>
				<li value="1">Using the <strong class="source-inline">newMessage</strong> function we created earlier, it is simple to create a message list. We just create a <strong class="source-inline">VBox</strong> container and pass it a list of <strong class="source-inline">message</strong> widgets created using that helper function. Clearly, in a full application, this would use an external data source of some sort:<p class="source-code">func loadMessages() *fyne.Container {</p><p class="source-code">    return container.NewVBox(</p><p class="source-code">        newMessage("Hi there, how are you doing?",         	            "Jim"),</p><p class="source-code">        newMessage("Yeah good thanks, you?", myName),</p><p class="source-code">        newMessage("Not bad thanks. Weekend!", "Jim"),</p><p class="source-code">        newMessage("Want to visit the cinema?", "Jim"),</p><p class="source-code">        newMessage("Great idea, what's showing?",          	            myName),</p><p class="source-code">    )</p><p class="source-code">}</p></li>
				<li>We can implement a simple <strong class="source-inline">main</strong> function to show us our progress so far. This will be useful later when the full user interface is ready to run. For this version, we just set the window content to the list returned from <strong class="source-inline">loadMessages()</strong>. We give the window a sensible size and show it:<p class="source-code">func main() {</p><p class="source-code">    a := app.New()</p><p class="source-code">    w := a.NewWindow("Messages")</p><p class="source-code">    w.SetContent(loadMessages())</p><p class="source-code">    w.Resize(fyne.NewSize(160, 280))</p><p class="source-code">    w.ShowAndRun()</p><p class="source-code">}</p></li>
				<li>We can<a id="_idIndexMarker512"/> now run the message list to see the current work:<p class="source-code"><strong class="bold">Chapter07/example$ go run .</strong></p></li>
			</ol>
			<p>The result is a list of messages, aligned according to sender, and displaying the appropriate color. This can be seen in the following diagram:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/Figure_7.6_B16820.jpg" alt="Figure 7.6 – Our messaging list in the default theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Our messaging list in the default theme</p>
			<p>This completes the message listing (we will add a scroll container around the list in the following section). We should also add an input section to send new messages, which we will also do next.</p>
			<p>Completing the user interface</p>
			<p>The message list<a id="_idIndexMarker513"/> looks great, but we want to be able to send new messages. Let's see how this can be done:</p>
			<ol>
				<li value="1">To add the remaining user interface elements, we create a new function, <strong class="source-inline">makeUI</strong>, and start by adding the <strong class="source-inline">loadMessages</strong> list:<p class="source-code">func makeUI() fyne.CanvasObject {</p><p class="source-code">    list := loadMessages()</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>We then create a footer that contains an <strong class="source-inline">Entry</strong> to capture the text and a <strong class="source-inline">Send</strong> Button to transmit the message:<p class="source-code">    msg := widget.NewEntry()</p><p class="source-code">    send := widget.NewButtonWithIcon("",</p><p class="source-code">        theme.MailSendIcon(), func() {</p><p class="source-code">        list.Add(newMessage(msg.Text, myName))</p><p class="source-code">        msg.SetText("")</p><p class="source-code">    })</p><p class="source-code">    input := container.NewBorder(nil, nil, nil, send,</p><p class="source-code">        msg)</p><p>From the preceding code, we can see that by using the <strong class="source-inline">submitEntry</strong> earlier in this chapter, you could also support the ability to send on return if you like. The button tap handler will create a new message widget and add it to the list, which will refresh. It then resets the text in our <strong class="source-inline">Entry</strong>. We return a <strong class="source-inline">Container</strong> called <strong class="source-inline">input</strong> that positions these elements appropriately.</p></li>
				<li>Lastly, for this function, we return a new <strong class="source-inline">Border</strong> container that positions the input row at the bottom and uses the rest of the space for the message list. We also add a <strong class="source-inline">Scroll</strong> container around the list so it can contain more data than fits on the screen:<p class="source-code">    return container.NewBorder(nil, input, nil, nil, </p><p class="source-code">        container.NewVScroll(list))</p></li>
				<li>To use this new code, we update the <strong class="source-inline">main</strong> function to call <strong class="source-inline">makeUI()</strong> instead of <strong class="source-inline">loadMessages()</strong>:<p class="source-code">    w.SetContent(makeUI())</p></li>
				<li>We can now run the app again to see the complete interface, as follows:<p class="source-code"><strong class="bold">Chapter07/example$ go run .</strong></p></li>
				<li>This time, we can <a id="_idIndexMarker514"/>use the input box at the end to add a new message. In Figure 7.7, we added a <strong class="bold">How about...?</strong> message:</li>
			</ol>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/Figure_7.7_B16820.jpg" alt="Figure 7.7 – Our messaging app in the default theme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Our messaging app in the default theme</p>
			<p>This completes our <a id="_idIndexMarker515"/>application functionality, but we can still make it more interesting by applying a custom theme.</p>
			<p>Adding some flair with a custom theme</p>
			<p>The default look of <a id="_idIndexMarker516"/>Fyne applications is designed to be clear and attractive, but some apps may want to apply more identity or design flair. We will do this for our messaging app, starting with a new file, <strong class="source-inline">theme.go</strong>:</p>
			<ol>
				<li value="1">We start by defining a new type for our theme. It does not need to manage any state or inherit from other structs, so it is created empty:<p class="source-code">type myTheme struct {</p><p class="source-code">}</p></li>
				<li>The main purpose of this custom theme is to return a different <strong class="source-inline">Color</strong> for certain elements. We start by adapting the <strong class="source-inline">Background</strong> color to display light or dark versions of a <em class="italic">blue-gray</em> color, depending on the current user setting (called <strong class="source-inline">ThemeVariant</strong>). We return the default theme lookup at the end of this function to show that we do not have a customization for other colors:<p class="source-code">func (m *myTheme) Color(n fyne.ThemeColorName,</p><p class="source-code">     v fyne.ThemeVariant) color.Color {</p><p class="source-code">     switch n {</p><p class="source-code">     case theme.ColorNameBackground:</p><p class="source-code">         if v == theme.VariantLight {</p><p class="source-code">             return &amp;color.NRGBA{0xcf, 0xd8, 0xdc, 0xff}</p><p class="source-code">         }</p><p class="source-code">         return &amp;color.NRGBA{0x45, 0x5A, 0x64, 0xff}</p><p class="source-code">     }</p><p class="source-code">     return theme.DefaultTheme().Color(n, v)</p><p class="source-code">}</p></li>
				<li>We will also provide a custom color for focused elements. We insert the following code into the <strong class="source-inline">switch</strong> statement in the previous code segment. Clearly, many more customizations could be provided if you desire:<p class="source-code">    case theme.ColorNameFocus:</p><p class="source-code">         return &amp;color.NRGBA{0xff, 0xc1, 0x07, 0xff}</p></li>
				<li>In this example, we don't want to provide custom size values or fonts, but you could return custom <a id="_idIndexMarker517"/>values if you want (as shown in the <em class="italic">Adding a custom theme</em> section earlier). We need to implement these methods, but we will return the default theme lookup so that the standard values will be used:<p class="source-code">func (m *myTheme) Size(n fyne.ThemeSizeName) int {</p><p class="source-code">     return theme.DefaultTheme().Size(n)</p><p class="source-code">}</p><p class="source-code">func (m *myTheme) Font(n fyne.TextStyle) fyne.Resource {</p><p class="source-code">     return theme.DefaultTheme().Font(n)</p><p class="source-code">}</p><p class="source-code">func (m *myTheme) Icon(n fyne.ThemeIconName) fyne.Resource { </p><p class="source-code">     return theme.DefaultTheme().Icon(n)</p><p class="source-code">}</p></li>
				<li>To apply this theme to our app, we use <strong class="source-inline">App.Settings.SetTheme()</strong>. This should be called from the <strong class="source-inline">main()</strong> function before <strong class="source-inline">ShowAndRun()</strong>:<p class="source-code">    a.Settings().SetTheme(&amp;myTheme{})</p></li>
				<li>Once again, we can run this code and see the completed work:<p class="source-code"><strong class="bold">Chapter07/example$ go run .</strong></p></li>
				<li>We will see the custom theme loaded. In Figure 7.8, it is running with <strong class="source-inline">FYNE_THEME=dark</strong> to show that our custom theme works for light and dark modes:</li>
			</ol>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/Figure_7.8_B16820.jpg" alt="Figure 7.8 – Using the theme we just wrote in dark mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Using the theme we just wrote in dark mode</p>
			<p>We have seen how <a id="_idIndexMarker518"/>to implement custom widgets and themes to build an attractive messaging user interface. It is left as an exercise for the reader to actually send and receive messages through your favorite chat protocol!</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor203"/>Summary</h1>
			<p>In this chapter, we have seen how to deviate from the standard components and built-in theme in various ways. We explored how existing widgets can be extended and adapted, as well as how to build our own components from scratch. We also saw how custom themes can be created and how we can apply our own customizations to the default theme through theme extension.</p>
			<p>With this knowledge, we created an application that was a mix of standard and custom components. We added some visual enhancements through our widget's renderer, but also created further customization by defining a custom theme. Through the code in this chapter, we learned how to customize individual elements and widgets, as well as how to make visual changes that apply across custom and standard widgets, using the theme API.</p>
			<p>This brings us to the end of our exploration of the Fyne toolkit APIs and their functionality. In the following chapters, we will see how to create and manage GUI applications and how best practices can help make robust software that is easy to maintain. We will also learn that applications can be prepared for distribution and even uploaded to platform app stores and marketplaces. In the next chapter, we will explore the best practices around project structure and how to keep a growing GUI app robust and maintainable.</p>
		</div>
	</body></html>