- en: '*Chapter 7*: Building Custom Widgets and Themes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of the previous chapters, we have seen a lot of functionality
    that comes as part of the Fyne toolkit. Many applications will, however, benefit
    from components or functionality that are not included as standard. To be able
    to support an easy-to-use toolkit API and at the same time support additional
    functionality, the Fyne toolkit provides the ability to use custom code alongside
    regular widgets.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how custom data can be used in a Fyne app,
    and how custom styling can be added using code or by loading custom themes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending existing widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a component from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a custom theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the chapter, we will see how to make use of the custom widget
    and theme capabilities to create an app that presents a conversation history that
    could be used for various instant messenger protocols. It will demonstrate how
    a new widget can complement the standard set, and also how a custom theme can
    add some individuality to an application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*: you will need to have the Fyne toolkit installed
    and a working Go and C compiler. For more information, please refer to the previous
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Extending existing widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard widgets that we explored in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes,* all have minimal APIs to define commonly required
    functionality. To support the addition of more advanced functionality, each Fyne
    widget can be extended by application developers. In this section, we will see
    how widgets can be enhanced by overriding their existing functionality or adding
    new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following diagram, extended widgets, as well as custom
    widgets, can be included in a container alongside standard widgets and canvas
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Extended and custom widgets can be used alongside standard elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Extended and custom widgets can be used alongside standard elements
  prefs: []
  type: TYPE_NORMAL
- en: An extended widget will embed an existing widget and provide replacement, or
    enhanced, functionality around it. Custom widgets, which we will see later in
    this chapter, implement the complete `Widget` interface, and so are not constrained
    by the designs of a standard widget.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom widgets offers more flexibility; however, it requires a lot
    more code. Instead, we will start by learning how to extend existing widgets to
    add our own functionality. Once we have understood how to extend existing widgets,
    we will learn more about custom components in the *Creating a component from scratch*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding widget functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first way that we will explore how to extend an existing widget is by overriding
    some of its functionality. This is normally accomplished by embedding a widget
    and creating a method of the same signature that Fyne would call into it, essentially
    replacing the built-in method with our own. When taking this approach, it is common
    to want the original functionality to execute after we have processed our override.
    To do this, our extended widget can call the original method from our own method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we will create an extended `Entry` widget that performs
    an action when the `submitEntry`, and will enter the code in `submitentry.go`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a new struct that will define our custom type, naming it `submitEntry`.
    Inside it, we add an anonymous field, `widget.Entry`, which means that we will
    inherit all the fields and functionality of an `Entry` widget. Note that this
    is not a pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a constructor function, `newSubmitEntry`. This step is not
    strictly required, but it is essential that we call `ExtendBaseWidget()`, and
    so a function like this is usually the best approach. We need to pass the new
    widget as a parameter to `ExtendBaseWidget` so that the toolkit code knows that
    we are providing a replacement to the embedded widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then add our own, overriding, functionality. In this case, we replace
    the `TypedKey` method, which is called when a key (physical or virtual) has been
    tapped to trigger an event. If we wanted to intercept characters, we would use
    `TypedRune`. In our method, we check whether the key is `KeyReturn`, and if it
    is, we take a custom action. If any other key is pressed, we call the `TypedKey`
    function of the embedded `Entry` widget (passing the same `KeyEvent`), which ensures
    that our widget continues to function as a text entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we create the usual `main` function. In this case, we simply set the
    content to our new `submitEntry` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run the sample with the `go run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see a window containing what looks like a regular entry widget, but
    if you hit the **Return** key when typing, you will see a log message in the console
    and the content will clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The submitEntry struct looks like a regular widget.Entry'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The submitEntry struct looks like a regular widget.Entry
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to override an existing function of a widget, but it is also
    possible to add new features, as we will see when we learn how to make a tappable
    icon in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second way that developers can extend existing widgets is to add new functionality
    by implementing new handlers around an embedded type. In this example, we will
    create a tappable icon. This extended `widget.Icon` will behave like a button
    with a single icon, but it does not include the border or tap animations of a
    regular button (which may not be desired in some situations). We start this example
    by creating `tapicon.go` and proceeding as described:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we start with a custom struct that embeds the existing widget,
    this time a `widget.Icon`. As before, this should not be a pointer type. In this
    struct, we will also include a `func()` to store the callback that should be run
    when the icon is tapped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a constructor function again, primarily to ensure that `ExtendBaseWidget`
    is called. Into this we will pass a `fyne.Resource`, which specifies the icon
    to show, and a `func()`, which will be used to call when the icon is tapped. The
    resource is passed into the original icon as it will still handle the rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add the tapped functionality, all we need to do is implement the `fyne.Tappable`
    interface, which requires a single method, `Tapped()`, taking a `*PointEvent`
    parameter. We simply execute the callback that was saved earlier inside this function,
    as long as one was set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this demonstration, we will create a basic user interface that holds three
    of our `tapIcon` instances, simulating the home, back, and next navigation items
    from an app. To do this, we create a new `makeUI` function that aligns them in
    a horizontal box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete this example, we create a new `main` function that will set the
    window content to the result of a `makeUI()` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run this whole example to see the resulting widgets in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the application runs, you will see a window like the following that renders
    the icons. You can tap them and see the log output appearing when you do so. We
    have just recreated button widgets without the additional borders, padding, and
    tap animations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The tappable icons in a horizontal box'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – The tappable icons in a horizontal box
  prefs: []
  type: TYPE_NORMAL
- en: We have explored some different ways to extend existing widgets, but sometimes
    we want to create something completely new. In these situations, it is possible
    to build a widget from scratch, which we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a component from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of building a new component by extending an existing widget, as we did
    in the previous section, we could build one from scratch. Any component that implements
    the `fyne.Widget` interface can be used as a widget in a Fyne application. To
    ease development, there is a `widget.BaseWidget` definition that we can inherit
    from. Let's start by defining the behavior of a new widget—the three-state checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Defining widget behavior
  prefs: []
  type: TYPE_NORMAL
- en: 'The API of a Fyne widget is based on behavior rather than how it looks. To
    begin our widget development, we will therefore define the states that our three-state
    checkbox can take and how a user can interact with it. We will create `threestate.go`
    and start coding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we must define a new type, `CheckState`, which will hold the three
    different states of our new checkbox widget. As we are building a reusable component,
    it is a good idea to export the types that are required, such as `CheckState`
    and the various states it defines. The usage of `iota` defines the first index
    and the following states will increment from that value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define the core of the new component, calling it `ThreeStateCheck,`
    and setting it to inherit the basic widget behavior from `widget.BaseWidget`.
    Using `BaseWidget` is optional but it saves some coding. We add a field named
    `State` that will hold the current state of the check widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a constructor function for this new type. As with previous
    examples, we need to call `ExtendBaseWidget`; in this case, the basic functionality
    that we have inherited is set up correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last behavior element of this type is its ability to respond to tap events.
    We set up a `Tapped` handler, just as we did with the tappable icon in the previous
    section. This time, we will rotate the three states of this widget, wrapping to
    `CheckOff` if the previous state was `CheckIndeterminate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all that we need to write to define the behavior of this new widget.
    However, because it is a new component (instead of an extension of an existing
    widget), we must also define how it will be rendered, which we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing rendering details
  prefs: []
  type: TYPE_NORMAL
- en: 'For a new widget to be complete, it must also define how it will be rendered.
    This requires a new type that implements `fyne.WidgetRenderer`, as we will implement
    ahead. This new type must be returned from a `CreateRenderer` function on the
    widget implementation as well, as you will see in the code ahead. This renderer
    will use one of three checkbox icons—two are built into the Fyne theme and the
    third we will provide in this code base. Note that extra resources like this should
    be bundled for distribution, which will be discussed in detail in [*Chapter 9*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219),
    *Bundling Resources and Preparing for Release,* in the *Bundling assets* section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the renderer definition, we create a new type named `threeStateRender`;
    this should not be exported, as renderer details are private. This will hold a
    reference to the `ThreeStateCheck` that it is rendering, as well as a `canvas.Image`
    that will display one of the three icons used for our check widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just as if we were defining a layout for a container, we need to define how
    elements of a widget renderer are sized and positioned. In this example, we will
    simply specify that our checkbox icons should be set to `theme.IconInlineSize`
    to be consistent with other widgets. We define this as our `MinSize` and use the
    same value to size our widget when it is asked to define a `Layout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete our renderer, we must also define the additional methods: the `Destroy`
    (called when this renderer is no longer needed), `Objects` (which returns the
    list of graphical elements), and `Refresh` (which is called if a state changes)
    methods. These methods are relatively simple—most are empty, and the `Refresh`
    method simply calls a new `updateImage` method, which is defined in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The key to ensuring that the widget is up to date is the selection of the right
    image for the current state. We do this in a new `updateImage` method, described
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It simply checks the state and picks a resource to display. In the normal states,
    we can use built-in icons from the theme, but for our new indeterminate state,
    we must load our own resource. As we noted earlier in this section, the asset
    should be bundled, but we will explore this in more detail in [*Chapter 9*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219),
    *Bundling Resources and Preparing for Release*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last part of writing a `WidgetRenderer` is to return it from the `CreateRenderer`
    method defined on the widget that we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, we set up the renderer and pass it a `canvas.Image` instance
    that it can use to display. We then call the `updateImage` method that we defined
    earlier to ensure that the initial state is rendered correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run this demo, all we need to do is add the usual `main` function.
    This time, we will set the content to a single three-state checkbox using `NewThreeStateCheck()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run the code as usual with the `go run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the application will display the first window in Figure 7.4\. Tapping
    the icon will rotate the checkbox through the three states that are illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The three states of our custom checkbox'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The three states of our custom checkbox
  prefs: []
  type: TYPE_NORMAL
- en: We have now explored the various ways to extend widgets to add new behavior
    and to create completely new components. As you can see from the figures in the
    chapter so far, they all look similar because they respect the current theme.
    In the next section, we will see how to make application-wide style changes using
    a custom theme.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom theme
  prefs: []
  type: TYPE_NORMAL
- en: To bring some individual style or brand identity to an application, it can be
    useful to define a custom theme. This is a powerful feature, but should be used
    carefully. The selection of colors can significantly impact the readability of
    text elements and icons. Additionally, users of Fyne applications are allowed
    to choose between light and dark modes, so it is important that your theme reflects
    this choice where possible.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways that developers can create a custom theme—either by defining
    a new theme from scratch by implementing the `Theme` interface, or by inheriting
    from the standard theme. Each have their own benefits, and so we will explore
    both, starting with looking at creating a brand new theme.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the theme interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All themes in Fyne are provided by implementing the `fyne.Theme` interface
    (much like any widget will implement `fyne.Widget`). The interface requires us
    to provide four methods that are used to look up the details of a theme. These
    methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can guess, these methods return the color, size, icon, and fonts provided
    by a theme. The four signatures vary, but the meanings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Color`: The color lookup uses two parameters: the first is the name of the
    requested color (which we will explore more later) and the second is `ThemeVariant`.
    At the time of writing, there are two variants: `theme.VariantLight` and `theme.VariantDark`.
    This allows a theme to adapt to light and dark mode, although doing so is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Size`: This lookup takes only the size name parameter. It is one of the `ThemeSizeName`
    constants, such as `theme.SizeNamePadding` or `theme.SizeNameText`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Font`: This lookup takes `TextStyle` as its lookup parameter. A theme can
    choose which font to return for the various styles, such as `TextStyle{Bold: true}`
    for bold. The theme should also check the `Italic` and `Monospaced` fields. Other
    options may be added in future releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Icon`: The final method allows a theme to provide custom icons if desired.
    The parameter is the name of the icon resource and the returned resource can be
    an image in PNG, JPEG, or SVG format. It is normally advisable for you to use
    `theme.NewThemedResource` if returning an SVG file so that it will adapt to the
    theme variant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Color` method is the most complex of these, as it is expected (but not
    required) to return different values depending on the `ThemeVariant` passed in.
    Most theme colors would likely change if the user switched from light to dark
    mode; you can see this in the standard theme. However, not all do. As the user
    is able to pick their preferred primary color, it is common to keep this consistent
    between modes.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the various values for `ThemeColourName` and `ThemeSizeName`, the
    `theme` package provides collections of constants, named `theme.ColorNameXxx`,
    `theme.SizeNameXxx,` and `theme.IconNameXxx`. A complete theme should return a
    suitable value for each of these constants. At the time of writing, the size constants
    are `SizeNamePadding`, `SizeNameScrollBar`, `SizeNameScrollBarSmall`, `SizeNameText`,
    and `SizeNameInlineIcon`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of colors is far longer, and will probably grow as new theming capabilities
    are added. The list currently required is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ColorNameBackground`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameDisabledButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameDisabled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameFocus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameForeground`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameHover`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNamePlaceHolder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNamePrimary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameScrollBar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorNameShadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it is recommended that you implement a return value (that adapts to
    the requested variant) for each of the colors and sizes listed, there may be new
    items added over time that your theme may not know about. To help adapt to these
    situations, it is possible to specify that the theme extends the built-in one
    (which will always have a suitable color available). We will look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: Providing customizations to the standard theme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, an application developer may wish to only modify certain color
    elements of a theme, such as introducing their own primary color to match their
    company branding. To support this, you can implement a partial theme and ask that
    it delegate any items that are not defined to the default theme that ships as
    part of Fyne. To do this, you can partially implement a theme and call out to
    `theme.DefaultTheme()` methods to provide the standard values. This could also
    be used to change the font in an application, for example, while leaving the colors
    as standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple theme customization that wants to use a monospaced
    font for all text and wants that text to be orange. We will start in a new file,
    `theme.go`, and begin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `Theme` interface, we need to define a new type. We will use
    an empty `struct` for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To always use a monospace font, we can implement the `Font` function and return
    the default font resource for any request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then want to specify that the text should be an orange color. To do this,
    we implement the `Color` method and return this custom value when the name is
    `Colors.Text`. We can ignore the `ThemeVariant` parameter as we are not providing
    different values for light and dark. By delegating to `theme.DefaultTheme()` for
    all other colors, we will specify that the default theme values should be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We do not have any size considerations, but we must implement the method. We
    simply return the value from the default theme so that the current sizes will
    be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, we need to provide an empty `Icon` function that will return the
    default theme icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be able to demonstrate the theme, we create a simple interface with a `Label`,
    `Entry`, and `Button`. The following `makeUI` function returns these elements
    in a vertical box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we create a `main` function that loads and runs our app. Note that
    this time we call `App.Settings().SetTheme`, which will set a new theme to be
    used, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run this app in the usual way, or specify the dark theme as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And now we can see the result of our custom theme. All text is monospaced and
    of a bright orange color!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Using a custom theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Using a custom theme
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how app-specific themes and custom widgets can add to
    a Fyne application interface, we will bring it together in an example application.
    This time, we will build a chat app interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a chat app user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common example of graphical applications, especially in a mobile context,
    is the messaging app. Although there are many messaging apps now, they often share
    the design of colored textboxes scrolling back through time. They are also either
    left or right aligned (with some padding for emphasis) to show incoming messages
    as distinct from outgoing. In this example, we will implement the message component
    to show text in this way and apply a custom theme to give the app an identity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a message widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with the message widget that is used to display a single message.
    Each message will have a body of text and the name of the person who sent the
    message. Using the sender name, we can determine whether the message is outgoing.
    To begin, we define a custom `Widget` type that will hold this data in a new file,
    `message.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom widget, we define a new type, named `message`, that extends
    `widget.BaseWidget`. We add to this our own fields, `text` and `from`, which will
    hold our widget state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also make use of some constant values in this example—`myName` is the
    name that we will use for outgoing messages. Obviously, in a real app this would
    be a user setting. `messageIndent` is a value that determines how much left or
    right space will appear in our message output to align the incoming and outgoing
    messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As with our examples earlier in this chapter, we create a helpful constructor
    function that sets up the custom widget and ensures that `ExtendBaseWidget` is
    called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Most of the work in our custom message widget relates to its positioning and
    style, so its renderer is where we have to do most of the work. We start this
    by defining a custom renderer type, `messageRender`. There is no standard renderer
    type to extend, but we will want to save a reference to the `message` widget that
    it is rendering (in case we need to read its state). We also add `Rectangle` for
    the background and `Label` that will display our text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An important part of `Widget` (or any `CanvasObject`) is to know its minimum
    size. This determines how layouts will pack the content on screen. Our size is
    complicated by the use of wrapped text—the available width will alter the height.
    We create a helper method, `messageMinSize`, that will return the actual minimum
    size for an available width, from which we subtract `messageIndent` to create
    the gap in the resulting display (making it clearer which messages are incoming
    compared to outgoing):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we know the space required for the text, we can implement the `MinSize`
    method. We add `messageIndent` to the width so that the horizontal space is reserved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main logic for our renderer is the `Layout` method. It must size and position
    the text and background rectangles within the `Widget`. All positions are relative
    to our widget''s top-left position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After calculating the full size of the text content plus padding, we set up
    the graphical details of this component. If it is an outgoing message, we right-align
    the content and set it to a `blue` color; otherwise, we make it green. The calculated
    sizes and positions are then applied to the elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To complete the renderer, we must implement the remaining methods. These are
    mostly empty because this example does not use dynamic data. The `Objects` method
    returns each of the elements included in the order they should be drawn, so the
    background must be before the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last function to complete this widget is the method that links `Widget`
    with `WidgetRenderer`. We pass in the canvas objects that will be drawn to save
    us from recreating them later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This completes the custom component, but before we can test it, we need to create
    the user interface that will use them. We start by making a list of message widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Listing messages
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the rest of the user interface, we will create a new file, `main.go`,
    and add the standard components. Firstly, we create a list of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `newMessage` function we created earlier, it is simple to create
    a message list. We just create a `VBox` container and pass it a list of `message`
    widgets created using that helper function. Clearly, in a full application, this
    would use an external data source of some sort:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can implement a simple `main` function to show us our progress so far. This
    will be useful later when the full user interface is ready to run. For this version,
    we just set the window content to the list returned from `loadMessages()`. We
    give the window a sensible size and show it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run the message list to see the current work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is a list of messages, aligned according to sender, and displaying
    the appropriate color. This can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Our messaging list in the default theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Our messaging list in the default theme
  prefs: []
  type: TYPE_NORMAL
- en: This completes the message listing (we will add a scroll container around the
    list in the following section). We should also add an input section to send new
    messages, which we will also do next.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the user interface
  prefs: []
  type: TYPE_NORMAL
- en: 'The message list looks great, but we want to be able to send new messages.
    Let''s see how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the remaining user interface elements, we create a new function, `makeUI`,
    and start by adding the `loadMessages` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create a footer that contains an `Entry` to capture the text and a
    `Send` Button to transmit the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the preceding code, we can see that by using the `submitEntry` earlier
    in this chapter, you could also support the ability to send on return if you like.
    The button tap handler will create a new message widget and add it to the list,
    which will refresh. It then resets the text in our `Entry`. We return a `Container`
    called `input` that positions these elements appropriately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, for this function, we return a new `Border` container that positions
    the input row at the bottom and uses the rest of the space for the message list.
    We also add a `Scroll` container around the list so it can contain more data than
    fits on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use this new code, we update the `main` function to call `makeUI()` instead
    of `loadMessages()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run the app again to see the complete interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we can use the input box at the end to add a new message. In Figure
    7.7, we added a **How about...?** message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Our messaging app in the default theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.7_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Our messaging app in the default theme
  prefs: []
  type: TYPE_NORMAL
- en: This completes our application functionality, but we can still make it more
    interesting by applying a custom theme.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some flair with a custom theme
  prefs: []
  type: TYPE_NORMAL
- en: 'The default look of Fyne applications is designed to be clear and attractive,
    but some apps may want to apply more identity or design flair. We will do this
    for our messaging app, starting with a new file, `theme.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a new type for our theme. It does not need to manage any
    state or inherit from other structs, so it is created empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main purpose of this custom theme is to return a different `Color` for
    certain elements. We start by adapting the `Background` color to display light
    or dark versions of a *blue-gray* color, depending on the current user setting
    (called `ThemeVariant`). We return the default theme lookup at the end of this
    function to show that we do not have a customization for other colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also provide a custom color for focused elements. We insert the following
    code into the `switch` statement in the previous code segment. Clearly, many more
    customizations could be provided if you desire:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, we don''t want to provide custom size values or fonts, but
    you could return custom values if you want (as shown in the *Adding a custom theme*
    section earlier). We need to implement these methods, but we will return the default
    theme lookup so that the standard values will be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To apply this theme to our app, we use `App.Settings.SetTheme()`. This should
    be called from the `main()` function before `ShowAndRun()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, we can run this code and see the completed work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see the custom theme loaded. In Figure 7.8, it is running with `FYNE_THEME=dark`
    to show that our custom theme works for light and dark modes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Using the theme we just wrote in dark mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.8_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Using the theme we just wrote in dark mode
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to implement custom widgets and themes to build an attractive
    messaging user interface. It is left as an exercise for the reader to actually
    send and receive messages through your favorite chat protocol!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to deviate from the standard components and
    built-in theme in various ways. We explored how existing widgets can be extended
    and adapted, as well as how to build our own components from scratch. We also
    saw how custom themes can be created and how we can apply our own customizations
    to the default theme through theme extension.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we created an application that was a mix of standard and
    custom components. We added some visual enhancements through our widget's renderer,
    but also created further customization by defining a custom theme. Through the
    code in this chapter, we learned how to customize individual elements and widgets,
    as well as how to make visual changes that apply across custom and standard widgets,
    using the theme API.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of our exploration of the Fyne toolkit APIs and their
    functionality. In the following chapters, we will see how to create and manage
    GUI applications and how best practices can help make robust software that is
    easy to maintain. We will also learn that applications can be prepared for distribution
    and even uploaded to platform app stores and marketplaces. In the next chapter,
    we will explore the best practices around project structure and how to keep a
    growing GUI app robust and maintainable.
  prefs: []
  type: TYPE_NORMAL
