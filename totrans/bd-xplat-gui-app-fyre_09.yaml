- en: '*Chapter 7*: Building Custom Widgets and Themes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：构建自定义小部件和主题'
- en: Over the course of the previous chapters, we have seen a lot of functionality
    that comes as part of the Fyne toolkit. Many applications will, however, benefit
    from components or functionality that are not included as standard. To be able
    to support an easy-to-use toolkit API and at the same time support additional
    functionality, the Fyne toolkit provides the ability to use custom code alongside
    regular widgets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看到了许多作为Fyne工具包一部分的功能。然而，许多应用程序将受益于作为标准不包括的组件或功能。为了能够支持易于使用的工具包API并同时支持附加功能，Fyne工具包提供了在常规小部件旁边使用自定义代码的能力。
- en: In this chapter, we will explore how custom data can be used in a Fyne app,
    and how custom styling can be added using code or by loading custom themes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在Fyne应用程序中使用自定义数据，以及如何通过代码或加载自定义主题来添加自定义样式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Extending existing widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展现有小部件
- en: Creating a component from scratch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头创建组件
- en: Adding a custom theme
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义主题
- en: At the end of the chapter, we will see how to make use of the custom widget
    and theme capabilities to create an app that presents a conversation history that
    could be used for various instant messenger protocols. It will demonstrate how
    a new widget can complement the standard set, and also how a custom theme can
    add some individuality to an application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将看到如何利用自定义小部件和主题功能来创建一个展示可用于各种即时通讯协议的对话历史的应用程序。它将展示如何使新小部件补充标准集，以及如何使自定义主题为应用程序增添一些个性。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*: you will need to have the Fyne toolkit installed
    and a working Go and C compiler. For more information, please refer to the previous
    chapter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与[*第3章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)、“Windows、Canvas和绘图”的要求相同：您需要安装Fyne工具包并拥有一个有效的Go和C编译器。更多信息，请参阅上一章。
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter07)找到。
- en: Extending existing widgets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展现有小部件
- en: The standard widgets that we explored in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes,* all have minimal APIs to define commonly required
    functionality. To support the addition of more advanced functionality, each Fyne
    widget can be extended by application developers. In this section, we will see
    how widgets can be enhanced by overriding their existing functionality or adding
    new behavior.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第5章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)“小部件库和主题”中探讨的标准小部件都具有最小的API来定义常用功能。为了支持添加更高级的功能，应用程序开发者可以扩展每个Fyne小部件。在本节中，我们将看到如何通过覆盖现有功能或添加新行为来增强小部件。
- en: 'As we can see in the following diagram, extended widgets, as well as custom
    widgets, can be included in a container alongside standard widgets and canvas
    objects:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，扩展小部件以及自定义小部件都可以与标准小部件和画布对象一起包含在容器中：
- en: '![Figure 7.1 – Extended and custom widgets can be used alongside standard elements'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 扩展和自定义小部件可以与标准元素一起使用'
- en: '](img/Figure_7.1_B16820.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.1_B16820.jpg]'
- en: Figure 7.1 – Extended and custom widgets can be used alongside standard elements
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 扩展和自定义小部件可以与标准元素一起使用
- en: An extended widget will embed an existing widget and provide replacement, or
    enhanced, functionality around it. Custom widgets, which we will see later in
    this chapter, implement the complete `Widget` interface, and so are not constrained
    by the designs of a standard widget.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展小部件将嵌入现有小部件并提供替换或增强的功能。我们将在本章后面看到，自定义小部件实现了完整的`Widget`接口，因此不受标准小部件设计的限制。
- en: Building custom widgets offers more flexibility; however, it requires a lot
    more code. Instead, we will start by learning how to extend existing widgets to
    add our own functionality. Once we have understood how to extend existing widgets,
    we will learn more about custom components in the *Creating a component from scratch*
    section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义小部件提供了更多的灵活性；然而，它需要更多的代码。相反，我们将从学习如何扩展现有小部件以添加我们自己的功能开始。一旦我们理解了如何扩展现有小部件，我们将在“从头创建组件”部分了解更多关于自定义组件的内容。
- en: Overriding widget functions
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖小部件函数
- en: The first way that we will explore how to extend an existing widget is by overriding
    some of its functionality. This is normally accomplished by embedding a widget
    and creating a method of the same signature that Fyne would call into it, essentially
    replacing the built-in method with our own. When taking this approach, it is common
    to want the original functionality to execute after we have processed our override.
    To do this, our extended widget can call the original method from our own method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索如何扩展现有小部件的第一种方式是通过覆盖它的一些功能。这通常是通过嵌入一个小部件并创建一个与 Fyne 调用它的签名相同的方法来完成的，本质上是用我们自己的方法替换了内置方法。在采取这种方法时，通常希望在处理了我们的覆盖之后执行原始功能。为此，我们的扩展小部件可以从我们自己的方法中调用原始方法。
- en: 'To illustrate this, we will create an extended `Entry` widget that performs
    an action when the `submitEntry`, and will enter the code in `submitentry.go`,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将创建一个扩展的 `Entry` 小部件，当 `submitEntry` 被触发时执行一个动作，并将代码放入 `submitentry.go`
    中，如下所示：
- en: 'We first create a new struct that will define our custom type, naming it `submitEntry`.
    Inside it, we add an anonymous field, `widget.Entry`, which means that we will
    inherit all the fields and functionality of an `Entry` widget. Note that this
    is not a pointer:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的结构体，它将定义我们的自定义类型，命名为 `submitEntry`。在里面，我们添加一个匿名字段，`widget.Entry`，这意味着我们将继承
    `Entry` 小部件的所有字段和功能。注意，这并不是一个指针：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we create a constructor function, `newSubmitEntry`. This step is not
    strictly required, but it is essential that we call `ExtendBaseWidget()`, and
    so a function like this is usually the best approach. We need to pass the new
    widget as a parameter to `ExtendBaseWidget` so that the toolkit code knows that
    we are providing a replacement to the embedded widget:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个构造函数，`newSubmitEntry`。这一步不是严格必要的，但我们必须调用 `ExtendBaseWidget()`，因此这样的函数通常是最佳方法。我们需要将新小部件作为参数传递给
    `ExtendBaseWidget`，以便工具包代码知道我们正在提供对嵌入小部件的替换：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then add our own, overriding, functionality. In this case, we replace
    the `TypedKey` method, which is called when a key (physical or virtual) has been
    tapped to trigger an event. If we wanted to intercept characters, we would use
    `TypedRune`. In our method, we check whether the key is `KeyReturn`, and if it
    is, we take a custom action. If any other key is pressed, we call the `TypedKey`
    function of the embedded `Entry` widget (passing the same `KeyEvent`), which ensures
    that our widget continues to function as a text entry:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以添加我们自己的、覆盖的功能。在这种情况下，我们替换了 `TypedKey` 方法，该方法在按下键（物理或虚拟）以触发事件时被调用。如果我们想拦截字符，我们会使用
    `TypedRune`。在我们的方法中，我们检查键是否为 `KeyReturn`，如果是，我们执行一个自定义动作。如果按下任何其他键，我们调用嵌入的 `Entry`
    小部件的 `TypedKey` 函数（传递相同的 `KeyEvent`），这确保了我们的小部件继续作为文本输入工作：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, we create the usual `main` function. In this case, we simply set the
    content to our new `submitEntry` widget:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个常规的 `main` 函数。在这种情况下，我们只需将内容设置为我们的新 `submitEntry` 小部件：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now run the sample with the `go run` command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `go run` 命令运行示例：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see a window containing what looks like a regular entry widget, but
    if you hit the **Return** key when typing, you will see a log message in the console
    and the content will clear:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个包含看起来像常规输入小部件的窗口，但如果你在输入时按下 **回车** 键，你将在控制台看到一个日志消息，内容将被清除：
- en: '![Figure 7.2 – The submitEntry struct looks like a regular widget.Entry'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – `submitEntry` 结构体看起来像是一个常规的 `widget.Entry`'
- en: '](img/Figure_7.2_B16820.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16820.jpg)'
- en: Figure 7.2 – The submitEntry struct looks like a regular widget.Entry
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – `submitEntry` 结构体看起来像是一个常规的 `widget.Entry`
- en: We have seen how to override an existing function of a widget, but it is also
    possible to add new features, as we will see when we learn how to make a tappable
    icon in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何覆盖小部件的现有函数，但也可以添加新功能，正如我们将在下一节学习如何创建可点击图标时看到的那样。
- en: Adding new behavior
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新行为
- en: 'The second way that developers can extend existing widgets is to add new functionality
    by implementing new handlers around an embedded type. In this example, we will
    create a tappable icon. This extended `widget.Icon` will behave like a button
    with a single icon, but it does not include the border or tap animations of a
    regular button (which may not be desired in some situations). We start this example
    by creating `tapicon.go` and proceeding as described:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过在嵌入类型周围实现新的处理程序来扩展现有小部件的另一种方式是添加新功能。在这个例子中，我们将创建一个可点击图标。这个扩展的`widget.Icon`将像按钮一样只有一个图标，但它不包括常规按钮的边框或点击动画（在某些情况下可能不希望有）。我们从这个例子开始创建`tapicon.go`，并按描述进行操作：
- en: 'Once again, we start with a custom struct that embeds the existing widget,
    this time a `widget.Icon`. As before, this should not be a pointer type. In this
    struct, we will also include a `func()` to store the callback that should be run
    when the icon is tapped:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次从一个自定义结构体开始，该结构体嵌入现有的小部件，这次是一个`widget.Icon`。与之前一样，这不应该是一个指针类型。在这个结构体中，我们还将包括一个`func()`来存储当图标被点击时应运行的回调：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We create a constructor function again, primarily to ensure that `ExtendBaseWidget`
    is called. Into this we will pass a `fyne.Resource`, which specifies the icon
    to show, and a `func()`, which will be used to call when the icon is tapped. The
    resource is passed into the original icon as it will still handle the rendering:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次创建一个构造函数，主要是为了确保调用`ExtendBaseWidget`。我们将传递一个`fyne.Resource`到这个函数中，该资源指定要显示的图标，以及一个`func()`，当图标被点击时将调用它。资源被传递到原始图标中，因为它仍然将处理渲染：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To add the tapped functionality, all we need to do is implement the `fyne.Tappable`
    interface, which requires a single method, `Tapped()`, taking a `*PointEvent`
    parameter. We simply execute the callback that was saved earlier inside this function,
    as long as one was set:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加可点击功能，我们只需实现`fyne.Tappable`接口，该接口需要一个方法，即`Tapped()`，它接受一个`*PointEvent`参数。我们只需在这个函数内部执行之前保存的回调，只要设置了回调即可：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For this demonstration, we will create a basic user interface that holds three
    of our `tapIcon` instances, simulating the home, back, and next navigation items
    from an app. To do this, we create a new `makeUI` function that aligns them in
    a horizontal box:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将创建一个基本的用户界面，其中包含我们的三个`tapIcon`实例，模拟来自应用程序的首页、后退和下一项导航元素。为此，我们创建一个新的`makeUI`函数，将它们在水平框中排列：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To complete this example, we create a new `main` function that will set the
    window content to the result of a `makeUI()` call:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个示例，我们创建一个新的`main`函数，该函数将窗口内容设置为`makeUI()`调用的结果：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now run this whole example to see the resulting widgets in action:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行整个示例，以查看操作中的结果小部件：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the application runs, you will see a window like the following that renders
    the icons. You can tap them and see the log output appearing when you do so. We
    have just recreated button widgets without the additional borders, padding, and
    tap animations:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序运行时，您将看到一个类似于以下窗口，它渲染图标。您可以点击它们，并在这样做时看到日志输出。我们只是重新创建了没有额外边框、填充和点击动画的按钮小部件：
- en: '![Figure 7.3 – The tappable icons in a horizontal box'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 水平框中的可点击图标'
- en: '](img/Figure_7.3_B16820.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16820.jpg)'
- en: Figure 7.3 – The tappable icons in a horizontal box
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 水平框中的可点击图标
- en: We have explored some different ways to extend existing widgets, but sometimes
    we want to create something completely new. In these situations, it is possible
    to build a widget from scratch, which we will do next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了扩展现有小部件的一些不同方法，但有时我们想要创建一些完全新的东西。在这些情况下，我们可以从头开始构建一个小部件，这就是我们接下来要做的。
- en: Creating a component from scratch
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头创建组件
- en: Instead of building a new component by extending an existing widget, as we did
    in the previous section, we could build one from scratch. Any component that implements
    the `fyne.Widget` interface can be used as a widget in a Fyne application. To
    ease development, there is a `widget.BaseWidget` definition that we can inherit
    from. Let's start by defining the behavior of a new widget—the three-state checkbox.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一节中通过扩展现有小部件来构建新组件不同，我们可以从头开始构建。任何实现了`fyne.Widget`接口的组件都可以用作Fyne应用程序中的小部件。为了简化开发，有一个`widget.BaseWidget`定义，我们可以从它继承。让我们首先定义一个新的小部件的行为——三态复选框。
- en: Defining widget behavior
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 定义小部件行为
- en: 'The API of a Fyne widget is based on behavior rather than how it looks. To
    begin our widget development, we will therefore define the states that our three-state
    checkbox can take and how a user can interact with it. We will create `threestate.go`
    and start coding:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne小部件的API基于行为而不是外观。因此，为了开始我们的小部件开发，我们将定义我们的三态复选框可以采取的状态以及用户如何与之交互。我们将创建`threestate.go`并开始编码：
- en: 'Firstly, we must define a new type, `CheckState`, which will hold the three
    different states of our new checkbox widget. As we are building a reusable component,
    it is a good idea to export the types that are required, such as `CheckState`
    and the various states it defines. The usage of `iota` defines the first index
    and the following states will increment from that value:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须定义一个新类型`CheckState`，它将保存我们新复选框小部件的三个不同状态。由于我们正在构建一个可重用组件，导出所需的类型，如`CheckState`及其定义的各种状态，是一个好主意。`iota`的使用定义了第一个索引，后续状态将从该值递增：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then define the core of the new component, calling it `ThreeStateCheck,`
    and setting it to inherit the basic widget behavior from `widget.BaseWidget`.
    Using `BaseWidget` is optional but it saves some coding. We add a field named
    `State` that will hold the current state of the check widget:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义新组件的核心，将其命名为`ThreeStateCheck`，并设置它从`widget.BaseWidget`继承基本小部件行为。使用`BaseWidget`是可选的，但它可以节省一些编码工作。我们添加一个名为`State`的字段，它将保存检查小部件的当前状态：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we create a constructor function for this new type. As with previous
    examples, we need to call `ExtendBaseWidget`; in this case, the basic functionality
    that we have inherited is set up correctly:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为这个新类型创建一个构造函数。与之前的示例一样，我们需要调用`ExtendBaseWidget`；在这种情况下，我们继承的基本功能已经正确设置：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last behavior element of this type is its ability to respond to tap events.
    We set up a `Tapped` handler, just as we did with the tappable icon in the previous
    section. This time, we will rotate the three states of this widget, wrapping to
    `CheckOff` if the previous state was `CheckIndeterminate`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此类型行为的最后一个元素是其对触摸事件的响应能力。我们设置了一个`Tapped`处理程序，就像我们在上一节中对可触摸图标所做的那样。这次，我们将旋转此小部件的三个状态，如果上一个状态是`CheckIndeterminate`，则将其包裹到`CheckOff`：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That is all that we need to write to define the behavior of this new widget.
    However, because it is a new component (instead of an extension of an existing
    widget), we must also define how it will be rendered, which we will do next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义这个新小部件行为所需编写的全部内容。然而，因为它是一个新组件（而不是现有小部件的扩展），我们必须定义它的渲染方式，这将在接下来的内容中完成。
- en: Implementing rendering details
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实现渲染细节
- en: 'For a new widget to be complete, it must also define how it will be rendered.
    This requires a new type that implements `fyne.WidgetRenderer`, as we will implement
    ahead. This new type must be returned from a `CreateRenderer` function on the
    widget implementation as well, as you will see in the code ahead. This renderer
    will use one of three checkbox icons—two are built into the Fyne theme and the
    third we will provide in this code base. Note that extra resources like this should
    be bundled for distribution, which will be discussed in detail in [*Chapter 9*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219),
    *Bundling Resources and Preparing for Release,* in the *Bundling assets* section:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使新小部件完整，它还必须定义其渲染方式。这需要一个实现`fyne.WidgetRenderer`的新类型，正如我们将在下面实现的那样。这个新类型必须从小部件实现中的`CreateRenderer`函数返回，正如你将在下面的代码中看到的。这个渲染器将使用三个复选框图标之一——两个内置在Fyne主题中，第三个我们将在此代码库中提供。请注意，像这样的额外资源应该捆绑以供分发，这将在*第9章*中详细讨论，*捆绑资源和准备发布*部分，在*捆绑资产*节中：
- en: 'To start the renderer definition, we create a new type named `threeStateRender`;
    this should not be exported, as renderer details are private. This will hold a
    reference to the `ThreeStateCheck` that it is rendering, as well as a `canvas.Image`
    that will display one of the three icons used for our check widget:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始渲染器定义，我们创建一个名为`threeStateRender`的新类型；这个类型不应该被导出，因为渲染器细节是私有的。这将持有它所渲染的`ThreeStateCheck`的引用，以及一个将显示我们检查小部件所使用的三个图标之一的`canvas.Image`：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Just as if we were defining a layout for a container, we need to define how
    elements of a widget renderer are sized and positioned. In this example, we will
    simply specify that our checkbox icons should be set to `theme.IconInlineSize`
    to be consistent with other widgets. We define this as our `MinSize` and use the
    same value to size our widget when it is asked to define a `Layout`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们定义容器布局一样，我们需要定义小部件渲染器元素的尺寸和位置。在这个例子中，我们将简单地指定我们的复选框图标应设置为 `theme.IconInlineSize`，以与其他小部件保持一致。我们将其定义为我们的
    `MinSize` 并在需要定义 `Layout` 时使用相同的值来调整小部件的尺寸：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To complete our renderer, we must also define the additional methods: the `Destroy`
    (called when this renderer is no longer needed), `Objects` (which returns the
    list of graphical elements), and `Refresh` (which is called if a state changes)
    methods. These methods are relatively simple—most are empty, and the `Refresh`
    method simply calls a new `updateImage` method, which is defined in the next step:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的渲染器，我们还必须定义额外的方法：`Destroy` 方法（当此渲染器不再需要时调用），`Objects` 方法（返回图形元素列表），以及
    `Refresh` 方法（如果状态发生变化时调用）。这些方法相对简单——大多数都是空的，而 `Refresh` 方法只是简单地调用一个新定义的 `updateImage`
    方法，该方法将在下一步定义：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The key to ensuring that the widget is up to date is the selection of the right
    image for the current state. We do this in a new `updateImage` method, described
    in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保小部件是最新的关键是选择当前状态的正确图像。我们通过一个新的 `updateImage` 方法来完成这项工作，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It simply checks the state and picks a resource to display. In the normal states,
    we can use built-in icons from the theme, but for our new indeterminate state,
    we must load our own resource. As we noted earlier in this section, the asset
    should be bundled, but we will explore this in more detail in [*Chapter 9*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219),
    *Bundling Resources and Preparing for Release*.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它只是检查状态并选择一个要显示的资源。在正常状态下，我们可以使用主题内置的图标，但对我们新的不确定状态，我们必须加载自己的资源。正如我们在此节前面提到的，资产应该被打包，但我们将更详细地探讨这一点，在[*第
    9 章*](B16820_09_Final_JM_ePub.xhtml#_idTextAnchor219)，*打包资源和准备发布*。
- en: 'The last part of writing a `WidgetRenderer` is to return it from the `CreateRenderer`
    method defined on the widget that we have created:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `WidgetRenderer` 的最后一部分是从我们创建的小部件上定义的 `CreateRenderer` 方法返回它：
- en: '[PRE19]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this method, we set up the renderer and pass it a `canvas.Image` instance
    that it can use to display. We then call the `updateImage` method that we defined
    earlier to ensure that the initial state is rendered correctly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们设置渲染器并传递一个 `canvas.Image` 实例，它可以使用该实例来显示。然后我们调用之前定义的 `updateImage`
    方法，以确保初始状态正确渲染：
- en: 'To be able to run this demo, all we need to do is add the usual `main` function.
    This time, we will set the content to a single three-state checkbox using `NewThreeStateCheck()`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行这个演示，我们只需要添加一个常规的 `main` 函数。这次，我们将内容设置为单个三态复选框，使用 `NewThreeStateCheck()`：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now run the code as usual with the `go run` command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `go run` 命令像往常一样运行代码：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the application will display the first window in Figure 7.4\. Tapping
    the icon will rotate the checkbox through the three states that are illustrated:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序将显示图 7.4 中的第一个窗口。点击图标将使复选框旋转到图中所示的三个状态：
- en: '![Figure 7.4 – The three states of our custom checkbox'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 我们自定义复选框的三个状态]'
- en: '](img/Figure_7.4_B16820.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 自定义复选框的三个状态](img/Figure_7.4_B16820.jpg)'
- en: Figure 7.4 – The three states of our custom checkbox
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 我们自定义复选框的三个状态
- en: We have now explored the various ways to extend widgets to add new behavior
    and to create completely new components. As you can see from the figures in the
    chapter so far, they all look similar because they respect the current theme.
    In the next section, we will see how to make application-wide style changes using
    a custom theme.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探讨了扩展小部件以添加新行为和创建全新组件的各种方法。正如您从本章到目前为止的图中可以看到，它们看起来都很相似，因为它们尊重当前的主题。在下一节中，我们将看到如何使用自定义主题进行全局样式更改。
- en: Adding a custom theme
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义主题
- en: To bring some individual style or brand identity to an application, it can be
    useful to define a custom theme. This is a powerful feature, but should be used
    carefully. The selection of colors can significantly impact the readability of
    text elements and icons. Additionally, users of Fyne applications are allowed
    to choose between light and dark modes, so it is important that your theme reflects
    this choice where possible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给应用程序带来一些个性风格或品牌识别，定义一个自定义主题可能很有用。这是一个强大的功能，但应谨慎使用。颜色的选择可能会显著影响文本元素和图标的可读性。此外，Fyne应用程序的用户可以自由选择亮色和暗色模式，因此您的主题应尽可能反映这一选择。
- en: There are two ways that developers can create a custom theme—either by defining
    a new theme from scratch by implementing the `Theme` interface, or by inheriting
    from the standard theme. Each have their own benefits, and so we will explore
    both, starting with looking at creating a brand new theme.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过两种方式创建自定义主题——要么从头开始定义一个新主题并实现`Theme`接口，要么从标准主题继承。每种方法都有其优点，因此我们将探讨两种方法，首先从创建全新的主题开始。
- en: Implementing the theme interface
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现主题接口
- en: 'All themes in Fyne are provided by implementing the `fyne.Theme` interface
    (much like any widget will implement `fyne.Widget`). The interface requires us
    to provide four methods that are used to look up the details of a theme. These
    methods are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne中的所有主题都是通过实现`fyne.Theme`接口（就像任何小部件都将实现`fyne.Widget`一样）来提供的。该接口要求我们提供四个方法，用于查找主题的详细信息。这些方法如下：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can guess, these methods return the color, size, icon, and fonts provided
    by a theme. The four signatures vary, but the meanings are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜，这些方法返回主题提供的颜色、大小、图标和字体。四个签名各不相同，但含义如下：
- en: '`Color`: The color lookup uses two parameters: the first is the name of the
    requested color (which we will explore more later) and the second is `ThemeVariant`.
    At the time of writing, there are two variants: `theme.VariantLight` and `theme.VariantDark`.
    This allows a theme to adapt to light and dark mode, although doing so is optional.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`颜色`: 颜色查找使用两个参数：第一个是请求的颜色名称（我们将在稍后进行更多探讨）和第二个是`ThemeVariant`。在撰写本文时，有两种变体：`theme.VariantLight`和`theme.VariantDark`。这允许主题适应亮色和暗色模式，尽管这样做是可选的。'
- en: '`Size`: This lookup takes only the size name parameter. It is one of the `ThemeSizeName`
    constants, such as `theme.SizeNamePadding` or `theme.SizeNameText`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`大小`: 此查找仅接受大小名称参数。它是`ThemeSizeName`常量之一，例如`theme.SizeNamePadding`或`theme.SizeNameText`。'
- en: '`Font`: This lookup takes `TextStyle` as its lookup parameter. A theme can
    choose which font to return for the various styles, such as `TextStyle{Bold: true}`
    for bold. The theme should also check the `Italic` and `Monospaced` fields. Other
    options may be added in future releases.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字体`: 此查找以`TextStyle`作为查找参数。主题可以选择为各种样式返回哪种字体，例如`TextStyle{Bold: true}`用于粗体。主题还应检查`Italic`和`Monospaced`字段。未来版本可能会添加其他选项。'
- en: '`Icon`: The final method allows a theme to provide custom icons if desired.
    The parameter is the name of the icon resource and the returned resource can be
    an image in PNG, JPEG, or SVG format. It is normally advisable for you to use
    `theme.NewThemedResource` if returning an SVG file so that it will adapt to the
    theme variant.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图标`: 最后一种方法允许主题在需要时提供自定义图标。参数是图标资源的名称，返回的资源可以是PNG、JPEG或SVG格式的图像。通常建议您在返回SVG文件时使用`theme.NewThemedResource`，以便它能够适应主题变体。'
- en: The `Color` method is the most complex of these, as it is expected (but not
    required) to return different values depending on the `ThemeVariant` passed in.
    Most theme colors would likely change if the user switched from light to dark
    mode; you can see this in the standard theme. However, not all do. As the user
    is able to pick their preferred primary color, it is common to keep this consistent
    between modes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`颜色`方法是这些方法中最复杂的，因为它预期（但不要求）根据传入的`ThemeVariant`返回不同的值。大多数主题颜色在用户从亮色模式切换到暗色模式时可能会发生变化；您可以在标准主题中看到这一点。然而，并非所有颜色都会变化。由于用户可以挑选他们喜欢的首选颜色，因此通常在两种模式下保持这种一致性。'
- en: To manage the various values for `ThemeColourName` and `ThemeSizeName`, the
    `theme` package provides collections of constants, named `theme.ColorNameXxx`,
    `theme.SizeNameXxx,` and `theme.IconNameXxx`. A complete theme should return a
    suitable value for each of these constants. At the time of writing, the size constants
    are `SizeNamePadding`, `SizeNameScrollBar`, `SizeNameScrollBarSmall`, `SizeNameText`,
    and `SizeNameInlineIcon`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理`ThemeColourName`和`ThemeSizeName`的各种值，`theme`包提供了常量集合，命名为`theme.ColorNameXxx`、`theme.SizeNameXxx`和`theme.IconNameXxx`。一个完整的主题应该为这些常量中的每一个返回一个合适的值。在撰写本文时，大小常量是`SizeNamePadding`、`SizeNameScrollBar`、`SizeNameScrollBarSmall`、`SizeNameText`和`SizeNameInlineIcon`。
- en: 'The list of colors is far longer, and will probably grow as new theming capabilities
    are added. The list currently required is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色列表很长，并且随着新主题功能的添加可能会增长。目前所需列表如下：
- en: '`ColorNameBackground`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameBackground`'
- en: '`ColorNameButton`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameButton`'
- en: '`ColorNameDisabledButton`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameDisabledButton`'
- en: '`ColorNameDisabled`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameDisabled`'
- en: '`ColorNameFocus`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameFocus`'
- en: '`ColorNameForeground`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameForeground`'
- en: '`ColorNameHover`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameHover`'
- en: '`ColorNamePlaceHolder`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNamePlaceHolder`'
- en: '`ColorNamePrimary`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNamePrimary`'
- en: '`ColorNameScrollBar`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameScrollBar`'
- en: '`ColorNameShadow`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorNameShadow`'
- en: Although it is recommended that you implement a return value (that adapts to
    the requested variant) for each of the colors and sizes listed, there may be new
    items added over time that your theme may not know about. To help adapt to these
    situations, it is possible to specify that the theme extends the built-in one
    (which will always have a suitable color available). We will look at this next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然建议为列出的每种颜色和大小实现一个返回值（该值适应请求的变体），但随着时间的推移可能会添加新的项目，你的主题可能不知道。为了帮助适应这些情况，可以指定主题扩展了内置的主题（它将始终有合适的颜色可用）。我们将在下一节中探讨这一点。
- en: Providing customizations to the standard theme
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供标准主题的定制
- en: In some cases, an application developer may wish to only modify certain color
    elements of a theme, such as introducing their own primary color to match their
    company branding. To support this, you can implement a partial theme and ask that
    it delegate any items that are not defined to the default theme that ships as
    part of Fyne. To do this, you can partially implement a theme and call out to
    `theme.DefaultTheme()` methods to provide the standard values. This could also
    be used to change the font in an application, for example, while leaving the colors
    as standard.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，应用程序开发者可能希望只修改主题的某些颜色元素，例如引入他们自己的主色以匹配他们的公司品牌。为了支持这一点，你可以实现一个部分主题，并要求它将任何未定义的项目委托给作为Fyne一部分提供的默认主题。为此，你可以部分实现一个主题，并调用`theme.DefaultTheme()`方法来提供标准值。这也可以用来在应用程序中更改字体，例如，同时保留颜色为标准。
- en: 'Let''s look at a simple theme customization that wants to use a monospaced
    font for all text and wants that text to be orange. We will start in a new file,
    `theme.go`, and begin as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的主题定制，它希望所有文本都使用等宽字体，并且希望这些文本是橙色。我们将在一个新的文件`theme.go`中开始，如下所示：
- en: 'To implement the `Theme` interface, we need to define a new type. We will use
    an empty `struct` for now:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`Theme`接口，我们需要定义一个新的类型。现在我们将使用一个空的`struct`：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To always use a monospace font, we can implement the `Font` function and return
    the default font resource for any request:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要始终使用等宽字体，我们可以实现`Font`函数并返回任何请求的默认字体资源：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then want to specify that the text should be an orange color. To do this,
    we implement the `Color` method and return this custom value when the name is
    `Colors.Text`. We can ignore the `ThemeVariant` parameter as we are not providing
    different values for light and dark. By delegating to `theme.DefaultTheme()` for
    all other colors, we will specify that the default theme values should be used:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们希望指定文本应该是橙色。为此，我们实现`Color`方法，并在名称为`Colors.Text`时返回这个自定义值。由于我们不提供浅色和深色不同的值，我们可以忽略`ThemeVariant`参数。通过将所有其他颜色委托给`theme.DefaultTheme()`，我们将指定应使用默认主题的值：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We do not have any size considerations, but we must implement the method. We
    simply return the value from the default theme so that the current sizes will
    be used:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有大小考虑，但我们必须实现这个方法。我们只需简单地返回默认主题的值，以便使用当前的大小：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Similarly, we need to provide an empty `Icon` function that will return the
    default theme icon.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们需要提供一个空的`Icon`函数，它将返回默认主题的图标。
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To be able to demonstrate the theme, we create a simple interface with a `Label`,
    `Entry`, and `Button`. The following `makeUI` function returns these elements
    in a vertical box:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够展示主题，我们创建了一个简单的界面，包含一个`Label`、`Entry`和一个`Button`。下面的`makeUI`函数将这些元素以垂直框的形式返回：
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lastly, we create a `main` function that loads and runs our app. Note that
    this time we call `App.Settings().SetTheme`, which will set a new theme to be
    used, as shown in the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`main`函数来加载并运行我们的应用程序。注意这次我们调用了`App.Settings().SetTheme`，这将设置一个新主题，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now run this app in the usual way, or specify the dark theme as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以像往常一样运行此应用程序，或者指定深色主题，如下所示：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And now we can see the result of our custom theme. All text is monospaced and
    of a bright orange color!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们自定义主题的结果。所有文本都是等宽的，并且是明亮的橙色！
- en: '![Figure 7.5 – Using a custom theme'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 使用自定义主题'
- en: '](img/Figure_7.5_B16820.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5](img/Figure_7.5_B16820.jpg)'
- en: Figure 7.5 – Using a custom theme
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 使用自定义主题
- en: Now that we have seen how app-specific themes and custom widgets can add to
    a Fyne application interface, we will bring it together in an example application.
    This time, we will build a chat app interface.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何通过特定的应用程序主题和自定义小部件来增强Fyne应用程序界面，我们将在一个示例应用程序中将它们结合起来。这次，我们将构建一个聊天应用界面。
- en: Implementing a chat app user interface
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现聊天应用用户界面
- en: A common example of graphical applications, especially in a mobile context,
    is the messaging app. Although there are many messaging apps now, they often share
    the design of colored textboxes scrolling back through time. They are also either
    left or right aligned (with some padding for emphasis) to show incoming messages
    as distinct from outgoing. In this example, we will implement the message component
    to show text in this way and apply a custom theme to give the app an identity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图形应用程序的一个常见例子，尤其是在移动环境中，是消息应用。尽管现在有许多消息应用，但它们通常共享彩色文本框的设计，这些文本框可以滚动回过去。它们也通常是左对齐或右对齐（带有一些填充以强调），以区分传入的消息和发出的消息。在这个例子中，我们将实现消息组件以这种方式显示文本，并应用自定义主题以赋予应用一个身份。
- en: Creating a message widget
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建消息小部件
- en: 'We start with the message widget that is used to display a single message.
    Each message will have a body of text and the name of the person who sent the
    message. Using the sender name, we can determine whether the message is outgoing.
    To begin, we define a custom `Widget` type that will hold this data in a new file,
    `message.go`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从用于显示单个消息的消息小部件开始。每条消息都将有一个文本正文和发送消息的人的名字。使用发送者的名字，我们可以确定这条消息是发出的。首先，我们定义一个自定义的`Widget`类型，它将在新的文件`message.go`中保存这些数据：
- en: 'To create a custom widget, we define a new type, named `message`, that extends
    `widget.BaseWidget`. We add to this our own fields, `text` and `from`, which will
    hold our widget state:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个自定义小部件，我们定义一个新的类型，命名为`message`，它扩展了`widget.BaseWidget`。我们添加了自己的字段，`text`和`from`，它们将保存我们的小部件状态：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will also make use of some constant values in this example—`myName` is the
    name that we will use for outgoing messages. Obviously, in a real app this would
    be a user setting. `messageIndent` is a value that determines how much left or
    right space will appear in our message output to align the incoming and outgoing
    messages:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在这个例子中使用一些常量值——`myName`是我们将用于发出消息的名字。显然，在一个真正的应用中，这将是用户设置。`messageIndent`是一个值，它决定了在我们的消息输出中会出现多少左或右的空间，以对齐传入和发出的消息：
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As with our examples earlier in this chapter, we create a helpful constructor
    function that sets up the custom widget and ensures that `ExtendBaseWidget` is
    called:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与本章前面的示例一样，我们创建了一个有用的构造函数，用于设置自定义小部件并确保调用`ExtendBaseWidget`：
- en: '[PRE33]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Most of the work in our custom message widget relates to its positioning and
    style, so its renderer is where we have to do most of the work. We start this
    by defining a custom renderer type, `messageRender`. There is no standard renderer
    type to extend, but we will want to save a reference to the `message` widget that
    it is rendering (in case we need to read its state). We also add `Rectangle` for
    the background and `Label` that will display our text:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的自定义消息小部件中，大部分工作都与它的定位和样式相关，因此渲染器是我们必须做大部分工作的地方。我们首先定义一个自定义渲染器类型，`messageRender`。没有标准的渲染器类型可以扩展，但我们将想要保存它所渲染的`message`小部件的引用（以防我们需要读取其状态）。我们还添加了`Rectangle`作为背景和将显示我们的文本的`Label`：
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An important part of `Widget` (or any `CanvasObject`) is to know its minimum
    size. This determines how layouts will pack the content on screen. Our size is
    complicated by the use of wrapped text—the available width will alter the height.
    We create a helper method, `messageMinSize`, that will return the actual minimum
    size for an available width, from which we subtract `messageIndent` to create
    the gap in the resulting display (making it clearer which messages are incoming
    compared to outgoing):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Widget`（或任何`CanvasObject`）的一个重要部分是知道其最小尺寸。这决定了布局如何在屏幕上打包内容。我们的尺寸因使用换行文本而变得复杂——可用宽度将改变高度。我们创建了一个辅助方法`messageMinSize`，它将返回可用宽度下的实际最小尺寸，然后我们从其中减去`messageIndent`以创建最终显示中的间隙（使其更清晰地区分传入和发出的消息）：'
- en: '[PRE35]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we know the space required for the text, we can implement the `MinSize`
    method. We add `messageIndent` to the width so that the horizontal space is reserved:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了文本所需的空间，我们可以实现`MinSize`方法。我们将`messageIndent`添加到宽度中，以便保留水平空间：
- en: '[PRE36]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The main logic for our renderer is the `Layout` method. It must size and position
    the text and background rectangles within the `Widget`. All positions are relative
    to our widget''s top-left position:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们渲染器的主要逻辑是`Layout`方法。它必须在`Widget`内调整文本和背景矩形的尺寸和位置。所有位置都是相对于我们的小部件的左上角位置：
- en: '[PRE37]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After calculating the full size of the text content plus padding, we set up
    the graphical details of this component. If it is an outgoing message, we right-align
    the content and set it to a `blue` color; otherwise, we make it green. The calculated
    sizes and positions are then applied to the elements.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在计算文本内容加上填充的完整大小后，我们设置此组件的图形细节。如果是发出的消息，我们将内容右对齐并设置为`蓝色`；否则，我们将其设置为绿色。然后，将计算出的尺寸和位置应用于元素。
- en: 'To complete the renderer, we must implement the remaining methods. These are
    mostly empty because this example does not use dynamic data. The `Objects` method
    returns each of the elements included in the order they should be drawn, so the
    background must be before the text:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成渲染器，我们必须实现剩余的方法。这些方法大多为空，因为此示例没有使用动态数据。`Objects`方法返回应该按绘制顺序包含的每个元素，因此背景必须在文本之前：
- en: '[PRE38]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The last function to complete this widget is the method that links `Widget`
    with `WidgetRenderer`. We pass in the canvas objects that will be drawn to save
    us from recreating them later:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此小部件的最后一个函数是将`Widget`与`WidgetRenderer`链接起来的方法。我们传入将要绘制的画布对象，以避免稍后重新创建它们：
- en: '[PRE39]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This completes the custom component, but before we can test it, we need to create
    the user interface that will use them. We start by making a list of message widgets.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了自定义组件，但在我们可以测试它之前，我们需要创建将使用它们的用户界面。我们首先创建一个消息小部件列表。
- en: Listing messages
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列出消息
- en: 'To create the rest of the user interface, we will create a new file, `main.go`,
    and add the standard components. Firstly, we create a list of messages:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用户界面的其余部分，我们将创建一个新的文件`main.go`，并添加标准组件。首先，我们创建一个消息列表：
- en: 'Using the `newMessage` function we created earlier, it is simple to create
    a message list. We just create a `VBox` container and pass it a list of `message`
    widgets created using that helper function. Clearly, in a full application, this
    would use an external data source of some sort:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前创建的`newMessage`函数，创建一个消息列表非常简单。我们只需创建一个`VBox`容器，并传递一个使用该辅助函数创建的`message`小部件列表。显然，在一个完整的应用程序中，这将使用某种外部数据源：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can implement a simple `main` function to show us our progress so far. This
    will be useful later when the full user interface is ready to run. For this version,
    we just set the window content to the list returned from `loadMessages()`. We
    give the window a sensible size and show it:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以实施一个简单的`main`函数来展示我们到目前为止的进度。这将有助于稍后当完整用户界面准备好运行时。对于这个版本，我们只需将窗口内容设置为从`loadMessages()`返回的列表。我们给窗口一个合理的尺寸并显示它：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now run the message list to see the current work:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行消息列表来查看当前的工作：
- en: '[PRE42]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The result is a list of messages, aligned according to sender, and displaying
    the appropriate color. This can be seen in the following diagram:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个按发送者对齐的消息列表，并显示适当的颜色。这可以在以下图中看到：
- en: '![Figure 7.6 – Our messaging list in the default theme'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.6 – Our messaging list in the default theme'
- en: '](img/Figure_7.6_B16820.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.6_B16820.jpg]'
- en: Figure 7.6 – Our messaging list in the default theme
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 默认主题下的我们的消息列表
- en: This completes the message listing (we will add a scroll container around the
    list in the following section). We should also add an input section to send new
    messages, which we will also do next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了消息列表（我们将在下一节中添加一个滚动容器）。我们还应该添加一个输入部分来发送新的消息，我们也将这样做。
- en: Completing the user interface
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完成用户界面
- en: 'The message list looks great, but we want to be able to send new messages.
    Let''s see how this can be done:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 消息列表看起来很棒，但我们希望能够发送新的消息。让我们看看如何实现这一点：
- en: 'To add the remaining user interface elements, we create a new function, `makeUI`,
    and start by adding the `loadMessages` list:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加剩余的用户界面元素，我们创建了一个新的函数`makeUI`，并首先添加`loadMessages`列表：
- en: '[PRE43]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then create a footer that contains an `Entry` to capture the text and a
    `Send` Button to transmit the message:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含用于捕获文本的`Entry`和用于发送消息的`Send`按钮的页脚：
- en: '[PRE44]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: From the preceding code, we can see that by using the `submitEntry` earlier
    in this chapter, you could also support the ability to send on return if you like.
    The button tap handler will create a new message widget and add it to the list,
    which will refresh. It then resets the text in our `Entry`. We return a `Container`
    called `input` that positions these elements appropriately.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到，通过在本章早期使用`submitEntry`，您也可以支持在按回车键时发送消息的功能。按钮点击处理程序将创建一个新的消息小部件并将其添加到列表中，这将刷新。然后它将重置我们的`Entry`中的文本。我们返回一个名为`input`的`Container`，适当地定位这些元素。
- en: 'Lastly, for this function, we return a new `Border` container that positions
    the input row at the bottom and uses the rest of the space for the message list.
    We also add a `Scroll` container around the list so it can contain more data than
    fits on the screen:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于这个函数，我们返回一个新的`Border`容器，将输入行定位在底部，并使用剩余的空间显示消息列表。我们还添加了一个`Scroll`容器围绕列表，以便它可以包含比屏幕上显示更多的数据：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To use this new code, we update the `main` function to call `makeUI()` instead
    of `loadMessages()`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用这段新代码，我们更新`main`函数，将其从调用`loadMessages()`改为调用`makeUI()`：
- en: '[PRE46]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can now run the app again to see the complete interface, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以再次运行应用程序以查看完整的界面，如下所示：
- en: '[PRE47]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This time, we can use the input box at the end to add a new message. In Figure
    7.7, we added a **How about...?** message:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们可以使用末尾的输入框来添加一条新消息。在图7.7中，我们添加了一条**如何...**的消息：
- en: '![Figure 7.7 – Our messaging app in the default theme'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 – 默认主题下的我们的消息应用'
- en: '](img/Figure_7.7_B16820.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.7_B16820.jpg]'
- en: Figure 7.7 – Our messaging app in the default theme
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 默认主题下的我们的消息应用
- en: This completes our application functionality, but we can still make it more
    interesting by applying a custom theme.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的应用程序功能，但我们可以通过应用自定义主题使其更加有趣。
- en: Adding some flair with a custom theme
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义主题添加一些风格
- en: 'The default look of Fyne applications is designed to be clear and attractive,
    but some apps may want to apply more identity or design flair. We will do this
    for our messaging app, starting with a new file, `theme.go`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne应用程序的默认外观设计得既清晰又吸引人，但某些应用程序可能希望应用更多的身份或设计风格。我们将为我们的消息应用做这件事，从一个新的文件`theme.go`开始：
- en: 'We start by defining a new type for our theme. It does not need to manage any
    state or inherit from other structs, so it is created empty:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的类型来表示我们的主题。它不需要管理任何状态或从其他结构体继承，因此我们创建了一个空的结构体：
- en: '[PRE48]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The main purpose of this custom theme is to return a different `Color` for
    certain elements. We start by adapting the `Background` color to display light
    or dark versions of a *blue-gray* color, depending on the current user setting
    (called `ThemeVariant`). We return the default theme lookup at the end of this
    function to show that we do not have a customization for other colors:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个自定义主题的主要目的是为某些元素返回不同的`Color`。我们首先调整`Background`颜色以显示蓝色灰度的浅色或深色版本，这取决于当前用户的设置（称为`ThemeVariant`）。在这个函数的末尾返回默认主题的查找，以表明我们没有为其他颜色提供自定义选项：
- en: '[PRE49]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will also provide a custom color for focused elements. We insert the following
    code into the `switch` statement in the previous code segment. Clearly, many more
    customizations could be provided if you desire:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为聚焦元素提供自定义颜色。我们将以下代码插入到上一段代码段中的`switch`语句中。显然，如果您愿意，可以提供更多自定义选项：
- en: '[PRE50]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this example, we don''t want to provide custom size values or fonts, but
    you could return custom values if you want (as shown in the *Adding a custom theme*
    section earlier). We need to implement these methods, but we will return the default
    theme lookup so that the standard values will be used:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们不希望提供自定义大小值或字体，但如果你想要的话可以返回自定义值（如之前在“添加自定义主题”部分所示）。我们需要实现这些方法，但我们将返回默认主题查找，以便使用标准值：
- en: '[PRE51]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To apply this theme to our app, we use `App.Settings.SetTheme()`. This should
    be called from the `main()` function before `ShowAndRun()`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此主题应用到我们的应用中，我们使用 `App.Settings.SetTheme()`。这应该在 `main()` 函数调用 `ShowAndRun()`
    之前执行：
- en: '[PRE52]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once again, we can run this code and see the completed work:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行此代码，我们可以看到完成的工作：
- en: '[PRE53]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will see the custom theme loaded. In Figure 7.8, it is running with `FYNE_THEME=dark`
    to show that our custom theme works for light and dark modes:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到自定义主题被加载。在图7.8中，它以 `FYNE_THEME=dark` 运行，以表明我们的自定义主题适用于亮暗模式：
- en: '![Figure 7.8 – Using the theme we just wrote in dark mode'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – 使用我们刚刚编写的暗黑模式主题'
- en: '](img/Figure_7.8_B16820.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B16820.jpg)'
- en: Figure 7.8 – Using the theme we just wrote in dark mode
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 使用我们刚刚编写的暗黑模式主题
- en: We have seen how to implement custom widgets and themes to build an attractive
    messaging user interface. It is left as an exercise for the reader to actually
    send and receive messages through your favorite chat protocol!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何实现自定义小部件和主题来构建一个吸引人的消息用户界面。实际通过你喜欢的聊天协议发送和接收消息的任务留给读者作为练习！
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to deviate from the standard components and
    built-in theme in various ways. We explored how existing widgets can be extended
    and adapted, as well as how to build our own components from scratch. We also
    saw how custom themes can be created and how we can apply our own customizations
    to the default theme through theme extension.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何以各种方式偏离标准组件和内置主题。我们探讨了现有小部件如何扩展和适应，以及如何从头开始构建我们自己的组件。我们还看到了如何创建自定义主题，以及我们如何通过主题扩展将我们的自定义修改应用到默认主题中。
- en: With this knowledge, we created an application that was a mix of standard and
    custom components. We added some visual enhancements through our widget's renderer,
    but also created further customization by defining a custom theme. Through the
    code in this chapter, we learned how to customize individual elements and widgets,
    as well as how to make visual changes that apply across custom and standard widgets,
    using the theme API.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些知识，我们创建了一个混合了标准和自定义组件的应用程序。我们通过小部件的渲染器添加了一些视觉增强，但还通过定义自定义主题创建了进一步的定制。通过本章中的代码，我们学习了如何自定义单个元素和小部件，以及如何使用主题API在自定义和标准小部件上应用视觉更改。
- en: This brings us to the end of our exploration of the Fyne toolkit APIs and their
    functionality. In the following chapters, we will see how to create and manage
    GUI applications and how best practices can help make robust software that is
    easy to maintain. We will also learn that applications can be prepared for distribution
    and even uploaded to platform app stores and marketplaces. In the next chapter,
    we will explore the best practices around project structure and how to keep a
    growing GUI app robust and maintainable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们结束了对Fyne工具包API及其功能的探索。在接下来的章节中，我们将看到如何创建和管理GUI应用程序，以及最佳实践如何帮助构建易于维护的健壮软件。我们还将了解到应用程序可以准备分发，甚至可以上传到平台应用商店和市场。在下一章中，我们将探讨项目结构方面的最佳实践，以及如何保持不断增长的GUI应用程序的健壮性和可维护性。
