<html><head></head><body>
		<div id="_idContainer110">
			<h1 id="_idParaDest-204"><em class="italic"><a id="_idTextAnchor205"/>Chapter 8</em>: Project Structure and Best Practices</h1>
			<p>The Go language comes with a well-understood set of best practices such as style, documentation, and code structure. Often, when applications start adding <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) elements, these best practices can be lost. Testing individual components and keeping a clean separation of types helps us maintain clean code that is easier to maintain over time. These concepts can be followed within GUI code as well, with support from a toolkit such as Fyne.</p>
			<p>In this chapter, we'll explore how these concepts apply to graphical application development and how we can learn from them to make our GUIs easier to manage over time. We will cover the following topics:</p>
			<ul>
				<li>Organizing a well-structured project</li>
				<li>Understanding the separation of concerns</li>
				<li>Using test-driven development and writing tests for the whole application GUI</li>
				<li>Managing platform-specific code</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor206"/>Technical requirements</h1>
			<p>This chapter has the same requirements as <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Windows, Canvas, and Drawing</em>; that is, you must have the Fyne toolkit installed and a Go and C compiler working. For more information, please refer to that chapter.</p>
			<p>The full source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08</a>.</p>
			<p>Some parts of this chapter refer to managing platform-specific code, so it may be beneficial if you have two different operating systems available to work with.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor207"/>Organizing your project</h1>
			<p>One <a id="_idIndexMarker519"/>of the design principles of the Go language is that you can start simple and build more structure into your project as it grows. Following this mantra, you can simply start a GUI project with a single <strong class="source-inline">main.go</strong> file inside a directory that's been created for the project. This will initially contain your entire application, starting from its <strong class="source-inline">main()</strong> function.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor208"/>Starting simple</h2>
			<p>Once your user interface has grown from the very basics, it is a good idea to split it into a new file, perhaps named <strong class="source-inline">ui.go</strong>. Splitting the code in this way makes it clearer which code is simply <a id="_idIndexMarker520"/>booting an application (the <strong class="source-inline">main()</strong> function and helpers) compared to what is actually building the user interface.</p>
			<p>By this time, you should be thinking about adding unit tests (if you have not already added them!). These tests will live in a file, alongside your code, that ends in <strong class="source-inline">_test.go</strong> – for example, <strong class="source-inline">ui_test.go</strong>. It is good practice to test all of your code, and for each new function or type you add, there will be new tests to ensure the code is working correctly over time. It is normal for there to not be a test file for the main function since its purpose is simply to wire up the application's components and launch it. A project that has passed the very basic stage might contain the following files:</p>
			<p class="source-code">project/</p>
			<p class="source-code">    main.go</p>
			<p class="source-code">    ui.go</p>
			<p class="source-code">    ui_test.go</p>
			<p>This structure works well until an application needs to add some custom types. We will explore this next.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor209"/>Adding new types</h2>
			<p>Since Fyne application user interface code focuses mainly on behavior, it is common to break up <a id="_idIndexMarker521"/>different areas of an application into separate areas, each defining its own type. Each type will define the data (or data access) that it represents, as well as the various methods that can operate on that information. These sections of the application code could be simple type definitions, where there will likely be a UI creation function, named <strong class="source-inline">makeUI()</strong> or something similar. Here's an example:</p>
			<p class="source-code">func (t *myType) makeUI() fyne.CanvasObject { … }</p>
			<p>Alternatively, they may be custom widgets, in which case the type extends <strong class="source-inline">CanvasObject</strong>, so it can be passed into the wider GUI structure. In either situation, these types deserve a new file, such as <strong class="source-inline">mytype.go</strong>, and their own tests, in <strong class="source-inline">mytype_test.go</strong>. For example, an application that is growing may have the following structure:</p>
			<p class="source-code">project/</p>
			<p class="source-code">    editor.go</p>
			<p class="source-code">    editor_test.go</p>
			<p class="source-code">    files.go</p>
			<p class="source-code">    files_test.go</p>
			<p class="source-code">    main.go</p>
			<p class="source-code">    status.go</p>
			<p class="source-code">    status_test.go</p>
			<p class="source-code">    ui.go</p>
			<p class="source-code">    ui_test.go</p>
			<p>This is a good structure for a simple application, but once the code base grows, especially if it <a id="_idIndexMarker522"/>contains libraries or supporting functionality that are not part of the GUI, you will likely want to consider using multiple packages. So, what happens then? Let's take a look.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor210"/>Splitting code into packages</h2>
			<p>Packages are useful when you want to separate some complex code that manages, for example, data access or complex calculations from the user interface code that will display it. In these situations, a separate package allows you to maintain the clean divide and test <a id="_idIndexMarker523"/>these elements independently (see the <em class="italic">Understanding the separation of concerns</em> section later in this chapter). If you would like this subpackage API to be publicly available, then you can just create a new folder for it (for example, <strong class="source-inline">project/mylib</strong>). Alternatively, you could choose to group many subpackages under a standard <strong class="source-inline">pkg</strong> directory (that is, <strong class="source-inline">project/pkg/mylib</strong>). </p>
			<p>However, if you would like to keep its API as an internal detail for this project, you can use the special <strong class="source-inline">internal</strong> package as its parent (that is, <strong class="source-inline">project/internal/pkg/mylib</strong>).</p>
			<p>It can also be helpful to keep your code tidy if the GUI code makes use of the internal structure as well, so that the top of the project contains fewer files. It is common to use <strong class="source-inline">project/internal/app/</strong> for this purpose. So, an application that contains the <strong class="source-inline">storage</strong> and <strong class="source-inline">cache</strong> internal libraries might begin to look like this:</p>
			<p class="source-code">project/</p>
			<p class="source-code">    internal/</p>
			<p class="source-code">        app/</p>
			<p class="source-code">            editor.go</p>
			<p class="source-code">            editor_test.go</p>
			<p class="source-code">            files.go</p>
			<p class="source-code">            files_test.go</p>
			<p class="source-code">            status.go</p>
			<p class="source-code">            status_test.go</p>
			<p class="source-code">            ui.go</p>
			<p class="source-code">            ui_test.go</p>
			<p class="source-code">        pkg/</p>
			<p class="source-code">            storage/</p>
			<p class="source-code">                storage.go</p>
			<p class="source-code">                storage_test.go</p>
			<p class="source-code">            cache/</p>
			<p class="source-code">                cache.go</p>
			<p class="source-code">                cache_test.go</p>
			<p class="source-code">    main.go</p>
			<p>Using this model, the library packages are all self-contained and the app package can depend on them to operate. The <strong class="source-inline">main.go</strong> file may depend on all of these packages to prepare the application and launch its GUI.</p>
			<p>The preceding <a id="_idIndexMarker524"/>structure works well for a single application repository. The following command will install it directly (note that this should not include a scheme prefix such as <strong class="source-inline">http://</strong>):</p>
			<p class="source-code">$ go get projectURL </p>
			<p>However, in some situations, you will require more than one executable in a project. We'll look at this in the next section.</p>
			<p>Multiple executables</p>
			<p>Regardless of <a id="_idIndexMarker525"/>whether the project is primarily a library or an application that contains multiple executables, there is a standard directory named <strong class="source-inline">cmd</strong> that can contain multiple subdirectories, one for each executable. Each package within <strong class="source-inline">cmd</strong> will contain the name of the application it should compile to, though the <strong class="source-inline">Go</strong> package will always be <strong class="source-inline">main</strong> so that it can be executed.</p>
			<p>So, if your project was mainly a library but contained the <strong class="source-inline">mylib_gui</strong> and <strong class="source-inline">mylib_config</strong> executables, then you would have a structure like the following (omitting any internal code):</p>
			<p class="source-code">project/</p>
			<p class="source-code">    cmd/</p>
			<p class="source-code">        mylib_gui/</p>
			<p class="source-code">            main.go</p>
			<p class="source-code">        mylib_config/</p>
			<p class="source-code">            main.go</p>
			<p class="source-code">    lib.go</p>
			<p>By using this format, someone could depend on your library by using the following command (without <strong class="source-inline">http://</strong> being used):</p>
			<p class="source-code">import "projectURL"</p>
			<p>They could also choose to install the GUI binary using the following command:</p>
			<p class="source-code">$ go get projectURL/cmd/mylib_gui</p>
			<p>This flexibility allows repositories to have multiple purposes while maintaining a clean structure. Of course, there would probably be a lot of common code in <strong class="source-inline">internal/pkg/</strong> or <strong class="source-inline">internal/app/</strong> to allow this.</p>
			<p>The preceding illustrations are just examples – each application will have different requirements and may wish to diverge from these common layouts. To help developers understand an application, its <strong class="source-inline">main()</strong> function should be at the root of a project or in a <strong class="source-inline">cmd/appname/</strong> subdirectory. Similarly, a library's main API should be importable from the root of a project or the <strong class="source-inline">pkg/libname/</strong> subdirectory. Following these hints will make your app or library easier to pick up for new developers who are familiar with the recommended Go project layouts.</p>
			<p>In this section, we learned how an application can be split into multiple pieces. It may not have been clear why this is important, though. In the next section, we'll look at the separation <a id="_idIndexMarker526"/>of concerns, which shows how this approach helps keep our code clean and maintainable for the future.</p>
			<p>Understanding the separation of concerns</p>
			<p>As we mentioned earlier in this chapter, as well as when we discussed the Fyne toolkit API principles in <a href="B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">The Future According to Fyne</em>, in the <em class="italic">Designing APIs for simplicity and maintainability</em> section, the concept of <strong class="bold">separation of concerns</strong> is important if we <a id="_idIndexMarker527"/>wish to maintain a clean code base. It enables us keep related code together without the fear of breaking other areas when we make a change.</p>
			<p>This concept is closely related to the single responsibility principle, as introduced by Robert C. Martin in his <em class="italic">Principles of Object-Oriented Design</em> (<a href="http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>) article. Here, he stated the following:</p>
			<p class="author-quote">"A class should have one, and only one, reason to change."</p>
			<p class="author-quote">–Robert C. Martin</p>
			<p>In this respect, <em class="italic">concerns</em> have a wider scope than responsibilities in that they typically influence your application's design and architecture rather than individual classes or interfaces. Separation of concerns is essential in a graphical application if you wish to correctly detach your easily tested logic from the presentation code, which manages user interaction. By separating the concerns of an application, it is easier to test subcomponents and check the validity of our software without even needing to run the application. In doing so, we create more robust applications that can adapt to changes in requirements or technology over time.</p>
			<p>For example, the Fyne widgets and APIs should not be incorporated into, or impact the design of, your business logic. Even a graphical API focused on behavior, such as the Fyne toolkit, should only be referenced by the presentation layer of your application (items in the project root or <strong class="source-inline">internal/app</strong> packages). It is for this reason that a robust application is split into multiple areas. Each of the supporting libraries will operate without any reference to the presentation layer or toolkit's capabilities. In this way, we keep the software open to change without it having a huge impact on unrelated areas.</p>
			<p>In the next section, we'll learn how the provided test utilities help ease the creation of unit tests. We can do this by keeping our code separated into smaller components. This is useful for <a id="_idIndexMarker528"/>validating the behavior of the presentation code of our apps.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor211"/>Test driving your development</h1>
			<p>The effort required to automatically test user interfaces or frontend software is often considered too expensive for the value it returns when it comes to avoiding future bugs. However, this is largely rooted in the toolkits being utilized or even the presentation technologies <a id="_idIndexMarker529"/>that have been chosen. Without full support for testing in the development tools or graphical APIs, it can be difficult to create simple unit tests without a huge amount of effort being needed.</p>
			<p>One of the design principles of the Fyne toolkit is that the application GUI should be as easy to test as the rest of its code. This is partly made possible by the API's design, but this is further reinforced by the test utilities that we can provision. We will explore this later in this section. Using the following approaches, we will learn how a Fyne application can follow <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>), even for the user interface components.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>Designed to be tested</h2>
			<p>The modular design of the Fyne toolkit allows different drivers to be loaded for different systems or purposes. This approach primarily supports Fyne applications working on any operating system, without developers needing to modify their applications. An additional benefit of this approach is that an app can be loaded<a id="_idIndexMarker530"/> into a test runtime to execute various checks, without ever needing to display to the screen. This vastly improves the speed of test runs and also makes your tests more reliable (as user interaction cannot interfere with the test process).</p>
			<p>By importing the <strong class="source-inline">fyne.io/fyne/test</strong> package, we automatically create an in-memory application that is capable of creating virtual windows that contain actual application GUIs. These windows support the same APIs as regular windows so that your code can run the same as it ran previously. Each graphical element can be programmatically interacted with and tested to confirm its behavior and state, and even to verify its rendering output.</p>
			<p>In the next two examples, we'll learn how to test the behavior of a user interface component and then how to verify that it rendered correctly, all without needing to display the GUI on a screen.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/>Testing our GUI logic</h2>
			<p>To test the functionality <a id="_idIndexMarker531"/>of an application, we must define a very simple GUI. It will have a <strong class="source-inline">Hello World!</strong> label, followed by an entry widget that we can use to specify our name. The final component – a simple button – will be triggered, updating the greeting based on the input. Here is how it works:</p>
			<ol>
				<li>First, we define a simple <strong class="source-inline">struct</strong> called <strong class="source-inline">greeter</strong> that will hold references to these objects. For this example, we will write the following code to <strong class="source-inline">ui.go</strong>:<p class="source-code">type greeter struct {</p><p class="source-code">    greeting       *widget.Label</p><p class="source-code">    name           *widget.Entry</p><p class="source-code">    updateGreeting *widget.Button</p><p class="source-code">}</p></li>
				<li>Since we are not creating a custom widget in this example, we will define a small method named <strong class="source-inline">makeUI</strong> that will construct the widgets that represent this application. In this case, this is a simple vertical box container that combines all the widgets that we created following the preceding description. We create each of the widgets, assign them to variables of the <strong class="source-inline">greeter</strong> type, and then return a vertical box that packs them together:<p class="source-code">func (g *greeter) makeUI() fyne.CanvasObject {</p><p class="source-code">    g.greeting = widget.NewLabel("Hello World!")</p><p class="source-code">    g.name = widget.NewEntry()</p><p class="source-code">    g.name.PlaceHolder = "Enter name"</p><p class="source-code">    g.updateGreeting = widget.NewButton("Welcome", </p><p class="source-code">        g.setGreeting)</p><p class="source-code">    return container.NewVBox(g.greeting, g.name, g.up</p><p class="source-code">        dateGreeting)</p><p class="source-code">}</p></li>
				<li>To perform the update, when the button is tapped, we need an additional function, <strong class="source-inline">setGreeting</strong>, that will format a replacement string using <strong class="source-inline">fmt.Sprintf</strong>. It passes in the current content of the <strong class="source-inline">name</strong> entry widget to make the greeting personal. This looks as follows:<p class="source-code">func (g *greeter) setGreeting() { </p><p class="source-code">    text := fmt.Sprintf("Hello %s!", g.name.Text) </p><p class="source-code">    g.greeting.SetText(text) </p><p class="source-code">} </p></li>
				<li>Lastly, we create <a id="_idIndexMarker532"/>a simple <strong class="source-inline">main</strong> function that will load the greeter, display it in a window, and run the application:<p class="source-code">func main() {</p><p class="source-code">     a := app.New()</p><p class="source-code">     w := a.NewWindow("Hello!")</p><p class="source-code">     g := &amp;greeter{}</p><p class="source-code">     w.SetContent(g.makeUI())</p><p class="source-code">     w.ShowAndRun()</p><p class="source-code">}</p></li>
			</ol>
			<p>You can verify that the application works correctly by simply running it, as follows:</p>
			<p class="source-code">$ go run ui.go</p>
			<p>In this section, we're focusing on the tests we must employ, so let's write a unit test that validates the behavior we defined earlier:</p>
			<ol>
				<li value="1">First, create the test file that will be provided along with this code; that is, <strong class="source-inline">ui_test.go</strong>. Here, we define a test with the standard signature. It must start with <strong class="source-inline">Test</strong> and accept a single parameter; that is, a <strong class="source-inline">testing.T</strong> pointer:<p class="source-code">func TestGreeter_UpdateGreeting(t *testing.T) {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>In this function, we will create a new instance of our greeter and request that the interface components are created. Once this has been run, we assert that the initial state is correct. Here, we use the <strong class="source-inline">assert</strong> package from the testify project by <strong class="source-inline">stretchr</strong> (more information can be found at <a href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a>). This will use the <strong class="source-inline">github.com/stretchr/testify/assert</strong> import path, which should be added to the top of the file.<p>By adding the following code, you can set up the user interface so that it can be tested and perform its first assertions:</p><p class="source-code">    g := &amp;greeter{}</p><p class="source-code">    g.makeUI()</p><p class="source-code">    assert.Equal(t, "Hello World!", g.greeting.Text)</p><p class="source-code">    assert.Equal(t, "", g.name.Text)</p></li>
				<li>The final step of writing this test is to execute the user steps and check the resulting changes. We're using Fyne's <strong class="source-inline">test</strong> package to simulate a user typing into the entry <a id="_idIndexMarker533"/>widget and then tapping the button to confirm this. After that, we confirm that the greeting text has been updated:<p class="source-code">    test.Type(g.name, "Joe")</p><p class="source-code">    test.Tap(g.updateGreeting)</p><p class="source-code">    assert.Equal(t, "Hello Joe!", g.greeting.Text)</p></li>
			</ol>
			<p>With this test code, we can be sure that the user interface is working correctly. It can be simply executed like any other go test:</p>
			<p class="source-code">$ go test .</p>
			<p>With that, we know that the app works correctly. However, it can be helpful to verify that the output is being rendered as expected. Let's write a new test to do that.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor214"/>Verifying that the output is being rendered</h2>
			<p>In most situations, an application can be tested for correctness through behavior testing, as we <a id="_idIndexMarker534"/>saw previously. However, it is sometimes useful to actually see what will be rendered to check the result. If your application contains custom drawing code or complex layouts, this may be appropriate.</p>
			<p>In this section, we will create a new test, similar to the one we created in the preceding section, but in this case, we will test the rendered output using another <strong class="source-inline">test</strong> utility. Let's see how this works: </p>
			<ol>
				<li value="1">Create a new method, as shown in the following code. Once you've set up the <strong class="source-inline">greeter</strong> type, pass <strong class="source-inline">g.makeUI()</strong> into <strong class="source-inline">test.NewWindow()</strong>. This will create an in-memory window that we can use to capture the output, as follows:<p class="source-code">func TestGreeter_Render(t *testing.T) {</p><p class="source-code">    g := &amp;greeter{}</p><p class="source-code">    w := test.NewWindow(g.makeUI())</p><p class="source-code">}</p></li>
				<li>With a test window created, we can get its content using <strong class="source-inline">w.Canvas().Capture()</strong>. This function will return an image with the interface rendered as if it were running in a real window. <p>Now, we can use the <strong class="source-inline">AssertImageMatches</strong> test utility, which requires that the test compares this image to the named file, as follows:</p><p class="source-code">    test.AssertImageMatches(t, "default.png", </p><p class="source-code">        w.Canvas().Capture())</p></li>
				<li>This code <a id="_idIndexMarker535"/>will compare the default look. Now, we can simulate user actions again and compare the new state to another image file with an appropriate name:<p class="source-code">    test.Type(g.name, "Joe")</p><p class="source-code">    test.Tap(g.updateGreeting)</p><p class="source-code">    test.AssertImageMatches(t, "typed_joe.png",</p><p class="source-code">        w.Canvas().Capture())</p></li>
			</ol>
			<p>You can run these tests just like the behavior tests before, though this time, the tests will fail because the images it is being compared to don't exist. You will find two new files inside the <strong class="source-inline">testdata/failed/</strong> directory. </p>
			<p>You should look at these files to see what is being drawn. If you agree that the output is correct, then these files can be moved to the <strong class="source-inline">testdata/</strong> directory. On a second run of these tests, you will see that they all pass as expected. The following screenshot shows what the <strong class="source-inline">typed_joe.png</strong> file looks like:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Figure_8.1_B16820.jpg" alt="Figure 8.1 – The generated image from testing our user interface code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The generated image from testing our user interface code</p>
			<p>Such tests can be brittle since making a change to the design of the toolkit will cause them to fail. However, they can be helpful to highlight when a code change causes a graphical change that was unexpected. Therefore, when used appropriately in your test code, this approach can be a valuable addition to your validation pro<a id="_idTextAnchor215"/>cess.</p>
			<p>The tests <a id="_idIndexMarker536"/>we have explored in this section help verify that your application code is correct, and they should be run regularly. The best way to ensure this is to have a server run tests automatically. We will look at this next.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor216"/>Continuous integration for GUIs </h2>
			<p><strong class="bold">Continuous integration</strong> (<strong class="bold">CI</strong> – the regular way to merge a team's work-in-progress code so that <a id="_idIndexMarker537"/>it can be automatically tested) has become commonplace in software development teams. Adding this process to your team workflow is shown to highlight issues earlier in the development process, which leads to issues <a id="_idIndexMarker538"/>being fixed faster and, ultimately, better-quality software.</p>
			<p>A critical part of this is automating the tests that exercise the entire source code – including the GUI. It is highly recommended to include not only a regular compilation of your entire application code, but also a full run of the unit tests upon each commit. Doing so will help you quickly identify breakages or unexpected changes in behavior. Various CI tools are available for this purpose, though looking at them is outside the scope of this book. These are helpful when you're configuring your automated processes as they ensure that tests such as the ones explored in this section are part of your regular testing and acceptance checks.</p>
			<p>We have already seen that testing, and doing so regularly, is important, but how does this change if we want to have slightly different code for different platforms? At some point, most applications <a id="_idIndexMarker539"/>are likely to need system calls that vary based on the operating system. Next, we will look at how to do this while maintaining good code structure that is easy to understand.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor217"/>Managing platform-specific code</h1>
			<p>Back in <a href="B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">The Future According to Fyne</em>, we saw that the Go compiler has built-in support for the conditional inclusion of source files based on a system of environment <a id="_idIndexMarker540"/>variables and build tags. As an application adds more functionality, especially from a platform integration perspective, it is possible that the toolkit will not provide all of the functionality you are looking for. When this happens, the code will need to be updated to handle platform-specific functionality. To do so, we will use a variation of the conditional build – using well-named files instead of build tags. This is easier to read at the project level and should clearly indicate which files will be compiled for which platform.</p>
			<p>Let's create a simple example: we want to read text out loud, but our code only has the ability to do so on macOS (Darwin). We will set up a simple <strong class="source-inline">say()</strong> function that does what we want in the <strong class="source-inline">say_darwin.go</strong> file:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "log"</p>
			<p class="source-code">    "os/exec"</p>
			<p class="source-code">)</p>
			<p class="source-code">func say(text string) {</p>
			<p class="source-code">    cmd := exec.Command("say", text)</p>
			<p class="source-code">    err := cmd.Run()</p>
			<p class="source-code">    if err != nil {</p>
			<p class="source-code">        log.Println("Error saying text", err)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This simple function calls out to the built-in <em class="italic">say</em> tool, a command-line application bundled with macOS that allows text to be read out loud. Since this file ends with <strong class="source-inline">_darwin.go</strong>, it will only be compiled when we are building for macOS. To compile correctly when building on other platforms, we need to create another file that will be loaded instead. We will call this file <strong class="source-inline">say_other.go</strong>:</p>
			<p class="source-code">// +build !darwin</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "log"</p>
			<p class="source-code">    "runtime"</p>
			<p class="source-code">)</p>
			<p class="source-code">func say(_ string) {</p>
			<p class="source-code">    log.Println("Say support is not available for", </p>
			<p class="source-code">        runtime.GOOS)</p>
			<p class="source-code">}</p>
			<p>In this file, we must specify the build condition since there is no special filename format for all other platforms. Here, <strong class="source-inline">// +build !darwin</strong> means that the file will be included on any platform <a id="_idIndexMarker541"/>other than macOS. The method we'll be providing in this file simply logs that the feature is not supported. Finally, we must create a simple application launcher named <strong class="source-inline">main.go</strong> that will call the <strong class="source-inline">say()</strong> function:</p>
			<p class="source-code">package main</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    say("Hello world!")</p>
			<p class="source-code">}</p>
			<p>Running this code (using<strong class="source-inline"> go run .</strong>) will read <strong class="source-inline">Hello world!</strong> out loud when it's run on a macOS computer. On other operating systems, it will print an error stating that the feature is not available:</p>
			<p class="source-code">Chapter08/say&gt; go run .</p>
			<p class="source-code">2020/10/01 16:46:32 Say support is not available for linux</p>
			<p class="source-code">Chapter08/say&gt;</p>
			<p>We can handle platform-specific code in such a way that it's clear to anyone learning the project at hand and reading its code for the first time. Another developer could decide to add a <strong class="source-inline">say_windows.go</strong> file to add support for reading text on Windows. As long as they also update the build rules in <strong class="source-inline">say_other.go</strong>, the application will continue to work as expected <a id="_idIndexMarker542"/>but with the addition of Windows-based text reading. The benefit of this approach is that it does not require us to modify any of the existing code to simply add this new functionality.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor218"/>Summary</h1>
			<p>In this chapter, we explored some of the tips and techniques for managing a GUI-based application written with Go. By carefully planning the modules of an application and how they interact, we saw that we can make any application easier to test and maintain. Since higher test coverage is a factor when it comes to increasing the quality of software applications, we looked at how we can use these techniques to test our graphical code, which is a notoriously difficult topic. We stepped through an example of writing test code for a simple GUI application that could be run automatically. </p>
			<p>When it becomes necessary to adapt to a specific operating system, we need to learn how our code can adapt. With appropriate abstractions or by writing platform-specific code that is switched out by generic fallbacks, we can keep our applications easy to maintain, despite operating system differences.</p>
			<p>Throughout this book, we have been running examples from the command line, next to their source code. This means that we have been able to incorporate files that exist in the current directory – but this is not going to be possible as we start to distribute our applications.</p>
			<p>In the next chapter, we will look at how to include these extra assets (such as images and data files) in our application in preparation for their release.</p>
		</div>
	</body></html>