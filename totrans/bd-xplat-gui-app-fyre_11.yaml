- en: '*Chapter 8*: Project Structure and Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go language comes with a well-understood set of best practices such as style,
    documentation, and code structure. Often, when applications start adding **graphical
    user interface** (**GUI**) elements, these best practices can be lost. Testing
    individual components and keeping a clean separation of types helps us maintain
    clean code that is easier to maintain over time. These concepts can be followed
    within GUI code as well, with support from a toolkit such as Fyne.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore how these concepts apply to graphical application
    development and how we can learn from them to make our GUIs easier to manage over
    time. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing a well-structured project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using test-driven development and writing tests for the whole application GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing platform-specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*; that is, you must have the Fyne toolkit installed
    and a Go and C compiler working. For more information, please refer to that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Some parts of this chapter refer to managing platform-specific code, so it may
    be beneficial if you have two different operating systems available to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the design principles of the Go language is that you can start simple
    and build more structure into your project as it grows. Following this mantra,
    you can simply start a GUI project with a single `main.go` file inside a directory
    that's been created for the project. This will initially contain your entire application,
    starting from its `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Starting simple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once your user interface has grown from the very basics, it is a good idea to
    split it into a new file, perhaps named `ui.go`. Splitting the code in this way
    makes it clearer which code is simply booting an application (the `main()` function
    and helpers) compared to what is actually building the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'By this time, you should be thinking about adding unit tests (if you have not
    already added them!). These tests will live in a file, alongside your code, that
    ends in `_test.go` – for example, `ui_test.go`. It is good practice to test all
    of your code, and for each new function or type you add, there will be new tests
    to ensure the code is working correctly over time. It is normal for there to not
    be a test file for the main function since its purpose is simply to wire up the
    application''s components and launch it. A project that has passed the very basic
    stage might contain the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This structure works well until an application needs to add some custom types.
    We will explore this next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Fyne application user interface code focuses mainly on behavior, it is
    common to break up different areas of an application into separate areas, each
    defining its own type. Each type will define the data (or data access) that it
    represents, as well as the various methods that can operate on that information.
    These sections of the application code could be simple type definitions, where
    there will likely be a UI creation function, named `makeUI()` or something similar.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, they may be custom widgets, in which case the type extends `CanvasObject`,
    so it can be passed into the wider GUI structure. In either situation, these types
    deserve a new file, such as `mytype.go`, and their own tests, in `mytype_test.go`.
    For example, an application that is growing may have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a good structure for a simple application, but once the code base grows,
    especially if it contains libraries or supporting functionality that are not part
    of the GUI, you will likely want to consider using multiple packages. So, what
    happens then? Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting code into packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packages are useful when you want to separate some complex code that manages,
    for example, data access or complex calculations from the user interface code
    that will display it. In these situations, a separate package allows you to maintain
    the clean divide and test these elements independently (see the *Understanding
    the separation of concerns* section later in this chapter). If you would like
    this subpackage API to be publicly available, then you can just create a new folder
    for it (for example, `project/mylib`). Alternatively, you could choose to group
    many subpackages under a standard `pkg` directory (that is, `project/pkg/mylib`).
  prefs: []
  type: TYPE_NORMAL
- en: However, if you would like to keep its API as an internal detail for this project,
    you can use the special `internal` package as its parent (that is, `project/internal/pkg/mylib`).
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be helpful to keep your code tidy if the GUI code makes use of
    the internal structure as well, so that the top of the project contains fewer
    files. It is common to use `project/internal/app/` for this purpose. So, an application
    that contains the `storage` and `cache` internal libraries might begin to look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using this model, the library packages are all self-contained and the app package
    can depend on them to operate. The `main.go` file may depend on all of these packages
    to prepare the application and launch its GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding structure works well for a single application repository. The
    following command will install it directly (note that this should not include
    a scheme prefix such as `http://`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, in some situations, you will require more than one executable in a
    project. We'll look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple executables
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether the project is primarily a library or an application that
    contains multiple executables, there is a standard directory named `cmd` that
    can contain multiple subdirectories, one for each executable. Each package within
    `cmd` will contain the name of the application it should compile to, though the
    `Go` package will always be `main` so that it can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if your project was mainly a library but contained the `mylib_gui` and
    `mylib_config` executables, then you would have a structure like the following
    (omitting any internal code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this format, someone could depend on your library by using the following
    command (without `http://` being used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'They could also choose to install the GUI binary using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This flexibility allows repositories to have multiple purposes while maintaining
    a clean structure. Of course, there would probably be a lot of common code in
    `internal/pkg/` or `internal/app/` to allow this.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding illustrations are just examples – each application will have different
    requirements and may wish to diverge from these common layouts. To help developers
    understand an application, its `main()` function should be at the root of a project
    or in a `cmd/appname/` subdirectory. Similarly, a library's main API should be
    importable from the root of a project or the `pkg/libname/` subdirectory. Following
    these hints will make your app or library easier to pick up for new developers
    who are familiar with the recommended Go project layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how an application can be split into multiple pieces.
    It may not have been clear why this is important, though. In the next section,
    we'll look at the separation of concerns, which shows how this approach helps
    keep our code clean and maintainable for the future.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the separation of concerns
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier in this chapter, as well as when we discussed the Fyne
    toolkit API principles in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036),
    *The Future According to Fyne*, in the *Designing APIs for simplicity and maintainability*
    section, the concept of **separation of concerns** is important if we wish to
    maintain a clean code base. It enables us keep related code together without the
    fear of breaking other areas when we make a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept is closely related to the single responsibility principle, as
    introduced by Robert C. Martin in his *Principles of Object-Oriented Design* ([http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod))
    article. Here, he stated the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A class should have one, and only one, reason to change."'
  prefs: []
  type: TYPE_NORMAL
- en: –Robert C. Martin
  prefs: []
  type: TYPE_NORMAL
- en: In this respect, *concerns* have a wider scope than responsibilities in that
    they typically influence your application's design and architecture rather than
    individual classes or interfaces. Separation of concerns is essential in a graphical
    application if you wish to correctly detach your easily tested logic from the
    presentation code, which manages user interaction. By separating the concerns
    of an application, it is easier to test subcomponents and check the validity of
    our software without even needing to run the application. In doing so, we create
    more robust applications that can adapt to changes in requirements or technology
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Fyne widgets and APIs should not be incorporated into, or impact
    the design of, your business logic. Even a graphical API focused on behavior,
    such as the Fyne toolkit, should only be referenced by the presentation layer
    of your application (items in the project root or `internal/app` packages). It
    is for this reason that a robust application is split into multiple areas. Each
    of the supporting libraries will operate without any reference to the presentation
    layer or toolkit's capabilities. In this way, we keep the software open to change
    without it having a huge impact on unrelated areas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how the provided test utilities help ease the
    creation of unit tests. We can do this by keeping our code separated into smaller
    components. This is useful for validating the behavior of the presentation code
    of our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Test driving your development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The effort required to automatically test user interfaces or frontend software
    is often considered too expensive for the value it returns when it comes to avoiding
    future bugs. However, this is largely rooted in the toolkits being utilized or
    even the presentation technologies that have been chosen. Without full support
    for testing in the development tools or graphical APIs, it can be difficult to
    create simple unit tests without a huge amount of effort being needed.
  prefs: []
  type: TYPE_NORMAL
- en: One of the design principles of the Fyne toolkit is that the application GUI
    should be as easy to test as the rest of its code. This is partly made possible
    by the API's design, but this is further reinforced by the test utilities that
    we can provision. We will explore this later in this section. Using the following
    approaches, we will learn how a Fyne application can follow **test-driven development**
    (**TDD**), even for the user interface components.
  prefs: []
  type: TYPE_NORMAL
- en: Designed to be tested
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The modular design of the Fyne toolkit allows different drivers to be loaded
    for different systems or purposes. This approach primarily supports Fyne applications
    working on any operating system, without developers needing to modify their applications.
    An additional benefit of this approach is that an app can be loaded into a test
    runtime to execute various checks, without ever needing to display to the screen.
    This vastly improves the speed of test runs and also makes your tests more reliable
    (as user interaction cannot interfere with the test process).
  prefs: []
  type: TYPE_NORMAL
- en: By importing the `fyne.io/fyne/test` package, we automatically create an in-memory
    application that is capable of creating virtual windows that contain actual application
    GUIs. These windows support the same APIs as regular windows so that your code
    can run the same as it ran previously. Each graphical element can be programmatically
    interacted with and tested to confirm its behavior and state, and even to verify
    its rendering output.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two examples, we'll learn how to test the behavior of a user interface
    component and then how to verify that it rendered correctly, all without needing
    to display the GUI on a screen.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our GUI logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the functionality of an application, we must define a very simple GUI.
    It will have a `Hello World!` label, followed by an entry widget that we can use
    to specify our name. The final component – a simple button – will be triggered,
    updating the greeting based on the input. Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a simple `struct` called `greeter` that will hold references
    to these objects. For this example, we will write the following code to `ui.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are not creating a custom widget in this example, we will define a
    small method named `makeUI` that will construct the widgets that represent this
    application. In this case, this is a simple vertical box container that combines
    all the widgets that we created following the preceding description. We create
    each of the widgets, assign them to variables of the `greeter` type, and then
    return a vertical box that packs them together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To perform the update, when the button is tapped, we need an additional function,
    `setGreeting`, that will format a replacement string using `fmt.Sprintf`. It passes
    in the current content of the `name` entry widget to make the greeting personal.
    This looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we create a simple `main` function that will load the greeter, display
    it in a window, and run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify that the application works correctly by simply running it, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we''re focusing on the tests we must employ, so let''s write
    a unit test that validates the behavior we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the test file that will be provided along with this code; that
    is, `ui_test.go`. Here, we define a test with the standard signature. It must
    start with `Test` and accept a single parameter; that is, a `testing.T` pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we will create a new instance of our greeter and request that
    the interface components are created. Once this has been run, we assert that the
    initial state is correct. Here, we use the `assert` package from the testify project
    by `stretchr` (more information can be found at [https://github.com/stretchr/testify](https://github.com/stretchr/testify)).
    This will use the `github.com/stretchr/testify/assert` import path, which should
    be added to the top of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By adding the following code, you can set up the user interface so that it
    can be tested and perform its first assertions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step of writing this test is to execute the user steps and check
    the resulting changes. We''re using Fyne''s `test` package to simulate a user
    typing into the entry widget and then tapping the button to confirm this. After
    that, we confirm that the greeting text has been updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this test code, we can be sure that the user interface is working correctly.
    It can be simply executed like any other go test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With that, we know that the app works correctly. However, it can be helpful
    to verify that the output is being rendered as expected. Let's write a new test
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the output is being rendered
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most situations, an application can be tested for correctness through behavior
    testing, as we saw previously. However, it is sometimes useful to actually see
    what will be rendered to check the result. If your application contains custom
    drawing code or complex layouts, this may be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a new test, similar to the one we created in
    the preceding section, but in this case, we will test the rendered output using
    another `test` utility. Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method, as shown in the following code. Once you''ve set up the
    `greeter` type, pass `g.makeUI()` into `test.NewWindow()`. This will create an
    in-memory window that we can use to capture the output, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With a test window created, we can get its content using `w.Canvas().Capture()`.
    This function will return an image with the interface rendered as if it were running
    in a real window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can use the `AssertImageMatches` test utility, which requires that
    the test compares this image to the named file, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code will compare the default look. Now, we can simulate user actions
    again and compare the new state to another image file with an appropriate name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can run these tests just like the behavior tests before, though this time,
    the tests will fail because the images it is being compared to don't exist. You
    will find two new files inside the `testdata/failed/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should look at these files to see what is being drawn. If you agree that
    the output is correct, then these files can be moved to the `testdata/` directory.
    On a second run of these tests, you will see that they all pass as expected. The
    following screenshot shows what the `typed_joe.png` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The generated image from testing our user interface code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – The generated image from testing our user interface code
  prefs: []
  type: TYPE_NORMAL
- en: Such tests can be brittle since making a change to the design of the toolkit
    will cause them to fail. However, they can be helpful to highlight when a code
    change causes a graphical change that was unexpected. Therefore, when used appropriately
    in your test code, this approach can be a valuable addition to your validation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The tests we have explored in this section help verify that your application
    code is correct, and they should be run regularly. The best way to ensure this
    is to have a server run tests automatically. We will look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration for GUIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI** – the regular way to merge a team''s work-in-progress
    code so that it can be automatically tested) has become commonplace in software
    development teams. Adding this process to your team workflow is shown to highlight
    issues earlier in the development process, which leads to issues being fixed faster
    and, ultimately, better-quality software.'
  prefs: []
  type: TYPE_NORMAL
- en: A critical part of this is automating the tests that exercise the entire source
    code – including the GUI. It is highly recommended to include not only a regular
    compilation of your entire application code, but also a full run of the unit tests
    upon each commit. Doing so will help you quickly identify breakages or unexpected
    changes in behavior. Various CI tools are available for this purpose, though looking
    at them is outside the scope of this book. These are helpful when you're configuring
    your automated processes as they ensure that tests such as the ones explored in
    this section are part of your regular testing and acceptance checks.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen that testing, and doing so regularly, is important, but
    how does this change if we want to have slightly different code for different
    platforms? At some point, most applications are likely to need system calls that
    vary based on the operating system. Next, we will look at how to do this while
    maintaining good code structure that is easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Managing platform-specific code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036), *The
    Future According to Fyne*, we saw that the Go compiler has built-in support for
    the conditional inclusion of source files based on a system of environment variables
    and build tags. As an application adds more functionality, especially from a platform
    integration perspective, it is possible that the toolkit will not provide all
    of the functionality you are looking for. When this happens, the code will need
    to be updated to handle platform-specific functionality. To do so, we will use
    a variation of the conditional build – using well-named files instead of build
    tags. This is easier to read at the project level and should clearly indicate
    which files will be compiled for which platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple example: we want to read text out loud, but our code
    only has the ability to do so on macOS (Darwin). We will set up a simple `say()`
    function that does what we want in the `say_darwin.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple function calls out to the built-in *say* tool, a command-line application
    bundled with macOS that allows text to be read out loud. Since this file ends
    with `_darwin.go`, it will only be compiled when we are building for macOS. To
    compile correctly when building on other platforms, we need to create another
    file that will be loaded instead. We will call this file `say_other.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, we must specify the build condition since there is no special
    filename format for all other platforms. Here, `// +build !darwin` means that
    the file will be included on any platform other than macOS. The method we''ll
    be providing in this file simply logs that the feature is not supported. Finally,
    we must create a simple application launcher named `main.go` that will call the
    `say()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code (using `go run .`) will read `Hello world!` out loud when
    it''s run on a macOS computer. On other operating systems, it will print an error
    stating that the feature is not available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can handle platform-specific code in such a way that it's clear to anyone
    learning the project at hand and reading its code for the first time. Another
    developer could decide to add a `say_windows.go` file to add support for reading
    text on Windows. As long as they also update the build rules in `say_other.go`,
    the application will continue to work as expected but with the addition of Windows-based
    text reading. The benefit of this approach is that it does not require us to modify
    any of the existing code to simply add this new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored some of the tips and techniques for managing a
    GUI-based application written with Go. By carefully planning the modules of an
    application and how they interact, we saw that we can make any application easier
    to test and maintain. Since higher test coverage is a factor when it comes to
    increasing the quality of software applications, we looked at how we can use these
    techniques to test our graphical code, which is a notoriously difficult topic.
    We stepped through an example of writing test code for a simple GUI application
    that could be run automatically.
  prefs: []
  type: TYPE_NORMAL
- en: When it becomes necessary to adapt to a specific operating system, we need to
    learn how our code can adapt. With appropriate abstractions or by writing platform-specific
    code that is switched out by generic fallbacks, we can keep our applications easy
    to maintain, despite operating system differences.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have been running examples from the command line, next
    to their source code. This means that we have been able to incorporate files that
    exist in the current directory – but this is not going to be possible as we start
    to distribute our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to include these extra assets (such
    as images and data files) in our application in preparation for their release.
  prefs: []
  type: TYPE_NORMAL
