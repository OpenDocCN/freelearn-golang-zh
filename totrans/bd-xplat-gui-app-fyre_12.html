<html><head></head><body>
		<div id="_idContainer115">
			<h1 id="_idParaDest-217"><em class="italic"><a id="_idTextAnchor219"/>Chapter 9</em>: Bundling Resources and Preparing for Release</h1>
			<p>Go applications are known for building simple application binary files that make them easy to install. However, the additional data required for graphical applications can make this challenging and has resulted in complex package formats and the introduction of installers as well. Fyne provides an alternative solution that allows apps to once again be distributed as a single file on most platforms.</p>
			<p>Completing the packaging of an application requires metadata and an additional build step to prepare the files for distribution. This step allows applications to be installed to the local system or development devices alongside system-native apps, which we will study in this chapter.</p>
			<p>We will walk through adding the various files an app will need at runtime. We will cover the following topics:</p>
			<ul>
				<li>How to include additional files in your application</li>
				<li>Checking for common <strong class="bold">User Experience</strong> (<strong class="bold">UX</strong>) mistakes to improve your GUI</li>
				<li>Packaging applications ready for distribution</li>
				<li>Installing on your computer or development mobile devices</li>
			</ul>
			<p>At the end of this chapter, you will install your applications on your computer and smartphone for real-world testing.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor220"/>Technical requirements</h1>
			<p>This chapter has the same requirements as <a href="B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>,<em class="italic"> Windows, Canvas, and Drawing</em>: to have the Fyne toolkit installed and Go and C compilers working. For more information, please refer to that chapter.</p>
			<p>For deployment to Android devices, you will need to install the Android SDK and NDK (refer to <a href="B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256"><em class="italic">Appendix B</em></a>, <em class="italic">Installation of Mobile Build Tools</em>). To build for iOS devices, you will also need to install Xcode on your Macintosh computer (a Mac is required for licensing reasons).</p>
			<p>The full source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09">https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09</a>.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor221"/>Bundling assets</h1>
			<p>Go applications<a id="_idIndexMarker543"/> are designed to run from a single binary file. This means they can easily be distributed and do not rely on installation scripts. Unfortunately, this benefit results in a cost for developers—we cannot rely on resources being found along with our applications in the way that web or mobile app developers can (and as we have been doing during development). To ensure that our applications conform to this design, we must embed any required assets into the application binary. This includes fonts, images, and any other static content that is needed for the application to operate correctly. </p>
			<p>The Fyne toolkit provides a tool for the bundling of assets that is recommended for any apps built using Fyne. The benefit of using this tool is that it generates <strong class="source-inline">fyne.Resource</strong> definitions for each embedded resource, which makes it easy to pass embedded assets into various Fyne APIs. This bundle tool is actually a command within the project's <strong class="source-inline">fyne</strong> command-line tool that is used in various examples within this book. The command is installed with a single <strong class="source-inline">go get</strong> command as follows:</p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ go get fyne.io/fyne/cmd/fyne</strong></p>
			<p>The <strong class="source-inline">bundle</strong> command simply converts assets from the filesystem in to the Go source code, which can then be compiled into applications. This means that the compiled application will include the assets and therefore not rely on them being present on the filesystem when the app runs. The <strong class="source-inline">bundle</strong> command is a part of the <strong class="source-inline">fyne</strong> executable, and takes the file to embed as its main parameter. It prints the result to the system output, so we use console redirection (<strong class="source-inline">&gt;</strong>) to send the generated Go source code to a suitable file, as shown in the following code snippet:</p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ ls</strong></p>
			<p class="source-code"><strong class="bold">data</strong></p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ fyne bundle data/demo.svg &gt; bundled.go</strong></p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ ls</strong></p>
			<p class="source-code"><strong class="bold">bundled.go    data</strong></p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$</strong></p>
			<p>Once the file is generated, we can reference it using the created symbol (of type <strong class="source-inline">*fyne.StaticResource</strong>, which implements <strong class="source-inline">fyne.Resource</strong>). This can be used like any other resource, so we can load it as an image in the following way: </p>
			<p class="source-code">image := canvas.NewImageFromResource(resourceDemoSvg) </p>
			<p>The generated variable name may not be ideal for your usage, but it can be changed using an additional command parameter. For example, if you wanted to export this new symbol, you<a id="_idIndexMarker544"/> could specify a simpler name that starts with an uppercase letter by adding the <strong class="source-inline">-name Demo parameter</strong>, as follows:</p>
			<p class="source-code">Chapter09/bundle$ fyne bundle -name Demo data/demo.svg &gt; bundled.go</p>
			<p>The preceding command manages the inclusion of a single asset, but most apps will need to have many. Let's see how to add many resources.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor222"/>Including multiple assets</h2>
			<p>In the previous example, we <a id="_idIndexMarker545"/>bundled a single file that included all the headers needed to make the bundle file a complete Go source file. To bundle multiple files in this way, we would need a new bundle file for each asset. This is probably not ideal and so the bundle tool includes a <strong class="source-inline">-append</strong> parameter that can be used to add more assets to the same bundle file.</p>
			<p>To bundle a second file we use this new parameter and change the console redirection symbol to the append version (<strong class="source-inline">&gt;&gt;</strong>). For example, we can add <strong class="source-inline">demo2.svg</strong> to the same bundle output:</p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ fyne bundle data/demo.svg &gt; bundled.go</strong></p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ fyne bundle -append data/demo2.svg &gt;&gt; bundled.go</strong></p>
			<p>The resulting <strong class="source-inline">bundle.go</strong> file will contain two definitions, <strong class="source-inline">resourceDemoSvg</strong> and <strong class="source-inline">resourceDemo2Svg</strong>.</p>
			<p>In this manner, you can embed many resources, but it requires an additional command for each resource, which can be time-consuming and prone to human error. Instead, we can bundle all of the assets from a directory with a single command. To do so, we just use a directory path instead of the filename, using the same syntax as the first bundle we executed. The result of the following directory bundle will create the same output as running the two file commands shown previously:</p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ fyne bundle data &gt; bundled.go</strong></p>
			<p>As you can see, it can be quite powerful to embed lots of data with a single command. The resulting file (<strong class="source-inline">bundle.go</strong>) should be added to your version control so other developers do not have to run this command. </p>
			<p>To support this, an <a id="_idIndexMarker546"/>easy configuration works best when the assets are in a separate directory. Therefore, in addition to the file structure discussed in <a href="B16820_08_Final_JM_ePub.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Project Structure and Best Practices</em>, it is common to add <strong class="source-inline">data</strong> directories alongside code that will utilize the embedded assets.</p>
			<p>When the assets are updated, however, a developer may not remember the command to use, and so we will look briefly at how this can be automated.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor223"/>Automating bundle commands</h2>
			<p>The Go <a id="_idIndexMarker547"/>compiler has a helpful <strong class="source-inline">generate</strong> subcommand that can be used to process resources such as the assets we have been bundling in this section. To make use of this tool, we add a <strong class="source-inline">//go:generate</strong> header to one of our source files (not the generated file, as this will be overwritten).</p>
			<p>For this simple example, we add a new file named <strong class="source-inline">main.go</strong> that exists simply to include this header (normally there would already be a file available). Into this, we add a header line that tells Go how to generate our resources, before the package name:</p>
			<p class="source-code">//go:generate fyne bundle -o bundled.go data</p>
			<p class="source-code">package main</p>
			<p>You can see here a change to how we were calling the command before—the inclusion of a <strong class="source-inline">-o</strong> parameter followed by the name we want to output to. This is introduced because within a <strong class="source-inline">generate</strong> command, we cannot use the command-line redirection tools that were in use previously. The parameter simply has the same effect – it specifies which file the output should be sent to. And so when we run <strong class="source-inline">go generate</strong> we see the same result as if we'd bundled the data directory manually. This is as shown here:</p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ ls</strong></p>
			<p class="source-code"><strong class="bold">data    main.go</strong></p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ go generate</strong></p>
			<p class="source-code"><strong class="bold">Chapter09/bundle$ ls</strong></p>
			<p class="source-code"><strong class="bold">bundled.go data    main.go</strong></p>
			<p>Using the preceding <a id="_idIndexMarker548"/>tools, we have prepared our application work without the asset files present, which makes it easier to distribute. Before we start packaging we should also check whether the Fyne toolkit has other tips for our app.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor224"/>Checking for UI hints</h1>
			<p>As Fyne is<a id="_idIndexMarker549"/> built using <strong class="bold">Material Design</strong> principles, it is possible to make use of their recommendations for good <a id="_idIndexMarker550"/>and bad ways to use certain components and how you should and shouldn't combine elements for a great UX.</p>
			<p>Built into the Fyne toolkit is the<a id="_idIndexMarker551"/> concept of <strong class="bold">hints</strong>. These are suggestions that widgets and other components can make about how an app could make changes to offer an improved user interface.</p>
			<p>We will start exploring what these hints can offer by creating a simple example tab container application. This code snippet will load two tabs into a tab container (the <strong class="source-inline">makeTabs()</strong> function). We then include a <strong class="source-inline">main()</strong> function that will load a new app, create a window, and set the tabs to be its content. The function then runs our app in the usual way as follows:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fyne.io/fyne/app"</p>
			<p class="source-code">    "fyne.io/fyne/container"</p>
			<p class="source-code">    "fyne.io/fyne/theme"</p>
			<p class="source-code">    "fyne.io/fyne/widget"</p>
			<p class="source-code">)</p>
			<p class="source-code">func makeTabs() *container.AppTabs {</p>
			<p class="source-code">    return container.NewAppTabs(</p>
			<p class="source-code">        container.NewTabItemWithIcon("Home",theme.HomeIcon(),</p>
			<p class="source-code">            widget.NewLabel("Tab 1")),</p>
			<p class="source-code">        container.NewTabItem("JustText",</p>
			<p class="source-code">            widget.NewLabel("Tab 2")),</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    a := app.New()</p>
			<p class="source-code">    w := a.NewWindow("Tabs hints")</p>
			<p class="source-code">    w.SetContent(makeTabs())</p>
			<p class="source-code">    w.ShowAndRun()</p>
			<p class="source-code">}</p>
			<p>With this code written, we <a id="_idIndexMarker552"/>can run it as normal. However, this time we will pass the additional <strong class="source-inline">-tags hints</strong> parameter to turn on the suggestions:</p>
			<p class="source-code"><strong class="bold">Chapter09/hints$ go run -tags hints .</strong></p>
			<p>When running, you will see the app as illustrated in <em class="italic">Figure 9.1</em>:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/Figure_9.1_B16820.jpg" alt="Figure 9.1 – The Tabs app looks like it’s working correctly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The Tabs app looks like it's working correctly</p>
			<p>There really are no surprises in how the app looks, but if you check the output of the application that's printed to the command line you will notice lots of output that we have not seen before. You will probably see something like the following (it may vary based on the version of Fyne being used):</p>
			<p class="source-code"><strong class="bold">Chapter09/hints$ go run -tags hints .</strong></p>
			<p class="source-code"><strong class="bold">2020/10/07 14:06:08 Fyne hint:  Applications should be</strong></p>
			<p class="source-code"><strong class="bold"> created with a unique ID using app.NewWithID()</strong></p>
			<p class="source-code"><strong class="bold">2020/10/07 14:06:08   Created at:</strong></p>
			<p class="source-code"><strong class="bold"> .../Chapter09/hints/main.go:18</strong></p>
			<p class="source-code"><strong class="bold">2020/10/07 14:06:08 Fyne hint:  TabContainer items should all</strong></p>
			<p class="source-code"><strong class="bold"> have the same type of content (text, icons or both)</strong></p>
			<p class="source-code"><strong class="bold">2020/10/07 14:06:08   Created at:</strong></p>
			<p class="source-code"><strong class="bold"> .../Chapter09/hints/main.go:11</strong></p>
			<p>As you can see in the preceding output, there are two lines marked <strong class="source-inline">Fyne hint</strong>. These are each the start of a new suggestion. The line after each instance is useful to show where in our code the hint refers to (the paths were partly removed for clarity). The preceding hints tell us the following:</p>
			<ul>
				<li>Our application is <a id="_idIndexMarker553"/>missing the unique ID that is required for some functionality to work – you will have learned about <strong class="source-inline">appID</strong> already if you read <a href="B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166"><em class="italic">Chapter 6</em></a>,<em class="italic"> Data Binding and Storage</em>. We will discuss this further in the <em class="italic">Metadata, icons, and app IDs</em> section later in this chapter.</li>
				<li>The tab container that we created has a mix of tab styles; one has an icon and the other does not. We could resolve this by adding an icon to the <strong class="source-inline">JustText</strong> tab, or by removing the <strong class="source-inline">Home</strong> tab icon.</li>
			</ul>
			<p>As you can see from this, it can be helpful to check the hints for your application. The small changes suggested by doing so can lead to an improved UX, or resolve future issues that have not yet been encountered.</p>
			<p>As our app is now ready to be packaged, we need to think about how it will be presented in terms of its app name, icon, and other metadata.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor225"/>Choosing metadata, icons, and app IDs</h1>
			<p>Before we start on the technical aspects of creating an application release, there are a few <a id="_idIndexMarker554"/>prerequisites to consider. The application name is probably set by now, but<a id="_idIndexMarker555"/> do you have a great description for it? Do you know how to articulate <a id="_idIndexMarker556"/>the key features of your software in a way that will grab the attention of potential users? Have you (or your design team) created a great app icon that will be memorable and somehow indicative of its functionality? </p>
			<p>If you won't distribute your app through a managed channel, such as an app store or platform package manager, you should consider how the application will be discovered by your target audience. There is a lot of discussion and information online about <strong class="bold">Search Engine Optimization</strong> (<strong class="bold">SEO</strong>) and a <a id="_idIndexMarker557"/>growing amount about <strong class="bold">App Store Optimization</strong> (<strong class="bold">ASO</strong>) to be found, so we will not go into detail here. What is<a id="_idIndexMarker558"/> clear in the current software climate is that the ease of discovery and memorability of your app are now more important than ever before. The three most important aspects are the icon and description of the app, and the unique identifier that it will use in each store. We'll start by exploring the details of an app icon.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor226"/>Application icons</h2>
			<p>Picking your icon<a id="_idIndexMarker559"/> is probably the single most important part of preparing an application for release. It needs to be memorable and also evoke some idea of what the software is for. A great icon should look good when displayed either large or small, and in general, tiny details should be avoided, or only used for unimportant aspects of the design. Make sure that your icon is created at a high resolution; using a vector format is advisable (for example, <strong class="bold">SVG</strong>), but if you are working with a bitmap format (such as <strong class="bold">PNG</strong>) then 1024 x 1024 pixels is the minimum requirement for an icon to look great on the widest variety of devices. It's also important to consider the use of transparency—depending on the platforms you wish to distribute to, this may or may not be recommended. Most desktop systems allow the use of shaped icons, but not all will allow semi-transparent areas and iOS does not allow transparency at all, whereas Android encourages it.</p>
			<p>Take some time to look at popular or commonplace icons on each of the operating systems or desktop environments where you expect your application to be used. Can you match your icon style to each of them successfully? Does it seem like a particular shape or style will be expected by users of these systems? It may be best, or necessary, to create different versions of the graphic for different platforms. Doing so is not a problem, and can be accommodated by passing different icons to the build commands that we will study later in this chapter. </p>
			<p>The packaging commands later in this chapter allow an icon to be specified; however, if you would like to set a default icon for your app, simply call it <strong class="source-inline">Icon.png</strong> or <strong class="source-inline">Icon.svg</strong>.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor227"/>Describing your app </h2>
			<p>At this stage <a id="_idIndexMarker560"/>of development, you may have started to engage your audience and understand what they like about the software and who the target users will be. If not, then don't fear – just note that this is the time to think about how your description and supporting materials could best attract new users. Whether it's through a web search engine or an application marketplace, the text you use is critical for convincing anyone to install your application. As well as the name of the application and its main functionality, make sure you consider how it could benefit your users. What tasks do you expect they will be trying to complete when searching for the solution you have built? Don't worry about making this text long, but do try to include these important points.</p>
			<p>How exactly you will ship your application is discussed further in <a href="B16820_10_Final_JM_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a>, <em class="italic">Distribution – App Stores and Beyond</em>, but whether you intend to ship your application via an online store or a simple website, it's advisable to make sure you have completed your metadata before you continue to the release process. The information we have prepared here will be embedded in the packages we create and it's important that it retains consistency with the distribution metadata that will be used later in this chapter and beyond. User trust can be quickly lost and having an app icon that does not match the preview, for example, can cause concern. Remember that the description should match the name and the icon so that users will quickly recognize it once installed.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor228"/>Application identifier (appID)</h2>
			<p>As we saw in the <em class="italic">Checking for UI hints</em> section, a unique identifier will be needed at some point for every Fyne app. If you have already used the preferences or storage APIs then this may already <a id="_idIndexMarker561"/>be set; however, if you have not then you need to pick the app ID at this stage as it is required to proceed to packaging your app on many operating systems.</p>
			<p>An app identifier is used to uniquely recognize this software; as well as being globally unique, it must never change. Accidentally changing this would likely result in users losing their data and may also mean that updates are not sent to existing users of your software, so pick one now and be careful that it is kept consistent.</p>
			<p>The normal scheme for choosing your unique ID is to use the reverse-DNS notation. This format will be familiar to developers who have worked with Java or Android packages, or Apple's <strong class="bold">Uniform Type Identifier</strong> (<strong class="bold">UTI</strong>). The<a id="_idIndexMarker562"/> format is based on the assumption that each developer, company, or product has a website or home page address that can be used as a namespace for their work. When such a grouping is applied then additional information can be used to identify the software component internally, making it a globally unique identifier. The <em class="italic">reverse</em> component of reverse-DNS is useful for sorting and searching, which is why it gained popularity in the management of software components.</p>
			<p>The generic format is as follows:</p>
			<p class="source-code">&lt;extension&gt;.&lt;domain name&gt;.&lt;optional categories&gt;.&lt;app name&gt;</p>
			<p>And so, following this format, an example company with domain name <strong class="source-inline">myco.com</strong> that is releasing a product named <strong class="source-inline">tasks</strong> in their category of <strong class="source-inline">productivity</strong> software might use the following app ID:</p>
			<p class="source-code">com.myco.productivity.tasks</p>
			<p>The content of this string <a id="_idIndexMarker563"/>after the initial, reversed domain name can be whatever you choose; adding categories or another identifier is commonplace. It is not advisable, however, to add a version number as this string must remain identical for the life of your software to avoid some of the potential issues described previously.</p>
			<p>If you do not have a website for your application, you could choose to use the location that it is stored in instead. It does not matter if you move the location in the future, as this is just an identifier – be sure to keep it the same if you do move the repository location. For example, a tutorial app stored on GitHub for user <strong class="source-inline">dummyUser</strong> might take the following app ID – notice that there is a third element to the domain name to remain globally unique:</p>
			<p class="source-code">com.github.dummyUser.tutorial</p>
			<p>Now that we have our metadata in order, we can start packaging our application and then install it on our test devices.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor229"/>Packaging applications (desktop and mobile)</h1>
			<p>To incorporate the <a id="_idIndexMarker564"/>metadata prepared in the preceding sections, we need to execute the <em class="italic">packaging</em> phase. This will take the standard Go application binary and attach or embed the required data based on the operating specifics. As each platform requires different data formats and produces different resulting file structures, we use the <strong class="source-inline">fyne</strong> tool once again to take care of the details.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor230"/>Packaging for your current computer</h2>
			<p>To create a <a id="_idIndexMarker565"/>package from a Fyne project, we use the <strong class="source-inline">fyne package</strong> command. By default, this will create an application bundle or executable for the current operating system. When run on macOS this will create a <strong class="source-inline">.app</strong> bundle; on Windows it will be a <strong class="source-inline">.exe</strong> file (with additional metadata); on Linux it creates a <strong class="source-inline">.tar.gz</strong> file that can be used to install the app. </p>
			<p>It is possible to build this for a different system as well, using the <strong class="source-inline">-os</strong> parameter, which we will explore later in this chapter.</p>
			<p>Before packaging, it is a good idea to confirm that your application builds successfully using the <strong class="source-inline">go build</strong> command. When your app is ready, simply execute the <strong class="source-inline">fyne package</strong> command and it will process your app and metadata to create the platform-appropriate output. For example, on a macOS computer you would see the following:</p>
			<p class="source-code">Chapter09/package$ ls</p>
			<p class="source-code">Icon.png main.go</p>
			<p class="source-code">Chapter09/package$ go build .</p>
			<p class="source-code">Chapter09/package$ ls</p>
			<p class="source-code">Icon.png main.go  package</p>
			<p class="source-code">Chapter09/package$ fyne package</p>
			<p class="source-code">Chapter09/package$ ls</p>
			<p class="source-code">Icon.png    main.go     package     package.app</p>
			<p>You can see that the <strong class="source-inline">go build</strong> command created a regular binary file, and that <strong class="source-inline">fyne package</strong> created an app bundle. When opened in macOS Finder, you can see how the icon has been applied to the output application bundle:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_9.2_B16820.jpg" alt="Figure 9.2 – The file icons from a macOS build&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – The file icons from a macOS build</p>
			<p>If you run the same commands on a Linux computer you would see the following:</p>
			<p class="source-code">Chapter09/package$ ls</p>
			<p class="source-code">Icon.png main.go</p>
			<p class="source-code">Chapter09/package$ go build .</p>
			<p class="source-code">Chapter09/package$ ls</p>
			<p class="source-code">Icon.png main.go  package</p>
			<p class="source-code">Chapter09/package$ fyne package</p>
			<p class="source-code">Chapter09/package$ ls</p>
			<p class="source-code">Icon.png    main.go     package     package.tar.gz</p>
			<p>To read about <a id="_idIndexMarker566"/>installing the applications we have just built, you can skip to the <em class="italic">Installing your application</em> section. However, if you would like to prepare a build for mobile devices, read on, as we will do that next.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor231"/>Packaging for a mobile device</h2>
			<p>As mobile apps <a id="_idIndexMarker567"/>cannot be created on the device, they have to be packaged from a desktop computer and then installed on the mobile device. We use the same tools as we used in the previous sections, with the additional <strong class="source-inline">-os</strong> parameter specifying <strong class="source-inline">ios</strong> or <strong class="source-inline">android</strong> as the target system.</p>
			<p>As mobile apps require an app ID to build, we must also pass the <strong class="source-inline">appID</strong> parameter along with the unique identifier discussed in the <em class="italic">Application identifier (appID)</em> section earlier in this chapter. </p>
			<p>Before packaging for iOS or Android devices you will need to install Xcode or the Android Developer Tools (discussed in more detail in <a href="B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256"><em class="italic">Appendix B</em></a><em class="italic">, Installation of Mobile Build Tools</em>).</p>
			<p>With Xcode installed on a macOS computer (due to Apple's licensing restrictions), you can build an iOS app using the following command:</p>
			<p class="source-code">$ fyne package -os ios -appID com.example.myapp .</p>
			<p>To build an Android app package (<strong class="source-inline">.apk</strong>) use the following command:</p>
			<p class="source-code">$ fyne package -os android -appID com.example.myapp .</p>
			<p>Now that you have your application bundle or binary file ready to be installed, we will see how to simply install your app on your desktop and mobile devices.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor232"/>Installing your application</h1>
			<p>If you just want to install<a id="_idIndexMarker568"/> the desktop app on your computer or development devices then you can make use of the helpful <strong class="source-inline">install</strong> subcommand. There are two modes for the <strong class="source-inline">install</strong> tool, firstly to install on the current computer, and secondly to install on a mobile device that is set up for development.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor233"/>Installing on your current computer</h2>
			<p>To install your application<a id="_idIndexMarker569"/> onto your current computer and make it available system-wide, you could simply execute the following:</p>
			<p class="source-code">$ fyne install -icon myapp.png</p>
			<p>The icon file is the minimum required metadata for installing an app to the desktop. If you would like to avoid passing the <strong class="source-inline">-icon</strong> parameter each time, you can simply rename the file to <strong class="source-inline">Icon.png</strong> and it will be used by default. Once the application is installed, you will see it in your computer's program list with appropriate icons showing.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor234"/>Installing on a mobile device</h2>
			<p>At this stage, we<a id="_idIndexMarker570"/> can install apps to a mobile device if it is set up for development. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Development provisioning can be complicated and is out of the scope of this book. </p>
			<p class="callout">You can read more for iOS devices<a id="_idIndexMarker571"/> at <a href="https://help.apple.com/xcode/mac/current/#/dev5a825a1ca">https://help.apple.com/xcode/mac/current/#/dev5a825a1ca</a>. </p>
			<p class="callout">For Android devices, you<a id="_idIndexMarker572"/> can read the documentation at <a href="https://developer.android.com/studio/debug/dev-options">https://developer.android.com/studio/debug/dev-options</a>.</p>
			<p>With a development-enabled mobile device, apps can be installed using the same install command by passing a <strong class="source-inline">-os</strong> parameter as either <strong class="source-inline">android</strong> or <strong class="source-inline">ios</strong>. For example, to install a generated <strong class="source-inline">.apk</strong> file on your Android device, use the following command:</p>
			<p class="source-code">$ fyne install -os android -appID com.example.myid -icon myapp.png</p>
			<p>As you can see, for the <a id="_idIndexMarker573"/>mobile app installation, we needed the additional <strong class="source-inline">appID</strong> metadata value. This value is passed into the <strong class="source-inline">package</strong> command that we explored in the preceding section. If the package is up to date, this value may not be required, but it's usually a good idea to pass it just in case.</p>
			<p>And so, you can see that it's simple to install applications on the current computer or connected mobile devices. To make this possible, the Fyne tool was actually cross-compiling (that means compiling for a different type of computer). Let's now look into how that works in more detail.</p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor235"/>Cross-compiling with ease</h1>
			<p>The ability to compile for different operating systems or architectures than the current computer is called <strong class="bold">cross-compiling</strong>. We saw it used in the previous section to package and install a mobile<a id="_idIndexMarker574"/> app from a desktop computer. By cross-compiling, we can also build applications from one computer for other types of desktop as well, for example using Windows to build a macOS application.</p>
			<p>There are two ways that this can be done. Firstly, we will see how developers familiar with platform-specific compilation can use their normal tools to build for multiple platforms. After that, we will look at the <strong class="source-inline">fyne-cross</strong> tool and how it hides all of the complexity using a Docker image to manage compiling.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor236"/>Using installed toolchains</h2>
			<p>When taking the <a id="_idIndexMarker575"/>traditional approach to cross-compiling, the<a id="_idIndexMarker576"/> computer will require an additional compiler <strong class="bold">toolchain</strong> for each platform and architecture that the developer wants to support. This is what provides the ability to compile the graphics and system integration code and typically comprises a C compiler and linker. The manner of installation for each toolchain varies depending on the current operating system as well as the target toolchain. Details for the various installations are available in <em class="italic">, Cross-Compiling</em>.</p>
			<p>With a toolchain installed, the build process is like regular Go cross-compiling where you specify <strong class="source-inline">GOOS</strong> and <strong class="source-inline">GOARCH</strong> environment variables to specify the target operating system and architecture. However, we additionally must specify <strong class="source-inline">CGO_ENABLED=1</strong> (so that C integration is enabled) and also a <strong class="source-inline">CC</strong> environment variable that specifies which toolchain compiler to use.</p>
			<p>A quick <a id="_idIndexMarker577"/>summary of the most commonly used <a id="_idIndexMarker578"/>compilers and the <strong class="source-inline">CC</strong> environment variable to use is as follows (for more information please see <em class="italic">, Cross-Compiling</em>):</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Table_01.jpg" alt="Table 9.1 – Downloads, notes, and CC environments for various desktop platforms&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.1 – Downloads, notes, and CC environments for various desktop platforms</p>
			<p>With the appropriate compilers and libraries installed, we can continue to the build phase. For each of the target operating systems, you will need to run through these steps with the correct environment variables set. It is recommended to build for one platform and then complete the packaging step for each before changing to the next configuration. This is because the release binary for one platform may overwrite another (for example, macOS and Linux binaries have the same name when compiled).</p>
			<p>To see how this works, we'll launch a terminal on a macOS computer and will compile and package applications for the current macOS system, followed by Windows and Linux. You can use any project; the following example uses the package example from earlier in this chapter. Let's see how this goes:</p>
			<ol>
				<li>First of all, we <a id="_idIndexMarker579"/>check that the application is <a id="_idIndexMarker580"/>building correctly for the current system. For our macOS host computer, this will create a <strong class="source-inline">package.app</strong> file, as the application we are building is called <strong class="source-inline">package</strong>:<p class="source-code"><strong class="bold">$ ls</strong></p><p class="source-code"><strong class="bold">Icon.png main.go</strong></p><p class="source-code"><strong class="bold">$ fyne package</strong></p><p class="source-code"><strong class="bold">$ ls</strong></p><p class="source-code"><strong class="bold">Icon.png    main.go     package     package.app</strong></p><p>Before moving on, we should remove any temporary files, and as we are just testing we can remove the packaged app we created as well:</p><p class="source-code"><strong class="bold">$ rm -r package.app package</strong></p></li>
				<li>Next, we will build for Microsoft Windows. As described in the preceding table, this will require the installation of the <strong class="source-inline">mingw-w64</strong> package using Homebrew or another package manager. With this installed, we can set the environment variables, including <strong class="source-inline">CC</strong> to specify the compiler. The command will look like the following:<p class="source-code"><strong class="bold">$ GOOS=windows CC=x86_64-w64-mingw64-gcc CGO_ENABLED=1 fyne package</strong></p><p class="source-code"><strong class="bold">$ ls</strong></p><p class="source-code"><strong class="bold">Icon.png    fyne.syso   main.go     package.exe</strong></p><p>As you can see, this successfully built the <strong class="source-inline">package.exe</strong> file as well as a <strong class="source-inline">.syso</strong> temporary file (this is what Windows builds use to bundle metadata – it can normally be ignored). </p><p>Before packaging for Linux, we will remove these files:</p><p class="source-code"><strong class="bold">$ rm package.exe fyne.syso</strong></p></li>
				<li>Preparing a Linux build from macOS requires more work. First, you will need to install the compiler toolchain, which is the <strong class="source-inline">FiloSottile/musl-cross/musl-cross</strong> package in Homebrew. After this, you will need to locate and install suitable X11 and OpenGL packages for Linux development (the details here will vary based on the Linux computer you are building for; detailed information can be <a id="_idIndexMarker581"/>found in <em class="italic">, Cross-Compiling</em>). Once this is all installed, you can execute the Linux build much like the Windows command previously, but using<a id="_idIndexMarker582"/> the appropriate <strong class="source-inline">CC</strong> variable:<p class="source-code"><strong class="bold">$ GOOS=linux CC=x86_64-linux-musl-gcc CGO_ENABLED=1 fyne package</strong></p><p class="source-code"><strong class="bold">$ ls</strong></p><p class="source-code"><strong class="bold">Icon.png    main.go     package     package.tar.gz</strong></p></li>
			</ol>
			<p>And so, you can see that it is possible to build for all different platforms from a single development computer.</p>
			<p>However, this involved a lot of package installation and configuration. To avoid this complication there is a helpful tool, <strong class="source-inline">fyne-cross</strong>, which packages the required files for easier cross-compiling.</p>
			<p>For each of the preceding builds, we could also have specified a <strong class="source-inline">GOARCH</strong> variable if we wanted to target, for example, a 32-bit computer while building on our 64-bit desktop. Likewise, specifying an ARM architecture allows us to compile for Raspberry Pi computers.</p>
			<p class="callout-heading">Note that the iOS and Android targets do not use a traditional toolchain</p>
			<p class="callout">The ability to build for mobile targets is provided by the platform-specific development packages (for example, Xcode or the Android SDK). This means you can avoid the manual compiler configuration, but will need to use the <strong class="source-inline">fyne</strong> package instead of a traditional <strong class="source-inline">go build</strong> process.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor237"/>Using the fyne-cross tool</h2>
			<p>The <strong class="source-inline">fyne-cross</strong> tool was<a id="_idIndexMarker583"/> created to provide a simple cross-compiling<a id="_idIndexMarker584"/> approach for the Fyne toolkit. It utilizes a Docker container to package all of the build tools so that the developer does not have to install them all manually, as we did in the previous section. You can read more about the project at <a href="https://github.com/fyne-io/fyne-cross">https://github.com/fyne-io/fyne-cross</a>.</p>
			<p>Using <strong class="source-inline">fyne-cross</strong>, you can simply specify the <em class="italic">platform</em> you would like to build for on the command line and the tool sets up the development environment and builds the package as requested. The <strong class="source-inline">platform</strong> parameter is like the <strong class="source-inline">-os</strong> parameter we used earlier.</p>
			<p>To be able to install and<a id="_idIndexMarker585"/> use this tool, all we need is our existing Go compiler and an installation of <strong class="bold">Docker</strong> (an application that manages software containers). We will now step through the work involved to build our first app using <strong class="source-inline">fyne-cross</strong>. </p>
			<p>In this example, we have a macOS computer building for Linux (the configuration that was complex in the previous section):</p>
			<ol>
				<li value="1">First, we must<a id="_idIndexMarker586"/> install Docker. The easiest way to do this is to download and run the desktop installer from their website at <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>. Unfortunately, this is not supported on Linux, so you will need to install Docker Engine (usually in the package named <strong class="source-inline">docker</strong>) using your package manager.</li>
				<li>To run <strong class="source-inline">fyne-cross</strong>, the Docker app must be running. If using Docker Desktop you should see the icon in your system tray (see the icon on the left in <em class="italic">Figure 9.3</em>). If it is not running, then just open the app using its launch icon (the icon on the right in <em class="italic">Figure 9.3</em>):<div id="_idContainer114" class="IMG---Figure"><img src="image/Figure_9.3_B16820.jpg" alt="Figure 9.3 – The Docker running symbol and app icon&#13;&#10;"/></div><p class="figure-caption">Figure 9.3 – The Docker running symbol and app icon</p><p>If running on Linux, then make sure that the service is started according to your specific distribution's documentation.</p></li>
				<li>To install the <strong class="source-inline">fyne-cross</strong> tool, we use a version of the <strong class="source-inline">go get</strong> command, which will install it along with other Go-based applications in the <strong class="source-inline">~/go/bin/</strong> directory:<p class="source-code"><strong class="bold">$ go get github.com/fyne-io/fyne-cross</strong></p></li>
				<li>Next, we issue the<a id="_idIndexMarker587"/> command to run <strong class="source-inline">fyne-cross</strong>. The basic build requires a single parameter that is the operating system we want <a id="_idIndexMarker588"/>to build for, so for Linux, we simply call the following:<p class="source-code"><strong class="bold">$ fyne-cross linux</strong></p><p class="source-code"><strong class="bold">[i] Target: linux/amd64</strong></p><p class="source-code"><strong class="bold">[i] Cleaning target directories...</strong></p><p class="source-code"><strong class="bold">[</strong>√<strong class="bold">] "bin" dir cleaned: /.../Chapter09/package/fyne-cross/bin/linux-amd64</strong></p><p class="source-code"><strong class="bold">[</strong>√<strong class="bold">] "dist" dir cleaned: /.../Chapter09/package/fyne-cross/dist/linux-amd64</strong></p><p class="source-code"><strong class="bold">[</strong>√<strong class="bold">] "temp" dir cleaned: /.../Chapter09/package/fyne-cross/tmp/linux-amd64</strong></p><p class="source-code"><strong class="bold">[i] Checking for go.mod: /.../Chapter09/package/go.mod</strong></p><p class="source-code"><strong class="bold">[i] go.mod not found, creating a temporary one...</strong></p><p class="source-code"><strong class="bold">Unable to find image 'fyneio/fyne-cross:base-latest' locally</strong></p><p class="source-code"><strong class="bold">base-latest: Pulling from fyneio/fyne-cross </strong></p><p class="source-code"><strong class="bold">(downloads lots of stuff)</strong></p><p class="source-code"><strong class="bold">[</strong>√<strong class="bold">] Binary: /.../Chapter09/package/fyne-cross/bin/linux-amd64/package</strong></p><p class="source-code"><strong class="bold">[i] Packaging app...</strong></p><p class="source-code"><strong class="bold">[</strong>√<strong class="bold">] Package: /.../Chapter09/package/fyne-cross/dist/linux-amd64/package.tar.gz</strong></p></li>
				<li>Once this has completed (the first run will take some time as the Docker image needs to be downloaded), we should see that the expected package has been created for us:<p class="source-code"><strong class="bold">$ ls fyne-cross/dist/linux-amd64</strong></p><p class="source-code"><strong class="bold">package.tar.gz</strong></p></li>
			</ol>
			<p>As you can see, the <strong class="source-inline">fyne-cross</strong> tool was able to create the application package for a system that was otherwise difficult to compile for. </p>
			<p>Builds for any operating <a id="_idIndexMarker589"/>system and platform in the supported <a id="_idIndexMarker590"/>list (at the time of writing) include the following:</p>
			<ul>
				<li><strong class="source-inline">darwin/amd64</strong></li>
				<li><strong class="source-inline">darwin/386</strong></li>
				<li><strong class="source-inline">freebsd/amd64</strong></li>
				<li><strong class="source-inline">linux/amd64</strong></li>
				<li><strong class="source-inline">linux/386</strong></li>
				<li><strong class="source-inline">linux/arm</strong></li>
				<li><strong class="source-inline">linux/arm64</strong></li>
				<li><strong class="source-inline">windows/amd64</strong></li>
				<li><strong class="source-inline">windows/386</strong></li>
				<li><strong class="source-inline">android</strong></li>
				<li><strong class="source-inline">ios</strong><p class="callout-heading">Note </p><p class="callout">iOS compilation is supported only on macOS computers. You will need to download and install Xcode from the Apple App Store. This is a restriction of Apple licenses and unfortunately cannot be worked around.</p></li>
			</ul>
			<p>If you are able to install Docker, this is probably the easier way to build for different computers.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor238"/>Summary</h1>
			<p>In this chapter, we have seen the steps involved to take an application from running from the source code, through to packaged files ready for distribution. We saw the techniques and tools available to help make applications portable and how the Fyne toolkit can offer hints of how to improve your UX.</p>
			<p>We also explored the world of cross-compiling and how to create application packages for different operating systems. As illustrated in this chapter, it is possible to set up your development computer to build for all supported platforms; however, we saw that this can be complicated. The <strong class="source-inline">fyne-cross</strong> tool was introduced as a way to solve this complexity and make it trivial to package builds for the multitude of potential target systems.</p>
			<p>In the next chapter, we will look at how to distribute these files. We will explore how you can share packaged files with beta testers and then how to prepare the packages with the certification required for app store and marketplace uploads.</p>
		</div>
	</body></html>