- en: '*Chapter 9*: Bundling Resources and Preparing for Release'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：资源打包和准备发布'
- en: Go applications are known for building simple application binary files that
    make them easy to install. However, the additional data required for graphical
    applications can make this challenging and has resulted in complex package formats
    and the introduction of installers as well. Fyne provides an alternative solution
    that allows apps to once again be distributed as a single file on most platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序以其构建简单的应用程序二进制文件而闻名，这使得它们易于安装。然而，图形应用程序所需的附加数据可能会使这一过程变得具有挑战性，并导致了复杂的包格式以及安装器的引入。Fyne提供了一种替代解决方案，允许应用程序在大多数平台上再次以单个文件的形式分发。
- en: Completing the packaging of an application requires metadata and an additional
    build step to prepare the files for distribution. This step allows applications
    to be installed to the local system or development devices alongside system-native
    apps, which we will study in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成应用程序的打包需要元数据和额外的构建步骤来准备分发文件。这一步骤允许应用程序与系统原生应用程序一起安装到本地系统或开发设备上，我们将在本章中研究这一点。
- en: 'We will walk through adding the various files an app will need at runtime.
    We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍应用程序在运行时所需的各个文件。我们将涵盖以下主题：
- en: How to include additional files in your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在您的应用程序中包含额外的文件
- en: Checking for common **User Experience** (**UX**) mistakes to improve your GUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查常见的**用户体验**（**UX**）错误以改进您的GUI
- en: Packaging applications ready for distribution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备分发应用程序
- en: Installing on your computer or development mobile devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机或开发移动设备上安装
- en: At the end of this chapter, you will install your applications on your computer
    and smartphone for real-world testing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，您将在您的计算机和智能手机上安装应用程序进行实际测试。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*: to have the Fyne toolkit installed and Go and
    C compilers working. For more information, please refer to that chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与[*第3章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)，*Windows、画布和绘图*的要求相同：需要安装Fyne工具包，并且Go和C编译器正常工作。有关更多信息，请参阅该章节。
- en: For deployment to Android devices, you will need to install the Android SDK
    and NDK (refer to [*Appendix B*](B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256),
    *Installation of Mobile Build Tools*). To build for iOS devices, you will also
    need to install Xcode on your Macintosh computer (a Mac is required for licensing
    reasons).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于部署到Android设备，您需要安装Android SDK和NDK（请参阅[*附录B*](B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256)，*移动构建工具的安装*）。要为iOS设备构建，您还需要在您的Macintosh计算机上安装Xcode（由于许可原因，需要Mac）。
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09)找到。
- en: Bundling assets
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产打包
- en: Go applications are designed to run from a single binary file. This means they
    can easily be distributed and do not rely on installation scripts. Unfortunately,
    this benefit results in a cost for developers—we cannot rely on resources being
    found along with our applications in the way that web or mobile app developers
    can (and as we have been doing during development). To ensure that our applications
    conform to this design, we must embed any required assets into the application
    binary. This includes fonts, images, and any other static content that is needed
    for the application to operate correctly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序设计为从单个二进制文件运行。这意味着它们可以轻松分发，并且不依赖于安装脚本。不幸的是，这种好处给开发者带来了成本——我们不能像网络或移动应用程序开发者那样（以及我们在开发过程中所做的那样）依赖于应用程序中找到的资源。为了确保我们的应用程序符合这种设计，我们必须将任何所需的资产嵌入到应用程序二进制文件中。这包括字体、图像以及任何其他应用程序正常运行所需的静态内容。
- en: 'The Fyne toolkit provides a tool for the bundling of assets that is recommended
    for any apps built using Fyne. The benefit of using this tool is that it generates
    `fyne.Resource` definitions for each embedded resource, which makes it easy to
    pass embedded assets into various Fyne APIs. This bundle tool is actually a command
    within the project''s `fyne` command-line tool that is used in various examples
    within this book. The command is installed with a single `go get` command as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne工具包为使用Fyne构建的任何应用程序提供了打包资源的工具。使用此工具的好处是它为每个嵌入的资源生成`fyne.Resource`定义，这使得将嵌入的资产传递到各种Fyne
    API变得容易。实际上，这个打包工具是项目`fyne`命令行工具中的一个命令，本书中的许多示例都使用了这个命令。该命令可以通过单个`go get`命令安装，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `bundle` command simply converts assets from the filesystem in to the Go
    source code, which can then be compiled into applications. This means that the
    compiled application will include the assets and therefore not rely on them being
    present on the filesystem when the app runs. The `bundle` command is a part of
    the `fyne` executable, and takes the file to embed as its main parameter. It prints
    the result to the system output, so we use console redirection (`>`) to send the
    generated Go source code to a suitable file, as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`bundle`命令简单地将文件系统中的资产转换为Go源代码，然后可以将其编译成应用程序。这意味着编译后的应用程序将包含资产，因此当应用程序运行时不需要依赖文件系统中的资产。`bundle`命令是`fyne`可执行文件的一部分，它将嵌入的文件作为其主要参数。它将结果打印到系统输出，因此我们使用控制台重定向（`>`）将生成的Go源代码发送到合适的文件，如下面的代码片段所示：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the file is generated, we can reference it using the created symbol (of
    type `*fyne.StaticResource`, which implements `fyne.Resource`). This can be used
    like any other resource, so we can load it as an image in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 文件生成后，我们可以使用创建的符号（类型为`*fyne.StaticResource`，实现了`fyne.Resource`接口）来引用它。这可以像任何其他资源一样使用，因此我们可以以下面的方式将其加载为图像：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The generated variable name may not be ideal for your usage, but it can be
    changed using an additional command parameter. For example, if you wanted to export
    this new symbol, you could specify a simpler name that starts with an uppercase
    letter by adding the `-name Demo parameter`, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的变量名可能不适合您的使用，但可以通过添加额外的命令参数来更改。例如，如果您想导出这个新符号，可以通过添加`-name Demo`参数来指定一个以大写字母开头的简单名称，如下所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding command manages the inclusion of a single asset, but most apps
    will need to have many. Let's see how to add many resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令管理单个资产的包含，但大多数应用程序需要包含许多资产。让我们看看如何添加多个资源。
- en: Including multiple assets
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含多个资产
- en: In the previous example, we bundled a single file that included all the headers
    needed to make the bundle file a complete Go source file. To bundle multiple files
    in this way, we would need a new bundle file for each asset. This is probably
    not ideal and so the bundle tool includes a `-append` parameter that can be used
    to add more assets to the same bundle file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们打包了一个包含所有必需头文件的单一文件，以便将打包文件变成一个完整的Go源文件。要以这种方式打包多个文件，我们需要为每个资产创建一个新的打包文件。这可能不是最佳选择，因此打包工具包括一个`-append`参数，可以用来向同一个打包文件添加更多资产。
- en: 'To bundle a second file we use this new parameter and change the console redirection
    symbol to the append version (`>>`). For example, we can add `demo2.svg` to the
    same bundle output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要打包第二个文件，我们使用这个新参数并将控制台重定向符号更改为追加版本（`>>`）。例如，我们可以将`demo2.svg`添加到同一个打包输出中：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The resulting `bundle.go` file will contain two definitions, `resourceDemoSvg`
    and `resourceDemo2Svg`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`bundle.go`文件将包含两个定义，`resourceDemoSvg`和`resourceDemo2Svg`。
- en: 'In this manner, you can embed many resources, but it requires an additional
    command for each resource, which can be time-consuming and prone to human error.
    Instead, we can bundle all of the assets from a directory with a single command.
    To do so, we just use a directory path instead of the filename, using the same
    syntax as the first bundle we executed. The result of the following directory
    bundle will create the same output as running the two file commands shown previously:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，您可以嵌入许多资源，但需要为每个资源添加额外的命令，这可能会很耗时且容易出错。相反，我们可以使用单个命令将目录中的所有资产打包在一起。为此，我们只需使用目录路径而不是文件名，使用与第一个打包相同的语法。以下目录打包的结果将生成与之前显示的两个文件命令相同的输出：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, it can be quite powerful to embed lots of data with a single
    command. The resulting file (`bundle.go`) should be added to your version control
    so other developers do not have to run this command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用单个命令嵌入大量数据可以非常强大。生成的文件（`bundle.go`）应该添加到您的版本控制中，这样其他开发者就不必运行此命令。
- en: To support this, an easy configuration works best when the assets are in a separate
    directory. Therefore, in addition to the file structure discussed in [*Chapter
    8*](B16820_08_Final_JM_ePub.xhtml#_idTextAnchor205), *Project Structure and Best
    Practices*, it is common to add `data` directories alongside code that will utilize
    the embedded assets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，当资产位于单独的目录中时，简单的配置效果最好。因此，除了在 [*第 8 章*](B16820_08_Final_JM_ePub.xhtml#_idTextAnchor205)
    中讨论的文件结构，*项目结构和最佳实践*，通常还会在将利用嵌入式资产的代码旁边添加 `data` 目录。
- en: When the assets are updated, however, a developer may not remember the command
    to use, and so we will look briefly at how this can be automated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当资产更新时，开发者可能不会记得要使用的命令，因此我们将简要地看看如何自动化这个过程。
- en: Automating bundle commands
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化捆绑命令
- en: The Go compiler has a helpful `generate` subcommand that can be used to process
    resources such as the assets we have been bundling in this section. To make use
    of this tool, we add a `//go:generate` header to one of our source files (not
    the generated file, as this will be overwritten).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编译器有一个有用的 `generate` 子命令，可以用来处理资源，例如我们在这个部分捆绑的资产。为了使用这个工具，我们在我们的源文件之一（而不是生成的文件，因为这个文件将被覆盖）中添加了一个
    `//go:generate` 头文件。
- en: 'For this simple example, we add a new file named `main.go` that exists simply
    to include this header (normally there would already be a file available). Into
    this, we add a header line that tells Go how to generate our resources, before
    the package name:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们添加了一个名为 `main.go` 的新文件，它仅仅是为了包含这个头文件（通常情况下，已经存在一个文件）。在这个文件中，我们在包名之前添加了一行头文件，告诉
    Go 如何生成我们的资源。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see here a change to how we were calling the command before—the inclusion
    of a `-o` parameter followed by the name we want to output to. This is introduced
    because within a `generate` command, we cannot use the command-line redirection
    tools that were in use previously. The parameter simply has the same effect –
    it specifies which file the output should be sent to. And so when we run `go generate`
    we see the same result as if we''d bundled the data directory manually. This is
    as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们之前调用命令的方式发生了变化——添加了一个 `-o` 参数，后面跟着我们想要输出的名称。这是引入的，因为在 `generate` 命令中，我们不能使用之前使用的命令行重定向工具。该参数具有相同的效果——它指定了输出应该发送到哪个文件。因此，当我们运行
    `go generate` 时，我们会看到与手动捆绑数据目录相同的结果。如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the preceding tools, we have prepared our application work without the
    asset files present, which makes it easier to distribute. Before we start packaging
    we should also check whether the Fyne toolkit has other tips for our app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的工具，我们已经准备了一个没有资产文件的应用程序工作，这使得它更容易分发。在我们开始打包之前，我们还应该检查 Fyne 工具包是否有其他对我们应用程序的建议。
- en: Checking for UI hints
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 UI 提示
- en: As Fyne is built using **Material Design** principles, it is possible to make
    use of their recommendations for good and bad ways to use certain components and
    how you should and shouldn't combine elements for a great UX.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Fyne 是基于 **Material Design** 原则构建的，因此可以参考其关于如何使用某些组件的推荐，以及如何组合元素以实现良好的用户体验。
- en: Built into the Fyne toolkit is the concept of **hints**. These are suggestions
    that widgets and other components can make about how an app could make changes
    to offer an improved user interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 工具包中内置了 **提示** 的概念。这些是关于应用程序如何进行更改以提供改进的用户界面的建议。
- en: 'We will start exploring what these hints can offer by creating a simple example
    tab container application. This code snippet will load two tabs into a tab container
    (the `makeTabs()` function). We then include a `main()` function that will load
    a new app, create a window, and set the tabs to be its content. The function then
    runs our app in the usual way as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个简单的示例标签容器应用程序来开始探索这些提示可以提供什么。这个代码片段将把两个标签加载到标签容器中（`makeTabs()` 函数）。然后我们包含一个
    `main()` 函数，该函数将加载一个新的应用程序，创建一个窗口，并将标签设置为它的内容。然后函数以通常的方式运行我们的应用程序，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this code written, we can run it as normal. However, this time we will
    pass the additional `-tags hints` parameter to turn on the suggestions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以像平常一样运行它。然而，这次我们将传递额外的 `-tags hints` 参数来启用建议：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When running, you will see the app as illustrated in *Figure 9.1*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，您将看到如图*图9.1*所示的应用程序：
- en: '![Figure 9.1 – The Tabs app looks like it’s working correctly'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.1 – The Tabs app looks like it’s working correctly'
- en: '](img/Figure_9.1_B16820.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.1_B16820.jpg]'
- en: Figure 9.1 – The Tabs app looks like it's working correctly
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 标签应用程序看起来运行正确
- en: 'There really are no surprises in how the app looks, but if you check the output
    of the application that''s printed to the command line you will notice lots of
    output that we have not seen before. You will probably see something like the
    following (it may vary based on the version of Fyne being used):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的外观方面，实际上并没有太多惊喜，但如果您检查打印到命令行中的应用程序输出，您将注意到很多我们之前没有看到的内容。您可能会看到以下类似的内容（它可能基于使用的Fyne版本而有所不同）：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in the preceding output, there are two lines marked `Fyne hint`.
    These are each the start of a new suggestion. The line after each instance is
    useful to show where in our code the hint refers to (the paths were partly removed
    for clarity). The preceding hints tell us the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的输出中看到的，有两行被标记为`Fyne提示`。这些每一行都是新建议的开始。每个实例之后的行有助于显示提示在代码中的位置（为了清晰起见，路径部分已被删除）。前面的提示告诉我们以下信息：
- en: Our application is missing the unique ID that is required for some functionality
    to work – you will have learned about `appID` already if you read [*Chapter 6*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166),
    *Data Binding and Storage*. We will discuss this further in the *Metadata, icons,
    and app IDs* section later in this chapter.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序缺少某些功能正常工作所需的唯一ID – 如果您阅读了[*第6章*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166)，*数据绑定和存储*，您可能已经了解了`appID`。我们将在本章后面的*元数据、图标和应用程序ID*部分进一步讨论这个问题。
- en: The tab container that we created has a mix of tab styles; one has an icon and
    the other does not. We could resolve this by adding an icon to the `JustText`
    tab, or by removing the `Home` tab icon.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的标签容器混合了多种标签样式；一个有图标，另一个没有。我们可以通过向`JustText`标签添加图标或删除`Home`标签图标来解决这个问题。
- en: As you can see from this, it can be helpful to check the hints for your application.
    The small changes suggested by doing so can lead to an improved UX, or resolve
    future issues that have not yet been encountered.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，检查您应用程序的提示可能会有所帮助。通过这样做建议的小改动可以导致用户体验的改善，或者解决尚未遇到的问题。
- en: As our app is now ready to be packaged, we need to think about how it will be
    presented in terms of its app name, icon, and other metadata.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序现在准备好打包时，我们需要考虑它在应用名称、图标和其他元数据方面的展示方式。
- en: Choosing metadata, icons, and app IDs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择元数据、图标和应用程序ID
- en: Before we start on the technical aspects of creating an application release,
    there are a few prerequisites to consider. The application name is probably set
    by now, but do you have a great description for it? Do you know how to articulate
    the key features of your software in a way that will grab the attention of potential
    users? Have you (or your design team) created a great app icon that will be memorable
    and somehow indicative of its functionality?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建应用程序发布的技术细节之前，有一些先决条件需要考虑。应用程序的名称现在可能已经确定，但您有出色的描述吗？您知道如何以吸引潜在用户注意的方式阐述您软件的关键特性吗？您（或您的设计团队）是否创建了一个令人难忘且能体现其功能的优秀应用程序图标？
- en: If you won't distribute your app through a managed channel, such as an app store
    or platform package manager, you should consider how the application will be discovered
    by your target audience. There is a lot of discussion and information online about
    **Search Engine Optimization** (**SEO**) and a growing amount about **App Store
    Optimization** (**ASO**) to be found, so we will not go into detail here. What
    is clear in the current software climate is that the ease of discovery and memorability
    of your app are now more important than ever before. The three most important
    aspects are the icon and description of the app, and the unique identifier that
    it will use in each store. We'll start by exploring the details of an app icon.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不会通过管理渠道分发您的应用程序，例如应用商店或平台包管理器，您应该考虑您的目标受众将如何发现应用程序。关于**搜索引擎优化**（**SEO**）的讨论和信息在网上有很多，关于**应用商店优化**（**ASO**）的内容也在不断增加，所以我们在这里不会详细介绍。在当前的软件环境中，很明显，您应用程序的可发现性和记忆性现在比以往任何时候都更重要。最重要的三个方面是应用程序的图标和描述，以及它在每个商店中使用的唯一标识符。我们将首先探讨应用程序图标的细节。
- en: Application icons
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序图标
- en: Picking your icon is probably the single most important part of preparing an
    application for release. It needs to be memorable and also evoke some idea of
    what the software is for. A great icon should look good when displayed either
    large or small, and in general, tiny details should be avoided, or only used for
    unimportant aspects of the design. Make sure that your icon is created at a high
    resolution; using a vector format is advisable (for example, **SVG**), but if
    you are working with a bitmap format (such as **PNG**) then 1024 x 1024 pixels
    is the minimum requirement for an icon to look great on the widest variety of
    devices. It's also important to consider the use of transparency—depending on
    the platforms you wish to distribute to, this may or may not be recommended. Most
    desktop systems allow the use of shaped icons, but not all will allow semi-transparent
    areas and iOS does not allow transparency at all, whereas Android encourages it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 选择图标可能是准备发布应用程序最重要的单个部分。它需要让人印象深刻，并且能够唤起一些关于软件用途的想法。一个优秀的图标在显示为大或小尺寸时都应该看起来很好，而且通常应该避免使用过多的细节，或者只用于设计的不重要方面。确保你的图标以高分辨率创建；使用矢量格式是可取的（例如，**SVG**），但如果你正在使用位图格式（例如，**PNG**），那么1024
    x 1024像素是图标在广泛设备上看起来很棒的最小要求。同时，考虑透明度的使用也很重要——根据你希望分发的平台，这可能或可能不被推荐。大多数桌面系统允许使用形状图标，但并非所有都允许半透明区域，iOS则完全不允许透明度，而Android则鼓励使用透明度。
- en: Take some time to look at popular or commonplace icons on each of the operating
    systems or desktop environments where you expect your application to be used.
    Can you match your icon style to each of them successfully? Does it seem like
    a particular shape or style will be expected by users of these systems? It may
    be best, or necessary, to create different versions of the graphic for different
    platforms. Doing so is not a problem, and can be accommodated by passing different
    icons to the build commands that we will study later in this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间查看你预期应用程序将在其中使用的每个操作系统或桌面环境中的流行或常见图标。你能否成功地匹配你的图标风格与它们中的每一个？这些系统的用户是否期望特定的形状或风格？可能最好，或者必要的是，为不同的平台创建不同的图形版本。这样做没有问题，并且可以通过在后面章节中学习的构建命令传递不同的图标来实现。
- en: The packaging commands later in this chapter allow an icon to be specified;
    however, if you would like to set a default icon for your app, simply call it
    `Icon.png` or `Icon.svg`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面的打包命令允许指定图标；然而，如果你想为你的应用程序设置一个默认图标，只需将其命名为`Icon.png`或`Icon.svg`。
- en: Describing your app
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述你的应用程序
- en: At this stage of development, you may have started to engage your audience and
    understand what they like about the software and who the target users will be.
    If not, then don't fear – just note that this is the time to think about how your
    description and supporting materials could best attract new users. Whether it's
    through a web search engine or an application marketplace, the text you use is
    critical for convincing anyone to install your application. As well as the name
    of the application and its main functionality, make sure you consider how it could
    benefit your users. What tasks do you expect they will be trying to complete when
    searching for the solution you have built? Don't worry about making this text
    long, but do try to include these important points.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个发展阶段，你可能已经开始吸引你的受众并了解他们喜欢软件的哪些方面，以及目标用户是谁。如果没有，那么不要害怕——只需注意，现在是考虑如何让你的描述和支持材料最能吸引新用户的时候。无论是通过网络搜索引擎还是应用市场，你使用的文本对于说服任何人安装你的应用程序至关重要。除了应用程序的名称和其主要功能外，确保你考虑了它如何为你的用户带来好处。你期望他们在寻找你构建的解决方案时尝试完成哪些任务？不用担心让这段文字太长，但尽量包括这些重要观点。
- en: How exactly you will ship your application is discussed further in [*Chapter
    10*](B16820_10_Final_JM_ePub.xhtml#_idTextAnchor239), *Distribution – App Stores
    and Beyond*, but whether you intend to ship your application via an online store
    or a simple website, it's advisable to make sure you have completed your metadata
    before you continue to the release process. The information we have prepared here
    will be embedded in the packages we create and it's important that it retains
    consistency with the distribution metadata that will be used later in this chapter
    and beyond. User trust can be quickly lost and having an app icon that does not
    match the preview, for example, can cause concern. Remember that the description
    should match the name and the icon so that users will quickly recognize it once
    installed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如何具体发布您的应用程序将在[*第10章*](B16820_10_Final_JM_ePub.xhtml#_idTextAnchor239)中进一步讨论，*分发
    – 应用商店及其他*，但无论您打算通过在线商店还是简单的网站发布应用程序，在继续发布流程之前，确保您已经完成了元数据是很明智的。我们在这里准备的信息将嵌入我们创建的包中，并且它与本章及以后将使用的分发元数据保持一致性非常重要。用户的信任可能会迅速丧失，例如，如果应用程序图标与预览不匹配，可能会引起担忧。请记住，描述应与名称和图标相匹配，以便用户安装后能快速识别。
- en: Application identifier (appID)
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用标识符（appID）
- en: As we saw in the *Checking for UI hints* section, a unique identifier will be
    needed at some point for every Fyne app. If you have already used the preferences
    or storage APIs then this may already be set; however, if you have not then you
    need to pick the app ID at this stage as it is required to proceed to packaging
    your app on many operating systems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *检查 UI 提示* 部分中看到的，每个 Fyne 应用程序在某个时候都需要一个唯一标识符。如果您已经使用了首选项或存储 API，那么这可能已经设置好了；然而，如果您还没有，那么您需要在此时选择
    app ID，因为它对于在许多操作系统上打包您的应用程序是必需的。
- en: An app identifier is used to uniquely recognize this software; as well as being
    globally unique, it must never change. Accidentally changing this would likely
    result in users losing their data and may also mean that updates are not sent
    to existing users of your software, so pick one now and be careful that it is
    kept consistent.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用标识符用于唯一识别此软件；除了是全球唯一的，它永远不能改变。意外更改它可能会导致用户丢失数据，也可能意味着不会向现有软件用户发送更新，所以现在选择一个，并确保它保持一致。
- en: The normal scheme for choosing your unique ID is to use the reverse-DNS notation.
    This format will be familiar to developers who have worked with Java or Android
    packages, or Apple's **Uniform Type Identifier** (**UTI**). The format is based
    on the assumption that each developer, company, or product has a website or home
    page address that can be used as a namespace for their work. When such a grouping
    is applied then additional information can be used to identify the software component
    internally, making it a globally unique identifier. The *reverse* component of
    reverse-DNS is useful for sorting and searching, which is why it gained popularity
    in the management of software components.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 选择您独特 ID 的常规方案是使用反向 DNS 表示法。这种格式对与 Java 或 Android 包或苹果的 **统一类型标识符**（**UTI**）工作过的开发者来说很熟悉。该格式基于每个开发者、公司或产品都有一个网站或主页地址，可以用作其工作的命名空间的假设。当应用这种分组时，可以使用附加信息来识别软件组件，使其成为全球唯一标识符。反向
    DNS 的 *反向* 部分对于排序和搜索很有用，这就是为什么它在软件组件管理中变得流行。
- en: 'The generic format is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通用格式如下：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And so, following this format, an example company with domain name `myco.com`
    that is releasing a product named `tasks` in their category of `productivity`
    software might use the following app ID:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按照这种格式，一个名为 `myco.com` 的公司，在其 `productivity` 软件类别中发布名为 `tasks` 的产品时，可能会使用以下
    app ID：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The content of this string after the initial, reversed domain name can be whatever
    you choose; adding categories or another identifier is commonplace. It is not
    advisable, however, to add a version number as this string must remain identical
    for the life of your software to avoid some of the potential issues described
    previously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始反向域名之后的字符串内容可以是您选择的任何内容；添加类别或另一个标识符很常见。然而，不建议添加版本号，因为这个字符串必须在其软件生命周期内保持相同，以避免之前描述的一些潜在问题。
- en: 'If you do not have a website for your application, you could choose to use
    the location that it is stored in instead. It does not matter if you move the
    location in the future, as this is just an identifier – be sure to keep it the
    same if you do move the repository location. For example, a tutorial app stored
    on GitHub for user `dummyUser` might take the following app ID – notice that there
    is a third element to the domain name to remain globally unique:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为你的应用程序创建网站，你可以选择使用它存储的位置。即使你将来移动位置，这也没有关系，因为这只是一个标识符——如果你确实移动了存储库位置，请确保保持它不变。例如，存储在GitHub上的用户`dummyUser`的教程应用程序可能采用以下应用程序ID——请注意，域名中有一个第三元素以保持全球唯一性：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have our metadata in order, we can start packaging our application
    and then install it on our test devices.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好元数据，我们可以开始打包我们的应用程序，然后将其安装到我们的测试设备上。
- en: Packaging applications (desktop and mobile)
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包应用程序（桌面和移动）
- en: To incorporate the metadata prepared in the preceding sections, we need to execute
    the *packaging* phase. This will take the standard Go application binary and attach
    or embed the required data based on the operating specifics. As each platform
    requires different data formats and produces different resulting file structures,
    we use the `fyne` tool once again to take care of the details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要整合前面章节中准备好的元数据，我们需要执行*打包*阶段。这将从标准的Go应用程序二进制文件中提取所需数据，并根据操作系统的具体情况进行附加或嵌入。由于每个平台都需要不同的数据格式并产生不同的结果文件结构，我们再次使用`fyne`工具来处理细节。
- en: Packaging for your current computer
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的当前计算机打包
- en: To create a package from a Fyne project, we use the `fyne package` command.
    By default, this will create an application bundle or executable for the current
    operating system. When run on macOS this will create a `.app` bundle; on Windows
    it will be a `.exe` file (with additional metadata); on Linux it creates a `.tar.gz`
    file that can be used to install the app.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Fyne项目创建包，我们使用`fyne package`命令。默认情况下，这将创建适用于当前操作系统的应用程序包或可执行文件。在macOS上运行时，这将创建一个`.app`包；在Windows上，它将是一个`.exe`文件（带有附加的元数据）；在Linux上，它创建一个`.tar.gz`文件，可以用来安装应用程序。
- en: It is possible to build this for a different system as well, using the `-os`
    parameter, which we will explore later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`-os`参数为不同的系统构建，我们将在本章后面探讨这一点。
- en: 'Before packaging, it is a good idea to confirm that your application builds
    successfully using the `go build` command. When your app is ready, simply execute
    the `fyne package` command and it will process your app and metadata to create
    the platform-appropriate output. For example, on a macOS computer you would see
    the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包之前，确认你的应用程序使用`go build`命令成功构建是一个好主意。当你的应用程序准备就绪时，只需执行`fyne package`命令，它将处理你的应用程序和元数据以创建适合平台的输出。例如，在macOS计算机上你会看到以下内容：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see that the `go build` command created a regular binary file, and
    that `fyne package` created an app bundle. When opened in macOS Finder, you can
    see how the icon has been applied to the output application bundle:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`go build`命令创建了一个常规的二进制文件，而`fyne package`创建了一个应用程序包。在macOS Finder中打开时，你可以看到图标是如何应用到输出应用程序包上的：
- en: '![Figure 9.2 – The file icons from a macOS build'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – macOS构建的文件图标'
- en: '](img/Figure_9.2_B16820.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B16820.jpg)'
- en: Figure 9.2 – The file icons from a macOS build
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – macOS构建的文件图标
- en: 'If you run the same commands on a Linux computer you would see the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Linux计算机上运行相同的命令，你会看到以下内容：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To read about installing the applications we have just built, you can skip to
    the *Installing your application* section. However, if you would like to prepare
    a build for mobile devices, read on, as we will do that next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何安装我们刚刚构建的应用程序，你可以跳转到*安装你的应用程序*部分。然而，如果你想要为移动设备准备构建，请继续阅读，因为我们将接下来进行这一操作。
- en: Packaging for a mobile device
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为移动设备打包
- en: As mobile apps cannot be created on the device, they have to be packaged from
    a desktop computer and then installed on the mobile device. We use the same tools
    as we used in the previous sections, with the additional `-os` parameter specifying
    `ios` or `android` as the target system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于移动应用程序不能在设备上创建，它们必须从桌面计算机打包，然后安装到移动设备上。我们使用与前面章节相同的工具，并添加`-os`参数指定`ios`或`android`作为目标系统。
- en: As mobile apps require an app ID to build, we must also pass the `appID` parameter
    along with the unique identifier discussed in the *Application identifier (appID)*
    section earlier in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于移动应用程序需要应用 ID 来构建，我们还必须传递与本章前面*应用程序标识符（appID）*部分中讨论的唯一标识符一起的`appID`参数。
- en: Before packaging for iOS or Android devices you will need to install Xcode or
    the Android Developer Tools (discussed in more detail in [*Appendix B*](B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256)*,
    Installation of Mobile Build Tools*).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 iOS 或 Android 设备打包之前，您需要安装 Xcode 或 Android 开发者工具（在[*附录 B*](B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256)*，移动构建工具的安装*中更详细地讨论）。
- en: 'With Xcode installed on a macOS computer (due to Apple''s licensing restrictions),
    you can build an iOS app using the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 计算机上安装了 Xcode（由于苹果的许可限制），您可以使用以下命令构建 iOS 应用程序：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To build an Android app package (`.apk`) use the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 Android 应用程序包（`.apk`），请使用以下命令：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that you have your application bundle or binary file ready to be installed,
    we will see how to simply install your app on your desktop and mobile devices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好了应用程序包或二进制文件，我们将看到如何在您的桌面和移动设备上简单地安装您的应用程序。
- en: Installing your application
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装您的应用程序
- en: If you just want to install the desktop app on your computer or development
    devices then you can make use of the helpful `install` subcommand. There are two
    modes for the `install` tool, firstly to install on the current computer, and
    secondly to install on a mobile device that is set up for development.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想在计算机或开发设备上安装桌面应用程序，则可以使用有用的`install`子命令。`install`工具有两种模式，首先是在当前计算机上安装，其次是在已设置为开发模式的移动设备上安装。
- en: Installing on your current computer
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您当前的计算机上安装
- en: 'To install your application onto your current computer and make it available
    system-wide, you could simply execute the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的应用程序安装到您当前的计算机并使其系统范围内可用，您可以简单地执行以下操作：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The icon file is the minimum required metadata for installing an app to the
    desktop. If you would like to avoid passing the `-icon` parameter each time, you
    can simply rename the file to `Icon.png` and it will be used by default. Once
    the application is installed, you will see it in your computer's program list
    with appropriate icons showing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图标文件是将应用程序安装到桌面所需的最小元数据。如果您想避免每次都传递`-icon`参数，只需将文件重命名为`Icon.png`，它将默认使用。一旦应用程序安装完成，您将在计算机的程序列表中看到它，并显示适当的图标。
- en: Installing on a mobile device
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在移动设备上安装
- en: At this stage, we can install apps to a mobile device if it is set up for development.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果设备已设置为开发模式，我们可以将应用程序安装到移动设备上。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Development provisioning can be complicated and is out of the scope of this
    book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 开发配置可能很复杂，并且超出了本书的范围。
- en: You can read more for iOS devices at [https://help.apple.com/xcode/mac/current/#/dev5a825a1ca](https://help.apple.com/xcode/mac/current/#/dev5a825a1ca).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://help.apple.com/xcode/mac/current/#/dev5a825a1ca](https://help.apple.com/xcode/mac/current/#/dev5a825a1ca)上阅读有关
    iOS 设备的更多信息。
- en: For Android devices, you can read the documentation at [https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android 设备，您可以在[https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options)上阅读文档。
- en: 'With a development-enabled mobile device, apps can be installed using the same
    install command by passing a `-os` parameter as either `android` or `ios`. For
    example, to install a generated `.apk` file on your Android device, use the following
    command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已启用开发的移动设备，可以通过传递`-os`参数作为`android`或`ios`来使用相同的安装命令进行安装。例如，要将生成的`.apk`文件安装到您的
    Android 设备上，请使用以下命令：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, for the mobile app installation, we needed the additional `appID`
    metadata value. This value is passed into the `package` command that we explored
    in the preceding section. If the package is up to date, this value may not be
    required, but it's usually a good idea to pass it just in case.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于移动应用程序安装，我们需要额外的`appID`元数据值。这个值被传递到我们在上一节中探讨的`package`命令中。如果包是最新的，这个值可能不是必需的，但通常出于谨慎考虑最好还是传递它。
- en: And so, you can see that it's simple to install applications on the current
    computer or connected mobile devices. To make this possible, the Fyne tool was
    actually cross-compiling (that means compiling for a different type of computer).
    Let's now look into how that works in more detail.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到在当前计算机或连接的移动设备上安装应用程序非常简单。为了实现这一点，Fyne 工具实际上进行了交叉编译（这意味着为不同类型的计算机编译）。现在让我们更详细地了解一下它是如何工作的。
- en: Cross-compiling with ease
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻松交叉编译
- en: The ability to compile for different operating systems or architectures than
    the current computer is called **cross-compiling**. We saw it used in the previous
    section to package and install a mobile app from a desktop computer. By cross-compiling,
    we can also build applications from one computer for other types of desktop as
    well, for example using Windows to build a macOS application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编译不同于当前计算机的操作系统或架构的能力被称为 **交叉编译**。我们在上一节中看到它被用于从桌面计算机打包和安装移动应用。通过交叉编译，我们还可以从一台计算机为其他类型的桌面构建应用程序，例如使用
    Windows 构建macOS 应用程序。
- en: There are two ways that this can be done. Firstly, we will see how developers
    familiar with platform-specific compilation can use their normal tools to build
    for multiple platforms. After that, we will look at the `fyne-cross` tool and
    how it hides all of the complexity using a Docker image to manage compiling.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种方式完成。首先，我们将看到熟悉特定平台编译的开发者如何使用他们的常规工具为多个平台构建。之后，我们将探讨 `fyne-cross` 工具以及它是如何通过使用
    Docker 镜像来管理编译而隐藏所有复杂性的。
- en: Using installed toolchains
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用已安装的工具链
- en: When taking the traditional approach to cross-compiling, the computer will require
    an additional compiler **toolchain** for each platform and architecture that the
    developer wants to support. This is what provides the ability to compile the graphics
    and system integration code and typically comprises a C compiler and linker. The
    manner of installation for each toolchain varies depending on the current operating
    system as well as the target toolchain. Details for the various installations
    are available in *, Cross-Compiling*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用传统的交叉编译方法时，计算机将需要为开发者想要支持的每个平台和架构添加一个额外的 **工具链**。这提供了编译图形和系统集成代码的能力，通常包括一个
    C 编译器和链接器。每个工具链的安装方式取决于当前的操作系统以及目标工具链。各种安装的详细信息可在 *, 交叉编译* 中找到。
- en: With a toolchain installed, the build process is like regular Go cross-compiling
    where you specify `GOOS` and `GOARCH` environment variables to specify the target
    operating system and architecture. However, we additionally must specify `CGO_ENABLED=1`
    (so that C integration is enabled) and also a `CC` environment variable that specifies
    which toolchain compiler to use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了工具链之后，构建过程就像常规的 Go 交叉编译一样，你需要指定 `GOOS` 和 `GOARCH` 环境变量来指定目标操作系统和架构。然而，我们还需要指定
    `CGO_ENABLED=1`（以便启用 C 集成）以及一个指定要使用哪个工具链编译器的 `CC` 环境变量。
- en: 'A quick summary of the most commonly used compilers and the `CC` environment
    variable to use is as follows (for more information please see *, Cross-Compiling*):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用编译器和要使用的 `CC` 环境变量的简要总结如下（更多信息请参阅 *, 交叉编译*）：
- en: '![Table 9.1 – Downloads, notes, and CC environments for various desktop platforms'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 9.1 – 各桌面平台下载、备注和 CC 环境'
- en: '](img/Table_01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_01.jpg)'
- en: Table 9.1 – Downloads, notes, and CC environments for various desktop platforms
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – 各桌面平台下载、备注和 CC 环境
- en: With the appropriate compilers and libraries installed, we can continue to the
    build phase. For each of the target operating systems, you will need to run through
    these steps with the correct environment variables set. It is recommended to build
    for one platform and then complete the packaging step for each before changing
    to the next configuration. This is because the release binary for one platform
    may overwrite another (for example, macOS and Linux binaries have the same name
    when compiled).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了适当的编译器和库之后，我们可以继续到构建阶段。对于每个目标操作系统，你需要设置正确的环境变量并运行这些步骤。建议先为单个平台构建，然后在更改到下一个配置之前，为每个平台完成包装步骤。这是因为一个平台的发布二进制文件可能会覆盖另一个（例如，当编译时，macOS
    和 Linux 的二进制文件具有相同的名称）。
- en: 'To see how this works, we''ll launch a terminal on a macOS computer and will
    compile and package applications for the current macOS system, followed by Windows
    and Linux. You can use any project; the following example uses the package example
    from earlier in this chapter. Let''s see how this goes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这是如何工作的，我们将在macOS计算机上启动一个终端，并编译和打包当前macOS系统的应用程序，然后是Windows和Linux。你可以使用任何项目；以下示例使用本章早些时候的打包示例。让我们看看结果如何：
- en: 'First of all, we check that the application is building correctly for the current
    system. For our macOS host computer, this will create a `package.app` file, as
    the application we are building is called `package`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查应用程序是否正在为当前系统正确构建。对于我们的macOS主机计算机，这将创建一个 `package.app` 文件，因为我们正在构建的应用程序名为
    `package`：
- en: '[PRE20]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before moving on, we should remove any temporary files, and as we are just
    testing we can remove the packaged app we created as well:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该删除任何临时文件，因为我们只是进行测试，所以也可以删除我们创建的打包应用：
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will build for Microsoft Windows. As described in the preceding table,
    this will require the installation of the `mingw-w64` package using Homebrew or
    another package manager. With this installed, we can set the environment variables,
    including `CC` to specify the compiler. The command will look like the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为Microsoft Windows进行构建。如前表所述，这需要使用Homebrew或其他包管理器安装 `mingw-w64` 包。安装后，我们可以设置环境变量，包括将
    `CC` 设置为指定编译器。命令将如下所示：
- en: '[PRE22]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: $ rm package.exe fyne.syso
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除 `package.exe` 和 `fyne.syso`
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Preparing a Linux build from macOS requires more work. First, you will need
    to install the compiler toolchain, which is the `FiloSottile/musl-cross/musl-cross`
    package in Homebrew. After this, you will need to locate and install suitable
    X11 and OpenGL packages for Linux development (the details here will vary based
    on the Linux computer you are building for; detailed information can be found
    in *, Cross-Compiling*). Once this is all installed, you can execute the Linux
    build much like the Windows command previously, but using the appropriate `CC`
    variable:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从macOS准备Linux构建需要更多的工作。首先，你需要安装编译器工具链，这是Homebrew中的 `FiloSottile/musl-cross/musl-cross`
    包。安装此包后，你需要找到并安装适合Linux开发的合适的X11和OpenGL包（这里的详细信息将根据你构建的Linux计算机而变化；更详细的信息可以在 *,
    交叉编译* 中找到）。一旦所有这些都安装好了，你就可以像之前使用Windows命令一样执行Linux构建，但使用适当的 `CC` 变量：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And so, you can see that it is possible to build for all different platforms
    from a single development computer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到，从单个开发计算机构建所有不同的平台是可能的。
- en: However, this involved a lot of package installation and configuration. To avoid
    this complication there is a helpful tool, `fyne-cross`, which packages the required
    files for easier cross-compiling.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这涉及到大量的包安装和配置。为了避免这种复杂性，有一个有用的工具，`fyne-cross`，它打包了所需的文件以简化交叉编译。
- en: For each of the preceding builds, we could also have specified a `GOARCH` variable
    if we wanted to target, for example, a 32-bit computer while building on our 64-bit
    desktop. Likewise, specifying an ARM architecture allows us to compile for Raspberry
    Pi computers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的每个构建，如果我们想针对例如32位计算机进行构建，同时在我们64位桌面上构建，我们也可以指定一个 `GOARCH` 变量。同样，指定ARM架构允许我们为树莓派计算机编译。
- en: Note that the iOS and Android targets do not use a traditional toolchain
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，iOS和Android目标不使用传统的工具链
- en: The ability to build for mobile targets is provided by the platform-specific
    development packages (for example, Xcode or the Android SDK). This means you can
    avoid the manual compiler configuration, but will need to use the `fyne` package
    instead of a traditional `go build` process.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为移动目标构建的能力由特定平台的发展包提供（例如，Xcode或Android SDK）。这意味着你可以避免手动编译器配置，但需要使用 `fyne` 包而不是传统的
    `go build` 过程。
- en: Using the fyne-cross tool
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `fyne-cross` 工具
- en: The `fyne-cross` tool was created to provide a simple cross-compiling approach
    for the Fyne toolkit. It utilizes a Docker container to package all of the build
    tools so that the developer does not have to install them all manually, as we
    did in the previous section. You can read more about the project at [https://github.com/fyne-io/fyne-cross](https://github.com/fyne-io/fyne-cross).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`fyne-cross` 工具是为了为Fyne工具包提供一个简单的交叉编译方法而创建的。它利用Docker容器来打包所有构建工具，这样开发者就不必手动安装它们，就像我们在上一节中所做的那样。你可以在[https://github.com/fyne-io/fyne-cross](https://github.com/fyne-io/fyne-cross)上了解更多关于这个项目的信息。'
- en: Using `fyne-cross`, you can simply specify the *platform* you would like to
    build for on the command line and the tool sets up the development environment
    and builds the package as requested. The `platform` parameter is like the `-os`
    parameter we used earlier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fyne-cross`，您可以在命令行上简单地指定您想要构建的平台，该工具将设置开发环境并按请求构建包。`platform` 参数类似于我们之前使用的
    `-os` 参数。
- en: To be able to install and use this tool, all we need is our existing Go compiler
    and an installation of `fyne-cross`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够安装和使用此工具，我们需要的只是我们现有的 Go 编译器和 `fyne-cross` 的安装。
- en: 'In this example, we have a macOS computer building for Linux (the configuration
    that was complex in the previous section):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有一个 macOS 计算机为 Linux 构建应用程序（这是前一个章节中复杂的配置）：
- en: First, we must install Docker. The easiest way to do this is to download and
    run the desktop installer from their website at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).
    Unfortunately, this is not supported on Linux, so you will need to install Docker
    Engine (usually in the package named `docker`) using your package manager.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装 Docker。最简单的方法是下载并从他们的网站运行桌面安装程序，网址为 [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)。不幸的是，这不支持
    Linux，因此您需要使用您的包管理器安装 Docker 引擎（通常在名为 `docker` 的软件包中）。
- en: To run `fyne-cross`, the Docker app must be running. If using Docker Desktop
    you should see the icon in your system tray (see the icon on the left in *Figure
    9.3*). If it is not running, then just open the app using its launch icon (the
    icon on the right in *Figure 9.3*):![Figure 9.3 – The Docker running symbol and
    app icon
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 `fyne-cross`，Docker 应用必须正在运行。如果您使用 Docker Desktop，您应该在系统托盘中看到图标（见 *Figure
    9.3* 中的左侧图标）。如果它没有运行，只需使用其启动图标（*Figure 9.3* 中的右侧图标）打开应用程序即可：![Figure 9.3 – The
    Docker running symbol and app icon](img/Figure_9.3_B16820.jpg)
- en: '](img/Figure_9.3_B16820.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 9.3 – The Docker running symbol and app icon](img/Figure_9.3_B16820.jpg)'
- en: Figure 9.3 – The Docker running symbol and app icon
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 9.3 – The Docker running symbol and app icon
- en: If running on Linux, then make sure that the service is started according to
    your specific distribution's documentation.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在 Linux 上运行，请确保根据您特定发行版的文档启动服务。
- en: 'To install the `fyne-cross` tool, we use a version of the `go get` command,
    which will install it along with other Go-based applications in the `~/go/bin/`
    directory:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 `fyne-cross` 工具，我们使用 `go get` 命令的版本，它将把它与其他基于 Go 的应用程序一起安装到 `~/go/bin/`
    目录中：
- en: '[PRE25]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we issue the command to run `fyne-cross`. The basic build requires a
    single parameter that is the operating system we want to build for, so for Linux,
    we simply call the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们发出运行 `fyne-cross` 的命令。基本构建需要一个参数，即我们想要为哪个操作系统构建，因此对于 Linux，我们只需调用以下命令：
- en: '[PRE26]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once this has completed (the first run will take some time as the Docker image
    needs to be downloaded), we should see that the expected package has been created
    for us:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成（第一次运行将花费一些时间，因为需要下载 Docker 镜像），我们应该看到为我们创建了预期的包：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the `fyne-cross` tool was able to create the application package
    for a system that was otherwise difficult to compile for.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`fyne-cross` 工具能够为其他难以编译的系统创建应用程序包。
- en: 'Builds for any operating system and platform in the supported list (at the
    time of writing) include the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对支持列表（在撰写本文时）中的任何操作系统和平台进行的构建包括以下内容：
- en: '`darwin/amd64`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`darwin/amd64`'
- en: '`darwin/386`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`darwin/386`'
- en: '`freebsd/amd64`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`freebsd/amd64`'
- en: '`linux/amd64`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux/amd64`'
- en: '`linux/386`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux/386`'
- en: '`linux/arm`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux/arm`'
- en: '`linux/arm64`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux/arm64`'
- en: '`windows/amd64`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`windows/amd64`'
- en: '`windows/386`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`windows/386`'
- en: '`android`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android`'
- en: '`ios`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios`'
- en: Note
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: iOS compilation is supported only on macOS computers. You will need to download
    and install Xcode from the Apple App Store. This is a restriction of Apple licenses
    and unfortunately cannot be worked around.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: iOS 编译仅在 macOS 计算机上受支持。您需要从 Apple App Store 下载并安装 Xcode。这是 Apple 许可证的限制，不幸的是无法绕过。
- en: If you are able to install Docker, this is probably the easier way to build
    for different computers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够安装 Docker，这可能是为不同计算机构建的更简单方法。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen the steps involved to take an application from
    running from the source code, through to packaged files ready for distribution.
    We saw the techniques and tools available to help make applications portable and
    how the Fyne toolkit can offer hints of how to improve your UX.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了将应用程序从源代码运行到打包文件准备分发所涉及的步骤。我们看到了可用的技术和工具，可以帮助使应用程序可移植，以及 Fyne 工具包如何提供改进
    UX 的提示。
- en: We also explored the world of cross-compiling and how to create application
    packages for different operating systems. As illustrated in this chapter, it is
    possible to set up your development computer to build for all supported platforms;
    however, we saw that this can be complicated. The `fyne-cross` tool was introduced
    as a way to solve this complexity and make it trivial to package builds for the
    multitude of potential target systems.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探索了交叉编译的世界以及如何为不同的操作系统创建应用程序包。正如本章所示，您可以将您的开发计算机设置为构建所有受支持的平台；然而，我们发现这可能会很复杂。`fyne-cross`工具被引入作为一种解决这种复杂性并使为众多潜在目标系统打包构建变得简单的方法。
- en: In the next chapter, we will look at how to distribute these files. We will
    explore how you can share packaged files with beta testers and then how to prepare
    the packages with the certification required for app store and marketplace uploads.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何分发这些文件。我们将探讨您如何与测试人员共享打包文件，以及如何准备适用于应用商店和市场上传所需的认证包。
