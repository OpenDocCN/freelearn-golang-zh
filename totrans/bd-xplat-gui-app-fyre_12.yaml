- en: '*Chapter 9*: Bundling Resources and Preparing for Release'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go applications are known for building simple application binary files that
    make them easy to install. However, the additional data required for graphical
    applications can make this challenging and has resulted in complex package formats
    and the introduction of installers as well. Fyne provides an alternative solution
    that allows apps to once again be distributed as a single file on most platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the packaging of an application requires metadata and an additional
    build step to prepare the files for distribution. This step allows applications
    to be installed to the local system or development devices alongside system-native
    apps, which we will study in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will walk through adding the various files an app will need at runtime.
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to include additional files in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for common **User Experience** (**UX**) mistakes to improve your GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging applications ready for distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing on your computer or development mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will install your applications on your computer
    and smartphone for real-world testing.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*: to have the Fyne toolkit installed and Go and
    C compilers working. For more information, please refer to that chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: For deployment to Android devices, you will need to install the Android SDK
    and NDK (refer to [*Appendix B*](B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256),
    *Installation of Mobile Build Tools*). To build for iOS devices, you will also
    need to install Xcode on your Macintosh computer (a Mac is required for licensing
    reasons).
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Bundling assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go applications are designed to run from a single binary file. This means they
    can easily be distributed and do not rely on installation scripts. Unfortunately,
    this benefit results in a cost for developers—we cannot rely on resources being
    found along with our applications in the way that web or mobile app developers
    can (and as we have been doing during development). To ensure that our applications
    conform to this design, we must embed any required assets into the application
    binary. This includes fonts, images, and any other static content that is needed
    for the application to operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fyne toolkit provides a tool for the bundling of assets that is recommended
    for any apps built using Fyne. The benefit of using this tool is that it generates
    `fyne.Resource` definitions for each embedded resource, which makes it easy to
    pass embedded assets into various Fyne APIs. This bundle tool is actually a command
    within the project''s `fyne` command-line tool that is used in various examples
    within this book. The command is installed with a single `go get` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bundle` command simply converts assets from the filesystem in to the Go
    source code, which can then be compiled into applications. This means that the
    compiled application will include the assets and therefore not rely on them being
    present on the filesystem when the app runs. The `bundle` command is a part of
    the `fyne` executable, and takes the file to embed as its main parameter. It prints
    the result to the system output, so we use console redirection (`>`) to send the
    generated Go source code to a suitable file, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file is generated, we can reference it using the created symbol (of
    type `*fyne.StaticResource`, which implements `fyne.Resource`). This can be used
    like any other resource, so we can load it as an image in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated variable name may not be ideal for your usage, but it can be
    changed using an additional command parameter. For example, if you wanted to export
    this new symbol, you could specify a simpler name that starts with an uppercase
    letter by adding the `-name Demo parameter`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command manages the inclusion of a single asset, but most apps
    will need to have many. Let's see how to add many resources.
  prefs: []
  type: TYPE_NORMAL
- en: Including multiple assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we bundled a single file that included all the headers
    needed to make the bundle file a complete Go source file. To bundle multiple files
    in this way, we would need a new bundle file for each asset. This is probably
    not ideal and so the bundle tool includes a `-append` parameter that can be used
    to add more assets to the same bundle file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bundle a second file we use this new parameter and change the console redirection
    symbol to the append version (`>>`). For example, we can add `demo2.svg` to the
    same bundle output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The resulting `bundle.go` file will contain two definitions, `resourceDemoSvg`
    and `resourceDemo2Svg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this manner, you can embed many resources, but it requires an additional
    command for each resource, which can be time-consuming and prone to human error.
    Instead, we can bundle all of the assets from a directory with a single command.
    To do so, we just use a directory path instead of the filename, using the same
    syntax as the first bundle we executed. The result of the following directory
    bundle will create the same output as running the two file commands shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it can be quite powerful to embed lots of data with a single
    command. The resulting file (`bundle.go`) should be added to your version control
    so other developers do not have to run this command.
  prefs: []
  type: TYPE_NORMAL
- en: To support this, an easy configuration works best when the assets are in a separate
    directory. Therefore, in addition to the file structure discussed in [*Chapter
    8*](B16820_08_Final_JM_ePub.xhtml#_idTextAnchor205), *Project Structure and Best
    Practices*, it is common to add `data` directories alongside code that will utilize
    the embedded assets.
  prefs: []
  type: TYPE_NORMAL
- en: When the assets are updated, however, a developer may not remember the command
    to use, and so we will look briefly at how this can be automated.
  prefs: []
  type: TYPE_NORMAL
- en: Automating bundle commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go compiler has a helpful `generate` subcommand that can be used to process
    resources such as the assets we have been bundling in this section. To make use
    of this tool, we add a `//go:generate` header to one of our source files (not
    the generated file, as this will be overwritten).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this simple example, we add a new file named `main.go` that exists simply
    to include this header (normally there would already be a file available). Into
    this, we add a header line that tells Go how to generate our resources, before
    the package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see here a change to how we were calling the command before—the inclusion
    of a `-o` parameter followed by the name we want to output to. This is introduced
    because within a `generate` command, we cannot use the command-line redirection
    tools that were in use previously. The parameter simply has the same effect –
    it specifies which file the output should be sent to. And so when we run `go generate`
    we see the same result as if we''d bundled the data directory manually. This is
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding tools, we have prepared our application work without the
    asset files present, which makes it easier to distribute. Before we start packaging
    we should also check whether the Fyne toolkit has other tips for our app.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for UI hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Fyne is built using **Material Design** principles, it is possible to make
    use of their recommendations for good and bad ways to use certain components and
    how you should and shouldn't combine elements for a great UX.
  prefs: []
  type: TYPE_NORMAL
- en: Built into the Fyne toolkit is the concept of **hints**. These are suggestions
    that widgets and other components can make about how an app could make changes
    to offer an improved user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start exploring what these hints can offer by creating a simple example
    tab container application. This code snippet will load two tabs into a tab container
    (the `makeTabs()` function). We then include a `main()` function that will load
    a new app, create a window, and set the tabs to be its content. The function then
    runs our app in the usual way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code written, we can run it as normal. However, this time we will
    pass the additional `-tags hints` parameter to turn on the suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When running, you will see the app as illustrated in *Figure 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Tabs app looks like it’s working correctly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The Tabs app looks like it's working correctly
  prefs: []
  type: TYPE_NORMAL
- en: 'There really are no surprises in how the app looks, but if you check the output
    of the application that''s printed to the command line you will notice lots of
    output that we have not seen before. You will probably see something like the
    following (it may vary based on the version of Fyne being used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding output, there are two lines marked `Fyne hint`.
    These are each the start of a new suggestion. The line after each instance is
    useful to show where in our code the hint refers to (the paths were partly removed
    for clarity). The preceding hints tell us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Our application is missing the unique ID that is required for some functionality
    to work – you will have learned about `appID` already if you read [*Chapter 6*](B16820_06_Final_JM_ePub.xhtml#_idTextAnchor166),
    *Data Binding and Storage*. We will discuss this further in the *Metadata, icons,
    and app IDs* section later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tab container that we created has a mix of tab styles; one has an icon and
    the other does not. We could resolve this by adding an icon to the `JustText`
    tab, or by removing the `Home` tab icon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from this, it can be helpful to check the hints for your application.
    The small changes suggested by doing so can lead to an improved UX, or resolve
    future issues that have not yet been encountered.
  prefs: []
  type: TYPE_NORMAL
- en: As our app is now ready to be packaged, we need to think about how it will be
    presented in terms of its app name, icon, and other metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing metadata, icons, and app IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start on the technical aspects of creating an application release,
    there are a few prerequisites to consider. The application name is probably set
    by now, but do you have a great description for it? Do you know how to articulate
    the key features of your software in a way that will grab the attention of potential
    users? Have you (or your design team) created a great app icon that will be memorable
    and somehow indicative of its functionality?
  prefs: []
  type: TYPE_NORMAL
- en: If you won't distribute your app through a managed channel, such as an app store
    or platform package manager, you should consider how the application will be discovered
    by your target audience. There is a lot of discussion and information online about
    **Search Engine Optimization** (**SEO**) and a growing amount about **App Store
    Optimization** (**ASO**) to be found, so we will not go into detail here. What
    is clear in the current software climate is that the ease of discovery and memorability
    of your app are now more important than ever before. The three most important
    aspects are the icon and description of the app, and the unique identifier that
    it will use in each store. We'll start by exploring the details of an app icon.
  prefs: []
  type: TYPE_NORMAL
- en: Application icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Picking your icon is probably the single most important part of preparing an
    application for release. It needs to be memorable and also evoke some idea of
    what the software is for. A great icon should look good when displayed either
    large or small, and in general, tiny details should be avoided, or only used for
    unimportant aspects of the design. Make sure that your icon is created at a high
    resolution; using a vector format is advisable (for example, **SVG**), but if
    you are working with a bitmap format (such as **PNG**) then 1024 x 1024 pixels
    is the minimum requirement for an icon to look great on the widest variety of
    devices. It's also important to consider the use of transparency—depending on
    the platforms you wish to distribute to, this may or may not be recommended. Most
    desktop systems allow the use of shaped icons, but not all will allow semi-transparent
    areas and iOS does not allow transparency at all, whereas Android encourages it.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to look at popular or commonplace icons on each of the operating
    systems or desktop environments where you expect your application to be used.
    Can you match your icon style to each of them successfully? Does it seem like
    a particular shape or style will be expected by users of these systems? It may
    be best, or necessary, to create different versions of the graphic for different
    platforms. Doing so is not a problem, and can be accommodated by passing different
    icons to the build commands that we will study later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The packaging commands later in this chapter allow an icon to be specified;
    however, if you would like to set a default icon for your app, simply call it
    `Icon.png` or `Icon.svg`.
  prefs: []
  type: TYPE_NORMAL
- en: Describing your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage of development, you may have started to engage your audience and
    understand what they like about the software and who the target users will be.
    If not, then don't fear – just note that this is the time to think about how your
    description and supporting materials could best attract new users. Whether it's
    through a web search engine or an application marketplace, the text you use is
    critical for convincing anyone to install your application. As well as the name
    of the application and its main functionality, make sure you consider how it could
    benefit your users. What tasks do you expect they will be trying to complete when
    searching for the solution you have built? Don't worry about making this text
    long, but do try to include these important points.
  prefs: []
  type: TYPE_NORMAL
- en: How exactly you will ship your application is discussed further in [*Chapter
    10*](B16820_10_Final_JM_ePub.xhtml#_idTextAnchor239), *Distribution – App Stores
    and Beyond*, but whether you intend to ship your application via an online store
    or a simple website, it's advisable to make sure you have completed your metadata
    before you continue to the release process. The information we have prepared here
    will be embedded in the packages we create and it's important that it retains
    consistency with the distribution metadata that will be used later in this chapter
    and beyond. User trust can be quickly lost and having an app icon that does not
    match the preview, for example, can cause concern. Remember that the description
    should match the name and the icon so that users will quickly recognize it once
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Application identifier (appID)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the *Checking for UI hints* section, a unique identifier will be
    needed at some point for every Fyne app. If you have already used the preferences
    or storage APIs then this may already be set; however, if you have not then you
    need to pick the app ID at this stage as it is required to proceed to packaging
    your app on many operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: An app identifier is used to uniquely recognize this software; as well as being
    globally unique, it must never change. Accidentally changing this would likely
    result in users losing their data and may also mean that updates are not sent
    to existing users of your software, so pick one now and be careful that it is
    kept consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The normal scheme for choosing your unique ID is to use the reverse-DNS notation.
    This format will be familiar to developers who have worked with Java or Android
    packages, or Apple's **Uniform Type Identifier** (**UTI**). The format is based
    on the assumption that each developer, company, or product has a website or home
    page address that can be used as a namespace for their work. When such a grouping
    is applied then additional information can be used to identify the software component
    internally, making it a globally unique identifier. The *reverse* component of
    reverse-DNS is useful for sorting and searching, which is why it gained popularity
    in the management of software components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And so, following this format, an example company with domain name `myco.com`
    that is releasing a product named `tasks` in their category of `productivity`
    software might use the following app ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The content of this string after the initial, reversed domain name can be whatever
    you choose; adding categories or another identifier is commonplace. It is not
    advisable, however, to add a version number as this string must remain identical
    for the life of your software to avoid some of the potential issues described
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have a website for your application, you could choose to use
    the location that it is stored in instead. It does not matter if you move the
    location in the future, as this is just an identifier – be sure to keep it the
    same if you do move the repository location. For example, a tutorial app stored
    on GitHub for user `dummyUser` might take the following app ID – notice that there
    is a third element to the domain name to remain globally unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our metadata in order, we can start packaging our application
    and then install it on our test devices.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging applications (desktop and mobile)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To incorporate the metadata prepared in the preceding sections, we need to execute
    the *packaging* phase. This will take the standard Go application binary and attach
    or embed the required data based on the operating specifics. As each platform
    requires different data formats and produces different resulting file structures,
    we use the `fyne` tool once again to take care of the details.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging for your current computer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a package from a Fyne project, we use the `fyne package` command.
    By default, this will create an application bundle or executable for the current
    operating system. When run on macOS this will create a `.app` bundle; on Windows
    it will be a `.exe` file (with additional metadata); on Linux it creates a `.tar.gz`
    file that can be used to install the app.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to build this for a different system as well, using the `-os`
    parameter, which we will explore later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before packaging, it is a good idea to confirm that your application builds
    successfully using the `go build` command. When your app is ready, simply execute
    the `fyne package` command and it will process your app and metadata to create
    the platform-appropriate output. For example, on a macOS computer you would see
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the `go build` command created a regular binary file, and
    that `fyne package` created an app bundle. When opened in macOS Finder, you can
    see how the icon has been applied to the output application bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The file icons from a macOS build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16820.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – The file icons from a macOS build
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the same commands on a Linux computer you would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To read about installing the applications we have just built, you can skip to
    the *Installing your application* section. However, if you would like to prepare
    a build for mobile devices, read on, as we will do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging for a mobile device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mobile apps cannot be created on the device, they have to be packaged from
    a desktop computer and then installed on the mobile device. We use the same tools
    as we used in the previous sections, with the additional `-os` parameter specifying
    `ios` or `android` as the target system.
  prefs: []
  type: TYPE_NORMAL
- en: As mobile apps require an app ID to build, we must also pass the `appID` parameter
    along with the unique identifier discussed in the *Application identifier (appID)*
    section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before packaging for iOS or Android devices you will need to install Xcode or
    the Android Developer Tools (discussed in more detail in [*Appendix B*](B16820_12_Final_JM_ePub.xhtml#_idTextAnchor256)*,
    Installation of Mobile Build Tools*).
  prefs: []
  type: TYPE_NORMAL
- en: 'With Xcode installed on a macOS computer (due to Apple''s licensing restrictions),
    you can build an iOS app using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To build an Android app package (`.apk`) use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have your application bundle or binary file ready to be installed,
    we will see how to simply install your app on your desktop and mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Installing your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you just want to install the desktop app on your computer or development
    devices then you can make use of the helpful `install` subcommand. There are two
    modes for the `install` tool, firstly to install on the current computer, and
    secondly to install on a mobile device that is set up for development.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on your current computer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install your application onto your current computer and make it available
    system-wide, you could simply execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The icon file is the minimum required metadata for installing an app to the
    desktop. If you would like to avoid passing the `-icon` parameter each time, you
    can simply rename the file to `Icon.png` and it will be used by default. Once
    the application is installed, you will see it in your computer's program list
    with appropriate icons showing.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on a mobile device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, we can install apps to a mobile device if it is set up for development.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Development provisioning can be complicated and is out of the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more for iOS devices at [https://help.apple.com/xcode/mac/current/#/dev5a825a1ca](https://help.apple.com/xcode/mac/current/#/dev5a825a1ca).
  prefs: []
  type: TYPE_NORMAL
- en: For Android devices, you can read the documentation at [https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options).
  prefs: []
  type: TYPE_NORMAL
- en: 'With a development-enabled mobile device, apps can be installed using the same
    install command by passing a `-os` parameter as either `android` or `ios`. For
    example, to install a generated `.apk` file on your Android device, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, for the mobile app installation, we needed the additional `appID`
    metadata value. This value is passed into the `package` command that we explored
    in the preceding section. If the package is up to date, this value may not be
    required, but it's usually a good idea to pass it just in case.
  prefs: []
  type: TYPE_NORMAL
- en: And so, you can see that it's simple to install applications on the current
    computer or connected mobile devices. To make this possible, the Fyne tool was
    actually cross-compiling (that means compiling for a different type of computer).
    Let's now look into how that works in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling with ease
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to compile for different operating systems or architectures than
    the current computer is called **cross-compiling**. We saw it used in the previous
    section to package and install a mobile app from a desktop computer. By cross-compiling,
    we can also build applications from one computer for other types of desktop as
    well, for example using Windows to build a macOS application.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways that this can be done. Firstly, we will see how developers
    familiar with platform-specific compilation can use their normal tools to build
    for multiple platforms. After that, we will look at the `fyne-cross` tool and
    how it hides all of the complexity using a Docker image to manage compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Using installed toolchains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When taking the traditional approach to cross-compiling, the computer will require
    an additional compiler **toolchain** for each platform and architecture that the
    developer wants to support. This is what provides the ability to compile the graphics
    and system integration code and typically comprises a C compiler and linker. The
    manner of installation for each toolchain varies depending on the current operating
    system as well as the target toolchain. Details for the various installations
    are available in *, Cross-Compiling*.
  prefs: []
  type: TYPE_NORMAL
- en: With a toolchain installed, the build process is like regular Go cross-compiling
    where you specify `GOOS` and `GOARCH` environment variables to specify the target
    operating system and architecture. However, we additionally must specify `CGO_ENABLED=1`
    (so that C integration is enabled) and also a `CC` environment variable that specifies
    which toolchain compiler to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick summary of the most commonly used compilers and the `CC` environment
    variable to use is as follows (for more information please see *, Cross-Compiling*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 – Downloads, notes, and CC environments for various desktop platforms'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.1 – Downloads, notes, and CC environments for various desktop platforms
  prefs: []
  type: TYPE_NORMAL
- en: With the appropriate compilers and libraries installed, we can continue to the
    build phase. For each of the target operating systems, you will need to run through
    these steps with the correct environment variables set. It is recommended to build
    for one platform and then complete the packaging step for each before changing
    to the next configuration. This is because the release binary for one platform
    may overwrite another (for example, macOS and Linux binaries have the same name
    when compiled).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, we''ll launch a terminal on a macOS computer and will
    compile and package applications for the current macOS system, followed by Windows
    and Linux. You can use any project; the following example uses the package example
    from earlier in this chapter. Let''s see how this goes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we check that the application is building correctly for the current
    system. For our macOS host computer, this will create a `package.app` file, as
    the application we are building is called `package`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before moving on, we should remove any temporary files, and as we are just
    testing we can remove the packaged app we created as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will build for Microsoft Windows. As described in the preceding table,
    this will require the installation of the `mingw-w64` package using Homebrew or
    another package manager. With this installed, we can set the environment variables,
    including `CC` to specify the compiler. The command will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ rm package.exe fyne.syso
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Preparing a Linux build from macOS requires more work. First, you will need
    to install the compiler toolchain, which is the `FiloSottile/musl-cross/musl-cross`
    package in Homebrew. After this, you will need to locate and install suitable
    X11 and OpenGL packages for Linux development (the details here will vary based
    on the Linux computer you are building for; detailed information can be found
    in *, Cross-Compiling*). Once this is all installed, you can execute the Linux
    build much like the Windows command previously, but using the appropriate `CC`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And so, you can see that it is possible to build for all different platforms
    from a single development computer.
  prefs: []
  type: TYPE_NORMAL
- en: However, this involved a lot of package installation and configuration. To avoid
    this complication there is a helpful tool, `fyne-cross`, which packages the required
    files for easier cross-compiling.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the preceding builds, we could also have specified a `GOARCH` variable
    if we wanted to target, for example, a 32-bit computer while building on our 64-bit
    desktop. Likewise, specifying an ARM architecture allows us to compile for Raspberry
    Pi computers.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the iOS and Android targets do not use a traditional toolchain
  prefs: []
  type: TYPE_NORMAL
- en: The ability to build for mobile targets is provided by the platform-specific
    development packages (for example, Xcode or the Android SDK). This means you can
    avoid the manual compiler configuration, but will need to use the `fyne` package
    instead of a traditional `go build` process.
  prefs: []
  type: TYPE_NORMAL
- en: Using the fyne-cross tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fyne-cross` tool was created to provide a simple cross-compiling approach
    for the Fyne toolkit. It utilizes a Docker container to package all of the build
    tools so that the developer does not have to install them all manually, as we
    did in the previous section. You can read more about the project at [https://github.com/fyne-io/fyne-cross](https://github.com/fyne-io/fyne-cross).
  prefs: []
  type: TYPE_NORMAL
- en: Using `fyne-cross`, you can simply specify the *platform* you would like to
    build for on the command line and the tool sets up the development environment
    and builds the package as requested. The `platform` parameter is like the `-os`
    parameter we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to install and use this tool, all we need is our existing Go compiler
    and an installation of `fyne-cross`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have a macOS computer building for Linux (the configuration
    that was complex in the previous section):'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must install Docker. The easiest way to do this is to download and
    run the desktop installer from their website at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).
    Unfortunately, this is not supported on Linux, so you will need to install Docker
    Engine (usually in the package named `docker`) using your package manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run `fyne-cross`, the Docker app must be running. If using Docker Desktop
    you should see the icon in your system tray (see the icon on the left in *Figure
    9.3*). If it is not running, then just open the app using its launch icon (the
    icon on the right in *Figure 9.3*):![Figure 9.3 – The Docker running symbol and
    app icon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B16820.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.3 – The Docker running symbol and app icon
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If running on Linux, then make sure that the service is started according to
    your specific distribution's documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To install the `fyne-cross` tool, we use a version of the `go get` command,
    which will install it along with other Go-based applications in the `~/go/bin/`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we issue the command to run `fyne-cross`. The basic build requires a
    single parameter that is the operating system we want to build for, so for Linux,
    we simply call the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this has completed (the first run will take some time as the Docker image
    needs to be downloaded), we should see that the expected package has been created
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `fyne-cross` tool was able to create the application package
    for a system that was otherwise difficult to compile for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Builds for any operating system and platform in the supported list (at the
    time of writing) include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`darwin/amd64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`darwin/386`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`freebsd/amd64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linux/amd64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linux/386`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linux/arm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linux/arm64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`windows/amd64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`windows/386`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iOS compilation is supported only on macOS computers. You will need to download
    and install Xcode from the Apple App Store. This is a restriction of Apple licenses
    and unfortunately cannot be worked around.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are able to install Docker, this is probably the easier way to build
    for different computers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen the steps involved to take an application from
    running from the source code, through to packaged files ready for distribution.
    We saw the techniques and tools available to help make applications portable and
    how the Fyne toolkit can offer hints of how to improve your UX.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the world of cross-compiling and how to create application
    packages for different operating systems. As illustrated in this chapter, it is
    possible to set up your development computer to build for all supported platforms;
    however, we saw that this can be complicated. The `fyne-cross` tool was introduced
    as a way to solve this complexity and make it trivial to package builds for the
    multitude of potential target systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to distribute these files. We will
    explore how you can share packaged files with beta testers and then how to prepare
    the packages with the certification required for app store and marketplace uploads.
  prefs: []
  type: TYPE_NORMAL
