<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer018">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Getting Started with TinyGo</h1>
			<p>In my opinion, Go is easy to learn, easy to read, and easy to write. The language is not overloaded with fancy features but rather focuses on being concise. The built-in concurrency, fast compile times, high execution performance, and rich standard libraries make a great mix for an awesome language. This is why I want to take you on a journey from very basic high-level Go programs to the depths of microcontrollers utilizing the full power of TinyGo.</p>
			<p>In this chapter, we are going to set up TinyGo and learn how to get code completion to work in VS Code and different editors. After this is done, we will have a look at the Arduino UNO and its technical specifications. We are going to compare TinyGo with Go and talk about what makes TinyGo special compared to other languages on microcontrollers. At the end of this chapter, we will write, compile, deploy, and run our first TinyGo program on a real microcontroller. Having all these topics covered, you will have learned how to write, build, and run programs on microcontrollers. </p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding what TinyGo is</li>
				<li>Setting up TinyGo</li>
				<li>Understanding the IDE integration</li>
				<li>The Arduino UNO</li>
				<li>Checking out the Hello World of things</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>In order to continue, you need to have the following:</p>
			<ul>
				<li>Go must be installed</li>
				<li>GOPATH must be set up</li>
				<li>Git must be installed</li>
				<li>An Arduino Uno, preferably the Rev3 Edition but you can also use other Arduino Uno boards</li>
			</ul>
			<p>You can find all code examples from this chapter in the following GitHub repository: <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01</a></p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3mLFCCJ">https://bit.ly/3mLFCCJ</a></p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Understanding what TinyGo is</h1>
			<p>TinyGo is an independently written <em class="italic">compiler</em>, with its <em class="italic">own runtime implementation</em>. It is intended to be <a id="_idIndexMarker000"/>used for microcontroller programming, <strong class="bold">WebAssembly</strong> (<strong class="bold">WASM</strong>), and CLI tools. TinyGo <a id="_idIndexMarker001"/>heavily makes use of the LLVM infrastructure to optimize and compile code to binaries that a microcontroller can understand. </p>
			<p>The first release of TinyGo (v0.1) was published on February 1, 2019 on GitHub. Since then, the project has quickly implemented lots of features and never stopped adding support for more microcontrollers, sensors, displays, and other devices.</p>
			<p>On February 2, 2020, TinyGo announced that it is now officially a Google-sponsored project. This was a big step for the complete project.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>How TinyGo works</h2>
			<p>The TinyGo <a id="_idIndexMarker002"/>compiler uses a different set of steps than other languages to transform Go source code to machine code. We will not be going into the details though, but let's take a look at an overview of the compiler pipeline:</p>
			<ol>
				<li>We write the Go source code.</li>
				<li>This source <a id="_idIndexMarker003"/>code gets translated to Go <strong class="bold">SSA</strong> (<strong class="bold">Static Single Assignment</strong>).</li>
				<li>The Go SSA is transformed to LLVM IR by the TinyGo compiler package.</li>
				<li>The initialization code in the LLVRM IR is interpreted by the TinyGo <strong class="source-inline">interp</strong> packages. This step optimizes globals, constants, and more.</li>
				<li>The result is then optimized by some LLVM optimization passes (such as <strong class="source-inline">string</strong> to <strong class="source-inline">[]byte</strong> optimization).</li>
				<li>The result is then again optimized by the LLVM optimizer.</li>
				<li>Next, some fixes are done by the compiler package.</li>
				<li>And as the last step, LLVM creates the machine code.</li>
			</ol>
			<p>If this sounds <a id="_idIndexMarker004"/>complicated right now, don't worry – we don't have to take care of this process. TinyGo does all this for us. Now let's have a look at what makes TinyGo special compared to Go.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Comparing TinyGo to Go</h2>
			<p>TinyGo can compile <a id="_idIndexMarker005"/>some, but not all Go programs. Let's have a look at an <a id="_idIndexMarker006"/>example that can be compiled by both. Let's write a small Hello World program in Go—build it and check its size:</p>
			<ol>
				<li value="1">This is the most minimal Hello World program I can currently think of:<p class="source-code">package main</p><p class="source-code">func main() {</p><p class="source-code">    print("Hello World\n")</p><p class="source-code">}</p><p>It does not need an external package such as <strong class="source-inline">fmt</strong> to print the line.</p></li>
				<li>I will be using Go 1.15.2 on an Ubuntu 20.01 operating system. To check your currently installed Go version, use the <strong class="source-inline">go version</strong> command:<p class="source-code"><strong class="bold">$ go version</strong></p><p class="source-code"><strong class="bold">go version go1.15.2 linux/amd64</strong></p></li>
				<li>We build the program using the <strong class="source-inline">go build</strong> command:<p class="source-code"><strong class="bold">$ go build ./ch1/hello-world/</strong></p></li>
				<li>Now we check the size using the <strong class="source-inline">ls –l</strong> command:<p class="source-code"><strong class="bold">$ ls -l</strong></p><p class="source-code"><strong class="bold">-rwxrwxr-x 1 tobias tobias 1231780 Okt  4 19:31 hello-world</strong></p></li>
			</ol>
			<p>So, the program has 1,231,780 bytes, which is 1.23178 megabytes. That is pretty big for a program that consists of just 4 lines of code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">ls</strong> command is not available on all operating systems. If you want to check the sizes for yourself, you need to use tools that are available on your operating system.</p>
			<p class="callout">The size of the binary file may differ when you try it out, as the Go team continues to optimize the compiler. </p>
			<p class="callout">Furthermore, the size of the binary file could differ when building for other operating systems.</p>
			<p>Now let's check what <a id="_idIndexMarker007"/>the size of the same program is, but this time compiled <a id="_idIndexMarker008"/>using TinyGo. As TinyGo does not support building binaries for Windows, I take care of the compiling, so we can just compare the sizes here:</p>
			<ol>
				<li value="1">I used the following command to build the binary:<p class="source-code"><strong class="bold">$ tinygo build -o hello-world-tiny ch1/hello-world/main.go</strong></p><p>The <strong class="source-inline">tinygo build</strong> command has a syntax that is similar to the Go build command. </p></li>
				<li>Then I checked the size using the <strong class="source-inline">ls –l</strong> command, as we did before:<p class="source-code"><strong class="bold">$ ls -l</strong></p><p class="source-code"><strong class="bold">-rwxrwxr-x 1 tobias tobias 1231780 Okt  4 19:31 hello-world</strong></p><p class="source-code"><strong class="bold">-rwxrwxr-x 1 tobias tobias   21152 Okt  4 19:39 hello-world-tiny</strong></p></li>
			</ol>
			<p>We see that the TinyGo version of our Hello World program is only a fraction of the size that the Go compiler emitted. The TinyGo version is only 21,152 bytes, which is about 0.021152 megabytes. The TinyGo program is 58 times smaller as compared to the Go program. This is a huge difference. If you still want to test it out yourself, you can do this after setting up TinyGo.</p>
			<p>We have now learned that TinyGo <a id="_idIndexMarker009"/>can compile some, but not all Go programs. Also, we learned that <a id="_idIndexMarker010"/>programs that are compiled with TinyGo are very small. In the next sections, we'll get to know why TinyGo cannot compile all Go programs and what features TinyGo offers that Go does not offer.</p>
			<h3>Supported language features</h3>
			<p>TinyGo supports a <a id="_idIndexMarker011"/>part of the Go language features, but not everything is supported right now. Goroutines and channels work on most microcontrollers. Reflection is supported for most types. While slices are supported, you may encounter some problems when working with maps. Only certain types of strings, integers, pointers, and structs or arrays that contain the previous types are supported. So, all in all, a good portion of Go is supported in TinyGo.</p>
			<h3>Supported standard packages</h3>
			<p>The biggest part of <a id="_idIndexMarker012"/>the standard library is also supported in TinyGo. As of the time of writing, however, most of the <strong class="source-inline">net</strong> and <strong class="source-inline">crypto</strong> packages still do not compile. That means, if you import them, you will get compile errors.</p>
			<p>You can look up a list of currently supported standard packages here: <a href="https://tinygo.org/lang-support/stdlib/">https://tinygo.org/lang-support/stdlib/</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <em class="italic">yes</em> in the support table does not mean that every function in a package is actually usable in TinyGo. Some functions still could cause compile errors.</p>
			<h3>Volatile operations</h3>
			<p>Volatile operations can be used to read to and write from memory-mapped registers. The values inside these <a id="_idIndexMarker013"/>registers can change between several reads without the knowledge of the compiler. The compiler has no knowledge about the effects of these <a id="_idIndexMarker014"/>operations, hence they are called volatile.</p>
			<p>Go does not have a volatile operator, which is <a id="_idIndexMarker015"/>why TinyGo provides a <strong class="bold">volatile package</strong>. For most cases, we will not need volatile operations, as these are abstracted away by the machine package. </p>
			<h3>Inline assembly</h3>
			<p><strong class="bold">Assembly Language</strong> (<strong class="bold">ASM</strong>) is a language <a id="_idIndexMarker016"/>that is specifically designed for a <a id="_idIndexMarker017"/>certain processor architecture. This happens because assembly depends on the machine code instruction set. The device-specific packages of TinyGo provide assembly packages.</p>
			<p>This enables us to use inline assembly code in our Go programs, which is not possible in standard Go.</p>
			<h3>Heap allocations</h3>
			<p>The <strong class="bold">Heap</strong> is <a id="_idIndexMarker018"/>the part of the <a id="_idIndexMarker019"/>memory where dynamic allocations and deallocations take place during runtime. So, when our application wants to reserve a part of the memory, it talks with the Heap to reserve the memory. That part of the memory will then be marked as being in use. As this space is rather limited on microcontrollers and garbage collection is expensive and slow, TinyGo tries to optimize away Heap allocations. The result is that, often, objects can be statically allocated instead of dynamically. </p>
			<h3>Garbage collection</h3>
			<p>Garbage collection is the <a id="_idIndexMarker020"/>process of freeing memory. So, when your application no longer needs a part of the memory it earlier requested, this memory is marked as unused (free) again. </p>
			<p>For that purpose, TinyGo has implemented its own variant of garbage collection. TinyGo uses a conservative mark/sweep garbage collection, where <a id="_idIndexMarker021"/>conservative means that the <strong class="bold">Garbage Collector</strong> (<strong class="bold">GC</strong>) has no knowledge of what is a pointer and what it is not. The GC process is split into two parts: </p>
			<ul>
				<li><strong class="bold">Mark</strong>: In the marking phase, the gc <a id="_idIndexMarker022"/>marks objects as reachable. </li>
				<li><strong class="bold">Sweep</strong>: In the <a id="_idIndexMarker023"/>sweeping phase, the gc frees memory by marking the areas of unreachable objects as free. These freed areas can then be reused to allocate new objects.</li>
			</ul>
			<p>We do now know what TinyGo is and what differences exist between TinyGo and Go. We have also learned what the Heap, the GC, and volatile packages are. The next logical step is to go on and set up TinyGo, which we will be doing in the next section.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Setting up TinyGo</h1>
			<p>The easiest way to <a id="_idIndexMarker024"/>install TinyGo and all its dependencies is to follow the Quick Start Guides for Linux, macOS, Windows, and Docker at the following link: <a href="https://tinygo.org/getting-started/">https://tinygo.org/getting-started/</a>.</p>
			<p>As these guides cover important parts, I will only cover the Quick Start part for x64-based architectures and only for Debian-based operating systems such as Ubuntu for Linux.</p>
			<p>The first thing to do before we start the setup is to check the latest version of TinyGo. To do so, go to <a href="https://github.com/tinygo-org/tinygo/releases">https://github.com/tinygo-org/tinygo/releases</a> and check for the newest release. Now, keep this information written down somewhere or memorize it as we'll be using it later.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Installing on Linux</h2>
			<p>The following <a id="_idIndexMarker025"/>steps cover installing TinyGo on a Linux derivate, which is <a id="_idIndexMarker026"/>based on Debian:</p>
			<ol>
				<li value="1">We use the following command to download the <strong class="source-inline">deb</strong> package from GitHub and install it using <strong class="source-inline">dpkg</strong>:<p class="source-code"><strong class="bold">wget https://github.com/tinygo-org/tinygo/releases/download/v0.15.0/tinygo_0.15.0_amd64.deb</strong></p><p class="source-code"><strong class="bold">sudo dpkg -i tinygo_0.15.0_amd64.deb</strong></p><p>You can exchange the version in the path and filename with the newest release version you found before.</p></li>
				<li>Now we must add TinyGo to <strong class="source-inline">GOPATH</strong>. You can use the following command:<p class="source-code"><strong class="bold">export PATH=$PATH:/usr/local/tinygo/bin</strong></p><p>You can also extend <strong class="source-inline">GOPATH</strong> by editing your <strong class="source-inline">.profile</strong> or <strong class="source-inline">.netrc</strong> file.</p></li>
				<li>The next step is to verify the installation. Use the <strong class="source-inline">tinygo version</strong> command to verify that TinyGo has been successfully installed:<p class="source-code"><strong class="bold">$ tinygo version</strong></p><p class="source-code"><strong class="bold">tinygo version 0.15.0 linux/amd64 (using go version go1.15.2 and LLVM version 10.0.1)</strong></p></li>
				<li>AVR dependencies: As we are going to work with an Arduino UNO in the first chapters, we <a id="_idIndexMarker027"/>need to install some additional dependencies. We do <a id="_idIndexMarker028"/>so by using the following commands:<p class="source-code"><strong class="bold">sudo apt-get install gcc-avr</strong></p><p class="source-code"><strong class="bold">sudo apt-get install avr-libc</strong></p><p class="source-code"><strong class="bold">sudo apt-get install avrdude</strong></p></li>
			</ol>
			<p>After installing these dependencies, we can now compile on AVR-based boards such as the Arduino UNO.</p>
			<p>If you are using Fedora, Arch Linux, or other distributions, please follow the installation guide: <a href="https://tinygo.org/getting-started/linux/">https://tinygo.org/getting-started/linux/</a>.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Installing on Windows</h2>
			<p>In this <a id="_idIndexMarker029"/>section, we are going to learn how to install TinyGo on Windows. After <a id="_idIndexMarker030"/>this section, we will have also learned how to install dependencies, which are needed to flash the Arduino UNO.</p>
			<p class="callout-heading">Very important note</p>
			<p class="callout">You cannot create Windows binary programs using TinyGo. You can still compile and flash programs for microcontroller and WebAssembly targets.</p>
			<p class="callout">You may want to directly install and <a id="_idIndexMarker031"/>use TinyGo inside the <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>). The WSL is the way I recommend for Windows users.</p>
			<p>To install TinyGo on Windows without using the WSL, I recommend using Scoop, a command-line installer for Windows. Make sure that you have PowerShell 5 (or later) and .NET Framework 4.5 (or later) installed. To do so, please follow these steps: </p>
			<ol>
				<li value="1">Enable PowerShell for your current user account using the following command:<p class="source-code"><strong class="bold">Set-ExecutionPolicy RemoteSigned -scope CurrentUser</strong></p></li>
				<li>Now run the following command to download Scoop:<p class="source-code"><strong class="bold">iwr -useb get.scoop.sh | iex</strong></p></li>
				<li>You <a id="_idIndexMarker032"/>can install TinyGo by <a id="_idIndexMarker033"/>using the following command:<p class="source-code"><strong class="bold">scoop install tinygo</strong></p></li>
				<li>Now to verify the installation was successful, use the following command:<p class="source-code"><strong class="bold">tinygo version</strong></p><p>The output should look like the following: </p><p class="source-code"><strong class="bold">tinygo version 0.15.0 windows/amd64 (using go version go1.15.3 and LLVM version 10.0.1)</strong></p><p>The actual TinyGo and Go version might differ.</p></li>
				<li>AVR dependencies: In order to be able to compile and flash programs for the Arduino UNO, we need to have an AVR 8-bit toolchain installed. You can find a download here: <a href="https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers">https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers</a>.<p>Extend your <strong class="source-inline">%PATH%</strong> and make sure that the <strong class="source-inline">bin</strong> folder is included:</p></li>
				<li>Next, download and install GNU Make for Windows. You can find GNU Make here: <a href="http://gnuwin32.sourceforge.net/packages/make.htm">http://gnuwin32.sourceforge.net/packages/make.htm</a>.</li>
				<li>As the last step, you need to download and install <strong class="source-inline">avrdude</strong>. The <strong class="source-inline">avrdude</strong> EXE also must be inside your <strong class="source-inline">%PATH%</strong>. You can download AVR Dude here: <a href="http://download.savannah.gnu.org/releases/avrdude/">http://download.savannah.gnu.org/releases/avrdude/</a>. The file you are looking for is called <strong class="source-inline">avrdude-6.3-mingw32.zip</strong>.</li>
			</ol>
			<p>If you encounter any <a id="_idIndexMarker034"/>problems regarding the <strong class="source-inline">avr</strong> setup or don't know how to configure environment variables, you <a id="_idIndexMarker035"/>may want to check out the following guide: <a href="https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html">https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html</a>.</p>
			<p class="callout-heading">WSL installation</p>
			<p class="callout">It is also possible to install <a id="_idIndexMarker036"/>TinyGo directly on the <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>). Just follow the Linux section to do that.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Installing on macOS</h2>
			<p>Installation <a id="_idIndexMarker037"/>on macOS is straightforward. Let's take a quick look <a id="_idIndexMarker038"/>at the steps:</p>
			<ol>
				<li value="1">We are going to use Homebrew to <strong class="source-inline">install tinygo</strong>. Just use the following two commands:<p class="source-code"><strong class="bold">brew tap tinygo-org/tools</strong></p><p class="source-code"><strong class="bold">brew install tinygo</strong></p></li>
				<li>Simply run the <strong class="source-inline">tinygo version</strong> command to verify the installation:<p class="source-code"><strong class="bold">$ tinygo version</strong></p><p class="source-code"><strong class="bold">tinygo version 0.15.0 darwin/amd64 (using go version go1.15 and LLVM version 10.0.1)</strong></p></li>
				<li>Run the following commands to install the additional requirements needed to compile programs <a id="_idIndexMarker039"/>for AVR-based microcontrollers <a id="_idIndexMarker040"/>such as the Arduino UNO, which we are going to use in the first few chapters of the book:<p class="source-code"><strong class="bold">brew tap osx-cross/avr</strong></p><p class="source-code"><strong class="bold">brew install avr-gcc</strong></p><p class="source-code"><strong class="bold">brew install avrdude</strong></p></li>
			</ol>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Installing on Docker</h2>
			<p>It is <a id="_idIndexMarker041"/>possible to directly use a Docker image to compile our programs. However, it is <a id="_idIndexMarker042"/>not possible to flash the programs using the Docker image. </p>
			<p>Simply download the image using the following:</p>
			<p class="source-code">docker pull tinygo/tinygo:0.15.0</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The actual TinyGo version might differ. Use the newest TinyGo version from the check we did when we started the section.</p>
			<p>Here is an example call to build a program:</p>
			<p class="source-code">docker run -v $GOPATH:/go -e "GOPATH=/go" tinygo/tinygo:0.15.0 tinygo build -o /go/src/github.com/myuser/myrepo/wasm.wasm -target wasm --no-debug /go/src/github.com/myuser/myrepo/wasm-main.go</p>
			<p>We have now successfully set up TinyGo and installed all additional requirements to compile and flash programs to the Arduino UNO microcontroller. Also, everything we need for WebAssembly is now set up. The next step is to set up IDE integration before we start writing our first program for a microcontroller.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Understanding IDE integration</h1>
			<p>Having a properly set <a id="_idIndexMarker043"/>up IDE is truly a blessing as we benefit from its features of code completion, functional linting, and so on. This way, we do not have to investigate the source code or documentation for every function we want to call. </p>
			<p>In this section, we will look at the process of integrating TinyGo into VS Code, Goland, and other editors. This enables us to choose whatever editor we prefer to use.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>VS Code integration</h2>
			<p>VS Code offers an <a id="_idIndexMarker044"/>extension system, which makes it easy to <a id="_idIndexMarker045"/>integrate the Go and TinyGo toolset into the IDE. We are going to install the Go Extension, which offers support for the Go programming language. Afterward, we are going to install the TinyGo extension, which brings TinyGo support.</p>
			<h3>The Go extension</h3>
			<p>We install the Go <a id="_idIndexMarker046"/>extension using the <strong class="bold">Extensions</strong> view using the following steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Extensions</strong> view either by clicking on the <strong class="bold">Extensions</strong> icon or pressing <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">X</em>.</li>
				<li>Search for <strong class="bold">Go</strong>.</li>
				<li>Select the first entry in the list, which is called <strong class="bold">Go</strong> and is from the Go team at Google.</li>
				<li>Click on the <strong class="bold">Install</strong> button, as seen in the following screenshot:<div id="_idContainer005" class="IMG---Figure"><img src="Images/Figure_1.1_B16555.jpg" alt="Figure 1.1 – Installation from the Extensions view&#13;&#10;" width="1295" height="485"/></div><p class="figure-caption">Figure 1.1 – Installation from the Extensions view</p></li>
				<li>After installing the extension for the first time, you might get prompted to install more <a id="_idIndexMarker047"/>dependencies. Do so by clicking on the <strong class="bold">Install</strong> button. If you do not get prompt, you can also install all dependencies by hitting <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">P</em> and entering the following command:<p class="source-code"><strong class="bold">Go: install</strong></p></li>
				<li>Select the <strong class="bold">Go: Install/Update Tools</strong> command and hit <em class="italic">Enter</em>:<div id="_idContainer006" class="IMG---Figure"><img src="Images/Figure_1.2_B16555.jpg" alt="Figure 1.2 – Go: Install/Update Tools command to execute&#13;&#10;" width="1050" height="489"/></div><p class="figure-caption">Figure 1.2 – Go: Install/Update Tools command to execute</p></li>
				<li>Now select all dependencies by checking the box on the left side and click <strong class="bold">OK</strong>:<div id="_idContainer007" class="IMG---Figure"><img src="Images/Figure_1.3_B16555.jpg" alt="Figure 1.3 – Selection of all dependencies&#13;&#10;" width="1051" height="705"/></div><p class="figure-caption">Figure 1.3 – Selection of all dependencies</p></li>
				<li>VS Code will now <a id="_idIndexMarker048"/>install all dependencies, and it should print the following message when done:<p class="source-code"><strong class="bold">All tools successfully installed. You are ready to Go :).</strong></p></li>
			</ol>
			<p>Next, we'll see the TinyGo integration in VS Code.</p>
			<h3>The TinyGo extension</h3>
			<p>TinyGo integration in <a id="_idIndexMarker049"/>VS Code is straightforward as there is a TinyGo extension that we simply need to install. Let's quickly go through the steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Extensions</strong> view either by clicking on the <strong class="bold">Extensions</strong> icon or pressing <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">X</em>.</li>
				<li>Search for <strong class="bold">TinyGo</strong>.</li>
				<li>Select the first entry in the list, which is called <strong class="bold">TinyGo</strong> and is from the TinyGo team.</li>
				<li>Click on the <strong class="bold">Install</strong> button, as seen in the following screenshot:<div id="_idContainer008" class="IMG---Figure"><img src="Images/Figure_1.4_B16555.jpg" alt="Figure 1.4 – Extensions view showing the TinyGo extension&#13;&#10;" width="1059" height="539"/></div><p class="figure-caption">Figure 1.4 – Extensions view showing the TinyGo extension</p></li>
				<li>We are not done <a id="_idIndexMarker050"/>with installing the extension. We need to use another command to configure the target we want to build for. Hit <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">P</em>, type <strong class="source-inline">TinyGo target</strong>, and hit <em class="italic">Enter</em>. </li>
				<li>Now search for <strong class="source-inline">arduino</strong> and hit <em class="italic">Enter</em>, as we see in the following screenshot:<div id="_idContainer009" class="IMG---Figure"><img src="Images/Figure_1.5_B16555.jpg" alt="Figure 1.5 – The target selection popup&#13;&#10;" width="295" height="494"/></div><p class="figure-caption">Figure 1.5 – The target selection popup</p></li>
				<li>VS Code will open a popup telling you that it needs to reload the window. Do so by clicking on <strong class="bold">Reload</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="Images/Figure_1.6_B16555.jpg" alt="Figure 1.6 – Popup asking to reload the window&#13;&#10;" width="575" height="143"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Popup asking to reload the window</p>
			<p>Okay, we now have <a id="_idIndexMarker051"/>the extension installed and have selected a target. But what does it do internally? The only function of this extension is to set the <strong class="source-inline">go.toolsEnvVars</strong> variable in <strong class="source-inline">vs code settings.json</strong> of your current project.</p>
			<p>This could look like the following example:</p>
			<p class="source-code">{</p>
			<p class="source-code">   "go.toolsEnvVars": {</p>
			<p class="source-code">     "GOROOT": "/home/user/.cache/tinygo/goroot-go1.14-f930d5b</p>
			<p class="source-code">         5f36579e8cbf1f-syscall",</p>
			<p class="source-code">     "GOFLAGS": "-tags=cortexm,baremetal,linux,arm,nrf51822,</p>
			<p class="source-code">         nrf51,nrf,microbit,tinygo,gc.conservative,scheduler.</p>
			<p class="source-code">         tasks"</p>
			<p class="source-code"> }</p>
			<p class="source-code">}</p>
			<p>Sometimes a popup similar to the one in the following screenshot will appear. Do not click on <strong class="bold">Update tools</strong>; just close it.</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="Images/Figure_1.7_B16555.jpg" alt="Figure 1.7 – Popup asking to update tools&#13;&#10;" width="569" height="236"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Popup asking to update tools</p>
			<p>If you are <a id="_idIndexMarker052"/>using VS Code, congratulations, you are done with the setup and are ready to go! The next sections are going to explain how to set up the IDE integration in other editors.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>General IDE integration</h2>
			<p>You may wonder, how <a id="_idIndexMarker053"/>does IDE integration work with TinyGo? Well, we simply have to configure the standard Go tooling, especially the <strong class="bold">gopls language</strong> server.</p>
			<p>TinyGo has its own implementation of the standard libraries and also provides additional libraries, such as the machine package. The <a id="_idIndexMarker054"/>gopls language server needs to know where to look for these packages. That is why we need to set a <strong class="source-inline">GOROOT</strong> for this project. </p>
			<p>TinyGo makes heavy use of compiler flags. These flags are used during compile time to determine which files must be included in the build, as we see in the following screenshot:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="Images/Figure_1.8_B16555.jpg" alt="Figure 1.8 – The board_arduino.go file from the TinyGo source code showing a build flag&#13;&#10;" width="472" height="198"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – The board_arduino.go file from the TinyGo source code showing a build flag</p>
			<p>So basically, we integrate TinyGo into an IDE by locally setting these environment variables.</p>
			<p>We do not have to guess the correct values for <strong class="source-inline">GOROOT</strong> and <strong class="source-inline">GOFLAGS</strong>. TinyGo provides a command <a id="_idIndexMarker055"/>for that purpose. Let's say we want to set the correct flags for an Arduino, we can find out by using the following command:</p>
			<p class="source-code">tinygo info arduino</p>
			<p>This will print the following result:</p>
			<p class="source-code">LLVM triple:       avr-unknown-unknown</p>
			<p class="source-code">GOOS:              linux</p>
			<p class="source-code">GOARCH:            arm</p>
			<p class="source-code">build tags:        avr baremetal linux arm atmega328p atmega avr5 arduino tinygo gc.conservative scheduler.none</p>
			<p class="source-code">garbage collector: conservative</p>
			<p class="source-code">scheduler:         none</p>
			<p class="source-code">cached GOROOT:     /home/tobias/.cache/tinygo/goroot-go1.15.2-bb8dfc1625dfff39df9d5a78a474eb93c273cccfe3243ee4e33bafef0dcd97fe-syscall</p>
			<p>The important parts of the output are <strong class="source-inline">build tags</strong> and <strong class="source-inline">cached GOROOT</strong>.</p>
			<p>As we now know where to <a id="_idIndexMarker056"/>find the needed information, we can go ahead and configure any IDE we want to use.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Setting up Goland </h2>
			<p>As we have <a id="_idIndexMarker057"/>now learned that we must set a <strong class="source-inline">GOROOT</strong> and <strong class="source-inline">build</strong> tags, we <a id="_idIndexMarker058"/>can also configure the integration in Goland.</p>
			<p>Set <strong class="bold">GOROOT</strong> to the cached <strong class="source-inline">GOROOT</strong> from the <strong class="source-inline">tinygo info</strong> command, as seen in the following screenshot:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="Images/Figure_1.9_B16555.jpg" alt="Figure 1.9 – GOROOT configuration in Goland&#13;&#10;" width="1007" height="207"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – GOROOT configuration in Goland</p>
			<p>The next step is to set the <strong class="source-inline">build</strong> tags. You can find them under <strong class="bold">Build Tags &amp; Vendoring</strong>.<strong class="bold"> </strong>Add the tags into the <strong class="bold">Custom tags</strong> field:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="Images/Figure_1.10_B16555.jpg" alt=" Figure 1.10 – Custom tags configuration in Goland&#13;&#10;" width="743" height="287"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 1.10 – Custom tags configuration in Goland</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You must manually change <strong class="bold">Custom tags</strong> each time you want to program for another microcontroller. </p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Integrating any editor</h2>
			<p>If you have the <a id="_idIndexMarker059"/>standard Go tolling installed, you can use any other editor such as Vim or Nano so you can get IDE support. As other editors might lack configuration files, we can work around this fact by passing them the environment variables at the moment we start them.</p>
			<p>In the following example, we start a VS Code instance by first setting environment variables and then starting VS Code:</p>
			<p class="source-code"> export GOFLAGS=-tags=avr,baremetal,linux,arm,atmega328p,atmega,avr5,arduino,tinygo,gc.conservative,scheduler.none; code</p>
			<p>You can exchange the code call to any other program such as <strong class="source-inline">vim</strong> or <strong class="source-inline">nano</strong>. On Windows systems, the call might look a little bit different.</p>
			<p>As we now know how to configure any IDE for the use of TinyGo, we will move on to learn about the Arduino UNO.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>The Arduino UNO</h1>
			<p>The Arduino UNO is one <a id="_idIndexMarker060"/>of the most popular boards out there. It is powered by an 8-bit ATmega328P microcontroller, and as of the writing of this book, there are lots of derivates from the original Arduino UNO boards. Let's get to know it better in the following subsections.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Getting to know the technical specifications</h2>
			<p>As you can see in <a id="_idIndexMarker061"/>the following table, the ATmega328P has only 16 MHz and 32 KB Flash memory. Standard Go produces a Hello World program of about 1.2 MB, which would not even fit on this microcontroller. So, we are working with very limited hardware here, but you will see that this is sufficient to build amazing projects.</p>
			<p>Here is a brief look at the technical specs of the Arduino UNO:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="Images/Table_1.1_B16555.jpg" alt="Table 1.1 – Technical specifications&#13;&#10;" width="1221" height="756"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.1 – Technical specifications</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Consider the DC <a id="_idIndexMarker062"/>current per I/O pin of 20 mA as an upper limit. You should not exceed this limit to prevent damaging your microcontroller.</p>
			<p>Let's have a look at the pinout next.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Exploring pinout</h2>
			<p>A <strong class="bold">Pinout</strong> is basically a map <a id="_idIndexMarker063"/>of the pins. We are going to use the <a id="_idIndexMarker064"/>descriptions of these pins in all projects that we build with the Arduino UNO. We will need it to correctly wire our components.</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="Images/Figure_1.11_B16555.jpg" alt="Figure 1.11 – Arduino UNO REV3 pinout&#13;&#10;" width="927" height="933"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Arduino UNO REV3 pinout</p>
			<p>As we now <a id="_idIndexMarker065"/>have learned some basic information about the <a id="_idIndexMarker066"/>Arduino UNO, let's go on and write our first program.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Checking out the Hello World of Things</h1>
			<p>A Hello World program is the typical way to start the journey in a new programming language. A Hello World <a id="_idIndexMarker067"/>program on a microcontroller looks a bit different compared to a normal Hello World program. We are going to write a Hello World program to let the built-in LED blink. Let's get started!</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Getting the requirements ready</h2>
			<p>To get started with <a id="_idIndexMarker068"/>our program, we need the following:</p>
			<ul>
				<li>An Arduino UNO</li>
				<li>One USB cable to connect it to your computer</li>
			</ul>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Preparing the project</h2>
			<p>Follow <a id="_idIndexMarker069"/>these steps closely for your project:</p>
			<ol>
				<li value="1">Create a new folder named <strong class="source-inline">ch1</strong> in the root of your project. </li>
				<li>Inside the folder, we need to create a folder named <strong class="source-inline">hello-world-of-things</strong> and inside it, we are going to create a new <strong class="source-inline">main.go</strong> file. </li>
				<li>Your structure should now look like the following:</li>
			</ol>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="Images/Figure_1.12_B16555.jpg" alt="Figure 1.12 – The project structure&#13;&#10;" width="359" height="67"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – The project structure</p>
			<p>As we have now prepared our project, we can go on and write our first program. </p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Programming the microcontroller</h2>
			<p>We are going <a id="_idIndexMarker070"/>to let the onboard LED blink. It is the easiest possible start for us. The example we are using is inspired by the <em class="italic">Blinky example</em> from the TinyGo source code, which is also used as a Hello World of Things showcase. Let's go through each step carefully:</p>
			<ol>
				<li value="1">Declare the <strong class="source-inline">main</strong> package:<p class="source-code">package main</p></li>
				<li>Import the packages <strong class="source-inline">machine</strong> and <strong class="source-inline">time</strong>:<p class="source-code">import (</p><p class="source-code">    "machine"</p><p class="source-code">    "time"</p><p class="source-code">)</p></li>
				<li>Add a <strong class="source-inline">main</strong> function:<p class="source-code">func main() {</p></li>
				<li>Initialize a variable named <strong class="source-inline">led</strong> with the value <strong class="source-inline">machine.LED</strong>:<p class="source-code">    led := machine.LED</p></li>
				<li>Configure the <strong class="source-inline">led</strong> pin as the output pin:<p class="source-code">    led.Configure(machine.PinConfig{Mode: machine.</p><p class="source-code">    PinOutput})</p></li>
				<li>Declare an endless loop:<p class="source-code">    for {</p></li>
				<li>Set the <strong class="source-inline">led</strong> to <strong class="source-inline">Low</strong> so that no voltage is given on the LED:<p class="source-code">    led.Low()</p></li>
				<li>Set <strong class="source-inline">sleep</strong> for <strong class="source-inline">300</strong> milliseconds, that is the time the LED is off:<p class="source-code">    time.Sleep(time.Millisecond * 300)</p></li>
				<li>Set the <strong class="source-inline">led</strong> to <strong class="source-inline">High</strong> so a voltage is given to the LED to make it shine:<p class="source-code">    led.High()</p></li>
				<li>Set <strong class="source-inline">Sleep</strong> for <strong class="source-inline">300</strong> milliseconds, which is the amount of time the LED is on for:<p class="source-code">    time.Sleep(time.Millisecond * 300)</p></li>
				<li>Close the <strong class="source-inline">for</strong> loop:<p class="source-code">}</p></li>
				<li>Closing braces for the <strong class="source-inline">main</strong> function:<p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">machine</strong> package provides constants for the pin mapping and provides some more functions that are directly related to the used microcontroller. </p>
			<p>We must wait for a <a id="_idIndexMarker071"/>certain amount of time between giving voltage to the LED and taking it off again, so we can see the blinking. </p>
			<p>Configuring a pin as output means that we tell the microcontroller that we are only going to send signals using this pin. We can also configure a pin as input, which enables us to read the state from the pin.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Flashing the program</h2>
			<p>Flashing the program is <a id="_idIndexMarker072"/>a simple command, if you are on Linux, macOS, or are using Windows WSL. </p>
			<p>Simply connect your Arduino UNO to any USB port and execute the following command:</p>
			<p class="source-code">tinygo flash --target=arduino ch1/hello-world-of-things/main.go</p>
			<p>The <strong class="source-inline">tinygo flash</strong> command needs at least the following parameters:</p>
			<ul>
				<li><strong class="source-inline">--target</strong>, which sets the microcontroller to flash</li>
				<li>The path to the <strong class="source-inline">main.go</strong> file</li>
			</ul>
			<p>Your output should look like the following:</p>
			<p class="source-code">avrdude: AVR device initialized and ready to accept instructions </p>
			<p class="source-code">Reading | ################################################## | 100% 0.00s </p>
			<p class="source-code">avrdude: Device signature = 0x1e950f (probably m328p)</p>
			<p class="source-code">avrdude: NOTE: "flash" memory has been specified, an erase cycle will be performed</p>
			<p class="source-code">         To disable this feature, specify the -D option.</p>
			<p class="source-code">avrdude: erasing chip</p>
			<p class="source-code">avrdude: reading input file "/tmp/tinygo208327574/main.hex"</p>
			<p class="source-code">avrdude: writing flash (558 bytes): </p>
			<p class="source-code">Writing | ################################################## | 100% 0.10s </p>
			<p class="source-code">avrdude: 558 bytes of flash written</p>
			<p class="source-code">avrdude: verifying flash memory against /tmp/tinygo208327574/main.hex:</p>
			<p class="source-code">avrdude: load data flash data from input file /tmp/tinygo208327574/main.hex:</p>
			<p class="source-code">avrdude: input file /tmp/tinygo208327574/main.hex contains 558 bytes</p>
			<p class="source-code">avrdude: reading on-chip flash data: </p>
			<p class="source-code">Reading | ################################################## | 100% 0.08s </p>
			<p class="source-code">avrdude: verifying ...</p>
			<p class="source-code">avrdude: 558 bytes of flash verified </p>
			<p class="source-code">avrdude done.  Thank you.</p>
			<p>As you can see, in my example, the code flashed onto the Arduino UNO is only using 558 bytes of memory.</p>
			<p>Congratulations, you <a id="_idIndexMarker073"/>have successfully written, built, and flashed your first program onto an Arduino UNO using TinyGo. </p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Using TinyGo Playground</h2>
			<p>You don't have an <a id="_idIndexMarker074"/>Arduino UNO right now? You can test the code using <strong class="bold">TinyGo Playground</strong>. TinyGo Playground <a id="_idIndexMarker075"/>makes use of WebAssembly to emulate the behavior of a small number of boards such as the Arduino Nano IoT 33 and the Arduino UNO. <a id="_idTextAnchor038"/>It can also compile programs for the Arduino Nano IoT 33. But please keep in mind that the behavior in the TinyGo Playground might differ from real hardware.</p>
			<p>You can find the <a id="_idIndexMarker076"/>TinyGo Playground at <a href="https://play.tinygo.org/">https://play.tinygo.org/</a>.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Summary</h1>
			<p>We have learned what TinyGo actually is, how it differs from standard Go, we have acquired basic knowledge about the Arduino UNO itself, how to set up TinyGo, how to set up IDE integration, and finally, wrote and flashed our first program onto real hardware and made an LED blink with our code. Isn't that an interesting start?</p>
			<p>We are going to build a traffic light controller system in the next chapter. </p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/>Questions</h1>
			<ol>
				<li value="1">Which command can be used to find out the needed environment variable values for the IDE integration?</li>
				<li>Which command can be used to flash a program onto a microcontroller?</li>
				<li>Why do we have to sleep a certain amount of time when giving voltage or taking voltage away from the LED?</li>
				<li>How would you let the LED blink S-O-S in morse code?</li>
			</ol>
		</div>
	</div></body></html>