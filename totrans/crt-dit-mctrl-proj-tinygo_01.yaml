- en: '*Chapter 1*: Getting Started with TinyGo'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, Go is easy to learn, easy to read, and easy to write. The language
    is not overloaded with fancy features but rather focuses on being concise. The
    built-in concurrency, fast compile times, high execution performance, and rich
    standard libraries make a great mix for an awesome language. This is why I want
    to take you on a journey from very basic high-level Go programs to the depths
    of microcontrollers utilizing the full power of TinyGo.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to set up TinyGo and learn how to get code completion
    to work in VS Code and different editors. After this is done, we will have a look
    at the Arduino UNO and its technical specifications. We are going to compare TinyGo
    with Go and talk about what makes TinyGo special compared to other languages on
    microcontrollers. At the end of this chapter, we will write, compile, deploy,
    and run our first TinyGo program on a real microcontroller. Having all these topics
    covered, you will have learned how to write, build, and run programs on microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what TinyGo is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up TinyGo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the IDE integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino UNO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking out the Hello World of things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to continue, you need to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go must be installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GOPATH must be set up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git must be installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arduino Uno, preferably the Rev3 Edition but you can also use other Arduino
    Uno boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find all code examples from this chapter in the following GitHub repository:
    [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3mLFCCJ](https://bit.ly/3mLFCCJ)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what TinyGo is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TinyGo is an independently written *compiler*, with its *own runtime implementation*.
    It is intended to be used for microcontroller programming, **WebAssembly** (**WASM**),
    and CLI tools. TinyGo heavily makes use of the LLVM infrastructure to optimize
    and compile code to binaries that a microcontroller can understand.
  prefs: []
  type: TYPE_NORMAL
- en: The first release of TinyGo (v0.1) was published on February 1, 2019 on GitHub.
    Since then, the project has quickly implemented lots of features and never stopped
    adding support for more microcontrollers, sensors, displays, and other devices.
  prefs: []
  type: TYPE_NORMAL
- en: On February 2, 2020, TinyGo announced that it is now officially a Google-sponsored
    project. This was a big step for the complete project.
  prefs: []
  type: TYPE_NORMAL
- en: How TinyGo works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TinyGo compiler uses a different set of steps than other languages to transform
    Go source code to machine code. We will not be going into the details though,
    but let''s take a look at an overview of the compiler pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: We write the Go source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This source code gets translated to Go **SSA** (**Static Single Assignment**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Go SSA is transformed to LLVM IR by the TinyGo compiler package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The initialization code in the LLVRM IR is interpreted by the TinyGo `interp`
    packages. This step optimizes globals, constants, and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is then optimized by some LLVM optimization passes (such as `string`
    to `[]byte` optimization).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is then again optimized by the LLVM optimizer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, some fixes are done by the compiler package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And as the last step, LLVM creates the machine code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this sounds complicated right now, don't worry – we don't have to take care
    of this process. TinyGo does all this for us. Now let's have a look at what makes
    TinyGo special compared to Go.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing TinyGo to Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TinyGo can compile some, but not all Go programs. Let''s have a look at an
    example that can be compiled by both. Let''s write a small Hello World program
    in Go—build it and check its size:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the most minimal Hello World program I can currently think of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It does not need an external package such as `fmt` to print the line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'I will be using Go 1.15.2 on an Ubuntu 20.01 operating system. To check your
    currently installed Go version, use the `go version` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We build the program using the `go build` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we check the size using the `ls –l` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, the program has 1,231,780 bytes, which is 1.23178 megabytes. That is pretty
    big for a program that consists of just 4 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `ls` command is not available on all operating systems. If you want to check
    the sizes for yourself, you need to use tools that are available on your operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the binary file may differ when you try it out, as the Go team continues
    to optimize the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the size of the binary file could differ when building for other
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check what the size of the same program is, but this time compiled
    using TinyGo. As TinyGo does not support building binaries for Windows, I take
    care of the compiling, so we can just compare the sizes here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the following command to build the binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then I checked the size using the `ls –l` command, as we did before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that the TinyGo version of our Hello World program is only a fraction
    of the size that the Go compiler emitted. The TinyGo version is only 21,152 bytes,
    which is about 0.021152 megabytes. The TinyGo program is 58 times smaller as compared
    to the Go program. This is a huge difference. If you still want to test it out
    yourself, you can do this after setting up TinyGo.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned that TinyGo can compile some, but not all Go programs. Also,
    we learned that programs that are compiled with TinyGo are very small. In the
    next sections, we'll get to know why TinyGo cannot compile all Go programs and
    what features TinyGo offers that Go does not offer.
  prefs: []
  type: TYPE_NORMAL
- en: Supported language features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TinyGo supports a part of the Go language features, but not everything is supported
    right now. Goroutines and channels work on most microcontrollers. Reflection is
    supported for most types. While slices are supported, you may encounter some problems
    when working with maps. Only certain types of strings, integers, pointers, and
    structs or arrays that contain the previous types are supported. So, all in all,
    a good portion of Go is supported in TinyGo.
  prefs: []
  type: TYPE_NORMAL
- en: Supported standard packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest part of the standard library is also supported in TinyGo. As of
    the time of writing, however, most of the `net` and `crypto` packages still do
    not compile. That means, if you import them, you will get compile errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can look up a list of currently supported standard packages here: [https://tinygo.org/lang-support/stdlib/](https://tinygo.org/lang-support/stdlib/).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A *yes* in the support table does not mean that every function in a package
    is actually usable in TinyGo. Some functions still could cause compile errors.
  prefs: []
  type: TYPE_NORMAL
- en: Volatile operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Volatile operations can be used to read to and write from memory-mapped registers.
    The values inside these registers can change between several reads without the
    knowledge of the compiler. The compiler has no knowledge about the effects of
    these operations, hence they are called volatile.
  prefs: []
  type: TYPE_NORMAL
- en: Go does not have a volatile operator, which is why TinyGo provides a **volatile
    package**. For most cases, we will not need volatile operations, as these are
    abstracted away by the machine package.
  prefs: []
  type: TYPE_NORMAL
- en: Inline assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Assembly Language** (**ASM**) is a language that is specifically designed
    for a certain processor architecture. This happens because assembly depends on
    the machine code instruction set. The device-specific packages of TinyGo provide
    assembly packages.'
  prefs: []
  type: TYPE_NORMAL
- en: This enables us to use inline assembly code in our Go programs, which is not
    possible in standard Go.
  prefs: []
  type: TYPE_NORMAL
- en: Heap allocations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Heap** is the part of the memory where dynamic allocations and deallocations
    take place during runtime. So, when our application wants to reserve a part of
    the memory, it talks with the Heap to reserve the memory. That part of the memory
    will then be marked as being in use. As this space is rather limited on microcontrollers
    and garbage collection is expensive and slow, TinyGo tries to optimize away Heap
    allocations. The result is that, often, objects can be statically allocated instead
    of dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Garbage collection is the process of freeing memory. So, when your application
    no longer needs a part of the memory it earlier requested, this memory is marked
    as unused (free) again.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that purpose, TinyGo has implemented its own variant of garbage collection.
    TinyGo uses a conservative mark/sweep garbage collection, where conservative means
    that the **Garbage Collector** (**GC**) has no knowledge of what is a pointer
    and what it is not. The GC process is split into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mark**: In the marking phase, the gc marks objects as reachable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sweep**: In the sweeping phase, the gc frees memory by marking the areas
    of unreachable objects as free. These freed areas can then be reused to allocate
    new objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do now know what TinyGo is and what differences exist between TinyGo and
    Go. We have also learned what the Heap, the GC, and volatile packages are. The
    next logical step is to go on and set up TinyGo, which we will be doing in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up TinyGo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to install TinyGo and all its dependencies is to follow the
    Quick Start Guides for Linux, macOS, Windows, and Docker at the following link:
    [https://tinygo.org/getting-started/](https://tinygo.org/getting-started/).'
  prefs: []
  type: TYPE_NORMAL
- en: As these guides cover important parts, I will only cover the Quick Start part
    for x64-based architectures and only for Debian-based operating systems such as
    Ubuntu for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do before we start the setup is to check the latest version
    of TinyGo. To do so, go to [https://github.com/tinygo-org/tinygo/releases](https://github.com/tinygo-org/tinygo/releases)
    and check for the newest release. Now, keep this information written down somewhere
    or memorize it as we'll be using it later.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps cover installing TinyGo on a Linux derivate, which is based
    on Debian:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following command to download the `deb` package from GitHub and
    install it using `dpkg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can exchange the version in the path and filename with the newest release
    version you found before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we must add TinyGo to `GOPATH`. You can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to verify the installation. Use the `tinygo version` command
    to verify that TinyGo has been successfully installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'AVR dependencies: As we are going to work with an Arduino UNO in the first
    chapters, we need to install some additional dependencies. We do so by using the
    following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After installing these dependencies, we can now compile on AVR-based boards
    such as the Arduino UNO.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Fedora, Arch Linux, or other distributions, please follow
    the installation guide: [https://tinygo.org/getting-started/linux/](https://tinygo.org/getting-started/linux/).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to install TinyGo on Windows. After
    this section, we will have also learned how to install dependencies, which are
    needed to flash the Arduino UNO.
  prefs: []
  type: TYPE_NORMAL
- en: Very important note
  prefs: []
  type: TYPE_NORMAL
- en: You cannot create Windows binary programs using TinyGo. You can still compile
    and flash programs for microcontroller and WebAssembly targets.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to directly install and use TinyGo inside the **Windows Subsystem
    for Linux** (**WSL**). The WSL is the way I recommend for Windows users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install TinyGo on Windows without using the WSL, I recommend using Scoop,
    a command-line installer for Windows. Make sure that you have PowerShell 5 (or
    later) and .NET Framework 4.5 (or later) installed. To do so, please follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable PowerShell for your current user account using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the following command to download Scoop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can install TinyGo by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now to verify the installation was successful, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The actual TinyGo and Go version might differ.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'AVR dependencies: In order to be able to compile and flash programs for the
    Arduino UNO, we need to have an AVR 8-bit toolchain installed. You can find a
    download here: [https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers](https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extend your `%PATH%` and make sure that the `bin` folder is included:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, download and install GNU Make for Windows. You can find GNU Make here:
    [http://gnuwin32.sourceforge.net/packages/make.htm](http://gnuwin32.sourceforge.net/packages/make.htm).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the last step, you need to download and install `avrdude`. The `avrdude`
    EXE also must be inside your `%PATH%`. You can download AVR Dude here: [http://download.savannah.gnu.org/releases/avrdude/](http://download.savannah.gnu.org/releases/avrdude/).
    The file you are looking for is called `avrdude-6.3-mingw32.zip`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you encounter any problems regarding the `avr` setup or don''t know how
    to configure environment variables, you may want to check out the following guide:
    [https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html](https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html).'
  prefs: []
  type: TYPE_NORMAL
- en: WSL installation
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to install TinyGo directly on the **Windows Subsystem for
    Linux** (**WSL**). Just follow the Linux section to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installation on macOS is straightforward. Let''s take a quick look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use Homebrew to `install tinygo`. Just use the following two
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Simply run the `tinygo version` command to verify the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands to install the additional requirements needed to
    compile programs for AVR-based microcontrollers such as the Arduino UNO, which
    we are going to use in the first few chapters of the book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing on Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to directly use a Docker image to compile our programs. However,
    it is not possible to flash the programs using the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply download the image using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The actual TinyGo version might differ. Use the newest TinyGo version from the
    check we did when we started the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example call to build a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have now successfully set up TinyGo and installed all additional requirements
    to compile and flash programs to the Arduino UNO microcontroller. Also, everything
    we need for WebAssembly is now set up. The next step is to set up IDE integration
    before we start writing our first program for a microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IDE integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a properly set up IDE is truly a blessing as we benefit from its features
    of code completion, functional linting, and so on. This way, we do not have to
    investigate the source code or documentation for every function we want to call.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the process of integrating TinyGo into VS Code,
    Goland, and other editors. This enables us to choose whatever editor we prefer
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VS Code offers an extension system, which makes it easy to integrate the Go
    and TinyGo toolset into the IDE. We are going to install the Go Extension, which
    offers support for the Go programming language. Afterward, we are going to install
    the TinyGo extension, which brings TinyGo support.
  prefs: []
  type: TYPE_NORMAL
- en: The Go extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We install the Go extension using the **Extensions** view using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Extensions** view either by clicking on the **Extensions** icon or
    pressing *Ctrl* + *Shift* + *X*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for **Go**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first entry in the list, which is called **Go** and is from the Go
    team at Google.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Install** button, as seen in the following screenshot:![Figure
    1.1 – Installation from the Extensions view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.1 – Installation from the Extensions view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After installing the extension for the first time, you might get prompted to
    install more dependencies. Do so by clicking on the **Install** button. If you
    do not get prompt, you can also install all dependencies by hitting *Ctrl* + *Shift*
    + *P* and entering the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the **Go: Install/Update Tools** command and hit *Enter*:![Figure 1.2
    – Go: Install/Update Tools command to execute'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.2 – Go: Install/Update Tools command to execute'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now select all dependencies by checking the box on the left side and click **OK**:![Figure
    1.3 – Selection of all dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.3 – Selection of all dependencies
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'VS Code will now install all dependencies, and it should print the following
    message when done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we'll see the TinyGo integration in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: The TinyGo extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TinyGo integration in VS Code is straightforward as there is a TinyGo extension
    that we simply need to install. Let''s quickly go through the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Extensions** view either by clicking on the **Extensions** icon or
    pressing *Ctrl* + *Shift* + *X*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for **TinyGo**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first entry in the list, which is called **TinyGo** and is from the
    TinyGo team.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Install** button, as seen in the following screenshot:![Figure
    1.4 – Extensions view showing the TinyGo extension
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.4 – Extensions view showing the TinyGo extension
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are not done with installing the extension. We need to use another command
    to configure the target we want to build for. Hit *Ctrl* + *Shift* + *P*, type
    `TinyGo target`, and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now search for `arduino` and hit *Enter*, as we see in the following screenshot:![Figure
    1.5 – The target selection popup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.5 – The target selection popup
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'VS Code will open a popup telling you that it needs to reload the window. Do
    so by clicking on **Reload**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Popup asking to reload the window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – Popup asking to reload the window
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we now have the extension installed and have selected a target. But what
    does it do internally? The only function of this extension is to set the `go.toolsEnvVars`
    variable in `vs code settings.json` of your current project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This could look like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes a popup similar to the one in the following screenshot will appear.
    Do not click on **Update tools**; just close it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Popup asking to update tools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Popup asking to update tools
  prefs: []
  type: TYPE_NORMAL
- en: If you are using VS Code, congratulations, you are done with the setup and are
    ready to go! The next sections are going to explain how to set up the IDE integration
    in other editors.
  prefs: []
  type: TYPE_NORMAL
- en: General IDE integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder, how does IDE integration work with TinyGo? Well, we simply have
    to configure the standard Go tooling, especially the **gopls language** server.
  prefs: []
  type: TYPE_NORMAL
- en: TinyGo has its own implementation of the standard libraries and also provides
    additional libraries, such as the machine package. The gopls language server needs
    to know where to look for these packages. That is why we need to set a `GOROOT`
    for this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'TinyGo makes heavy use of compiler flags. These flags are used during compile
    time to determine which files must be included in the build, as we see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – The board_arduino.go file from the TinyGo source code showing
    a build flag'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – The board_arduino.go file from the TinyGo source code showing a
    build flag
  prefs: []
  type: TYPE_NORMAL
- en: So basically, we integrate TinyGo into an IDE by locally setting these environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have to guess the correct values for `GOROOT` and `GOFLAGS`. TinyGo
    provides a command for that purpose. Let''s say we want to set the correct flags
    for an Arduino, we can find out by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The important parts of the output are `build tags` and `cached GOROOT`.
  prefs: []
  type: TYPE_NORMAL
- en: As we now know where to find the needed information, we can go ahead and configure
    any IDE we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Goland
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have now learned that we must set a `GOROOT` and `build` tags, we can
    also configure the integration in Goland.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `GOROOT` from the `tinygo info` command, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – GOROOT configuration in Goland'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.9_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – GOROOT configuration in Goland
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set the `build` tags. You can find them under **Build Tags
    & Vendoring**.Add the tags into the **Custom tags** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 1.10 – Custom tags configuration in Goland'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.10_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – Custom tags configuration in Goland
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You must manually change **Custom tags** each time you want to program for another
    microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating any editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have the standard Go tolling installed, you can use any other editor
    such as Vim or Nano so you can get IDE support. As other editors might lack configuration
    files, we can work around this fact by passing them the environment variables
    at the moment we start them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we start a VS Code instance by first setting environment
    variables and then starting VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can exchange the code call to any other program such as `vim` or `nano`.
    On Windows systems, the call might look a little bit different.
  prefs: []
  type: TYPE_NORMAL
- en: As we now know how to configure any IDE for the use of TinyGo, we will move
    on to learn about the Arduino UNO.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino UNO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino UNO is one of the most popular boards out there. It is powered by
    an 8-bit ATmega328P microcontroller, and as of the writing of this book, there
    are lots of derivates from the original Arduino UNO boards. Let's get to know
    it better in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the technical specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see in the following table, the ATmega328P has only 16 MHz and 32
    KB Flash memory. Standard Go produces a Hello World program of about 1.2 MB, which
    would not even fit on this microcontroller. So, we are working with very limited
    hardware here, but you will see that this is sufficient to build amazing projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief look at the technical specs of the Arduino UNO:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.1 – Technical specifications'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_1.1_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.1 – Technical specifications
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Consider the DC current per I/O pin of 20 mA as an upper limit. You should not
    exceed this limit to prevent damaging your microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the pinout next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring pinout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Pinout** is basically a map of the pins. We are going to use the descriptions
    of these pins in all projects that we build with the Arduino UNO. We will need
    it to correctly wire our components.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Arduino UNO REV3 pinout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.11_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11 – Arduino UNO REV3 pinout
  prefs: []
  type: TYPE_NORMAL
- en: As we now have learned some basic information about the Arduino UNO, let's go
    on and write our first program.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out the Hello World of Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Hello World program is the typical way to start the journey in a new programming
    language. A Hello World program on a microcontroller looks a bit different compared
    to a normal Hello World program. We are going to write a Hello World program to
    let the built-in LED blink. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting the requirements ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with our program, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino UNO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One USB cable to connect it to your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps closely for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `ch1` in the root of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the folder, we need to create a folder named `hello-world-of-things`
    and inside it, we are going to create a new `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your structure should now look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.12 – The project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.12_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – The project structure
  prefs: []
  type: TYPE_NORMAL
- en: As we have now prepared our project, we can go on and write our first program.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the microcontroller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to let the onboard LED blink. It is the easiest possible start
    for us. The example we are using is inspired by the *Blinky example* from the
    TinyGo source code, which is also used as a Hello World of Things showcase. Let''s
    go through each step carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `main` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages `machine` and `time`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a variable named `led` with the value `machine.LED`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `led` pin as the output pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an endless loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `led` to `Low` so that no voltage is given on the LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `sleep` for `300` milliseconds, that is the time the LED is off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `led` to `High` so a voltage is given to the LED to make it shine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `Sleep` for `300` milliseconds, which is the amount of time the LED is
    on for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Closing braces for the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `machine` package provides constants for the pin mapping and provides some
    more functions that are directly related to the used microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: We must wait for a certain amount of time between giving voltage to the LED
    and taking it off again, so we can see the blinking.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a pin as output means that we tell the microcontroller that we are
    only going to send signals using this pin. We can also configure a pin as input,
    which enables us to read the state from the pin.
  prefs: []
  type: TYPE_NORMAL
- en: Flashing the program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flashing the program is a simple command, if you are on Linux, macOS, or are
    using Windows WSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply connect your Arduino UNO to any USB port and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tinygo flash` command needs at least the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--target`, which sets the microcontroller to flash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path to the `main.go` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in my example, the code flashed onto the Arduino UNO is only
    using 558 bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have successfully written, built, and flashed your first
    program onto an Arduino UNO using TinyGo.
  prefs: []
  type: TYPE_NORMAL
- en: Using TinyGo Playground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't have an Arduino UNO right now? You can test the code using **TinyGo
    Playground**. TinyGo Playground makes use of WebAssembly to emulate the behavior
    of a small number of boards such as the Arduino Nano IoT 33 and the Arduino UNO.
    It can also compile programs for the Arduino Nano IoT 33\. But please keep in
    mind that the behavior in the TinyGo Playground might differ from real hardware.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the TinyGo Playground at [https://play.tinygo.org/](https://play.tinygo.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned what TinyGo actually is, how it differs from standard Go, we
    have acquired basic knowledge about the Arduino UNO itself, how to set up TinyGo,
    how to set up IDE integration, and finally, wrote and flashed our first program
    onto real hardware and made an LED blink with our code. Isn't that an interesting
    start?
  prefs: []
  type: TYPE_NORMAL
- en: We are going to build a traffic light controller system in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which command can be used to find out the needed environment variable values
    for the IDE integration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command can be used to flash a program onto a microcontroller?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we have to sleep a certain amount of time when giving voltage or taking
    voltage away from the LED?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you let the LED blink S-O-S in morse code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
