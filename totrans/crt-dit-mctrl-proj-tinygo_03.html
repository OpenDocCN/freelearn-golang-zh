<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer045">
			<h1 id="_idParaDest-58"><em class="italic"><a id="_idTextAnchor058"/>Chapter 3</em>: Building a Safety Lock Using a Keypad</h1>
			<p>We gained basic knowledge of using LEDs, GPIO ports, and resistors in the last chapter. We also learned how to handle input and output. In this chapter, we are going to build a safety lock using a keypad. We will be able to input a passcode in the keypad that triggers a servomotor to unlock a lock. This will be achieved by splitting up the project into individual steps and putting it all together at the end of the chapter. </p>
			<p>After working through this chapter, we will know how to write information to the serial port and how to monitor this information. This is a great way to easily debug an application. Then, we are going to write our own driver for a 4x4 keypad, which can be used as passcode input in our case. This 4x4 keypad can also be used as controller input, or as input to start different parts of a program. With that covered, we are going to write the logic to control a servomotor. Servomotors can be used as a lock mechanism and are also often used in remote-controlled planes. In the end, we will have a project where we can set up a passcode, enter the passcode, and trigger the servomotor if the input was correct.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Writing to the serial port</li>
				<li>Monitoring the serial port </li>
				<li>Monitoring input from a keypad </li>
				<li>Writing the driver</li>
				<li>Finding drivers for TinyGo</li>
				<li>Controlling a servomotor</li>
				<li>Building a safety lock using a keypad</li>
			</ul>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Technical requirements</h1>
			<p>We are going to need the following components for this project:</p>
			<ul>
				<li>One Arduino Uno</li>
				<li>One 4x4 membrane keypad</li>
				<li>One SG90 servomotor</li>
				<li>One red LED</li>
				<li>One green LED</li>
				<li>14 jumper wires</li>
				<li>Two 220 Ohm resistors</li>
				<li>A breadboard</li>
			</ul>
			<p>You can find the code for this chapter on GitHub: <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03</a></p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3uN9OAf">https://bit.ly/3uN9OAf</a></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Writing to the serial port</h1>
			<p>An easy way to <a id="_idIndexMarker125"/>debug your programs on a microcontroller is to write messages to the serial port. You can later use this technique to debug your program, by printing the current step or sensor values, for example. </p>
			<p>Let's write a small program to see how writing to a serial port is done. We start by creating a new folder named <strong class="source-inline">Chapter03</strong> in the project directory, and inside this new directory, we create another directory named <strong class="source-inline">writing-to-serial</strong>. Now we have to create a new <strong class="source-inline">main.go</strong> file and insert an empty <strong class="source-inline">main()</strong> function. The folder structure should now look like the following:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="Images/Figure_3.1_B16555.jpg" alt="Figure 3.1 – The folder structure for writing to serial port&#13;&#10;" width="264" height="43"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The folder structure for writing to serial port</p>
			<p>Now, follow these steps: </p>
			<ol>
				<li>We print the word <strong class="source-inline">starting</strong> followed by a space and print the word <strong class="source-inline">program </strong>followed by an <strong class="source-inline">\n</strong>:<p class="source-code">print("starting ")</p><p class="source-code">print("program\n")</p></li>
				<li>We endlessly loop, print <strong class="source-inline">Hello World</strong>, and sleep for a second:<p class="source-code">for {</p><p class="source-code">  println("Hello World")</p><p class="source-code">  time.Sleep(1 * time.Second)</p><p class="source-code">}</p></li>
				<li>Now, flash <a id="_idIndexMarker126"/>the program to your microcontroller by using the following command: <p class="source-code"><strong class="bold">tinygo flash --target=arduino Chapter03/writing-to-serial/main.go</strong></p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">print</strong> just writes the text to the serial port and does not insert a character for a newline.</p><p class="callout"><strong class="source-inline">println</strong> adds a character for a newline.</p></li>
			</ol>
			<p>Okay, we now have a program on our controller that prints text to the serial port. We have learned about a very convenient way to insert debug logging into our programs. In the next section, we are going to learn how to read data from the serial port on the computer.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Monitoring the serial port</h1>
			<p>As we are <a id="_idIndexMarker127"/>writing debug logs or other messages to the serial port, we need a convenient way to monitor these logs. An easy way to monitor the serial port on all operating systems is to use PuTTy. </p>
			<p>Let's first look at how to<a id="_idIndexMarker128"/> install PuTTy on various platforms:</p>
			<ul>
				<li><strong class="bold">Linux</strong>: On Linux, PuTTy is available through <strong class="source-inline">apt</strong>. We can install it using the following command:<p class="source-code"><strong class="bold">sudo apt install putty</strong></p><p>Alternatively, we can find <strong class="source-inline">tar.gz</strong> here: <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p></li>
				<li><strong class="bold">MacOS</strong>: On Mac, PuTTy is available using <strong class="source-inline">brew</strong>. We can install it using the following command:<p class="source-code"><strong class="bold">brew install Putty</strong></p></li>
				<li><strong class="bold">Windows</strong>: On Windows, we can download PuTTy from here: <a href="https://www.putty.org/">https://www.putty.org/</a>. We simply download and run the <strong class="source-inline">.msi</strong> file.</li>
			</ul>
			<p>As we have now installed PuTty, it is time to monitor our serial port:</p>
			<ol>
				<li value="1">Make sure the program from the previous section is flashed on your microcontroller and the USB cable is plugged in. </li>
				<li>The next step is starting PuTTy. As soon as PuTTy is started, click on <strong class="bold">Session</strong> and select <strong class="bold">Serial</strong> for <strong class="bold">Connection type</strong>. This should look as in the following screenshot:<div id="_idContainer030" class="IMG---Figure"><img src="Images/Figure_3.2_B16555.jpg" alt="Figure 3.2 – PuTTy Configuration&#13;&#10;" width="658" height="582"/></div><p class="figure-caption">Figure 3.2 – PuTTy Configuration</p></li>
				<li>Now we have <a id="_idIndexMarker129"/>to choose the serial line. On Windows, this will typically be <strong class="bold">COM0</strong>. It could also be any other COM port, such as COM5 or similar. Once you have found the correct COM port, it will usually stay the same. The Device Manager usually lists all devices including the used COM ports in the <strong class="bold">Ports (COM &amp; LPT)</strong> section. On Linux and Mac, this will typically be <strong class="source-inline">/dev/ttyACM0</strong> or <strong class="source-inline">/dev/ttyUSB0</strong>. </li>
				<li>As we have now successfully configured the session, we can save this configuration. To do so, add <strong class="source-inline">Microcontroller</strong> as the name and click on <strong class="bold">Save</strong>. This should look as in the following screenshot: <div id="_idContainer031" class="IMG---Figure"><img src="Images/Figure_3.3_B16555.jpg" alt="Figure 3.3 – PuTTy saving the configuration&#13;&#10;" width="659" height="582"/></div><p class="figure-caption">Figure 3.3 – PuTTy saving the configuration</p></li>
				<li>As we have now <a id="_idIndexMarker130"/>saved the configuration, we can reuse it each time we want to monitor the serial port. Now select <strong class="bold">Microcontroller</strong> from the list and click on the <strong class="bold">Open</strong> button:<div id="_idContainer032" class="IMG---Figure"><img src="Images/Figure_3.4_B16555.jpg" alt="Figure 3.4 – PuTTy Microcontroller session selected&#13;&#10;" width="659" height="582"/></div><p class="figure-caption">Figure 3.4 – PuTTy Microcontroller session selected</p></li>
				<li>After clicking<a id="_idIndexMarker131"/> on the <strong class="bold">Open</strong> button, a new window opens, which shows the output from our program. It should look similar to the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="Images/Figure_3.5_B16555.jpg" alt="Figure 3.5 – PuTTy program output&#13;&#10;" width="506" height="363"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – PuTTy program output</p>
			<p>We have now<a id="_idIndexMarker132"/> learned how to monitor the output of our programs. Next, we are going to learn how to use a 4x4 keypad and monitor button presses.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Monitoring input from a keypad</h1>
			<p>In this section, we <a id="_idIndexMarker133"/>are going to read input from a 4x4 keypad and print the pressed button to the serial port. Since TinyGo does not have a driver for this keypad, we will look at how to create a driver. This will help you understand the process and you can use this knowledge when you need to use other unsupported hardware. </p>
			<p>As part of this exercise, I have also followed the process of adding this to the TinyGo codebase and it should be supported in the future. We are going to start by learning how to connect the keypad. Then we will move on to writing a driver, and then we are going to have a brief look at how new drivers are added to TinyGo.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Building the circuit</h2>
			<p>We start off by <a id="_idIndexMarker134"/>assembling the circuit. We are going to need a 4x4 keypad and eight jumper wires. Although we could use jumper cables to directly wire the keypad to the Arduino ports, we are going to wire it through a breadboard. We are going to add more components to this in the upcoming sections. Follow these steps to correctly wire the keypad:</p>
			<ol>
				<li value="1">Connect pin <em class="italic">D3</em> to <em class="italic">A32</em>.</li>
				<li>Connect pin <em class="italic">D4</em> to <em class="italic">A31</em>.</li>
				<li>Connect pin <em class="italic">D5</em> to <em class="italic">A30</em>.</li>
				<li>Connect pin <em class="italic">D6</em> to <em class="italic">A29</em>.</li>
				<li>Connect pin <em class="italic">D7</em> to <em class="italic">A28</em>.</li>
				<li>Connect pin <em class="italic">D8</em> to <em class="italic">A27</em>.</li>
				<li>Connect pin <em class="italic">D9</em> to <em class="italic">A26</em>.</li>
				<li>Connect pin <em class="italic">D10</em> to <em class="italic">A25</em>.</li>
				<li>Connect <em class="italic">E32</em> with pin <em class="italic">0</em> on the keypad.</li>
				<li>Connect <em class="italic">E31</em> with pin <em class="italic">1</em> on the keypad.</li>
				<li>Connect <em class="italic">E30</em> with pin <em class="italic">2</em> on the keypad.</li>
				<li>Connect <em class="italic">E29</em> with pin <em class="italic">3</em> on the keypad.</li>
				<li>Connect <em class="italic">E28</em> with pin <em class="italic">4</em> on the keypad.</li>
				<li>Connect <em class="italic">E27</em> with pin <em class="italic">5</em> on the keypad.</li>
				<li>Connect <em class="italic">E26</em> with pin <em class="italic">6</em> on the keypad.</li>
				<li>Connect <em class="italic">E25</em> with P pin in <em class="italic">7</em> on the keypad.</li>
			</ol>
			<p>Having done this, your circuit should look similar to the following screenshot:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="Images/Figure_3.6_B16555.jpg" alt="Figure 3.6 – Keypad circuit – image is taken from Fritzing&#13;&#10;" width="964" height="863"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Keypad circuit – image is taken from Fritzing</p>
			<p>We have now<a id="_idIndexMarker135"/> correctly wired the keypad. Before we can go on with implementing the code, we need to understand how a 4x4 keypad works. </p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>Understanding the workings of a 4x4 keypad</h2>
			<p>Having<a id="_idIndexMarker136"/> a <a id="_idIndexMarker137"/>look at the keypad, we realize that it basically consists of <strong class="bold">four rows</strong> with <strong class="bold">four columns</strong> per row. The keypad comes with eight pins. The first <a id="_idIndexMarker138"/>four <a id="_idIndexMarker139"/>pins are used for the rows, and the remaining four are used for the columns. To determine which key is being pressed, we just need to find the position of the pressed key in this 4x4 coordinate system. </p>
			<p>Button <strong class="bold">1</strong>, for example, has the coordinates 0,0 (row 0, column 0), while button <strong class="bold">D</strong> has the coordinates 3,3 (row 3, column 3).</p>
			<p>In the internal circuit of the keypad, the rows are connected to the columns. When a button is being pressed, the circuit is closed. When the circuit is closed, current flows, which is the signal we can read on a pin. As the keypad is not directly connected to GND and VCC, we need to provide the keypad with power. That is why four pins will be used as input and four will be used as output pins.</p>
			<p>I have <a id="_idIndexMarker140"/>dissembled such a 4x4 keypad, to provide a visual of the<a id="_idIndexMarker141"/> internal circuit:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="Images/Figure_3.7_B16555.jpg" alt="Figure 3.7 – Keypad internal circuit &#13;&#10;" width="378" height="443"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Keypad internal circuit </p>
			<p>As we now know that we basically just have to check each coordinate in this 4x4 coordinate system for the correct state, we can go on and write the code. </p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Writing the driver</h1>
			<p>As we want to<a id="_idIndexMarker142"/> have reusable code, we are going to write a driver package for the keypad. The driver will provide an easy-to-use interface while hiding the more complicated implementation logic. Doing it this way, we can simply reuse the package in later projects even beyond the book. The official TinyGo drivers typically provide a constructor-like function that creates a new instance of the driver and a <strong class="source-inline">Configure</strong> function that takes care of initialization. We are also going to provide a similar API.</p>
			<p>Just like in our previous projects, we are going to start by creating a new folder named <strong class="source-inline">controlling-keypad</strong> inside the <strong class="source-inline">Chapter03</strong> folder. Then, we are going to create a <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function. Also, we need to create a new folder named <strong class="source-inline">keypad</strong> and create a new file named <strong class="source-inline">driver.go</strong>, and then name the package <strong class="source-inline">keypad</strong>. Your project structure should now look like the following:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="Images/Figure_3.8_B16555.jpg" alt="Figure 3.8 – Project structure for writing the driver&#13;&#10;" width="249" height="133"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Project structure for writing the driver</p>
			<p>We are going to split the logic into the following five parts:</p>
			<ul>
				<li><strong class="source-inline">Driver</strong> variables</li>
				<li><strong class="source-inline">Configure</strong></li>
				<li><strong class="source-inline">GetIndices</strong></li>
				<li><strong class="source-inline">GetKey</strong></li>
				<li><strong class="source-inline">main</strong></li>
			</ul>
			<p>Let's understand each of them. </p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Driver variables</h2>
			<p>We are going to<a id="_idIndexMarker143"/> need some variables inside our <strong class="source-inline">Driver</strong> struct. Follow<a id="_idIndexMarker144"/> these steps to set it up:</p>
			<ol>
				<li value="1">Define a new struct named <strong class="source-inline">Driver</strong>:<p class="source-code">type Driver struct {</p></li>
				<li>We need an <strong class="source-inline">inputEnabled</strong> variable to debounce the keypresses:<p class="source-code">   inputEnabled bool</p></li>
				<li><strong class="source-inline">lastColumn</strong> and <strong class="source-inline">lastRow</strong> are used to save the position of the last keypress:<p class="source-code">   lastColumn int</p><p class="source-code">   lastRow int</p></li>
				<li>We need an array of <strong class="source-inline">machine.Pin</strong> to store the column pins:<p class="source-code">   columns [4]machine.Pin</p></li>
				<li>We need an array of <strong class="source-inline">machine.Pin</strong> to store the row pins:<p class="source-code">   rows [4]machine.Pin</p></li>
				<li>We use mapping to map the key values to indices (positions):<p class="source-code">   mapping [4][4]string</p><p class="source-code">}</p></li>
			</ol>
			<p>Now we are going to initialize the pins and the <strong class="source-inline">Driver</strong> variables.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>Configure</h2>
			<p>Start <a id="_idIndexMarker145"/>off <a id="_idIndexMarker146"/>by creating an empty function named <strong class="source-inline">Configure</strong> that takes eight <strong class="source-inline">machine.Pin</strong> function as an argument and is a pointer receiver to <strong class="source-inline">Driver</strong>. This should look like the following snippet: </p>
			<p class="source-code">func (keypad *Driver)Configure(r4, r3, r2, r1, c4, c3, c2 ,c1 machine.Pin) {}</p>
			<p>The next step is to put the initialization logic into this function. To do so, follow these steps:</p>
			<ol>
				<li value="1">Initialize the column pins using a PinInputPullup config. The internal pullup resistor is going to hold the column to 5 V until a button is being pressed, which we then can read as input:<p class="source-code">inputConfig := machine.PinConfig{Mode: machine.</p><p class="source-code">               PinInputPullup}</p><p class="source-code">outputConfig := machine.PinConfig{Mode: machine.</p><p class="source-code">                PinOutput}</p><p class="source-code">c4.Configure(inputConfig)</p><p class="source-code">c3.Configure(inputConfig)</p><p class="source-code">c2.Configure(inputConfig)</p><p class="source-code">c1.Configure(inputConfig)</p></li>
				<li>Add the <a id="_idIndexMarker147"/>column pins to the <strong class="source-inline">columns</strong> array. By doing so, we<a id="_idIndexMarker148"/> can later just use a loop to iterate over all columns:<p class="source-code">keypad.columns = [4]machine.Pin{c4, c3, c2, c1}</p></li>
				<li>Initialize the row pins using the <strong class="source-inline">PinOutput</strong> config:<p class="source-code">outputConfig := machine.PinConfig{Mode: machine.</p><p class="source-code">                PinOutput}</p><p class="source-code">r4.Configure(outputConfig)</p><p class="source-code">r3.Configure(outputConfig)</p><p class="source-code">r2.Configure(outputConfig)</p><p class="source-code">r1.Configure(outputConfig)</p></li>
				<li>Add all the row pins to the rows array. This enables us to iterate over all the rows using a loop:<p class="source-code">keypad.rows = [4]machine.Pin{r4, r3, r2, r1}</p></li>
				<li>Initialize the mapping with the key values. We will be mapping the pressed column and row index to get the correct key value:<p class="source-code">keypad.mapping = [4][4]string{</p><p class="source-code">    {"1", "2", "3", "A"},</p><p class="source-code">    {"4", "5", "6", "B"},</p><p class="source-code">    {"7", "8", "9", "C"},</p><p class="source-code">    {"*", "0", "#", "D"},</p><p class="source-code">}</p></li>
				<li>Initialize <strong class="source-inline">inputEnabled</strong>, <strong class="source-inline">lastColumn</strong>, and <strong class="source-inline">lastRow</strong>:<p class="source-code">keypad.inputEnabled = true</p><p class="source-code">keypad.lastColumn = -1</p><p class="source-code">keypad.lastRow = -1</p></li>
			</ol>
			<p>This is<a id="_idIndexMarker149"/> everything we need to initialize our program to talk <a id="_idIndexMarker150"/>to the keypad.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>GetIndices</h2>
			<p>Now we just<a id="_idIndexMarker151"/> need to loop over the arrays and columns and find the <a id="_idIndexMarker152"/>pressed key. We start by creating a new function named <strong class="source-inline">GetIndices</strong> that returns two integers and is a pointer receiver to <strong class="source-inline">Driver</strong>. This should look like the following snippet:</p>
			<p class="source-code">func (keypad *Driver) GetIndices() (int, int){}</p>
			<p>Now, follow these steps to implement the function logic:</p>
			<ol>
				<li value="1">Iterate over all rows:<p class="source-code">for rowIndex := range keypad.rows {</p></li>
				<li>Set the <a id="_idIndexMarker153"/>current <strong class="source-inline">rowPin</strong> to <strong class="source-inline">Low</strong>. We need to do this as we are using<a id="_idIndexMarker154"/> internal <strong class="bold">pullup resistors</strong>. If <strong class="bold">pulldown resistors</strong> were used, we would set <strong class="source-inline">rowPin</strong> to <strong class="source-inline">High</strong> instead:<p class="source-code">rowPin := keypad.rows[rowIndex]</p><p class="source-code">rowPin.Low()</p></li>
				<li>Iterate over all columns:<p class="source-code">for columnIndex := range keypad.columns {</p></li>
				<li>Get the current <strong class="source-inline">columnPin</strong>:<p class="source-code">columnPin := keypad.columns[columnIndex]</p></li>
				<li>Check whether the current <strong class="source-inline">columnPin</strong> is pressed and execute the logic if we accept input. Disable<a id="_idIndexMarker155"/> accepting input and save the current<a id="_idIndexMarker156"/> column and row, and then return the indices:<p class="source-code">if !columnPin.Get() &amp;&amp; keypad.inputEnabled {</p><p class="source-code">  keypad.inputEnabled = false</p><p class="source-code">  keypad.lastColumn = columnIndex</p><p class="source-code">  keypad.lastRow = rowIndex</p><p class="source-code">  return keypad.lastRow, keypad.lastColumn</p><p class="source-code">}</p></li>
				<li>Accept the input again, if the previous key is not pressed anymore:<p class="source-code">if columnPin.Get() &amp;&amp;</p><p class="source-code">    columnIndex == keypad.lastColumn &amp;&amp;</p><p class="source-code">    rowIndex == keypad.lastRow &amp;&amp;</p><p class="source-code">    !keypad.inputEnabled {</p><p class="source-code">    keypad.inputEnabled = true</p><p class="source-code">}}</p></li>
				<li>Set <strong class="source-inline">rowPin</strong> to <strong class="source-inline">High</strong> again and close the outer loop:<p class="source-code">rowPin.High()</p><p class="source-code">}</p></li>
				<li>Return <strong class="source-inline">–1, -1</strong> if no key was pressed and close the function:<p class="source-code">return -1, -1</p><p class="source-code">}</p></li>
			</ol>
			<p>Calling this function will now tell us the position of the pressed key in the coordinate system. If you <a id="_idIndexMarker157"/>want to understand pullup and pulldown resistors in<a id="_idIndexMarker158"/> more detail, have a look at the following link: <a href="https://www.electronics-tutorials.ws/logic/pull-up-resistor.html">https://www.electronics-tutorials.ws/logic/pull-up-resistor.html</a>.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>GetKey</h2>
			<p>Next, we <a id="_idIndexMarker159"/>are going to create a function that checks the indices of the pressed<a id="_idIndexMarker160"/> key and maps the indices to the key value. To do so, we start with an empty function named <strong class="source-inline">GetKey</strong> that returns a string and is a pointer receiver to <strong class="source-inline">Driver</strong>. This should look like the following snippet:</p>
			<p class="source-code">func (keypad *Driver) GetKey() string {}</p>
			<p>Inside this function, we just call the <strong class="source-inline">GetIndices</strong> method, check whether a button was pressed, and if a button was pressed, we return the key value as a string. This looks like the following:</p>
			<p class="source-code">    row, column := keypad.GetIndices()</p>
			<p class="source-code">        if row == -1 &amp;&amp; column == -1 {</p>
			<p class="source-code">              return ""</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return keypad.mapping[row][column]</p>
			<p>Now, only the <strong class="source-inline">main</strong> logic is missing. Let's look at that next!</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>main</h2>
			<p>We call our <a id="_idIndexMarker161"/>initialization logic and loop endlessly to check the <a id="_idIndexMarker162"/>pressed key. The following steps show how:</p>
			<ol>
				<li value="1">Initialize <strong class="source-inline">keypadDevice</strong>:<p class="source-code">keypadDevice := keypad.Driver{}</p><p class="source-code">keypadDevice.Configure(machine.D3, machine.D4, machine.</p><p class="source-code">    D5, machine.D6, machine.D7, machine.D8, machine.D9, </p><p class="source-code">    machine.D10)</p></li>
				<li>Now, loop endlessly, check for a keypress, and print the value if a key was pressed:<p class="source-code">for {</p><p class="source-code">  key := keypadDevice.GetKey()</p><p class="source-code">  if key != "" {</p><p class="source-code">    println("Button: ", key)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Great! That's it. Now we can flash the program and monitor the outputs. Flash the program using the following command: </p>
			<p class="source-code">tinygo flash –target=arduino Chapter03/controlling-keypad/main.go</p>
			<p>Now, open PuTTy and monitor the serial output while pressing keys on the keypad. The output should look similar to the following screenshot:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="Images/Figure_3.9_B16555.jpg" alt="Figure 3.9 – Keypad output in PuTTy&#13;&#10;" width="506" height="363"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Keypad output in PuTTy</p>
			<p>Great, we have<a id="_idIndexMarker163"/> successfully written our own driver to monitor button <a id="_idIndexMarker164"/>presses on a keypad!</p>
			<p>In the next section, we are going to learn where to find TinyGo drivers for peripheral hardware. We are also going to look at the process of contributing to the TinyGo drivers repository.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Finding drivers for TinyGo</h1>
			<p>As of the time<a id="_idIndexMarker165"/> of writing, there are 53 devices supported by<a id="_idIndexMarker166"/> TinyGo. The driver we just wrote, which I am going to contribute to TinyGo, will support 54 devices. But where can we find drivers for devices that we want to use? The answer is simple: there is a repository for this purpose. You can find it at <a href="https://github.com/tinygo-org/drivers">https://github.com/tinygo-org/drivers</a>.</p>
			<p>In the next chapter, we will learn how to use such drivers when using different types of displays.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Contributing drivers to TinyGo</h2>
			<p>The TinyGo <a id="_idIndexMarker167"/>community happily appreciates all contributions. If <a id="_idIndexMarker168"/>you develop a driver for a device and want to contribute it to TinyGo, you can follow these simple steps:</p>
			<ol>
				<li value="1">Open an issue and explain what you want to add and how you plan to implement it.</li>
				<li>Fork the repository.</li>
				<li>Create a new branch based on the dev branch.</li>
				<li>Create a pull request.</li>
			</ol>
			<p>You can find the contribution guidelines at the following link: <a href="https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md">https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md</a>.</p>
			<p>All in all, my personal experience with the TinyGo community has been extremely positive. They are very polite and will help you out with any kind of problem. I have not encountered a single problem where the community could not give me a helpful answer. Don't be afraid to ask a question in an issue or on the TinyGo channel in the Gophers slack. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please do not ask any questions that are directly related to this book in any of the official TinyGo channels, such as Slack or GitHub. If you have any questions regarding this book, you can raise an issue on the accompanying GitHub repository or send an email to me.</p>
			<p>As we now know how keypads work and where to find drivers, we can go on with the next part of our safety lock.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Controlling a servomotor</h1>
			<p>As we are now<a id="_idIndexMarker169"/> able to read the input to the keypad, the thing that is missing to build a safety lock is some kind of motor. For that case, we are going to use an SG90 servomotor. As of the time of writing, the timings on the Arduino Uno are not accurate enough to completely control the SG90 servomotor, but that is not a problem for our use case. We are just going to move the servo in one direction, which is clockwise. Also, there is currently no official driver for the SG90 servomotor, so we are going to write <a id="_idIndexMarker170"/>our own! </p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Understanding SG90 servomotors</h2>
			<p>SG90 <a id="_idIndexMarker171"/>servomotors <a id="_idIndexMarker172"/>are controlled by <strong class="bold">Pulse Width Moduluation</strong> (<strong class="bold">PWM</strong>). Basically, the SG90 <a id="_idIndexMarker173"/>reads inputs in a 50 Hz period. During this period, we can tell the servomotor to adjust itself to a certain angle by setting a signal for a certain amount of time. The signal length is called the <em class="italic">duty cycle</em>. After the duty cycle, we wait for the rest<a id="_idIndexMarker174"/> of the period. Depending on the duty cycle (the <strong class="bold">pulse width</strong>), the SG90 will adjust its angle.</p>
			<p>The SG90 can be adjusted to the following three positions:</p>
			<ul>
				<li>0 degrees (center) using a 1.5 ms pulse</li>
				<li>+ 90 degrees (right) using a 2 ms pulse</li>
				<li>- 90 degrees (left) using a 1 ms pulse</li>
			</ul>
			<p>It is also possible to adjust the servomotor to all angles in between this by doing some math on the pulse width sizes, but we do not need to do that for our example. </p>
			<p>The SG90 typically has three wires:</p>
			<ul>
				<li>Black/brown for ground</li>
				<li>Red for VCC</li>
				<li>Orange/yellow for the PWM signal</li>
			</ul>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Building the circuit</h2>
			<p>We will build<a id="_idIndexMarker175"/> on top of our last example. We just have to add the servomotor by following these steps:</p>
			<ol>
				<li value="1">Connect the 5 V port from the Arduino Uno to the positive lane on the power bus.</li>
				<li>Connect a GND port from the Arduino Uno to the ground lane on the power bus.</li>
				<li>Connect the GND wire from the SG90 to the ground lane on the power bus.</li>
				<li>Connect the VCC wire from the SG90 to the positive lane on the power bus.</li>
				<li>Connect the PWM wire from the SG90 to pin <em class="italic">D11</em> on the Arduino Uno.</li>
			</ol>
			<p>Our circuit <a id="_idIndexMarker176"/>should now look as in the following screenshot:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="Images/Figure_3.10_B16555.jpg" alt="Figure 3.10 – Keypad and servomotor&#13;&#10;" width="798" height="741"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Keypad and servomotor</p>
			<p>Excellent. Before we can start programming, we should learn something about PWM pins on the Arduino Uno. Only six pins of the GPIO ports are capable of PWM. The pins are marked with a <strong class="bold">~</strong> symbol. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">On the Arduino <a id="_idIndexMarker177"/>Uno, you can use pins <em class="italic">D3</em>, <em class="italic">D5</em>, <em class="italic">D6</em>, <em class="italic">D9</em>, <em class="italic">D10</em>, and <em class="italic">D11</em> for PWM.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Writing the servo control logic</h2>
			<p>We need<a id="_idIndexMarker178"/> to<a id="_idIndexMarker179"/> create a new folder named <strong class="source-inline">controlling-servo</strong> inside the <strong class="source-inline">Chapter03</strong> folder. Next, we create a new <strong class="source-inline">main.go</strong> file inside the new folder and insert an empty <strong class="source-inline">main</strong> function. Also, we need to create a new folder named <strong class="source-inline">servo</strong> with a new <strong class="source-inline">driver.go</strong> file inside the <strong class="source-inline">servo</strong> package. Our project structure should now look like the following:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="Images/Figure_3.11_B16555.jpg" alt="Figure 3.11 – Project structure for servo control logic&#13;&#10;" width="252" height="174"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Project structure for servo control logic</p>
			<p class="callout-heading">Note</p>
			<p class="callout">PWM is currently being reworked. In the future handling, PWM devices will be much simpler. It is also being handled by hardware PWM instead of emulating the PWM behavior. You can check the progress at the following pull request: <a href="https://github.com/tinygo-org/tinygo/pull/1121">https://github.com/tinygo-org/tinygo/pull/1121</a>.</p>
			<p>The driver that we are now building has the main purpose of teaching us how PWM actually works and is going to work better on all microcontrollers that are not based on the 8-bit AVR architecture, such as the ATmega328P, which is onboard the Arduino Uno. This is due to the fact that the AVR support is still experimental, although it is being improved with nearly every release of TinyGo. As soon as the PR mentioned previously is merged, I recommend using a driver that is based on that hardware PWM support for controlling servos.</p>
			<p>Also be aware that as of the time of writing, you manually need to reset the servo when it <a id="_idIndexMarker180"/>reaches <a id="_idIndexMarker181"/>the rightmost position.</p>
			<p>Inside the <strong class="source-inline">driver.go</strong> file, we need to use the following steps to let our servo rotate a bit:</p>
			<ol>
				<li value="1">Declare package-level constants for the duty cycles and <strong class="source-inline">rightRemainingPeriod</strong>:<p class="source-code">const centerDutyCycle = 1500 * time.Microsecond</p><p class="source-code">const centerRemainingPeriod = 18500 * time.Microsecond</p><p class="source-code">const leftDutyCycle = 2000 * time.Microsecond</p><p class="source-code">const leftRemainingPeriod = 18000 * time.Microsecond</p><p class="source-code">const rightDutyCycle = 1000 * time.Microsecond</p><p class="source-code">const rightRemainingPeriod = 19000 * time.Microsecond</p></li>
				<li>Create a new struct named <strong class="source-inline">Driver</strong> that has <strong class="source-inline">machine.Pin</strong> as a member:<p class="source-code">type Driver struct {</p><p class="source-code">    pin machine.Pin</p><p class="source-code">}</p></li>
				<li>Define a new, empty function named <strong class="source-inline">Configure</strong> that takes <strong class="source-inline">machine.Pin</strong> as a parameter and is a pointer receiver to <strong class="source-inline">Driver</strong>:<p class="source-code">func (servo *Driver) Configure(pin machine.Pin) {}</p></li>
				<li>Configure pin as output:<p class="source-code">    servo.pin = pin</p><p class="source-code">    servo.pin.Configure(machine.PinConfig{Mode: machine.</p><p class="source-code">    PinOutput})</p></li>
				<li>Loop four times to rotate the motor only about 30 degrees:<p class="source-code">for position := 0; position &lt;= 4; position++ {</p></li>
				<li>Set a signal for the duty cycle, pull it down, and sleep for the rest of the period:<p class="source-code">    servo.pwm.Pin.High()</p><p class="source-code">    time.Sleep(rightDutyCycle)</p><p class="source-code">    servo.pwm.Pin.Low()</p><p class="source-code">    time.Sleep(rightRemainingPeriod)</p><p class="source-code">}</p></li>
			</ol>
			<p>Before we can <a id="_idIndexMarker182"/>try out our library, we need to write a small example <a id="_idIndexMarker183"/>program. To do so, put the following snippet inside the <strong class="source-inline">main.go</strong> file inside the controlling <strong class="source-inline">servo</strong> folder:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    servo := servo.Driver{}</p>
			<p class="source-code">    servo.Configure(machine.D11)</p>
			<p class="source-code">    servo.Right()</p>
			<p class="source-code">}</p>
			<p>Now we just need to try that program by flashing it using the following command:</p>
			<p class="source-code">tinygo flash –target=arduino Chapter03/controlling-servo/main.go</p>
			<p>Congratulations, this was the first time that we moved something using code. As we have now learned how to rotate the servo a bit and how to read inputs from a keypad, the next step is to put everything together.</p>
			<p>As soon as the refactoring of the PWM is merged to upstream and released in a TinyGo version, you do not want to use the previous driver anymore. For that case, we create a new driver that makes use of hardware PWM instead of emulating the behavior. So go on and create a new folder named <strong class="source-inline">servo-pwm</strong> and create a new <strong class="source-inline">driver.go</strong> file inside. Then follow these steps to implement the better driver:</p>
			<ol>
				<li value="1">We define the period, which is 20.000 microsecond and create a new <strong class="source-inline">Device</strong> struct, shown as follows:<p class="source-code">const period = 20e6</p><p class="source-code">type Device struct {</p><p class="source-code">    pwm machine.PWM</p><p class="source-code">    pin machine.Pin</p><p class="source-code">    channel uint8</p><p class="source-code">}</p></li>
				<li>The next step is to add a constructor function as follows:<p class="source-code">func NewDevice(timer machine.PWM, pin machine.Pin) *Device {</p><p class="source-code">    return &amp;Device{</p><p class="source-code">        pwm: timer,</p><p class="source-code">        pin: pin,</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now we configure the PWM interface. We need to set the period and get the channel for our output pin:<p class="source-code">func (d *Device) Configure() error {</p><p class="source-code">    err := d.pwm.Configure(machine.PWMConfig{</p><p class="source-code">        Period: period,</p><p class="source-code">    })</p><p class="source-code">    if err != nil {</p><p class="source-code">        return err</p><p class="source-code">    }</p><p class="source-code">    d.channel, err = d.pwm.Channel(machine.Pin(d.pin))</p><p class="source-code">        if err != nil {</p><p class="source-code">            return err}</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>Now we add functions that lets us set the position of the servomotor. We pass in the microseconds for the duty cycles as parameter, as follows:<p class="source-code">func (d *Device) Right() {</p><p class="source-code">    d.setDutyCycle(1000)</p><p class="source-code">}</p><p class="source-code">func (d *Device) Center() {</p><p class="source-code">    d.setDutyCycle(1500)</p><p class="source-code">}</p><p class="source-code">func (d *Device) Left() {</p><p class="source-code">    d.setDutyCycle(2000)</p><p class="source-code">}</p></li>
				<li>As a last step, we control the duty cycle of the channel:<p class="source-code">func (d *Device) setDutyCycle(cycle uint64) {</p><p class="source-code">    value := uint64(d.pwm.Top()) * cycle / (period / </p><p class="source-code">    1000)</p><p class="source-code">    d.pwm.Set(d.channel, uint32(value))</p><p class="source-code">}</p></li>
			</ol>
			<p>Let us try how the <strong class="source-inline">Set</strong> function works. For this, we take a look at the documentation as it the function is very well explained there:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/Figure_3.12_B16555.jpg" alt="Figure 3.12 – The pwm.Set() documentation&#13;&#10;" width="482" height="70"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – The pwm.Set() documentation</p>
			<p>Now let us also create an alternative example program that uses the new driver. To do so, create a new folder named <strong class="source-inline">controlling-servo-pwm</strong> inside the <strong class="source-inline">Chapter03</strong> folder and place the following code into the <strong class="source-inline">main</strong> function:</p>
			<p class="source-code">servo := servopwm.NewDevice(<strong class="bold">machine.Timer1, machine.D9</strong>)</p>
			<p class="source-code">err := servo.Configure()</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">    for {</p>
			<p class="source-code">        println("could not configure servo:", err.Error())</p>
			<p class="source-code">        time.Sleep(time.Second)</p>
			<p class="source-code">}</p>
			<p class="source-code">}</p>
			<p class="source-code">for {</p>
			<p class="source-code">    servo.Left()</p>
			<p class="source-code">    time.Sleep(time.Second)</p>
			<p class="source-code">    servo.Center()</p>
			<p class="source-code">    time.Sleep(time.Second)</p>
			<p class="source-code">    servo.Right()</p>
			<p class="source-code">    time.Sleep(time.Second)</p>
			<p class="source-code">}</p>
			<p>We are using the <strong class="source-inline">machine.Timer1</strong> in the preceding example, as the <strong class="source-inline">Timer1</strong> is a 16-bit timer, which is usable in combination with the <strong class="source-inline">machine.D9</strong> pin. <strong class="source-inline">Timer0</strong> and <strong class="source-inline">Timer2</strong> are 8-bit timers used by the other PWM pins.</p>
			<p>Excellent! I have also added alternative implementations that use hardware PWM based driver instead of the software emulated driver we have in the preceding code, for all following projects in this chapter. You can find them in the GitHub repository in the <strong class="source-inline">Chapter03</strong> folder. I strongly advice to use this implementation of the servomotor driver instead of the one we created first, as this implementation works way better on the Arduino UNO compared to the software emulated PWM driver that we wrote first. Implementing a software emulation of the PWM interface is still a good way to understand how PWM works internally. I have also implemented an alternative program for the final project of this chapter that uses the hardware PWM servo driver. If you cannot build the projects that use the new driver, then the PWM refactoring has not yet made its way onto the TinyGo release branch. But I am very sure, that this feature is going to be released this year (2021).</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Building a safety lock using a keypad</h1>
			<p>We now know<a id="_idIndexMarker184"/> how to read input from a keypad and how to control a servomotor. We are going to use this knowledge to build a safety lock that opens when the correct passcode has been entered through the keypad. As we wrote libraries to control the servo and read data from the keypad, we only need to write the logic to check a passcode and light up LEDs. We are going to let the red LED blink each time a key is being pressed. When we enter a wrong passcode, we light up the red LED for 3 seconds. When we enter the correct passcode, we light up the green LED for 3 seconds and trigger the servomotor.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Building the circuit</h2>
			<p>We are going <a id="_idIndexMarker185"/>to reuse the circuits we built in the previous sections of this chapter. As we already have a servo and the keypad wired, we just have to add the LEDs and the resistors. </p>
			<p>To build the final circuit, follow these steps:</p>
			<ol>
				<li value="1">Connect a GND port from the Arduino Uno with the GND lane on the power bus.</li>
				<li>Place a red LED with the cathode in <em class="italic">G7</em> and the anode in <em class="italic">G8</em>.</li>
				<li>Place a green LED with the cathode in <em class="italic">G11</em> and the anode in <em class="italic">G12</em>.</li>
				<li>Connect <em class="italic">F7</em> with ground on the power bus using a jumper wire.</li>
				<li>Connect <em class="italic">F11</em> with ground on the power bus using a jumper wire.</li>
				<li>Use a 220 Ohm resistor to connect <em class="italic">D8</em> with <em class="italic">F8</em>.</li>
				<li>Use a 220 Ohm resistor to connect <em class="italic">D12</em> with <em class="italic">F12</em>.</li>
				<li>Connect pin <em class="italic">D12</em> from the Arduino Uno with <em class="italic">A12</em> using a jumper wire.</li>
				<li>Connect pin <em class="italic">D13</em> from the Arduino Uno with <em class="italic">A8</em> using a jumper wire.</li>
			</ol>
			<p>Our circuit should now look like the circuit in the following screenshot:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/Figure_3.13_B16555.jpg" alt="Figure 3.13 – Keypad, servomotor, and LED circuit&#13;&#10;" width="901" height="861"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Keypad, servomotor, and LED circuit</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Writing the logic</h2>
			<p>As we have <a id="_idIndexMarker186"/>successfully wired our circuit, we can now start to write the logic for our program. We start by creating a new folder named <strong class="source-inline">safety-lock-keypad</strong> inside the <strong class="source-inline">Chapter03</strong> folder and create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function inside the new folder. Our project structure should now look like the following:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="Images/Figure_3.14_B16555.jpg" alt="Figure 3.14 – Project structure for safety lock program&#13;&#10;" width="312" height="177"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Project structure for safety lock program</p>
			<p>As we can reuse our libraries, we just have to concern ourselves with the actual passcode logic. To implement the logic, use the following steps:</p>
			<ol>
				<li value="1">Import <strong class="source-inline">keypad</strong> and the <strong class="source-inline">servo</strong> driver. Then, you need to adjust the paths to match the paths to the packages in your <strong class="source-inline">Gopath</strong>:<p class="source-code">"https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03/keypad"</p><p class="source-code">"https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03/servo"</p></li>
				<li>Inside <a id="_idIndexMarker187"/>the <strong class="source-inline">main</strong> function, we start by initializing <strong class="source-inline">keypadDriver</strong>:<p class="source-code">keypadDriver := keypad.Driver{}</p><p class="source-code">keypadDriver.Configure(machine.D2, machine.D3, machine.</p><p class="source-code">    D4, machine.D5, machine.D6, machine.D7, machine.D8, </p><p class="source-code">    machine.D9)</p></li>
				<li>Now, we initialize <strong class="source-inline">servoDriver</strong>:<p class="source-code">servoDriver := servo.Driver{}</p><p class="source-code">servoDriver.Configure(machine.D11)</p></li>
				<li>Initialize a new <strong class="source-inline">outPutConfig</strong>:<p class="source-code">outPutConfig := machine.PinConfig{Mode: machine.</p><p class="source-code">                PinOutput}</p></li>
				<li>Initialize both LEDs:<p class="source-code">led1 := machine.D12</p><p class="source-code">led1.Configure(outPutConfig)</p><p class="source-code">led2 := machine.D13</p><p class="source-code">led2.Configure(outPutConfig)</p></li>
				<li>Initialize the passcode with the value <strong class="source-inline">133742</strong>:<p class="source-code">const passcode = "133742"</p></li>
				<li>Initialize a<a id="_idIndexMarker188"/> new variable named <strong class="source-inline">enteredPasscode</strong> with an empty string as the value:<p class="source-code">enteredPasscode := ""</p></li>
				<li>Read the keypad input:<p class="source-code">for {</p><p class="source-code">    key := keypadDriver.GetKey()</p></li>
				<li>Check whether a key was pressed and print the pressed key to the serial port, while appending the pressed key to <strong class="source-inline">enteredPasscode</strong>:<p class="source-code">    if key != "" {</p><p class="source-code">        println("Button: ", key)</p><p class="source-code">        enteredPasscode += key</p></li>
				<li>Light up the red LED to provide visual feedback and close the <strong class="source-inline">if</strong> statement:<p class="source-code">        led2.High()</p><p class="source-code">        time.Sleep (time.Second / 5)</p><p class="source-code">        led2.Low()</p><p class="source-code">}</p></li>
				<li>Check whether <strong class="source-inline">enteredPasscode</strong> has same length as <strong class="source-inline">passcode</strong>:<p class="source-code">    if len(enteredPasscode) == len(passcode) {</p></li>
				<li>If <strong class="source-inline">enteredPasscode</strong> matches the <strong class="source-inline">passcode</strong> value, print <strong class="source-inline">Success</strong> to the serial port , reset the <strong class="source-inline">enteredPasscode</strong> and trigger the servomotor:<p class="source-code">    if enteredPasscode == passcode {</p><p class="source-code">        println("Success") </p><p class="source-code">        enteredPasscode = ""</p><p class="source-code">        servoDriver.Right()</p></li>
				<li>Light up the green LED to give visual feedback for the success and handle the incorrect passcode case with <strong class="source-inline">else</strong>:<p class="source-code">        led1.High()</p><p class="source-code">        time.Sleep(time.Second * 3)</p><p class="source-code">        led1.Low()</p><p class="source-code">} else {</p></li>
				<li>Print <strong class="source-inline">Fail</strong> and the entered passcode to the serial port , that helps us, when debugging the program and also reset the <strong class="source-inline">enteredPasscode</strong>:<p class="source-code">        println("Fail")</p><p class="source-code">        println("Entered Password: ", enteredPasscode)</p><p class="source-code">        enteredPasscode = ""</p></li>
				<li>Light up the red LED to give visual feedback for the failure and close the <strong class="source-inline">else</strong> and <strong class="source-inline">if</strong> cases:<p class="source-code">        led2.High()</p><p class="source-code">        time.Sleep(time.Duration(time.Second * 3))</p><p class="source-code">        led2.Low()</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>Sleep for <strong class="source-inline">50</strong> milliseconds and close the <strong class="source-inline">for</strong> loop. This helps to debounce the keypresses:<p class="source-code">time.Sleep(50 * time.Millisecond)</p><p class="source-code">}</p></li>
			</ol>
			<p>Great, we have <a id="_idIndexMarker189"/>now written the complete logic for our final project in this chapter. Now flash the program using the following command: </p>
			<p class="source-code">tinygo flash –target=arduino Chapter03/safety-lock-keypad/main.go</p>
			<p>As we have now successfully flashed the program, open PuTTy and open the <strong class="bold">Microcontroller</strong> serial session by loading your saved profile. Now enter a random passcode to let the program fail. The red LED should light up for 3 seconds and the output in PuTTy should look as in the following screenshot:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="Images/Figure_3.15_B16555.jpg" alt="Figure 3.15 – Incorrect input&#13;&#10;" width="514" height="195"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Incorrect input</p>
			<p>Now, let's try the<a id="_idIndexMarker190"/> correct passcode, so enter <strong class="source-inline">133742</strong> as the passcode. The output should now look similar to the following screenshot:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="Images/Figure_3.16_B16555.jpg" alt="Figure 3.16 – Correct input&#13;&#10;" width="506" height="273"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Correct input</p>
			<p>Excellent, we <a id="_idIndexMarker191"/>have successfully built a circuit that accepts a passcode and triggers a servomotor when the correct passcode has been entered. </p>
			<p>You can find a alternative implementation that uses the new refactored PWM jere: <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go</a></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>Summary</h1>
			<p>In this chapter, we have learned how to write messages to the serial port and how to configure PuTTy to monitor messages on the serial port. We have then used this knowledge to output keypresses on a keypad that we controlled using a driver that we wrote. During that procedure, we learned how to write drivers for devices that currently have no official drivers and also learned about the contribution process of the driver's repository from TinyGo. </p>
			<p>Then we learned how to control a servomotor and wrote a library to do so. As the last step, we combined everything we learned in this chapter to build a safety lock that accepts a passcode to open up the lock. This knowledge can be very useful if you ever want to build a door lock or a flight control system, where you need to control servomotors. The keypad can also be used as a gamepad, where you use the keys as input. As a bonus, we also wrote two drivers that we can reuse in all upcoming projects after finishing the book.</p>
			<p>In the next chapter, we are going to learn how to read sensor values using ADC pins, how to find thresholds in values, how to control a pump, and how to use relays and buzzers. </p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Questions</h1>
			<ol>
				<li value="1">Having learned about the coordinate system we used for the keypad, what are the coordinates for key 3? </li>
				<li>In our final project, we checked whether the input is correct when the correct passcode length has been reached. How would you change the code to get it to check whether the passcode is correct when the key number has been pressed?</li>
			</ol>
		</div>
	</div></body></html>