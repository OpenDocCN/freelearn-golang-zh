- en: '*Chapter 3*: Building a Safety Lock Using a Keypad'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We gained basic knowledge of using LEDs, GPIO ports, and resistors in the last
    chapter. We also learned how to handle input and output. In this chapter, we are
    going to build a safety lock using a keypad. We will be able to input a passcode
    in the keypad that triggers a servomotor to unlock a lock. This will be achieved
    by splitting up the project into individual steps and putting it all together
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, we will know how to write information to
    the serial port and how to monitor this information. This is a great way to easily
    debug an application. Then, we are going to write our own driver for a 4x4 keypad,
    which can be used as passcode input in our case. This 4x4 keypad can also be used
    as controller input, or as input to start different parts of a program. With that
    covered, we are going to write the logic to control a servomotor. Servomotors
    can be used as a lock mechanism and are also often used in remote-controlled planes.
    In the end, we will have a project where we can set up a passcode, enter the passcode,
    and trigger the servomotor if the input was correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the serial port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the serial port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring input from a keypad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding drivers for TinyGo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a servomotor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a safety lock using a keypad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to need the following components for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Uno
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 4x4 membrane keypad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One SG90 servomotor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One green LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14 jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 220 Ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3uN9OAf](https://bit.ly/3uN9OAf)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the serial port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An easy way to debug your programs on a microcontroller is to write messages
    to the serial port. You can later use this technique to debug your program, by
    printing the current step or sensor values, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a small program to see how writing to a serial port is done. We
    start by creating a new folder named `Chapter03` in the project directory, and
    inside this new directory, we create another directory named `writing-to-serial`.
    Now we have to create a new `main.go` file and insert an empty `main()` function.
    The folder structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The folder structure for writing to serial port'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The folder structure for writing to serial port
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We print the word `starting` followed by a space and print the word `program`
    followed by an `\n`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We endlessly loop, print `Hello World`, and sleep for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, flash the program to your microcontroller by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Okay, we now have a program on our controller that prints text to the serial
    port. We have learned about a very convenient way to insert debug logging into
    our programs. In the next section, we are going to learn how to read data from
    the serial port on the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the serial port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are writing debug logs or other messages to the serial port, we need a
    convenient way to monitor these logs. An easy way to monitor the serial port on
    all operating systems is to use PuTTy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at how to install PuTTy on various platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apt`. We can install it using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`brew`. We can install it using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.msi` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have now installed PuTty, it is time to monitor our serial port:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the program from the previous section is flashed on your microcontroller
    and the USB cable is plugged in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is starting PuTTy. As soon as PuTTy is started, click on **Session**
    and select **Serial** for **Connection type**. This should look as in the following
    screenshot:![Figure 3.2 – PuTTy Configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.2 – PuTTy Configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have to choose the serial line. On Windows, this will typically be `/dev/ttyACM0`
    or `/dev/ttyUSB0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we have now successfully configured the session, we can save this configuration.
    To do so, add `Microcontroller` as the name and click on **Save**. This should
    look as in the following screenshot:![Figure 3.3 – PuTTy saving the configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.3 – PuTTy saving the configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we have now saved the configuration, we can reuse it each time we want to
    monitor the serial port. Now select **Microcontroller** from the list and click
    on the **Open** button:![Figure 3.4 – PuTTy Microcontroller session selected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B16555.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.4 – PuTTy Microcontroller session selected
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After clicking on the **Open** button, a new window opens, which shows the
    output from our program. It should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – PuTTy program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – PuTTy program output
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to monitor the output of our programs. Next, we are
    going to learn how to use a 4x4 keypad and monitor button presses.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring input from a keypad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to read input from a 4x4 keypad and print the
    pressed button to the serial port. Since TinyGo does not have a driver for this
    keypad, we will look at how to create a driver. This will help you understand
    the process and you can use this knowledge when you need to use other unsupported
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this exercise, I have also followed the process of adding this to
    the TinyGo codebase and it should be supported in the future. We are going to
    start by learning how to connect the keypad. Then we will move on to writing a
    driver, and then we are going to have a brief look at how new drivers are added
    to TinyGo.
  prefs: []
  type: TYPE_NORMAL
- en: Building the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start off by assembling the circuit. We are going to need a 4x4 keypad and
    eight jumper wires. Although we could use jumper cables to directly wire the keypad
    to the Arduino ports, we are going to wire it through a breadboard. We are going
    to add more components to this in the upcoming sections. Follow these steps to
    correctly wire the keypad:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect pin *D3* to *A32*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D4* to *A31*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D5* to *A30*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D6* to *A29*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D7* to *A28*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D8* to *A27*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D9* to *A26*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D10* to *A25*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E32* with pin *0* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E31* with pin *1* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E30* with pin *2* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E29* with pin *3* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E28* with pin *4* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E27* with pin *5* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E26* with pin *6* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E25* with P pin in *7* on the keypad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Having done this, your circuit should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Keypad circuit – image is taken from Fritzing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Keypad circuit – image is taken from Fritzing
  prefs: []
  type: TYPE_NORMAL
- en: We have now correctly wired the keypad. Before we can go on with implementing
    the code, we need to understand how a 4x4 keypad works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the workings of a 4x4 keypad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a look at the keypad, we realize that it basically consists of **four
    rows** with **four columns** per row. The keypad comes with eight pins. The first
    four pins are used for the rows, and the remaining four are used for the columns.
    To determine which key is being pressed, we just need to find the position of
    the pressed key in this 4x4 coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Button **1**, for example, has the coordinates 0,0 (row 0, column 0), while
    button **D** has the coordinates 3,3 (row 3, column 3).
  prefs: []
  type: TYPE_NORMAL
- en: In the internal circuit of the keypad, the rows are connected to the columns.
    When a button is being pressed, the circuit is closed. When the circuit is closed,
    current flows, which is the signal we can read on a pin. As the keypad is not
    directly connected to GND and VCC, we need to provide the keypad with power. That
    is why four pins will be used as input and four will be used as output pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have dissembled such a 4x4 keypad, to provide a visual of the internal circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Keypad internal circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Keypad internal circuit
  prefs: []
  type: TYPE_NORMAL
- en: As we now know that we basically just have to check each coordinate in this
    4x4 coordinate system for the correct state, we can go on and write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we want to have reusable code, we are going to write a driver package for
    the keypad. The driver will provide an easy-to-use interface while hiding the
    more complicated implementation logic. Doing it this way, we can simply reuse
    the package in later projects even beyond the book. The official TinyGo drivers
    typically provide a constructor-like function that creates a new instance of the
    driver and a `Configure` function that takes care of initialization. We are also
    going to provide a similar API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in our previous projects, we are going to start by creating a new
    folder named `controlling-keypad` inside the `Chapter03` folder. Then, we are
    going to create a `main.go` file with an empty `main` function. Also, we need
    to create a new folder named `keypad` and create a new file named `driver.go`,
    and then name the package `keypad`. Your project structure should now look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Project structure for writing the driver'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Project structure for writing the driver
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to split the logic into the following five parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Driver` variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Configure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetIndices`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetKey`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Driver variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to need some variables inside our `Driver` struct. Follow these
    steps to set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new struct named `Driver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need an `inputEnabled` variable to debounce the keypresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`lastColumn` and `lastRow` are used to save the position of the last keypress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need an array of `machine.Pin` to store the column pins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need an array of `machine.Pin` to store the row pins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use mapping to map the key values to indices (positions):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we are going to initialize the pins and the `Driver` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Configure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start off by creating an empty function named `Configure` that takes eight
    `machine.Pin` function as an argument and is a pointer receiver to `Driver`. This
    should look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to put the initialization logic into this function. To do
    so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the column pins using a PinInputPullup config. The internal pullup
    resistor is going to hold the column to 5 V until a button is being pressed, which
    we then can read as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the column pins to the `columns` array. By doing so, we can later just
    use a loop to iterate over all columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the row pins using the `PinOutput` config:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add all the row pins to the rows array. This enables us to iterate over all
    the rows using a loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the mapping with the key values. We will be mapping the pressed
    column and row index to get the correct key value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize `inputEnabled`, `lastColumn`, and `lastRow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is everything we need to initialize our program to talk to the keypad.
  prefs: []
  type: TYPE_NORMAL
- en: GetIndices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we just need to loop over the arrays and columns and find the pressed key.
    We start by creating a new function named `GetIndices` that returns two integers
    and is a pointer receiver to `Driver`. This should look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, follow these steps to implement the function logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterate over all rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the current `rowPin` to `Low`. We need to do this as we are using internal
    `rowPin` to `High` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate over all columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the current `columnPin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the current `columnPin` is pressed and execute the logic if we
    accept input. Disable accepting input and save the current column and row, and
    then return the indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Accept the input again, if the previous key is not pressed anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `rowPin` to `High` again and close the outer loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return `–1, -1` if no key was pressed and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling this function will now tell us the position of the pressed key in the
    coordinate system. If you want to understand pullup and pulldown resistors in
    more detail, have a look at the following link: [https://www.electronics-tutorials.ws/logic/pull-up-resistor.html](https://www.electronics-tutorials.ws/logic/pull-up-resistor.html).'
  prefs: []
  type: TYPE_NORMAL
- en: GetKey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we are going to create a function that checks the indices of the pressed
    key and maps the indices to the key value. To do so, we start with an empty function
    named `GetKey` that returns a string and is a pointer receiver to `Driver`. This
    should look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this function, we just call the `GetIndices` method, check whether a
    button was pressed, and if a button was pressed, we return the key value as a
    string. This looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, only the `main` logic is missing. Let's look at that next!
  prefs: []
  type: TYPE_NORMAL
- en: main
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We call our initialization logic and loop endlessly to check the pressed key.
    The following steps show how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize `keypadDevice`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, loop endlessly, check for a keypress, and print the value if a key was
    pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! That''s it. Now we can flash the program and monitor the outputs. Flash
    the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open PuTTy and monitor the serial output while pressing keys on the keypad.
    The output should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Keypad output in PuTTy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Keypad output in PuTTy
  prefs: []
  type: TYPE_NORMAL
- en: Great, we have successfully written our own driver to monitor button presses
    on a keypad!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn where to find TinyGo drivers for
    peripheral hardware. We are also going to look at the process of contributing
    to the TinyGo drivers repository.
  prefs: []
  type: TYPE_NORMAL
- en: Finding drivers for TinyGo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of the time of writing, there are 53 devices supported by TinyGo. The driver
    we just wrote, which I am going to contribute to TinyGo, will support 54 devices.
    But where can we find drivers for devices that we want to use? The answer is simple:
    there is a repository for this purpose. You can find it at [https://github.com/tinygo-org/drivers](https://github.com/tinygo-org/drivers).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use such drivers when using different
    types of displays.
  prefs: []
  type: TYPE_NORMAL
- en: Contributing drivers to TinyGo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TinyGo community happily appreciates all contributions. If you develop
    a driver for a device and want to contribute it to TinyGo, you can follow these
    simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an issue and explain what you want to add and how you plan to implement
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fork the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new branch based on the dev branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can find the contribution guidelines at the following link: [https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md](https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md).'
  prefs: []
  type: TYPE_NORMAL
- en: All in all, my personal experience with the TinyGo community has been extremely
    positive. They are very polite and will help you out with any kind of problem.
    I have not encountered a single problem where the community could not give me
    a helpful answer. Don't be afraid to ask a question in an issue or on the TinyGo
    channel in the Gophers slack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please do not ask any questions that are directly related to this book in any
    of the official TinyGo channels, such as Slack or GitHub. If you have any questions
    regarding this book, you can raise an issue on the accompanying GitHub repository
    or send an email to me.
  prefs: []
  type: TYPE_NORMAL
- en: As we now know how keypads work and where to find drivers, we can go on with
    the next part of our safety lock.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling a servomotor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are now able to read the input to the keypad, the thing that is missing
    to build a safety lock is some kind of motor. For that case, we are going to use
    an SG90 servomotor. As of the time of writing, the timings on the Arduino Uno
    are not accurate enough to completely control the SG90 servomotor, but that is
    not a problem for our use case. We are just going to move the servo in one direction,
    which is clockwise. Also, there is currently no official driver for the SG90 servomotor,
    so we are going to write our own!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SG90 servomotors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SG90 servomotors are controlled by **Pulse Width Moduluation** (**PWM**). Basically,
    the SG90 reads inputs in a 50 Hz period. During this period, we can tell the servomotor
    to adjust itself to a certain angle by setting a signal for a certain amount of
    time. The signal length is called the *duty cycle*. After the duty cycle, we wait
    for the rest of the period. Depending on the duty cycle (the **pulse width**),
    the SG90 will adjust its angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SG90 can be adjusted to the following three positions:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 degrees (center) using a 1.5 ms pulse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: + 90 degrees (right) using a 2 ms pulse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- 90 degrees (left) using a 1 ms pulse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to adjust the servomotor to all angles in between this by
    doing some math on the pulse width sizes, but we do not need to do that for our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SG90 typically has three wires:'
  prefs: []
  type: TYPE_NORMAL
- en: Black/brown for ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red for VCC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orange/yellow for the PWM signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will build on top of our last example. We just have to add the servomotor
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the 5 V port from the Arduino Uno to the positive lane on the power
    bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND port from the Arduino Uno to the ground lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND wire from the SG90 to the ground lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the VCC wire from the SG90 to the positive lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the PWM wire from the SG90 to pin *D11* on the Arduino Uno.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our circuit should now look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Keypad and servomotor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Keypad and servomotor
  prefs: []
  type: TYPE_NORMAL
- en: Excellent. Before we can start programming, we should learn something about
    PWM pins on the Arduino Uno. Only six pins of the GPIO ports are capable of PWM.
    The pins are marked with a **~** symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: On the Arduino Uno, you can use pins *D3*, *D5*, *D6*, *D9*, *D10*, and *D11*
    for PWM.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the servo control logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to create a new folder named `controlling-servo` inside the `Chapter03`
    folder. Next, we create a new `main.go` file inside the new folder and insert
    an empty `main` function. Also, we need to create a new folder named `servo` with
    a new `driver.go` file inside the `servo` package. Our project structure should
    now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Project structure for servo control logic'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Project structure for servo control logic
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'PWM is currently being reworked. In the future handling, PWM devices will be
    much simpler. It is also being handled by hardware PWM instead of emulating the
    PWM behavior. You can check the progress at the following pull request: [https://github.com/tinygo-org/tinygo/pull/1121](https://github.com/tinygo-org/tinygo/pull/1121).'
  prefs: []
  type: TYPE_NORMAL
- en: The driver that we are now building has the main purpose of teaching us how
    PWM actually works and is going to work better on all microcontrollers that are
    not based on the 8-bit AVR architecture, such as the ATmega328P, which is onboard
    the Arduino Uno. This is due to the fact that the AVR support is still experimental,
    although it is being improved with nearly every release of TinyGo. As soon as
    the PR mentioned previously is merged, I recommend using a driver that is based
    on that hardware PWM support for controlling servos.
  prefs: []
  type: TYPE_NORMAL
- en: Also be aware that as of the time of writing, you manually need to reset the
    servo when it reaches the rightmost position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `driver.go` file, we need to use the following steps to let our
    servo rotate a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare package-level constants for the duty cycles and `rightRemainingPeriod`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new struct named `Driver` that has `machine.Pin` as a member:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new, empty function named `Configure` that takes `machine.Pin` as
    a parameter and is a pointer receiver to `Driver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure pin as output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop four times to rotate the motor only about 30 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a signal for the duty cycle, pull it down, and sleep for the rest of the
    period:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we can try out our library, we need to write a small example program.
    To do so, put the following snippet inside the `main.go` file inside the controlling
    `servo` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just need to try that program by flashing it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, this was the first time that we moved something using code.
    As we have now learned how to rotate the servo a bit and how to read inputs from
    a keypad, the next step is to put everything together.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the refactoring of the PWM is merged to upstream and released in
    a TinyGo version, you do not want to use the previous driver anymore. For that
    case, we create a new driver that makes use of hardware PWM instead of emulating
    the behavior. So go on and create a new folder named `servo-pwm` and create a
    new `driver.go` file inside. Then follow these steps to implement the better driver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the period, which is 20.000 microsecond and create a new `Device`
    struct, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to add a constructor function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we configure the PWM interface. We need to set the period and get the channel
    for our output pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we add functions that lets us set the position of the servomotor. We pass
    in the microseconds for the duty cycles as parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a last step, we control the duty cycle of the channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us try how the `Set` function works. For this, we take a look at the documentation
    as it the function is very well explained there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The pwm.Set() documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – The pwm.Set() documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us also create an alternative example program that uses the new driver.
    To do so, create a new folder named `controlling-servo-pwm` inside the `Chapter03`
    folder and place the following code into the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `machine.Timer1` in the preceding example, as the `Timer1`
    is a 16-bit timer, which is usable in combination with the `machine.D9` pin. `Timer0`
    and `Timer2` are 8-bit timers used by the other PWM pins.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! I have also added alternative implementations that use hardware PWM
    based driver instead of the software emulated driver we have in the preceding
    code, for all following projects in this chapter. You can find them in the GitHub
    repository in the `Chapter03` folder. I strongly advice to use this implementation
    of the servomotor driver instead of the one we created first, as this implementation
    works way better on the Arduino UNO compared to the software emulated PWM driver
    that we wrote first. Implementing a software emulation of the PWM interface is
    still a good way to understand how PWM works internally. I have also implemented
    an alternative program for the final project of this chapter that uses the hardware
    PWM servo driver. If you cannot build the projects that use the new driver, then
    the PWM refactoring has not yet made its way onto the TinyGo release branch. But
    I am very sure, that this feature is going to be released this year (2021).
  prefs: []
  type: TYPE_NORMAL
- en: Building a safety lock using a keypad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to read input from a keypad and how to control a servomotor.
    We are going to use this knowledge to build a safety lock that opens when the
    correct passcode has been entered through the keypad. As we wrote libraries to
    control the servo and read data from the keypad, we only need to write the logic
    to check a passcode and light up LEDs. We are going to let the red LED blink each
    time a key is being pressed. When we enter a wrong passcode, we light up the red
    LED for 3 seconds. When we enter the correct passcode, we light up the green LED
    for 3 seconds and trigger the servomotor.
  prefs: []
  type: TYPE_NORMAL
- en: Building the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to reuse the circuits we built in the previous sections of this
    chapter. As we already have a servo and the keypad wired, we just have to add
    the LEDs and the resistors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the final circuit, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect a GND port from the Arduino Uno with the GND lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a red LED with the cathode in *G7* and the anode in *G8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a green LED with the cathode in *G11* and the anode in *G12*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *F7* with ground on the power bus using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *F11* with ground on the power bus using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a 220 Ohm resistor to connect *D8* with *F8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a 220 Ohm resistor to connect *D12* with *F12*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D12* from the Arduino Uno with *A12* using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D13* from the Arduino Uno with *A8* using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our circuit should now look like the circuit in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Keypad, servomotor, and LED circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Keypad, servomotor, and LED circuit
  prefs: []
  type: TYPE_NORMAL
- en: Writing the logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have successfully wired our circuit, we can now start to write the logic
    for our program. We start by creating a new folder named `safety-lock-keypad`
    inside the `Chapter03` folder and create a new `main.go` file with an empty `main`
    function inside the new folder. Our project structure should now look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Project structure for safety lock program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Project structure for safety lock program
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can reuse our libraries, we just have to concern ourselves with the actual
    passcode logic. To implement the logic, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `keypad` and the `servo` driver. Then, you need to adjust the paths
    to match the paths to the packages in your `Gopath`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, we start by initializing `keypadDriver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we initialize `servoDriver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a new `outPutConfig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize both LEDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the passcode with the value `133742`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a new variable named `enteredPasscode` with an empty string as the
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the keypad input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether a key was pressed and print the pressed key to the serial port,
    while appending the pressed key to `enteredPasscode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Light up the red LED to provide visual feedback and close the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether `enteredPasscode` has same length as `passcode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `enteredPasscode` matches the `passcode` value, print `Success` to the serial
    port , reset the `enteredPasscode` and trigger the servomotor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Light up the green LED to give visual feedback for the success and handle the
    incorrect passcode case with `else`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print `Fail` and the entered passcode to the serial port , that helps us, when
    debugging the program and also reset the `enteredPasscode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Light up the red LED to give visual feedback for the failure and close the
    `else` and `if` cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sleep for `50` milliseconds and close the `for` loop. This helps to debounce
    the keypresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great, we have now written the complete logic for our final project in this
    chapter. Now flash the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have now successfully flashed the program, open PuTTy and open the **Microcontroller**
    serial session by loading your saved profile. Now enter a random passcode to let
    the program fail. The red LED should light up for 3 seconds and the output in
    PuTTy should look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Incorrect input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Incorrect input
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try the correct passcode, so enter `133742` as the passcode. The
    output should now look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Correct input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Correct input
  prefs: []
  type: TYPE_NORMAL
- en: Excellent, we have successfully built a circuit that accepts a passcode and
    triggers a servomotor when the correct passcode has been entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a alternative implementation that uses the new refactored PWM
    jere: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to write messages to the serial port and
    how to configure PuTTy to monitor messages on the serial port. We have then used
    this knowledge to output keypresses on a keypad that we controlled using a driver
    that we wrote. During that procedure, we learned how to write drivers for devices
    that currently have no official drivers and also learned about the contribution
    process of the driver's repository from TinyGo.
  prefs: []
  type: TYPE_NORMAL
- en: Then we learned how to control a servomotor and wrote a library to do so. As
    the last step, we combined everything we learned in this chapter to build a safety
    lock that accepts a passcode to open up the lock. This knowledge can be very useful
    if you ever want to build a door lock or a flight control system, where you need
    to control servomotors. The keypad can also be used as a gamepad, where you use
    the keys as input. As a bonus, we also wrote two drivers that we can reuse in
    all upcoming projects after finishing the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to read sensor values using ADC
    pins, how to find thresholds in values, how to control a pump, and how to use
    relays and buzzers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having learned about the coordinate system we used for the keypad, what are
    the coordinates for key 3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our final project, we checked whether the input is correct when the correct
    passcode length has been reached. How would you change the code to get it to check
    whether the passcode is correct when the key number has been pressed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
