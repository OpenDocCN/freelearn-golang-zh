- en: '*Chapter 4*: Building a Plant Watering System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to write to the serial port and how
    to monitor the serial port on our computers. Furthermore, we learned how to write
    drivers for components, which have not yet been implemented by the TinyGo community,
    and we used this knowledge to write a driver for a 4x4 keypad and a servo motor
    in [*Chapter 3*](B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058), *Building a
    Safety Lock Using a Keypad*.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to build on top of this knowledge in this chapter by introducing
    a new type of pin and we are going to build an automated plant watering system
    using some new devices. We will be able to pump water from a container into a
    plant's soil, measure the soil's moisture, check the water level of a container,
    and let a buzzer beep when the water level in the container is below a certain
    threshold. This will be achieved by splitting the project up into single steps
    and putting it all together at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, we will know how to read input from analog
    pins, how to measure thresholds in sensor data, how to let a buzzer beep, and
    how to control a pump using relays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading soil moisture sensor data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading water level sensor data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a buzzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a pump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watering your plants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to need the following components for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino UNO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capacitive Soil Moisture Sensor v1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K-0135 Water Level Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive buzzer with 2 pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro submersible water pump DC 3V-5V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard power supply module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 100 Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components can usually be found in online stores and also in local electronic
    supply stores. Most components used in this book are also part of so-called **Arduino
    Starter Kits**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3tlhRnx](https://bit.ly/3tlhRnx)'
  prefs: []
  type: TYPE_NORMAL
- en: Reading soil moisture sensor data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When automatically watering plants, we need to know when we have to add water
    to the soil. An easy way to detect that the soil is too dry is to use a soil moisture
    sensor. We are going to use a capacitive soil moisture sensor in this project,
    which provides the readings as an analog signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sensor has the following technical specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: A 3.3 V to 5.0 V supply range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 3.3 V operating range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An analog output in the range of 1.5 V to 3.3 V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operating current of 5 mA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensors from other manufacturers might differ slightly in these specs. Datasheets
    are usually provided by the vendor you buy the hardware from. We'll now start
    off by assembling the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We only need some cables, the sensor itself, and a breadboard to begin with.
    Depending on the manufacturer of the sensor, the labels on the port of your sensor
    might differ. The one I use has the following labels:'
  prefs: []
  type: TYPE_NORMAL
- en: AOUT (short for **Analog out**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VCC (+) (short for **Voltage Common Collector**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND (-) (stands for **Ground**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now assemble the circuit as per the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the *GND* port to *GND* on the power bus using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect port *D2* to *A1* on the breadboard using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect port *A5* to *A2* on the breadboard using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E1* on the breadboard to *AOUT* on the sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E2* to *VCC* on the sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *GND* from the power bus with *GND* on the sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your circuit should now look similar to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Soil Sensor Circuit  image taken from Fritzing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Soil sensor circuit – image taken from Fritzing
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Soil Sensor Circuit image taken from Fritzing
  prefs: []
  type: TYPE_NORMAL
- en: Great! We have successfully assembled the circuit. We are going to use this
    circuit to create a small sample project to read values from the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Finding thresholds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next task is to find out the values that indicate the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: Dry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In water
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check the dryness, we need to create a new folder for this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off by creating a new folder named `Chapter04`. Inside this folder, create
    a new folder named `soil-moisture-sensor-thresholds` and inside this folder, create
    a new `main.go` file and insert an empty `main()` function. The folder structure
    should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Folder structure for Soil moisture sensor threshold'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Folder structure for Soil moisture sensor threshold
  prefs: []
  type: TYPE_NORMAL
- en: 'Now follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `machine` package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the registers needed for ADC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new variable named `soilSensor` of the type `machine.ADC` with `Pin
    machine.ADC5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the pin so it is able to read analog values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the machine D2 pin as output and set it to `high`. We do not store
    this inside a new variable, as we will never change the state of the pin again.
    We only use it to provide currency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the sensor value two times a second in an endless loop and print it to
    the serial port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great, we have successfully written our first program that reads sensor data
    from an analog pin. Now we need to ascertain threshold values. To do so, first
    flash the program onto your Arduino using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open up PuTTY and select the microcontroller profile to see the sensor
    readings. This should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Soil moisture sensor output in PuTTY'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Soil moisture sensor output in PuTTY
  prefs: []
  type: TYPE_NORMAL
- en: The value is pretty stable at **37888**. You might notice some small changes
    in the value between the readings. Just take the highest value you see in that
    case.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to declare **37888** as the threshold for dry values. So, everything
    equal or above this value can be considered completely dry. The values that you
    receive from your sensor might differ a bit, so you can just do the same; have
    a look at the values, and take the lowest one as your threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Take care that your sensor is completely dry and clean. Otherwise, you might
    get in trouble with your dry value.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We just managed to find out the value for completely dry soil. Now
    we need to find a value for being completely wet (in water).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a glass of water and put the sensor in there, while watching the sensor
    readings in PuTTY. **Be really careful that you only put the sensor so deep in
    the water that it reaches the white line on it!** Do not let the water touch the
    electronics above! Check the following figure for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Capacitive Soil Moisture Sensor in a glass of water'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Capacitive Soil Moisture Sensor in a glass of water
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the sensor readings in PuTTY – you can find them in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Soil sensor readings from inside a glass of water in PuTTY'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Soil sensor readings from inside a glass of water in PuTTY
  prefs: []
  type: TYPE_NORMAL
- en: This time we take the highest value we can find in PuTTY as our threshold, which
    in my case is **17856**. We have used GPIO pins in all previous chapters, but
    we have not yet used the **Analog Digital Converter**, so let's understand how
    the **Analog Digital Converter** (**ADC**) works on Arduino before we continue
    to write a library for the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ADC in TinyGo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arduino UNO ADC has 10-bit precision. The value returned by the `Get()`
    function is of the type `uint16`. So, internally, the `Get()` function tells the
    ADC to scale the 10-bit value to a 16-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, we can use the following equation to get an ADC result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know that the Arduino UNO has 10-bit precision and the voltage is about
    `5V`, we can insert this into the equation to get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say the analog voltage measured is `3.33V`. This will result in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we do some math equation magic and get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This result will now scale to 16 bits, which equals a bit shift left by 6 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result we would get from TinyGo would be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since we have now discovered how ADC works, we can now continue to write a small
    library that will help us use the sensor later on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a library for the sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As having reusable code is a nice thing, we will now go on to write a small
    library, to reuse it in the last part of this chapter, *Watering your plants*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need to create a new folder named `soil-moisture-sensor` inside
    the `Chapter04` folder. In our newly created folder, we create a new empty `driver.go`
    file and name the package `soil`. The structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Folder structure for soil moisture sensor library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Folder structure for soil moisture sensor library
  prefs: []
  type: TYPE_NORMAL
- en: We want to have an interface that provides a function to get the current `MoistureLevel`,
    instance which will be an enum-like type. Also, we want to provide functionality
    to turn the sensor on and off, so it does not draw current all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new interface named `SoilSensor` with `Get()`, `Configure()`, `On()`,
    and `Off()` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new struct named `soilSensor`. This struct is going to contain the
    pin that is being used to turn the sensor on and off and the pin that is being
    used to read the sensor value. Also, we want to be able to configure thresholds
    that are used to identify whether the sensor is completely dry or is in water:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add members that save the thresholds for `completelyDry` and `water`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an enum-like type so we can easily check for these values when using
    the library. We chose six `MoistureLevel`categories here, to have a clear distinction
    between the different states of the soil:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a constructor function that takes `waterThreshold`, `dryThreshold`,
    `dataPin`, and `voltagePin` and returns `SoilSensor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the thresholds and create `category`, which will later be used to calculate
    the `category` value. As we want to have six categories, we divide the values
    by six, which have been read from where the sensor lies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set all values and return a pointer to a new instance of `soilSensor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new `func` named `Get`, which is in a function receiver to a pointer
    to `soilSensor` and returns `MoistureLevel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the value from `sensor` and save it the new variable value of type `float32`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the value is greater than or equal to `completelyDryThreshold`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether `value` falls into the second category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether `value` falls into the third category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether `value` falls into the fourth category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether `value` falls into the fifth category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only remaining possible state is `Water`, so we use the default case here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function named `Configure` that has a function receiver for a pointer
    of `soilSensor`. We use a pointer receiver as we set values on the `soilSensor`
    instance, which we would otherwise lose outside of this function scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure `dataPin` for ADC usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `voltage` pin as output and set it to `Low`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function to turn on the voltage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function to turn off the voltage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the complete logic we need for our library. Let's test our code in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will write an example to test the new library. To do so, we need to
    create a new folder named `soil-moisture-sensor-example` inside the `Chapter04`
    folder and create a `main.go` file with an empty `main()` function inside. Your
    project structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Testing the soil moisture sensor library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Testing the soil moisture sensor library
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our new library, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `machine`, `time`, and `soil-moisture-sensor` packages as shown
    in the following code. Note that the path to your library will be a bit different,
    depending on where it lies on your filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, initialize the ADC interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `SoilSensor`. The values in this example differ slightly
    from the ones measured in the last example. These values tend to trigger the `Water`
    and `CompletelyDry` states earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we call the `Configure` function, which initializes our pins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start an endless loop and turn on the sensor, and wait a brief moment to let
    the readings stabilize a bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then switch over the result from the `Get()` function and print a string depending
    on the case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn the sensor off again and wait a second until the next reading starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we now have the complete code to test our library, let''s flash it onto
    our Arduino and let''s check the output in PuTTY. Use the following command to
    flash it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The best thing to do now is to actually put the sensor in very dry soil while
    having an eye on the readings. Then add some water, to check whether you will
    see the `Wet`, `Very Wet`, and maybe the `Water` states. Before we continue with
    the next section, we should definitely check it. If the readings seem odd, try
    to adjust the thresholds, which are handled in the library in the `NewSoilSensor`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you could harm plants by pouring too much water into the soil.
    Also, it is not necessary to stick the sensor all the way down into the soil until
    it reaches the white line. I suggest leaving some air between the white line and
    the soil so you have some buffer between the electronics and the soil. When I
    did my testing, I achieved good results when having about 1 cm of air as a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to calibrate the Capacitive Soil Moisture sensor, used
    the ADC interface for the first time, and written a new library. Using this library,
    we are able to tell the humidity state of the soil. In the next section, we are
    going to learn how to use a water level sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Reading water level sensor data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we plan to have a water tank later in the chapter, it will be beneficial
    to have a water level sensor, so we can tell when the tank is empty. We''ll start
    off by adding the sensor to our existing circuit. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect pin *A4* from the Arduino with *F22* on the breadboard using a jumper
    cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *D3* from the Arduino with *F21* on the breadboard using a jumper
    cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J22* on the breadboard with the *S* (Signal) port on the sensor using
    a jumper cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J21* on the breadboard with the *+* (*VCC*) port on the sensor using
    a jumper cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *- GND* from the sensor with *GND* on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result should now look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Water level sensor – image is taken from Fritzing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Water level sensor – image is taken from Fritzing
  prefs: []
  type: TYPE_NORMAL
- en: After assembling this, we can continue to also create a small library for this
    sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a water level sensor library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many different types of water level sensors. The cheap ones that
    are often part of Arduino Starter Kits often suffer from corrosion. To prevent
    that, we are going to also add the possibility to turn it on and off. But first,
    we are going to have a look at the technical data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating voltage**: 5 V'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating current**: Less than 20 mA'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working temperature**: 10° to 30°'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, having this sensor draws less than 20 mA current. We can again use a *GPIO*
    pin to power it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a new folder named `water-level-sensor` inside the `Chapter04`
    folder. Inside the new folder, create a new file named `driver.go` and name the
    package `waterlevel`. The folder structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Folder structure for water level sensor library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Folder structure for water level sensor library
  prefs: []
  type: TYPE_NORMAL
- en: 'As the project structure is now set up, we can go on to implement the actual
    library. Just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `machine` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new interface named `WaterLevel` with the following functions. The
    functions are going to be explained when we implement them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a struct named `waterLevel` with the following members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new constructor-like function that takes `dryThreshold`, `dataPin`,
    and `voltagePin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `IsEmpty` check. We''ll just check whether the sensor reading is lower
    than our threshold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the sensor pin for ADC usage and configure the voltage pin as output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn the power on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn the power off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now written the library for the water level sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s write a small example program to test our library. To do so, we
    start by creating a new folder named `water-level-sensor-example` inside the `Chapter04`
    folder. Inside the new folder, create a new `main.go` file with an empty `main`
    function inside. The folder structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Folder structure for testing the library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Folder structure for testing the library
  prefs: []
  type: TYPE_NORMAL
- en: 'As the project structure is now set up, we can go on to write the test code.
    To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the ADC interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `WaterLevelSensor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the pins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We turn the sensor on and then wait a brief moment to let the readings of the
    sensor stabilize before we access it. Then, print the result of `IsEmpty()` every
    second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the water level sensor does not touch any water, the returned value should
    be `0`. We chose `7000` as `dryThreshold` in this case, so the tip of the sensor
    can be inside the water and still be able to tell us it's empty. That will be
    useful later on, in the case when we also need to pump water. This is for when
    the pump should not run when there is not enough water to pump. We should play
    around with this threshold value a bit. Do so by flashing the program to your
    Arduino, check the water presence with the sensor, and when it realizes that there
    is water, change the threshold value and flash again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flash the program by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So we now have written a library that checks whether any kind of water tank
    is empty. In the next section, we are going to use a buzzer to have an audio signal
    when the water tank is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling a buzzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to write a very simple buzzer library. We only want the buzzer
    to make any sound, regardless of the pitch. We start off by adding the buzzer
    to the circuit. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect *D4* from the Arduino to *A31* on the breadboard using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a *100* Ohm resistor to connect *E31* with *G31* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *VCC* pin from the buzzer with *J31*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *GND* pin to *GND* on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The circuit should now look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Buzzer – image taken from Fritzing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Buzzer – image taken from Fritzing
  prefs: []
  type: TYPE_NORMAL
- en: As we have now added the buzzer to the circuit, we can now start to write our
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a buzzer library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The buzzer library will have two functions: `Configure()`, which sets up the
    pin, and the `Beep()` function, which will make the sound.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by creating a new folder named `buzzer` inside the `Chapter04`
    folder. Inside the new folder, create a file named `driver.go` and name the package
    `buzzer`. The project structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FIgure 4.12 – Project structure for buzzer library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: FIgure 4.12 – Project structure for buzzer library
  prefs: []
  type: TYPE_NORMAL
- en: 'Now follow these steps to implement the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an interface named `Buzzer` that has a `Configure` function and a `Beep`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `struct` named `buzzer` that holds `machine.Pin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function named `NewBuzzer` that returns `Buzzer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function named `Configure` that configures `pin` as output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function named `Beep`, which takes `time.Duration` and `amount` of
    the `uint8` type as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop the amount of times and let the buzzer beep and sleep in between:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all for the buzzer library.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to test the library with a small example project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we first create a new folder named `buzzer-example` inside the `Chapter04`
    folder. Inside the new folder, create a new `main.go` file with an empty `main()`
    function in it. The project structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Testing the buzzer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Testing the buzzer
  prefs: []
  type: TYPE_NORMAL
- en: 'Now put the following inside the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a new instance of `buzzer` and configure it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop forever, beep three times for `100` milliseconds, and then sleep for `3`
    seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s all the code we need to test the buzzer. To try this example, flash
    it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When the program runs, you should be able to hear the buzzer. If it does not
    start to make a sound after a brief amount of time, check all the cables and pins
    again.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully written a very simple buzzer library and tested it
    using an example project. In the next section, we are going to control a pump.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling a pump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As pumps tend to draw more current than simple sensors, we are not going to
    power the pump directly through a *GPIO* port. Drawing too much current could
    permanently damage the Arduino. So, we will use an external power supply and a
    relay to power the pump. Before we start assembling the circuit, let's have a
    brief look at how relays work.
  prefs: []
  type: TYPE_NORMAL
- en: Working with relays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A relay that is used for microcontroller projects typically comes mounted on
    a board, which typically has six ports. It has three input ports: *VCC*, *GND*,
    and *Signal*. It also has three output ports: *normally open*, *common*, and *normally
    closed*.'
  prefs: []
  type: TYPE_NORMAL
- en: When a *high signal* is given, the current flows between *normally open* and
    *common*.
  prefs: []
  type: TYPE_NORMAL
- en: When a *low signal* is given, the current flows between *normally closed* and
    *common*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we now know how to use a relay, we can continue to add the new components
    to our circuit. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the *GND* pin from the relay to *GND* on the power bus using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *VCC* pin from the relay to *VCC* on the power bus using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *Signal* (in) pin from the relay to *D5* on the Arduino using a
    jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *VCC* pin of the pump to the *normally open* port on the relay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *GND* pin of the pump to *GND* on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *common* pin of the relay with the *VCC* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *VIN* from the Arduino to *VCC* on the power bus using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your circuit should now look similar to the one in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Full circuit including a pump – image taken from Fritzing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Full circuit including a pump – image taken from Fritzing
  prefs: []
  type: TYPE_NORMAL
- en: With this circuit, we will be able to power the Arduino using an external power
    supply. As we might want to water plants that are not anywhere near a USB port,
    we have connected the *VIN* pin on the Arduino with the *VCC* lane on the power
    bus, which is powered by our external power supply. We will now go on and write
    a library that is able to control the pump.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a pump library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pump library is basically going to have two functions: `Configure`, which
    sets up the pin, and the `Pump` function, which pumps for a given duration and
    a given number of iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a new folder named `pump` inside the `Chapter04` folder.
    Inside the new folder, create a `driver.go` file and name the package `pump`.
    The project structure should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FIgure 4.15 – Project structure for pump library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: FIgure 4.15 – Project structure for pump library
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we have set up the project structure, we can go on to write the code
    to control the pump. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the interface named `Pump`, which has the `Configure` or `Pump` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new `struct` named `pump` that holds `machine.Pin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function named `NewPump` that takes `machine.Pin` and returns a new
    pointer to `pump`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then define a function named `Configure` and set `pin` as the output pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a function named `Pump` and loop it `iterations` times, to set
    `pin` to `high`, sleep for `duration`, and set it back to `low` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This was everything we need for our `pump` library. We could now go on and
    create a small example project to test the library. To do so, we''ll create a
    new folder named `pump-example` inside the `Chapter04` folder and create a `main.go`
    file with an empty `main` function inside. The project structure should now look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Testing the pump'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Testing the pump
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `main` function, we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new instance of `pump` by calling the `NewPump` function and hand
    in `machine.D5` as `pin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop forever and `pump 3` times for `350` milliseconds and `sleep` for `30`
    seconds afterward, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the complete example code to try out our pump.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Due to the laws of physics being the way they are, I would recommend that a
    possible receiving container should always be placed above the upper water level
    of the source container since the water will continue to flow even though the
    pump stopped pumping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now put your pump in a glass of water or some other water tank and try it out
    by flashing the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Use this example to find out good pump duration and iteration times that don't
    pump too much water. Keep in mind that we want to water plants, so this is going
    to help us find good values.
  prefs: []
  type: TYPE_NORMAL
- en: This was the last component we needed. We have learned how to use a relay to
    power and control a pump and we wrote a new library. We are now going to put everything
    together in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Watering your plants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to utilize every component we created in the past sections.
    Putting everything together, we will be building a completely automated plant
    watering system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, we need to create a new folder named `plant-watering-system`
    inside the `Chapter04` folder. Inside the new folder, create a new `main.go` file
    with an empty `main()` function inside. The final project structure should now
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Project structure for plant watering system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Project structure for plant watering system
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside the `main` function, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the `ADC` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a new `soilSensor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a new `waterLevelSensor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a new `pump`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a new `buzzer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn `waterLevelSensor` on and sleep for a brief amount so the readings can
    stabilize:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the water container is empty, turn the sensor off, beep 3 times,
    and then sleep for an hour, before continuing the `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the water container is not empty, turn off `waterLevelSensor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn on `soilSensor` and sleep for a brief amount of time to let the readings
    stabilize:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then switch over the result of `soilSensor.Get()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the soil is `VeryDry` or `CompletelyDry`, turn off the soil sensor and pump
    water:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In all other cases, turn off `soilSensor` and sleep for an hour:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is everything we need for this final project. You can try out the program
    by flashing it onto your Arduino using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that every plant has other needs in terms of water. So, we will
    need to tweak the values for the amount of water pumped to fit the needs of the
    plant being watered.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully built a complete automated plant watering system and
    flashed it onto the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to read sensor values using the ADC interface.
    We also learned how the ADC interface translates voltage to digital values, and
    then we utilized this knowledge to write the `soil moisture sensor` library.
  prefs: []
  type: TYPE_NORMAL
- en: We then wrote the `water level sensor` library by utilizing the knowledge we
    gathered in the first project of this chapter. Then we learned how to use a **buzzer**
    and wrote a very simple library that enables us to let a buzzer create warning
    sounds. After that, we learned how relays work and utilized this knowledge to
    control a **pump** using a library we wrote. At the end of this chapter, we put
    all the libraries in a single project and only had to add a small amount of control
    logic to build the automatic plant watering system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to use supersonic sensors and
    how to control seven-segment displays.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are the water level sensor and soil moisture sensor not permanently powered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is the circuit between *normally open* and *GND* closed in a relay?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Capacitive Soil Moisture Sensor fritzing part was part of a collection
    from the following repository: [https://github.com/OgreTransporter/fritzing-parts-extra](https://github.com/OgreTransporter/fritzing-parts-extra)'
  prefs: []
  type: TYPE_NORMAL
