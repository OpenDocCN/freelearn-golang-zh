<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer081">
			<h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor101"/>Chapter 5</em>: Building a Touchless Handwash Timer</h1>
			<p>In <a href="B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 4</em></a>, <em class="italic">Building a Plant Watering System</em>, we learned how the ADC interface works, and we used that knowledge to write libraries for a capacitive soil moisture sensor and a water level sensor. We also wrote a small library to control a buzzer and learned how relays work and used that knowledge to control a pump using our code. Then we used all this knowledge to build an automated plant watering system.</p>
			<p>In this chapter, we are going to build a touchless handwash timer. After working through this chapter, you will know how ultrasonic sound sensors work and how to measure distance with them. We are going to utilize this knowledge to create a sensor that recognizes a hand that is between 20 and 30 centimeters away from the sensor to start a timer. The timer will then be displayed on a 7-segment display. While implementing this, we will also learn about the MAX7219 chip and how to use it to control different display types.</p>
			<p>In this chapter, we're going to cover the following main topics:  </p>
			<ul>
				<li>Introducing the Arduino Nano 33 IoT</li>
				<li>Measuring distance</li>
				<li>Using a 7-segment display</li>
				<li>Putting it all together</li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Technical requirements</h1>
			<p>We are going to need the following components for this project:</p>
			<ul>
				<li>An Arduino Nano 33 IoT</li>
				<li>An HC-SR04 sensor</li>
				<li>An external power supply module</li>
				<li>HS420561K 4-Digit 7-segment display common cathode</li>
				<li>A MAX7219 or MAX7221 serial input/output common-cathode display driver</li>
				<li>One 10,000 Ohm resistor</li>
				<li>One 1,000 Ohm resistor</li>
				<li>One 2,000 Ohm resistor</li>
				<li>2 breadboards</li>
				<li>Jumper wire cables</li>
			</ul>
			<p>Most of the components are part of the so-called Arduino Starter Kit. If you do not have such a set, they can be acquired at any electronics supply store.</p>
			<p>You can find the code for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05</a></p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3e2IYgG">https://bit.ly/3e2IYgG</a></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Introducing the Arduino Nano 33 IoT</h1>
			<p>We have <a id="_idIndexMarker239"/>reached a point where the TinyGo support for the Arduino UNO has reached its limit. At the time of writing, it is not possible to resolve this shortcoming for the current and following chapters using an Arduino UNO. The <a id="_idIndexMarker240"/>cause of this is a missing <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) implementation for the Arduino UNO. However, we will be able to overcome this in the near future, as there is a <strong class="source-inline">Pull</strong> request for that opened by me. Additionally, the <strong class="bold">Alf and Vegard's RISC</strong> (<strong class="bold">AVR</strong>) backend in <a id="_idIndexMarker241"/>the TinyGo compiler toolchain has some problems in the versions used by the current TinyGo version, and the code won't compile. So, let's take a look at another board, which is fully supported by TinyGo—the Arduino Nano 33 IoT. Compared to UNO, the Nano 33 IoT is a powerhouse. Here <a id="_idIndexMarker242"/>are its technical specifications:</p>
			<ul>
				<li><strong class="bold">Microcontroller</strong>: AMD21 Cortex®-M0+ 32bit low power ARM MCU</li>
				<li><strong class="bold">Radio module</strong>: U-blox NINA-W102</li>
				<li><strong class="bold">Operating voltage</strong>: 3.3V</li>
				<li><strong class="bold">Input Voltage (limit)</strong>: 2V</li>
				<li><strong class="bold">DC Current per I/O Pin</strong>: 7 mA</li>
				<li><strong class="bold">Clock speed</strong>: 48 MHz</li>
				<li><strong class="bold">CPU Flash Memory</strong>: 256 KB</li>
				<li><strong class="bold">SRAM</strong>: 32 KB</li>
				<li><strong class="bold">GPIO Pins</strong>: 14</li>
				<li><strong class="bold">Analog input pins</strong>: 8 (8/10/12 bit)</li>
				<li><strong class="bold">Analog output pins</strong>: 1 (10 bit)</li>
			</ul>
			<p>So, the Arduino Nano 33 IoT has a much higher clock speed, more RAM, and more flash memory while operating on 3.3V instead of 5V. Additionally, on top of that, the Nano 33 IoT is capable of Wi-Fi communication. </p>
			<p>Now, let's take a brief <a id="_idIndexMarker243"/>look at the 5V output capabilities of the Arduino Nano 33 IoT.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although the Arduino Nano 33 IoT has a 5V output pin, this pin is deactivated by default. To activate that pin, some soldering needs to be done.</p>
			<p class="callout">When powering the Arduino Nano 33 IoT through USB, we also have a 5V current available on the <strong class="source-inline">Vin</strong> pin, but that pin is intended to power the Arduino. We will be handling devices that require 5V input, but that is not a problem; we are just going to use an external power supply to power these devices.</p>
			<p>Now that we have a brief understanding, let's take a look at the pinout. The following diagram shows the pinout of the Arduino Nano 33 IoT:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="Images/Figure_5.1_B16555.jpg" alt="Figure 5.1 – The Arduino Nano 33 IoT pinout &#13;&#10;" width="1650" height="1184"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The Arduino Nano 33 IoT pinout </p>
			<p>The <a id="_idIndexMarker244"/>source of the pinout diagram <a id="_idIndexMarker245"/>can be found at <a href="https://store.arduino.cc/arduino-nano-33-iot">https://store.arduino.cc/arduino-nano-33-iot</a>.</p>
			<p>In this section, we took a brief look at the technical specs of the Arduino Nano 33 IoT. However, before we can use it in our project, we need to install some dependencies.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Installing Bossa</h2>
			<p>Bossa is <a id="_idIndexMarker246"/>needed in order to flash programs onto the Arduino Nano 33 IoT.</p>
			<p>First, let's take a look at the installing process on a Mac system:</p>
			<ul>
				<li>You can simply install the dependencies using the following command: <p class="source-code"><strong class="bold">brew cask install bossa</strong></p><p>To install the dependencies on Windows download, execute the following <strong class="source-inline">msi</strong>:</p><p class="source-code"><strong class="bold">https://github.com/shumatech/BOSSA/releases/download/1.9.1/bossa-x64-1.9.1.msi</strong></p></li>
				<li>When executing the <strong class="source-inline">msi</strong>, choose the following installation path: <p class="source-code"><strong class="bold">c:\Program Files</strong></p><p>Now, add <strong class="source-inline">bossa</strong> to the path using the following command: </p><p class="source-code"><strong class="bold">set PATH=%PATH%;"c:\Program Files\BOSSA";</strong></p></li>
				<li>In order to install <strong class="source-inline">bossa</strong> on a Linux system, execute the following commands: <p class="source-code"><strong class="bold">sudo apt install libreadline-dev libwxgtk3.0-gtk3-dev</strong></p><p class="source-code"><strong class="bold">git clone https://github.com/shumatech/BOSSA.git</strong></p><p class="source-code"><strong class="bold">cd BOSSAmakesudo </strong></p><p class="source-code"><strong class="bold">cp bin/bossac /usr/local/bin</strong></p></li>
			</ul>
			<p>To verify the installation success, use the following command:</p>
			<p class="source-code">bossac –help</p>
			<p>Up-to-date information on how to install the needed dependencies can be found at <a href="https://tinygo.org/microcontrollers/arduino-nano33-iot/">https://tinygo.org/microcontrollers/arduino-nano33-iot/</a>.</p>
			<p>We have now set up the dependencies required to flash programs on the Arduino Nano 33 IoT. Let's move on to the first project of this chapter.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Learning to measure distances</h1>
			<p>If you have ever wondered how touchless soap dispensers or touchless blow dryers register that <a id="_idIndexMarker247"/>there is a hand beneath them, there is a good chance that they are using the HC-SR04 ultrasonic sensor. We are going to use this sensor to measure the distance between an object and the sensor. Let's begin with the HC-SR04 sensor.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Understanding the HC-SR04 sensor</h2>
			<p>The HC-SR04 sensor emits an ultrasound at 40k Hz, which travels through <a id="_idIndexMarker248"/>the air and bounces back if the emitted pulse collides with any object in its path. The sensor cannot be used as a detector for other ultrasound pulses, as it only registers echoes from the exact same pulse that it itself emitted. Typically, these sensors look similar to the one in the following photograph:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="Images/Figure_5.2_B16555.jpg" alt="Figure 5.2 – The HC-SR04 sensor&#13;&#10;" width="1650" height="964"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – The HC-SR04 sensor</p>
			<p>This sensor has the <a id="_idIndexMarker249"/>following technical specifications:</p>
			<ul>
				<li>It has a detection range from 2 to 400 centimeters. </li>
				<li>It draws less than 2 mA current.</li>
				<li>It has a working voltage of 5V.</li>
				<li>It has a resolution of 0.3 centimeters.</li>
				<li>It has an angle of fewer than 15 degrees.</li>
			</ul>
			<p>The sensor has the following <a id="_idIndexMarker250"/>three ports:</p>
			<ul>
				<li><em class="italic">VCC</em>: This is used to power the sensor.</li>
				<li><em class="italic">TRIG</em>: This triggers the pulse.</li>
				<li><em class="italic">ECHO</em>: This receives the echo of the pulse.</li>
			</ul>
			<p>Now, let's take a look at how exactly an ultrasonic pulse can be used to measure the distance between the sender and an object. The sensor emits eight pulses that travel through the air. If they hit <a id="_idIndexMarker251"/>an object, they get reflected and travel back as an echo, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="Images/Figure_5.3_B16555.jpg" alt="Figure 5.3 – Eight pulses and one echo&#13;&#10;" width="562" height="335"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Eight pulses and one echo</p>
			<p>When recognizing the echo, the <strong class="bold">echo</strong> pin will be set to high from the sensor for the exact same time frame that the pulse needed to leave and return to the sensor. Now, we only need some math to calculate the distance. </p>
			<p>The pulse travels at 340 m/s, which is the speed of sound in the air. This can also be expressed as 0.034 m/μs (microseconds). If the object is about 30 centimeters away from the sensor, the pulse needs to travel for about 882 microseconds. The <strong class="bold">echo</strong> pin will be set to high for exactly as long as the pulse needs to travel the entire path; that is why we need to divide the result by 2. And as the last step, we are going to divide the travel time by 0.034 to get the traveled distance in centimeters. </p>
			<p>Here is how this example works out:</p>
			<p class="source-code">Time = Distance / Speed  </p>
			<p class="source-code">t = s/v </p>
			<p class="source-code">t = 30cm / 0.034m/us</p>
			<p class="source-code">t = 882.352941176us</p>
			<p>Let's <a id="_idIndexMarker252"/>rearrange that formula to get <strong class="source-inline">distance</strong>:</p>
			<p class="source-code">Distance = Time * Speed </p>
			<p class="source-code">30cm = 882.352941176us * 0.34m/us</p>
			<p>Now we have learned how to use an ultrasonic sound sensor, theoretically, we can now go on to prove this theory by trying it out in real time. </p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Assembling the circuit</h2>
			<p>Before we start to assemble the circuit, we need to make sure that the <a id="_idIndexMarker253"/>echo pin from the sensor, which will be connected to an input pin on the Arduino, does send 3.3V signals instead of 5V signals. For this, we <a id="_idIndexMarker254"/>can make use of a <strong class="bold">voltage divider</strong>. The echo pin of the sensor outputs 5V, but the Arduino Nano 33 IoT should not be connected to 5V, as this could cause permanent damage to the Arduino. That is why we make use of the voltage divider.</p>
			<p>The formula <a id="_idIndexMarker255"/>to calculate the <strong class="bold">output voltage</strong> (<strong class="bold">Vout</strong>) is as follows:</p>
			<p class="source-code">Vout = Vs * R2 / (R1 + R2)</p>
			<p>Here, <strong class="source-inline">Vs</strong> is the source voltage, <strong class="source-inline">R2</strong> is the resistor that is connected to the source voltage, and <strong class="source-inline">R1</strong> is the resistor that is connected to the ground. </p>
			<p>So, we are going to need a 2,000-Ohm resistor for R2 and a 1,000-Ohm resistor for R1. This is going to result in the following equation:</p>
			<p><em class="italic">3.333V = 5 * 2,000 / (1,000 + 2,000)</em></p>
			<p>Now that we have learned how to build a voltage divider, we can go ahead and assemble the circuit using the following steps:</p>
			<ol>
				<li>Place the HC-SR04 sensor on the breadboard with the <em class="italic">VCC</em> pin in the <em class="italic">J</em> row on the breadboard.</li>
				<li>Connect the <em class="italic">VCC</em> lane on the power bus with <em class="italic">VCC</em> of the sensor using a jumper wire.</li>
				<li>Connect <a id="_idIndexMarker256"/>the <em class="italic">GND</em> lane on the <a id="_idIndexMarker257"/>power bus with <em class="italic">GND</em> of the sensor using a jumper wire. Connect <em class="italic">D2</em> from the Arduino with <em class="italic">Trig</em> of the sensor using a jumper wire.</li>
				<li>Use a 2,000-Ohm resistor to connect <strong class="source-inline">GND</strong> with <em class="italic">C53</em> on the breadboard using a jumper wire.</li>
				<li>Use a 1,000-Ohm resistor to connect <em class="italic">Echo</em> with <em class="italic">A53</em> on the breadboard jumper wire.</li>
				<li>Now, connect <em class="italic">D3</em> from the Arduino with <em class="italic">B53</em> on the breadboard using a jumper wire. We can read the 3.3V <em class="italic">Echo</em> signal here.</li>
				<li>Place an external power supply on the breadboard. Take care to <strong class="bold">set the jumpers to 5V</strong>.</li>
			</ol>
			<p>This is everything we need to write and test a library. Your circuit should now look similar to the following diagram:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="Images/Figure_5.4_B16555.jpg" alt="Figure 5.4 – The HC-SR04 circuit (image taken from Fritzing)&#13;&#10;" width="1650" height="772"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The HC-SR04 circuit (image taken from Fritzing)</p>
			<p>We have now learned how <a id="_idIndexMarker258"/>an ultrasonic sound sensor <a id="_idIndexMarker259"/>works and have assembled a circuit. As has been the case with the previous chapters, here, we also start by creating a library to control the sensor.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Writing a library</h2>
			<p>We are going to <a id="_idIndexMarker260"/>write a library that has a function that returns the current distance from the sensor to an object, or <strong class="source-inline">0</strong> if the object is out of range. We start by creating a new folder, called <strong class="source-inline">Chapter05</strong>, inside our project. Inside the new <strong class="source-inline">Chapter05 </strong>folder, create a new folder, called <strong class="source-inline">ultrasonic-distance-sensor</strong>, and create a new <strong class="source-inline">driver.go</strong> file. Name the package <strong class="source-inline">hcsr04</strong>. Your folder structure should look like the following:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="Images/Figure_5.5_B16555.jpg" alt="Figure 5.5 – The project structure for writing a library&#13;&#10;" width="799" height="63"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – The project structure for writing a library</p>
			<p>Now that we have set up our project structure, we can start to write the actual logic. To do this, perform these steps:</p>
			<ol>
				<li value="1">Define a new constant at the package level, name it <strong class="source-inline">speedOfSound</strong>, and set its value to <strong class="source-inline">0.0343</strong>, which is the speed of sound in centimeters per microsecond:<p class="source-code">const speedOfSound = 0.0343</p></li>
				<li>Next, define a new interface and call it HCSR04, as shown in the following code:<p class="source-code">type Device interface {</p><p class="source-code">        Configure()</p><p class="source-code">        GetDistance() uint16</p><p class="source-code">        GetDistanceFromPulseLength(</p><p class="source-code">            float32) uint16</p><p class="source-code">}</p></li>
				<li>Then, we <a id="_idIndexMarker261"/>define a new <strong class="source-inline">struct</strong>, called <strong class="source-inline">hcsr04</strong>, which holds the <strong class="source-inline">trigger</strong> and <strong class="source-inline">echo</strong> <strong class="source-inline">pins</strong> as well as a <strong class="source-inline">timeout</strong> in microseconds, as shown in the following code:<p class="source-code">type device struct {</p><p class="source-code">        trigger machine.Pin</p><p class="source-code">        echo machine.Pin</p><p class="source-code">        timeout int64</p><p class="source-code">}</p></li>
				<li>Next, we add a function named <strong class="source-inline">NewHCSR04</strong>, which takes a <strong class="source-inline">trigger</strong> and <strong class="source-inline">echo</strong> pin along with the <strong class="source-inline">maxDistance</strong> in centimeters and returns <strong class="source-inline">HCSR04</strong>:<p class="source-code">func NewDevice(trigger, echo machine.Pin, maxDistance</p><p class="source-code">    float32) HCSR04 {</p></li>
				<li>Calculate the <strong class="source-inline">timeout</strong> in microseconds. We multiply the <strong class="source-inline">maxDistance</strong> by <strong class="source-inline">2</strong> because the pulse needs to travel to an object and back again. We then divide the result by <strong class="source-inline">speedOfSound</strong>:<p class="source-code">timeout := int64(maxDistance * 2 / speedOfSound)</p></li>
				<li>Create a new instance of <strong class="source-inline">hcsr04</strong>, set <strong class="source-inline">trigger</strong>, <strong class="source-inline">echo</strong>, and <strong class="source-inline">timeout</strong>, and return a pointer to the new instance:<p class="source-code">return &amp;device{</p><p class="source-code">        trigger: trigger,</p><p class="source-code">        echo: echo,</p><p class="source-code">        timeout: timeout,</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>Add <a id="_idIndexMarker262"/>the <strong class="source-inline">Configure</strong> function, which is a pointer receiver that configures <strong class="source-inline">trigger</strong> as output and the <strong class="source-inline">echo</strong> pin as input:<p class="source-code">func (sensor *device) Configure() {</p><p class="source-code">    sensor.trigger.Configure(</p><p class="source-code">        machine.PinConfig{Mode: machine.PinOutput},</p><p class="source-code">    )</p><p class="source-code">    sensor.echo.Configure(</p><p class="source-code">        machine.PinConfig{Mode: machine.PinInput},</p><p class="source-code">    )</p><p class="source-code">}</p></li>
				<li>Add the <strong class="source-inline">sendPulse</strong> function, which pulls the <strong class="source-inline">trigger</strong> high for <strong class="source-inline">10</strong> microseconds and then sets the <strong class="source-inline">trigger</strong> to low again. This will trigger eight ultrasonic pulses in the HC-SR04 sensor:<p class="source-code">func (sensor *device) sendPulse() {</p><p class="source-code">    sensor.trigger.High()</p><p class="source-code">    time.Sleep(10 * time.Microsecond)</p><p class="source-code">    sensor.trigger.Low()</p><p class="source-code">}</p></li>
				<li>Add a new function named <strong class="source-inline">GetDistance</strong>, which returns <strong class="source-inline">uint16</strong> and is a pointer receiver. First, the function sends out a pulse and then listens for the echo. We receive an <a id="_idIndexMarker263"/>incoming echo when the echo pin reads a high value:<p class="source-code">func (sensor *device) GetDistance() uint16 {</p><p class="source-code">    i := 0</p><p class="source-code">    timeoutTimer := time.Now()</p><p class="source-code">    sensor.sendPulse()</p><p class="source-code">    for {</p><p class="source-code">        if sensor.echo.Get() {</p><p class="source-code">            timeoutTimer = time.Now()</p><p class="source-code">            break</p><p class="source-code">        } </p><p class="source-code">        i++</p></li>
				<li>Check whether <strong class="source-inline">i</strong> is greater than <strong class="source-inline">15</strong>. We do this to save some time, as comparing an integer is a very fast operation in comparison to getting a current timestamp. If the time since our timer started is greater than our configured <strong class="source-inline">timeout</strong>, then return <strong class="source-inline">0</strong>, which we can use as the <strong class="source-inline">timeout</strong> value:<p class="source-code">if i &gt; 15 {</p><p class="source-code">    microseconds := time.Since(timeoutTimer).</p><p class="source-code">        Microseconds()</p><p class="source-code">    if microseconds &gt; sensor.timeout {</p><p class="source-code">        return 0</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p><p>Now we have to measure the <a id="_idIndexMarker264"/>time when the <strong class="source-inline">echo</strong> pin is set to high:</p><p class="source-code">var pulseLength float32</p><p class="source-code">i = 0</p><p class="source-code">for {</p><p class="source-code">    if !sensor.echo.Get() {</p><p class="source-code">        microseconds := time.Since(timeoutTimer).</p><p class="source-code">            Microseconds()</p><p class="source-code">        pulseLength = float32(microseconds)</p><p class="source-code">        break</p><p class="source-code">    }</p><p class="source-code">    i++</p><p class="source-code">    if i &gt; 15 {</p><p class="source-code">        microseconds := time.Since(timeoutTimer).</p><p class="source-code">            Microseconds()</p><p class="source-code">        if microseconds &gt; sensor.timeout {</p><p class="source-code">            return 0</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">return sensor.GetDistanceFromPulseLength(pulseLength)</p><p class="source-code">}</p></li>
				<li>Add a function named <strong class="source-inline">GetDistanceFromPulseLength</strong>, which takes <strong class="source-inline">pulseLength</strong> as a parameter, returns the distance in centimeters, and is a pointer receiver:<p class="source-code">func (sensor *hcsr04) GetDistanceFromPulseLength(</p><p class="source-code">    pulseLength float32) uint16 {</p></li>
				<li>As the <strong class="source-inline">pulseLength</strong> parameter is the time that <a id="_idIndexMarker265"/>the signal needs to travel to the target and back, we need to divide it by <strong class="source-inline">2</strong>:<p class="source-code">pulseLength = pulseLength / 2</p></li>
				<li>To get the result in centimeters, we need to multiply <strong class="source-inline">pulseLength</strong> with <strong class="source-inline">speedOfSound</strong>:<p class="source-code">result := pulseLength * speedOfSound</p></li>
				<li>Return <strong class="source-inline">result</strong> as <strong class="source-inline">uint16</strong>, as we don't care about decimal places:<p class="source-code">return uint16(result)</p><p class="source-code">}</p></li>
			</ol>
			<p>This is all the code we need for the library. From now on, we can use this library to measure distances using an HCSR-04 sensor.</p>
			<p>Before we move on to test the library in a real-world example, let's use the <strong class="source-inline">GetDistanceFromPulseLength</strong> function to take a brief look at how unit testing can be done in TinyGo.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Unit testing in TinyGo</h2>
			<p>TinyGo does <a id="_idIndexMarker266"/>support unit testing, which comes in <a id="_idIndexMarker267"/>handy when you have complicated logic and do not want to flash every single change onto your microcontroller when you are trying to find a bug. Let's take a look at what is currently is supported in a practical way. To do this, create a new file, called <strong class="source-inline">driver_test.go</strong>, inside the <strong class="source-inline">ultrasonic-distance-sensor</strong> folder and name the package <strong class="source-inline">hcsr04_test</strong>. The project structure should look similar to the following:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="Images/Figure_5.6_B16555.jpg" alt="Figure 5.6 – The project structure for the first unit test&#13;&#10;" width="793" height="105"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – The project structure for the first unit test</p>
			<p>Now, let's add our first unit test in TinyGo. To do so, perform these steps:</p>
			<ol>
				<li value="1">Add a new function named <strong class="source-inline">TestGetDistanceFromPulseLength_30cm</strong>:<p class="source-code">func TestGetDistanceFromPulseLength_30cm(t *testing.T)</p><p class="source-code">{</p></li>
				<li>Create a new <strong class="source-inline">HCSR04</strong> instance. We do not really need a parameter for this test, as these <a id="_idIndexMarker268"/>parameters will not <a id="_idIndexMarker269"/>be used; however, we can add some correct ones anyway:<p class="source-code">sensor := hcsr04.NewHCSR04(</p><p class="source-code">    machine.D2, machine.D3, 100)</p></li>
				<li>Calculate the <strong class="source-inline">distance</strong> for the given <strong class="source-inline">pulseLength</strong> parameter, which is exactly the length of a pulse for a distance of 30 centimeters:<p class="source-code">distance := sensor.GetDistanceFromPulseLength(</p><p class="source-code">            1749.27113703)</p></li>
				<li>Check whether the <strong class="source-inline">distance</strong> equals <strong class="source-inline">30</strong>. If it does not, we fail the test and log some information, as follows:<p class="source-code">if distance != 30 {</p><p class="source-code">    t.Error("Expected distance: 30cm", "actual </p><p class="source-code">        distance: ", distance, "cm")</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This was our first unit test in TinyGo. Do not forget to import the <strong class="source-inline">testing</strong> package. Just like in the normal program code, we can make use of the standard Golang package. You can run the test by using the following command: </p>
			<p class="source-code">tinygo test --tags "arduino_nano33" Chapter05/ultrasonic-distance-sensor/driver_test.go</p>
			<p>TinyGo internally makes heavy use of <strong class="bold">build flags</strong>. These build flags, such as <strong class="source-inline">arduino_nano33</strong>, are used to decide which packages and files are needed to build the current code. The <a id="_idIndexMarker270"/>test will not compile if we <a id="_idIndexMarker271"/>omit the <strong class="source-inline">–tags</strong> parameter, as the <strong class="source-inline">machine</strong> package would then be missing.</p>
			<p>The output of the test should look like the following:</p>
			<p class="source-code">=== RUN   TestGetDistanceFromPulseLength_30cm</p>
			<p class="source-code">--- PASS: TestGetDistanceFromPulseLength_30cm</p>
			<p>Now we know that we can make use of very simple tests to test our logic in TinyGo. Let's go one step further and do a <strong class="bold">table-driven test</strong>. Perform these steps:</p>
			<ol>
				<li value="1">The next step is to add a new function, called <strong class="source-inline">TestGetDistanceFromPulseLength_TableDriven</strong>, right underneath the other test. The code snippet looks like the following:<p class="source-code">func TestGetDistanceFromPulseLength_TableDriven(</p><p class="source-code">    t *testing.T) {</p></li>
				<li>Add four test cases, each of them with a <strong class="source-inline">Name</strong>, the expected <strong class="source-inline">Result</strong>, and the <strong class="source-inline">PulseLength</strong>, which we use as input, as follows:<p class="source-code">var testCases = [4]struct {</p><p class="source-code">    Name string</p><p class="source-code">    Result uint16</p><p class="source-code">    PulseLength float32</p><p class="source-code">}{</p><p class="source-code">    { </p><p class="source-code">        Name: "1cm", </p><p class="source-code">        Result: 1, </p><p class="source-code">        PulseLength: 58.8235294117},</p><p class="source-code">    { </p><p class="source-code">        Name: "30cm", </p><p class="source-code">        Result: 30, </p><p class="source-code">        PulseLength: 1749.27113703},</p><p class="source-code">    { </p><p class="source-code">        Name: "60cm", </p><p class="source-code">        Result: 60, </p><p class="source-code">        PulseLength: 3498.54227405},</p><p class="source-code">    { </p><p class="source-code">        Name: "400cm", </p><p class="source-code">        Result: 400, </p><p class="source-code">        PulseLength: 23323.6151603},</p><p class="source-code">}</p></li>
				<li>Create a <a id="_idIndexMarker272"/>new instance of the <strong class="source-inline">HCSR04</strong> <strong class="source-inline">Device</strong> instance. It <a id="_idIndexMarker273"/>should look like the following snippet:<p class="source-code">sensor := hcsr04.NewDevice(</p><p class="source-code">          machine.D2, machine.D3, 100)</p></li>
				<li>Now we can run a test for each <strong class="source-inline">testCase</strong> in the array. This looks like the following code:<p class="source-code">for _, testCase := range testCases {</p><p class="source-code">    t.Run(testCase.Name, func(t *testing.T) {</p></li>
				<li>Calculate the <strong class="source-inline">distance</strong>. And check whether we get a result that differs from the predefined test cases:<p class="source-code">distance := sensor.GetDistanceFromPulseLength(</p><p class="source-code">    testCase.PulseLength)</p><p class="source-code">if distance != testCase.Result {</p><p class="source-code">    t.Error("Expected distance:", testCase.Name,</p><p class="source-code">        "actual distance: ", distance, "cm")</p><p class="source-code">}</p><p class="source-code">})</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This was <a id="_idIndexMarker274"/>everything for the tests. Now, let's run the tests again using the <a id="_idIndexMarker275"/>following command:</p>
			<p class="source-code">tinygo test --tags "arduino_nano33" Chapter5/ultrasonic-distance-sensor/driver_test.go</p>
			<p>The output should now look like the following:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="Images/Figure_5.7_B16555.jpg" alt="Figure 5.7 – The tinygo test output&#13;&#10;" width="1118" height="338"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – The tinygo test output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since building binaries for Windows is currently not supported, the preceding <strong class="source-inline">tinygo test</strong> command is going to fail on a Windows systems. One option for Windows users is to use the WSL for unit tests. Another possibility is to set a build target by using the <strong class="source-inline">–target</strong> parameter. Windows does support building the <strong class="bold">wasm</strong> or <strong class="bold">wasi</strong> targets, but as our code depends on the machine package, that will not work for this specific test. This is because the machine package is not available for the wasm and wasi targets.</p>
			<p>Now we know that we <a id="_idIndexMarker276"/>can also use table-driven <a id="_idIndexMarker277"/>tests in TinyGo. At the time of writing, the majority of the testing package seems to be implemented. Currently, only the <strong class="source-inline">Helper()</strong> function seems to not be implemented. However, there could be one or two small things that I have not found yet, which might not work. Additionally, we have checked that our logic to calculate the distance seems to be working as expected.</p>
			<p>With that covered, we can go on and write a small example program to test the rest of our code on real hardware.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>Writing an example program for the library</h2>
			<p>We have <a id="_idIndexMarker278"/>now checked that our formula to calculate the distance from a pulse length input seems to be correct. So, we can move ahead and create an example that outputs the measured distance to serial. To do that, first, we need to create a new folder, called <strong class="source-inline">ultrasonic-distance-sensor-example</strong>, inside the <strong class="source-inline">Chapter05</strong> folder. Additionally, we need to create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function. The project structure should look similar to the following:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="Images/Figure_5.8_B16555.jpg" alt="Figure 5.8 – The project structure for the example program&#13;&#10;" width="752" height="134"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – The project structure for the example program</p>
			<p>The example logic consists of initializing the sensor and then printing the distance each second. All of this is done inside the <strong class="source-inline">main</strong> function. It looks like the following snippet:</p>
			<p class="source-code">sensor := hcsr04.NewHCSR04(machine.D2, machine.D3, 80)</p>
			<p class="source-code">sensor.Configure()</p>
			<p class="source-code">for {</p>
			<p class="source-code">    distance := sensor.GetDistance()</p>
			<p class="source-code">    if distance != 0 {</p>
			<p class="source-code">        println("Current distance:", distance, "cm")</p>
			<p class="source-code">}</p>
			<p class="source-code">    time.Sleep(time.Second)</p>
			<p class="source-code">}</p>
			<p>This is the complete code for the <a id="_idIndexMarker279"/>example. The library was imported with an alias named <strong class="source-inline">hcsr04</strong>. Now, let's flash the program onto the Arduino Nano 33 IoT using the following command:</p>
			<p class="source-code">tinygo flash --target=arduino-nano33 Chapter05/ultrasonic-distance-sensor-example/main.go</p>
			<p>To check the output, we can use the same <strong class="source-inline">PuTTY</strong> profile that we created in <a href="B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058"><em class="italic">Chapter 3</em></a>, <em class="italic">Building a Safety Lock Using a Keypad</em>. Open up PuTTY and select the <strong class="bold">Microcontroller</strong> profile. Make sure that you have the USB cable plugged into the same port as the Arduino UNO beforehand. Depending on the current distance from the sensor to any object, the output should look similar to the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="Images/Figure_5.9_B16555.jpg" alt="Figure 5.9 – Sensor readings in PuTTy&#13;&#10;" width="506" height="363"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Sensor readings in PuTTy</p>
			<p>In this section, we wrote a library <a id="_idIndexMarker280"/>for the HC-SR04 sensor, learned that unit testing also works in TinyGo, and then wrote an example project to test the library. So, we are now able to measure distance, which is the first half of our project. </p>
			<p>In the next section, we will look at 7-segment displays, as we need 7-segment displays to display a timer in our final project.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Using 4-digit 7-segment displays</h1>
			<p>A 7-segment display can <a id="_idIndexMarker281"/>be used for multiple purposes. One of them is to display times, which is exactly what we want to do in our final project. But how can we control them?</p>
			<p>The 4-digit display has 12 pins: one pin for each digit (from 0 to 9), one pin for each segment, and a pin for the dot. So, to display anything, we have to send a high signal to the digit we want to set and then just set all pins to high, which we need to represent the character we want to display.</p>
			<p>For instance, if we want to display the character of "1" in the fourth digit, we would set pin 4 and pins B and C to high.</p>
			<p>To get a better <a id="_idIndexMarker282"/>understanding of this, take a look at the following diagram:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="Images/Figure_5.10_B16555.jpg" alt="Figure 5.10 – A 7-segment display pinout&#13;&#10;" width="749" height="486"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – A 7-segment display pinout</p>
			<p>From the preceding diagram, you can see that pins 1 to 4 are being used to select the digit.</p>
			<p>The 7-segment A-G pins are being used to control the segments and the <strong class="bold">dot</strong> pin is being used to set the dot.</p>
			<p>So, having to control 12 <a id="_idIndexMarker283"/>pins is kind of hard, as then we would only have 2 digital pins left when controlling the display. That is why we use another device to control the display: a MAX7219. The next section explains how this is done.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Using a MAX7219 </h2>
			<p>The MAX7219 (and Max7221) is a <em class="italic">serially interfaced</em>, 8-digit LED <em class="italic">display driver</em>. In short, we can <a id="_idIndexMarker284"/>control this chip using only four wires, which controls up to eight 7-segment digits.</p>
			<p>To send data to that chip, we simply need to drive the load pin low, send 1 byte of data containing the register to set and 1 byte of data to set the segments and the dot. Then, we drive the load pin high and the 16 bits that have been written are processed. The chip will then decode the data and set all of the output pins. The following diagram is a pinout of the chip for reference:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="Images/Figure_5.11_B16555.jpg" alt="Figure 5.11 – The MAX7219 and MAX7221 pinout&#13;&#10;" width="1098" height="1742"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – The MAX7219 and MAX7221 pinout</p>
			<p>These chips are commonly used in 8x8 LED matrices. So ,if you have such a device, you could carefully remove the chip using a tweezer. <em class="italic">Removing the chip could cause permanent damage to the chip!</em> These chips are also freely available in most shops for microcontroller components. Before we start to write a library for this chip, let's first assemble our circuit. To do this, perform the following steps:</p>
			<ol>
				<li value="1">Take a second breadboard; a half-size one is sufficient.</li>
				<li>Place the MAX7219 on to the breadboard. The <em class="italic">CLK</em> pin should sit in <em class="italic">E1</em>, and the <em class="italic">LOAD</em> pin should sit in <em class="italic">G1</em>.</li>
				<li>Place the 7-segment <a id="_idIndexMarker285"/>display on to the breadboard. The <strong class="source-inline">E</strong> pin should sit in <strong class="source-inline">D25</strong>, and the <strong class="source-inline">1</strong> pin should sit in <em class="italic">F25</em> or <em class="italic">G25</em> (depending on which fits better).</li>
				<li>Connect <em class="italic">DIG0</em> from the MAX7219 with <em class="italic">Digit1</em> from the display.</li>
				<li>Connect <em class="italic">DIG1</em> from the MAX7219 with <em class="italic">Digit2</em> from the display.</li>
				<li>Connect <em class="italic">DIG2</em> from the MAX7219 with <em class="italic">Digit3</em> from the display.</li>
				<li>Connect <em class="italic">DIG3</em> from the MAX7219 with <em class="italic">Digit4</em> from the display.</li>
				<li>Connect <em class="italic">SEGA</em> from the MAX7219 with <em class="italic">A</em> from the display.</li>
				<li>Connect <em class="italic">SEGB</em> from the MAX7219 with <em class="italic">B</em> from the display.</li>
				<li>Connect <em class="italic">SEGC</em> from the MAX7219 with <em class="italic">C</em> from the display.</li>
				<li>Connect <em class="italic">SEGD</em> from the MAX7219 with <em class="italic">D</em> from the display.</li>
				<li>Connect <em class="italic">SEGE</em> from the MAX7219 with <em class="italic">E</em> from the display.</li>
				<li>Connect <em class="italic">SEGF</em> from the MAX7219 with <em class="italic">F</em> from the display.</li>
				<li>Connect <em class="italic">SEGG</em> from the MAX7219 with <em class="italic">G</em> from the display.</li>
				<li>Connect <em class="italic">SEGDP</em> from the MAX7219 with <em class="italic">DOT</em> from the display.</li>
				<li>Connect the <em class="italic">GND</em> lane from the power bus of both breadboards.</li>
				<li>Connect the <em class="italic">VCC</em> lane from the power bus of both breadboards using a jumper wire.</li>
				<li>Connect <em class="italic">ISET</em> with VCC from the MAX7219 using a <strong class="bold">10,000-Ohm resistor</strong>. This is a hardware solution that controls the brightness of the display.</li>
				<li>Connect <em class="italic">D13</em> from the Arduino with <em class="italic">CLK</em> from the MAX7219.</li>
				<li>Connect <em class="italic">D6</em> from the Arduino with <em class="italic">LOAD</em> from the MAX7219.</li>
				<li>Connect <em class="italic">D11</em> from the <a id="_idIndexMarker286"/>Arduino with <em class="italic">DIN</em> from the MAX7219.</li>
				<li>Connect <em class="italic">D5</em> from the Arduino with <em class="italic">VCC</em> from the buzzer.</li>
				<li>Connect <em class="italic">GND</em> from the buzzer with <em class="italic">GND</em> on the power bus.<p>When all of this is done, the result should now look similar to the following diagram:</p></li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="Images/Figure_5.12_B16555.jpg" alt="Figure 5.12 – The final circuit&#13;&#10;" width="1352" height="748"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – The final circuit</p>
			<p>Now, let's better understand how the MAX7219 works by writing a small library that communicates with this chip.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Writing a library to control the MAX7219</h2>
			<p>We do not <a id="_idIndexMarker287"/>only want to learn how to use a MAX7219 in a single project, but <a id="_idIndexMarker288"/>we also want to create a library that we can use in all future projects, even beyond the book.</p>
			<p>To begin with, we need to create a new folder, called <strong class="source-inline">max7219spi</strong>, inside the <strong class="source-inline">Chapter05</strong> folder. Create two files named <strong class="source-inline">registers.go</strong> and <strong class="source-inline">device.go</strong> inside the newly created folder, and use <strong class="source-inline">MAX7219spi</strong> as the package name. The project structure should look like the following:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="Images/Figure_5.13_B16555.jpg" alt="Figure 5.13 – The project structure to control the MAX7219&#13;&#10;" width="851" height="194"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – The project structure to control the MAX7219</p>
			<p>We are now ready <a id="_idIndexMarker289"/>to move ahead and write some code. We will start <a id="_idIndexMarker290"/>by implementing the needed registers in the next section.</p>
			<h3>Registers.go</h3>
			<p>Inside the <strong class="source-inline">registers.go</strong> file, we place a <a id="_idIndexMarker291"/>bunch of constants that represent register addresses. We will explain the constants as soon as we use them in the code:</p>
			<p class="source-code">const ( </p>
			<p class="source-code">    REG_NOOP byte = 0x00</p>
			<p class="source-code">    REG_DIGIT0 byte = 0x01</p>
			<p class="source-code">    REG_DIGIT1 byte = 0x02</p>
			<p class="source-code">    REG_DIGIT2 byte = 0x03</p>
			<p class="source-code">    REG_DIGIT3 byte = 0x04</p>
			<p class="source-code">    REG_DIGIT4 byte = 0x05</p>
			<p class="source-code">    REG_DIGIT5 byte = 0x06</p>
			<p class="source-code">    REG_DIGIT6 byte = 0x07</p>
			<p class="source-code">    REG_DIGIT7 byte = 0x08</p>
			<p class="source-code">    REG_DECODE_MODE byte = 0x09</p>
			<p class="source-code">    REG_INTENSITY byte = 0x0A</p>
			<p class="source-code">    REG_SCANLIMIT byte = 0x0B</p>
			<p class="source-code">    REG_SHUTDOWN byte = 0x0C</p>
			<p class="source-code">    REG_DISPLAY_TEST byte = 0x0F</p>
			<p class="source-code">)</p>
			<p>This is it <a id="_idIndexMarker292"/>for this file. Further explanations regarding these constants can also be found in the datasheet at <a href="https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf">https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf</a>. Now, we are going to implement the driver.</p>
			<h3>Device.go</h3>
			<p>In this file, we can <a id="_idIndexMarker293"/>define an interface to implement its methods. The interface will provide a function to write data to the MAX7219, along with some convenience functions to start a display test for our example. To implement it, follow these steps:</p>
			<ol>
				<li value="1">Define the <strong class="source-inline">Device</strong> interface with all of its functions, as follows:<p class="source-code">type Device interface {</p><p class="source-code">    WriteCommand(register, data byte)</p><p class="source-code">    Configure()</p><p class="source-code">    StartShutdownMode()</p><p class="source-code">    StopShutdownMode()</p><p class="source-code">    StartDisplayTest()</p><p class="source-code">    StopDisplayTest()</p><p class="source-code">    SetDecodeMode(digitNumber uint8)</p><p class="source-code">    SetScanLimit(digitNumber uint8)</p><p class="source-code">}</p></li>
				<li>Then, define a <strong class="source-inline">device</strong> struct that contains an <strong class="bold">SPI bus</strong> and a pin that handles the <strong class="source-inline">load</strong>. We will explain these pins in more detail as soon as we use them:<p class="source-code">type device struct {</p><p class="source-code">    bus machine.SPI</p><p class="source-code">    load machine.Pin </p><p class="source-code">}</p></li>
				<li>Then, define a <a id="_idIndexMarker294"/>function, called <strong class="source-inline">NewDevice</strong>, that creates a new instance of <strong class="source-inline">device</strong> and sets the <strong class="source-inline">load</strong> pin along with the SPI <strong class="source-inline">bus</strong>:<p class="source-code">func NewDevice(</p><p class="source-code">        load machine.Pin, bus machine.SPI) Device {</p><p class="source-code">    return &amp;device{</p><p class="source-code">        load: load,</p><p class="source-code">        bus: bus,</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Define a function, called <strong class="source-inline">WriteCommand</strong>, that takes 2 bytes as its parameter. The first byte is <strong class="source-inline">register</strong> and the second one is the <strong class="source-inline">data</strong> to set. For the register, we use the constants of the <strong class="source-inline">registers.go</strong> file. We write data to the MAX7219 by pulling the <strong class="source-inline">load</strong> pin to low. Next, we write the <strong class="source-inline">register</strong> byte, then the <strong class="source-inline">payload</strong>, and then we pull the load <strong class="source-inline">pin</strong> to <strong class="source-inline">high</strong>. Pulling the <strong class="source-inline">load</strong> pin to <strong class="source-inline">high</strong> triggers the MAX7219 to load and process the data:<p class="source-code">func (driver *device) WriteCommand(</p><p class="source-code">        register, data byte) {</p><p class="source-code">    driver.load.Low()</p><p class="source-code">    driver.writeByte(register)</p><p class="source-code">    driver.writeByte(data)</p><p class="source-code">    driver.load.High()</p><p class="source-code">}</p></li>
				<li>Define a function, called <strong class="source-inline">Configure</strong>, that sets the <strong class="source-inline">load</strong> pin as the output:<p class="source-code">func (driver *device) Configure() {</p><p class="source-code">    outPutConfig := machine.PinConfig{</p><p class="source-code">        Mode: machine.PinOutput,</p><p class="source-code">    }</p><p class="source-code">    driver.load.Configure(outPutConfig)</p><p class="source-code">}</p></li>
				<li>Define a <a id="_idIndexMarker295"/>function, called <strong class="source-inline">SetScanLimit</strong>, that tells the MAX7219 how many digits we are going to use in our program. Digits in the MAX7219 start from 0, so we subtract 1 from our digit number, as follows:<p class="source-code">func (driver *device) SetScanLimit(digitNumber uint8) {</p><p class="source-code">    driver.WriteCommand(REG_SCANLIMIT, byte(</p><p class="source-code">        digitNumber-1))</p><p class="source-code">}</p></li>
				<li>Next, define a function, called <strong class="source-inline">SetDecodeMode</strong>, that tells the MAX7219 how many digits should be decoded. The decode mode is going to help us later, as it translates our input into the matching output for the 7-segment display in order to display a character. The MAX7219 has a predefined set of characters for this purpose:<p class="source-code">func (driver *device) SetDecodeMode(digitNumber uint8) {</p></li>
				<li>Switch over to the <strong class="source-inline">digitNumber</strong> input; if we only use one digit, we tell the MAX7219 to only <em class="italic">decode the first digit</em>:<p class="source-code">switch digitNumber {</p><p class="source-code">case 1: driver.WriteCommand(REG_DECODE_MODE, <strong class="bold">0x01</strong>)</p><p>If we use two, three, or four digits, we tell the MAX7219 to <em class="italic">decode the first four digits</em>:</p><p class="source-code">case 2, 3, 4: driver.WriteCommand(</p><p class="source-code">    REG_DECODE_MODE, <strong class="bold">0x0F</strong>)</p></li>
				<li>Decode all of the digits:<p class="source-code">case 8: driver.WriteCommand(REG_DECODE_MODE, <strong class="bold">0xFF</strong>)</p></li>
				<li>If the input is 0, or <a id="_idIndexMarker296"/>greater than 8, we tell the MAX7219 to <em class="italic">decode nothing</em>:<p class="source-code">default: driver.WriteCommand(REG_DECODE_MODE, <strong class="bold">0x00</strong>)</p><p class="source-code">}</p><p class="source-code">}</p><p>We want to be able to activate and deactivate the shutdown mode. We do this by writing a byte to the <strong class="source-inline">REG_SHUTDOWN</strong> register. This looks like the following snippet:</p><p class="source-code">func (driver *device) StartShutdownMode() {</p><p class="source-code">    driver.WriteCommand(REG_SHUTDOWN, 0x00)</p><p class="source-code">}</p><p class="source-code">func (driver *device) StopShutdownMode() {</p><p class="source-code">driver.WriteCommand(REG_SHUTDOWN, 0x01)</p><p class="source-code">}</p></li>
				<li>Now, we want to be able to start and stop the display test mode. The <em class="italic">display test activates all of the connected LEDs</em>. This looks like the following:<p class="source-code">func (driver *device) StartDisplayTest() {</p><p class="source-code">    driver.WriteCommand(REG_DISPLAY_TEST, 0x01)</p><p class="source-code">}</p><p class="source-code">func (driver *device) StopDisplayTest() {</p><p class="source-code">    driver.WriteCommand(REG_DISPLAY_TEST, 0x00)</p><p class="source-code">}</p></li>
				<li>Define a function, called <strong class="source-inline">writeByte</strong>, that takes a byte and writes it to the MAX7219. Here, we make use of the SPI interface. First, the SPI implementation internally pulls down the <a id="_idIndexMarker297"/>clock pin, then it takes each bit of the byte, and sets the data pin to low for a 0 and to high for a 1. After the data line bit has been set, it pulls up the clock pin:<p class="source-code">func (driver *device) writeByte(data byte) {</p><p class="source-code">    driver.bus.Transfer(data)</p><p class="source-code">}</p></li>
			</ol>
			<p>This is everything we need for the MAX7219.</p>
			<p>In the next section, we will create a small abstraction layer above this device. Our abstraction layer will implement the specifics of 7-segment displays. We have implemented the MAX7219 package in a very generic way, and that was done on purpose so that we can build abstraction layers for 7-segment displays and 8x8 LED matrices based on this package.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Writing a library to control the hs42561k display</h2>
			<p>This library makes <a id="_idIndexMarker298"/>use of the MAX7219 library to <a id="_idIndexMarker299"/>set it up for 7-segment display use and provides a convenience function to set a character to a specific digit. We start by creating a new folder, called <strong class="source-inline">hs42561k</strong>, inside the <strong class="source-inline">Chapter05</strong> folder and create two files named <strong class="source-inline">constants.go</strong> and <strong class="source-inline">device.go</strong>. Then, name the package <strong class="source-inline">hs42561k</strong>. The project structure should look similar to the following:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="Images/Figure_5.14_B16555.jpg" alt="Figure 5.14 – The project structure to control the hs42561k display&#13;&#10;" width="720" height="124"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – The project structure to control the hs42561k display</p>
			<p>We start with the <strong class="source-inline">constants.go</strong> file. This file is going to hold some constants and a convenience function that returns a string for a character. To do this, perform the following steps:</p>
			<ol>
				<li value="1">Add constants for all of the characters. The values are taken from the MAX7219 datasheet. If we <a id="_idIndexMarker300"/>use these values, the <a id="_idIndexMarker301"/>MAX7219 is going to set the correct pins on the display, thanks to the integrated decoder:<p class="source-code">const (</p><p class="source-code">    Zero Character = 0</p><p class="source-code">    One Character = 1</p><p class="source-code">    Two Character = 2</p><p class="source-code">    Three Character = 3</p><p class="source-code">    Four Character = 4</p><p class="source-code">    Five Character = 5</p><p class="source-code">    Six Character = 6</p><p class="source-code">    Seven Character = 7</p><p class="source-code">    Eight Character = 8</p><p class="source-code">    Nine Character = 9</p><p class="source-code">    Dash Character = 10</p><p class="source-code">    E Character = 11</p><p class="source-code">    H Character = 12</p><p class="source-code">    L Character = 13</p><p class="source-code">    P Character = 14</p><p class="source-code">    Blank Character = 15</p><p class="source-code">    Dot Character = 128</p><p class="source-code">)</p></li>
				<li>Now, let's add the <strong class="source-inline">Character</strong> struct, which implements the <strong class="source-inline">String</strong> function. The <strong class="source-inline">String</strong> function will come in handy when debugging. We have truncated the list in the example; of <a id="_idIndexMarker302"/>course, you might <a id="_idIndexMarker303"/>also want to add cases <strong class="source-inline">One</strong> to <strong class="source-inline">Eight</strong>:<p class="source-code">type Character byte</p><p class="source-code">func (char Character) String() string {</p><p class="source-code">    switch char {</p><p class="source-code">    case Zero:</p><p class="source-code">        return "0"</p><p class="source-code">        [...]</p><p class="source-code">    case Nine:</p><p class="source-code">        return "9"</p><p class="source-code">    case Dash:</p><p class="source-code">        return "-"</p><p class="source-code">    case E:</p><p class="source-code">        return "E"</p><p class="source-code">    case H:</p><p class="source-code">        return "H"</p><p class="source-code">    case L:</p><p class="source-code">        return "L"</p><p class="source-code">    case P:</p><p class="source-code">        return "P"</p><p class="source-code">    case Blank:</p><p class="source-code">        return ""</p><p class="source-code">    case Dot:</p><p class="source-code">        return "."</p><p class="source-code">    }</p><p class="source-code">    return ""</p><p class="source-code">}</p></li>
			</ol>
			<p>This is everything we need in the <strong class="source-inline">constants.go</strong> file. </p>
			<p>Now, let's implement the <strong class="source-inline">device.go</strong> file by following these steps:</p>
			<ol>
				<li value="1">Add an interface <a id="_idIndexMarker304"/>named <strong class="source-inline">Device</strong> with a <strong class="source-inline">Configure</strong> function <a id="_idIndexMarker305"/>and a <strong class="source-inline">SetDigit</strong> function:<p class="source-code">type Device interface {</p><p class="source-code">    Configure()</p><p class="source-code">    SetDigit(digit byte, character Character) error</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">struct</strong>, called <strong class="source-inline">device</strong>, which holds the number of digits we want to control and a reference to the MAX7219 device:<p class="source-code">type device struct {</p><p class="source-code">    digitNumber uint8</p><p class="source-code">    displayDevice MAX7219spi.Device</p><p class="source-code">}</p></li>
				<li>Add a function, called <strong class="source-inline">NewDevice</strong>, that returns a <strong class="source-inline">Device</strong> instance:<p class="source-code">func NewDevice(displayDevice MAX7219spi.Device,</p><p class="source-code">    digitNumber uint8) Device {</p><p class="source-code">        return &amp;device{</p><p class="source-code">            displayDevice: displayDevice,</p><p class="source-code">            digitNumber: digitNumber,</p><p class="source-code">        }</p><p class="source-code">}</p></li>
				<li>Add a function named <strong class="source-inline">Configure</strong>. The <strong class="source-inline">Configure</strong> function is used to initialize the display driver. It does this by setting the correct <strong class="source-inline">decode mode</strong> and <strong class="source-inline">scan limit</strong> functions <a id="_idIndexMarker306"/>and stopping the shutdown mode <a id="_idIndexMarker307"/>to bring the display into operational mode, which is implemented in the following snippet:<p class="source-code">func (device *device) Configure() {</p><p class="source-code">    device.displayDevice.StopDisplayTest()</p><p class="source-code">    device.displayDevice.SetDecodeMode(</p><p class="source-code">        device.digitNumber)</p><p class="source-code">    device.displayDevice.SetScanLimit(</p><p class="source-code">        device.digitNumber)</p><p class="source-code">    device.displayDevice.StopShutdownMode()</p></li>
				<li>Write <strong class="source-inline">blank</strong> next to each digit, so we can start off with a clean display, just like the following code:<p class="source-code">for i := 1; i &lt; int(device.digitNumber); i++ {</p><p class="source-code">    device.displayDevice.WriteCommand(byte(i),</p><p class="source-code">        byte(Blank))</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>Now we can define an <em class="italic">error</em> for an invalid digit selection:<p class="source-code">var ErrIllegalDigit = errors.New("Invalid digit</p><p class="source-code">    selected")</p></li>
				<li>The next step is to define a function, called <strong class="source-inline">SetDigit</strong>, that sets the given character to the given digit:<p class="source-code">func (device *device) SetDigit(digit byte, character </p><p class="source-code">    Character) error {</p></li>
				<li>If we have an invalid digit number, we need to validate the <strong class="source-inline">digit</strong> input and return an error. This is <a id="_idIndexMarker308"/>because we cannot display <a id="_idIndexMarker309"/>values on digits that do not exist:<p class="source-code">if uint8(digit) &gt; device.digitNumber {</p><p class="source-code">    return ErrIllegalDigit</p><p class="source-code">}</p></li>
				<li>The last step is to write the <strong class="source-inline">character</strong> to the given <strong class="source-inline">digit</strong>, as shown in the following snippet:<p class="source-code">device.displayDevice.WriteCommand(</p><p class="source-code">    digit, byte(character))</p><p class="source-code">return nil</p><p class="source-code">}</p></li>
			</ol>
			<p>This is the complete logic for the display driver.</p>
			<p>Now, let's add a small example project to validate that our code is working as expected. For that purpose, we create a new folder, called <strong class="source-inline">hs42561k-spi-example</strong>, inside the <strong class="source-inline">Chapter05</strong> folder and create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function in it. The project structure should look like the following:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="Images/Figure_5.15_B16555.jpg" alt="Figure 5.15 – The project structure to validate the code for the hs42561k-spi-example&#13;&#10;" width="936" height="233"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – The project structure to validate the code for the hs42561k-spi-example</p>
			<p>Now, we can add logic to the new <strong class="source-inline">main.go</strong> file. Follow these steps to set up our example program:</p>
			<ol>
				<li value="1">First, we add an <a id="_idIndexMarker310"/>array of <strong class="source-inline">Character</strong>, which contains all possible characters. Here <a id="_idIndexMarker311"/>are the characters that we want to display:<p class="source-code">var characters = [17]hs42561k.Character{</p><p class="source-code">    hs42561k.Zero,</p><p class="source-code">    hs42561k.One,</p><p class="source-code">    hs42561k.Two,</p><p class="source-code">    hs42561k.Three,</p><p class="source-code">    hs42561k.Four,</p><p class="source-code">    hs42561k.Five,</p><p class="source-code">    hs42561k.Six,</p><p class="source-code">    hs42561k.Seven,</p><p class="source-code">    hs42561k.Eight,</p><p class="source-code">    hs42561k.Nine,</p><p class="source-code">    hs42561k.Dash,</p><p class="source-code">    hs42561k.E,</p><p class="source-code">    hs42561k.H,</p><p class="source-code">    hs42561k.L,</p><p class="source-code">    hs42561k.P,</p><p class="source-code">    hs42561k.Blank,</p><p class="source-code">    hs42561k.Dot,</p><p class="source-code">}</p></li>
				<li>Configure the <strong class="source-inline">SPI0</strong> interface. <strong class="source-inline">SDO</strong> is our output pin, and <strong class="source-inline">SCK</strong> is our clock pin. We send data with the most <em class="italic">significant bit first</em> at a <strong class="source-inline">frequency</strong> of 10 MHz. 10 MHz is the <a id="_idIndexMarker312"/>maximum frequency that the <a id="_idIndexMarker313"/>MAX7219 can handle according to the datasheet:<p class="source-code">err := machine.SPI0.Configure(machine.SPIConfig{ </p><p class="source-code">    SDO: machine.D11,</p><p class="source-code">    SCK: machine.D13,</p><p class="source-code">    LSBFirst: false,</p><p class="source-code">    Frequency: 10000000,</p><p class="source-code">})</p></li>
				<li>We check whether there was an error and print the error if there was one. This information helps us when debugging:<p class="source-code">if err != nil {</p><p class="source-code">    println("failed to configure spi:", err.Error())</p><p class="source-code">}</p></li>
				<li>Initialize the MAX7219 display driver with <strong class="source-inline">D6</strong> as the load pin and <strong class="source-inline">machine.SPI0</strong> as the SPI bus:<p class="source-code">displayDriver := max7219spi.NewDevice(</p><p class="source-code">    machine.D6, machine.SPI0)</p><p class="source-code">displayDriver.Configure()</p></li>
				<li>Now, we need to initialize the <strong class="source-inline">display</strong> with 4 digits. After this step, the display is ready to be used:<p class="source-code">display := hs42561k.NewDevice(displayDriver, 4)</p><p class="source-code">display.Configure()</p></li>
				<li>For each <strong class="source-inline">character</strong> in <strong class="source-inline">characters</strong>, set the <strong class="source-inline">character</strong> to all digits and sleep for half a <a id="_idIndexMarker314"/>second. That way, we can test <a id="_idIndexMarker315"/>whether we are able to display every possible character on every digit:<p class="source-code">for {</p><p class="source-code">    for _, character := range characters {</p><p class="source-code">        println("writing", "characterValue:",</p><p class="source-code">            character.String())</p><p class="source-code">        display.SetDigit(4, character)</p><p class="source-code">        display.SetDigit(3, character)</p><p class="source-code">        display.SetDigit(2, character)</p><p class="source-code">        display.SetDigit(1, character)</p><p class="source-code">        time.Sleep(500 * time.Millisecond)</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This is the complete example program. We can go ahead and flash the program using the following command:</p>
			<p class="source-code">tinygo flash --target=arduino-nano33 Chapter05/hs42561k-spi-example/main.go</p>
			<p>If everything went as expected, the display should now start to print each possible character.</p>
			<p>We have now learned how to control a 7-segment display, learned about the MAX7219 display <a id="_idIndexMarker316"/>driver, wrote a library for the display driver and the display, and also wrote an example program. In <a id="_idIndexMarker317"/>the next section, we are going to use these libraries and the ultrasonic distance sensor to build our final project of this chapter.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Putting it all together</h1>
			<p>In our final project of this chapter, we are going to make use of everything we have learned in the preceding sections. We are going to use the ultrasonic distance sensor to recognize a hand movement in close proximity to the sensor. We are using the 7-segment display to count down from 20 to 0 and we are going to use a buzzer, to provide an additional signal, for the timer start and the timer end. In Germany, it is officially recommended that we wash our hands for at least 20 seconds, which is why we will also add a timer for 20 seconds. Putting all of this together, we will create a touchless handwash timer.</p>
			<p>Before we start to write the code to control the hand wash timer, we need to add a buzzer. We can add this by following these steps:</p>
			<ol>
				<li value="1">Put the <em class="italic">GND</em> pin of the buzzer in <em class="italic">D53</em> and the <em class="italic">VCC</em> pin of the buzzer into <strong class="source-inline">D54</strong>. If that is too close together for your buzzer's pins, just put the buzzer in and wire the following two wires accordingly.</li>
				<li>Connect the <em class="italic">GND</em> pin of the Arduino with <em class="italic">A53</em> on the breadboard using a jumper wire.</li>
				<li>Connect the <em class="italic">D5</em> pin of the Arduino with <em class="italic">A54</em> on the breadboard using a jumper wire.</li>
			</ol>
			<p>The circuit should look similar to the following diagram:</p>
			<p class="figure-caption">.</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="Images/Figure_5.16_B16555.jpg" alt="Figure 5.16 – The touchless handwash timer circuit&#13;&#10;" width="1219" height="764"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – The touchless handwash timer circuit</p>
			<p>Now that we have set up the circuit, we can go ahead and write the logic. We start by creating a new folder, called <strong class="source-inline">touchless-handwash-timer</strong>, inside the <strong class="source-inline">Chapter05</strong> folder. Then, we create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function. The project structure should look like the following:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="Images/Figure_5.17_B16555.jpg" alt="Figure 5.17 – The project structure for the handwash timer&#13;&#10;" width="818" height="231"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – The project structure for the handwash timer</p>
			<p>Now, follow these steps inside the <strong class="source-inline">main</strong> function to implement the logic for the touchless handwash timer:</p>
			<ol>
				<li value="1">The first step is to initialize the <strong class="source-inline">SPI0</strong> interface, as follows:<p class="source-code">err := machine.SPI0.Configure(machine.SPIConfig{</p><p class="source-code">       SDO: machine.D11,</p><p class="source-code">       SCK: machine.D13,</p><p class="source-code">       LSBFirst: false,</p><p class="source-code">       Frequency: 10000000,</p><p class="source-code">})</p></li>
				<li>If an error occurs, we print it. Doing so enables us to debug the program by monitoring the output of the serial port:<p class="source-code">if err != nil {</p><p class="source-code">    println("failed to configure spi:", err.Error())</p><p class="source-code">}</p></li>
				<li>Now we want to initialize the <strong class="source-inline">display</strong>:<p class="source-code">displayDriver := max7219spi.NewDevice(</p><p class="source-code">    machine.D6, machine.SPI0)</p><p class="source-code">displayDriver.Configure()</p><p class="source-code">display := hs42561k.NewDevice(displayDriver, 4)</p><p class="source-code">display.Configure()</p></li>
				<li>After that is done, we can go on and initialize the <strong class="source-inline">distanceSensor</strong>:<p class="source-code">distanceSensor := hcsr04.NewHCSR04(</p><p class="source-code">    machine.D2, machine.D3, 60)</p><p class="source-code">distanceSensor.Configure()</p></li>
				<li>Now, we initialize the <strong class="source-inline">buzzer</strong>. If you skipped <a href="B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 4</em></a>, <em class="italic">Building a Plant Watering System</em>, simply import the buzzer package from <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer</a>:<p class="source-code">buzzer := buzzer.NewBuzzer(machine.D5)</p><p class="source-code">buzzer.Configure()</p></li>
				<li>Now, we get and print the <strong class="source-inline">currentDistance</strong>. Printing the distance helps us to debug the program if any problems occur later on. This looks like the following:<p class="source-code">for {</p><p class="source-code">    currentDistance := distanceSensor.GetDistance()</p><p class="source-code">    println("current distance:", currentDistance)</p></li>
				<li>If the <strong class="source-inline">currentDistance</strong> is between <strong class="source-inline">12</strong> and <strong class="source-inline">25</strong> centimeters, activate the timer. This is shown with the following snippet:<p class="source-code">if currentDistance &gt;= 12 &amp;&amp; currentDistance &lt;= 25 {</p><p class="source-code">    println("timer activated")</p><p class="source-code">    handleTimer(display, displayDriver, buzzer)</p><p class="source-code">}</p></li>
				<li>Now we have to sleep for <strong class="source-inline">100</strong> milliseconds. We do this to prevent the echoes from overlapping:<p class="source-code">time.Sleep(100 * time.Millisecond)</p><p class="source-code">}</p></li>
				<li>The last function is the <strong class="source-inline">handleTimer</strong> function, which takes <strong class="source-inline">display</strong>, <strong class="source-inline">displayDriver</strong>, and <strong class="source-inline">buzzer</strong> as parameters:<p class="source-code">func handleTimer(display hs42561k.Device,</p><p class="source-code">    displayDriver max7219spi.Device, buzzer</p><p class="source-code">        buzzer.Buzzer) {</p></li>
				<li>First, we make sure that <strong class="source-inline">display</strong> is in operational mode:<p class="source-code">display.Configure()</p></li>
				<li>Now we let the <strong class="source-inline">buzzer</strong> beep two times to indicate that the timer has started:<p class="source-code">buzzer.Beep(100*time.Millisecond, 2)</p></li>
				<li>Then, we count from <strong class="source-inline">20</strong> to <strong class="source-inline">0</strong>. This represents the 20 seconds that our timer is running, as follows:<p class="source-code">for i := 20; i &gt; 0; i-- {</p><p class="source-code">    println("counting:", i)</p></li>
				<li>If we have more than 10 seconds left, we need to set the third <strong class="source-inline">digit</strong>. Because we need to set more than one digit, we are going to set digit <strong class="source-inline">3</strong> and <strong class="source-inline">4</strong>, which looks like the following:<p class="source-code">if i &gt;= 10 {</p><p class="source-code">    display.SetDigit(3, hs42561k.Character(i/10))</p><p>Additionally, we need to handle all numbers that have a trailing 0. And this looks similar to the following snippet:</p><p class="source-code">if i%10 == 0 {</p><p class="source-code">    display.SetDigit(4, hs42561k.Character(0))</p><p class="source-code">} else {</p><p class="source-code">    display.SetDigit(4, hs42561k.Character(i-10))</p><p class="source-code">}</p><p>Now, we need to handle all numbers that are smaller than 10. This is implemented in the following snippet:</p><p class="source-code">} else {</p><p class="source-code">    display.SetDigit(3, hs42561k.Blank)</p><p class="source-code">    display.SetDigit(4, hs42561k.Character(i))</p><p class="source-code">}</p><p class="source-code">time.Sleep(time.Second)</p><p class="source-code">}</p></li>
				<li>After the timer runs out, we reset both used digits by setting them to <strong class="source-inline">blank</strong>:<p class="source-code">display.SetDigit(3, hs42561k.Blank)</p><p class="source-code">display.SetDigit(4, hs42561k.Blank)</p><p>Let the <strong class="source-inline">buzzer</strong> beep for half a second to indicate that the timer has finished:</p><p class="source-code">buzzer.Beep(500*time.Millisecond, 1)</p></li>
				<li>Put the display driver into shutdown mode:<p class="source-code">displayDriver.StartShutdownMode()</p></li>
			</ol>
			<p>This is all the code we need. Now, try the code by flashing it onto the Arduino using the following command:</p>
			<p class="source-code">tinygo flash –target=arduino-nano33 Chapter05/touchless-handwash-timer/main.go</p>
			<p>We have successfully built and flashed the program. Now it is time to try it out.</p>
			<p>So, we combined all the components that we built throughout this chapter into this final project, and we used the components to recognize the movement from a certain distance in front of the sensor to start a timer. This was the final project of this chapter.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor116"/>Summary</h1>
			<p>In this chapter, we have learned about the technical specifications of the Arduino Nano 33 IoT and how to calculate the distance between an object and an ultrasonic distance sensor. Additionally, we learned how the sensor works internally and wrote a library for it. We also learned that unit testing is supported in TinyGo and wrote some tests for the ultrasonic distance sensor library. Then, we learned how to use a MAX7219 serial interfaced display driver to control a 7-segment display, and we wrote a library for the MAX7219 and the 7-segment display. At the end of this chapter, we put all of the drivers into a single project and only had to add a small amount of control logic to build a touchless handwash timer.</p>
			<p>In the next chapter, we are going to learn how to use 16x02 LCD and ST7735 TFT displays.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Questions</h1>
			<ol>
				<li value="1">Is it possible to draw 5V output from the Arduino Nano 33 IoT?</li>
				<li>Why do we divide <strong class="source-inline">pulseLength</strong> by 2 when calculating the distance to an object?</li>
				<li>Change the code so that the handwash timer counts from 120 to 0. Use three digits to display the remaining seconds.</li>
			</ol>
		</div>
	</div></body></html>