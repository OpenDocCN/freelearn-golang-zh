["```go\n    msi:\n\n    ```", "```go\n\n    ```", "```go\n    bossa to the path using the following command: \n\n    ```", "```go\n\n    ```", "```go\n    sudo apt install libreadline-dev libwxgtk3.0-gtk3-dev\n    git clone https://github.com/shumatech/BOSSA.git\n    cd BOSSAmakesudo \n    cp bin/bossac /usr/local/bin\n    ```", "```go\nbossac –help\n```", "```go\nTime = Distance / Speed  \nt = s/v \nt = 30cm / 0.034m/us\nt = 882.352941176us\n```", "```go\nDistance = Time * Speed \n30cm = 882.352941176us * 0.34m/us\n```", "```go\nVout = Vs * R2 / (R1 + R2)\n```", "```go\n    const speedOfSound = 0.0343\n    ```", "```go\n    type Device interface {\n            Configure()\n            GetDistance() uint16\n            GetDistanceFromPulseLength(\n                float32) uint16\n    }\n    ```", "```go\n    type device struct {\n            trigger machine.Pin\n            echo machine.Pin\n            timeout int64\n    }\n    ```", "```go\n    func NewDevice(trigger, echo machine.Pin, maxDistance\n        float32) HCSR04 {\n    ```", "```go\n    timeout := int64(maxDistance * 2 / speedOfSound)\n    ```", "```go\n    return &device{\n            trigger: trigger,\n            echo: echo,\n            timeout: timeout,\n    }\n    }\n    ```", "```go\n    func (sensor *device) Configure() {\n        sensor.trigger.Configure(\n            machine.PinConfig{Mode: machine.PinOutput},\n        )\n        sensor.echo.Configure(\n            machine.PinConfig{Mode: machine.PinInput},\n        )\n    }\n    ```", "```go\n    func (sensor *device) sendPulse() {\n        sensor.trigger.High()\n        time.Sleep(10 * time.Microsecond)\n        sensor.trigger.Low()\n    }\n    ```", "```go\n    func (sensor *device) GetDistance() uint16 {\n        i := 0\n        timeoutTimer := time.Now()\n        sensor.sendPulse()\n        for {\n            if sensor.echo.Get() {\n                timeoutTimer = time.Now()\n                break\n            } \n            i++\n    ```", "```go\n    if i > 15 {\n        microseconds := time.Since(timeoutTimer).\n            Microseconds()\n        if microseconds > sensor.timeout {\n            return 0\n        }\n    }\n    }\n    ```", "```go\n    var pulseLength float32\n    i = 0\n    for {\n        if !sensor.echo.Get() {\n            microseconds := time.Since(timeoutTimer).\n                Microseconds()\n            pulseLength = float32(microseconds)\n            break\n        }\n        i++\n        if i > 15 {\n            microseconds := time.Since(timeoutTimer).\n                Microseconds()\n            if microseconds > sensor.timeout {\n                return 0\n            }\n        }\n    }\n    return sensor.GetDistanceFromPulseLength(pulseLength)\n    }\n    ```", "```go\n    func (sensor *hcsr04) GetDistanceFromPulseLength(\n        pulseLength float32) uint16 {\n    ```", "```go\n    pulseLength = pulseLength / 2\n    ```", "```go\n    result := pulseLength * speedOfSound\n    ```", "```go\n    return uint16(result)\n    }\n    ```", "```go\n    func TestGetDistanceFromPulseLength_30cm(t *testing.T)\n    {\n    ```", "```go\n    sensor := hcsr04.NewHCSR04(\n        machine.D2, machine.D3, 100)\n    ```", "```go\n    distance := sensor.GetDistanceFromPulseLength(\n                1749.27113703)\n    ```", "```go\n    if distance != 30 {\n        t.Error(\"Expected distance: 30cm\", \"actual \n            distance: \", distance, \"cm\")\n    }\n    }\n    ```", "```go\ntinygo test --tags \"arduino_nano33\" Chapter05/ultrasonic-distance-sensor/driver_test.go\n```", "```go\n=== RUN   TestGetDistanceFromPulseLength_30cm\n--- PASS: TestGetDistanceFromPulseLength_30cm\n```", "```go\n    func TestGetDistanceFromPulseLength_TableDriven(\n        t *testing.T) {\n    ```", "```go\n    var testCases = [4]struct {\n        Name string\n        Result uint16\n        PulseLength float32\n    }{\n        { \n            Name: \"1cm\", \n            Result: 1, \n            PulseLength: 58.8235294117},\n        { \n            Name: \"30cm\", \n            Result: 30, \n            PulseLength: 1749.27113703},\n        { \n            Name: \"60cm\", \n            Result: 60, \n            PulseLength: 3498.54227405},\n        { \n            Name: \"400cm\", \n            Result: 400, \n            PulseLength: 23323.6151603},\n    }\n    ```", "```go\n    sensor := hcsr04.NewDevice(\n              machine.D2, machine.D3, 100)\n    ```", "```go\n    for _, testCase := range testCases {\n        t.Run(testCase.Name, func(t *testing.T) {\n    ```", "```go\n    distance := sensor.GetDistanceFromPulseLength(\n        testCase.PulseLength)\n    if distance != testCase.Result {\n        t.Error(\"Expected distance:\", testCase.Name,\n            \"actual distance: \", distance, \"cm\")\n    }\n    })\n    }\n    }\n    ```", "```go\ntinygo test --tags \"arduino_nano33\" Chapter5/ultrasonic-distance-sensor/driver_test.go\n```", "```go\nsensor := hcsr04.NewHCSR04(machine.D2, machine.D3, 80)\nsensor.Configure()\nfor {\n    distance := sensor.GetDistance()\n    if distance != 0 {\n        println(\"Current distance:\", distance, \"cm\")\n}\n    time.Sleep(time.Second)\n}\n```", "```go\ntinygo flash --target=arduino-nano33 Chapter05/ultrasonic-distance-sensor-example/main.go\n```", "```go\nconst ( \n    REG_NOOP byte = 0x00\n    REG_DIGIT0 byte = 0x01\n    REG_DIGIT1 byte = 0x02\n    REG_DIGIT2 byte = 0x03\n    REG_DIGIT3 byte = 0x04\n    REG_DIGIT4 byte = 0x05\n    REG_DIGIT5 byte = 0x06\n    REG_DIGIT6 byte = 0x07\n    REG_DIGIT7 byte = 0x08\n    REG_DECODE_MODE byte = 0x09\n    REG_INTENSITY byte = 0x0A\n    REG_SCANLIMIT byte = 0x0B\n    REG_SHUTDOWN byte = 0x0C\n    REG_DISPLAY_TEST byte = 0x0F\n)\n```", "```go\n    type Device interface {\n        WriteCommand(register, data byte)\n        Configure()\n        StartShutdownMode()\n        StopShutdownMode()\n        StartDisplayTest()\n        StopDisplayTest()\n        SetDecodeMode(digitNumber uint8)\n        SetScanLimit(digitNumber uint8)\n    }\n    ```", "```go\n    type device struct {\n        bus machine.SPI\n        load machine.Pin \n    }\n    ```", "```go\n    func NewDevice(\n            load machine.Pin, bus machine.SPI) Device {\n        return &device{\n            load: load,\n            bus: bus,\n        }\n    }\n    ```", "```go\n    func (driver *device) WriteCommand(\n            register, data byte) {\n        driver.load.Low()\n        driver.writeByte(register)\n        driver.writeByte(data)\n        driver.load.High()\n    }\n    ```", "```go\n    func (driver *device) Configure() {\n        outPutConfig := machine.PinConfig{\n            Mode: machine.PinOutput,\n        }\n        driver.load.Configure(outPutConfig)\n    }\n    ```", "```go\n    func (driver *device) SetScanLimit(digitNumber uint8) {\n        driver.WriteCommand(REG_SCANLIMIT, byte(\n            digitNumber-1))\n    }\n    ```", "```go\n    func (driver *device) SetDecodeMode(digitNumber uint8) {\n    ```", "```go\n    switch digitNumber {\n    case 1: driver.WriteCommand(REG_DECODE_MODE, 0x01)\n    ```", "```go\n    case 2, 3, 4: driver.WriteCommand(\n        REG_DECODE_MODE, 0x0F)\n    ```", "```go\n    case 8: driver.WriteCommand(REG_DECODE_MODE, 0xFF)\n    ```", "```go\n    default: driver.WriteCommand(REG_DECODE_MODE, REG_SHUTDOWN register. This looks like the following snippet:\n\n    ```", "```go\n\n    ```", "```go\n    func (driver *device) StartDisplayTest() {\n        driver.WriteCommand(REG_DISPLAY_TEST, 0x01)\n    }\n    func (driver *device) StopDisplayTest() {\n        driver.WriteCommand(REG_DISPLAY_TEST, 0x00)\n    }\n    ```", "```go\n    func (driver *device) writeByte(data byte) {\n        driver.bus.Transfer(data)\n    }\n    ```", "```go\n    const (\n        Zero Character = 0\n        One Character = 1\n        Two Character = 2\n        Three Character = 3\n        Four Character = 4\n        Five Character = 5\n        Six Character = 6\n        Seven Character = 7\n        Eight Character = 8\n        Nine Character = 9\n        Dash Character = 10\n        E Character = 11\n        H Character = 12\n        L Character = 13\n        P Character = 14\n        Blank Character = 15\n        Dot Character = 128\n    )\n    ```", "```go\n    type Character byte\n    func (char Character) String() string {\n        switch char {\n        case Zero:\n            return \"0\"\n            [...]\n        case Nine:\n            return \"9\"\n        case Dash:\n            return \"-\"\n        case E:\n            return \"E\"\n        case H:\n            return \"H\"\n        case L:\n            return \"L\"\n        case P:\n            return \"P\"\n        case Blank:\n            return \"\"\n        case Dot:\n            return \".\"\n        }\n        return \"\"\n    }\n    ```", "```go\n    type Device interface {\n        Configure()\n        SetDigit(digit byte, character Character) error\n    }\n    ```", "```go\n    type device struct {\n        digitNumber uint8\n        displayDevice MAX7219spi.Device\n    }\n    ```", "```go\n    func NewDevice(displayDevice MAX7219spi.Device,\n        digitNumber uint8) Device {\n            return &device{\n                displayDevice: displayDevice,\n                digitNumber: digitNumber,\n            }\n    }\n    ```", "```go\n    func (device *device) Configure() {\n        device.displayDevice.StopDisplayTest()\n        device.displayDevice.SetDecodeMode(\n            device.digitNumber)\n        device.displayDevice.SetScanLimit(\n            device.digitNumber)\n        device.displayDevice.StopShutdownMode()\n    ```", "```go\n    for i := 1; i < int(device.digitNumber); i++ {\n        device.displayDevice.WriteCommand(byte(i),\n            byte(Blank))\n    }\n    }\n    ```", "```go\n    var ErrIllegalDigit = errors.New(\"Invalid digit\n        selected\")\n    ```", "```go\n    func (device *device) SetDigit(digit byte, character \n        Character) error {\n    ```", "```go\n    if uint8(digit) > device.digitNumber {\n        return ErrIllegalDigit\n    }\n    ```", "```go\n    device.displayDevice.WriteCommand(\n        digit, byte(character))\n    return nil\n    }\n    ```", "```go\n    var characters = [17]hs42561k.Character{\n        hs42561k.Zero,\n        hs42561k.One,\n        hs42561k.Two,\n        hs42561k.Three,\n        hs42561k.Four,\n        hs42561k.Five,\n        hs42561k.Six,\n        hs42561k.Seven,\n        hs42561k.Eight,\n        hs42561k.Nine,\n        hs42561k.Dash,\n        hs42561k.E,\n        hs42561k.H,\n        hs42561k.L,\n        hs42561k.P,\n        hs42561k.Blank,\n        hs42561k.Dot,\n    }\n    ```", "```go\n    err := machine.SPI0.Configure(machine.SPIConfig{ \n        SDO: machine.D11,\n        SCK: machine.D13,\n        LSBFirst: false,\n        Frequency: 10000000,\n    })\n    ```", "```go\n    if err != nil {\n        println(\"failed to configure spi:\", err.Error())\n    }\n    ```", "```go\n    displayDriver := max7219spi.NewDevice(\n        machine.D6, machine.SPI0)\n    displayDriver.Configure()\n    ```", "```go\n    display := hs42561k.NewDevice(displayDriver, 4)\n    display.Configure()\n    ```", "```go\n    for {\n        for _, character := range characters {\n            println(\"writing\", \"characterValue:\",\n                character.String())\n            display.SetDigit(4, character)\n            display.SetDigit(3, character)\n            display.SetDigit(2, character)\n            display.SetDigit(1, character)\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n    }\n    ```", "```go\ntinygo flash --target=arduino-nano33 Chapter05/hs42561k-spi-example/main.go\n```", "```go\n    err := machine.SPI0.Configure(machine.SPIConfig{\n           SDO: machine.D11,\n           SCK: machine.D13,\n           LSBFirst: false,\n           Frequency: 10000000,\n    })\n    ```", "```go\n    if err != nil {\n        println(\"failed to configure spi:\", err.Error())\n    }\n    ```", "```go\n    displayDriver := max7219spi.NewDevice(\n        machine.D6, machine.SPI0)\n    displayDriver.Configure()\n    display := hs42561k.NewDevice(displayDriver, 4)\n    display.Configure()\n    ```", "```go\n    distanceSensor := hcsr04.NewHCSR04(\n        machine.D2, machine.D3, 60)\n    distanceSensor.Configure()\n    ```", "```go\n    buzzer := buzzer.NewBuzzer(machine.D5)\n    buzzer.Configure()\n    ```", "```go\n    for {\n        currentDistance := distanceSensor.GetDistance()\n        println(\"current distance:\", currentDistance)\n    ```", "```go\n    if currentDistance >= 12 && currentDistance <= 25 {\n        println(\"timer activated\")\n        handleTimer(display, displayDriver, buzzer)\n    }\n    ```", "```go\n    time.Sleep(100 * time.Millisecond)\n    }\n    ```", "```go\n    func handleTimer(display hs42561k.Device,\n        displayDriver max7219spi.Device, buzzer\n            buzzer.Buzzer) {\n    ```", "```go\n    display.Configure()\n    ```", "```go\n    buzzer.Beep(100*time.Millisecond, 2)\n    ```", "```go\n    for i := 20; i > 0; i-- {\n        println(\"counting:\", i)\n    ```", "```go\n    if i >= 10 {\n        display.SetDigit(3, hs42561k.Character(i/10))\n    ```", "```go\n    if i%10 == 0 {\n        display.SetDigit(4, hs42561k.Character(0))\n    } else {\n        display.SetDigit(4, hs42561k.Character(i-10))\n    }\n    ```", "```go\n    } else {\n        display.SetDigit(3, hs42561k.Blank)\n        display.SetDigit(4, hs42561k.Character(i))\n    }\n    time.Sleep(time.Second)\n    }\n    ```", "```go\n    display.SetDigit(3, hs42561k.Blank)\n    display.SetDigit(4, hs42561k.Blank)\n    ```", "```go\n    buzzer.Beep(500*time.Millisecond, 1)\n    ```", "```go\n    displayDriver.StartShutdownMode()\n    ```", "```go\ntinygo flash –target=arduino-nano33 Chapter05/touchless-handwash-timer/main.go\n```"]