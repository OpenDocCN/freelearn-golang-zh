- en: '*Chapter 5*: Building a Touchless Handwash Timer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082), *Building
    a Plant Watering System*, we learned how the ADC interface works, and we used
    that knowledge to write libraries for a capacitive soil moisture sensor and a
    water level sensor. We also wrote a small library to control a buzzer and learned
    how relays work and used that knowledge to control a pump using our code. Then
    we used all this knowledge to build an automated plant watering system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to build a touchless handwash timer. After working
    through this chapter, you will know how ultrasonic sound sensors work and how
    to measure distance with them. We are going to utilize this knowledge to create
    a sensor that recognizes a hand that is between 20 and 30 centimeters away from
    the sensor to start a timer. The timer will then be displayed on a 7-segment display.
    While implementing this, we will also learn about the MAX7219 chip and how to
    use it to control different display types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Arduino Nano 33 IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 7-segment display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to need the following components for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Nano 33 IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HC-SR04 sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An external power supply module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HS420561K 4-Digit 7-segment display common cathode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A MAX7219 or MAX7221 serial input/output common-cathode display driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 10,000 Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 1,000 Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 2,000 Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 breadboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wire cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the components are part of the so-called Arduino Starter Kit. If you
    do not have such a set, they can be acquired at any electronics supply store.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05)
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3e2IYgG](https://bit.ly/3e2IYgG)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Arduino Nano 33 IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have reached a point where the TinyGo support for the Arduino UNO has reached
    its limit. At the time of writing, it is not possible to resolve this shortcoming
    for the current and following chapters using an Arduino UNO. The cause of this
    is a missing `Pull` request for that opened by me. Additionally, the **Alf and
    Vegard''s RISC** (**AVR**) backend in the TinyGo compiler toolchain has some problems
    in the versions used by the current TinyGo version, and the code won''t compile.
    So, let''s take a look at another board, which is fully supported by TinyGo—the
    Arduino Nano 33 IoT. Compared to UNO, the Nano 33 IoT is a powerhouse. Here are
    its technical specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microcontroller**: AMD21 Cortex®-M0+ 32bit low power ARM MCU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radio module**: U-blox NINA-W102'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating voltage**: 3.3V'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input Voltage (limit)**: 2V'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DC Current per I/O Pin**: 7 mA'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clock speed**: 48 MHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU Flash Memory**: 256 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SRAM**: 32 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIO Pins**: 14'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analog input pins**: 8 (8/10/12 bit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analog output pins**: 1 (10 bit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the Arduino Nano 33 IoT has a much higher clock speed, more RAM, and more
    flash memory while operating on 3.3V instead of 5V. Additionally, on top of that,
    the Nano 33 IoT is capable of Wi-Fi communication.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a brief look at the 5V output capabilities of the Arduino Nano
    33 IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although the Arduino Nano 33 IoT has a 5V output pin, this pin is deactivated
    by default. To activate that pin, some soldering needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: When powering the Arduino Nano 33 IoT through USB, we also have a 5V current
    available on the `Vin` pin, but that pin is intended to power the Arduino. We
    will be handling devices that require 5V input, but that is not a problem; we
    are just going to use an external power supply to power these devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a brief understanding, let''s take a look at the pinout. The
    following diagram shows the pinout of the Arduino Nano 33 IoT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The Arduino Nano 33 IoT pinout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The Arduino Nano 33 IoT pinout
  prefs: []
  type: TYPE_NORMAL
- en: The source of the pinout diagram can be found at [https://store.arduino.cc/arduino-nano-33-iot](https://store.arduino.cc/arduino-nano-33-iot).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we took a brief look at the technical specs of the Arduino
    Nano 33 IoT. However, before we can use it in our project, we need to install
    some dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Bossa
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bossa is needed in order to flash programs onto the Arduino Nano 33 IoT.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the installing process on a Mac system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply install the dependencies using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: https://github.com/shumatech/BOSSA/releases/download/1.9.1/bossa-x64-1.9.1.msi
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When executing the `msi`, choose the following installation path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: set PATH=%PATH%;"c:\Program Files\BOSSA";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to install `bossa` on a Linux system, execute the following commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify the installation success, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Up-to-date information on how to install the needed dependencies can be found
    at [https://tinygo.org/microcontrollers/arduino-nano33-iot/](https://tinygo.org/microcontrollers/arduino-nano33-iot/).
  prefs: []
  type: TYPE_NORMAL
- en: We have now set up the dependencies required to flash programs on the Arduino
    Nano 33 IoT. Let's move on to the first project of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to measure distances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever wondered how touchless soap dispensers or touchless blow dryers
    register that there is a hand beneath them, there is a good chance that they are
    using the HC-SR04 ultrasonic sensor. We are going to use this sensor to measure
    the distance between an object and the sensor. Let's begin with the HC-SR04 sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the HC-SR04 sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HC-SR04 sensor emits an ultrasound at 40k Hz, which travels through the
    air and bounces back if the emitted pulse collides with any object in its path.
    The sensor cannot be used as a detector for other ultrasound pulses, as it only
    registers echoes from the exact same pulse that it itself emitted. Typically,
    these sensors look similar to the one in the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The HC-SR04 sensor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The HC-SR04 sensor
  prefs: []
  type: TYPE_NORMAL
- en: 'This sensor has the following technical specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a detection range from 2 to 400 centimeters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It draws less than 2 mA current.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a working voltage of 5V.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a resolution of 0.3 centimeters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an angle of fewer than 15 degrees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sensor has the following three ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '*VCC*: This is used to power the sensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TRIG*: This triggers the pulse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ECHO*: This receives the echo of the pulse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how exactly an ultrasonic pulse can be used to measure
    the distance between the sender and an object. The sensor emits eight pulses that
    travel through the air. If they hit an object, they get reflected and travel back
    as an echo, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Eight pulses and one echo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Eight pulses and one echo
  prefs: []
  type: TYPE_NORMAL
- en: When recognizing the echo, the **echo** pin will be set to high from the sensor
    for the exact same time frame that the pulse needed to leave and return to the
    sensor. Now, we only need some math to calculate the distance.
  prefs: []
  type: TYPE_NORMAL
- en: The pulse travels at 340 m/s, which is the speed of sound in the air. This can
    also be expressed as 0.034 m/μs (microseconds). If the object is about 30 centimeters
    away from the sensor, the pulse needs to travel for about 882 microseconds. The
    **echo** pin will be set to high for exactly as long as the pulse needs to travel
    the entire path; that is why we need to divide the result by 2\. And as the last
    step, we are going to divide the travel time by 0.034 to get the traveled distance
    in centimeters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how this example works out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rearrange that formula to get `distance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we have learned how to use an ultrasonic sound sensor, theoretically, we
    can now go on to prove this theory by trying it out in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start to assemble the circuit, we need to make sure that the echo
    pin from the sensor, which will be connected to an input pin on the Arduino, does
    send 3.3V signals instead of 5V signals. For this, we can make use of a **voltage
    divider**. The echo pin of the sensor outputs 5V, but the Arduino Nano 33 IoT
    should not be connected to 5V, as this could cause permanent damage to the Arduino.
    That is why we make use of the voltage divider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula to calculate the **output voltage** (**Vout**) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Vs` is the source voltage, `R2` is the resistor that is connected to
    the source voltage, and `R1` is the resistor that is connected to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are going to need a 2,000-Ohm resistor for R2 and a 1,000-Ohm resistor
    for R1\. This is going to result in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3.333V = 5 * 2,000 / (1,000 + 2,000)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how to build a voltage divider, we can go ahead and
    assemble the circuit using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the HC-SR04 sensor on the breadboard with the *VCC* pin in the *J* row
    on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *VCC* lane on the power bus with *VCC* of the sensor using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *GND* lane on the power bus with *GND* of the sensor using a jumper
    wire. Connect *D2* from the Arduino with *Trig* of the sensor using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a 2,000-Ohm resistor to connect `GND` with *C53* on the breadboard using
    a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a 1,000-Ohm resistor to connect *Echo* with *A53* on the breadboard jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, connect *D3* from the Arduino with *B53* on the breadboard using a jumper
    wire. We can read the 3.3V *Echo* signal here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an external power supply on the breadboard. Take care to **set the jumpers
    to 5V**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is everything we need to write and test a library. Your circuit should
    now look similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The HC-SR04 circuit (image taken from Fritzing)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – The HC-SR04 circuit (image taken from Fritzing)
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how an ultrasonic sound sensor works and have assembled
    a circuit. As has been the case with the previous chapters, here, we also start
    by creating a library to control the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to write a library that has a function that returns the current
    distance from the sensor to an object, or `0` if the object is out of range. We
    start by creating a new folder, called `Chapter05`, inside our project. Inside
    the new `Chapter05` folder, create a new folder, called `ultrasonic-distance-sensor`,
    and create a new `driver.go` file. Name the package `hcsr04`. Your folder structure
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The project structure for writing a library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – The project structure for writing a library
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have set up our project structure, we can start to write the actual
    logic. To do this, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new constant at the package level, name it `speedOfSound`, and set
    its value to `0.0343`, which is the speed of sound in centimeters per microsecond:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a new interface and call it HCSR04, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define a new `struct`, called `hcsr04`, which holds the `trigger`
    and `echo` `pins` as well as a `timeout` in microseconds, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add a function named `NewHCSR04`, which takes a `trigger` and `echo`
    pin along with the `maxDistance` in centimeters and returns `HCSR04`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `timeout` in microseconds. We multiply the `maxDistance` by `2`
    because the pulse needs to travel to an object and back again. We then divide
    the result by `speedOfSound`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `hcsr04`, set `trigger`, `echo`, and `timeout`, and
    return a pointer to the new instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Configure` function, which is a pointer receiver that configures `trigger`
    as output and the `echo` pin as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `sendPulse` function, which pulls the `trigger` high for `10` microseconds
    and then sets the `trigger` to low again. This will trigger eight ultrasonic pulses
    in the HC-SR04 sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new function named `GetDistance`, which returns `uint16` and is a pointer
    receiver. First, the function sends out a pulse and then listens for the echo.
    We receive an incoming echo when the echo pin reads a high value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether `i` is greater than `15`. We do this to save some time, as comparing
    an integer is a very fast operation in comparison to getting a current timestamp.
    If the time since our timer started is greater than our configured `timeout`,
    then return `0`, which we can use as the `timeout` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have to measure the time when the `echo` pin is set to high:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function named `GetDistanceFromPulseLength`, which takes `pulseLength`
    as a parameter, returns the distance in centimeters, and is a pointer receiver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the `pulseLength` parameter is the time that the signal needs to travel
    to the target and back, we need to divide it by `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the result in centimeters, we need to multiply `pulseLength` with `speedOfSound`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return `result` as `uint16`, as we don''t care about decimal places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is all the code we need for the library. From now on, we can use this library
    to measure distances using an HCSR-04 sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to test the library in a real-world example, let's use the
    `GetDistanceFromPulseLength` function to take a brief look at how unit testing
    can be done in TinyGo.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in TinyGo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TinyGo does support unit testing, which comes in handy when you have complicated
    logic and do not want to flash every single change onto your microcontroller when
    you are trying to find a bug. Let''s take a look at what is currently is supported
    in a practical way. To do this, create a new file, called `driver_test.go`, inside
    the `ultrasonic-distance-sensor` folder and name the package `hcsr04_test`. The
    project structure should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The project structure for the first unit test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – The project structure for the first unit test
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add our first unit test in TinyGo. To do so, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new function named `TestGetDistanceFromPulseLength_30cm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `HCSR04` instance. We do not really need a parameter for this
    test, as these parameters will not be used; however, we can add some correct ones
    anyway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `distance` for the given `pulseLength` parameter, which is exactly
    the length of a pulse for a distance of 30 centimeters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the `distance` equals `30`. If it does not, we fail the test
    and log some information, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This was our first unit test in TinyGo. Do not forget to import the `testing`
    package. Just like in the normal program code, we can make use of the standard
    Golang package. You can run the test by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: TinyGo internally makes heavy use of `arduino_nano33`, are used to decide which
    packages and files are needed to build the current code. The test will not compile
    if we omit the `–tags` parameter, as the `machine` package would then be missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the test should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we know that we can make use of very simple tests to test our logic in
    TinyGo. Let''s go one step further and do a **table-driven test**. Perform these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add a new function, called `TestGetDistanceFromPulseLength_TableDriven`,
    right underneath the other test. The code snippet looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add four test cases, each of them with a `Name`, the expected `Result`, and
    the `PulseLength`, which we use as input, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of the `HCSR04` `Device` instance. It should look like
    the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can run a test for each `testCase` in the array. This looks like the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `distance`. And check whether we get a result that differs from
    the predefined test cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This was everything for the tests. Now, let''s run the tests again using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The tinygo test output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.7_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – The tinygo test output
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since building binaries for Windows is currently not supported, the preceding
    `tinygo test` command is going to fail on a Windows systems. One option for Windows
    users is to use the WSL for unit tests. Another possibility is to set a build
    target by using the `–target` parameter. Windows does support building the **wasm**
    or **wasi** targets, but as our code depends on the machine package, that will
    not work for this specific test. This is because the machine package is not available
    for the wasm and wasi targets.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that we can also use table-driven tests in TinyGo. At the time of
    writing, the majority of the testing package seems to be implemented. Currently,
    only the `Helper()` function seems to not be implemented. However, there could
    be one or two small things that I have not found yet, which might not work. Additionally,
    we have checked that our logic to calculate the distance seems to be working as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: With that covered, we can go on and write a small example program to test the
    rest of our code on real hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an example program for the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now checked that our formula to calculate the distance from a pulse
    length input seems to be correct. So, we can move ahead and create an example
    that outputs the measured distance to serial. To do that, first, we need to create
    a new folder, called `ultrasonic-distance-sensor-example`, inside the `Chapter05`
    folder. Additionally, we need to create a new `main.go` file with an empty `main`
    function. The project structure should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The project structure for the example program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.8_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – The project structure for the example program
  prefs: []
  type: TYPE_NORMAL
- en: 'The example logic consists of initializing the sensor and then printing the
    distance each second. All of this is done inside the `main` function. It looks
    like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the complete code for the example. The library was imported with an
    alias named `hcsr04`. Now, let''s flash the program onto the Arduino Nano 33 IoT
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the output, we can use the same `PuTTY` profile that we created in
    [*Chapter 3*](B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058), *Building a Safety
    Lock Using a Keypad*. Open up PuTTY and select the **Microcontroller** profile.
    Make sure that you have the USB cable plugged into the same port as the Arduino
    UNO beforehand. Depending on the current distance from the sensor to any object,
    the output should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Sensor readings in PuTTy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.9_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Sensor readings in PuTTy
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we wrote a library for the HC-SR04 sensor, learned that unit
    testing also works in TinyGo, and then wrote an example project to test the library.
    So, we are now able to measure distance, which is the first half of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at 7-segment displays, as we need 7-segment
    displays to display a timer in our final project.
  prefs: []
  type: TYPE_NORMAL
- en: Using 4-digit 7-segment displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A 7-segment display can be used for multiple purposes. One of them is to display
    times, which is exactly what we want to do in our final project. But how can we
    control them?
  prefs: []
  type: TYPE_NORMAL
- en: 'The 4-digit display has 12 pins: one pin for each digit (from 0 to 9), one
    pin for each segment, and a pin for the dot. So, to display anything, we have
    to send a high signal to the digit we want to set and then just set all pins to
    high, which we need to represent the character we want to display.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we want to display the character of "1" in the fourth digit,
    we would set pin 4 and pins B and C to high.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better understanding of this, take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – A 7-segment display pinout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – A 7-segment display pinout
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram, you can see that pins 1 to 4 are being used to select
    the digit.
  prefs: []
  type: TYPE_NORMAL
- en: The 7-segment A-G pins are being used to control the segments and the **dot**
    pin is being used to set the dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, having to control 12 pins is kind of hard, as then we would only have 2
    digital pins left when controlling the display. That is why we use another device
    to control the display: a MAX7219\. The next section explains how this is done.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a MAX7219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MAX7219 (and Max7221) is a *serially interfaced*, 8-digit LED *display driver*.
    In short, we can control this chip using only four wires, which controls up to
    eight 7-segment digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send data to that chip, we simply need to drive the load pin low, send 1
    byte of data containing the register to set and 1 byte of data to set the segments
    and the dot. Then, we drive the load pin high and the 16 bits that have been written
    are processed. The chip will then decode the data and set all of the output pins.
    The following diagram is a pinout of the chip for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The MAX7219 and MAX7221 pinout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – The MAX7219 and MAX7221 pinout
  prefs: []
  type: TYPE_NORMAL
- en: 'These chips are commonly used in 8x8 LED matrices. So ,if you have such a device,
    you could carefully remove the chip using a tweezer. *Removing the chip could
    cause permanent damage to the chip!* These chips are also freely available in
    most shops for microcontroller components. Before we start to write a library
    for this chip, let''s first assemble our circuit. To do this, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Take a second breadboard; a half-size one is sufficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the MAX7219 on to the breadboard. The *CLK* pin should sit in *E1*, and
    the *LOAD* pin should sit in *G1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the 7-segment display on to the breadboard. The `E` pin should sit in
    `D25`, and the `1` pin should sit in *F25* or *G25* (depending on which fits better).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *DIG0* from the MAX7219 with *Digit1* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *DIG1* from the MAX7219 with *Digit2* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *DIG2* from the MAX7219 with *Digit3* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *DIG3* from the MAX7219 with *Digit4* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGA* from the MAX7219 with *A* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGB* from the MAX7219 with *B* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGC* from the MAX7219 with *C* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGD* from the MAX7219 with *D* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGE* from the MAX7219 with *E* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGF* from the MAX7219 with *F* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGG* from the MAX7219 with *G* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *SEGDP* from the MAX7219 with *DOT* from the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *GND* lane from the power bus of both breadboards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *VCC* lane from the power bus of both breadboards using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *ISET* with VCC from the MAX7219 using a **10,000-Ohm resistor**. This
    is a hardware solution that controls the brightness of the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *D13* from the Arduino with *CLK* from the MAX7219.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *D6* from the Arduino with *LOAD* from the MAX7219.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *D11* from the Arduino with *DIN* from the MAX7219.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *D5* from the Arduino with *VCC* from the buzzer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *GND* from the buzzer with *GND* on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When all of this is done, the result should now look similar to the following
    diagram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The final circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – The final circuit
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's better understand how the MAX7219 works by writing a small library
    that communicates with this chip.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a library to control the MAX7219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do not only want to learn how to use a MAX7219 in a single project, but we
    also want to create a library that we can use in all future projects, even beyond
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we need to create a new folder, called `max7219spi`, inside
    the `Chapter05` folder. Create two files named `registers.go` and `device.go`
    inside the newly created folder, and use `MAX7219spi` as the package name. The
    project structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The project structure to control the MAX7219'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – The project structure to control the MAX7219
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to move ahead and write some code. We will start by implementing
    the needed registers in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Registers.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `registers.go` file, we place a bunch of constants that represent
    register addresses. We will explain the constants as soon as we use them in the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is it for this file. Further explanations regarding these constants can
    also be found in the datasheet at [https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf](https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf).
    Now, we are going to implement the driver.
  prefs: []
  type: TYPE_NORMAL
- en: Device.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this file, we can define an interface to implement its methods. The interface
    will provide a function to write data to the MAX7219, along with some convenience
    functions to start a display test for our example. To implement it, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Device` interface with all of its functions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a `device` struct that contains an `load`. We will explain these
    pins in more detail as soon as we use them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a function, called `NewDevice`, that creates a new instance of
    `device` and sets the `load` pin along with the SPI `bus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function, called `WriteCommand`, that takes 2 bytes as its parameter.
    The first byte is `register` and the second one is the `data` to set. For the
    register, we use the constants of the `registers.go` file. We write data to the
    MAX7219 by pulling the `load` pin to low. Next, we write the `register` byte,
    then the `payload`, and then we pull the load `pin` to `high`. Pulling the `load`
    pin to `high` triggers the MAX7219 to load and process the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function, called `Configure`, that sets the `load` pin as the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function, called `SetScanLimit`, that tells the MAX7219 how many digits
    we are going to use in our program. Digits in the MAX7219 start from 0, so we
    subtract 1 from our digit number, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a function, called `SetDecodeMode`, that tells the MAX7219 how
    many digits should be decoded. The decode mode is going to help us later, as it
    translates our input into the matching output for the 7-segment display in order
    to display a character. The MAX7219 has a predefined set of characters for this
    purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch over to the `digitNumber` input; if we only use one digit, we tell the
    MAX7219 to only *decode the first digit*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we use two, three, or four digits, we tell the MAX7219 to *decode the first
    four digits*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decode all of the digits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the input is 0, or greater than 8, we tell the MAX7219 to *decode nothing*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: func (driver *device) StartShutdownMode() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: driver.WriteCommand(REG_SHUTDOWN, 0x00)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: func (driver *device) StopShutdownMode() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: driver.WriteCommand(REG_SHUTDOWN, 0x01)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we want to be able to start and stop the display test mode. The *display
    test activates all of the connected LEDs*. This looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function, called `writeByte`, that takes a byte and writes it to the
    MAX7219\. Here, we make use of the SPI interface. First, the SPI implementation
    internally pulls down the clock pin, then it takes each bit of the byte, and sets
    the data pin to low for a 0 and to high for a 1\. After the data line bit has
    been set, it pulls up the clock pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is everything we need for the MAX7219.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create a small abstraction layer above this device.
    Our abstraction layer will implement the specifics of 7-segment displays. We have
    implemented the MAX7219 package in a very generic way, and that was done on purpose
    so that we can build abstraction layers for 7-segment displays and 8x8 LED matrices
    based on this package.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a library to control the hs42561k display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This library makes use of the MAX7219 library to set it up for 7-segment display
    use and provides a convenience function to set a character to a specific digit.
    We start by creating a new folder, called `hs42561k`, inside the `Chapter05` folder
    and create two files named `constants.go` and `device.go`. Then, name the package
    `hs42561k`. The project structure should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The project structure to control the hs42561k display'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – The project structure to control the hs42561k display
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `constants.go` file. This file is going to hold some constants
    and a convenience function that returns a string for a character. To do this,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add constants for all of the characters. The values are taken from the MAX7219
    datasheet. If we use these values, the MAX7219 is going to set the correct pins
    on the display, thanks to the integrated decoder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add the `Character` struct, which implements the `String` function.
    The `String` function will come in handy when debugging. We have truncated the
    list in the example; of course, you might also want to add cases `One` to `Eight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is everything we need in the `constants.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `device.go` file by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an interface named `Device` with a `Configure` function and a `SetDigit`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `struct`, called `device`, which holds the number of digits we want to
    control and a reference to the MAX7219 device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function, called `NewDevice`, that returns a `Device` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function named `Configure`. The `Configure` function is used to initialize
    the display driver. It does this by setting the correct `decode mode` and `scan
    limit` functions and stopping the shutdown mode to bring the display into operational
    mode, which is implemented in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write `blank` next to each digit, so we can start off with a clean display,
    just like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can define an *error* for an invalid digit selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to define a function, called `SetDigit`, that sets the given
    character to the given digit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we have an invalid digit number, we need to validate the `digit` input and
    return an error. This is because we cannot display values on digits that do not
    exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to write the `character` to the given `digit`, as shown in
    the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the complete logic for the display driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a small example project to validate that our code is working
    as expected. For that purpose, we create a new folder, called `hs42561k-spi-example`,
    inside the `Chapter05` folder and create a new `main.go` file with an empty `main`
    function in it. The project structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The project structure to validate the code for the hs42561k-spi-example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – The project structure to validate the code for the hs42561k-spi-example
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add logic to the new `main.go` file. Follow these steps to set
    up our example program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add an array of `Character`, which contains all possible characters.
    Here are the characters that we want to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `SPI0` interface. `SDO` is our output pin, and `SCK` is our clock
    pin. We send data with the most *significant bit first* at a `frequency` of 10
    MHz. 10 MHz is the maximum frequency that the MAX7219 can handle according to
    the datasheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We check whether there was an error and print the error if there was one. This
    information helps us when debugging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the MAX7219 display driver with `D6` as the load pin and `machine.SPI0`
    as the SPI bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to initialize the `display` with 4 digits. After this step, the
    display is ready to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each `character` in `characters`, set the `character` to all digits and
    sleep for half a second. That way, we can test whether we are able to display
    every possible character on every digit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the complete example program. We can go ahead and flash the program
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If everything went as expected, the display should now start to print each possible
    character.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to control a 7-segment display, learned about the MAX7219
    display driver, wrote a library for the display driver and the display, and also
    wrote an example program. In the next section, we are going to use these libraries
    and the ultrasonic distance sensor to build our final project of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our final project of this chapter, we are going to make use of everything
    we have learned in the preceding sections. We are going to use the ultrasonic
    distance sensor to recognize a hand movement in close proximity to the sensor.
    We are using the 7-segment display to count down from 20 to 0 and we are going
    to use a buzzer, to provide an additional signal, for the timer start and the
    timer end. In Germany, it is officially recommended that we wash our hands for
    at least 20 seconds, which is why we will also add a timer for 20 seconds. Putting
    all of this together, we will create a touchless handwash timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start to write the code to control the hand wash timer, we need to
    add a buzzer. We can add this by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the *GND* pin of the buzzer in *D53* and the *VCC* pin of the buzzer into
    `D54`. If that is too close together for your buzzer's pins, just put the buzzer
    in and wire the following two wires accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *GND* pin of the Arduino with *A53* on the breadboard using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *D5* pin of the Arduino with *A54* on the breadboard using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The circuit should look similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The touchless handwash timer circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – The touchless handwash timer circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have set up the circuit, we can go ahead and write the logic. We
    start by creating a new folder, called `touchless-handwash-timer`, inside the
    `Chapter05` folder. Then, we create a new `main.go` file with an empty `main`
    function. The project structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – The project structure for the handwash timer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – The project structure for the handwash timer
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps inside the `main` function to implement the logic for
    the touchless handwash timer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to initialize the `SPI0` interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If an error occurs, we print it. Doing so enables us to debug the program by
    monitoring the output of the serial port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we want to initialize the `display`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that is done, we can go on and initialize the `distanceSensor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we initialize the `buzzer`. If you skipped [*Chapter 4*](B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082),
    *Building a Plant Watering System*, simply import the buzzer package from [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we get and print the `currentDistance`. Printing the distance helps us
    to debug the program if any problems occur later on. This looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `currentDistance` is between `12` and `25` centimeters, activate the
    timer. This is shown with the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have to sleep for `100` milliseconds. We do this to prevent the echoes
    from overlapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last function is the `handleTimer` function, which takes `display`, `displayDriver`,
    and `buzzer` as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we make sure that `display` is in operational mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we let the `buzzer` beep two times to indicate that the timer has started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we count from `20` to `0`. This represents the 20 seconds that our timer
    is running, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we have more than 10 seconds left, we need to set the third `digit`. Because
    we need to set more than one digit, we are going to set digit `3` and `4`, which
    looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, we need to handle all numbers that have a trailing 0\. And this
    looks similar to the following snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to handle all numbers that are smaller than 10\. This is implemented
    in the following snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the timer runs out, we reset both used digits by setting them to `blank`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let the `buzzer` beep for half a second to indicate that the timer has finished:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put the display driver into shutdown mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is all the code we need. Now, try the code by flashing it onto the Arduino
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully built and flashed the program. Now it is time to try it
    out.
  prefs: []
  type: TYPE_NORMAL
- en: So, we combined all the components that we built throughout this chapter into
    this final project, and we used the components to recognize the movement from
    a certain distance in front of the sensor to start a timer. This was the final
    project of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the technical specifications of the Arduino
    Nano 33 IoT and how to calculate the distance between an object and an ultrasonic
    distance sensor. Additionally, we learned how the sensor works internally and
    wrote a library for it. We also learned that unit testing is supported in TinyGo
    and wrote some tests for the ultrasonic distance sensor library. Then, we learned
    how to use a MAX7219 serial interfaced display driver to control a 7-segment display,
    and we wrote a library for the MAX7219 and the 7-segment display. At the end of
    this chapter, we put all of the drivers into a single project and only had to
    add a small amount of control logic to build a touchless handwash timer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to use 16x02 LCD and ST7735 TFT
    displays.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it possible to draw 5V output from the Arduino Nano 33 IoT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we divide `pulseLength` by 2 when calculating the distance to an object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the code so that the handwash timer counts from 120 to 0\. Use three
    digits to display the remaining seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
