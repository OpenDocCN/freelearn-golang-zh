<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer102">
			<h1 id="_idParaDest-118"><em class="italic"><a id="_idTextAnchor118"/>Chapter 6</em>: Building Displays for Communication using I2C and SPI Interfaces</h1>
			<p>In the previous chapter, we learned how to display data using a 7-segment display, how a MAX7219 chip works, how ultrasonic distance sensors work, and how to write a library for all this. We used the SPI interface to do so.</p>
			<p>After working through this chapter, we will know how to use different types of displays and which displays use different interfaces for communication. We are going to learn how the I2C interface works by using a display that we can connect using an I2C bus. With that covered, we are going to learn how to read and interpret user input. After that, we are going to learn how to draw shapes and texts on displays. Finally, we are going to learn how to build a game that can run on a microcontroller. With this knowledge, we will be able to understand the overall concept of using various displays for communication.</p>
			<p>In this chapter, we're going to cover the following main topics:  </p>
			<ul>
				<li>Exploring the TinyGo drivers</li>
				<li>Displaying text on a 16x2 LCD display</li>
				<li>Displaying user input on the display</li>
				<li>Building a CLI</li>
				<li>Displaying a simple game</li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Technical requirements</h1>
			<p>We are going to need the following components for this project:</p>
			<ul>
				<li>An Arduino Nano 33 IoT</li>
				<li>HD44780 1602 LCD display bundled with an I2C interface</li>
				<li>ST7735 display</li>
				<li>1 x breadboard</li>
				<li>1 x 10k Ohm resistor</li>
				<li>1 x 4-pinned button</li>
				<li>Jumper wires</li>
			</ul>
			<p>You can find the code for this chapter on GitHub: <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06</a></p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/2Qo8Jji">https://bit.ly/2Qo8Jji</a></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/>Exploring the TinyGo drivers</h1>
			<p>In <a href="B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058"><em class="italic">Chapter 3</em></a>, <em class="italic">Building a Safety Lock Using a Keypad</em>, we learned about the TinyGo drivers<a id="_idIndexMarker318"/> repository. Let's have a brief look at how to find drivers and examples in this repository.  </p>
			<p>When you're planning a new project, it is always good to check if the drivers repository has drivers for the devices you plan to use. It will speed up your project and make it easier to implement. </p>
			<p>The drivers repository is split into two parts: </p>
			<ul>
				<li>The drivers</li>
				<li>Examples</li>
			</ul>
			<p>The drivers directly reside in the root of the repository. All the examples are inside an example folder.</p>
			<p>We want to use an hd44780 LCD display with an I2C interface in our example, so let's check if we can find it inside the drivers repository. Refer to the following screenshot: </p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="Images/Figure_6.1_B16555.jpg" alt="Figure 6.1 – An hd44780i2c driver&#13;&#10;" width="1275" height="341"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – An hd44780i2c driver</p>
			<p>As we can see, the package is named after the device and the interface (<strong class="bold">I2C</strong>) it uses. Sometimes, a driver package provides more than one interface to use in one package. Most of the drivers omit the additional interface in the name. </p>
			<p>To find example code that shows how to use a package, navigate to the <strong class="source-inline">examples</strong> folder and look for a folder that has exactly the same name as the driver package. The following<a id="_idIndexMarker319"/> screenshot shows the example code for the <strong class="bold">hd47780i2c</strong> driver:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="Images/Figure_6.2_B16555.jpg" alt="Figure 6.2 – hd44780i2c driver example&#13;&#10;" width="1028" height="294"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – hd44780i2c driver example</p>
			<p>Now that we now know that there is a driver for the display we want to use and where to find example code for that driver, let's move on and use that driver.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor121"/>Displaying text on an HD44780 16x2 LCD display</h1>
			<p>The HD44780 <a id="_idIndexMarker320"/>16x2 LCD is cheap and easy to use. If we only want to display text, this type of display can do just that and is the device of choice. It has 16 pins, which is too many, if we want to combine it with more devices in a project. That is why it is a pretty common practice to use an I2C display driver to control the display. This is a concept similar to using a MAX7219 to drive a 7-segment display, as we did in the previous chapter.</p>
			<p>The HD44780 16x2 display can be obtained in a bundle with an I2C driver soldered to it, or it can come without an I2C driver. The display can come in different color configurations, pertaining to background and text color. They typically look similar to the one shown in the following image:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="Images/Figure_6.3_B16555.jpg" alt="Figure 6.3 – HD44780 front  &#13;&#10;" width="1100" height="825"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – HD44780 front  </p>
			<p>When the<a id="_idIndexMarker321"/> display comes with an I2C driver, it is usually an LCM1602 IIC, which provides four ports: </p>
			<ul>
				<li>GND</li>
				<li>VCC</li>
				<li>SDA </li>
				<li>SCL</li>
			</ul>
			<p>So, when using the LCM1602, we only need to connect <em class="italic">GND</em> and <em class="italic">VCC</em> to the power bus; the remaining two wires are used for <em class="italic">SDA</em> and <em class="italic">SCL</em>. The LCM1602 IIC has a potentiometer on the board, which can be used to adjust the contrast of the display. The following image shows such an LCM1602 IIC, which has been soldered to the back of an HD44780:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="Images/Figure_6.4_B16555.jpg" alt="Figure 6.4 – LCM1602 IIC soldered to the back of an HD44780&#13;&#10;" width="1100" height="825"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – LCM1602 IIC soldered to the back of an HD44780</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Most HD47780 displays operate at 5V, but some only need 3.3V. So, check the datasheet of your display carefully to prevent possible damage!</p>
			<p>We now have<a id="_idIndexMarker322"/> a brief understanding of the HD44780 and that we can utilize an LCM1602 IIC to save some pins. Now, let's move on and build the circuit.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>Building the circuit</h2>
			<p>Before we can <a id="_idIndexMarker323"/>show anything on the display, we need to build the circuit. Just follow these steps to do so:</p>
			<ol>
				<li>Make sure that the jumper of the power supply sits on 5V. Double-check if you might have a 3.3V display and if so, set the jumper to 3.3V.</li>
				<li>Connect the <em class="italic">GND</em> pin of the display to the <em class="italic">GND</em> lane on the power bus.</li>
				<li>Connect the <em class="italic">VCC</em> pin of the display to the <em class="italic">VCC</em> lane on the power bus.</li>
				<li>Connect <em class="italic">A14</em> to the breadboard (<em class="italic">GND</em>) with the <em class="italic">GND</em> lane on the power bus.</li>
				<li>Connect <em class="italic">A9</em> to the breadboard (<em class="italic">SCL</em>) with the <em class="italic">SCL</em> pin of the display.</li>
				<li>Connect <em class="italic">A8</em> to the breadboard (<em class="italic">SDA</em>) with the <em class="italic">SDA</em> pin of the display.</li>
			</ol>
			<p>The circuit should now look similar to the following:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="Images/Figure_6.5_B16555.jpg" alt="Figure 6.5 – 16x02 I2C display circuit (image taken from Fritzing)&#13;&#10;" width="1110" height="543"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – 16x02 I2C display circuit (image taken from Fritzing)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">16x02 I2C LCD Fritzing parts have been taken from the following link:</p>
			<p class="callout"><a href="https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-">https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-</a>.</p>
			<p>That was<a id="_idIndexMarker324"/> everything we needed to set up regarding our hardware devices. However, before we start writing the code, we need to understand I2C.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/>Understanding I2C</h2>
			<p>I2C is a synchronous<a id="_idIndexMarker325"/> two-wired serial bus, where the <a id="_idIndexMarker326"/>data wire being used is bidirectional. Sometimes, <strong class="bold">I2C</strong> is also called a <strong class="bold">Two-Wire Interface</strong> (<strong class="bold">TWI</strong>). One wire is used to provide a <strong class="bold">clock</strong>, while the <a id="_idIndexMarker327"/>other wire is used to <strong class="bold">transmit data</strong>. </p>
			<p>The I2C bus<a id="_idIndexMarker328"/> allows multiple devices to communicate on the same bus. Unlike<a id="_idIndexMarker329"/> the <strong class="bold">Peripheral Interface</strong> (<strong class="bold">SPI</strong>)) bus, the I2C bus does not need a <strong class="bold">chip select</strong> (<strong class="bold">CS</strong>) pin; instead, it just includes the address of the receiving device in the message.</p>
			<p>An I2C message contains the following parts:</p>
			<ul>
				<li><strong class="bold">Start condition</strong>: The start condition signals that a new message is being sent.</li>
				<li><strong class="bold">Address frame</strong>: The address frame contains the address of the device that should receive the message.</li>
				<li><strong class="bold">Read/Write bit</strong>: This bit is used to signal whether data is being sent from the controller to the device, or if data is being requested from the device.</li>
				<li><strong class="bold">ACK/NACK bit</strong>: The receiving device tells the sender if the previous frame has been received successfully.</li>
				<li><strong class="bold">Data frame</strong>: A single message can contain <em class="italic">1</em> to <em class="italic">n</em> DataFrames of 8 bits each.</li>
				<li><strong class="bold">Stop condition</strong>: The stop condition signals that the message has been completely sent.</li>
			</ul>
			<p>The following image <a id="_idIndexMarker330"/>visualizes a message with 16 bits of data:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="Images/Figure_6.6_B16555.jpg" alt="Figure 6.6 – I2C message &#13;&#10;" width="761" height="69"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – I2C message </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you do not know the address of the device you want to use, you can make use of the ACK bit by iterating all possible addresses and checking if the device sends an ACK on an address. If that is the case, you've found the address.</p>
			<p>Now that we have a brief understanding of what I2C is and how it works, we can write our first program using I2C to control the display.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor124"/>Writing the code</h2>
			<p>We will <a id="_idIndexMarker331"/>start by creating a new folder named <strong class="source-inline">Chapter06</strong> inside our project. Inside the <strong class="source-inline">Chapter06</strong> folder, create a new folder named <strong class="source-inline">hd44780-text-display</strong> and create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function inside it. The project structure should now look as follows:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="Images/Figure_6.7_B16555.jpg" alt="Figure 6.7 – Project structure&#13;&#10;" width="533" height="74"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Project structure</p>
			<p>Now, follow these steps to display the first piece of text:</p>
			<ol>
				<li value="1">Import the driver:<p class="source-code">"tinygo.org/x/drivers/hd44780i2c"</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, configure the I2C interface and set the clock's <strong class="source-inline">frequency</strong> to <strong class="source-inline">400KHz</strong>:<p class="source-code">machine.I2C0.Configure(machine.I2CConfig{</p><p class="source-code">    Frequency: machine.TWI_FREQ_400KHZ,</p><p class="source-code">})</p></li>
				<li>Create a new instance of <strong class="source-inline">hd44780i2c</strong> and pass the <strong class="source-inline">I2C</strong> interface, as well as <strong class="source-inline">address</strong>, as a parameter. Most LCM1602 IICs should listen on the <strong class="source-inline">0x27</strong> address, but some modules listen on <strong class="source-inline">0x3F</strong>:<p class="source-code">lcd := hd44780i2c.New(machine.I2C0, 0x27)</p></li>
				<li>Configure the display by setting columns <strong class="source-inline">(Width)</strong>and rows (<strong class="source-inline">Height</strong>). We need to do this as this driver also supports 20x4 and other types of displays:<p class="source-code">lcd.Configure(hd44780i2c.Config{</p><p class="source-code">    Width: 16, </p><p class="source-code">    Height: 2, </p><p class="source-code">})</p></li>
				<li>Print the text. <strong class="source-inline">\n</strong> is being interpreted by the driver, and all characters followed by <strong class="source-inline">\n</strong> are being written to the next row. We can do this with the following code:<p class="source-code">lcd.Print([]byte(" Hello World \n LCD 16x02"))</p></li>
				<li>Now, let's test the code by flashing it. Use the following command:<p class="source-code"><strong class="bold">tinygo flash --target=arduino-nano33 Chapter6/hd44780-text-display/main.go</strong></p></li>
			</ol>
			<p>You should now see the text being printed on the screen. </p>
			<p>Let's look at what happens when we try to print more than 16x2 characters onto the screen. To do so, just add the following snippet to the end of our <strong class="source-inline">main</strong> function:</p>
			<p class="source-code">time.Sleep(5 * time.Second)</p>
			<p class="source-code">lcd.Print([]byte("We just print more text, to see what </p>
			<p class="source-code">    happens, when we overflow the 16x2 character limit"))</p>
			<p>Now, flash the <a id="_idIndexMarker332"/>program again and look at the result. What we can observe is that after reaching the 32nd character, the cursor jumps to position x = 0 and y = 0 again and continues to print from there. However, we want to print more than 32 characters on the display, and we want to be able to read all of them. To do so, we must create a small animation. Perform the following steps:</p>
			<ol>
				<li value="1">At the end of the <strong class="source-inline">main</strong> function, sleep for <strong class="source-inline">5</strong> seconds and call the <strong class="source-inline">animation </strong>function and pass <strong class="source-inline">lcd</strong> as a parameter, as shown in the following code snippet:<p class="source-code">time.Sleep(5 * time.Second)</p><p class="source-code">animation(lcd)</p></li>
				<li>We need to define the <strong class="source-inline">animation</strong> function, which takes <strong class="source-inline">lcd</strong> as a parameter:<p class="source-code">func animation(lcd hd44780i2c.Device) {</p></li>
				<li>Now, we need to define the text we want to print:<p class="source-code">text := []byte(" Hello World \n Sent by \n Arduino </p><p class="source-code">    Nano \n 33 IoT \n powered by \n TinyGo")</p></li>
				<li>We must clear the display to remove everything we printed previously. This also resets the cursor to the first position (0,0):<p class="source-code">lcd.ClearDisplay()</p></li>
				<li>Now, let's print a single character. We need to do some type conversions here as the display driver only accepts <strong class="source-inline">[]byte</strong> as a parameter. For this, refer to the following code:<p class="source-code">for {</p><p class="source-code">    for i := range text {</p><p class="source-code">        lcd.Print([]byte(string(text[i])))</p><p class="source-code">        time.Sleep(150 * time.Millisecond)</p><p class="source-code">    }</p></li>
				<li>When the<a id="_idIndexMarker333"/> message has been completely written onto the display, we sleep for <strong class="source-inline">2</strong> seconds and clear the display again. This enables a clean start for the next iteration:<p class="source-code">time.Sleep(2 * time.Second)</p><p class="source-code">lcd.ClearDisplay()</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, flash the updated program again. The characters should now nicely appear one after the other. </p>
			<p>Now that we understand how to use the display driver to print hardcoded texts and how to create a simple animation, let's display some dynamically received texts. </p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor125"/>Displaying user input on the display</h1>
			<p>In this section, we<a id="_idIndexMarker334"/> are going to print the input of a user onto the display. The input is being sent from the computer to the <a id="_idIndexMarker335"/>microcontroller using <strong class="bold">serial (UART)</strong>, which will then print it onto the display. </p>
			<p>In <a href="B16555_02_Final_VK_ePub.xhtml#_idTextAnchor041"><em class="italic">Chapter 2</em></a>, <em class="italic">Building a Traffic Lights Control System</em>, we learned how to use UART to send messages to the computer, and observed them using PuTTY. Now, we are going to use this interface bidirectionally. For this project, we are using the same hardware setup that we used in the previous section, which means we can directly dive into the code. </p>
			<p>Start by creating a new folder named <strong class="source-inline">hd44780-user-input</strong> inside the <strong class="source-inline">Chapter06</strong> folder. Then, inside this newly created folder, add a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main()</strong> function inside it. The project's structure should now look similar to the following:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="Images/Figure_6.8_B16555.jpg" alt="Figure 6.8 – Project structure&#13;&#10;" width="575" height="126"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Project structure</p>
			<p>Follow these steps to implement the program:</p>
			<ol>
				<li value="1">Save the hex value for  <strong class="source-inline">carriageReturn</strong> as a constant. Later, we will be checking if a received byte equals this <strong class="source-inline">carriageReturn</strong> value:<p class="source-code">const carriageReturn = 0x0D</p></li>
				<li>Save the <strong class="source-inline">uart</strong> interface in a variable so that we don't have to type <strong class="source-inline">machine.UART0</strong> every time:<p class="source-code">var (</p><p class="source-code">    uart = machine.UART0</p><p class="source-code">)</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, start by initializing the display driver:<p class="source-code">machine.I2C0.Configure(machine.I2CConfig{</p><p class="source-code">    Frequency: machine.TWI_FREQ_400KHZ,</p><p class="source-code">})</p><p class="source-code">lcd := hd44780i2c.New(machine.I2C0, 0x27) // some </p><p class="source-code">                        // modules have address 0x3F</p><p class="source-code">err := lcd.Configure(hd44780i2c.Config{</p><p class="source-code">        Width: 16, // required</p><p class="source-code">        Height: 2, // required</p><p class="source-code">        CursorOn: false,</p><p class="source-code">        CursorBlink: false,</p><p class="source-code">})</p><p class="source-code">if err != nil {</p><p class="source-code">    println("failed to configure display")</p><p class="source-code">}</p></li>
				<li>Let the user<a id="_idIndexMarker336"/> know that we can type something and then print it on the display:<p class="source-code">lcd.Print([]byte(" Type to print "))</p></li>
				<li>We want to clear the display as soon as the first input has been received. That is why we save this state:<p class="source-code">hadInput := false</p></li>
				<li>If no data resides in the buffer, we don't want to do anything. Incoming data is<em class="italic"> </em>internally buffered by TinyGo using a ring buffer:<p class="source-code">for {</p><p class="source-code">    if uart.Buffered() == 0 {</p><p class="source-code">        continue</p><p class="source-code">    }</p></li>
				<li>If we encounter the very first input, we must clear the display and save the state that we had input previously:<p class="source-code">if !hadInput {</p><p class="source-code">    hadInput = true</p><p class="source-code">    lcd.ClearDisplay()</p><p class="source-code">}</p></li>
				<li>Next, we<a id="_idIndexMarker337"/> read one byte from the buffer and log any possible errors:<p class="source-code">data, err := uart.ReadByte()</p><p class="source-code">if err != nil {</p><p class="source-code">    println(err.Error())</p><p class="source-code">}</p></li>
				<li>If a <strong class="source-inline">carriageReturn</strong> is being received, such as because the user pressed the <em class="italic">Enter</em> key, we also want to print in a new line. We print that character on the display, as well as to <strong class="source-inline">uart</strong>, so that the output in PuTTY and the output on the display behave similarly:<p class="source-code">if data == carriageReturn {</p><p class="source-code">    lcd.Print([]byte("\n"))</p><p class="source-code">    uart.Write([]byte("\r\n"))</p><p class="source-code">    continue</p><p class="source-code">}</p></li>
				<li>The last step is to simply print the data onto both outputs:<p class="source-code">lcd.Print([]byte{data})</p><p class="source-code">uart.WriteByte(data)</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, we can receive data from a computer that is connected to the microcontroller and print it onto the display. Try it out by flashing the program to the microcontroller by using the following command:</p>
			<p class="source-code">tinygo  flash –target=arduino-nano33 Chapter06/hd44780-user-input/main.go</p>
			<p>Now, start PuTTy, connect to the <strong class="source-inline">microcontroller</strong> profile, and start typing to check if the program <a id="_idIndexMarker338"/>runs correctly. If everything works correctly, PuTTY should also print what you have written, similar to what's shown in the following screenshot:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="Images/Figure_6.9_B16555.jpg" alt="Figure 6.9 – PuTTY output&#13;&#10;" width="506" height="243"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – PuTTY output</p>
			<p>The UART interface is a serial interface, which means it can be also used to send and receive data between two microcontrollers. On the Arduino Nano 33 IoT, the <strong class="bold">transmit</strong> (<strong class="bold">TX</strong>) pin is <a id="_idIndexMarker339"/>being used to send the data and the <strong class="bold">receive</strong> (<strong class="bold">RX</strong>) pin is being used to <a id="_idIndexMarker340"/>receive data. </p>
			<p>In this section, we learned how to read and interpret single bytes from the UART interface, as<a id="_idIndexMarker341"/> well as how to manually send data back to the UART interface, without using the <strong class="source-inline">print()</strong> or <strong class="source-inline">println()</strong> functions. We'll use this knowledge in the next section to learn how to interpret longer strings of data.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Building a CLI</h1>
			<p>In this section, we <a id="_idIndexMarker342"/>are going to parse the input from a user and compare the input with predefined commands. These commands will then be executed by the microcontroller. For this project, we are going to use the same hardware setup that we used in the previous one. </p>
			<p>We will start by creating a new folder named <strong class="source-inline">hd44780-cli</strong> inside the <strong class="source-inline">Chapter06</strong> folder. Then, we must create a <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function inside it. The project's structure should now look similar to the following: </p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="Images/Figure_6.10_B16555.jpg" alt="Figure 6.10 – Project structure&#13;&#10;" width="573" height="170"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Project structure</p>
			<p>Now that the project structure has been set up, we can implement the logic. To do so, follow these steps:</p>
			<ol>
				<li value="1">Above the <strong class="source-inline">main</strong> function, start by defining some constants. <strong class="source-inline">commandConstant</strong> represents the command that needs to be sent to the microcontroller. We will use these constants ahead in this code and compare them with the user input to determine whether a CLI command has been entered:<p class="source-code">const (</p><p class="source-code">    carriageReturn = 0x0D</p><p class="source-code">    homeCommand = "#home"</p><p class="source-code">    clearCommand = "#clear"</p><p class="source-code">)</p></li>
				<li>Save the UART interface in a variable. We could also always write <strong class="source-inline">machine.UART0</strong> instead, but by doing it this way, we improve the readability:<p class="source-code">var (</p><p class="source-code">    uart = machine.UART0</p><p class="source-code">)</p></li>
				<li>Inside the <a id="_idIndexMarker343"/><strong class="source-inline">main</strong> function, we initialize the display, as follows:<p class="source-code">machine.I2C0.Configure(machine.I2CConfig{</p><p class="source-code">    Frequency: machine.TWI_FREQ_400KHZ,</p><p class="source-code">})</p><p class="source-code">lcd := hd44780i2c.New(machine.I2C0, 0x27) </p><p class="source-code">err := lcd.Configure(hd44780i2c.Config{</p><p class="source-code">      Width: 16,</p><p class="source-code">      Height: 2,</p><p class="source-code">      CursorOn: false,</p><p class="source-code">      CursorBlink: false,</p><p class="source-code">})</p><p class="source-code">if err != nil {</p><p class="source-code">println("failed to configure display")</p><p class="source-code">}</p></li>
				<li>Now, let's call the <strong class="source-inline">homeScreen</strong> function (we are going to explain what this function does when we implement it later):<p class="source-code">homeScreen(lcd)</p></li>
				<li>Next, define a <strong class="source-inline">commandBuffer</strong>. That is a simple string where we store the parts of a command:<p class="source-code">var commandBuffer string</p></li>
				<li><strong class="source-inline">commandIndex</strong> is being used to count the characters inside <strong class="source-inline">commandBuffer</strong>. If the index is greater than the length of the longest command, then <a id="_idIndexMarker344"/>we know that we can reset the buffer:<p class="source-code">var commandIndex uint8</p></li>
				<li>We will be using the <strong class="source-inline">commandStart</strong> boolean as a signal, so we need to append any subsequent characters to <strong class="source-inline">commandBuffer</strong>:<p class="source-code">commandStart := false</p></li>
				<li>Just like in the previous project, we are going to use the <strong class="source-inline">hadInput</strong> flag to clear the screen when the first input is received:<p class="source-code">hadInput := false</p></li>
				<li>We don't need to do anything if there are no characters in the internal receive buffer:<p class="source-code">for {</p><p class="source-code">    if uart.Buffered() == 0 {</p><p class="source-code">        continue</p><p class="source-code">}</p></li>
				<li>Upon receiving the first input, clear the display. We will explain the <strong class="source-inline">clearDisplay</strong> function when we implement it ahead, after a few steps:<p class="source-code">if !hadInput {</p><p class="source-code">    hadInput = true</p><p class="source-code">    clearDisplay(lcd)</p><p class="source-code">}</p></li>
				<li>Then, we read a byte from the buffer, as follows:<p class="source-code">data, err := uart.ReadByte()</p><p class="source-code">if err != nil {</p><p class="source-code">    println(err.Error())</p><p class="source-code">}</p></li>
				<li>Check if we<a id="_idIndexMarker345"/> received a <strong class="bold">pound sign (#)</strong>. This is the indicator that a command is going to follow:<p class="source-code">if string(data) == "#" {</p><p class="source-code">    commandStart = true</p><p class="source-code">    uart.Write([]byte("\ncommand started\n"))</p><p class="source-code">}</p></li>
				<li>When we receive the start of the command, we append all subsequent characters to <strong class="source-inline">commandBuffer</strong>. This is done as follows:<p class="source-code">if commandStart {</p><p class="source-code">    commandBuffer += string(data)</p><p class="source-code">    commandIndex++</p><p class="source-code">}</p></li>
				<li>To check if we may have a complete command inside <strong class="source-inline">commandBuffer</strong>, we must switch over our <strong class="source-inline">commandBuffer</strong>:<p class="source-code">switch commandBuffer {</p></li>
				<li>If the content of <strong class="source-inline">commandBuffer</strong> equals <strong class="source-inline">homeCommand</strong>, we execute the <strong class="source-inline">homeScreen</strong> function and reset the command. We must also write the input data back inside the UART interface:<p class="source-code">case homeCommand:</p><p class="source-code">    uart.WriteByte(data)</p><p class="source-code">    homeScreen(lcd)</p><p class="source-code">    commandStart = false</p><p class="source-code">    commandIndex = 0</p><p class="source-code">    commandBuffer = ""</p><p class="source-code">    continue</p></li>
				<li>If the<a id="_idIndexMarker346"/> content of <strong class="source-inline">commandBuffer</strong> equals <strong class="source-inline">clearCommand</strong>, we must execute the <strong class="source-inline">clearDisplay</strong> function and reset the command:<p class="source-code">case clearCommand:</p><p class="source-code">    uart.WriteByte(data)</p><p class="source-code">    clearDisplay(lcd)</p><p class="source-code">    commandStart = false</p><p class="source-code">    commandIndex = 0</p><p class="source-code">    commandBuffer = ""</p><p class="source-code">    continue</p><p class="source-code">}</p></li>
				<li>If <strong class="source-inline">commandIndex</strong> is greater than the length of our longest command, we must reset the command:<p class="source-code">if commandIndex &gt; 5 {</p><p class="source-code">    commandStart = false</p><p class="source-code">    commandIndex = 0</p><p class="source-code">    commandBuffer = ""</p><p class="source-code">    uart.Write([]byte("\nresetting command state\n"))</p><p class="source-code">}</p></li>
				<li>If we receive a <strong class="source-inline">carriageReturn</strong>, we must print a new line:<p class="source-code">if data == carriageReturn {</p><p class="source-code">    lcd.Print([]byte("\n"))</p><p class="source-code">    uart.Write([]byte("\r\n"))</p><p class="source-code">    continue</p><p class="source-code">}</p></li>
				<li>Then, we <a id="_idIndexMarker347"/>print the received data, as follows:<p class="source-code">lcd.Print([]byte{data})</p><p class="source-code">uart.WriteByte(data)</p><p class="source-code">}</p></li>
				<li>Now, define the <strong class="source-inline">homeScreen</strong> function,  which is called when the input matches the <strong class="source-inline">homeScreen</strong> command. We must clear the display and print the first input again:<p class="source-code">func homeScreen(lcd hd44780i2c.Device) {</p><p class="source-code">    println("\nexecuting command homescreen\n")</p><p class="source-code">    clearDisplay(lcd)</p><p class="source-code">    lcd.Print([]byte(" TinyGo UART \n CLI "))</p><p class="source-code">}</p></li>
				<li>Now, define the <strong class="source-inline">clearDisplay</strong> function,  which is called when the input matches the <strong class="source-inline">clearDisplay</strong> command. We just make use of the <strong class="source-inline">ClearDisplay</strong> function of the display here:<p class="source-code">func clearDisplay(lcd hd44780i2c.Device) {</p><p class="source-code">    println("\nexecuting command cleardisplay\n")</p><p class="source-code">    lcd.ClearDisplay()</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, flash<a id="_idIndexMarker348"/> the program using the following command: </p>
			<p class="source-code">tinygo flash –target=arduino-nano33 Chapter06/hd44780-cli</p>
			<p>Now, let's try out our program. </p>
			<p>Start putty and select the microcontroller profile. Type something and use the <strong class="source-inline">#home</strong> and <strong class="source-inline">#clear</strong> commands that we defined in the code. PuTTY's output should now look similar to the following:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="Images/Figure_6.11_B16555.jpg" alt="Figure 6.11 – CLI output in PuTTY&#13;&#10;" width="506" height="243"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – CLI output in PuTTY</p>
			<p>With that, we <a id="_idIndexMarker349"/>have verified that the program works as intended. Such a system could be used to control a microcontroller using another microcontroller, not just to display something – it could also be used to request sensor readings or trigger other things. </p>
			<p>In this section, we learned how to interpret more than a single character of input data at a time, as well as how to set up a simple CLI in order to execute commands that are being sent through UART. In the next section, we are going to gain a deeper understanding of SPI, since we will be using an SPI-driven display in the final project.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/>Understanding SPI</h1>
			<p>SPI is a bus <a id="_idIndexMarker350"/>system that has a controller and one or many devices. The controller selects a device that should send data to the controller, or that is going to receive data from the controller. </p>
			<p>Devices on an SPI bus can also be daisy chained together. A <strong class="bold">daisy chain</strong> is a wiring scheme in which you put<a id="_idIndexMarker351"/> multiple devices together in a row. </p>
			<p>SPI communication between two devices uses the following four pins:</p>
			<ol>
				<li value="1"><strong class="bold">CS</strong>: <strong class="bold">ChipSelect</strong> selects<a id="_idIndexMarker352"/> which device on the bus should receive or send data.</li>
				<li><strong class="bold">CLK</strong>: <strong class="bold">Clock</strong> sets the<a id="_idIndexMarker353"/> frequency of the transfer (DO) and receive (DI) wires.</li>
				<li><strong class="bold">DO</strong>: <strong class="bold">DataOut</strong> or <strong class="bold">DigitalOut</strong> transmits<a id="_idIndexMarker354"/><a id="_idIndexMarker355"/> data to the receiving device.</li>
				<li><strong class="bold">DI</strong>: <strong class="bold">DataIn</strong> or <strong class="bold">DigitalIn</strong> receives<a id="_idIndexMarker356"/> data from the controller.</li>
			</ol>
			<p>The following<a id="_idIndexMarker357"/> diagram shows the one-to-one connection of an SPI controller and an SPI device:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="Images/Figure_6.12_B16555.jpg" alt="Figure 6.12 – SPI communication&#13;&#10;" width="567" height="237"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – SPI communication</p>
			<p>The following diagram shows the SPI connection of one controller and two devices. Here, we are using two CS pins to signal the receiving device. This is the device the controller is talking to:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="Images/Figure_6.13_B16555.jpg" alt="Figure 6.13 – SPI communication between a controller and two devices&#13;&#10;" width="567" height="493"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – SPI communication between a controller and two devices</p>
			<p>The following diagram <a id="_idIndexMarker358"/>shows how devices can be daisy chained together. The <em class="italic">DO</em> pin of the first device is connected to the <em class="italic">DI</em> pin of the next device, while they share the <em class="italic">CLK</em> and <em class="italic">CS</em> wires:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="Images/Figure_6.14_B16555.jpg" alt="Figure 6.14 – SPI communication with daisy chained devices&#13;&#10;" width="897" height="328"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – SPI communication with daisy chained devices</p>
			<p>Now that we <a id="_idIndexMarker359"/>have a better understanding of SPI, let's build a circuit using the ST7735 display.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Displaying a simple game</h1>
			<p>In this section, we are going to learn how to use another display type using the SPI interface. We <a id="_idIndexMarker360"/>need a new type of display since we want to display more than plain text. We will also discover two more TinyGo repositories that provide handy functions for when we're working with displays. The display we are going to use in this section is a 1.8" TFT ST7735 display with a resolution of 160x128 pixels. So, let's have a brief look at the technical specifications of the display.</p>
			<p>The ST7735 display provides an SD card slot, which is optional. The display has a color depth of 262K colors on a TFT-LCD module. The SPI interface is being used with the display. To draw something on the display, we need eight pins. We have already used SPI, but we did not have a deeper look at it, since the devices can be arranged on an SPI bus in different ways. So, let's gain a better understanding of how SPI works before we use the display in an example project.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/>Building the circuit</h2>
			<p>As in the <a id="_idIndexMarker361"/>previous projects, we are going to use an external power supply. We also need a ST7735 display, the Arduino Nano 33 IoT, and some jumper wires. To set everything up correctly, follow these steps:</p>
			<ol>
				<li value="1">Connect the <em class="italic">GND</em> lane from the power bus to pin <em class="italic">J50 (GND)</em> on the breadboard.</li>
				<li>Connect pin <em class="italic">E31 (LED)</em> on the breadboard to pin <em class="italic">A53 (D2)</em> on the breadboard.</li>
				<li>Connect pin <em class="italic">E32 (SCK)</em> on the breadboard to pin <em class="italic">J63 (D13)</em> on the breadboard.</li>
				<li>Connect pin <em class="italic">E33 (SDA)</em> on the breadboard to pin <em class="italic">A62 (D11)</em> on the breadboard.</li>
				<li>Connect pin <em class="italic">E34 (AO)</em> on the breadboard to pin <em class="italic">A56 (D5)</em> on the breadboard.</li>
				<li>Connect pin <em class="italic">E35 (RESET)</em> on the breadboard to pin <em class="italic">A57 (D6)</em> on the breadboard.</li>
				<li>Connect pin <em class="italic">E36 (CS)</em> on<a id="_idIndexMarker362"/> the breadboard to pin <em class="italic">A58 (D7)</em> on the breadboard.</li>
				<li>Connect the <em class="italic">GND</em> lane from the power bus to pin <em class="italic">E37 (GND)</em> on the breadboard.</li>
				<li>Connect the <em class="italic">VCC</em> lane from the power bus to pin <em class="italic">E38 (VCC)</em> on the breadboard.</li>
				<li>Place the ST7735 display so that the <em class="italic">LED</em> pin sits in <em class="italic">A31</em> and the <em class="italic">VCC</em> pin sits in <em class="italic">A37</em>.</li>
			</ol>
			<p>This is everything we need to connect to the display. The setup should now look as follows:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="Images/Figure_6.15_B16555.jpg" alt="Figure 6.15 – ST7735 circuit&#13;&#10;" width="1642" height="961"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – ST7735 circuit</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The 1.8" TFT display Fritzing part is made by vanepp: <a href="https://forum.fritzing.org/u/vanepp">https://forum.fritzing.org/u/vanepp</a>.</p>
			<p>Now that<a id="_idIndexMarker363"/> we've set up the hardware, let's implement some logic. </p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Using an ST7735 display</h2>
			<p>TinyGo <a id="_idIndexMarker364"/>provides <a id="_idIndexMarker365"/>a driver for ST7735 displays. This means we can use the existing driver. Also, TinyGo provides two additional packages named <strong class="source-inline">TinyFont</strong> and <strong class="source-inline">TinyDraw</strong>, both of which we are going to use. First, let's check out the <strong class="source-inline">TinyDraw</strong> package.</p>
			<p><strong class="source-inline">TinyDraw</strong> is a repository inside the TinyGo organization on GitHub. You can find it at <a href="https://github.com/tinygo-org/tinydraw">https://github.com/tinygo-org/tinydraw</a>.</p>
			<p><strong class="source-inline">TinyDraw</strong> is still in an early state, which means that it has not been optimized for performance or memory usage. However, it provides useful functionality, such as for dra<a id="_idTextAnchor131"/>wing rectangles, circles, filled rectangles and filled circles, and more. It works with most interface drivers since the APIs of display drivers are nearly (or exactly) the same. Now, let's have a look at the <strong class="source-inline">TinyFont</strong> package before we see it in action.</p>
			<p>Just like <strong class="source-inline">TinyDraw</strong>, <strong class="source-inline">TinyFont</strong> is a repository inside the TinyGo organization on GitHub. You can find it at <a href="https://github.com/tinygo-org/tinyfont">https://github.com/tinygo-org/tinyfont</a>. </p>
			<p><strong class="source-inline">TinyFont</strong> provides an API to let you draw text onto displays using fonts that come with the <strong class="source-inline">TinyFont</strong> package. It also allows you to create your own custom font. <strong class="source-inline">TinyFont</strong> also <a id="_idIndexMarker366"/>makes use of the fact that most TinyGo display drivers <a id="_idIndexMarker367"/>share the same interface. </p>
			<p>Now, let's set up a project that uses the ST7735, TinyDraw, and TinyFont. To do so, create a new folder named <strong class="source-inline">st7735</strong> inside the <strong class="source-inline">Chapter06</strong> folder and create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main()</strong> function inside it. The project's structure should now look similar to the following:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="Images/Figure_6.16_B16555.jpg" alt="Figure 6.16 – Project structure&#13;&#10;" width="552" height="206"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Project structure</p>
			<p>Now, let's dive into the code. We will need to import the following packages for this project: </p>
			<p class="source-code">"tinygo.org/x/drivers/st7735"</p>
			<p class="source-code">"tinygo.org/x/tinydraw"</p>
			<p class="source-code">"tinygo.org/x/tinyfont"</p>
			<p class="source-code">"tinygo.org/x/tinyfont/freemono"</p>
			<p>To write our first test program for this display, follow these steps:</p>
			<ol>
				<li value="1">Above the <strong class="source-inline">main</strong> function, define a set of colors that we are going to use later in the program:<p class="source-code">var (</p><p class="source-code">    white = color.RGBA{255, 255, 255, 255}</p><p class="source-code">    red = color.RGBA{255, 0, 0, 255}</p><p class="source-code">    blue = color.RGBA{0, 0, 255, 255}</p><p class="source-code">    green = color.RGBA{0, 255, 0, 255}</p><p class="source-code">    black = color.RGBA{0, 0, 0, 255}</p><p class="source-code">)</p></li>
				<li>Configure <a id="_idIndexMarker368"/>the <strong class="source-inline">SPI0</strong> interface with a frequency <a id="_idIndexMarker369"/>of 12 MHz. We do not need to pass the pins for SCK and DO as the <strong class="source-inline">Configure</strong> function will use the default SPI pins for this board when no pins are passed: <p class="source-code">machine.SPI0.Configure(machine.SPIConfig{</p><p class="source-code">    Frequency: 12000000,</p><p class="source-code">})</p></li>
				<li>Set the required pins for the display:<p class="source-code">resetPin := machine.D6</p><p class="source-code">dcPin := machine.D5</p><p class="source-code">csPin := machine.D7</p><p class="source-code">backLightPin := machine.D2</p></li>
				<li>Get a new instance of the <strong class="source-inline">st7735</strong> display:<p class="source-code">display := st7735.New(machine.SPI0, resetPin, dcPin, </p><p class="source-code">    csPin, backLightPin)</p></li>
				<li>Call the <strong class="source-inline">Configure</strong> function. This function transmits the bootup sequence to the display. After this call, the display is ready to use:<p class="source-code">display.Configure(st7735.Config{})</p></li>
				<li>Get the <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> attributes from the display:<p class="source-code">width, height := display.Size()</p></li>
				<li>Draw four rectangles. Each of them should take up a quarter of the screen and be a different color. The function takes a position on the x-axis, a position on the y-axis, the width and height of the rectangle to draw, as well as the color of the rectangle. We <a id="_idIndexMarker370"/>will use this as a test for our display. This is a <a id="_idIndexMarker371"/>good test for the display:<p class="source-code">display.FillRectangle(0, 0, width/2, height/2, white)</p><p class="source-code">display.FillRectangle(width/2, 0, width/2, </p><p class="source-code">    height/2, red)</p><p class="source-code">display.FillRectangle(0, height/2, width/2, </p><p class="source-code">    height/2, green)</p><p class="source-code">display.FillRectangle(width/2, height/2, </p><p class="source-code">    width/2, height/2, blue)</p></li>
				<li>Before we move on and draw some more advanced graphics, let's test the program by flashing it using the following command:<p class="source-code"><strong class="bold">tinygo flash –target=arduino-nano33 Chapter6/st7735/main.go</strong></p></li>
				<li>Once the program has been successfully flashed onto the microcontroller, you should see four rectangles. This looks similar to the following: </li>
			</ol>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="Images/Figure_6.17_B16555.jpg" alt="Figure 6.17 – ST7735 displaying four rectangles&#13;&#10;" width="687" height="837"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – ST7735 displaying four rectangles</p>
			<p>Now, let's draw some<a id="_idIndexMarker372"/> more complicated forms using <strong class="source-inline">TinyDraw</strong> and some text using <strong class="source-inline">TinyFont</strong>. To <a id="_idIndexMarker373"/>do so, follow these steps:</p>
			<ol>
				<li value="1">At the end of the <strong class="source-inline">main</strong> function, add a sleep for 3 seconds so that we have a chance to actually see the display test:<p class="source-code">time.Sleep(3 * time.Second)</p></li>
				<li>Initialize a counter that will be used to display a count of how many times we have drawn an animation:<p class="source-code">i := 0</p></li>
				<li>Fill the screen with <strong class="source-inline">black</strong> to clean the display:<p class="source-code">for {</p><p class="source-code">    display.FillScreen(black)</p></li>
				<li>Draw a white rectangle at the lower end of the screen. It should have a height of <strong class="source-inline">32</strong> pixels, which should leave us with 128x128 pixels:<p class="source-code">tinydraw.FilledRectangle(&amp;display, 0, 0, 128, 32, </p><p class="source-code">    white)</p></li>
				<li>Since we have assembled our display upside down, we are going to write text rotated:<p class="source-code">tinyfont.WriteLineRotated(&amp;display, </p><p class="source-code">    &amp;freemono.Bold9pt7b, 110, 145, "TinyDraw", red, </p><p class="source-code">    tinyfont.ROTATION_180)</p></li>
				<li>At the center of the black square, draw three circles of different sizes and colors on top of each other:<p class="source-code">tinydraw.FilledCircle(&amp;display, 64, 96, 32, green)</p><p class="source-code">tinydraw.FilledCircle(&amp;display, 64, 96, 24, blue)</p><p class="source-code">tinydraw.FilledCircle(&amp;display, 64, 96, 16, red)</p></li>
				<li>Now, draw<a id="_idIndexMarker374"/> the <strong class="source-inline">TinyFont</strong> text in <strong class="source-inline">green</strong> beneath <a id="_idIndexMarker375"/>the circles:<p class="source-code">tinyfont.WriteLineRotated(&amp;display, </p><p class="source-code">    &amp;freemono.Bold9pt7b, 110, 40, "TinyFont", green, </p><p class="source-code">    tinyfont.ROTATION_180)</p></li>
				<li>Draw the count of how many times the animation will run on the white rectangle:<p class="source-code">counterText := fmt.Sprintf("Count: %v", i)</p><p class="source-code">tinyfont.WriteLineRotated(&amp;display, &amp;freemono.Bold9pt7b, 123, 2, counterText, black, tinyfont.ROTATION_180)</p></li>
				<li>We need to sleep for a moment because otherwise, we won't be able to see the result. This is because it will be overridden in the next iteration:<p class="source-code">time.Sleep(2 * time.Second)</p><p class="source-code">i++</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, flash the program again. After the test screen, you should see a result similar to the following:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="Images/Figure_6.18_B16555.jpg" alt="Figure 6.18 – Result of the test program&#13;&#10;" width="700" height="935"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – Result of the test program</p>
			<p>In this<a id="_idIndexMarker376"/> section, we<a id="_idIndexMarker377"/> learned how to draw basic shapes and write text on our display. The next logical step is to write a game that runs on a microcontroller. </p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Developing a game</h2>
			<p>In this section, we<a id="_idIndexMarker378"/> are going to develop a very simple game that consists of an enemy, represented by a red block, that tries to reach the end of the screen. A green line will represent our home zone, which the red block should not cross. We'll also have a green block that represents the player, as well as a smaller green block that represents a bullet that we can shoot to stop the red block from invading our home zone. We will be adding a button that will act as a trigger and shoot the small green blocks. So, the logical first step is to add the button to our breadboard. To do so, follow these steps:</p>
			<ol>
				<li value="1">Place the button on the breadboard so that one pin sits in <em class="italic">E23</em> and the other pins sit in <em class="italic">E25</em> on one side and <em class="italic">F25</em> and <em class="italic">F23</em> on the other side. </li>
				<li>Connect the <em class="italic">+3V3</em> output from the Arduino to <em class="italic">J23</em> on the breadboard.</li>
				<li>Use a <strong class="bold">10K Ohm resistor</strong> to connect the <em class="italic">GND</em> lane from the power bus to <em class="italic">J25</em>.</li>
				<li>Connect <em class="italic">D25</em> to <em class="italic">A60 (D9)</em> on the breadboard. </li>
			</ol>
			<p>This was<a id="_idIndexMarker379"/> everything we needed to add to the circuit. It should now look as follows:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="Images/Figure_6.19_B16555.jpg" alt="Figure 6.19 – The final circuit with the button&#13;&#10;" width="1273" height="749"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – The final circuit with the button</p>
			<p>Now, let's create <a id="_idIndexMarker380"/>a new folder for the last project in this chapter. Name the folder <strong class="source-inline">tinygame</strong> and put it inside the <strong class="source-inline">Chapter06</strong> folder. Then, create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main()</strong> function inside it. The project's structure should now look as follows:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="Images/Figure_6.20_B16555.jpg" alt="Figure 6.20 – Project structure&#13;&#10;" width="305" height="231"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – Project structure</p>
			<p>To implement <a id="_idIndexMarker381"/>the logic, follow these steps:</p>
			<ol>
				<li value="1">Add a <strong class="source-inline">bool</strong> that holds the <strong class="source-inline">buttonPressed</strong> state. We will define this globally, so we do not need to use channels or something else to pass the state between the goroutines that we are going to use. This is just an easy and convenient way to do this:<p class="source-code">var buttonPressed bool</p></li>
				<li>Define <strong class="source-inline">enemySize</strong>, <strong class="source-inline">bulletSize</strong>, and the <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> properties of the game field in pixels:<p class="source-code">const enemySize = 8</p><p class="source-code">const bulletSize = 4</p><p class="source-code">const width = 128</p><p class="source-code">const height = 160</p></li>
				<li>Add two variables to store our <strong class="source-inline">currentScore</strong> and <strong class="source-inline">highscore</strong>, respectively:<p class="source-code">var highscore int = 0</p><p class="source-code">var currentScore int = 0</p></li>
				<li>Define a set of colors that we will use later:<p class="source-code">var (</p><p class="source-code">    white = color.RGBA{255, 255, 255, 255}</p><p class="source-code">    red = color.RGBA{255, 0, 0, 255}</p><p class="source-code">    blue = color.RGBA{0, 0, 255, 255}</p><p class="source-code">    green = color.RGBA{0, 255, 0, 255}</p><p class="source-code">    black = color.RGBA{0, 0, 0, 255}</p><p class="source-code">)</p></li>
				<li>Now, we <a id="_idIndexMarker382"/>need to move inside the <strong class="source-inline">main</strong> function. Here, assign <strong class="source-inline">buttonPin</strong> and configure it as input:<p class="source-code">buttonPin := machine.D9</p><p class="source-code">buttonPin.Configure(machine.PinConfig{Mode: </p><p class="source-code">          machine.PinInput})</p></li>
				<li>Update <strong class="source-inline">highscore</strong> since we are in the startup phase. Here, <strong class="source-inline">highscore</strong> is <strong class="source-inline">0</strong>:<p class="source-code">updateHighscore(0)</p></li>
				<li>Initialize the <a id="_idIndexMarker383"/>display, as follows:<p class="source-code">machine.SPI0.Configure(machine.SPIConfig{</p><p class="source-code">    Frequency: 12000000,</p><p class="source-code">})</p><p class="source-code">resetPin := machine.D6</p><p class="source-code">dcPin := machine.D5</p><p class="source-code">csPin := machine.D7</p><p class="source-code">backLightPin := machine.D2</p><p class="source-code">display := st7735.New(machine.SPI0, resetPin, dcPin,</p><p class="source-code">           csPin, backLightPin)</p><p class="source-code">display.Configure(st7735.Config{})</p></li>
				<li>Run the <strong class="source-inline">checkButton</strong> function inside a new goroutine so that it is non-blocking. This enables us to update the game loop in the <strong class="source-inline">main</strong> goroutine:<p class="source-code">go checkButton(buttonPin)</p></li>
				<li>Loop forever and fill the screen with black to erase everything from the screen after each<a id="_idIndexMarker384"/> round of the game:<p class="source-code">for {</p><p class="source-code">    display.FillScreen(black)</p><p class="source-code">    updateGame(display)</p><p class="source-code">}</p></li>
				<li>Loop forever and check the button's state. If the button has been pressed, we update the <strong class="source-inline">buttonPressed</strong> state. After each check, we sleep for <strong class="source-inline">20</strong> milliseconds, since we need a blocking call so that the scheduler can work on other<a id="_idIndexMarker385"/> goroutines again:<p class="source-code">func checkButton(buttonPin machine.Pin) {</p><p class="source-code">    for {</p><p class="source-code">        if buttonPin.Get() {</p><p class="source-code">            buttonPressed = true</p><p class="source-code">        }</p><p class="source-code">        time.Sleep(20 * time.Millisecond)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">updateHighscore</strong> function takes a <strong class="source-inline">score</strong>, checks if this new <strong class="source-inline">score</strong> is greater than <strong class="source-inline">highscore</strong>, and if so, it updates <strong class="source-inline">highscore</strong> and prints <strong class="source-inline">highscore</strong> to the serial:<p class="source-code">func updateHighscore(score int) {</p><p class="source-code">    if score &lt;= highscore &amp;&amp; score != 0 {</p><p class="source-code">        return</p><p class="source-code">    }</p><p class="source-code">    highscore = score</p><p class="source-code">    println(fmt.Sprintf(" TinyInvader Highscore: %d", </p><p class="source-code">        highscore))</p><p class="source-code">}</p></li>
			</ol>
			<p>With that, we have<a id="_idIndexMarker386"/> implemented a check for button presses, a function to update <strong class="source-inline">highscore</strong>, and also have a main goroutine that starts a new round of the game as soon as it ends. Now, let's implement the actual game logic. To do so, follow these steps:</p>
			<ol>
				<li value="1">Normally, it would be best to split the update for the game's physics, such as the player's movement, bullets, and the enemy and put it in one part of the logic, and then put the animation in another part of the logic. When developing games for other platforms, these two parts would update independently of each other so that they don't rely on the same framerate. However, to keep things simple, we will have a single game loop that updates the positions as well as drawing to the screen. The <strong class="source-inline">updateGame</strong> function represents the main logic of the game:<p class="source-code">func updateGame(display st7735.Device) {</p></li>
				<li>Define some variables that will store the position of the enemy:<p class="source-code">var enemyPosX, enemyPosY int16</p></li>
				<li>To prevent the <a id="_idIndexMarker387"/>enemy from starting above the game field, we must subtract its size:<p class="source-code">enemyPosY = height - enemySize</p></li>
				<li>Next, we need to store the position of the bullet inside a variable:<p class="source-code">var bulletPosY int16</p></li>
				<li>We store the state if a shot has been fired in a bool variable:<p class="source-code">shotFired := false</p></li>
				<li>We store the state if a new shot can be fired in a bool variable. We initialize it to <strong class="source-inline">true</strong> as we <a id="_idIndexMarker388"/>want the player to be able to fire a shot when the game starts:<p class="source-code">canFire := true</p></li>
				<li> The game has just started, so <strong class="source-inline">currentScore</strong> is <strong class="source-inline">0</strong>:<p class="source-code">currentScore = 0</p></li>
				<li>If the button has been pressed, we reset the <strong class="source-inline">buttonPressed</strong> state as we will be handling it. As long as the bullet is still flying inside the game field, we cannot fire again:<p class="source-code">for {</p><p class="source-code">    if buttonPressed {</p><p class="source-code">        buttonPressed = false  </p><p class="source-code">        if canFire {</p><p class="source-code">            shotFired = true</p><p class="source-code">            canFire = false</p><p class="source-code">        }</p><p class="source-code">}</p></li>
				<li>If a shot has <a id="_idIndexMarker389"/>been fired, we update the bullet:<p class="source-code">if shotFired {</p></li>
				<li>Here, we update the position and draw it:<p class="source-code">bulletPosY = updateBullet(display, bulletPosY)</p><p>If the bullet leaves the game field, we reset the position and reset the <strong class="source-inline">shotFired</strong> and <strong class="source-inline">canFire</strong> states. This enables the player to shoot again:</p><p class="source-code">if bulletPosY &gt; height {</p><p class="source-code">    shotFired = false</p><p class="source-code">    canFire = true</p><p class="source-code">    bulletPosY = 0</p><p class="source-code">}</p></li>
				<li>Next, we<a id="_idIndexMarker390"/> check that the bullet has collided with the enemy on the horizontal axis. For this, we use a hitbox that is slightly larger than the bullet itself: <p class="source-code">if enemyPosX &gt;= 54 &amp;&amp; enemyPosX &lt;= 64 {</p></li>
				<li>Now, we check for a collision on the vertical axis. This time, the hitbox is the same size as  <strong class="source-inline">bulletSize</strong>. These hitboxes have proven to work pretty well in my tests:<p class="source-code">if enemyPosY &gt;= bulletPosY &amp;&amp; enemyPosY &lt;= bulletPosY+bulletSize {</p></li>
				<li>If we hit the enemy, we increment the score:<p class="source-code">currentScore++</p></li>
				<li>Now, we must draw a black box over the enemy to let it disappear:<p class="source-code">display.FillRectangle(enemyPosX-1, enemyPosY,</p><p class="source-code">    enemySize, enemySize, black)</p></li>
				<li>Reset the enemy's position. This respawns the enemy at its spawn position:<p class="source-code">enemyPosY = height - enemySize</p><p class="source-code">enemyPosX = 0</p></li>
				<li>Update <strong class="source-inline">highscore</strong>, like so:<p class="source-code">updateHighscore(currentScore)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Update<a id="_idIndexMarker391"/> and draw the enemy's position:<p class="source-code">enemyPosX, enemyPosY = updateEnemy(display, enemyPosX, enemyPosY)</p></li>
				<li>If the enemy passes our home zone, we lose the game. If this happens, we return, as this lets the loop outside the function run again and start a new game:<p class="source-code">if enemyPosY &lt; enemySize {</p><p class="source-code">    return</p><p class="source-code">}</p></li>
				<li>Draw the home zone:<p class="source-code">display.FillRectangle(0, 4, width, 1, green)</p></li>
				<li>Draw the player:<p class="source-code">display.FillRectangle(58, 0, 6, 6, green)</p></li>
				<li>Sleep for <strong class="source-inline">12</strong> milliseconds. If we do not sleep here, the enemy and the bullet will move too quickly <a id="_idIndexMarker392"/>over the screen and will appear to be flickering, which does not look nice. So, we use this little trick to slow it down and reduce the flickering:<p class="source-code">time.Sleep(12 * time.Millisecond)</p><p class="source-code">  }</p><p class="source-code">}</p><p>Now that we have implemented the main game logic, we only have to create the logic that updates the bullet and the enemy before we can play the game.</p><p>Update the bullet by incrementing its position on the y-axis by 2. Draw a black box behind<a id="_idIndexMarker393"/> it so that it does not leave a trail on the display:</p><p class="source-code">func updateBullet(display st7735.Device, posY int16)</p><p class="source-code">    int16 {</p><p class="source-code">    display.FillRectangle(58, posY-2, bulletSize, 2, </p><p class="source-code">        black)</p><p class="source-code">    display.FillRectangle(58, posY, bulletSize, </p><p class="source-code">        bulletSize, green)</p><p class="source-code">    return posY + 2</p><p class="source-code">}</p></li>
			</ol>
			<p>The last thing we need to do is update the enemy. To do so, follow these last few steps:</p>
			<ol>
				<li value="1">First, we must define the positions and width of the rectangle we will use to clear out the <a id="_idIndexMarker394"/>previous position of the enemy:<p class="source-code">func updateEnemy(display st7735.Device, posX, posY </p><p class="source-code">        int16) (int16, int16) {</p><p class="source-code">    var clearX, clearY, clearWidth int16</p></li>
				<li>Now, we must calculate the position where we need to clear out the enemy:<p class="source-code">clearX = posX - 1</p><p class="source-code">clearY = posY</p><p class="source-code">clearWidth = 1</p></li>
				<li>If the enemy reaches the left-hand side, we need to completely remove its rectangle as the enemy will spawn on the other side of the screen again:<p class="source-code">if posX == 0 {</p><p class="source-code">    clearY = posY + enemySize</p><p class="source-code">    clearX = width – enemySize</p><p class="source-code">    clearWidth = enemySize</p><p class="source-code">}</p></li>
				<li>Now, we must <a id="_idIndexMarker395"/>clear out the enemy and draw the enemy in its new position. We must do this to prevent the enemy from leaving trails on the display:<p class="source-code">display.FillRectangle(clearX, clearY, clearWidth, enemySize, black)</p><p class="source-code">display.FillRectangle(posX, posY, enemySize, enemySize, red)</p></li>
				<li>Update the position of the enemy on the x-axis:<p class="source-code">posX++</p></li>
				<li>If the enemy reaches the border of the screen on the x-axis, they also move on the y-axis:<p class="source-code">if posX &gt; width-enemySize {</p><p class="source-code">    posX = 0</p><p class="source-code">    posY -= enemySize</p><p class="source-code">}</p></li>
				<li>Return the new position:<p class="source-code">return posX, posY</p><p class="source-code">}</p></li>
			</ol>
			<p>This is all the logic we need for that game. Now, let's play it. Flash the program using the following command:</p>
			<p class="source-code">tinygo flash –target=arduino-nano33 Chapter06/tinygame/main.go</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We do not need<a id="_idIndexMarker396"/> to specify a scheduler here because the scheduler is not deactivated by default for <strong class="source-inline">atsamd21</strong>. </p>
			<p>Once you've played the game for a few rounds, you can start thinking about how to extend the game:</p>
			<ul>
				<li>We could add two more buttons so that we can move the player left and right.</li>
				<li>We could make it possible for the player to shoot more than one bullet at a time.</li>
				<li>The enemy's movement could be randomized so that they don't always move from right to left.</li>
				<li>We could add<a id="_idIndexMarker397"/> a joystick to control the player's position.</li>
				<li>Multiple enemies could be spawned.</li>
				<li>The enemies could drop different kinds of powerups, which the player could then pick up.</li>
				<li>We could add a buzzer in order to add sounds to the game.</li>
				<li>We could display the high score at the end of each round.</li>
			</ul>
			<p>This was the last chapter <a id="_idIndexMarker398"/>before we start diving into the world of <strong class="bold">IoT</strong> and <strong class="bold">WebAssembly</strong>. If you <a id="_idIndexMarker399"/>want to test your knowledge, I recommend that you play around with this project. Extend it with more hardware and try to update the game's logic. I already provided some ideas in the preceding list. You could make use of these ideas or think of your own solutions. If you extend the game, I would love to see what and how you did this. So, please feel free to share your games on Twitter using the hashtags <strong class="source-inline">#tinygame</strong>, <strong class="source-inline">#tinygo</strong>, and <strong class="source-inline">#packtbookgame</strong>, and also don't forget to tag me using <strong class="source-inline">@Nooby_Games</strong>. Of course, you can also share your games on all other social media <a id="_idIndexMarker400"/>channels, blogs, and so on. You can also open an issue in this book's GitHub repository to show off your results. That way, I can also playtest your games.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor133"/>Summary</h1>
			<p>In this chapter, we learned what the I2C interface is and how to use it. We also learned how to use a 16x02 LCD display, how to display static text, how to display animations, and how to build a little CLI that can receive commands through UART and control the display. </p>
			<p>Then, we gained a deeper understanding of the SPI interface and used it to control a 1.8" TFT display. We drew some basic shapes and then used <strong class="source-inline">TinyDraw</strong> to draw circles and rectangles and <strong class="source-inline">TinyFont</strong> to draw text. At this point, we have used all the important interfaces of a microcontroller, so we now have the skills to connect and control any device we need in future projects.</p>
			<p>At the end of this chapter, we used the knowledge we'd gained in this chapter to build a simple game that is controlled by one button and is displayed on the 1.8" TFT display.</p>
			<p>In the next chapter, we are going to learn how build a <strong class="bold">WebAssembly</strong> page using TinyGo, as well as how to use the <strong class="bold">Wi-Fi chip</strong> that is built into the Arduino Nano 33 IoT.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor134"/>Questions</h1>
			<ol>
				<li value="1">How does a device that listens on an I2C bus know that a message is dedicated to that device?</li>
				<li>How does a device that listens on an SPI bus know that a message is dedicated to that device?</li>
			</ol>
		</div>
	</div></body></html>