- en: '*Chapter 6*: Building Displays for Communication using I2C and SPI Interfaces'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to display data using a 7-segment display,
    how a MAX7219 chip works, how ultrasonic distance sensors work, and how to write
    a library for all this. We used the SPI interface to do so.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, we will know how to use different types
    of displays and which displays use different interfaces for communication. We
    are going to learn how the I2C interface works by using a display that we can
    connect using an I2C bus. With that covered, we are going to learn how to read
    and interpret user input. After that, we are going to learn how to draw shapes
    and texts on displays. Finally, we are going to learn how to build a game that
    can run on a microcontroller. With this knowledge, we will be able to understand
    the overall concept of using various displays for communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the TinyGo drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying text on a 16x2 LCD display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying user input on the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a simple game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to need the following components for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Nano 33 IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HD44780 1602 LCD display bundled with an I2C interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ST7735 display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 10k Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 4-pinned button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/2Qo8Jji](https://bit.ly/2Qo8Jji)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the TinyGo drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058), *Building
    a Safety Lock Using a Keypad*, we learned about the TinyGo drivers repository.
    Let's have a brief look at how to find drivers and examples in this repository.
  prefs: []
  type: TYPE_NORMAL
- en: When you're planning a new project, it is always good to check if the drivers
    repository has drivers for the devices you plan to use. It will speed up your
    project and make it easier to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drivers repository is split into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The drivers directly reside in the root of the repository. All the examples
    are inside an example folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use an hd44780 LCD display with an I2C interface in our example,
    so let''s check if we can find it inside the drivers repository. Refer to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – An hd44780i2c driver'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – An hd44780i2c driver
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the package is named after the device and the interface (**I2C**)
    it uses. Sometimes, a driver package provides more than one interface to use in
    one package. Most of the drivers omit the additional interface in the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find example code that shows how to use a package, navigate to the `examples`
    folder and look for a folder that has exactly the same name as the driver package.
    The following screenshot shows the example code for the **hd47780i2c** driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – hd44780i2c driver example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – hd44780i2c driver example
  prefs: []
  type: TYPE_NORMAL
- en: Now that we now know that there is a driver for the display we want to use and
    where to find example code for that driver, let's move on and use that driver.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text on an HD44780 16x2 LCD display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HD44780 16x2 LCD is cheap and easy to use. If we only want to display text,
    this type of display can do just that and is the device of choice. It has 16 pins,
    which is too many, if we want to combine it with more devices in a project. That
    is why it is a pretty common practice to use an I2C display driver to control
    the display. This is a concept similar to using a MAX7219 to drive a 7-segment
    display, as we did in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HD44780 16x2 display can be obtained in a bundle with an I2C driver soldered
    to it, or it can come without an I2C driver. The display can come in different
    color configurations, pertaining to background and text color. They typically
    look similar to the one shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – HD44780 front'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – HD44780 front
  prefs: []
  type: TYPE_NORMAL
- en: 'When the display comes with an I2C driver, it is usually an LCM1602 IIC, which
    provides four ports:'
  prefs: []
  type: TYPE_NORMAL
- en: GND
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VCC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SDA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SCL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, when using the LCM1602, we only need to connect *GND* and *VCC* to the
    power bus; the remaining two wires are used for *SDA* and *SCL*. The LCM1602 IIC
    has a potentiometer on the board, which can be used to adjust the contrast of
    the display. The following image shows such an LCM1602 IIC, which has been soldered
    to the back of an HD44780:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – LCM1602 IIC soldered to the back of an HD44780'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – LCM1602 IIC soldered to the back of an HD44780
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Most HD47780 displays operate at 5V, but some only need 3.3V. So, check the
    datasheet of your display carefully to prevent possible damage!
  prefs: []
  type: TYPE_NORMAL
- en: We now have a brief understanding of the HD44780 and that we can utilize an
    LCM1602 IIC to save some pins. Now, let's move on and build the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Building the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can show anything on the display, we need to build the circuit. Just
    follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the jumper of the power supply sits on 5V. Double-check if you
    might have a 3.3V display and if so, set the jumper to 3.3V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *GND* pin of the display to the *GND* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *VCC* pin of the display to the *VCC* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *A14* to the breadboard (*GND*) with the *GND* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *A9* to the breadboard (*SCL*) with the *SCL* pin of the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *A8* to the breadboard (*SDA*) with the *SDA* pin of the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The circuit should now look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – 16x02 I2C display circuit (image taken from Fritzing)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – 16x02 I2C display circuit (image taken from Fritzing)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '16x02 I2C LCD Fritzing parts have been taken from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-](https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-).'
  prefs: []
  type: TYPE_NORMAL
- en: That was everything we needed to set up regarding our hardware devices. However,
    before we start writing the code, we need to understand I2C.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding I2C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I2C is a synchronous two-wired serial bus, where the data wire being used is
    bidirectional. Sometimes, **I2C** is also called a **Two-Wire Interface** (**TWI**).
    One wire is used to provide a **clock**, while the other wire is used to **transmit
    data**.
  prefs: []
  type: TYPE_NORMAL
- en: The I2C bus allows multiple devices to communicate on the same bus. Unlike the
    **Peripheral Interface** (**SPI**)) bus, the I2C bus does not need a **chip select**
    (**CS**) pin; instead, it just includes the address of the receiving device in
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'An I2C message contains the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start condition**: The start condition signals that a new message is being
    sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Address frame**: The address frame contains the address of the device that
    should receive the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read/Write bit**: This bit is used to signal whether data is being sent from
    the controller to the device, or if data is being requested from the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ACK/NACK bit**: The receiving device tells the sender if the previous frame
    has been received successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data frame**: A single message can contain *1* to *n* DataFrames of 8 bits
    each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop condition**: The stop condition signals that the message has been completely
    sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image visualizes a message with 16 bits of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – I2C message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.6_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – I2C message
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you do not know the address of the device you want to use, you can make use
    of the ACK bit by iterating all possible addresses and checking if the device
    sends an ACK on an address. If that is the case, you've found the address.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a brief understanding of what I2C is and how it works, we can
    write our first program using I2C to control the display.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating a new folder named `Chapter06` inside our project.
    Inside the `Chapter06` folder, create a new folder named `hd44780-text-display`
    and create a new `main.go` file with an empty `main` function inside it. The project
    structure should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.7_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps to display the first piece of text:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, configure the I2C interface and set the clock''s
    `frequency` to `400KHz`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `hd44780i2c` and pass the `I2C` interface, as well
    as `address`, as a parameter. Most LCM1602 IICs should listen on the `0x27` address,
    but some modules listen on `0x3F`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the display by setting columns `(Width)`and rows (`Height`). We need
    to do this as this driver also supports 20x4 and other types of displays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the text. `\n` is being interpreted by the driver, and all characters
    followed by `\n` are being written to the next row. We can do this with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s test the code by flashing it. Use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now see the text being printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what happens when we try to print more than 16x2 characters
    onto the screen. To do so, just add the following snippet to the end of our `main`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, flash the program again and look at the result. What we can observe is
    that after reaching the 32nd character, the cursor jumps to position x = 0 and
    y = 0 again and continues to print from there. However, we want to print more
    than 32 characters on the display, and we want to be able to read all of them.
    To do so, we must create a small animation. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `main` function, sleep for `5` seconds and call the `animation`
    function and pass `lcd` as a parameter, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to define the `animation` function, which takes `lcd` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to define the text we want to print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must clear the display to remove everything we printed previously. This
    also resets the cursor to the first position (0,0):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s print a single character. We need to do some type conversions here
    as the display driver only accepts `[]byte` as a parameter. For this, refer to
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the message has been completely written onto the display, we sleep for
    `2` seconds and clear the display again. This enables a clean start for the next
    iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, flash the updated program again. The characters should now nicely appear
    one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to use the display driver to print hardcoded texts
    and how to create a simple animation, let's display some dynamically received
    texts.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying user input on the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to print the input of a user onto the display.
    The input is being sent from the computer to the microcontroller using **serial
    (UART)**, which will then print it onto the display.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B16555_02_Final_VK_ePub.xhtml#_idTextAnchor041), *Building
    a Traffic Lights Control System*, we learned how to use UART to send messages
    to the computer, and observed them using PuTTY. Now, we are going to use this
    interface bidirectionally. For this project, we are using the same hardware setup
    that we used in the previous section, which means we can directly dive into the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new folder named `hd44780-user-input` inside the `Chapter06`
    folder. Then, inside this newly created folder, add a new `main.go` file with
    an empty `main()` function inside it. The project''s structure should now look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.8_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the hex value for `carriageReturn` as a constant. Later, we will be checking
    if a received byte equals this `carriageReturn` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the `uart` interface in a variable so that we don''t have to type `machine.UART0`
    every time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, start by initializing the display driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let the user know that we can type something and then print it on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to clear the display as soon as the first input has been received.
    That is why we save this state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If no data resides in the buffer, we don''t want to do anything. Incoming data
    isinternally buffered by TinyGo using a ring buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we encounter the very first input, we must clear the display and save the
    state that we had input previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we read one byte from the buffer and log any possible errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a `carriageReturn` is being received, such as because the user pressed the
    *Enter* key, we also want to print in a new line. We print that character on the
    display, as well as to `uart`, so that the output in PuTTY and the output on the
    display behave similarly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to simply print the data onto both outputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can receive data from a computer that is connected to the microcontroller
    and print it onto the display. Try it out by flashing the program to the microcontroller
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start PuTTy, connect to the `microcontroller` profile, and start typing
    to check if the program runs correctly. If everything works correctly, PuTTY should
    also print what you have written, similar to what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – PuTTY output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.9_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – PuTTY output
  prefs: []
  type: TYPE_NORMAL
- en: The UART interface is a serial interface, which means it can be also used to
    send and receive data between two microcontrollers. On the Arduino Nano 33 IoT,
    the **transmit** (**TX**) pin is being used to send the data and the **receive**
    (**RX**) pin is being used to receive data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to read and interpret single bytes from the
    UART interface, as well as how to manually send data back to the UART interface,
    without using the `print()` or `println()` functions. We'll use this knowledge
    in the next section to learn how to interpret longer strings of data.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to parse the input from a user and compare the
    input with predefined commands. These commands will then be executed by the microcontroller.
    For this project, we are going to use the same hardware setup that we used in
    the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a new folder named `hd44780-cli` inside the `Chapter06`
    folder. Then, we must create a `main.go` file with an empty `main` function inside
    it. The project''s structure should now look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the project structure has been set up, we can implement the logic.
    To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `main` function, start by defining some constants. `commandConstant`
    represents the command that needs to be sent to the microcontroller. We will use
    these constants ahead in this code and compare them with the user input to determine
    whether a CLI command has been entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the UART interface in a variable. We could also always write `machine.UART0`
    instead, but by doing it this way, we improve the readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, we initialize the display, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s call the `homeScreen` function (we are going to explain what this
    function does when we implement it later):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a `commandBuffer`. That is a simple string where we store the
    parts of a command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`commandIndex` is being used to count the characters inside `commandBuffer`.
    If the index is greater than the length of the longest command, then we know that
    we can reset the buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will be using the `commandStart` boolean as a signal, so we need to append
    any subsequent characters to `commandBuffer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just like in the previous project, we are going to use the `hadInput` flag
    to clear the screen when the first input is received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We don''t need to do anything if there are no characters in the internal receive
    buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Upon receiving the first input, clear the display. We will explain the `clearDisplay`
    function when we implement it ahead, after a few steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we read a byte from the buffer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if we received a **pound sign (#)**. This is the indicator that a command
    is going to follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we receive the start of the command, we append all subsequent characters
    to `commandBuffer`. This is done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check if we may have a complete command inside `commandBuffer`, we must
    switch over our `commandBuffer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the content of `commandBuffer` equals `homeCommand`, we execute the `homeScreen`
    function and reset the command. We must also write the input data back inside
    the UART interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the content of `commandBuffer` equals `clearCommand`, we must execute the
    `clearDisplay` function and reset the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `commandIndex` is greater than the length of our longest command, we must
    reset the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we receive a `carriageReturn`, we must print a new line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we print the received data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the `homeScreen` function, which is called when the input matches
    the `homeScreen` command. We must clear the display and print the first input
    again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the `clearDisplay` function, which is called when the input matches
    the `clearDisplay` command. We just make use of the `ClearDisplay` function of
    the display here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, flash the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try out our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start putty and select the microcontroller profile. Type something and use
    the `#home` and `#clear` commands that we defined in the code. PuTTY''s output
    should now look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – CLI output in PuTTY'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – CLI output in PuTTY
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have verified that the program works as intended. Such a system
    could be used to control a microcontroller using another microcontroller, not
    just to display something – it could also be used to request sensor readings or
    trigger other things.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to interpret more than a single character of
    input data at a time, as well as how to set up a simple CLI in order to execute
    commands that are being sent through UART. In the next section, we are going to
    gain a deeper understanding of SPI, since we will be using an SPI-driven display
    in the final project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPI is a bus system that has a controller and one or many devices. The controller
    selects a device that should send data to the controller, or that is going to
    receive data from the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Devices on an SPI bus can also be daisy chained together. A **daisy chain**
    is a wiring scheme in which you put multiple devices together in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'SPI communication between two devices uses the following four pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CS**: **ChipSelect** selects which device on the bus should receive or send
    data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CLK**: **Clock** sets the frequency of the transfer (DO) and receive (DI)
    wires.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DO**: **DataOut** or **DigitalOut** transmits data to the receiving device.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DI**: **DataIn** or **DigitalIn** receives data from the controller.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows the one-to-one connection of an SPI controller
    and an SPI device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – SPI communication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – SPI communication
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the SPI connection of one controller and two devices.
    Here, we are using two CS pins to signal the receiving device. This is the device
    the controller is talking to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – SPI communication between a controller and two devices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – SPI communication between a controller and two devices
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how devices can be daisy chained together. The
    *DO* pin of the first device is connected to the *DI* pin of the next device,
    while they share the *CLK* and *CS* wires:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – SPI communication with daisy chained devices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – SPI communication with daisy chained devices
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of SPI, let's build a circuit using
    the ST7735 display.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a simple game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to use another display type using
    the SPI interface. We need a new type of display since we want to display more
    than plain text. We will also discover two more TinyGo repositories that provide
    handy functions for when we're working with displays. The display we are going
    to use in this section is a 1.8" TFT ST7735 display with a resolution of 160x128
    pixels. So, let's have a brief look at the technical specifications of the display.
  prefs: []
  type: TYPE_NORMAL
- en: The ST7735 display provides an SD card slot, which is optional. The display
    has a color depth of 262K colors on a TFT-LCD module. The SPI interface is being
    used with the display. To draw something on the display, we need eight pins. We
    have already used SPI, but we did not have a deeper look at it, since the devices
    can be arranged on an SPI bus in different ways. So, let's gain a better understanding
    of how SPI works before we use the display in an example project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in the previous projects, we are going to use an external power supply.
    We also need a ST7735 display, the Arduino Nano 33 IoT, and some jumper wires.
    To set everything up correctly, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the *GND* lane from the power bus to pin *J50 (GND)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *E31 (LED)* on the breadboard to pin *A53 (D2)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *E32 (SCK)* on the breadboard to pin *J63 (D13)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *E33 (SDA)* on the breadboard to pin *A62 (D11)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *E34 (AO)* on the breadboard to pin *A56 (D5)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *E35 (RESET)* on the breadboard to pin *A57 (D6)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *E36 (CS)* on the breadboard to pin *A58 (D7)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *GND* lane from the power bus to pin *E37 (GND)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *VCC* lane from the power bus to pin *E38 (VCC)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the ST7735 display so that the *LED* pin sits in *A31* and the *VCC* pin
    sits in *A37*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is everything we need to connect to the display. The setup should now
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – ST7735 circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – ST7735 circuit
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The 1.8" TFT display Fritzing part is made by vanepp: [https://forum.fritzing.org/u/vanepp](https://forum.fritzing.org/u/vanepp).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up the hardware, let's implement some logic.
  prefs: []
  type: TYPE_NORMAL
- en: Using an ST7735 display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TinyGo provides a driver for ST7735 displays. This means we can use the existing
    driver. Also, TinyGo provides two additional packages named `TinyFont` and `TinyDraw`,
    both of which we are going to use. First, let's check out the `TinyDraw` package.
  prefs: []
  type: TYPE_NORMAL
- en: '`TinyDraw` is a repository inside the TinyGo organization on GitHub. You can
    find it at [https://github.com/tinygo-org/tinydraw](https://github.com/tinygo-org/tinydraw).'
  prefs: []
  type: TYPE_NORMAL
- en: '`TinyDraw` is still in an early state, which means that it has not been optimized
    for performance or memory usage. However, it provides useful functionality, such
    as for drawing rectangles, circles, filled rectangles and filled circles, and
    more. It works with most interface drivers since the APIs of display drivers are
    nearly (or exactly) the same. Now, let''s have a look at the `TinyFont` package
    before we see it in action.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like `TinyDraw`, `TinyFont` is a repository inside the TinyGo organization
    on GitHub. You can find it at [https://github.com/tinygo-org/tinyfont](https://github.com/tinygo-org/tinyfont).
  prefs: []
  type: TYPE_NORMAL
- en: '`TinyFont` provides an API to let you draw text onto displays using fonts that
    come with the `TinyFont` package. It also allows you to create your own custom
    font. `TinyFont` also makes use of the fact that most TinyGo display drivers share
    the same interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s set up a project that uses the ST7735, TinyDraw, and TinyFont.
    To do so, create a new folder named `st7735` inside the `Chapter06` folder and
    create a new `main.go` file with an empty `main()` function inside it. The project''s
    structure should now look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s dive into the code. We will need to import the following packages
    for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To write our first test program for this display, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `main` function, define a set of colors that we are going to use
    later in the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `SPI0` interface with a frequency of 12 MHz. We do not need to
    pass the pins for SCK and DO as the `Configure` function will use the default
    SPI pins for this board when no pins are passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the required pins for the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a new instance of the `st7735` display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `Configure` function. This function transmits the bootup sequence
    to the display. After this call, the display is ready to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the `width` and `height` attributes from the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw four rectangles. Each of them should take up a quarter of the screen and
    be a different color. The function takes a position on the x-axis, a position
    on the y-axis, the width and height of the rectangle to draw, as well as the color
    of the rectangle. We will use this as a test for our display. This is a good test
    for the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we move on and draw some more advanced graphics, let''s test the program
    by flashing it using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the program has been successfully flashed onto the microcontroller, you
    should see four rectangles. This looks similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – ST7735 displaying four rectangles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – ST7735 displaying four rectangles
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s draw some more complicated forms using `TinyDraw` and some text
    using `TinyFont`. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `main` function, add a sleep for 3 seconds so that we have
    a chance to actually see the display test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a counter that will be used to display a count of how many times
    we have drawn an animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fill the screen with `black` to clean the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw a white rectangle at the lower end of the screen. It should have a height
    of `32` pixels, which should leave us with 128x128 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we have assembled our display upside down, we are going to write text
    rotated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the center of the black square, draw three circles of different sizes and
    colors on top of each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, draw the `TinyFont` text in `green` beneath the circles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw the count of how many times the animation will run on the white rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to sleep for a moment because otherwise, we won''t be able to see the
    result. This is because it will be overridden in the next iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, flash the program again. After the test screen, you should see a result
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Result of the test program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.18_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – Result of the test program
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to draw basic shapes and write text on our display.
    The next logical step is to write a game that runs on a microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to develop a very simple game that consists of
    an enemy, represented by a red block, that tries to reach the end of the screen.
    A green line will represent our home zone, which the red block should not cross.
    We''ll also have a green block that represents the player, as well as a smaller
    green block that represents a bullet that we can shoot to stop the red block from
    invading our home zone. We will be adding a button that will act as a trigger
    and shoot the small green blocks. So, the logical first step is to add the button
    to our breadboard. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the button on the breadboard so that one pin sits in *E23* and the other
    pins sit in *E25* on one side and *F25* and *F23* on the other side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the *+3V3* output from the Arduino to *J23* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a **10K Ohm resistor** to connect the *GND* lane from the power bus to *J25*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *D25* to *A60 (D9)* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This was everything we needed to add to the circuit. It should now look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – The final circuit with the button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.19_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – The final circuit with the button
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new folder for the last project in this chapter. Name
    the folder `tinygame` and put it inside the `Chapter06` folder. Then, create a
    new `main.go` file with an empty `main()` function inside it. The project''s structure
    should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.20_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the logic, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `bool` that holds the `buttonPressed` state. We will define this globally,
    so we do not need to use channels or something else to pass the state between
    the goroutines that we are going to use. This is just an easy and convenient way
    to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define `enemySize`, `bulletSize`, and the `width` and `height` properties of
    the game field in pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two variables to store our `currentScore` and `highscore`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a set of colors that we will use later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to move inside the `main` function. Here, assign `buttonPin` and
    configure it as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `highscore` since we are in the startup phase. Here, `highscore` is
    `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the display, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `checkButton` function inside a new goroutine so that it is non-blocking.
    This enables us to update the game loop in the `main` goroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop forever and fill the screen with black to erase everything from the screen
    after each round of the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop forever and check the button''s state. If the button has been pressed,
    we update the `buttonPressed` state. After each check, we sleep for `20` milliseconds,
    since we need a blocking call so that the scheduler can work on other goroutines
    again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `updateHighscore` function takes a `score`, checks if this new `score`
    is greater than `highscore`, and if so, it updates `highscore` and prints `highscore`
    to the serial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we have implemented a check for button presses, a function to update
    `highscore`, and also have a main goroutine that starts a new round of the game
    as soon as it ends. Now, let''s implement the actual game logic. To do so, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, it would be best to split the update for the game''s physics, such
    as the player''s movement, bullets, and the enemy and put it in one part of the
    logic, and then put the animation in another part of the logic. When developing
    games for other platforms, these two parts would update independently of each
    other so that they don''t rely on the same framerate. However, to keep things
    simple, we will have a single game loop that updates the positions as well as
    drawing to the screen. The `updateGame` function represents the main logic of
    the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define some variables that will store the position of the enemy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To prevent the enemy from starting above the game field, we must subtract its
    size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to store the position of the bullet inside a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We store the state if a shot has been fired in a bool variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We store the state if a new shot can be fired in a bool variable. We initialize
    it to `true` as we want the player to be able to fire a shot when the game starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The game has just started, so `currentScore` is `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the button has been pressed, we reset the `buttonPressed` state as we will
    be handling it. As long as the bullet is still flying inside the game field, we
    cannot fire again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a shot has been fired, we update the bullet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we update the position and draw it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the bullet leaves the game field, we reset the position and reset the `shotFired`
    and `canFire` states. This enables the player to shoot again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we check that the bullet has collided with the enemy on the horizontal
    axis. For this, we use a hitbox that is slightly larger than the bullet itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we check for a collision on the vertical axis. This time, the hitbox is
    the same size as `bulletSize`. These hitboxes have proven to work pretty well
    in my tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we hit the enemy, we increment the score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must draw a black box over the enemy to let it disappear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reset the enemy''s position. This respawns the enemy at its spawn position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `highscore`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update and draw the enemy''s position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the enemy passes our home zone, we lose the game. If this happens, we return,
    as this lets the loop outside the function run again and start a new game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw the home zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sleep for `12` milliseconds. If we do not sleep here, the enemy and the bullet
    will move too quickly over the screen and will appear to be flickering, which
    does not look nice. So, we use this little trick to slow it down and reduce the
    flickering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have implemented the main game logic, we only have to create the
    logic that updates the bullet and the enemy before we can play the game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the bullet by incrementing its position on the y-axis by 2\. Draw a
    black box behind it so that it does not leave a trail on the display:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing we need to do is update the enemy. To do so, follow these last
    few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define the positions and width of the rectangle we will use
    to clear out the previous position of the enemy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must calculate the position where we need to clear out the enemy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the enemy reaches the left-hand side, we need to completely remove its rectangle
    as the enemy will spawn on the other side of the screen again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must clear out the enemy and draw the enemy in its new position. We
    must do this to prevent the enemy from leaving trails on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the position of the enemy on the x-axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the enemy reaches the border of the screen on the x-axis, they also move
    on the y-axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the new position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is all the logic we need for that game. Now, let''s play it. Flash the
    program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to specify a scheduler here because the scheduler is not deactivated
    by default for `atsamd21`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve played the game for a few rounds, you can start thinking about
    how to extend the game:'
  prefs: []
  type: TYPE_NORMAL
- en: We could add two more buttons so that we can move the player left and right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could make it possible for the player to shoot more than one bullet at a
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enemy's movement could be randomized so that they don't always move from
    right to left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could add a joystick to control the player's position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple enemies could be spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enemies could drop different kinds of powerups, which the player could then
    pick up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could add a buzzer in order to add sounds to the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could display the high score at the end of each round.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was the last chapter before we start diving into the world of `#tinygame`,
    `#tinygo`, and `#packtbookgame`, and also don't forget to tag me using `@Nooby_Games`.
    Of course, you can also share your games on all other social media channels, blogs,
    and so on. You can also open an issue in this book's GitHub repository to show
    off your results. That way, I can also playtest your games.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what the I2C interface is and how to use it. We
    also learned how to use a 16x02 LCD display, how to display static text, how to
    display animations, and how to build a little CLI that can receive commands through
    UART and control the display.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we gained a deeper understanding of the SPI interface and used it to control
    a 1.8" TFT display. We drew some basic shapes and then used `TinyDraw` to draw
    circles and rectangles and `TinyFont` to draw text. At this point, we have used
    all the important interfaces of a microcontroller, so we now have the skills to
    connect and control any device we need in future projects.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we used the knowledge we'd gained in this chapter
    to build a simple game that is controlled by one button and is displayed on the
    1.8" TFT display.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how build a **WebAssembly** page
    using TinyGo, as well as how to use the **Wi-Fi chip** that is built into the
    Arduino Nano 33 IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does a device that listens on an I2C bus know that a message is dedicated
    to that device?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a device that listens on an SPI bus know that a message is dedicated
    to that device?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
