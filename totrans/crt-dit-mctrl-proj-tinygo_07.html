<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer116">
			<h1 id="_idParaDest-134"><em class="italic"><a id="_idTextAnchor135"/>Chapter 7</em>: Displaying Weather Alerts on the TinyGo Wasm Dashboard</h1>
			<p>We have learned how to display data using different types of displays that are connected using either the <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>) protocol or the <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>). While doing so, we dived a bit deeper into understanding how SPI works by learning that multiple devices can listen on a SPI bus and that we can daisy-chain devices on the bus. Furthermore, we have built a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) that interprets commands sent over serial and executes functions depending on the input. </p>
			<p>After working through this chapter, you will be familiar with using <strong class="bold">Message Queuing Telemetry Transport</strong> (<strong class="bold">MQTT</strong>), serving a <strong class="bold">WebAssembly</strong> (<strong class="bold">Wasm</strong>) page through a web server, how to set up a local MQTT broker, and how to use the Wi-Fi functionalities of the Arduino Nano 33 IoT board. </p>
			<p>In this chapter, we're going to cover the following main topics:  </p>
			<ul>
				<li>Building a weather station</li>
				<li>Sending MQTT messages to a broker</li>
				<li>Introducing Wasm</li>
				<li>Displaying sensor data and weather alerts on a Wasm page</li>
			</ul>
			<p>By the end of this chapter, you will know how to utilize an MQTT broker in order to send messages from your microcontroller over Wi-Fi. You will also know how to subscribe to MQTT messages inside a Wasm app and how to display data that is being sent as an MQTT message payload.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Technical requirements</h1>
			<p>The following software needs to be installed: </p>
			<ul>
				<li>Docker—You can find an installation guide by following this link: <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></li>
			</ul>
			<p>We are going to need the following components for this project:</p>
			<ul>
				<li>An Arduino Nano 33 IoT board</li>
				<li>An external power supply  (<strong class="bold">5 volts</strong> (<strong class="bold">5V</strong>))</li>
				<li>A BME280 sensor (I2C)</li>
				<li>An ST7735 display</li>
				<li>A breadboard</li>
				<li>Jumper wires</li>
			</ul>
			<p>You can find the code for this chapter on GitHub at the following link: <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07</a></p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3dXGe4o">https://bit.ly/3dXGe4o</a></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor137"/>Building a weather station</h1>
			<p>We start <a id="_idIndexMarker401"/>our journey through the world of <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) and <a id="_idIndexMarker402"/>Wasm by building a <strong class="bold">weather station</strong>. In our first project of this chapter, we are going to build a program that displays weather data on an <strong class="bold">ST7735</strong> display. We are going to build some reusable components that we are going to utilize in the final project of the chapter. We are going to learn how to use a <strong class="bold">BME280</strong> sensor that is able to sense air pressure, temperature, and humidity—the elements required for noting a change in the weather. But first, we need to assemble a circuit—so, let's see how that works.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Assembling the circuit</h2>
			<p>Before we are<a id="_idIndexMarker403"/> able to read and display the sensor data, we need to assemble the circuit. We are connecting the BME/BMP280 sensor using the I2C interface, and we are going to connect the ST7735 display using the SPI interface. To do so, perform the following steps:</p>
			<ol>
				<li>Place the <strong class="bold">BME/BMP280</strong> sensor with serial data pin (<strong class="bold">SDA</strong>) in <em class="italic">F21</em>.</li>
				<li>Connect pin <em class="italic">H21</em> (SDA) with pin <em class="italic">J56</em> (SDA) on the breadboard, using a jumper wire.</li>
				<li>Connect <a id="_idIndexMarker404"/>pin <em class="italic">I22</em> <strong class="bold">Serial Clock</strong> (<strong class="bold">SCL</strong>) with pin <em class="italic">I55</em> (SCL) on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">J23</em> <strong class="bold">Ground </strong>(<strong class="bold">GND</strong>) with <a id="_idIndexMarker405"/>the <em class="italic">GND</em> lane on the power bus.</li>
				<li>Connect <em class="italic">J24</em> (VIN) with<a id="_idIndexMarker406"/> the <strong class="bold">Voltage Common Collector</strong> (<strong class="bold">VCC</strong>) lane on the power bus.</li>
				<li>Place the display<a id="_idIndexMarker407"/> with the <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>) pin in pin <em class="italic">A31</em> on the breadboard.</li>
				<li>Connect <em class="italic">E31</em> (LED) with <a id="_idIndexMarker408"/>pin <em class="italic">A53</em> (D2) on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">E32</em> (SCK) with pin <em class="italic">A54</em> (D13) on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">E33</em> (SDA) with pin <em class="italic">A62</em> (D11) on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">E34</em> <strong class="bold">Analog pin </strong>(<strong class="bold">AO</strong>) with<a id="_idIndexMarker409"/> pin <em class="italic">A56</em> on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">E35</em> (AO) with pin <em class="italic">A57</em> (D5) on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">E36</em> (RESET) with pin <em class="italic">A58</em> (D6) on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">E37</em> <strong class="bold">chip select</strong> (<strong class="bold">CS</strong>) with <a id="_idIndexMarker410"/>pin <em class="italic">A59</em> (D7) on the breadboard, using a jumper wire.</li>
				<li>Connect <em class="italic">E37</em> (GND) with the <em class="italic">GND</em> lane on the power bus.</li>
				<li>Connect <em class="italic">E38</em> (VCC) with the <em class="italic">VCC</em> lane on the power bus.</li>
				<li>Connect <em class="italic">J51</em> (GND) with the <em class="italic">GND</em> lane on the power bus.</li>
			</ol>
			<p>The circuit should now look similar to this:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="Images/Figure_7.1_B16555.jpg" alt="Figure 7.1 – Weather-station circuit (image is taken from Fritzing)&#13;&#10;" width="1343" height="790"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Weather-station circuit (image is taken from Fritzing)</p>
			<p>This is everything<a id="_idIndexMarker411"/> we need on assembling for the complete chapter. We can proceed to the next section and write the code that is able to <em class="italic">read the sensor data and display it</em> onto ST7735.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Programming the weather station</h2>
			<p>We are going<a id="_idIndexMarker412"/> to put the weather station logic, which consists of reading and interpreting sensor data, into a separate package so that we can use it in an example that only displays the data onto a display. When this is done, we are going to reuse this package to get the sensor data and calculate alerts to send it<a id="_idIndexMarker413"/> to an <strong class="bold">MQTT broker</strong>. </p>
			<p>We start off by creating a new folder named <strong class="source-inline">Chapter07</strong> inside the project folder, and create a new folder named <strong class="source-inline">weather-station</strong> inside <strong class="source-inline">Chapter07</strong>. We then create a new file named <strong class="source-inline">weather.go</strong> and name the package <strong class="source-inline">weatherstation</strong>. The project structure should now look like this:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="Images/Figure_7.2_B16555.jpg" alt="Figure 7.2 – Project structure for programming the weather station&#13;&#10;" width="213" height="47"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Project structure for programming the weather station</p>
			<p>To implement the logic, follow these steps:</p>
			<ol>
				<li value="1">Define colors that are later to be used when we draw something on the display, as follows:<p class="source-code">var (</p><p class="source-code">    white = color.RGBA{255, 255, 255, 255}</p><p class="source-code">    black = color.RGBA{0, 0, 0, 255}</p><p class="source-code">)</p></li>
				<li>Next, define an interface and insert the following functions. We are going to explain each function in detail as soon as we implement it, in some later steps of this<a id="_idIndexMarker414"/> list: <p class="source-code">type Service interface {</p><p class="source-code">    CheckSensorConnectivity()</p><p class="source-code">    ReadData() (temperature, pressure, humidity int32,</p><p class="source-code">        err error)</p><p class="source-code">    DisplayData(temperature, pressure, humidity int32)</p><p class="source-code">    GetFormattedReadings(temperature, pressure,</p><p class="source-code">        humidity int32) (temp, press, hum string)</p><p class="source-code">    SavePressureReading(pressure float64)</p><p class="source-code">    CheckAlert(alertThreshold float64, timeSpan int8)</p><p class="source-code">        (bool, float64)</p><p class="source-code">}</p></li>
				<li>We then define <strong class="source-inline">struct</strong> that contains the sensor and the display, as well as some more fields that we are going to explain as soon as we use them. For the BME280 device, we are going to use a driver from the TinyGo <strong class="source-inline">drivers</strong> repository. You can import it using the following path: <a href="http://tinygo.org/x/drivers/bme280">tinygo.org/x/drivers/bme280</a>. The code is shown in the following snippet:<p class="source-code">type service struct {</p><p class="source-code">    sensor *bme280.Device</p><p class="source-code">    display *st7735.Device</p><p class="source-code">    readings [6]float64</p><p class="source-code">    readingsIndex int8</p><p class="source-code">    firstReadingSaved bool</p><p class="source-code">}</p></li>
				<li>We then add<a id="_idIndexMarker415"/> a new constructor function that sets the sensor and display and initializes all values, as follows:<p class="source-code">func New(sensor *bme280.Device, </p><p class="source-code">    display *st7735.Device) Service {</p><p class="source-code">         return &amp;service{</p><p class="source-code">         sensor: sensor,</p><p class="source-code">         display: display,</p><p class="source-code">         readingsIndex: int8(0),</p><p class="source-code">         readings: [6]float64{},</p><p class="source-code">         firstReadingSaved: false,</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Then, add the <strong class="source-inline">ReadData</strong> function, which is a convenience function that reads all sensor values and returns them. The code can be seen in the following snippet:<p class="source-code">func (service *service) ReadData() (temp, press, hum</p><p class="source-code">     int32, err error) {temp, err =</p><p class="source-code">         service.sensor.ReadTemperature()</p><p class="source-code">            if err != nil {</p><p class="source-code">                return</p><p class="source-code">}</p><p class="source-code">press, err = service.sensor.ReadPressure()</p><p class="source-code">            if err != nil {</p><p class="source-code">                return</p><p class="source-code">}</p><p class="source-code">hum, err = service.sensor.ReadHumidity()</p><p class="source-code">            if err != nil {</p><p class="source-code">                return</p><p class="source-code">}</p><p class="source-code">return</p><p class="source-code">}</p></li>
				<li>We then add a<a id="_idIndexMarker416"/> function that blocks the execution of the program until connection to the BME280 sensor has been approved, as follows:<p class="source-code">func (service *service) CheckSensorConnectivity() {</p><p class="source-code">    for {</p><p class="source-code">        connected := service.sensor.Connected()</p><p class="source-code">        if !connected {</p><p class="source-code">            println("could not detect BME280")</p><p class="source-code">            time.Sleep(time.Second)</p><p class="source-code">}</p><p class="source-code">       println("BME280 detected")</p><p class="source-code">       break</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>We now add a function that takes the sensor readings and displays them on the screen, as<a id="_idIndexMarker417"/> follows:<p class="source-code">func (service *service) DisplayData(</p><p class="source-code">    temperature, pressure, humidity int32) {</p></li>
				<li>Fill the screen so that we have no artifacts from previous calls. If we were to skip this step, we would possibly draw images above it that had previously been drawn, which would look really messy. The code is shown in the following snippet:<p class="source-code">service.display.FillScreen(black)</p></li>
				<li>Write a header using <strong class="source-inline">tinyfont</strong>, as follows:<p class="source-code">tinyfont.WriteLineRotated(service.display,</p><p class="source-code">    &amp;freemono.Bold9pt7b, 110, 3, "Tiny Weather",</p><p class="source-code">        white, tinyfont.ROTATION_90)</p></li>
				<li>Convert the readings to strings, as follows:<p class="source-code">temp, press, hum :=</p><p class="source-code">    service.GetFormattedReadings(temperature,</p><p class="source-code">        pressure, humidity)</p></li>
				<li>Build and display the temperature, pressure, and humidity strings, as follows:<p class="source-code">tempString := "Temp:" + temp + "C"</p><p class="source-code">tinyfont.WriteLineRotated(service.display,</p><p class="source-code">    &amp;freemono.Bold9pt7b, 65, 3, tempString,</p><p class="source-code">    white,tinyfont.ROTATION_90)</p><p class="source-code">pressString := "P:" + press + "hPa"</p><p class="source-code">tinyfont.WriteLineRotated(service.display,</p><p class="source-code">    &amp;freemono.Bold9pt7b, 45, 3, pressString, white,</p><p class="source-code">    tinyfont.ROTATION_90)</p><p class="source-code">humString := "Hum:" + hum + "%"</p><p class="source-code">tinyfont.WriteLineRotated(service.display,</p><p class="source-code">    &amp;freemono.Bold9pt7b, 25, 3, humString, white,</p><p class="source-code">    tinyfont.ROTATION_90)</p><p class="source-code">}</p></li>
				<li>Add a function<a id="_idIndexMarker418"/> that converts the sensor readings to °C, <strong class="bold">hectopascal</strong> (<strong class="bold">hPa</strong>),  and relative humidity as percentage to the strings, as follows: <p class="source-code">func (service *service)</p><p class="source-code">    GetFormattedReadings(</p><p class="source-code">    temperature, pressure, humidity int32) (temp,</p><p class="source-code">        press, hum string) {</p><p class="source-code">temp = strconv.FormatFloat(</p><p class="source-code">    float64(temperature/1000), 'f', 2, 64)</p><p class="source-code">press = strconv.FormatFloat(</p><p class="source-code">    float64(pressure/100000), 'f', 2, 64)</p><p class="source-code">hum = strconv.FormatFloat(</p><p class="source-code">    float64(humidity/100), 'f', 2, 64)</p><p class="source-code">return</p><p class="source-code">}</p></li>
			</ol>
			<p>We have now<a id="_idIndexMarker419"/> finished implementing the logic to read and display the sensor data. The next step is calculating the weather alerts.</p>
			<h3>Calculating weather alerts</h3>
			<p>In order to<a id="_idIndexMarker420"/> calculate alerts, we need to save some readings. We can do so by following these steps:</p>
			<ol>
				<li value="1">For the weather-alert calculation, we will only need pressure. That is why we hold an array of <strong class="source-inline">float64</strong> in the <strong class="source-inline">service</strong> struct, as can be seen in the following code snippet:<p class="source-code">func (service *service) SavePressureReading(</p><p class="source-code">    pressure float64) {</p></li>
				<li>If we have ever saved a value before, we fill the complete array with the same value. This prevents some edge cases later on when calculating alerts. The code is shown in the following snippet:<p class="source-code">if !service.firstReadingSaved {</p><p class="source-code">    for i := 0; i &lt; len(service.readings); i++ {</p><p class="source-code">        service.readings[i] = pressure</p><p class="source-code">}</p></li>
				<li>As we have now inserted our first reading, we can set the <strong class="source-inline">true</strong> flag and <strong class="source-inline">return</strong>. This ensures that we only execute the preceding logic once. The code is shown in the following snippet:<p class="source-code">service.firstReadingSaved = true</p><p class="source-code">service.readingsIndex = 0</p><p class="source-code">return</p><p class="source-code">}</p></li>
				<li>Store the reading into the current index. If our current index exceeds the maximum number of stored datasets, we reset the index; so, the next reading is going to overwrite the reading in index <strong class="source-inline">0</strong>. The code is shown in the following snippet:<p class="source-code">service.readingsIndex++</p><p class="source-code">service.readingsIndex = service.readingsIndex %</p><p class="source-code">    int8(len(service.readings))</p><p class="source-code">service.readings[service.readingsIndex] = pressure</p><p class="source-code">}</p></li>
				<li>Add a function that uses the saved readings, calculates a difference between the two of them, and<a id="_idIndexMarker421"/> alerts if the difference exceeds the threshold. We are going to talk about thresholds and timespans later in this section when we call this function. The code is shown in the following snippet:<p class="source-code">func (service *service) CheckAlert(alertThreshold</p><p class="source-code">    float64, timeSpan int8) (bool, float64) {</p><p class="source-code">        currentReading :=</p><p class="source-code">               service.readings[service.readingsIndex]</p></li>
				<li>Calculate the <strong class="source-inline">comparisonIndex</strong> value based on the <strong class="source-inline">timeSpan</strong> value, as follows:<p class="source-code">currentReading := service.readings[currentIndex]</p><p class="source-code">comparisonIndex := currentIndex - timeSpan</p><p class="source-code">if comparisonIndex &lt; 0 {</p><p class="source-code">    comparisonIndex = 5 + comparisonIndex</p><p class="source-code">}</p></li>
				<li>Calculate the difference between the two values and raise an alert if the difference is greater than the threshold by returning <strong class="source-inline">diff</strong>, as follows:<p class="source-code">comparisonReading := service.readings[comparisonIndex]</p><p class="source-code">diff := comparisonReading - currentReading</p><p class="source-code">return diff &gt;= alertThreshold, diff</p><p class="source-code">}</p></li>
			</ol>
			<p>Okay—we just <a id="_idIndexMarker422"/>implemented an <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) that lets us read, convert, and<a id="_idIndexMarker423"/> display sensor data, and along with it we can save sensor readings and calculate weather alerts. </p>
			<p>Now, let's try out whether the code is actually able to read and display sensor data. To do so, we first create a new folder named <strong class="source-inline">weather-station-example</strong> inside the <strong class="source-inline">Chapter07</strong> folder. We then create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function inside. The project structure should now look like this:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="Images/Figure_7.3_B16555.jpg" alt="Figure 7.3 – Project structure for reading the code and displaying sensor data&#13;&#10;" width="209" height="90"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Project structure for reading the code and displaying sensor data</p>
			<p>Now, follow these steps to implement the example:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">main</strong> function, we sleep for <strong class="source-inline">5</strong> seconds to get enough time to open PuTTY so that we are able to monitor the output on the serial port. The code is shown in the following snippet:<p class="source-code">time.Sleep(5 * time.Second)</p></li>
				<li>Initialize and configure the display, as follows:<p class="source-code">machine.SPI0.Configure(machine.SPIConfig{</p><p class="source-code">    Frequency: 12000000,</p><p class="source-code">})</p><p class="source-code">resetPin := machine.D6</p><p class="source-code">dcPin := machine.D5</p><p class="source-code">csPin := machine.D7</p><p class="source-code">backLightPin := machine.D2</p><p class="source-code">display := st7735.New(</p><p class="source-code">    machine.SPI0, resetPin, dcPin, csPin,</p><p class="source-code">        backLightPin)</p><p class="source-code">display.Configure(st7735.Config{</p><p class="source-code">    Rotation: st7735.ROTATION_180,</p><p class="source-code">})</p></li>
				<li>Initialize and <a id="_idIndexMarker424"/>configure the sensor. The sensor needs to be calibrated, which is done inside the <strong class="source-inline">Configure</strong> function. The code is shown in the following snippet:<p class="source-code">machine.I2C0.Configure(machine.I2CConfig{})</p><p class="source-code">sensor := bme280.New(machine.I2C0)</p><p class="source-code">sensor.Configure()</p></li>
				<li>Create a new instance of <strong class="source-inline">weatherstation</strong> and wait for sensor connectivity. The code is shown in the following snippet:<p class="source-code">weatherStation := weatherstation.New(</p><p class="source-code">    &amp;sensor, &amp;display)</p><p class="source-code">weatherStation.CheckSensorConnectivity()</p></li>
				<li>Read and <a id="_idIndexMarker425"/>display the data, as follows:<p class="source-code">for {</p><p class="source-code">temperature, pressure, humidity, err :=</p><p class="source-code">    weatherStation.ReadData()</p><p class="source-code">if err != nil {</p><p class="source-code">    println("could not read sensor data:", err)</p><p class="source-code">    time.Sleep(1 * time.Second)</p><p class="source-code">    continue</p><p class="source-code">}</p><p class="source-code">weatherStation.DisplayData(</p><p class="source-code">    temperature, pressure, humidity)</p><p class="source-code">time.Sleep(2 * time.Second)</p><p class="source-code">}</p></li>
			</ol>
			<p>That's it for this example. Now, go on and flash the program, using the following command:</p>
			<p class="source-code">tinygo flash --target=arduino-nano33 ch7/weather-station-example/main.go</p>
			<p>After a brief moment, the display should now look similar to the one shown here: </p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="Images/Figure_7.4_B16555.jpg" alt="Figure 7.4 – Display output&#13;&#10;" width="787" height="410"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Display output</p>
			<p>We have now verified that we are able to read and display the sensor data. As we have now learned how to <a id="_idIndexMarker426"/>use the BMP280 sensor and have prepared a package that is able to calculate weather alerts, we can now go on to the next section, where we learn how to communicate with the Wi-Fi chip and how to send MQTT messages.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor140"/>Sending MQTT messages to a broker</h1>
			<p>Let's now start <a id="_idIndexMarker427"/>to dive into the world of IoT. As every device that has a connection to the internet—or at least to some network—can be considered an IoT device, the project in this section can be considered an IoT project. The Arduino Nano 33 IoT has a <strong class="source-inline">u-blox NINA-W102</strong> chip on board that is capable of Wi-Fi communication. We can communicate with this chip using the SPI interface. As a driver for the NINA chip already exists, we don't have to implement one ourselves. </p>
			<p>So, our plan is to send data through SPI to the NINA chip, which then sends the data through the network to an MQTT broker. The following diagram illustrates the process: </p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="Images/Figure_7.5_B16555.jpg" alt="Figure 7.5 – Communication diagram&#13;&#10;" width="1092" height="103"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Communication diagram</p>
			<p>Although the driver functionality is wrapped in a package, some boilerplate code is still needed to start <a id="_idIndexMarker428"/>using the Wi-Fi chip. So, let's wrap it inside a new package. </p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/>Implementing the Wi-Fi package</h2>
			<p>We are going to create an<a id="_idIndexMarker429"/> API that provides functionality to initialize the NINA chip, check the hardware and set up a connection. So, let's start by creating a new folder named <strong class="source-inline">wifi</strong> inside the <strong class="source-inline">Chapter07</strong> folder and creating a new <strong class="source-inline">wifi.go</strong> file inside the newly created folder, and name the package <strong class="source-inline">wifi</strong>. The project structure should now look like this:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="Images/Figure_7.6_B16555.jpg" alt="Figure 7.6 – Project structure &#13;&#10;" width="211" height="107"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Project structure </p>
			<p>Now, perform these steps to implement the logic:</p>
			<ol>
				<li value="1">Define an interface for the package, as follows:<p class="source-code">type Client interface {</p><p class="source-code">    Configure() error</p><p class="source-code">    CheckHardware()</p><p class="source-code">    ConnectWifi()</p><p class="source-code">}</p></li>
				<li>Add a client that stores the credentials as well as the SPI bus and <strong class="source-inline">wifinina.Device</strong>, as follows:<p class="source-code">type client struct {</p><p class="source-code">    ssid string</p><p class="source-code">    password string</p><p class="source-code">    spi machine.SPI</p><p class="source-code">    wifi *wifinina.Device</p><p class="source-code">}</p></li>
				<li>Add a constructor function that sets the SPI bus and the credentials, as follows:<p class="source-code">func New(ssid, password string) Client {</p><p class="source-code">    return &amp;client{</p><p class="source-code">        spi: machine.NINA_SPI,</p><p class="source-code">        ssid: ssid,</p><p class="source-code">        password: password,</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add <a id="_idIndexMarker430"/>the <strong class="source-inline">Configure</strong> function, as follows:<p class="source-code">func (client *client) Configure() error {</p></li>
				<li>Configure the NINA SPI bus using the default pins, as follows:<p class="source-code">err := client.spi.Configure(machine.SPIConfig{</p><p class="source-code">    Frequency: 8 * 1e6,</p><p class="source-code">    SDO: machine.NINA_SDO,</p><p class="source-code">    SDI: machine.NINA_SDI,</p><p class="source-code">    SCK: machine.NINA_SCK,</p><p class="source-code">})</p><p class="source-code">    if err != nil {return err</p><p class="source-code">}</p></li>
				<li>Create a new instance of the <strong class="source-inline">wifinina</strong> driver and pass the SPI bus as well as the default pins, as follows:<p class="source-code">client.wifi = &amp;wifinina.Device{</p><p class="source-code">    SPI: client.spi,</p><p class="source-code">    CS: machine.NINA_CS,</p><p class="source-code">    ACK: machine.NINA_ACK,</p><p class="source-code">    GPIO0: machine.NINA_GPIO0,</p><p class="source-code">    RESET: machine.NINA_RESETN,</p><p class="source-code">}</p><p class="source-code">client.wifi.Configure()</p></li>
				<li>The chip needs <a id="_idIndexMarker431"/><a id="_idIndexMarker432"/>a moment before it is ready to be used, which is why we sleep for a brief moment. The code is shown in the following snippet:<p class="source-code">time.Sleep(5 * time.Second)</p><p class="source-code">return nil</p><p class="source-code">}</p></li>
				<li>Now, we add a function to check the hardware, as follows:<p class="source-code">func (client *client) CheckHardware() {</p></li>
				<li>First, we print the <a id="_idIndexMarker433"/>currently installed <strong class="bold">firmware version</strong>. This information can be important if you face any issues using the NINA chip. Also, you can use this information to check which features are supported by the firmware. The code is shown in the following snippet: <p class="source-code">firmwareVersion, err := client.wifi.GetFwVersion()</p><p class="source-code">if err != nil {</p><p class="source-code">    return err</p><p class="source-code">}</p><p class="source-code">println("firmware version: ", firmwareVersion)</p></li>
				<li>Now, we scan for available Wi-Fi networks and print all results. The internal buffer only<a id="_idIndexMarker434"/> stores up to 10 <strong class="bold">service set identifiers</strong> (<strong class="bold">SSIDs</strong>). If the scan for Wi-Fi networks runs without any errors, we can be sure that we are able to communicate with the chip. The code is shown in the following snippet:<p class="source-code">result, err := client.wifi.ScanNetworks()</p><p class="source-code">if err != nil {</p><p class="source-code">    return err</p><p class="source-code">}</p><p class="source-code">for i := 0; i &lt; int(result); i++ {</p><p class="source-code">    ssid := client.wifi.GetNetworkSSID(i)</p><p class="source-code">    println("ssid:", ssid, "id:", i)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Now, we implement <a id="_idIndexMarker435"/>a convenience function that establishes a connection to a network, as follows:<p class="source-code">func (client *client) ConnectWifi() {</p><p class="source-code">    println("trying to connect to network: ",</p><p class="source-code">        client.ssid)</p><p class="source-code">client.connect()</p><p class="source-code">for {</p></li>
				<li>Sleep for a second, as it can take a while until the connection is established. The code is shown in the following snippet:<p class="source-code">time.Sleep(1 * time.Second)</p></li>
				<li>Get the connection status and print it, as follows:<p class="source-code">status, err := client.wifi.GetConnectionStatus()</p><p class="source-code">if err != nil {</p><p class="source-code">    println("error:",err.Error())</p><p class="source-code">}</p><p class="source-code">println("status:",status.String())</p></li>
				<li>If the status equals <strong class="source-inline">StatusConnected</strong>, as shown in the following code snippet, we are successfully connected to the network:<p class="source-code">if status == wifinina.StatusConnected {</p><p class="source-code">    break</p><p class="source-code">}</p></li>
				<li>Sometimes, the <a id="_idIndexMarker436"/>connection cannot be established on the first attempt, which is why we just try it again, as illustrated in the following code snippet:<p class="source-code">if status == wifinina.StatusConnectFailed || </p><p class="source-code">    status == wifinina.StatusDisconnected {</p><p class="source-code">        client.connect()</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>After the <a id="_idIndexMarker437"/>connection has successfully been established, we <a id="_idIndexMarker438"/>print the <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) address that our device has been assigned by the <strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>), as follows:<p class="source-code">ip, _, _, err := client.wifi.GetIP()</p><p class="source-code">if err != nil {</p><p class="source-code">    println("could not get ip address:", err.Error())</p><p class="source-code">}</p><p class="source-code">println("connected to wifi. got ip:", ip.String())</p><p class="source-code">}</p></li>
				<li>We can either only set the network (<strong class="source-inline">ssid</strong>) with no passphrase for open networks or we can set the network (<strong class="source-inline">ssid</strong>) and passphrase. Setting either of these options triggers a connection attempt. If no password has been set, we try to connect to an open network. If the password and <strong class="source-inline">ssid</strong> are set, we try to connect to a secured network, as follows:<p class="source-code">func (client *client) connect() error {</p><p class="source-code">    if client.password == "" {</p><p class="source-code">        return client.wifi.SetNetwork(client.ssid)</p><p class="source-code">}</p><p class="source-code">return client.wifi.SetPassphrase(</p><p class="source-code">    client.ssid, client.password)</p><p class="source-code">}</p></li>
			</ol>
			<p>That's everything we<a id="_idIndexMarker439"/> need to implement our abstraction layer. We are going to test this package together with an MQTT client abstraction layer, which we are going to implement next.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>Implementing an MQTT client abstraction layer</h2>
			<p>Just as with the <a id="_idIndexMarker440"/>Wi-Fi driver, the MQTT client needs some boilerplate code in order to get up and running. We are going to reduce the boilerplate code by adding an abstraction layer. That way, we only have the boilerplate code one time in a reusable component and do not have to write the same code repeatedly in every future project.</p>
			<p>We start by creating a new folder named <strong class="source-inline">mqtt-client</strong> inside the <strong class="source-inline">Chapter07</strong> folder, and create a new file named <strong class="source-inline">client.go</strong> and place it inside the <strong class="source-inline">mqttclient</strong> package. The project structure should now look like this:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="Images/Figure_7.7_B16555.jpg" alt="Figure 7.7 – Project structure&#13;&#10;" width="207" height="127"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Project structure</p>
			<p>Before we start to<a id="_idIndexMarker441"/> implement the code, we first need to understand what MQTT is and how it works.</p>
			<h3>Understanding MQTT</h3>
			<p>MQTT is a messaging<a id="_idIndexMarker442"/> protocol for the IoT. It <a id="_idIndexMarker443"/>is based on a <strong class="bold">publisher/subscriber</strong> architecture. A microcontroller that reads sensor data can <strong class="bold">publish messages</strong> to a<a id="_idIndexMarker444"/> so-called <strong class="bold">topic</strong> (such a microcontroller <a id="_idIndexMarker445"/>would<a id="_idIndexMarker446"/> be a thing in the IoT world). These messages are sent to a <strong class="bold">broker</strong>. </p>
			<p>The MQTT <a id="_idIndexMarker447"/>standard allows the usage of <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>), as well as <strong class="bold">Open Authorization</strong> (<strong class="bold">OAuth</strong>) for authentication. It <a id="_idIndexMarker448"/>is also possible to not authenticate at all. The available authentication flows depend on the implementation and configuration of the used MQTT broker. Securing the broker by using authentication flows is important when sending sensitive data over the internet. The following diagram shows an example architecture of a single MQTT broker and multiple MQTT clients:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="Images/Figure_7.8_B16555.jpg" alt="Figure 7.8 – MQTT architecture&#13;&#10;" width="1033" height="402"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – MQTT architecture</p>
			<p>In order to use MQTT, we need an active broker to which a client can publish messages. We also need one or <a id="_idIndexMarker449"/>many clients to be able to subscribe to messages from a certain topic.</p>
			<p>The sequence diagram of a typical MQTT communication is straightforward and is based on a <strong class="bold">command and command acknowledge</strong> pattern. Let's have a look at an example sequence, as follows:</p>
			<ol>
				<li value="1">The client connects to the broker.</li>
				<li>The broker acknowledges the connection.</li>
				<li>Optional: The client subscribes to a topic.</li>
				<li>The broker acknowledges the subscription.</li>
				<li>Optional: The client publishes a message.</li>
				<li>The broker acknowledges the published message.</li>
			</ol>
			<p>This looks like the sequence shown in the following diagram:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="Images/Figure_7.9_B16555.jpg" alt="Figure 7.9 – MQTT sequence diagram  (image was created using PlantUML)&#13;&#10;" width="266" height="277"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – MQTT sequence diagram  (image was created using PlantUML)</p>
			<p>Summarizing this, here<a id="_idIndexMarker450"/> we mean a broker can serve many clients, a client can subscribe to one or many topics, and a client can publish a message in a topic. This should be enough base knowledge about MQTT. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to gain a deeper knowledge about MQTT, you might want to have a look at the specification: </p>
			<p class="callout"><a href="https://mqtt.org/mqtt-specification/">https://mqtt.org/mqtt-specification/</a></p>
			<p>Let's now write the abstraction layer. As we have already prepared the project structure, we can start directly writing the code by following these steps inside the <strong class="source-inline">client.go</strong> file:</p>
			<ol>
				<li value="1">As our client is only going to publish messages, our API is going to be fairly simple. We need to be able to connect to a broker and we need to be able to publish messages. We now add <strong class="source-inline">struct</strong> that contains the <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) of the<a id="_idIndexMarker451"/> broker, an identifier that identifies us, and an <strong class="source-inline">mqtt.Client</strong> from the <strong class="source-inline">drivers</strong> repository, as follows:<p class="source-code">type Client struct {</p><p class="source-code">    mqttBroker string</p><p class="source-code">    mqttClientID string</p><p class="source-code">    MqttClient mqtt.Client</p><p class="source-code">}</p></li>
				<li>To create a<a id="_idIndexMarker452"/> new <strong class="source-inline">Client</strong>, we only need to set the <strong class="source-inline">mqttBroker</strong> URL, as follows:<p class="source-code">func New(mqttBroker, clientID string) *Client {</p><p class="source-code">    return &amp;client{</p><p class="source-code">        mqttBroker: mqttBroker,</p><p class="source-code">        MqttClientID: clientID,</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, add the <strong class="source-inline">ConnectBroker</strong> function, which is going to establish a connection to the broker. The code is shown in the following snippet:<p class="source-code">func (client *client) ConnectBroker() error {</p></li>
				<li>We create new client options that will later be passed as arguments when creating a new client. These options take all the parameters needed to establish a connection. When using a broker that requires a password and username, these can also be set here. The code is shown in the following snippet:<p class="source-code">opts := mqtt.NewClientOptions().</p><p class="source-code">        AddBroker(client.mqttBroker).</p><p>When testing programs using a local broker, we sometimes try to connect while the old client connection has not been discarded and we could run into problems connecting with the same <strong class="source-inline">clientID</strong> again, so using random strings helps a lot. The MQTT specification states that a <strong class="source-inline">clientID</strong> should be between 1 and 23 characters long, but brokers such as Mosquitto do not implement that. We will learn about the Mosquitto MQTT broker later in this section.</p><p>ClientIDs must be unique—otherwise, clients would be kicked out by the broker. </p></li>
				<li>We are going to use a combination of the <strong class="source-inline">clientID</strong> we passed in and a random string of length <strong class="source-inline">4</strong>, as illustrated in the following code snippet:<p class="source-code">SetClientID(client.mqttClientID + randomString(4))</p></li>
				<li>We now create a new client and pass <strong class="source-inline">opts</strong> as a parameter, and try to connect to the broker as follows:<p class="source-code">client.mqttClient = mqtt.NewClient(opts)</p><p class="source-code">token := client.MqttClient.Connect()</p></li>
				<li>Although the <a id="_idIndexMarker453"/>current implementation of the token always return <strong class="source-inline">true</strong> when using the <strong class="source-inline">wait</strong> function, we still add it here in case it is implemented by the time you have worked through this chapter. We can use this function to wait for any command to get <em class="italic">acked</em> (acknowledged). Alternatively, we could use <strong class="source-inline">token.WaitTimeout</strong>, which internally times out when the given time span is over. The first option is shown in the following code snippet:<p class="source-code">if token.Wait() &amp;&amp; token.Error() != nil {</p><p class="source-code">    return token.Error()</p><p class="source-code">}</p><p class="source-code">return nil</p><p class="source-code">}</p></li>
				<li>Add the <strong class="source-inline">PublishMessage</strong> function. <strong class="source-inline">qos</strong> (the <strong class="bold">quality of service</strong> (<strong class="bold">QOS</strong>)) can be <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, or <strong class="source-inline">2</strong>. After <a id="_idIndexMarker454"/>we have completely implemented this package, we are going to have a deeper look at the <strong class="source-inline">qos</strong> levels. The <strong class="source-inline">retain</strong> flag tells the broker to store the last message having a <strong class="source-inline">retain</strong> flag. When a new client subscribes to the broker, the retained message will directly get delivered. The code is shown in the following snippet:<p class="source-code">func (client *client) PublishMessage(</p><p class="source-code">    topic string, message []byte, qos uint8, retain</p><p class="source-code">        bool) error {</p><p class="source-code">    token := client.MqttClient.Publish(</p><p class="source-code">        topic, qos, retain, message)</p><p class="source-code">    if token.WaitTimeout(time.Second) &amp;&amp; </p><p class="source-code">        token.Error() != nil {</p><p class="source-code">            return token.Error()</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>The next step is <a id="_idIndexMarker455"/>to add a function that allows us to subscribe to a certain topic. The following code snippet illustrates this:<p class="source-code">func (client *Client) Subscribe(</p><p class="source-code">    topic string, qos byte, callback mqtt.MessageHandler)</p><p class="source-code">        error {</p><p class="source-code">    token := </p><p class="source-code">    client.MqttClient.<strong class="bold">Subscribe( topic, qos, callback)</strong></p><p class="source-code">    if token.WaitTimeout(time.Second) </p><p class="source-code">        &amp;&amp; token.Error() != nil {</p><p class="source-code">            return token.Error()</p><p class="source-code">}</p><p class="source-code">return nil</p><p class="source-code">}</p></li>
				<li>Now, add a function to generate a random string containing a character between <strong class="source-inline">A</strong> and <strong class="source-inline">Z</strong>. The following functions are taken from the <strong class="source-inline">mqtt</strong> driver example:<p class="source-code">func randomInt(min, max int) int {</p><p class="source-code">    return min + rand.Intn(max-min)</p><p class="source-code">}</p><p class="source-code">func randomString(len int) string {</p><p class="source-code">    bytes := make([]byte, len)</p><p class="source-code">    for i := 0; i &lt; len; i++ {</p><p class="source-code">        bytes[i] = byte(randomInt(65, 90))</p><p class="source-code">    }</p><p class="source-code">    return string(bytes)</p><p class="source-code">}</p></li>
			</ol>
			<p>That's it for our<a id="_idIndexMarker456"/> abstraction layer. Before we go on to write the actual weather-station program, let's have a look at the QOS levels.</p>
			<p>MQTT provides three QOS levels, which work as follows:</p>
			<ul>
				<li><strong class="bold">QOS 0</strong>: <em class="italic">A message is delivered once</em>. The message is not stored by the sender and is not ack<a id="_idIndexMarker457"/>nowledged. So, the client will only try to deliver it once, and if that fails, the message is discarded.</li>
				<li><strong class="bold">QOS 1</strong>: <em class="italic">The message is delivered at least once</em>. It is guaranteed that the message is being sent to the broker. The client tries to resend the message with an additional <strong class="source-inline">duplicate</strong> flag until it gets acknowledged by the broker. All of these messages will be sent to subscribed clients.</li>
				<li><strong class="bold">QOS 2</strong>: <em class="italic">The message will be delivered only once</em>. As in <strong class="bold">QOS 1</strong>, the message will be<a id="_idIndexMarker458"/> resent with a <strong class="source-inline">duplicate</strong> flag until the message has been acknowledged. The difference is that the message will only be delivered to subscribers when the client sends a <strong class="source-inline">PUBREL</strong> (publish release) message. </li>
			</ul>
			<p>You can find more information about the underlying processes by following this link: </p>
			<p><a href="https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/">https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/</a></p>
			<p>As we now have a <a id="_idIndexMarker459"/>basic understanding of MQTT and have implemented our abstraction layer, it's time to put everything together in the next step and actually start to publish messages to a broker.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Implementing the weather station</h2>
			<p>We have prepared <a id="_idIndexMarker460"/>all the code that we need to implement the actual logic but we do not have an MQTT broker yet. So, let's set up a local MQTT broker that we can use for this program.</p>
			<h3>Setting up an Eclipse Mosquitto MQTT broker</h3>
			<p>We are going to <a id="_idIndexMarker461"/>use the Eclipse Mosquitto MQTT broker. You can find more information regarding the broker here: <a href="https://mosquitto.org/">https://mosquitto.org/</a>.</p>
			<p>If you do not want to set up a local MQTT broker or if you cannot use Docker right now, you can skip this and use the Mosquitto test system. <em class="italic">But please only use the Mosquitto test system for testing purposes; also, never publish any sensitive data to the test system as anyone could listen to the messages.</em> You can find the needed URLs and ports for the test system here: <a href="http://test.mosquitto.org/">http://test.mosquitto.org/</a>.</p>
			<p>It is also possible to install a Mosquitto broker locally without using Docker, but that process won't be covered in this book as using Docker is an easy and straightforward process, while setting up Mosquitto locally is more complicated. To set up Mosquitto using Docker, we need to create a configuration file. To do so, create a new folder named <strong class="source-inline">mosquitto</strong> inside the <strong class="source-inline">Chapter07</strong> folder and create a new folder named <strong class="source-inline">config</strong> inside the <strong class="source-inline">mosquitto</strong> folder. Now, create a new file and name it <strong class="source-inline">mosquitto.conf</strong>. The next step is to insert the following configuration:</p>
			<p class="source-code">user mosquitto</p>
			<p class="source-code">listener 9001 127.0.0.1</p>
			<p class="source-code">protocol websockets</p>
			<p class="source-code">allow_anonymous true</p>
			<p>We have configured Mosquitto to use the user <strong class="source-inline">mosquitto</strong> and listen on all IP addresses of the host. We also listen for Websocket connections on the localhost using port <strong class="source-inline">9001</strong>, which we make use of in the Wasm app in the <em class="italic">Implementing the weather app</em> section later in this chapter. </p>
			<p>The <strong class="source-inline">allow_anonymous</strong> flag allows unauthenticated clients to connect. For more information<a id="_idIndexMarker462"/> regarding the possible configuration options, consult the main manual page at <a href="https://mosquitto.org/man/mosquitto-conf-5.html">https://mosquitto.org/man/mosquitto-conf-5.html</a>.</p>
			<p>Now, we only need to start the container. It is important to map ports <strong class="source-inline">1883</strong> and <strong class="source-inline">9001</strong> so that we can actually reach these ports. Also, we need to <em class="italic">pass the path to our config file</em>. So, <em class="italic">replace the path that I used with the actual path to the config file on your system</em>, as follows:</p>
			<p class="source-code">docker run -it --name mosquitto \</p>
			<p class="source-code">--restart=always \</p>
			<p class="source-code">-p 1883:1883 \</p>
			<p class="source-code">-p 9001:9001 \</p>
			<p class="source-code">-v <strong class="bold">~/go/src/ github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly /Chapter07/mosquitto/config/mosquitto.conf</strong>:/mosquitto/config/mosquitto.conf:ro \</p>
			<p class="source-code">eclipse-mosquitto</p>
			<p>As we now have a running Mosquitto instance, we can now truly begin to implement our client logic. </p>
			<p>Let's start by creating a new folder named <strong class="source-inline">weather-station-mqtt</strong> inside the <strong class="source-inline">Chapter07</strong> folder, then create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function inside. The project structure should now look like this:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="Images/Figure_7.10_B16555.jpg" alt="Figure 7.10 – Project structure for weather-station-mqtt&#13;&#10;" width="208" height="149"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – Project structure for weather-station-mqtt</p>
			<p>When developing<a id="_idIndexMarker463"/> these examples, I have faced some issues regarding the <strong class="source-inline">wifinina</strong> driver inside the TinyGo <strong class="source-inline">drivers</strong> repository. I am currently working on resolving these issues. So, if you face any problems connecting to your Wi-Fi network, use the two imports shown in the following code snippet instead of the official ones. You will also need to change these imports in the <strong class="source-inline">wifi</strong> and <strong class="source-inline">mqtt-client</strong> packages we developed earlier in this chapter:</p>
			<p class="source-code">github.com/Nerzal/drivers/wifinina</p>
			<p class="source-code">github.com/Nerzal/drivers/net/mqtt</p>
			<p>Also, when using my fork of the <strong class="source-inline">drivers</strong> repository for the <strong class="source-inline">wifinina</strong> driver, the initialization of <strong class="source-inline">wifi.Client</strong> looks a little bit different. When using the driver, you will see that there is an error in the <strong class="source-inline">Configure</strong> function. To fix it, replace the initialization of the <strong class="source-inline">client.wifi</strong> object with the following snippet:</p>
			<p class="source-code">wifiDevice := wifinina.NewSPI(</p>
			<p class="source-code">   client.spi,</p>
			<p class="source-code">   machine.NINA_CS,</p>
			<p class="source-code">   machine.NINA_ACK,</p>
			<p class="source-code">   machine.NINA_GPIO0,</p>
			<p class="source-code">   machine.NINA_RESETN,</p>
			<p class="source-code">)</p>
			<p class="source-code">client.wifi = wifiDevice</p>
			<p>To implement the program, follow these steps:</p>
			<ol>
				<li value="1">Define constants for <strong class="source-inline">ssid</strong> and <strong class="source-inline">password</strong>, as shown in the following code snippet. You must insert your own credentials here:<p class="source-code">const ssid = "<strong class="bold">changeMe</strong>"</p><p class="source-code">const password = "<strong class="bold">changeMe</strong>"</p></li>
				<li>Define variables for <strong class="source-inline">temperature</strong>, <strong class="source-inline">pressure</strong>, and <strong class="source-inline">humidity</strong>, as shown in the following code snippet. These will be accessed by multiple goroutines:<p class="source-code">var (</p><p class="source-code">    temperature float64</p><p class="source-code">    pressure float64</p><p class="source-code">    humidity float64</p><p class="source-code">)</p></li>
				<li>When <a id="_idIndexMarker464"/>watching streams from Ron Evans (who is one of the TinyGo maintainers), I learned a helpful trick. If an error occurs when doing really important things, we want to be able to find the error message in the serial output. In such a case, we pause the program execution and repeatedly print the message, as follows:<p class="source-code">func printError(message string, err error) {</p><p class="source-code">    for {</p><p class="source-code">        println(message, err.Error())</p><p class="source-code">        time.Sleep(time.Second)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, inside the <strong class="source-inline">main</strong> function, we start by sleeping a brief moment so that we have enough time to open up PuTTY to monitor the serial output while we initialize the sensor and weather station, as follows:<p class="source-code">time.Sleep(5 * time.Second)</p></li>
				<li>Initialize <strong class="source-inline">weatherStation</strong>, as follows:<p class="source-code">machine.I2C0.Configure(machine.I2CConfig{})</p><p class="source-code">sensor := bme280.New(machine.I2C0)</p><p class="source-code">sensor.Configure()</p><p class="source-code">weatherStation := weatherstation.New(&amp;sensor, nil)</p><p class="source-code">weatherStation.CheckSensorConnectivity()</p></li>
				<li>Create a <a id="_idIndexMarker465"/>new <strong class="source-inline">wifi</strong> client, as follows:<p class="source-code">wifiClient := wifi.New(ssid, password)</p></li>
				<li>Configure the <strong class="source-inline">wifi</strong> client, as follows:<p class="source-code">println("configuring nina wifi chip")</p><p class="source-code">err := wifiClient.Configure()</p><p class="source-code">if err != nil {</p><p class="source-code">    printError("could not configure wifi client", err)</p><p class="source-code">}</p></li>
				<li>Now, we call the <strong class="source-inline">CheckHardware</strong> function, which will output the firmware version and <strong class="source-inline">ssids</strong> that have been found when scanning for networks. If that works, we can be sure that the microcontroller is able to communicate with the NINA chip. The code is shown in the following snippet:<p class="source-code">println("checking firmware")</p><p class="source-code">err = wifiClient.CheckHardware()</p><p class="source-code">if err != nil {</p><p class="source-code">    printError("could not check hardware", err)</p><p class="source-code">}</p></li>
				<li>Try to connect to the network, as follows:<p class="source-code">wifiClient.ConnectWifi()</p><p>Create a new <strong class="source-inline">mqttClient</strong> instance. Please note that you have to change the IP address to the address of the host where your MQTT broker is running. <em class="italic">Do not omit the</em> <strong class="source-inline">tcp://</strong> <em class="italic">part</em>, as it is being used by the driver implementation to estimate which kind of connection needs to be established. The code is shown in the following snippet:</p><p class="source-code">mqttClient := mqttclient.New("tcp://192.0.2.22:1883")</p></li>
				<li>Try to<a id="_idIndexMarker466"/> connect to the MQTT broker, as follows:<p class="source-code">println("connecting to mqtt broker")</p><p class="source-code">err = mqttClient.ConnectBroker()</p><p class="source-code">if err != nil {</p><p class="source-code">    printError("could not configure mqtt", err)</p><p class="source-code">}</p><p class="source-code">println("connected to mqtt broker")</p></li>
				<li>Start a goroutine that publishes sensor data, as follows:<p class="source-code">go publishSensorData(</p><p class="source-code">    mqttClient, wifiClient, weatherStation)</p></li>
				<li>Start a goroutine that publishes weather alerts, as follows:<p class="source-code">go publishAlert(</p><p class="source-code">    mqttClient, wifiClient, weatherStation)</p></li>
				<li>Read new sensor values once a minute, as follows:<p class="source-code">for {</p><p class="source-code">    temperature, pressure, humidity, err </p><p class="source-code">        = weatherStation.ReadData()</p><p class="source-code">        if err != nil {</p><p class="source-code">        printError("could not read sensor data:", err)</p><p class="source-code">}</p><p class="source-code">time.Sleep(time.Minute)</p><p class="source-code">}</p></li>
				<li>Now, add the <strong class="source-inline">publishSensorData</strong> function. For testing purposes it runs once per <a id="_idIndexMarker467"/>minute, but you can customize it depending on your needs. The code is shown in the following snippet:<p class="source-code">func publishSensorData(mqttClient mqttclient.Client,</p><p class="source-code">    wifiClient wifi.Client, weatherStation</p><p class="source-code">    weatherstation.Service) {</p><p class="source-code">    for {</p><p class="source-code">        time.Sleep(time.Minute)</p><p class="source-code">        println("publishing sensor data")</p><p class="source-code">        tempString, pressString,</p><p class="source-code">        humidityString:=weatherStation.</p><p class="source-code">        GetFormattedReadings(temperature, pressure,</p><p class="source-code">        humidity)</p></li>
				<li>As most encoding packages are currently not supported by TinyGo, we use a <strong class="bold">character-separated string</strong> to serialize the data, as this will be easy to deserialize on <a id="_idIndexMarker468"/>the subscriber side. The code is shown in the following snippet:<p class="source-code">message := []byte(fmt.Sprintf("sensor</p><p class="source-code">    readings#%s#%s#%s", tempString, pressString,</p><p class="source-code">        humidityString))</p><p>Sometimes, we lose the connection to Wi-Fi or to the MQTT broker. In that case, we just try to<a id="_idIndexMarker469"/> establish a new connection, as follows:</p><p class="source-code">err := mqttClient.PublishMessage("weather/data", </p><p class="source-code">message, 0, true)</p><p class="source-code">if err != nil {</p><p class="source-code">    switch err.(type) {</p><p class="source-code">    println(err.Error())</p><p class="source-code">    case wifinina.Error:</p><p class="source-code">        wifiClient.ConnectWifi()</p><p class="source-code">        mqttClient.ConnectBroker()</p><p class="source-code">    default:</p><p class="source-code">        println(err.Error())</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>We now add the <strong class="source-inline">publishAlert</strong> function, which runs once an hour, as follows:<p class="source-code">func publishAlert(mqttClient mqttclient.Client,</p><p class="source-code">    wifiClient wifi.Client, weatherStation</p><p class="source-code">    weatherstation.Service) {</p><p class="source-code">        for {</p><p class="source-code">            time.Sleep(time.Hour)</p></li>
				<li>We save the pressure reading on an hourly basis, as follows:<p class="source-code">weatherStation.SavePressureReading(pressure)</p></li>
				<li>Now, we check for whether we have to send an alert. We use <strong class="source-inline">2</strong> as the value for the alert threshold, for the hourly check. We will talk about these values in more detail after finishing the implementation of the function. The code is shown in the following snippet:<p class="source-code">alert, diff := weatherStation.CheckAlert(2, 1)</p></li>
				<li>If we have<a id="_idIndexMarker470"/> an <strong class="source-inline">alert</strong>, we publish it by running the following code:<p class="source-code">if alert {</p><p class="source-code">    err := mqttClient.PublishMessage("weather/alert",</p><p class="source-code">        []byte(fmt.Sprintf("%s#%v#%s", "possible storm</p><p class="source-code">        incoming", diff, "1 hour")), 0, true)</p><p class="source-code">    if err != nil {</p><p class="source-code">        switch err.(type) {</p><p class="source-code">        case wifinina.Error:</p><p class="source-code">            println(err.Error())</p><p class="source-code">            wifiClient.ConnectWifi()</p><p class="source-code">            mqttClient.ConnectBroker()</p><p class="source-code">        default:</p><p class="source-code">            println(err.Error())</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, we check for an <strong class="source-inline">alert</strong> on a 3-hour schedule, as follows:<p class="source-code">alert, diff = weatherStation.CheckAlert(6, 3)</p><p>If we do not have an <strong class="source-inline">alert</strong>, we continue by running the following code:</p><p class="source-code">if !alert {</p><p class="source-code">    continue</p><p class="source-code">}</p></li>
				<li>Publish the<a id="_idIndexMarker471"/> alert (if we have one) on a 3-hour schedule, as follows:<p class="source-code">err := mqttClient.PublishMessage("weather/alert",</p><p class="source-code">    []byte(fmt.Sprintf("%s#%v#%s", "possible storm</p><p class="source-code">    incoming", diff, "3 hours")), 0, true)</p><p class="source-code">if err != nil {</p><p class="source-code">    println(err.Error())</p><p class="source-code">    switch err.(type) {</p><p class="source-code">        case wifinina.Error:</p><p class="source-code">            wifiClient.ConnectWifi()</p><p class="source-code">            mqttClient.ConnectBroker()</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>That's everything we need for our first IoT project. We have now developed a client that reads data from a sensor and publishes it to an MQTT broker. The client also checks the data for possible incoming storms and publishes these warnings as messages on a different topic. Before we try out the program, let's briefly talk about the thresholds and timespans we used as parameters in the alerts.</p>
			<p class="callout-heading">Very important note</p>
			<p class="callout">I am by no means a meteorologist. <em class="italic">This program is not able to predict every possible incoming storm</em>. The data I used as example values is not tested as I experienced no incoming storms when writing this book. Also, this information is based on articles I read online and might only work quite well in the place I'm living, so you might need to do your own research about the coherence of pressure changes and incoming bad weather. If this program did not predict an incoming storm but you feel one could be<a id="_idIndexMarker472"/> incoming, please check your local news and weather sources for that information. <em class="italic">So, again, if you live in an area that is frequently being hit by dangerous storms, please do not blindly trust this program.</em> Meteorology is way more complicated than this program and we do only check for incoming storms based on sudden drops in pressure. There are more indicators for incoming storms, so please consider this program a prototype.</p>
			<p>The source of my threshold values is the following web page:</p>
			<p><a href="http://www.bohlken.net/airpressure2.htm">http://www.bohlken.net/airpressure2.htm</a></p>
			<p>This states that a pressure drop of <strong class="bold">&gt;=2hPa</strong> during a 1-hour period could indicate a possible incoming storm. It also states that a pressure drop of <strong class="bold">&gt;=6hPa</strong> during a 3-hour period could indicate a possible incoming storm.  </p>
			<p>If you are interested in MQTT best practices, check out the following link: </p>
			<p><a href="https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/">https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/</a></p>
			<p>We can now go on and finally flash the program onto the microcontroller by using the following command:</p>
			<p class="source-code">tinygo flash --target=arduino-nano33 ch7/weather-station-mqtt/main.go</p>
			<p>We have now flashed the program and everything seems to be running fine, but how do we know that the messages are really being successfully published? We can use an MQTT <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) client in such cases. I do recommend <strong class="bold">MQTT Explorer</strong> for<a id="_idIndexMarker473"/> this. You can download the program for every platform<a id="_idIndexMarker474"/> here: </p>
			<p><a href="https://mqtt-explorer.com/">https://mqtt-explorer.com/</a></p>
			<p>After starting the program, you only need to insert the <strong class="source-inline">hostname</strong> and <strong class="source-inline">port</strong> values. Just use <strong class="source-inline">localhost</strong> and port <strong class="source-inline">1883</strong> as parameters, then save your connection. The connection window <a id="_idIndexMarker475"/>should now look similar to this: </p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="Images/Figure_7.11_B16555.jpg" alt="Figure 7.11 – MQTT Explorer connection window&#13;&#10;" width="1036" height="769"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – MQTT Explorer connection window</p>
			<p>When the program is running on the microcontroller, you should be able to see the topics and messages that are being published to the broker. This will look similar to the following output:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="Images/Figure_7.12_B16555.jpg" alt="Figure 7.12 – MQTT Explorer published message&#13;&#10;" width="1036" height="769"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – MQTT Explorer published message</p>
			<p>We have learned <a id="_idIndexMarker476"/>how to implement a weather station that is able to publish messages to different topics to an MQTT broker. We have also learned how to set up Mosquitto using Docker, and we have learned how to use MQTT Explorer to check if our messages really are being published. The next step is to create a Wasm app that displays these messages.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor144"/>Introducing Wasm</h1>
			<p>Let's find out what <a id="_idIndexMarker477"/>Wasm is. The <em class="italic">WebAssembly</em> home page states the following: </p>
			<p class="author-quote">"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications."</p>
			<p>Source: <a href="https://webassembly.org/">https://webassembly.org/</a></p>
			<p>In other <a id="_idIndexMarker478"/>words, we can write code in any language and compile it to the Wasm binary format, which can then be executed by the browser. That makes Wasm extremely valuable, as we can create client applications using languages other than JavaScript.</p>
			<p>A great advantage of Wasm compared to JavaScript is that it aims to execute at native speed, and as it runs in a sandboxed environment inside the browser it can be considered as relatively safe. Luckily, TinyGo does support Wasm as a compilation target, so we can make use of the incredibly small binary sizes that TinyGo produces, which will significantly<a id="_idIndexMarker479"/> speed up page loading times compared to other technologies.</p>
			<p>Here is a list to summarize the preceding information: </p>
			<ul>
				<li><strong class="bold">Wasm is a new language</strong> that <a id="_idIndexMarker480"/>officially became <a id="_idIndexMarker481"/>the fourth language of the web, after <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>), <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>), and JavaScript. Source: <a href="https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en">https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en</a></li>
				<li><strong class="bold">Wasm is a binary format</strong>. It does not aim to be human-readable.</li>
				<li><strong class="bold">Wasm is so low-level</strong> that it brings performance improvements compared to high-level languages such as JavaScript.</li>
				<li>Go code can be compiled in the Wasm binary format.</li>
			</ul>
			<p>As we now have a brief basic understanding of what Wasm theoretically is, let's just use it to get a better understanding.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor145"/>Displaying sensor data and weather alerts on a Wasm page</h1>
			<p>Our goal is to <a id="_idIndexMarker482"/>develop a small application that displays<a id="_idIndexMarker483"/> weather alerts and our sensor data that is being published to an MQTT broker, so we will need some very basic HTML and JavaScript skills in order to achieve this. We start by developing a small server that serves the Wasm app to a client. </p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor146"/>Serving the application</h2>
			<p>As Wasm is<a id="_idIndexMarker484"/> served to a browser, we need an HTTP endpoint that serves all files we might need. We start by creating a new folder named <strong class="source-inline">wasm-server</strong> inside the <strong class="source-inline">Chapter07</strong> folder, and inside this folder we create a new <strong class="source-inline">main.go</strong> file with an empty <strong class="source-inline">main</strong> function. Now, follow these steps to implement the server:</p>
			<ol>
				<li value="1">Define the directory where the <strong class="source-inline">FileServer</strong> should look for files, as follows:<p class="source-code">const dir = "Chapter07/html"</p></li>
				<li>Now, inside the <strong class="source-inline">main</strong> function, create a new <strong class="source-inline">FileServer</strong> and pass the directory as a parameter, as follows:<p class="source-code">fs := http.FileServer(http.Dir(dir))</p></li>
				<li>Start an HTTP server that listens on port <strong class="source-inline">8080</strong>, as follows:<p class="source-code">err := http.ListenAndServe(":8080",</p><p class="source-code">       http.HandlerFunc(func(resp http.ResponseWriter, </p><p class="source-code">       req *http.Request) {</p></li>
				<li>Tell the browser not to cache the files. <em class="italic">We only use this for our development environment</em> to ensure that we never get a cached version of the app. On production, you would not want to deactivate the cache. The code is shown in the following snippet:<p class="source-code">resp.Header().Add("Cache-Control", "no-cache")</p></li>
				<li>We need to set the proper <strong class="source-inline">content-type</strong> header for different file types, as follows:<p class="source-code">if strings.HasSuffix(req.URL.Path, ".wasm") {</p><p class="source-code">    resp.Header(). Set("content-type",</p><p class="source-code">        "application/wasm")</p><p class="source-code">}</p></li>
				<li>Now, finally, just let the file server serve the files, as follows:<p class="source-code">fs.ServeHTTP(resp, req)</p><p class="source-code">}))</p><p class="source-code">if err != nil {</p><p class="source-code">    println("failed to server http requests:",</p><p class="source-code">        err.Error())</p><p class="source-code">}</p></li>
			</ol>
			<p>This is <a id="_idIndexMarker485"/>everything we need to prepare our server. The server is now able to serve all files from inside the <strong class="source-inline">html</strong> directory, which we are going to create later. Note that this example server is nearly exactly the same as the example server from the TinyGo repository.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Implementing the weather app</h2>
			<p>Let's now <a id="_idIndexMarker486"/>create the actual app. The app is going to consist of three parts, as follows: </p>
			<ol>
				<li value="1">An HTML file, which is going to hold the page content.</li>
				<li>A <strong class="source-inline">wasm.js</strong> file, which is going to execute the Go code and also hold some other helper functions.</li>
				<li>A <strong class="source-inline">wasm_exec.js</strong> file, which can be considered as glue code, as it maps Go functions to JavaScript functions. This file is going to be provided by TinyGo itself.</li>
			</ol>
			<p>Let's start to create our HTML file. To do so, create a new folder named <strong class="source-inline">weather-app</strong> inside the <strong class="source-inline">Chapter07</strong> folder and create a new file named <strong class="source-inline">index.html</strong> inside this new folder. Now, follow these steps inside the HTML file:</p>
			<ol>
				<li value="1">Declare metadata such as <strong class="source-inline">charset</strong>, <strong class="source-inline">title</strong>, and <strong class="source-inline">viewport</strong> in the head, as follows:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset="utf-8" /&gt;</p><p class="source-code">    &lt;title&gt;TinyGo Weather Station&lt;/title&gt;</p><p class="source-code">    &lt;meta name="viewport" content="width=device-width,</p><p class="source-code">    initial-scale=1" /&gt;</p></li>
				<li>Import <a id="_idIndexMarker487"/>the <strong class="source-inline">paho mqtt</strong> library. We are going into more detail on this one as soon as we use it. The code is shown in the following snippet:<p class="source-code">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"&gt;&lt;/script&gt;</p></li>
				<li>Import the <strong class="source-inline">wasm_exec.js</strong> and <strong class="source-inline">wasm.js</strong> files. These files are being provided by our server. The code is shown in the following snippet:<p class="source-code">&lt;script src="wasm_exec.js"</p><p class="source-code">    type="text/javascript"&gt;&lt;/script&gt;</p><p class="source-code">&lt;script src="wasm.js" type="text/javascript"&gt;&lt;/script&gt;</p><p class="source-code">&lt;/head&gt;</p></li>
				<li>Now, in the body, we want to tell the user what the app is about and display our data, as follows:<p class="source-code">&lt;body&gt;</p><p class="source-code">    &lt;h1&gt;TinyGo Weather Station&lt;/h1&gt;</p><p class="source-code">    &lt;p&gt;Alerts:&lt;/p&gt;</p></li>
				<li>Define a table with four columns that are going to be dynamically filled with our weather alerts. The <strong class="source-inline">tbody</strong> column gets an <strong class="source-inline">id</strong> attribute so that we are able to identify<a id="_idIndexMarker488"/> that element. The code is shown in the following snippet:<p class="source-code">&lt;table&gt;</p><p class="source-code">    &lt;thead&gt;</p><p class="source-code">        &lt;tr&gt;</p><p class="source-code">            &lt;th&gt;TimeStamp&lt;/th&gt;</p><p class="source-code">            &lt;th&gt;Message&lt;/th&gt;</p><p class="source-code">            &lt;th&gt;Pressure Difference&lt;/th&gt;</p><p class="source-code">            &lt;th&gt;Time span&lt;/th&gt;</p><p class="source-code">        &lt;/tr&gt;</p><p class="source-code">    &lt;/thead&gt;</p><p class="source-code">    &lt;tbody id="tbody-alerts"&gt;&lt;/tbody&gt;</p><p class="source-code">&lt;/table&gt;</p></li>
				<li>Define a table with five columns that are going to be filled with our sensor data. The <strong class="source-inline">tbody</strong> column again gets an <strong class="source-inline">id</strong>. The code is shown in the following snippet:<p class="source-code">&lt;p&gt;Events:&lt;/p&gt;</p><p class="source-code">&lt;table&gt;</p><p class="source-code">    &lt;thead&gt;</p><p class="source-code">        &lt;tr&gt;</p><p class="source-code">            &lt;th&gt;TimeStamp&lt;/th&gt;</p><p class="source-code">            &lt;th&gt;Message&lt;/th&gt;</p><p class="source-code">            &lt;th&gt;Temperature&lt;/th&gt;</p><p class="source-code">            &lt;th&gt;Pressure&lt;/th&gt;</p><p class="source-code">            &lt;th&gt;Humidity&lt;/th&gt;</p><p class="source-code">        &lt;/tr&gt;</p><p class="source-code">    &lt;/thead&gt;</p><p class="source-code">    &lt;tbody id="tbody-data"&gt;&lt;/tbody&gt;</p><p class="source-code">&lt;/table&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
			</ol>
			<p>This is everything <a id="_idIndexMarker489"/>we need to display our data. I did not include any CSS, to keep the example as easy to understand and short as possible. You can, of course, also include inline CSS or reference a CSS file that could also be served from the <strong class="source-inline">html</strong> directory.</p>
			<p class="callout-heading">Reading more</p>
			<p class="callout">If you want to learn how to create beautiful web apps using HTML5 and CSS, I recommend the book <em class="italic">Responsive Web Design with HTML5 and CSS</em> by the awesome author Ben Frain. You can find it at the following link:</p>
			<p class="callout"><a href="https://www.packtpub.com/product/responsive-web-design-with-html5-and-css-third-edition/9781839211560">https://www.packtpub.com/product/responsive-web-design-with-html5-and-css-third-edition/9781839211560</a></p>
			<p>The next step is to implement the actual client logic. We start by creating a new file inside the <strong class="source-inline">weather-app</strong> directory and naming it <strong class="source-inline">wasm.go</strong>, and also create an empty <strong class="source-inline">main</strong> function inside the newly created file. Now, follow these steps:</p>
			<ol>
				<li value="1">Define a struct for our sensor events, as follows:<p class="source-code">type sensorEvent struct {</p><p class="source-code">    TimeStamp string</p><p class="source-code">    Message string</p><p class="source-code">    Temperature float32</p><p class="source-code">    Pressure float32</p><p class="source-code">    Humidity float32</p><p class="source-code">}</p></li>
				<li>Define a struct for our alert events, as follows:<p class="source-code">type alertEvent struct {</p><p class="source-code">    TimeStamp string</p><p class="source-code">    Message string</p><p class="source-code">    Diff string</p><p class="source-code">    TimeSpan string</p><p class="source-code">}</p></li>
				<li>Create a<a id="_idIndexMarker490"/> channel that is going to be used to handle the sensor events, as follows:<p class="source-code">var sensorEvents = make(chan sensorEvent)</p></li>
				<li>Create a channel that is going to be used to handle the alert events, as follows:<p class="source-code">var alertEvents = make(chan alertEvent)</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, we export the <strong class="source-inline">sensorDataHandler</strong> function as <strong class="source-inline">sensorDataHandler</strong> to the JavaScript environment. This way, we can call the <strong class="source-inline">go</strong> function from JavaScript. The code is shown in the following snippet:<p class="source-code">js.Global().Set("sensorDataHandler",</p><p class="source-code">    js.FuncOf(sensorDataHandler))</p></li>
				<li>We also export the <strong class="source-inline">alertHandler</strong> function, as follows:<p class="source-code">js.Global().Set("alertHandler",</p><p class="source-code">    js.FuncOf(alertHandler))</p></li>
				<li>Start a goroutine that handles the sensor events, as follows:<p class="source-code">go handleSensorEvents()</p></li>
				<li>Start a goroutine that handles the alert events, as follows:<p class="source-code">go handleAlertEvents()</p></li>
				<li>Block the execution of the main goroutine so that the program does not just shut down <a id="_idIndexMarker491"/>after executing the <strong class="source-inline">main</strong> function, as follows:<p class="source-code">wait := make(chan struct{}, 0)</p><p class="source-code">&lt;-wait</p></li>
				<li>Add the <strong class="source-inline">alertHandler</strong> function. In order to be able to export the function using the <strong class="source-inline">js.Global().Set()</strong> call, the function must have a signature that accepts a <strong class="source-inline">js.Value</strong> and a <strong class="source-inline">[].js.Value</strong> and returns an <strong class="source-inline">interface{}</strong>, as illustrated in the following code snippet: <p class="source-code">func alertHandler(this js.Value, args []js.Value)</p><p class="source-code">    interface{} {</p></li>
				<li>When calling this function, we pass a single string as parameter. We will be able to find the string inside the first index of <strong class="source-inline">args</strong>. Afterward, we need to split the message using a hashtag as separator. The code is shown in the following snippet:<p class="source-code">message := args[0].String()</p><p class="source-code">splittedStrings := strings.Split(message, "#")</p></li>
				<li>Add the deserialized message to the channel. As we have not placed a timestamp onto the message when sending it, we now add the timestamp, as illustrated in the following code snippet:<p class="source-code">alertEvents &lt;- alertEvent{</p><p class="source-code">    TimeStamp: time.Now().Format(time.RFC1123),</p><p class="source-code">    Message: splittedStrings[0],</p><p class="source-code">    Diff: splittedStrings[1],</p><p class="source-code">    TimeSpan: splittedStrings[2],</p><p class="source-code">}</p></li>
				<li>Simply return <strong class="source-inline">nil</strong> as we do not need to write back any value to the JavaScript code that calls this function, as illustrated in the following code snippet:<p class="source-code">return nil</p><p class="source-code">}</p></li>
				<li>We now do<a id="_idIndexMarker492"/> the same procedure for the sensor data events, as follows:<p class="source-code">func sensorDataHandler(this js.Value, args []js.Value)</p><p class="source-code">    interface{} {</p><p class="source-code">message := args[0].String()</p><p class="source-code">splittedStrings := strings.Split(message, "#")</p><p class="source-code">sensorEvents &lt;- sensorEvent{</p><p class="source-code">    TimeStamp: time.Now().Format(time.RFC1123),</p><p class="source-code">    Message: splittedStrings[0],</p><p class="source-code">    Temperature: splittedStrings[1],</p><p class="source-code">    Pressure: splittedStrings[2],</p><p class="source-code">    Humidity: splittedStrings[3],</p><p class="source-code">}</p><p class="source-code">return nil</p><p class="source-code">}</p></li>
				<li>Add the <strong class="source-inline">handleAlertEvents()</strong> function. This function loops forever and reads an alert from the channel. The code is shown in the following snippet:<p class="source-code">func handleAlertEvents() {</p><p class="source-code">for {</p><p class="source-code">    event := &lt;-alertEvents</p></li>
				<li>As we have read an alert event, we need to find the <strong class="source-inline">tbody</strong> element in the <strong class="source-inline">html</strong> directory in order to add a new row. We make use of some helper functions that we are going to explain as soon as we implement them. The code is shown in the following snippet:<p class="source-code">    tableBody := dom.GetElementByID("tbody-alerts")</p></li>
				<li>Create a <a id="_idIndexMarker493"/>new table row, as follows:<p class="source-code">    tr := dom.CreateElement("tr")</p></li>
				<li>Add the column data, as follows:<p class="source-code">    dom.AddTd(tr, event.TimeStamp)</p><p class="source-code">    dom.AddTd(tr, event.Message)</p></li>
				<li>Add the formatted column data, as follows:<p class="source-code">    dom.AddTdf(tr, "%s hPa", event.Diff)</p><p class="source-code">    dom.AddTdf(tr, "%s", event.TimeSpan)</p></li>
				<li>Append a new <strong class="source-inline">tableRow</strong> to <strong class="source-inline">tbody</strong>, as follows:<p class="source-code">    dom.AppendChild(tableBody, tr)</p><p class="source-code">    println("successfully added sensor event to</p><p class="source-code">       table")</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">handleSensorEvents</strong> function works in a very similar way. We loop forever, read events from the <strong class="source-inline">sensorEvents</strong> channel, and add the data to the <strong class="source-inline">tbody</strong>. The <a id="_idIndexMarker494"/>code is shown in the following snippet:<p class="source-code">func handleSensorEvents() {</p><p class="source-code">for {</p><p class="source-code">    event := &lt;-sensorEvents</p><p class="source-code">    tableBody := dom.GetElementByID("tbody-data")</p><p class="source-code">    tr := dom.CreateElement("tr")</p><p class="source-code">    dom.AddTd(tr, event.TimeStamp)</p><p class="source-code">    dom.AddTd(tr, event.Message)</p><p class="source-code">    dom.AddTdf(tr, "%s°C", event.Temperature)</p><p class="source-code">    dom.AddTdf(tr, "%s hPa", event.Pressure)</p><p class="source-code">    dom.AddTdf(tr, "%s", event.Humidity)</p><p class="source-code">    dom.AppendChild(tableBody, tr)</p><p class="source-code">    println("successfully added sensor event to</p><p class="source-code">    table")</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>The only thing missing from our Go code is the <strong class="source-inline">dom</strong> helper function. So, create a new folder named <strong class="source-inline">dom</strong> inside the <strong class="source-inline">Chapter07</strong> folder, create a new <strong class="source-inline">dom.go</strong> file inside the folder, and name the package <strong class="source-inline">dom</strong>. Now, follow these steps to implement it:</p>
			<ol>
				<li value="1">Add a <strong class="source-inline">GetDocument</strong> function that wraps the get document call. You can also refer to the <strong class="source-inline">Getdocument</strong> as the HTML. The code is shown in the following snippet:<p class="source-code">func GetDocument() js.Value {</p><p class="source-code">    return js.Global().Get("document")</p><p class="source-code">}</p></li>
				<li>Add a wrapper for the <strong class="source-inline">createElement</strong> call. A created element is not directly visible. A newly created element needs to be added to the document before it is being rendered. The code is shown in the following snippet:<p class="source-code">func CreateElement(tag string) js.Value {</p><p class="source-code">    document := GetDocument()</p><p class="source-code">    return document.Call("createElement", tag)</p><p class="source-code">}</p></li>
				<li>Add a wrapper<a id="_idIndexMarker495"/> for the <strong class="source-inline">getElementById</strong> function. We used this function to get the <strong class="source-inline">tbody</strong> elements, using the <strong class="source-inline">id</strong> we defined in the <strong class="source-inline">html</strong> directory. The code is shown in the following snippet:<p class="source-code">func GetElementByID(id string) js.Value {</p><p class="source-code">    document := GetDocument()</p><p class="source-code">    return document.Call("getElementById", id)</p><p class="source-code">}</p></li>
				<li>Add a wrapper for <strong class="source-inline">appendChild</strong>. We used this function to add the <strong class="source-inline">tableRows</strong> into the <strong class="source-inline">tbody</strong> elements. This actually adds the elements to the <strong class="source-inline">html</strong> directory. The code is shown in the following snippet:<p class="source-code">func AppendChild(parent js.Value, child js.Value) {</p><p class="source-code">    parent.Call("appendChild", child)</p><p class="source-code">}</p></li>
				<li>Add a wrapper to set the <strong class="source-inline">innerHTML</strong> function. This function adds the given value between <strong class="source-inline">html</strong> tags. The code is shown in the following snippet:<p class="source-code">func SetInnerHTML(object js.Value, value interface{}) {</p><p class="source-code">    object.Set("innerHTML", value)</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">AddTd</strong> function creates a new <strong class="source-inline">td</strong> element, sets the <strong class="source-inline">innerHTML</strong> function, and appends the child to the given <strong class="source-inline">tr</strong> element, as illustrated in the following code snippet:<p class="source-code">func AddTd(tr js.Value, value interface{}) {</p><p class="source-code">    td := CreateElement("td")</p><p class="source-code">    SetInnerHTML(td, value)</p><p class="source-code">    AppendChild(tr, td)</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">AddTdf</strong> function<a id="_idIndexMarker496"/> does the same as the <strong class="source-inline">AddTd</strong> function, with the difference that the <strong class="source-inline">innerHTML</strong> function gets formatted. The code is shown in the following snippet:<p class="source-code">func AddTdf(tr js.Value, formatString string, value</p><p class="source-code">    interface{}) {</p><p class="source-code">    td := CreateElement("td")</p><p class="source-code">    SetInnerHTML(td, fmt.Sprintf(formatString, value))</p><p class="source-code">    AppendChild(tr, td)</p><p class="source-code">}</p></li>
			</ol>
			<p>We have now implemented all the helper functions that we used in the <strong class="source-inline">wasm.go</strong> file. The only thing missing, before we can build and test the app, is the <strong class="source-inline">wasm.js</strong> file. So, let's create a new file named <strong class="source-inline">wasm.js</strong> and follow these steps to implement the last part:</p>
			<ol>
				<li value="1">Declare that this file should be executed in strict mode. For more information on strict mode, check out the following site:<p><a href="https://www.w3schools.com/js/js_strict.asp">https://www.w3schools.com/js/js_strict.asp</a></p></li>
				<li>Define a <strong class="source-inline">const</strong> value for the <strong class="source-inline">wasm</strong> file. The binary we build will later be named <strong class="source-inline">wasm.wasm</strong>. We also add new variables to store the <strong class="source-inline">mqtt</strong> client and the <strong class="source-inline">wasm</strong> object, as illustrated in the following code snippet:<p class="source-code">const WASM_URL = 'wasm.wasm';</p><p class="source-code">var wasm;</p><p class="source-code">var mqtt;</p></li>
				<li>We are using a JavaScript implementation of an MQTT client as I was not able to find an MQTT<a id="_idIndexMarker497"/> client in Go that could be built with TinyGo for the Wasm target. <em class="italic">Replace the values for host with the IP address from your MQTT broker</em>. In the future, there will surely be several clients that can be used for TinyGo Wasm projects. The code is shown in the following snippet:<p class="source-code">const host = "192.2.0.23";</p><p class="source-code">const port = 9001;</p></li>
				<li>This function gets called when the MQTT client has successfully established a connection. When this has happened, we subscribe to the topics that are of interest to us. The code is shown in the following snippet:<p class="source-code">function onConnect() {</p><p class="source-code">    mqtt.subscribe("weather/data");</p><p class="source-code">    mqtt.subscribe("weather/alert");</p><p class="source-code">}</p></li>
				<li>If we lose the connection to the MQTT broker, we want to log an error to the console. This function gets handed in later as a callback for the <strong class="source-inline">connectionLost</strong> event. The code is shown in the following snippet:<p class="source-code">function onConnectionLost(responseObject) {</p><p class="source-code">    if (responseObject.errorCode !== 0) {</p><p class="source-code">        console.log("onConnectionLost:" +</p><p class="source-code">        responseObject.errorMessage);</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>When a new message arrives, we want to check what type of message we have and call the correct Go function. We determine the type of the message using the information we provide inside the message. The code is shown in the following <a id="_idIndexMarker498"/>snippet:<p class="source-code">function onMessageArrived(message) {</p><p class="source-code">    console.log("onMessageArrived:" +</p><p class="source-code">    message.payloadString);</p><p class="source-code">var payload = message.payloadString;</p><p class="source-code">if (payload.indexOf("possible storm incoming") !== -1)</p><p class="source-code">{</p><p class="source-code">    alertHandler(payload);</p><p class="source-code">} else {</p><p class="source-code">    sensorDataHandler(payload);</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>We now add the <strong class="source-inline">MQTTconnect</strong> function. This function simply creates a new <strong class="source-inline">mqttClient</strong> and adds callback functions for the <strong class="source-inline">connect</strong>, <strong class="source-inline">connectionLost</strong>, and <strong class="source-inline">messageArrived</strong> events. The code is shown in the following snippet:<p class="source-code">function MQTTconnect() {</p><p class="source-code">    var cname = "weather-consumer";</p><p class="source-code">    mqtt = new Paho.MQTT.Client(host, port, cname);</p><p class="source-code">    var options = {</p><p class="source-code">        timeout: 3,</p><p class="source-code">        onSuccess: onConnect,</p><p class="source-code">};</p><p class="source-code">    mqtt.onConnectionLost = onConnectionLost;</p><p class="source-code">    mqtt.onMessageArrived = onMessageArrived;</p><p class="source-code">    mqtt.connect(options);</p><p class="source-code">}</p></li>
				<li>Now, add<a id="_idIndexMarker499"/> the <strong class="source-inline">init</strong> function that is going to run our Go code, as follows:<p class="source-code">function init() {</p></li>
				<li>Create a new instance of go, as follows:<p class="source-code">const go = new Go();</p></li>
				<li>Check if the browser supports the <strong class="source-inline">instantiateStreaming</strong> function and, if so, load and run Wasm using this function, as follows:<p class="source-code">if ('instantiateStreaming' in WebAssembly) {</p><p class="source-code">WebAssembly.instantiateStreaming(fetch(WASM_URL),</p><p class="source-code">    go.importObject).then(function(obj) {</p><p class="source-code">        wasm = obj.instance;</p><p class="source-code">        go.run(wasm);</p><p class="source-code">})</p><p class="source-code">}</p></li>
				<li>If the browser does not support the <strong class="source-inline">instantiateStreaming</strong> function, we load and run Wasm using the <strong class="source-inline">instantiate</strong> function, as follows:<p class="source-code">else {</p><p class="source-code">    fetch(WASM_URL).then(resp =&gt;</p><p class="source-code">    resp.arrayBuffer()</p><p class="source-code">    ).then(bytes =&gt;</p><p class="source-code">        WebAssembly.instantiate(bytes,</p><p class="source-code">        go.importObject).then(function(obj) {</p><p class="source-code">        wasm = obj.instance;</p><p class="source-code">        go.run(wasm);</p><p class="source-code">})</p><p class="source-code">)</p></li>
				<li>After starting <a id="_idIndexMarker500"/>our <strong class="source-inline">go</strong> code, we can try to connect to the MQTT broker, as follows:<p class="source-code">MQTTconnect()</p><p class="source-code">}</p></li>
				<li>At the end of the file, add a call to the <strong class="source-inline">init()</strong> function, as follows:<p class="source-code">init();</p></li>
			</ol>
			<p>That was the complete code for our program. Now, we need to download the <strong class="source-inline">wasm_exec.js</strong> file and add it to the <strong class="source-inline">weather-app</strong> folder. Always use the <strong class="source-inline">wasm_exec.js</strong> version from your currently installed TinyGo version. You can simply download the file for the current TinyGo release here: </p>
			<p><a href="https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js">https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js</a></p>
			<p>In order to build and start the app, I normally use a <strong class="source-inline">Makefile</strong> function. The content of the <strong class="source-inline">Makefile</strong> looks like this:</p>
			<p class="source-code">wasm-app: </p>
			<p class="source-code">rm -rf Chapter07/html</p>
			<p class="source-code">mkdir Chapter07/html</p>
			<p class="source-code">tinygo build -o Chapter07/html/wasm.wasm -target wasm -no-debug     ch7/weather-app/wasm.go</p>
			<p class="source-code">cp Chapter07/weather-app/wasm_exec.js ch7/html/</p>
			<p class="source-code">cp Chapter07/weather-app/wasm.js ch7/html/</p>
			<p class="source-code">cp Chapter07/weather-app/index.html ch7/html/</p>
			<p class="source-code">go run Chapter07/wasm-server/main.go</p>
			<p>In order to build th<a id="_idIndexMarker501"/>e app and start the server, I only need to call that <strong class="source-inline">Makefile</strong> function by using the following command:</p>
			<p class="source-code">make wasm-app</p>
			<p>That works well on Linux and Mac systems, and could also work on Windows systems if GNU Make is installed. But let's go through the process step by step so that you can also build and run that app without using <strong class="source-inline">make</strong>, as follows:</p>
			<ol>
				<li value="1">Delete the existing <strong class="source-inline">html</strong> folder.</li>
				<li>Create a new html folder.</li>
				<li>Build the Wasm app using the Wasm target. Also, we omit debug information, which results in smaller binary sizes. </li>
				<li>Now, copy the <strong class="source-inline">wasm_exec.js</strong> file to the <strong class="source-inline">html</strong> folder.</li>
				<li>Copy the <strong class="source-inline">wasm.js</strong> file to the <strong class="source-inline">html</strong> folder.</li>
				<li>Copy the <strong class="source-inline">index.html</strong> file to the <strong class="source-inline">HTML</strong> folder.</li>
				<li>Run the server using the <strong class="source-inline">go run</strong> command.</li>
			</ol>
			<p>After using the <strong class="source-inline">make</strong> command or doing the steps manually, open your browser and visit the following URL: <strong class="source-inline">localhost:8080</strong>. You should now see a site that is similar to this:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="Images/Figure_7.13_B16555.jpg" alt="Figure 7.13 –TinyGo weather station with opened developer tools&#13;&#10;" width="1564" height="810"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 –TinyGo weather station with opened developer tools</p>
			<p>Excellent! We have <a id="_idIndexMarker502"/>successfully implemented a Wasm app that subscribes to topics on an MQTT broker and dynamically updates the content of a website.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Summary</h1>
			<p>In this chapter, we have learned how to use the Wi-Fi chip that is built onboard the Arduino Nano 33 IoT board. We then wrote reusable packages to use the Wi-Fi chip and the MQTT client, we discovered what MQTT is, and we learned how to publish messages to a topic. We have learned how to read sensor data from a BME280 sensor and publish this to an MQTT broker that we have set up locally. </p>
			<p>Then, we have learned what Wasm is and implemented our first application using Wasm. We have also learned how to use a JavaScript MQTT client in order to subscribe to an MQTT topic and react to messages. While doing so, we learned how to manipulate the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) in order to dynamically update the view.</p>
			<p>In the next chapter, we are going to learn how to try out a Wasm app by using a login view, and will also learn how to implement bidirectional communication over MQTT.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Questions</h1>
			<ol>
				<li value="1">What needs to be done to ensure that an MQTT message actually gets delivered?</li>
				<li>Can multiple clients subscribe to the same topic on an MQTT broker?</li>
			</ol>
		</div>
	</div></body></html>