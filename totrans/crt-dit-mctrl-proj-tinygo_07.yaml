- en: '*Chapter 7*: Displaying Weather Alerts on the TinyGo Wasm Dashboard'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：在TinyGo Wasm仪表板上显示天气警报'
- en: We have learned how to display data using different types of displays that are
    connected using either the **Inter-Integrated Circuit** (**I2C**) protocol or
    the **Serial Peripheral Interface** (**SPI**). While doing so, we dived a bit
    deeper into understanding how SPI works by learning that multiple devices can
    listen on a SPI bus and that we can daisy-chain devices on the bus. Furthermore,
    we have built a **command-line interface** (**CLI**) that interprets commands
    sent over serial and executes functions depending on the input.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用不同类型的显示器来显示数据，这些显示器通过**互集成电路**（**I2C**）协议或**串行外设接口**（**SPI**）连接。在这个过程中，我们深入了解了SPI的工作原理，通过学习得知多个设备可以监听SPI总线，并且我们可以在总线上级联设备。此外，我们还构建了一个**命令行界面**（**CLI**），它可以解释通过串行发送的命令，并根据输入执行相应的功能。
- en: After working through this chapter, you will be familiar with using **Message
    Queuing Telemetry Transport** (**MQTT**), serving a **WebAssembly** (**Wasm**)
    page through a web server, how to set up a local MQTT broker, and how to use the
    Wi-Fi functionalities of the Arduino Nano 33 IoT board.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，你将熟悉使用**消息队列遥测传输**（**MQTT**），通过Web服务器提供**WebAssembly**（**Wasm**）页面，如何设置本地MQTT代理，以及如何使用Arduino
    Nano 33 IoT板的Wi-Fi功能。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Building a weather station
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个气象站
- en: Sending MQTT messages to a broker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向代理发送MQTT消息
- en: Introducing Wasm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Wasm
- en: Displaying sensor data and weather alerts on a Wasm page
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Wasm页面上显示传感器数据和天气警报
- en: By the end of this chapter, you will know how to utilize an MQTT broker in order
    to send messages from your microcontroller over Wi-Fi. You will also know how
    to subscribe to MQTT messages inside a Wasm app and how to display data that is
    being sent as an MQTT message payload.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解如何利用MQTT代理从你的微控制器通过Wi-Fi发送消息。你还将了解如何在Wasm应用程序内部订阅MQTT消息，以及如何显示作为MQTT消息有效载荷发送的数据。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software needs to be installed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件需要安装：
- en: 'Docker—You can find an installation guide by following this link: [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker——你可以通过以下链接找到安装指南：[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
- en: 'We are going to need the following components for this project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下组件来完成这个项目：
- en: An Arduino Nano 33 IoT board
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Arduino Nano 33 IoT板
- en: An external power supply  (**5 volts** (**5V**))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个外部电源（**5伏**（**5V**））
- en: A BME280 sensor (I2C)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个BME280传感器（I2C）
- en: An ST7735 display
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个ST7735显示器
- en: A breadboard
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Jumper wires
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 'You can find the code for this chapter on GitHub at the following link: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到本章的代码：[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07)
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3dXGe4o](https://bit.ly/3dXGe4o)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在以下链接找到：[https://bit.ly/3dXGe4o](https://bit.ly/3dXGe4o)
- en: Building a weather station
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个气象站
- en: We start our journey through the world of **Internet of Things** (**IoT**) and
    Wasm by building a **weather station**. In our first project of this chapter,
    we are going to build a program that displays weather data on an **ST7735** display.
    We are going to build some reusable components that we are going to utilize in
    the final project of the chapter. We are going to learn how to use a **BME280**
    sensor that is able to sense air pressure, temperature, and humidity—the elements
    required for noting a change in the weather. But first, we need to assemble a
    circuit—so, let's see how that works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过构建一个**气象站**来开始我们的物联网（**IoT**）和Wasm世界的旅程。在本章的第一个项目中，我们将构建一个程序，在**ST7735**显示器上显示天气数据。我们将构建一些可重用的组件，这些组件将在本章的最终项目中使用。我们将学习如何使用能够感知空气压力、温度和湿度的**BME280**传感器——这些是记录天气变化所需的元素。但首先，我们需要组装一个电路——所以，让我们看看它是如何工作的。
- en: Assembling the circuit
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装电路
- en: 'Before we are able to read and display the sensor data, we need to assemble
    the circuit. We are connecting the BME/BMP280 sensor using the I2C interface,
    and we are going to connect the ST7735 display using the SPI interface. To do
    so, perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Place the **BME/BMP280** sensor with serial data pin (**SDA**) in *F21*.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *H21* (SDA) with pin *J56* (SDA) on the breadboard, using a jumper
    wire.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *I22* **Serial Clock** (**SCL**) with pin *I55* (SCL) on the breadboard,
    using a jumper wire.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J23* **Ground** (**GND**) with the *GND* lane on the power bus.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J24* (VIN) with the **Voltage Common Collector** (**VCC**) lane on
    the power bus.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the display with the **light-emitting diode** (**LED**) pin in pin *A31*
    on the breadboard.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E31* (LED) with pin *A53* (D2) on the breadboard, using a jumper wire.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E32* (SCK) with pin *A54* (D13) on the breadboard, using a jumper wire.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E33* (SDA) with pin *A62* (D11) on the breadboard, using a jumper wire.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E34* **Analog pin** (**AO**) with pin *A56* on the breadboard, using
    a jumper wire.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E35* (AO) with pin *A57* (D5) on the breadboard, using a jumper wire.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E36* (RESET) with pin *A58* (D6) on the breadboard, using a jumper
    wire.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E37* **chip select** (**CS**) with pin *A59* (D7) on the breadboard,
    using a jumper wire.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E37* (GND) with the *GND* lane on the power bus.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E38* (VCC) with the *VCC* lane on the power bus.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J51* (GND) with the *GND* lane on the power bus.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The circuit should now look similar to this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Weather-station circuit (image is taken from Fritzing)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B16555.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Weather-station circuit (image is taken from Fritzing)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: This is everything we need on assembling for the complete chapter. We can proceed
    to the next section and write the code that is able to *read the sensor data and
    display it* onto ST7735.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Programming the weather station
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to put the weather station logic, which consists of reading and
    interpreting sensor data, into a separate package so that we can use it in an
    example that only displays the data onto a display. When this is done, we are
    going to reuse this package to get the sensor data and calculate alerts to send
    it to an **MQTT broker**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by creating a new folder named `Chapter07` inside the project
    folder, and create a new folder named `weather-station` inside `Chapter07`. We
    then create a new file named `weather.go` and name the package `weatherstation`.
    The project structure should now look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Project structure for programming the weather station'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B16555.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Project structure for programming the weather station
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the logic, follow these steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Define colors that are later to be used when we draw something on the display,
    as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, define an interface and insert the following functions. We are going
    to explain each function in detail as soon as we implement it, in some later steps
    of this list:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个接口并插入以下函数。我们将在此列表的一些后续步骤中，一旦实现就详细解释每个函数：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then define `struct` that contains the sensor and the display, as well as
    some more fields that we are going to explain as soon as we use them. For the
    BME280 device, we are going to use a driver from the TinyGo `drivers` repository.
    You can import it using the following path: [tinygo.org/x/drivers/bme280](http://tinygo.org/x/drivers/bme280).
    The code is shown in the following snippet:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个`struct`，其中包含传感器和显示，以及一些我们将使用时解释的更多字段。对于BME280设备，我们将使用TinyGo `drivers`存储库中的驱动程序。您可以使用以下路径导入它：[tinygo.org/x/drivers/bme280](http://tinygo.org/x/drivers/bme280)。代码如下所示：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then add a new constructor function that sets the sensor and display and
    initializes all values, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个新的构造函数，用于设置传感器和显示，并初始化所有值，如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add the `ReadData` function, which is a convenience function that reads
    all sensor values and returns them. The code can be seen in the following snippet:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加`ReadData`函数，这是一个便利函数，它读取所有传感器值并返回它们。代码如下所示：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then add a function that blocks the execution of the program until connection
    to the BME280 sensor has been approved, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个函数，该函数将阻止程序执行，直到BME280传感器的连接得到批准，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now add a function that takes the sensor readings and displays them on the
    screen, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加一个函数，该函数接收传感器读取值并在屏幕上显示，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Fill the screen so that we have no artifacts from previous calls. If we were
    to skip this step, we would possibly draw images above it that had previously
    been drawn, which would look really messy. The code is shown in the following
    snippet:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充屏幕，以确保没有来自先前调用的残留物。如果我们跳过此步骤，我们可能会在上面绘制之前绘制的图像，这将显得非常混乱。代码如下所示：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Write a header using `tinyfont`, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tinyfont`编写标题，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Convert the readings to strings, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将读取值转换为字符串，如下所示：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build and display the temperature, pressure, and humidity strings, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并显示温度、压力和湿度字符串，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a function that converts the sensor readings to °C, **hectopascal** (**hPa**),  and
    relative humidity as percentage to the strings, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数，将传感器读取值转换为°C、**百帕斯卡**（**hPa**）和相对湿度百分比字符串，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have now finished implementing the logic to read and display the sensor data.
    The next step is calculating the weather alerts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了读取和显示传感器数据的逻辑实现。下一步是计算天气警报。
- en: Calculating weather alerts
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算天气警报
- en: 'In order to calculate alerts, we need to save some readings. We can do so by
    following these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算警报，我们需要保存一些读取值。我们可以通过以下步骤来实现：
- en: 'For the weather-alert calculation, we will only need pressure. That is why
    we hold an array of `float64` in the `service` struct, as can be seen in the following
    code snippet:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于天气警报的计算，我们只需要压力。这就是为什么我们在`service`结构体中保留一个`float64`数组，如下所示：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we have ever saved a value before, we fill the complete array with the same
    value. This prevents some edge cases later on when calculating alerts. The code
    is shown in the following snippet:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们之前保存过值，我们将用相同的值填充整个数组。这可以防止在计算警报时出现一些边缘情况。代码如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we have now inserted our first reading, we can set the `true` flag and `return`.
    This ensures that we only execute the preceding logic once. The code is shown
    in the following snippet:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经插入了第一个读取值，我们可以设置`true`标志并`return`。这确保我们只执行前面的逻辑一次。代码如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Store the reading into the current index. If our current index exceeds the
    maximum number of stored datasets, we reset the index; so, the next reading is
    going to overwrite the reading in index `0`. The code is shown in the following
    snippet:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将读取值存储到当前索引。如果当前索引超过存储数据集的最大数量，我们将重置索引；因此，下一次读取将覆盖索引`0`中的读取值。代码如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a function that uses the saved readings, calculates a difference between
    the two of them, and alerts if the difference exceeds the threshold. We are going
    to talk about thresholds and timespans later in this section when we call this
    function. The code is shown in the following snippet:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数，该函数使用保存的读取值，计算两者之间的差异，并在差异超过阈值时发出警报。我们将在本节稍后讨论阈值和时间段，当我们调用此函数时。代码如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Calculate the `comparisonIndex` value based on the `timeSpan` value, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据时间跨度值计算`comparisonIndex`值，如下所示：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Calculate the difference between the two values and raise an alert if the difference
    is greater than the threshold by returning `diff`, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算两个值之间的差异，如果差异大于阈值，则返回`diff`以发出警报，如下所示：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Okay—we just implemented an **application programming interface** (**API**)
    that lets us read, convert, and display sensor data, and along with it we can
    save sensor readings and calculate weather alerts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——我们刚刚实现了一个**应用程序编程接口**（**API**），它允许我们读取、转换和显示传感器数据，并且我们可以保存传感器读数并计算天气警报。
- en: 'Now, let''s try out whether the code is actually able to read and display sensor
    data. To do so, we first create a new folder named `weather-station-example` inside
    the `Chapter07` folder. We then create a new `main.go` file with an empty `main`
    function inside. The project structure should now look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一下代码是否真的能够读取并显示传感器数据。为此，我们首先在`Chapter07`文件夹内创建一个名为`weather-station-example`的新文件夹。然后，我们创建一个包含空`main`函数的新`main.go`文件。现在，项目结构应该看起来像这样：
- en: '![Figure 7.3 – Project structure for reading the code and displaying sensor
    data'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 读取代码和显示传感器数据的项目结构'
- en: '](img/Figure_7.3_B16555.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 读取代码和显示传感器数据的项目结构](img/Figure_7.3_B16555.jpg)'
- en: Figure 7.3 – Project structure for reading the code and displaying sensor data
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 读取代码和显示传感器数据的项目结构
- en: 'Now, follow these steps to implement the example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤实现示例：
- en: 'Inside the `main` function, we sleep for `5` seconds to get enough time to
    open PuTTY so that we are able to monitor the output on the serial port. The code
    is shown in the following snippet:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内部，我们休眠`5`秒，以便有足够的时间打开PuTTY，这样我们就能监控串行端口上的输出。代码如下所示：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initialize and configure the display, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化并配置显示屏，如下所示：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Initialize and configure the sensor. The sensor needs to be calibrated, which
    is done inside the `Configure` function. The code is shown in the following snippet:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化并配置传感器。传感器需要校准，这是在`Configure`函数中完成的。代码如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new instance of `weatherstation` and wait for sensor connectivity.
    The code is shown in the following snippet:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`weatherstation`的新实例并等待传感器连接。代码如下所示：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Read and display the data, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取并显示数据，如下所示：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That''s it for this example. Now, go on and flash the program, using the following
    command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子就到这里。现在，使用以下命令烧录程序：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After a brief moment, the display should now look similar to the one shown
    here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微过一会儿，显示屏现在应该看起来与下面所示类似：
- en: '![Figure 7.4 – Display output'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 显示输出'
- en: '](img/Figure_7.4_B16555.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 显示输出](img/Figure_7.4_B16555.jpg)'
- en: Figure 7.4 – Display output
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 显示输出
- en: We have now verified that we are able to read and display the sensor data. As
    we have now learned how to use the BMP280 sensor and have prepared a package that
    is able to calculate weather alerts, we can now go on to the next section, where
    we learn how to communicate with the Wi-Fi chip and how to send MQTT messages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经验证了我们能够读取并显示传感器数据。因为我们已经学会了如何使用BMP280传感器，并准备了一个能够计算天气警报的包，我们现在可以继续到下一节，学习如何与Wi-Fi芯片通信以及如何发送MQTT消息。
- en: Sending MQTT messages to a broker
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向代理发送MQTT消息
- en: Let's now start to dive into the world of IoT. As every device that has a connection
    to the internet—or at least to some network—can be considered an IoT device, the
    project in this section can be considered an IoT project. The Arduino Nano 33
    IoT has a `u-blox NINA-W102` chip on board that is capable of Wi-Fi communication.
    We can communicate with this chip using the SPI interface. As a driver for the
    NINA chip already exists, we don't have to implement one ourselves.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始深入探索物联网的世界。由于每个连接到互联网——或者至少连接到某些网络的设备——都可以被认为是物联网设备，本节中的项目可以被认为是物联网项目。Arduino
    Nano 33 IoT板上有一个`u-blox NINA-W102`芯片，它能够进行Wi-Fi通信。我们可以使用SPI接口与该芯片通信。由于已经存在NINA芯片的驱动程序，我们不需要自己实现。
- en: 'So, our plan is to send data through SPI to the NINA chip, which then sends
    the data through the network to an MQTT broker. The following diagram illustrates
    the process:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的计划是通过SPI将数据发送到NINA芯片，然后该芯片通过网络将数据发送到MQTT代理。以下图表说明了这个过程：
- en: '![Figure 7.5 – Communication diagram'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 通信图'
- en: '](img/Figure_7.5_B16555.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 读取代码和显示传感器数据的项目结构](img/Figure_7.5_B16555.jpg)'
- en: Figure 7.5 – Communication diagram
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 通信图
- en: Although the driver functionality is wrapped in a package, some boilerplate
    code is still needed to start using the Wi-Fi chip. So, let's wrap it inside a
    new package.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管驱动功能被封装在一个包中，但仍然需要一些样板代码来开始使用Wi-Fi芯片。因此，让我们将其封装在一个新的包中。
- en: Implementing the Wi-Fi package
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Wi-Fi包
- en: 'We are going to create an API that provides functionality to initialize the
    NINA chip, check the hardware and set up a connection. So, let''s start by creating
    a new folder named `wifi` inside the `Chapter07` folder and creating a new `wifi.go`
    file inside the newly created folder, and name the package `wifi`. The project
    structure should now look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个API，它提供初始化NINA芯片、检查硬件和设置连接的功能。因此，让我们首先在`Chapter07`文件夹内创建一个名为`wifi`的新文件夹，并在新创建的文件夹内创建一个名为`wifi.go`的新文件，并将包命名为`wifi`。项目结构现在应该如下所示：
- en: '![Figure 7.6 – Project structure'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 项目结构'
- en: '](img/Figure_7.6_B16555.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B16555.jpg)'
- en: Figure 7.6 – Project structure
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 项目结构
- en: 'Now, perform these steps to implement the logic:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤以实现逻辑：
- en: 'Define an interface for the package, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包的接口，如下所示：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a client that stores the credentials as well as the SPI bus and `wifinina.Device`,
    as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个客户端，它存储凭证以及SPI总线和`wifinina.Device`，如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a constructor function that sets the SPI bus and the credentials, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构造函数，用于设置SPI总线和凭证，如下所示：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the `Configure` function, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Configure`函数，如下所示：
- en: '[PRE28]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Configure the NINA SPI bus using the default pins, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认引脚配置NINA SPI总线，如下所示：
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a new instance of the `wifinina` driver and pass the SPI bus as well
    as the default pins, as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`wifinina`驱动实例，并传递SPI总线和默认引脚，如下所示：
- en: '[PRE30]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The chip needs a moment before it is ready to be used, which is why we sleep
    for a brief moment. The code is shown in the following snippet:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 芯片在准备好使用之前需要一点时间，这就是为什么我们要短暂休眠。代码如下所示：
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we add a function to check the hardware, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加一个检查硬件的函数，如下所示：
- en: '[PRE32]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First, we print the currently installed **firmware version**. This information
    can be important if you face any issues using the NINA chip. Also, you can use
    this information to check which features are supported by the firmware. The code
    is shown in the following snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们打印当前安装的**固件版本**。如果您在使用NINA芯片时遇到任何问题，此信息可能很重要。此外，您可以使用此信息来检查固件支持哪些功能。代码如下所示：
- en: '[PRE33]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we scan for available Wi-Fi networks and print all results. The internal
    buffer only stores up to 10 **service set identifiers** (**SSIDs**). If the scan
    for Wi-Fi networks runs without any errors, we can be sure that we are able to
    communicate with the chip. The code is shown in the following snippet:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们扫描可用的Wi-Fi网络并打印所有结果。内部缓冲区仅存储最多10个**服务集标识符**（**SSID**）。如果Wi-Fi网络的扫描没有错误，我们可以确信我们能够与芯片通信。代码如下所示：
- en: '[PRE34]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we implement a convenience function that establishes a connection to a
    network, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们实现一个便利函数，用于建立与网络的连接，如下所示：
- en: '[PRE35]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Sleep for a second, as it can take a while until the connection is established.
    The code is shown in the following snippet:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 休眠一秒钟，因为连接建立可能需要一段时间。代码如下所示：
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Get the connection status and print it, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取连接状态并打印，如下所示：
- en: '[PRE37]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the status equals `StatusConnected`, as shown in the following code snippet,
    we are successfully connected to the network:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果状态等于`StatusConnected`，如下面的代码片段所示，我们就成功连接到了网络：
- en: '[PRE38]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Sometimes, the connection cannot be established on the first attempt, which
    is why we just try it again, as illustrated in the following code snippet:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，第一次尝试无法建立连接，这就是为什么我们只是再次尝试，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After the connection has successfully been established, we print the **Internet
    Protocol** (**IP**) address that our device has been assigned by the **Dynamic
    Host Configuration Protocol** (**DHCP**), as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接成功建立后，我们打印出由**动态主机配置协议**（**DHCP**）分配给我们的设备的**互联网协议**（**IP**）地址，如下所示：
- en: '[PRE40]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can either only set the network (`ssid`) with no passphrase for open networks
    or we can set the network (`ssid`) and passphrase. Setting either of these options
    triggers a connection attempt. If no password has been set, we try to connect
    to an open network. If the password and `ssid` are set, we try to connect to a
    secured network, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以只设置网络（`ssid`），对于开放网络不设置密码，或者我们可以设置网络（`ssid`）和密码。设置这些选项中的任何一个都会触发连接尝试。如果没有设置密码，我们将尝试连接到一个开放网络。如果设置了密码和`ssid`，我们将尝试连接到一个受保护的网络，如下所示：
- en: '[PRE41]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's everything we need to implement our abstraction layer. We are going to
    test this package together with an MQTT client abstraction layer, which we are
    going to implement next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们实现抽象层所需的所有内容。我们将与MQTT客户端抽象层一起测试这个包，我们将在下一个步骤中实现这个抽象层。
- en: Implementing an MQTT client abstraction layer
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现MQTT客户端抽象层
- en: Just as with the Wi-Fi driver, the MQTT client needs some boilerplate code in
    order to get up and running. We are going to reduce the boilerplate code by adding
    an abstraction layer. That way, we only have the boilerplate code one time in
    a reusable component and do not have to write the same code repeatedly in every
    future project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Wi-Fi驱动程序一样，MQTT客户端需要一些样板代码才能启动运行。我们将通过添加一个抽象层来减少样板代码。这样，我们只需在一个可重用的组件中编写一次样板代码，就不必在未来的每个项目中重复编写相同的代码。
- en: 'We start by creating a new folder named `mqtt-client` inside the `Chapter07`
    folder, and create a new file named `client.go` and place it inside the `mqttclient`
    package. The project structure should now look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`Chapter07`文件夹内创建一个名为`mqtt-client`的新文件夹，并在`mqttclient`包内创建一个名为`client.go`的新文件。现在，项目结构应该看起来像这样：
- en: '![Figure 7.7 – Project structure'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 – 项目结构'
- en: '](img/Figure_7.7_B16555.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B16555.jpg)'
- en: Figure 7.7 – Project structure
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 项目结构
- en: Before we start to implement the code, we first need to understand what MQTT
    is and how it works.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们首先需要了解MQTT是什么以及它是如何工作的。
- en: Understanding MQTT
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解MQTT
- en: MQTT is a messaging protocol for the IoT. It is based on a **publisher/subscriber**
    architecture. A microcontroller that reads sensor data can **publish messages**
    to a so-called **topic** (such a microcontroller would be a thing in the IoT world).
    These messages are sent to a **broker**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是一种物联网的消息协议。它基于**发布/订阅**架构。一个读取传感器数据的微控制器可以向所谓的**主题**（在物联网世界中这样的微控制器就是一个“物”）**发布消息**。这些消息被发送到一个**代理**。
- en: 'The MQTT standard allows the usage of **Transport Layer Security** (**TLS**),
    as well as **Open Authorization** (**OAuth**) for authentication. It is also possible
    to not authenticate at all. The available authentication flows depend on the implementation
    and configuration of the used MQTT broker. Securing the broker by using authentication
    flows is important when sending sensitive data over the internet. The following
    diagram shows an example architecture of a single MQTT broker and multiple MQTT
    clients:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT标准允许使用**传输层安全性**（**TLS**），以及**开放授权**（**OAuth**）进行身份验证。也可以完全不进行身份验证。可用的身份验证流程取决于所使用的MQTT代理的实现和配置。当在互联网上发送敏感数据时，使用身份验证流程来保护代理非常重要。以下图显示了单个MQTT代理和多个MQTT客户端的示例架构：
- en: '![Figure 7.8 – MQTT architecture'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – MQTT架构'
- en: '](img/Figure_7.8_B16555.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B16555.jpg)'
- en: Figure 7.8 – MQTT architecture
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – MQTT架构
- en: In order to use MQTT, we need an active broker to which a client can publish
    messages. We also need one or many clients to be able to subscribe to messages
    from a certain topic.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用MQTT，我们需要一个活跃的代理，客户端可以向其发布消息。我们还需要一个或多个客户端，以便能够订阅来自特定主题的消息。
- en: 'The sequence diagram of a typical MQTT communication is straightforward and
    is based on a **command and command acknowledge** pattern. Let''s have a look
    at an example sequence, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 典型MQTT通信的序列图简单直接，基于**命令和命令确认**模式。让我们看看以下示例序列：
- en: The client connects to the broker.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端连接到代理。
- en: The broker acknowledges the connection.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理确认连接。
- en: 'Optional: The client subscribes to a topic.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选：客户端订阅一个主题。
- en: The broker acknowledges the subscription.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理确认订阅。
- en: 'Optional: The client publishes a message.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选：客户端发布一条消息。
- en: The broker acknowledges the published message.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理确认已发布的消息。
- en: 'This looks like the sequence shown in the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是以下图中所示的序列：
- en: '![Figure 7.9 – MQTT sequence diagram  (image was created using PlantUML)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 – MQTT序列图（图像使用PlantUML创建）'
- en: '](img/Figure_7.9_B16555.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.9_B16555.jpg)'
- en: Figure 7.9 – MQTT sequence diagram  (image was created using PlantUML)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – MQTT序列图（图像使用PlantUML创建）
- en: Summarizing this, here we mean a broker can serve many clients, a client can
    subscribe to one or many topics, and a client can publish a message in a topic.
    This should be enough base knowledge about MQTT.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这里我们指的是一个代理可以服务多个客户端，一个客户端可以订阅一个或多个主题，并且一个客户端可以在一个主题中发布消息。这应该就足够了，关于MQTT的基础知识。
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to gain a deeper knowledge about MQTT, you might want to have a
    look at the specification:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解MQTT，你可能想查看规范：
- en: '[https://mqtt.org/mqtt-specification/](https://mqtt.org/mqtt-specification/)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mqtt.org/mqtt-specification/](https://mqtt.org/mqtt-specification/)'
- en: 'Let''s now write the abstraction layer. As we have already prepared the project
    structure, we can start directly writing the code by following these steps inside
    the `client.go` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写抽象层。由于我们已经准备好了项目结构，我们可以在`client.go`文件中按照以下步骤直接开始编写代码：
- en: 'As our client is only going to publish messages, our API is going to be fairly
    simple. We need to be able to connect to a broker and we need to be able to publish
    messages. We now add `struct` that contains the `mqtt.Client` from the `drivers`
    repository, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的客户端只将发布消息，我们的API将相对简单。我们需要能够连接到代理，并且需要能够发布消息。现在我们添加`struct`，它包含来自`drivers`存储库的`mqtt.Client`，如下所示：
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To create a new `Client`, we only need to set the `mqttBroker` URL, as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的`Client`，我们只需要设置`mqttBroker` URL，如下所示：
- en: '[PRE43]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, add the `ConnectBroker` function, which is going to establish a connection
    to the broker. The code is shown in the following snippet:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`ConnectBroker`函数，该函数将建立与代理的连接。代码如下所示：
- en: '[PRE44]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We create new client options that will later be passed as arguments when creating
    a new client. These options take all the parameters needed to establish a connection.
    When using a broker that requires a password and username, these can also be set
    here. The code is shown in the following snippet:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建新的客户端选项，这些选项将在创建新客户端时作为参数传递。这些选项包含建立连接所需的所有参数。当使用需要密码和用户名的代理时，这些也可以在这里设置。代码如下所示：
- en: '[PRE45]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When testing programs using a local broker, we sometimes try to connect while
    the old client connection has not been discarded and we could run into problems
    connecting with the same `clientID` again, so using random strings helps a lot.
    The MQTT specification states that a `clientID` should be between 1 and 23 characters
    long, but brokers such as Mosquitto do not implement that. We will learn about
    the Mosquitto MQTT broker later in this section.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用本地代理测试程序时，我们有时会在旧客户端连接尚未丢弃的情况下尝试连接，这可能导致再次使用相同的`clientID`时遇到问题，因此使用随机字符串非常有帮助。MQTT规范指出，`clientID`的长度应在1到23个字符之间，但像Mosquitto这样的代理并没有实现这一点。我们将在本节后面学习关于Mosquitto
    MQTT代理的内容。
- en: ClientIDs must be unique—otherwise, clients would be kicked out by the broker.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端ID必须是唯一的——否则，客户端将被代理踢出。
- en: 'We are going to use a combination of the `clientID` we passed in and a random
    string of length `4`, as illustrated in the following code snippet:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们传入的`clientID`和一个长度为`4`的随机字符串的组合，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We now create a new client and pass `opts` as a parameter, and try to connect
    to the broker as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个新的客户端，并将`opts`作为参数传递，并尝试以下方式连接到代理：
- en: '[PRE47]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Although the current implementation of the token always return `true` when
    using the `wait` function, we still add it here in case it is implemented by the
    time you have worked through this chapter. We can use this function to wait for
    any command to get *acked* (acknowledged). Alternatively, we could use `token.WaitTimeout`,
    which internally times out when the given time span is over. The first option
    is shown in the following code snippet:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管当前实现中，使用`wait`函数时令牌总是返回`true`，但我们仍然在这里添加它，以防你在完成本章内容时它已经被实现。我们可以使用这个函数来等待任何命令被*确认*（即被认可）。或者，我们也可以使用`token.WaitTimeout`，当给定的时间跨度结束后，它会内部超时。以下代码片段展示了第一种选项：
- en: '[PRE48]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the `PublishMessage` function. `qos` (the `0`, `1`, or `2`. After we have
    completely implemented this package, we are going to have a deeper look at the
    `qos` levels. The `retain` flag tells the broker to store the last message having
    a `retain` flag. When a new client subscribes to the broker, the retained message
    will directly get delivered. The code is shown in the following snippet:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`PublishMessage`函数。`qos`（`0`、`1`或`2`）。在我们完全实现这个包之后，我们将更深入地了解`qos`级别。`retain`标志告诉代理存储带有`retain`标志的最后一条消息。当新客户端订阅代理时，保留消息将直接被投递。代码如下所示：
- en: '[PRE49]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The next step is to add a function that allows us to subscribe to a certain
    topic. The following code snippet illustrates this:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加一个允许我们订阅特定主题的功能。以下代码片段说明了这一点：
- en: '[PRE50]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, add a function to generate a random string containing a character between
    `A` and `Z`. The following functions are taken from the `mqtt` driver example:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个生成包含`A`到`Z`字符的随机字符串的功能。以下函数是从`mqtt`驱动程序示例中取出的：
- en: '[PRE51]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That's it for our abstraction layer. Before we go on to write the actual weather-station
    program, let's have a look at the QOS levels.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的抽象层就到这里。在我们继续编写实际的气象站程序之前，让我们看看QOS级别。
- en: 'MQTT provides three QOS levels, which work as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT提供了三个QOS级别，其工作方式如下：
- en: '**QOS 0**: *A message is delivered once*. The message is not stored by the
    sender and is not acknowledged. So, the client will only try to deliver it once,
    and if that fails, the message is discarded.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QOS 0**：*消息只投递一次*。消息不会被发送者存储，也不会被确认。因此，客户端只会尝试投递一次，如果失败，则消息将被丢弃。'
- en: '`duplicate` flag until it gets acknowledged by the broker. All of these messages
    will be sent to subscribed clients.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duplicate`标志直到它被代理确认。所有这些消息都将发送给订阅的客户端。'
- en: '`duplicate` flag until the message has been acknowledged. The difference is
    that the message will only be delivered to subscribers when the client sends a
    `PUBREL` (publish release) message.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duplicate`标志直到消息被确认。区别在于，只有当客户端发送`PUBREL`（发布释放）消息时，消息才会被投递给订阅者。'
- en: 'You can find more information about the underlying processes by following this
    link:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接了解有关底层过程的更多信息：
- en: '[https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)'
- en: As we now have a basic understanding of MQTT and have implemented our abstraction
    layer, it's time to put everything together in the next step and actually start
    to publish messages to a broker.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经对MQTT有了基本的了解并实现了我们的抽象层，现在是时候在下一步中将所有内容组合起来，并实际上开始向代理发送消息。
- en: Implementing the weather station
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现气象站
- en: We have prepared all the code that we need to implement the actual logic but
    we do not have an MQTT broker yet. So, let's set up a local MQTT broker that we
    can use for this program.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了实现实际逻辑所需的所有代码，但我们还没有MQTT代理。因此，让我们设置一个本地MQTT代理，我们可以用它来运行这个程序。
- en: Setting up an Eclipse Mosquitto MQTT broker
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Eclipse Mosquitto MQTT代理
- en: 'We are going to use the Eclipse Mosquitto MQTT broker. You can find more information
    regarding the broker here: [https://mosquitto.org/](https://mosquitto.org/).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Eclipse Mosquitto MQTT代理。有关代理的更多信息，请参阅[https://mosquitto.org/](https://mosquitto.org/)。
- en: 'If you do not want to set up a local MQTT broker or if you cannot use Docker
    right now, you can skip this and use the Mosquitto test system. *But please only
    use the Mosquitto test system for testing purposes; also, never publish any sensitive
    data to the test system as anyone could listen to the messages.* You can find
    the needed URLs and ports for the test system here: [http://test.mosquitto.org/](http://test.mosquitto.org/).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想设置本地MQTT代理或现在无法使用Docker，您可以跳过此步骤并使用Mosquitto测试系统。*但请仅将Mosquitto测试系统用于测试目的；此外，请不要向测试系统发布任何敏感数据，因为任何人都可以监听消息。*您可以在以下位置找到测试系统所需的URL和端口号：[http://test.mosquitto.org/](http://test.mosquitto.org/)。
- en: 'It is also possible to install a Mosquitto broker locally without using Docker,
    but that process won''t be covered in this book as using Docker is an easy and
    straightforward process, while setting up Mosquitto locally is more complicated.
    To set up Mosquitto using Docker, we need to create a configuration file. To do
    so, create a new folder named `mosquitto` inside the `Chapter07` folder and create
    a new folder named `config` inside the `mosquitto` folder. Now, create a new file
    and name it `mosquitto.conf`. The next step is to insert the following configuration:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have configured Mosquitto to use the user `mosquitto` and listen on all IP
    addresses of the host. We also listen for Websocket connections on the localhost
    using port `9001`, which we make use of in the Wasm app in the *Implementing the
    weather app* section later in this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The `allow_anonymous` flag allows unauthenticated clients to connect. For more
    information regarding the possible configuration options, consult the main manual
    page at [https://mosquitto.org/man/mosquitto-conf-5.html](https://mosquitto.org/man/mosquitto-conf-5.html).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we only need to start the container. It is important to map ports `1883`
    and `9001` so that we can actually reach these ports. Also, we need to *pass the
    path to our config file*. So, *replace the path that I used with the actual path
    to the config file on your system*, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we now have a running Mosquitto instance, we can now truly begin to implement
    our client logic.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new folder named `weather-station-mqtt` inside the
    `Chapter07` folder, then create a new `main.go` file with an empty `main` function
    inside. The project structure should now look like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Project structure for weather-station-mqtt'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B16555.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Project structure for weather-station-mqtt
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing these examples, I have faced some issues regarding the `wifinina`
    driver inside the TinyGo `drivers` repository. I am currently working on resolving
    these issues. So, if you face any problems connecting to your Wi-Fi network, use
    the two imports shown in the following code snippet instead of the official ones.
    You will also need to change these imports in the `wifi` and `mqtt-client` packages
    we developed earlier in this chapter:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Also, when using my fork of the `drivers` repository for the `wifinina` driver,
    the initialization of `wifi.Client` looks a little bit different. When using the
    driver, you will see that there is an error in the `Configure` function. To fix
    it, replace the initialization of the `client.wifi` object with the following
    snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To implement the program, follow these steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Define constants for `ssid` and `password`, as shown in the following code
    snippet. You must insert your own credentials here:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define variables for `temperature`, `pressure`, and `humidity`, as shown in
    the following code snippet. These will be accessed by multiple goroutines:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When watching streams from Ron Evans (who is one of the TinyGo maintainers),
    I learned a helpful trick. If an error occurs when doing really important things,
    we want to be able to find the error message in the serial output. In such a case,
    we pause the program execution and repeatedly print the message, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, inside the `main` function, we start by sleeping a brief moment so that
    we have enough time to open up PuTTY to monitor the serial output while we initialize
    the sensor and weather station, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Initialize `weatherStation`, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a new `wifi` client, as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Configure the `wifi` client, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we call the `CheckHardware` function, which will output the firmware version
    and `ssids` that have been found when scanning for networks. If that works, we
    can be sure that the microcontroller is able to communicate with the NINA chip.
    The code is shown in the following snippet:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Try to connect to the network, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a new `mqttClient` instance. Please note that you have to change the
    IP address to the address of the host where your MQTT broker is running. *Do not
    omit the* `tcp://` *part*, as it is being used by the driver implementation to
    estimate which kind of connection needs to be established. The code is shown in
    the following snippet:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Try to connect to the MQTT broker, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Start a goroutine that publishes sensor data, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Start a goroutine that publishes weather alerts, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Read new sensor values once a minute, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, add the `publishSensorData` function. For testing purposes it runs once
    per minute, but you can customize it depending on your needs. The code is shown
    in the following snippet:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As most encoding packages are currently not supported by TinyGo, we use a **character-separated
    string** to serialize the data, as this will be easy to deserialize on the subscriber
    side. The code is shown in the following snippet:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Sometimes, we lose the connection to Wi-Fi or to the MQTT broker. In that case,
    we just try to establish a new connection, as follows:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We now add the `publishAlert` function, which runs once an hour, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We save the pressure reading on an hourly basis, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we check for whether we have to send an alert. We use `2` as the value
    for the alert threshold, for the hourly check. We will talk about these values
    in more detail after finishing the implementation of the function. The code is
    shown in the following snippet:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If we have an `alert`, we publish it by running the following code:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we check for an `alert` on a 3-hour schedule, as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we do not have an `alert`, we continue by running the following code:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Publish the alert (if we have one) on a 3-hour schedule, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: That's everything we need for our first IoT project. We have now developed a
    client that reads data from a sensor and publishes it to an MQTT broker. The client
    also checks the data for possible incoming storms and publishes these warnings
    as messages on a different topic. Before we try out the program, let's briefly
    talk about the thresholds and timespans we used as parameters in the alerts.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Very important note
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: I am by no means a meteorologist. *This program is not able to predict every
    possible incoming storm*. The data I used as example values is not tested as I
    experienced no incoming storms when writing this book. Also, this information
    is based on articles I read online and might only work quite well in the place
    I'm living, so you might need to do your own research about the coherence of pressure
    changes and incoming bad weather. If this program did not predict an incoming
    storm but you feel one could be incoming, please check your local news and weather
    sources for that information. *So, again, if you live in an area that is frequently
    being hit by dangerous storms, please do not blindly trust this program.* Meteorology
    is way more complicated than this program and we do only check for incoming storms
    based on sudden drops in pressure. There are more indicators for incoming storms,
    so please consider this program a prototype.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'The source of my threshold values is the following web page:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.bohlken.net/airpressure2.htm](http://www.bohlken.net/airpressure2.htm)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: This states that a pressure drop of **>=2hPa** during a 1-hour period could
    indicate a possible incoming storm. It also states that a pressure drop of **>=6hPa**
    during a 3-hour period could indicate a possible incoming storm.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in MQTT best practices, check out the following link:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/](https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go on and finally flash the program onto the microcontroller by
    using the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We have now flashed the program and everything seems to be running fine, but
    how do we know that the messages are really being successfully published? We can
    use an MQTT **graphical user interface** (**GUI**) client in such cases. I do
    recommend **MQTT Explorer** for this. You can download the program for every platform
    here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mqtt-explorer.com/](https://mqtt-explorer.com/)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the program, you only need to insert the `hostname` and `port`
    values. Just use `localhost` and port `1883` as parameters, then save your connection.
    The connection window should now look similar to this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – MQTT Explorer connection window'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B16555.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – MQTT Explorer connection window
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program is running on the microcontroller, you should be able to see
    the topics and messages that are being published to the broker. This will look
    similar to the following output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – MQTT Explorer published message'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B16555.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – MQTT Explorer published message
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to implement a weather station that is able to publish messages
    to different topics to an MQTT broker. We have also learned how to set up Mosquitto
    using Docker, and we have learned how to use MQTT Explorer to check if our messages
    really are being published. The next step is to create a Wasm app that displays
    these messages.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Wasm
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s find out what Wasm is. The *WebAssembly* home page states the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
    virtual machine. Wasm is designed as a portable compilation target for programming
    languages, enabling deployment on the web for client and server applications."'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://webassembly.org/](https://webassembly.org/)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can write code in any language and compile it to the Wasm
    binary format, which can then be executed by the browser. That makes Wasm extremely
    valuable, as we can create client applications using languages other than JavaScript.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: A great advantage of Wasm compared to JavaScript is that it aims to execute
    at native speed, and as it runs in a sandboxed environment inside the browser
    it can be considered as relatively safe. Luckily, TinyGo does support Wasm as
    a compilation target, so we can make use of the incredibly small binary sizes
    that TinyGo produces, which will significantly speed up page loading times compared
    to other technologies.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list to summarize the preceding information:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**Wasm is a new language** that officially became the fourth language of the
    web, after **HyperText Markup Language** (**HTML**), **Cascading Style Sheets**
    (**CSS**), and JavaScript. Source: [https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en](https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wasm is a binary format**. It does not aim to be human-readable.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wasm is so low-level** that it brings performance improvements compared to
    high-level languages such as JavaScript.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go code can be compiled in the Wasm binary format.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we now have a brief basic understanding of what Wasm theoretically is, let's
    just use it to get a better understanding.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Displaying sensor data and weather alerts on a Wasm page
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal is to develop a small application that displays weather alerts and
    our sensor data that is being published to an MQTT broker, so we will need some
    very basic HTML and JavaScript skills in order to achieve this. We start by developing
    a small server that serves the Wasm app to a client.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Serving the application
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As Wasm is served to a browser, we need an HTTP endpoint that serves all files
    we might need. We start by creating a new folder named `wasm-server` inside the
    `Chapter07` folder, and inside this folder we create a new `main.go` file with
    an empty `main` function. Now, follow these steps to implement the server:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the directory where the `FileServer` should look for files, as follows:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, inside the `main` function, create a new `FileServer` and pass the directory
    as a parameter, as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Start an HTTP server that listens on port `8080`, as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Tell the browser not to cache the files. *We only use this for our development
    environment* to ensure that we never get a cached version of the app. On production,
    you would not want to deactivate the cache. The code is shown in the following
    snippet:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We need to set the proper `content-type` header for different file types, as
    follows:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, finally, just let the file server serve the files, as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This is everything we need to prepare our server. The server is now able to
    serve all files from inside the `html` directory, which we are going to create
    later. Note that this example server is nearly exactly the same as the example
    server from the TinyGo repository.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the weather app
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now create the actual app. The app is going to consist of three parts,
    as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: An HTML file, which is going to hold the page content.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `wasm.js` file, which is going to execute the Go code and also hold some other
    helper functions.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `wasm_exec.js` file, which can be considered as glue code, as it maps Go functions
    to JavaScript functions. This file is going to be provided by TinyGo itself.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start to create our HTML file. To do so, create a new folder named `weather-app`
    inside the `Chapter07` folder and create a new file named `index.html` inside
    this new folder. Now, follow these steps inside the HTML file:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare metadata such as `charset`, `title`, and `viewport` in the head, as
    follows:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Import the `paho mqtt` library. We are going into more detail on this one as
    soon as we use it. The code is shown in the following snippet:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Import the `wasm_exec.js` and `wasm.js` files. These files are being provided
    by our server. The code is shown in the following snippet:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, in the body, we want to tell the user what the app is about and display
    our data, as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define a table with four columns that are going to be dynamically filled with
    our weather alerts. The `tbody` column gets an `id` attribute so that we are able
    to identify that element. The code is shown in the following snippet:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define a table with five columns that are going to be filled with our sensor
    data. The `tbody` column again gets an `id`. The code is shown in the following
    snippet:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is everything we need to display our data. I did not include any CSS, to
    keep the example as easy to understand and short as possible. You can, of course,
    also include inline CSS or reference a CSS file that could also be served from
    the `html` directory.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Reading more
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn how to create beautiful web apps using HTML5 and CSS,
    I recommend the book *Responsive Web Design with HTML5 and CSS* by the awesome
    author Ben Frain. You can find it at the following link:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/product/responsive-web-design-with-html5-and-css-third-edition/9781839211560](https://www.packtpub.com/product/responsive-web-design-with-html5-and-css-third-edition/9781839211560)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement the actual client logic. We start by creating
    a new file inside the `weather-app` directory and naming it `wasm.go`, and also
    create an empty `main` function inside the newly created file. Now, follow these
    steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a struct for our sensor events, as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Define a struct for our alert events, as follows:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create a channel that is going to be used to handle the sensor events, as follows:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a channel that is going to be used to handle the alert events, as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Inside the `main` function, we export the `sensorDataHandler` function as `sensorDataHandler`
    to the JavaScript environment. This way, we can call the `go` function from JavaScript.
    The code is shown in the following snippet:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We also export the `alertHandler` function, as follows:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Start a goroutine that handles the sensor events, as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Start a goroutine that handles the alert events, as follows:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Block the execution of the main goroutine so that the program does not just
    shut down after executing the `main` function, as follows:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Add the `alertHandler` function. In order to be able to export the function
    using the `js.Global().Set()` call, the function must have a signature that accepts
    a `js.Value` and a `[].js.Value` and returns an `interface{}`, as illustrated
    in the following code snippet:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When calling this function, we pass a single string as parameter. We will be
    able to find the string inside the first index of `args`. Afterward, we need to
    split the message using a hashtag as separator. The code is shown in the following
    snippet:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Add the deserialized message to the channel. As we have not placed a timestamp
    onto the message when sending it, we now add the timestamp, as illustrated in
    the following code snippet:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Simply return `nil` as we do not need to write back any value to the JavaScript
    code that calls this function, as illustrated in the following code snippet:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We now do the same procedure for the sensor data events, as follows:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Add the `handleAlertEvents()` function. This function loops forever and reads
    an alert from the channel. The code is shown in the following snippet:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'As we have read an alert event, we need to find the `tbody` element in the
    `html` directory in order to add a new row. We make use of some helper functions
    that we are going to explain as soon as we implement them. The code is shown in
    the following snippet:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create a new table row, as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Add the column data, as follows:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Add the formatted column data, as follows:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Append a new `tableRow` to `tbody`, as follows:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `handleSensorEvents` function works in a very similar way. We loop forever,
    read events from the `sensorEvents` channel, and add the data to the `tbody`.
    The code is shown in the following snippet:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The only thing missing from our Go code is the `dom` helper function. So, create
    a new folder named `dom` inside the `Chapter07` folder, create a new `dom.go`
    file inside the folder, and name the package `dom`. Now, follow these steps to
    implement it:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `GetDocument` function that wraps the get document call. You can also
    refer to the `Getdocument` as the HTML. The code is shown in the following snippet:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Add a wrapper for the `createElement` call. A created element is not directly
    visible. A newly created element needs to be added to the document before it is
    being rendered. The code is shown in the following snippet:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add a wrapper for the `getElementById` function. We used this function to get
    the `tbody` elements, using the `id` we defined in the `html` directory. The code
    is shown in the following snippet:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Add a wrapper for `appendChild`. We used this function to add the `tableRows`
    into the `tbody` elements. This actually adds the elements to the `html` directory.
    The code is shown in the following snippet:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Add a wrapper to set the `innerHTML` function. This function adds the given
    value between `html` tags. The code is shown in the following snippet:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `AddTd` function creates a new `td` element, sets the `innerHTML` function,
    and appends the child to the given `tr` element, as illustrated in the following
    code snippet:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `AddTdf` function does the same as the `AddTd` function, with the difference
    that the `innerHTML` function gets formatted. The code is shown in the following
    snippet:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We have now implemented all the helper functions that we used in the `wasm.go`
    file. The only thing missing, before we can build and test the app, is the `wasm.js`
    file. So, let''s create a new file named `wasm.js` and follow these steps to implement
    the last part:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare that this file should be executed in strict mode. For more information
    on strict mode, check out the following site:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.w3schools.com/js/js_strict.asp](https://www.w3schools.com/js/js_strict.asp)'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a `const` value for the `wasm` file. The binary we build will later
    be named `wasm.wasm`. We also add new variables to store the `mqtt` client and
    the `wasm` object, as illustrated in the following code snippet:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We are using a JavaScript implementation of an MQTT client as I was not able
    to find an MQTT client in Go that could be built with TinyGo for the Wasm target.
    *Replace the values for host with the IP address from your MQTT broker*. In the
    future, there will surely be several clients that can be used for TinyGo Wasm
    projects. The code is shown in the following snippet:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This function gets called when the MQTT client has successfully established
    a connection. When this has happened, we subscribe to the topics that are of interest
    to us. The code is shown in the following snippet:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If we lose the connection to the MQTT broker, we want to log an error to the
    console. This function gets handed in later as a callback for the `connectionLost`
    event. The code is shown in the following snippet:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'When a new message arrives, we want to check what type of message we have and
    call the correct Go function. We determine the type of the message using the information
    we provide inside the message. The code is shown in the following snippet:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We now add the `MQTTconnect` function. This function simply creates a new `mqttClient`
    and adds callback functions for the `connect`, `connectionLost`, and `messageArrived`
    events. The code is shown in the following snippet:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now, add the `init` function that is going to run our Go code, as follows:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Create a new instance of go, as follows:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Check if the browser supports the `instantiateStreaming` function and, if so,
    load and run Wasm using this function, as follows:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'If the browser does not support the `instantiateStreaming` function, we load
    and run Wasm using the `instantiate` function, as follows:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'After starting our `go` code, we can try to connect to the MQTT broker, as
    follows:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'At the end of the file, add a call to the `init()` function, as follows:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'That was the complete code for our program. Now, we need to download the `wasm_exec.js`
    file and add it to the `weather-app` folder. Always use the `wasm_exec.js` version
    from your currently installed TinyGo version. You can simply download the file
    for the current TinyGo release here:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js](https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build and start the app, I normally use a `Makefile` function.
    The content of the `Makefile` looks like this:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'In order to build the app and start the server, I only need to call that `Makefile`
    function by using the following command:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'That works well on Linux and Mac systems, and could also work on Windows systems
    if GNU Make is installed. But let''s go through the process step by step so that
    you can also build and run that app without using `make`, as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Delete the existing `html` folder.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new html folder.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the Wasm app using the Wasm target. Also, we omit debug information, which
    results in smaller binary sizes.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, copy the `wasm_exec.js` file to the `html` folder.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `wasm.js` file to the `html` folder.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `index.html` file to the `HTML` folder.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the server using the `go run` command.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After using the `make` command or doing the steps manually, open your browser
    and visit the following URL: `localhost:8080`. You should now see a site that
    is similar to this:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 –TinyGo weather station with opened developer tools'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.13_B16555.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 –TinyGo weather station with opened developer tools
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We have successfully implemented a Wasm app that subscribes to topics
    on an MQTT broker and dynamically updates the content of a website.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use the Wi-Fi chip that is built onboard
    the Arduino Nano 33 IoT board. We then wrote reusable packages to use the Wi-Fi
    chip and the MQTT client, we discovered what MQTT is, and we learned how to publish
    messages to a topic. We have learned how to read sensor data from a BME280 sensor
    and publish this to an MQTT broker that we have set up locally.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have learned what Wasm is and implemented our first application using
    Wasm. We have also learned how to use a JavaScript MQTT client in order to subscribe
    to an MQTT topic and react to messages. While doing so, we learned how to manipulate
    the **Document Object Model** (**DOM**) in order to dynamically update the view.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to try out a Wasm app by using
    a login view, and will also learn how to implement bidirectional communication
    over MQTT.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What needs to be done to ensure that an MQTT message actually gets delivered?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can multiple clients subscribe to the same topic on an MQTT broker?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
