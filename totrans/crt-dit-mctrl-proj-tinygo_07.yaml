- en: '*Chapter 7*: Displaying Weather Alerts on the TinyGo Wasm Dashboard'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to display data using different types of displays that are
    connected using either the **Inter-Integrated Circuit** (**I2C**) protocol or
    the **Serial Peripheral Interface** (**SPI**). While doing so, we dived a bit
    deeper into understanding how SPI works by learning that multiple devices can
    listen on a SPI bus and that we can daisy-chain devices on the bus. Furthermore,
    we have built a **command-line interface** (**CLI**) that interprets commands
    sent over serial and executes functions depending on the input.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, you will be familiar with using **Message
    Queuing Telemetry Transport** (**MQTT**), serving a **WebAssembly** (**Wasm**)
    page through a web server, how to set up a local MQTT broker, and how to use the
    Wi-Fi functionalities of the Arduino Nano 33 IoT board.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a weather station
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending MQTT messages to a broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Wasm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying sensor data and weather alerts on a Wasm page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to utilize an MQTT broker in order
    to send messages from your microcontroller over Wi-Fi. You will also know how
    to subscribe to MQTT messages inside a Wasm app and how to display data that is
    being sent as an MQTT message payload.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker—You can find an installation guide by following this link: [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to need the following components for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Nano 33 IoT board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An external power supply  (**5 volts** (**5V**))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BME280 sensor (I2C)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ST7735 display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub at the following link: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3dXGe4o](https://bit.ly/3dXGe4o)'
  prefs: []
  type: TYPE_NORMAL
- en: Building a weather station
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start our journey through the world of **Internet of Things** (**IoT**) and
    Wasm by building a **weather station**. In our first project of this chapter,
    we are going to build a program that displays weather data on an **ST7735** display.
    We are going to build some reusable components that we are going to utilize in
    the final project of the chapter. We are going to learn how to use a **BME280**
    sensor that is able to sense air pressure, temperature, and humidity—the elements
    required for noting a change in the weather. But first, we need to assemble a
    circuit—so, let's see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we are able to read and display the sensor data, we need to assemble
    the circuit. We are connecting the BME/BMP280 sensor using the I2C interface,
    and we are going to connect the ST7735 display using the SPI interface. To do
    so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the **BME/BMP280** sensor with serial data pin (**SDA**) in *F21*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *H21* (SDA) with pin *J56* (SDA) on the breadboard, using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin *I22* **Serial Clock** (**SCL**) with pin *I55* (SCL) on the breadboard,
    using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J23* **Ground** (**GND**) with the *GND* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J24* (VIN) with the **Voltage Common Collector** (**VCC**) lane on
    the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the display with the **light-emitting diode** (**LED**) pin in pin *A31*
    on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E31* (LED) with pin *A53* (D2) on the breadboard, using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E32* (SCK) with pin *A54* (D13) on the breadboard, using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E33* (SDA) with pin *A62* (D11) on the breadboard, using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E34* **Analog pin** (**AO**) with pin *A56* on the breadboard, using
    a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E35* (AO) with pin *A57* (D5) on the breadboard, using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E36* (RESET) with pin *A58* (D6) on the breadboard, using a jumper
    wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E37* **chip select** (**CS**) with pin *A59* (D7) on the breadboard,
    using a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E37* (GND) with the *GND* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *E38* (VCC) with the *VCC* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect *J51* (GND) with the *GND* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The circuit should now look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Weather-station circuit (image is taken from Fritzing)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Weather-station circuit (image is taken from Fritzing)
  prefs: []
  type: TYPE_NORMAL
- en: This is everything we need on assembling for the complete chapter. We can proceed
    to the next section and write the code that is able to *read the sensor data and
    display it* onto ST7735.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the weather station
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to put the weather station logic, which consists of reading and
    interpreting sensor data, into a separate package so that we can use it in an
    example that only displays the data onto a display. When this is done, we are
    going to reuse this package to get the sensor data and calculate alerts to send
    it to an **MQTT broker**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by creating a new folder named `Chapter07` inside the project
    folder, and create a new folder named `weather-station` inside `Chapter07`. We
    then create a new file named `weather.go` and name the package `weatherstation`.
    The project structure should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Project structure for programming the weather station'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Project structure for programming the weather station
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the logic, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define colors that are later to be used when we draw something on the display,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define an interface and insert the following functions. We are going
    to explain each function in detail as soon as we implement it, in some later steps
    of this list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define `struct` that contains the sensor and the display, as well as
    some more fields that we are going to explain as soon as we use them. For the
    BME280 device, we are going to use a driver from the TinyGo `drivers` repository.
    You can import it using the following path: [tinygo.org/x/drivers/bme280](http://tinygo.org/x/drivers/bme280).
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add a new constructor function that sets the sensor and display and
    initializes all values, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the `ReadData` function, which is a convenience function that reads
    all sensor values and returns them. The code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add a function that blocks the execution of the program until connection
    to the BME280 sensor has been approved, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now add a function that takes the sensor readings and displays them on the
    screen, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fill the screen so that we have no artifacts from previous calls. If we were
    to skip this step, we would possibly draw images above it that had previously
    been drawn, which would look really messy. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a header using `tinyfont`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the readings to strings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and display the temperature, pressure, and humidity strings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function that converts the sensor readings to °C, **hectopascal** (**hPa**),  and
    relative humidity as percentage to the strings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now finished implementing the logic to read and display the sensor data.
    The next step is calculating the weather alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating weather alerts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to calculate alerts, we need to save some readings. We can do so by
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the weather-alert calculation, we will only need pressure. That is why
    we hold an array of `float64` in the `service` struct, as can be seen in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we have ever saved a value before, we fill the complete array with the same
    value. This prevents some edge cases later on when calculating alerts. The code
    is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we have now inserted our first reading, we can set the `true` flag and `return`.
    This ensures that we only execute the preceding logic once. The code is shown
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the reading into the current index. If our current index exceeds the
    maximum number of stored datasets, we reset the index; so, the next reading is
    going to overwrite the reading in index `0`. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function that uses the saved readings, calculates a difference between
    the two of them, and alerts if the difference exceeds the threshold. We are going
    to talk about thresholds and timespans later in this section when we call this
    function. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `comparisonIndex` value based on the `timeSpan` value, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the difference between the two values and raise an alert if the difference
    is greater than the threshold by returning `diff`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Okay—we just implemented an **application programming interface** (**API**)
    that lets us read, convert, and display sensor data, and along with it we can
    save sensor readings and calculate weather alerts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try out whether the code is actually able to read and display sensor
    data. To do so, we first create a new folder named `weather-station-example` inside
    the `Chapter07` folder. We then create a new `main.go` file with an empty `main`
    function inside. The project structure should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Project structure for reading the code and displaying sensor
    data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Project structure for reading the code and displaying sensor data
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `main` function, we sleep for `5` seconds to get enough time to
    open PuTTY so that we are able to monitor the output on the serial port. The code
    is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize and configure the display, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize and configure the sensor. The sensor needs to be calibrated, which
    is done inside the `Configure` function. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `weatherstation` and wait for sensor connectivity.
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read and display the data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it for this example. Now, go on and flash the program, using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After a brief moment, the display should now look similar to the one shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Display output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Display output
  prefs: []
  type: TYPE_NORMAL
- en: We have now verified that we are able to read and display the sensor data. As
    we have now learned how to use the BMP280 sensor and have prepared a package that
    is able to calculate weather alerts, we can now go on to the next section, where
    we learn how to communicate with the Wi-Fi chip and how to send MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Sending MQTT messages to a broker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now start to dive into the world of IoT. As every device that has a connection
    to the internet—or at least to some network—can be considered an IoT device, the
    project in this section can be considered an IoT project. The Arduino Nano 33
    IoT has a `u-blox NINA-W102` chip on board that is capable of Wi-Fi communication.
    We can communicate with this chip using the SPI interface. As a driver for the
    NINA chip already exists, we don't have to implement one ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our plan is to send data through SPI to the NINA chip, which then sends
    the data through the network to an MQTT broker. The following diagram illustrates
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Communication diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Communication diagram
  prefs: []
  type: TYPE_NORMAL
- en: Although the driver functionality is wrapped in a package, some boilerplate
    code is still needed to start using the Wi-Fi chip. So, let's wrap it inside a
    new package.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Wi-Fi package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create an API that provides functionality to initialize the
    NINA chip, check the hardware and set up a connection. So, let''s start by creating
    a new folder named `wifi` inside the `Chapter07` folder and creating a new `wifi.go`
    file inside the newly created folder, and name the package `wifi`. The project
    structure should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, perform these steps to implement the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an interface for the package, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a client that stores the credentials as well as the SPI bus and `wifinina.Device`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a constructor function that sets the SPI bus and the credentials, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Configure` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the NINA SPI bus using the default pins, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of the `wifinina` driver and pass the SPI bus as well
    as the default pins, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The chip needs a moment before it is ready to be used, which is why we sleep
    for a brief moment. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add a function to check the hardware, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we print the currently installed **firmware version**. This information
    can be important if you face any issues using the NINA chip. Also, you can use
    this information to check which features are supported by the firmware. The code
    is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we scan for available Wi-Fi networks and print all results. The internal
    buffer only stores up to 10 **service set identifiers** (**SSIDs**). If the scan
    for Wi-Fi networks runs without any errors, we can be sure that we are able to
    communicate with the chip. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we implement a convenience function that establishes a connection to a
    network, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sleep for a second, as it can take a while until the connection is established.
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the connection status and print it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the status equals `StatusConnected`, as shown in the following code snippet,
    we are successfully connected to the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sometimes, the connection cannot be established on the first attempt, which
    is why we just try it again, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the connection has successfully been established, we print the **Internet
    Protocol** (**IP**) address that our device has been assigned by the **Dynamic
    Host Configuration Protocol** (**DHCP**), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can either only set the network (`ssid`) with no passphrase for open networks
    or we can set the network (`ssid`) and passphrase. Setting either of these options
    triggers a connection attempt. If no password has been set, we try to connect
    to an open network. If the password and `ssid` are set, we try to connect to a
    secured network, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's everything we need to implement our abstraction layer. We are going to
    test this package together with an MQTT client abstraction layer, which we are
    going to implement next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an MQTT client abstraction layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as with the Wi-Fi driver, the MQTT client needs some boilerplate code in
    order to get up and running. We are going to reduce the boilerplate code by adding
    an abstraction layer. That way, we only have the boilerplate code one time in
    a reusable component and do not have to write the same code repeatedly in every
    future project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a new folder named `mqtt-client` inside the `Chapter07`
    folder, and create a new file named `client.go` and place it inside the `mqttclient`
    package. The project structure should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.7_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: Before we start to implement the code, we first need to understand what MQTT
    is and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MQTT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MQTT is a messaging protocol for the IoT. It is based on a **publisher/subscriber**
    architecture. A microcontroller that reads sensor data can **publish messages**
    to a so-called **topic** (such a microcontroller would be a thing in the IoT world).
    These messages are sent to a **broker**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MQTT standard allows the usage of **Transport Layer Security** (**TLS**),
    as well as **Open Authorization** (**OAuth**) for authentication. It is also possible
    to not authenticate at all. The available authentication flows depend on the implementation
    and configuration of the used MQTT broker. Securing the broker by using authentication
    flows is important when sending sensitive data over the internet. The following
    diagram shows an example architecture of a single MQTT broker and multiple MQTT
    clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – MQTT architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.8_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – MQTT architecture
  prefs: []
  type: TYPE_NORMAL
- en: In order to use MQTT, we need an active broker to which a client can publish
    messages. We also need one or many clients to be able to subscribe to messages
    from a certain topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence diagram of a typical MQTT communication is straightforward and
    is based on a **command and command acknowledge** pattern. Let''s have a look
    at an example sequence, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client connects to the broker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The broker acknowledges the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Optional: The client subscribes to a topic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The broker acknowledges the subscription.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Optional: The client publishes a message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The broker acknowledges the published message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This looks like the sequence shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – MQTT sequence diagram  (image was created using PlantUML)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.9_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – MQTT sequence diagram  (image was created using PlantUML)
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing this, here we mean a broker can serve many clients, a client can
    subscribe to one or many topics, and a client can publish a message in a topic.
    This should be enough base knowledge about MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to gain a deeper knowledge about MQTT, you might want to have a
    look at the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mqtt.org/mqtt-specification/](https://mqtt.org/mqtt-specification/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write the abstraction layer. As we have already prepared the project
    structure, we can start directly writing the code by following these steps inside
    the `client.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As our client is only going to publish messages, our API is going to be fairly
    simple. We need to be able to connect to a broker and we need to be able to publish
    messages. We now add `struct` that contains the `mqtt.Client` from the `drivers`
    repository, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a new `Client`, we only need to set the `mqttBroker` URL, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `ConnectBroker` function, which is going to establish a connection
    to the broker. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create new client options that will later be passed as arguments when creating
    a new client. These options take all the parameters needed to establish a connection.
    When using a broker that requires a password and username, these can also be set
    here. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When testing programs using a local broker, we sometimes try to connect while
    the old client connection has not been discarded and we could run into problems
    connecting with the same `clientID` again, so using random strings helps a lot.
    The MQTT specification states that a `clientID` should be between 1 and 23 characters
    long, but brokers such as Mosquitto do not implement that. We will learn about
    the Mosquitto MQTT broker later in this section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ClientIDs must be unique—otherwise, clients would be kicked out by the broker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are going to use a combination of the `clientID` we passed in and a random
    string of length `4`, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now create a new client and pass `opts` as a parameter, and try to connect
    to the broker as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although the current implementation of the token always return `true` when
    using the `wait` function, we still add it here in case it is implemented by the
    time you have worked through this chapter. We can use this function to wait for
    any command to get *acked* (acknowledged). Alternatively, we could use `token.WaitTimeout`,
    which internally times out when the given time span is over. The first option
    is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `PublishMessage` function. `qos` (the `0`, `1`, or `2`. After we have
    completely implemented this package, we are going to have a deeper look at the
    `qos` levels. The `retain` flag tells the broker to store the last message having
    a `retain` flag. When a new client subscribes to the broker, the retained message
    will directly get delivered. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to add a function that allows us to subscribe to a certain
    topic. The following code snippet illustrates this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a function to generate a random string containing a character between
    `A` and `Z`. The following functions are taken from the `mqtt` driver example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it for our abstraction layer. Before we go on to write the actual weather-station
    program, let's have a look at the QOS levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'MQTT provides three QOS levels, which work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QOS 0**: *A message is delivered once*. The message is not stored by the
    sender and is not acknowledged. So, the client will only try to deliver it once,
    and if that fails, the message is discarded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duplicate` flag until it gets acknowledged by the broker. All of these messages
    will be sent to subscribed clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duplicate` flag until the message has been acknowledged. The difference is
    that the message will only be delivered to subscribers when the client sends a
    `PUBREL` (publish release) message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more information about the underlying processes by following this
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)'
  prefs: []
  type: TYPE_NORMAL
- en: As we now have a basic understanding of MQTT and have implemented our abstraction
    layer, it's time to put everything together in the next step and actually start
    to publish messages to a broker.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the weather station
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have prepared all the code that we need to implement the actual logic but
    we do not have an MQTT broker yet. So, let's set up a local MQTT broker that we
    can use for this program.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Eclipse Mosquitto MQTT broker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to use the Eclipse Mosquitto MQTT broker. You can find more information
    regarding the broker here: [https://mosquitto.org/](https://mosquitto.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want to set up a local MQTT broker or if you cannot use Docker
    right now, you can skip this and use the Mosquitto test system. *But please only
    use the Mosquitto test system for testing purposes; also, never publish any sensitive
    data to the test system as anyone could listen to the messages.* You can find
    the needed URLs and ports for the test system here: [http://test.mosquitto.org/](http://test.mosquitto.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to install a Mosquitto broker locally without using Docker,
    but that process won''t be covered in this book as using Docker is an easy and
    straightforward process, while setting up Mosquitto locally is more complicated.
    To set up Mosquitto using Docker, we need to create a configuration file. To do
    so, create a new folder named `mosquitto` inside the `Chapter07` folder and create
    a new folder named `config` inside the `mosquitto` folder. Now, create a new file
    and name it `mosquitto.conf`. The next step is to insert the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We have configured Mosquitto to use the user `mosquitto` and listen on all IP
    addresses of the host. We also listen for Websocket connections on the localhost
    using port `9001`, which we make use of in the Wasm app in the *Implementing the
    weather app* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `allow_anonymous` flag allows unauthenticated clients to connect. For more
    information regarding the possible configuration options, consult the main manual
    page at [https://mosquitto.org/man/mosquitto-conf-5.html](https://mosquitto.org/man/mosquitto-conf-5.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we only need to start the container. It is important to map ports `1883`
    and `9001` so that we can actually reach these ports. Also, we need to *pass the
    path to our config file*. So, *replace the path that I used with the actual path
    to the config file on your system*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we now have a running Mosquitto instance, we can now truly begin to implement
    our client logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new folder named `weather-station-mqtt` inside the
    `Chapter07` folder, then create a new `main.go` file with an empty `main` function
    inside. The project structure should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Project structure for weather-station-mqtt'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Project structure for weather-station-mqtt
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing these examples, I have faced some issues regarding the `wifinina`
    driver inside the TinyGo `drivers` repository. I am currently working on resolving
    these issues. So, if you face any problems connecting to your Wi-Fi network, use
    the two imports shown in the following code snippet instead of the official ones.
    You will also need to change these imports in the `wifi` and `mqtt-client` packages
    we developed earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, when using my fork of the `drivers` repository for the `wifinina` driver,
    the initialization of `wifi.Client` looks a little bit different. When using the
    driver, you will see that there is an error in the `Configure` function. To fix
    it, replace the initialization of the `client.wifi` object with the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the program, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define constants for `ssid` and `password`, as shown in the following code
    snippet. You must insert your own credentials here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define variables for `temperature`, `pressure`, and `humidity`, as shown in
    the following code snippet. These will be accessed by multiple goroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When watching streams from Ron Evans (who is one of the TinyGo maintainers),
    I learned a helpful trick. If an error occurs when doing really important things,
    we want to be able to find the error message in the serial output. In such a case,
    we pause the program execution and repeatedly print the message, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inside the `main` function, we start by sleeping a brief moment so that
    we have enough time to open up PuTTY to monitor the serial output while we initialize
    the sensor and weather station, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize `weatherStation`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `wifi` client, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `wifi` client, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we call the `CheckHardware` function, which will output the firmware version
    and `ssids` that have been found when scanning for networks. If that works, we
    can be sure that the microcontroller is able to communicate with the NINA chip.
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to connect to the network, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `mqttClient` instance. Please note that you have to change the
    IP address to the address of the host where your MQTT broker is running. *Do not
    omit the* `tcp://` *part*, as it is being used by the driver implementation to
    estimate which kind of connection needs to be established. The code is shown in
    the following snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to connect to the MQTT broker, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a goroutine that publishes sensor data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a goroutine that publishes weather alerts, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read new sensor values once a minute, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `publishSensorData` function. For testing purposes it runs once
    per minute, but you can customize it depending on your needs. The code is shown
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As most encoding packages are currently not supported by TinyGo, we use a **character-separated
    string** to serialize the data, as this will be easy to deserialize on the subscriber
    side. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sometimes, we lose the connection to Wi-Fi or to the MQTT broker. In that case,
    we just try to establish a new connection, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now add the `publishAlert` function, which runs once an hour, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We save the pressure reading on an hourly basis, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we check for whether we have to send an alert. We use `2` as the value
    for the alert threshold, for the hourly check. We will talk about these values
    in more detail after finishing the implementation of the function. The code is
    shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we have an `alert`, we publish it by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we check for an `alert` on a 3-hour schedule, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we do not have an `alert`, we continue by running the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Publish the alert (if we have one) on a 3-hour schedule, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's everything we need for our first IoT project. We have now developed a
    client that reads data from a sensor and publishes it to an MQTT broker. The client
    also checks the data for possible incoming storms and publishes these warnings
    as messages on a different topic. Before we try out the program, let's briefly
    talk about the thresholds and timespans we used as parameters in the alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Very important note
  prefs: []
  type: TYPE_NORMAL
- en: I am by no means a meteorologist. *This program is not able to predict every
    possible incoming storm*. The data I used as example values is not tested as I
    experienced no incoming storms when writing this book. Also, this information
    is based on articles I read online and might only work quite well in the place
    I'm living, so you might need to do your own research about the coherence of pressure
    changes and incoming bad weather. If this program did not predict an incoming
    storm but you feel one could be incoming, please check your local news and weather
    sources for that information. *So, again, if you live in an area that is frequently
    being hit by dangerous storms, please do not blindly trust this program.* Meteorology
    is way more complicated than this program and we do only check for incoming storms
    based on sudden drops in pressure. There are more indicators for incoming storms,
    so please consider this program a prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source of my threshold values is the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.bohlken.net/airpressure2.htm](http://www.bohlken.net/airpressure2.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: This states that a pressure drop of **>=2hPa** during a 1-hour period could
    indicate a possible incoming storm. It also states that a pressure drop of **>=6hPa**
    during a 3-hour period could indicate a possible incoming storm.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in MQTT best practices, check out the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/](https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go on and finally flash the program onto the microcontroller by
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now flashed the program and everything seems to be running fine, but
    how do we know that the messages are really being successfully published? We can
    use an MQTT **graphical user interface** (**GUI**) client in such cases. I do
    recommend **MQTT Explorer** for this. You can download the program for every platform
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mqtt-explorer.com/](https://mqtt-explorer.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the program, you only need to insert the `hostname` and `port`
    values. Just use `localhost` and port `1883` as parameters, then save your connection.
    The connection window should now look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – MQTT Explorer connection window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – MQTT Explorer connection window
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program is running on the microcontroller, you should be able to see
    the topics and messages that are being published to the broker. This will look
    similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – MQTT Explorer published message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – MQTT Explorer published message
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to implement a weather station that is able to publish messages
    to different topics to an MQTT broker. We have also learned how to set up Mosquitto
    using Docker, and we have learned how to use MQTT Explorer to check if our messages
    really are being published. The next step is to create a Wasm app that displays
    these messages.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Wasm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s find out what Wasm is. The *WebAssembly* home page states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
    virtual machine. Wasm is designed as a portable compilation target for programming
    languages, enabling deployment on the web for client and server applications."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://webassembly.org/](https://webassembly.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can write code in any language and compile it to the Wasm
    binary format, which can then be executed by the browser. That makes Wasm extremely
    valuable, as we can create client applications using languages other than JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: A great advantage of Wasm compared to JavaScript is that it aims to execute
    at native speed, and as it runs in a sandboxed environment inside the browser
    it can be considered as relatively safe. Luckily, TinyGo does support Wasm as
    a compilation target, so we can make use of the incredibly small binary sizes
    that TinyGo produces, which will significantly speed up page loading times compared
    to other technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list to summarize the preceding information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wasm is a new language** that officially became the fourth language of the
    web, after **HyperText Markup Language** (**HTML**), **Cascading Style Sheets**
    (**CSS**), and JavaScript. Source: [https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en](https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wasm is a binary format**. It does not aim to be human-readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wasm is so low-level** that it brings performance improvements compared to
    high-level languages such as JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go code can be compiled in the Wasm binary format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we now have a brief basic understanding of what Wasm theoretically is, let's
    just use it to get a better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying sensor data and weather alerts on a Wasm page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal is to develop a small application that displays weather alerts and
    our sensor data that is being published to an MQTT broker, so we will need some
    very basic HTML and JavaScript skills in order to achieve this. We start by developing
    a small server that serves the Wasm app to a client.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As Wasm is served to a browser, we need an HTTP endpoint that serves all files
    we might need. We start by creating a new folder named `wasm-server` inside the
    `Chapter07` folder, and inside this folder we create a new `main.go` file with
    an empty `main` function. Now, follow these steps to implement the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the directory where the `FileServer` should look for files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inside the `main` function, create a new `FileServer` and pass the directory
    as a parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start an HTTP server that listens on port `8080`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tell the browser not to cache the files. *We only use this for our development
    environment* to ensure that we never get a cached version of the app. On production,
    you would not want to deactivate the cache. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to set the proper `content-type` header for different file types, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, finally, just let the file server serve the files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is everything we need to prepare our server. The server is now able to
    serve all files from inside the `html` directory, which we are going to create
    later. Note that this example server is nearly exactly the same as the example
    server from the TinyGo repository.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the weather app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now create the actual app. The app is going to consist of three parts,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTML file, which is going to hold the page content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `wasm.js` file, which is going to execute the Go code and also hold some other
    helper functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `wasm_exec.js` file, which can be considered as glue code, as it maps Go functions
    to JavaScript functions. This file is going to be provided by TinyGo itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start to create our HTML file. To do so, create a new folder named `weather-app`
    inside the `Chapter07` folder and create a new file named `index.html` inside
    this new folder. Now, follow these steps inside the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare metadata such as `charset`, `title`, and `viewport` in the head, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `paho mqtt` library. We are going into more detail on this one as
    soon as we use it. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `wasm_exec.js` and `wasm.js` files. These files are being provided
    by our server. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the body, we want to tell the user what the app is about and display
    our data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a table with four columns that are going to be dynamically filled with
    our weather alerts. The `tbody` column gets an `id` attribute so that we are able
    to identify that element. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a table with five columns that are going to be filled with our sensor
    data. The `tbody` column again gets an `id`. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is everything we need to display our data. I did not include any CSS, to
    keep the example as easy to understand and short as possible. You can, of course,
    also include inline CSS or reference a CSS file that could also be served from
    the `html` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Reading more
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn how to create beautiful web apps using HTML5 and CSS,
    I recommend the book *Responsive Web Design with HTML5 and CSS* by the awesome
    author Ben Frain. You can find it at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/product/responsive-web-design-with-html5-and-css-third-edition/9781839211560](https://www.packtpub.com/product/responsive-web-design-with-html5-and-css-third-edition/9781839211560)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement the actual client logic. We start by creating
    a new file inside the `weather-app` directory and naming it `wasm.go`, and also
    create an empty `main` function inside the newly created file. Now, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a struct for our sensor events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a struct for our alert events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a channel that is going to be used to handle the sensor events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a channel that is going to be used to handle the alert events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, we export the `sensorDataHandler` function as `sensorDataHandler`
    to the JavaScript environment. This way, we can call the `go` function from JavaScript.
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also export the `alertHandler` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a goroutine that handles the sensor events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a goroutine that handles the alert events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Block the execution of the main goroutine so that the program does not just
    shut down after executing the `main` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `alertHandler` function. In order to be able to export the function
    using the `js.Global().Set()` call, the function must have a signature that accepts
    a `js.Value` and a `[].js.Value` and returns an `interface{}`, as illustrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When calling this function, we pass a single string as parameter. We will be
    able to find the string inside the first index of `args`. Afterward, we need to
    split the message using a hashtag as separator. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the deserialized message to the channel. As we have not placed a timestamp
    onto the message when sending it, we now add the timestamp, as illustrated in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Simply return `nil` as we do not need to write back any value to the JavaScript
    code that calls this function, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now do the same procedure for the sensor data events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `handleAlertEvents()` function. This function loops forever and reads
    an alert from the channel. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we have read an alert event, we need to find the `tbody` element in the
    `html` directory in order to add a new row. We make use of some helper functions
    that we are going to explain as soon as we implement them. The code is shown in
    the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new table row, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the column data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the formatted column data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append a new `tableRow` to `tbody`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `handleSensorEvents` function works in a very similar way. We loop forever,
    read events from the `sensorEvents` channel, and add the data to the `tbody`.
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only thing missing from our Go code is the `dom` helper function. So, create
    a new folder named `dom` inside the `Chapter07` folder, create a new `dom.go`
    file inside the folder, and name the package `dom`. Now, follow these steps to
    implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `GetDocument` function that wraps the get document call. You can also
    refer to the `Getdocument` as the HTML. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a wrapper for the `createElement` call. A created element is not directly
    visible. A newly created element needs to be added to the document before it is
    being rendered. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a wrapper for the `getElementById` function. We used this function to get
    the `tbody` elements, using the `id` we defined in the `html` directory. The code
    is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a wrapper for `appendChild`. We used this function to add the `tableRows`
    into the `tbody` elements. This actually adds the elements to the `html` directory.
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a wrapper to set the `innerHTML` function. This function adds the given
    value between `html` tags. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AddTd` function creates a new `td` element, sets the `innerHTML` function,
    and appends the child to the given `tr` element, as illustrated in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AddTdf` function does the same as the `AddTd` function, with the difference
    that the `innerHTML` function gets formatted. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have now implemented all the helper functions that we used in the `wasm.go`
    file. The only thing missing, before we can build and test the app, is the `wasm.js`
    file. So, let''s create a new file named `wasm.js` and follow these steps to implement
    the last part:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare that this file should be executed in strict mode. For more information
    on strict mode, check out the following site:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.w3schools.com/js/js_strict.asp](https://www.w3schools.com/js/js_strict.asp)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a `const` value for the `wasm` file. The binary we build will later
    be named `wasm.wasm`. We also add new variables to store the `mqtt` client and
    the `wasm` object, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are using a JavaScript implementation of an MQTT client as I was not able
    to find an MQTT client in Go that could be built with TinyGo for the Wasm target.
    *Replace the values for host with the IP address from your MQTT broker*. In the
    future, there will surely be several clients that can be used for TinyGo Wasm
    projects. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function gets called when the MQTT client has successfully established
    a connection. When this has happened, we subscribe to the topics that are of interest
    to us. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we lose the connection to the MQTT broker, we want to log an error to the
    console. This function gets handed in later as a callback for the `connectionLost`
    event. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a new message arrives, we want to check what type of message we have and
    call the correct Go function. We determine the type of the message using the information
    we provide inside the message. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now add the `MQTTconnect` function. This function simply creates a new `mqttClient`
    and adds callback functions for the `connect`, `connectionLost`, and `messageArrived`
    events. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `init` function that is going to run our Go code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of go, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if the browser supports the `instantiateStreaming` function and, if so,
    load and run Wasm using this function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the browser does not support the `instantiateStreaming` function, we load
    and run Wasm using the `instantiate` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After starting our `go` code, we can try to connect to the MQTT broker, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the file, add a call to the `init()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That was the complete code for our program. Now, we need to download the `wasm_exec.js`
    file and add it to the `weather-app` folder. Always use the `wasm_exec.js` version
    from your currently installed TinyGo version. You can simply download the file
    for the current TinyGo release here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js](https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build and start the app, I normally use a `Makefile` function.
    The content of the `Makefile` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to build the app and start the server, I only need to call that `Makefile`
    function by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'That works well on Linux and Mac systems, and could also work on Windows systems
    if GNU Make is installed. But let''s go through the process step by step so that
    you can also build and run that app without using `make`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the existing `html` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new html folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the Wasm app using the Wasm target. Also, we omit debug information, which
    results in smaller binary sizes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, copy the `wasm_exec.js` file to the `html` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `wasm.js` file to the `html` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `index.html` file to the `HTML` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the server using the `go run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After using the `make` command or doing the steps manually, open your browser
    and visit the following URL: `localhost:8080`. You should now see a site that
    is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 –TinyGo weather station with opened developer tools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.13_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 –TinyGo weather station with opened developer tools
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We have successfully implemented a Wasm app that subscribes to topics
    on an MQTT broker and dynamically updates the content of a website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use the Wi-Fi chip that is built onboard
    the Arduino Nano 33 IoT board. We then wrote reusable packages to use the Wi-Fi
    chip and the MQTT client, we discovered what MQTT is, and we learned how to publish
    messages to a topic. We have learned how to read sensor data from a BME280 sensor
    and publish this to an MQTT broker that we have set up locally.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have learned what Wasm is and implemented our first application using
    Wasm. We have also learned how to use a JavaScript MQTT client in order to subscribe
    to an MQTT topic and react to messages. While doing so, we learned how to manipulate
    the **Document Object Model** (**DOM**) in order to dynamically update the view.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to try out a Wasm app by using
    a login view, and will also learn how to implement bidirectional communication
    over MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What needs to be done to ensure that an MQTT message actually gets delivered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can multiple clients subscribe to the same topic on an MQTT broker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
