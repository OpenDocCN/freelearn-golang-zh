<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer123">
			<h1 id="_idParaDest-149"><em class="italic"><a id="_idTextAnchor150"/>Chapter 8</em>: Automating and Monitoring Your Home through the TinyGo Wasm Dashboard</h1>
			<p>In the previous chapter, we learned how to use the Wi-Fi chip on the Arduino Nano 33 IoT board in order to send <strong class="bold">Message Queuing Telemetry</strong> (<strong class="bold">MQTT</strong>) messages. We then consumed these messages containing weather data and weather alerts, to display them on a <strong class="bold">WebAssembly</strong> (<strong class="bold">Wasm</strong>) dashboard, but we were not able to control anything from inside the dashboard. We are now going to change this.</p>
			<p>After working through this chapter, we will know how to secure our Wasm apps by adding a login page. We're also going to learn about security aspects when validating credentials on a client application. After building the login view, we are going to learn how to send and receive data inside a dashboard that we are going to build. By doing so, we are also going to learn some new techniques that will help us by dynamically adding and removing content. By manipulating the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), we will know how to use bidirectional communication through MQTT. Lastly, we are going to learn about possibilities to control devices that operate at 130V (where <strong class="bold">V</strong> stands for <strong class="bold">volts</strong>) or 230V. </p>
			<p>Knowing all this will enable us to build all sorts of home automation projects you can think of, beyond this book. In this chapter, we're going to cover the following main topics:  </p>
			<ul>
				<li>Building a home automation dashboard</li>
				<li>Building the home automation client</li>
				<li>Requesting data from the microcontroller</li>
			</ul>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Technical requirements</h1>
			<p>We are going to need the following components for this project:</p>
			<ul>
				<li>An Arduino Nano 33 IoT board</li>
				<li>A breadboard</li>
				<li>A <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>)</li>
				<li>A 68 Ohm resistor</li>
				<li>Jumper wires</li>
			</ul>
			<p>You can find the code for this chapter on GitHub at the following link: <a href="https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08">https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08</a></p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3uPLI7X">https://bit.ly/3uPLI7X</a><a href="https://bit.ly/3cYZOh4%0D"/></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Building a home automation dashboard</h1>
			<p>After <a id="_idIndexMarker503"/>you have finished this book, you might want to build lots of cool projects that could include LED stripes or a motion-sensor-controlled light, or you might add a motor to your curtains to open or close them based on the light intensity or the time. These would be really cool projects, but now imagine that you're sitting on the couch and want to watch a movie, but the sun is too bright and did not exceed the threshold to start the motor that controls the curtains. What can we do in such a situation? Do we stand up and close the curtains manually, or do we open a Wasm app on our smartphone or tablet in order to control the motor for the curtains by just pressing a button on an app? You might also want to check if the LED stripe in the living room is still turned on, but you do not want to get out of bed to check. In that case, it would be great to have a dashboard that informs you about its status. In this section, we are going to build a Wasm app that provides a login page where the user is able to enter a username and a password before they can log in. The page should then be transitioned to a dashboard that provides functionality to enable or disable the lights in a specific room. </p>
			<p>We will start with a reusable MQTT JavaScript component that can be used until a TinyGo-compatible MQTT library has been created. </p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Creating a reusable MQTT component</h2>
			<p>In <a href="B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135"><em class="italic">Chapter 7</em></a>, <em class="italic">Displaying Weather Alerts on the TinyGo Wasm Dashboard</em>, we embedded the<a id="_idIndexMarker504"/> MQTT client into a <strong class="source-inline">wasm.js</strong> file. This worked well for the project but is not reusable. Therefore, we are now going to create a reusable component. </p>
			<p>To do so, start off by creating a new folder named <strong class="source-inline">Chapter08</strong> for this project. Inside the newly created folder, create a new folder called <strong class="source-inline">light-control</strong>. This new folder is going to contain all the files that are needed for the Wasm app. </p>
			<p>Now, create a new file inside the <strong class="source-inline">light-control</strong> folder and name the file <strong class="source-inline">mqtt.js</strong>. The project structure should now look like this: </p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="Images/Figure_8.1_B16555.jpg" alt="Figure 8.1 – Project structure&#13;&#10;" width="303" height="62"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Project structure</p>
			<p>Inside the <strong class="source-inline">mqtt.js</strong> file, follow these steps to implement it:</p>
			<ol>
				<li>First, we define a variable that holds the MQTT client and constants for the MQTT broker. We also use <strong class="source-inline">strict</strong> mode again, to prevent us from using undefined variables. Strict mode also eliminates some silent errors and exchanges them to throw errors instead, and enables JavaScript engines to perform optimizations that were otherwise not possible. Using <strong class="source-inline">strict</strong> mode could lead to faster execution. The <strong class="source-inline">host</strong> and <strong class="source-inline">port</strong> values <em class="italic">need to be set to your own MQTT broker</em> host and port if the broker is not running locally. The code is shown in the following snippet:<p class="source-code">'use strict';</p><p class="source-code">var mqtt;</p><p class="source-code"><strong class="bold">const host = "192.2.0.23";</strong></p><p class="source-code"><strong class="bold">const port = 9001;</strong></p><p class="source-code">const cname = "home-automation-dashboard";</p></li>
				<li>We then add a function that simply logs to the console when the connection to the MQTT broker has been successfully established, as follows:<p class="source-code">function onConnect() {</p><p class="source-code">    console.log("Successfully connected to mqtt broker");</p><p class="source-code">}</p></li>
				<li>As the Wasm app is being executed on the client, it is possible that we will lose the connection to the MQTT broker. This could be caused by an unstable Wi-Fi connection. If <a id="_idIndexMarker505"/>that happens, we want to attempt to create a new connection. We can do this by running the following code:<p class="source-code">function onConnectionLost(err) {</p><p class="source-code">    if (err.errorCode !== 0) {</p><p class="source-code">        console.log("onConnectionLost:" + </p><p class="source-code">            err.errorMessage);</p><p class="source-code">    }</p><p class="source-code">    MQTTconnect();</p><p class="source-code">}</p></li>
				<li>We now need to add a callback for the <strong class="source-inline">messageArrived</strong> event. When a new message arrives, we want to call a message handler that is exported by the Go code. This works as follows:<p class="source-code">function onMessageArrived(message) {</p><p class="source-code">    console.log(</p><p class="source-code">        "onMessageArrived:" + message.payloadString);</p><p class="source-code">    handleMessage(message.payloadString);</p><p class="source-code">}</p></li>
				<li>We next want to be able to publish messages. In this case, we set the <strong class="bold">quality of service</strong> (<strong class="bold">QOS</strong>) to <strong class="source-inline">1</strong> as we<a id="_idIndexMarker506"/> want to make sure that a message is definitely received by consumers. Furthermore, we do not need to retain messages. In later projects, you could also parameterize the QOS level and the <strong class="source-inline">retain</strong> flag. The code is shown in the following snippet:<p class="source-code">function publish(topic, message) {</p><p class="source-code">    mqtt.send(topic, message, 1, false);</p><p class="source-code">}</p></li>
				<li>Establish<a id="_idIndexMarker507"/> the connection to the MQTT broker, as follows:<p class="source-code">function MQTTconnect() {</p><p class="source-code">    console.log("mqtt client: connecting to " + host + </p><p class="source-code">        ":" + port);</p><p class="source-code">    mqtt = new Paho.MQTT.Client(host, port, cname);</p><p class="source-code">    var options = {</p><p class="source-code">        timeout: 3,</p><p class="source-code">        onSuccess: onConnect,</p><p class="source-code">    };</p><p class="source-code">    mqtt.onConnectionLost = onConnectionLost;</p><p class="source-code">    mqtt.onMessageArrived = onMessageArrived;</p><p class="source-code">    mqtt.connect(options);</p><p class="source-code">}</p></li>
			</ol>
			<p>This is everything we need for our reusable MQTT component. All we need to do when integrating it into projects is this: </p>
			<ol>
				<li value="1">Expose a<a id="_idIndexMarker508"/> <strong class="source-inline">handleMessage()</strong> function in the Go code.</li>
				<li>Set the <strong class="source-inline">hostname, port, and cname</strong> values to the MQTT broker in the JavaScript file.</li>
			</ol>
			<p>The next step is to set up the so-called glue code that connects the JavaScript code with the Go code.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Setting up the Wasm instantiation code</h2>
			<p>The Wasm instantiation <a id="_idIndexMarker509"/>code is nearly the same every time. It only changes if we want to add some project-specific code in it. So, let's quickly create a new file named <strong class="source-inline">wasm.js</strong> inside the <strong class="source-inline">light-control</strong> folder. Now, run the following standard code to initialize a Wasm app inside the new file:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">const WASM_URL = 'wasm.wasm';</p>
			<p class="source-code">var wasm;</p>
			<p class="source-code">function init() {</p>
			<p class="source-code">    const go = new Go();</p>
			<p class="source-code">    if ('instantiateStreaming' in WebAssembly) {</p>
			<p class="source-code">        WebAssembly.instantiateStreaming(fetch(WASM_URL), </p>
			<p class="source-code">                go.importObject).then(function (obj) {</p>
			<p class="source-code">            wasm = obj.instance;</p>
			<p class="source-code">            go.run(wasm);</p>
			<p class="source-code">        })</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        fetch(WASM_URL).then(resp =&gt;</p>
			<p class="source-code">            resp.arrayBuffer()</p>
			<p class="source-code">        ).then(bytes =&gt;</p>
			<p class="source-code">            WebAssembly.instantiate(bytes, </p>
			<p class="source-code">                    go.importObject).then(function (obj) {</p>
			<p class="source-code">                wasm = obj.instance;</p>
			<p class="source-code">                go.run(wasm);</p>
			<p class="source-code">            })</p>
			<p class="source-code">        )</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">init();</p>
			<p>This <a id="_idIndexMarker510"/>is nearly the same code as in <a href="B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135"><em class="italic">Chapter 7</em></a>, <em class="italic">Displaying Weather Alerts on the TinyGo Wasm Dashboard</em>, in the <em class="italic">Implementing the weather app</em> section, but this time we did not include the MQTT client code inside the file. You can use this file for every project beyond this book. </p>
			<p>The next step is to add the <strong class="source-inline">wasm_exec.js</strong> file. We can either download it from the TinyGo GitHub repository or copy it from our local installation. On Unix-based systems, you can use the following command to copy the file:</p>
			<p class="source-code">cp /usr/local/tinygo/targets/wasm_exec.js /path/to/Chapter08/light-control</p>
			<p>The path to the <strong class="source-inline">wasm_exec.js</strong> file is different on Windows. When using the preceding command, you need to insert your own path to the TinyGo installation. The path basically follows this pattern:</p>
			<p class="source-code">/path/to/your/tinygo/installation/target/wasm_exec.js</p>
			<p>That's everything we need in terms of JavaScript code. We can now go on to create our <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) template file.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Creating the HTML template</h2>
			<p>In <a href="B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135"><em class="italic">Chapter 7</em></a>, <em class="italic">Displaying Weather Alerts on the TinyGo Wasm Dashboard</em>, in the<em class="italic"> Implementing the weather app</em> section, we <a id="_idIndexMarker511"/>defined our base structure inside the HTML file, but this time our HTML template is going to be much shorter. We are only going to include the needed header and define an empty body element as we are going to create all HTML elements dynamically using DOM manipulation from inside the Go code. </p>
			<p>To do so, create a new file named <strong class="source-inline">index.html</strong> inside the <strong class="source-inline">light-control</strong> folder. The body element needs to get an <strong class="source-inline">id</strong> value as we are going to identify the element using the ID. We also import all needed JavaScript files in the header. This is what it will look like:</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">    &lt;meta charset="utf-8" /&gt;</p>
			<p class="source-code">    &lt;title&gt;TinyGo Home Automation&lt;/title&gt;</p>
			<p class="source-code">    &lt;meta name="viewport" content="width=device-width,</p>
			<p class="source-code">        initial-scale=1" /&gt;</p>
			<p class="source-code">    &lt;script src="wasm_exec.js" </p>
			<p class="source-code">        type="text/javascript"&gt;&lt;/script&gt;</p>
			<p class="source-code">    &lt;script src="wasm.js" type="text/javascript"&gt;&lt;/script&gt;</p>
			<p class="source-code">    &lt;script src="mqtt.js" type="text/javascript"&gt;&lt;/script&gt;</p>
			<p class="source-code">    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/paho-</p>
			<p class="source-code">        mqtt/1.0.1/mqttws31.min.js" </p>
			<p class="source-code">        type="text/javascript"&gt;&lt;/script&gt;</p>
			<p class="source-code">&lt;/head&gt;</p>
			<p class="source-code">&lt;body id="body-component"&gt;&lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>That's <a id="_idIndexMarker512"/>everything we need for the HTML template. The next step is writing the login view.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Implementing the login view logic</h2>
			<p>The<a id="_idIndexMarker513"/> login component needs to add the login view to the HTML document and also implement logic to handle the user input. Let's create a new folder named <strong class="source-inline">login</strong> inside the <strong class="source-inline">light-control</strong> folder and create a new file named <strong class="source-inline">userinfo.go</strong> inside the newly created folder.</p>
			<p>The <strong class="source-inline">userinfo.go</strong> file simply holds the <strong class="source-inline">UserInfo</strong> element, which looks like this:</p>
			<p class="source-code">type UserInfo struct {</p>
			<p class="source-code">    LoggedIn bool</p>
			<p class="source-code">    UserName string</p>
			<p class="source-code">    LoggedInAt time.Time</p>
			<p class="source-code">}</p>
			<p>Now, we create a new <strong class="source-inline">login.go</strong> file inside the <strong class="source-inline">login</strong> folder and implement the view by following these steps:</p>
			<ol>
				<li value="1">We need username and password values for the login, so we define them as follows:<p class="source-code">const user = "tinygo"</p><p class="source-code">const password = "secure1234"</p></li>
				<li>We only need to fetch the document a single time, so we just store it inside a package-level variable, as follows:<p class="source-code">var doc = tinydom.GetDocument()</p></li>
				<li>Now, we define a service that only needs to hold a channel. The channel is later being used to propagate the logged-in username to the other components. The code is shown in the following snippet:<p class="source-code">type Service struct {</p><p class="source-code"><strong class="bold">    channel chan string</strong></p><p class="source-code">}</p></li>
				<li>We define a constructor function that accepts a channel and returns a new instance of <strong class="source-inline">Service</strong>, as follows:<p class="source-code">func NewService(channel chan string) *Service {</p><p class="source-code">    return &amp;Service{channel: channel}</p><p class="source-code">}</p></li>
				<li>The <a id="_idIndexMarker514"/>next step is to implement the logic to create the view. We want to simulate having a multipage app by telling the browser to change the <strong class="bold">Uniform Resource Locator </strong>(<strong class="bold">URL</strong>) by pushing a new state. The code to do this is shown in the following snippet:<p class="source-code">func (service *Service) RenderLogin() {</p><p class="source-code">    tinydom.GetWindow().PushState(nil, "login", "/login")</p></li>
				<li>We now create a new <strong class="source-inline">div</strong> tag that is going to hold all subsequent elements, as follows: <p class="source-code">div := doc.CreateElement("div").</p><p class="source-code">       SetId("login-component")</p></li>
				<li>We then set an <strong class="source-inline">h1</strong> that also tells the user the name of the component, as follows:<p class="source-code">h1 := doc.CreateElement("h1").</p><p class="source-code">      SetInnerHTML("Login")</p></li>
				<li>Now, we create a form that holds the input fields. So, we simply create a new instance of <strong class="source-inline">form</strong> and also create a new <strong class="source-inline">userName</strong> input field with the corresponding label, which works as follows:<p class="source-code">loginForm := form.New()</p><p class="source-code">userNameLabel := label.</p><p class="source-code">      New().</p><p class="source-code">      SetFor("userName").</p><p class="source-code">      SetInnerHTML("UserName:")</p><p class="source-code">userName := input.</p><p class="source-code">      New(input.TextInput).</p><p class="source-code">      SetId("userName")</p></li>
				<li>We now <a id="_idIndexMarker515"/>want to add an input field of type <strong class="source-inline">password</strong> that obscures the input. To do this, run the following code:<p class="source-code">passwordLabel := label.</p><p class="source-code">      New().</p><p class="source-code">      SetFor("password").</p><p class="source-code">      SetInnerHTML("Password:")</p><p class="source-code">password := input.</p><p class="source-code">      New(input.PasswordInput).</p><p class="source-code">      SetId("password")</p></li>
				<li>As we now have both input fields, we need a button that emits <strong class="source-inline">click</strong> and <strong class="source-inline">keyPress</strong> events that we can use to trigger the <strong class="source-inline">login</strong> logic. Here is the code we run to do this:<p class="source-code">login := input.New(input.ButtonInput).</p><p class="source-code">      SetValue("login").</p><p class="source-code"><strong class="bold">      AddEventListener("click", </strong></p><p class="source-code"><strong class="bold">          js.FuncOf(service.onClick)).</strong></p><p class="source-code"><strong class="bold">      AddEventListener("keypress", </strong></p><p class="source-code"><strong class="bold">          js.FuncOf(service.onKeyPress))</strong></p></li>
				<li>We have <a id="_idIndexMarker516"/>now created all components that we need inside our <strong class="source-inline">loginForm</strong>, so we can go on and append them to <strong class="source-inline">loginForm</strong>, as follows:<p class="source-code">loginForm.AppendChildrenBr(</p><p class="source-code">      userNameLabel,</p><p class="source-code">      userName,</p><p class="source-code">      passwordLabel,</p><p class="source-code">      password,</p><p class="source-code">      login,</p><p class="source-code">)</p></li>
				<li>The last thing to do is to append the previous element to the <strong class="source-inline">div</strong>. We append everything inside a <strong class="source-inline">div</strong> so that we can easily delete the elements again. In order to display the newly created elements, we just append the <strong class="source-inline">div</strong> in the body, as follows:<p class="source-code">div.AppendChildren(h1, loginForm.Element)</p><p class="source-code">body := doc.GetElementById("body-component")</p><p class="source-code">body.AppendChild(div)</p><p class="source-code">}</p></li>
			</ol>
			<p>We can now create the view itself. The only thing missing here is the logic to handle <strong class="source-inline">EventListener</strong> from the <strong class="source-inline">login</strong> button, as well as the login logic itself. To do so, follow these last few steps for this component:</p>
			<ol>
				<li value="1">When the<a id="_idIndexMarker517"/> user clicks on the <strong class="source-inline">login</strong> button, we simply want to attempt a login. The following code snippet illustrates this:<p class="source-code">func (service *Service) onClick(this js.Value, args </p><p class="source-code">        []js.Value) interface{} {</p><p class="source-code">    service.login()</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>When the input button is focused and the user hits the <em class="italic">Enter</em> button, we also want to attempt a login. We wrap the event <strong class="source-inline">args</strong> into a <strong class="source-inline">tinydom</strong> event that provides us with convenience functions, as illustrated in the following code snippet:<p class="source-code">func (service *Service) onKeyPress(this js.Value, args </p><p class="source-code">        []js.Value) interface{} {</p><p class="source-code">    if len(args) != 1 {</p><p class="source-code">        println("bad number of arguments in keyPress </p><p class="source-code">            event")</p><p class="source-code">        return nil</p><p class="source-code">    }</p><p class="source-code"><strong class="bold">    event := tinydom.Event{Value: args[0]}</strong></p><p class="source-code">    if event.Key() == "Enter" {</p><p class="source-code">        service.login()</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">login</strong> function fetches the input from the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> input fields and compares them to our defined credentials. When invalid credentials are found, we trigger an alert. The most important bit in this function is the need to wrap the call that writes into the channel inside a goroutine. If we <a id="_idIndexMarker518"/>did not wrap a goroutine around it, the code could not compile. Refer to the following code:<p class="source-code">func (service *Service) login() {</p><p class="source-code">    userElem := input.FromElement(</p><p class="source-code">        doc.GetElementById("userName"))</p><p class="source-code">    userName := userElem.Value()</p><p class="source-code">    if userName != user {</p><p class="source-code">        tinydom.GetWindow().Alert("Invalid username or </p><p class="source-code">            password")</p><p class="source-code">        return</p><p class="source-code">    }</p><p class="source-code">    passwordElem := input.FromElement(</p><p class="source-code">        doc.GetElementById("password"))</p><p class="source-code">    passwordInput := passwordElem.Value()</p><p class="source-code">    if passwordInput != password {</p><p class="source-code">        tinydom.GetWindow().Alert("Invalid username or </p><p class="source-code">            password")</p><p class="source-code">        return</p><p class="source-code">    }</p><p class="source-code"><strong class="bold">    go func() {</strong></p><p class="source-code"><strong class="bold">        service.channel &lt;- userName</strong></p><p class="source-code"><strong class="bold">    }()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Excellent! We have <a id="_idIndexMarker519"/>completed the login component. But what would this view look like in a browser? Let's check the following screenshot to find out:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="Images/Figure_8.2_B16555.jpg" alt="Figure 8.2 – Login view rendered by a browser&#13;&#10;" width="268" height="205"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Login view rendered by a browser</p>
			<p>Before we<a id="_idIndexMarker520"/> implement the dashboard component, we have to talk about some security aspects of this login component. We have defined the credentials that are needed to log in inside the code. This code is going to be downloaded by the browser in the form of a Wasm binary file. As we provide the code that includes the credentials to the client, this procedure is considered unsecure. Let's have a look at the following screenshot that shows a part of the Wasm binary:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="Images/Figure_8.3_B16555.jpg" alt="Figure 8.3 – Credentials leaked in binary file&#13;&#10;" width="386" height="21"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Credentials leaked in binary file</p>
			<p>To find the credentials inside the Wasm binary, I simply opened the binary in a text editor and searched for the password. So, what other possibilities do we have to keep credentials safe? Here are a couple of options:</p>
			<ul>
				<li>Make an HTTP call to a <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) that validates credentials.</li>
				<li>Use any JavaScript library that is able to talk to an <strong class="bold">Open Authorization 2</strong> (<strong class="bold">OAuth 2</strong>) service.</li>
			</ul>
			<p>There might be plenty of other possibilities, but they all boil down to moving the actual credential validation logic to any kind of external API. But for our scope, this solution is good enough to validate the credentials inside the client. The next step is to implement the dashboard component.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Implementing the dashboard component</h2>
			<p>We are now going to <a id="_idIndexMarker521"/>implement our home automation dashboard. The dashboard is going to hold a list of components with associated actions that are represented by buttons. We also want to log out the user after a 5-minute period of inactivity. Before we dive into the code, we need to create a new folder named <strong class="source-inline">dashboard</strong> inside the <strong class="source-inline">light-control</strong> folder and create a new <strong class="source-inline">dashboard.go</strong> file inside. Now, follow these steps to implement the logic:</p>
			<ol>
				<li value="1">We save a reference to the current document, as follows:<p class="source-code">var doc = tinydom.GetDocument()</p></li>
				<li>The service object holds a channel that we use to signal a logout. The <strong class="source-inline">UserInfo</strong> object will later be used to check <strong class="source-inline">loginTime</strong>, which will be used as an inactivity timer. We also get <strong class="source-inline">UserName</strong> from <strong class="source-inline">UserInfo</strong>. The code is shown in the following snippet:<p class="source-code">type Service struct {</p><p class="source-code">    user login.UserInfo</p><p class="source-code">    logoutChannel chan struct{</p><p class="source-code">}</p><p>The constructor function needs to get the channel injected as we react to logout events that are being sent to the channel from the <strong class="source-inline">wasm.go</strong> file. The code is shown in the following snippet:</p><p class="source-code">func New(logout chan struct{}) *Service {</p><p class="source-code">    return &amp;Service{</p><p class="source-code">        logoutChannel: logout,</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We want to be able to trigger a connection attempt to the MQTT broker from inside the Go code, so we call the <strong class="source-inline">js</strong> function that resides inside the <strong class="source-inline">mqtt.js</strong> file, as follows:<p class="source-code">func (service *Service) ConnectMQTT() {</p><p class="source-code">    println("connecting to mqtt")</p><p class="source-code"><strong class="bold">    js.Global().</strong></p><p class="source-code"><strong class="bold">        Get("MQTTconnect").</strong></p><p class="source-code"><strong class="bold">        Invoke()</strong></p><p class="source-code">}</p></li>
				<li>Now, we define a function that can be used as a callback to an eventListener. As this function<a id="_idIndexMarker522"/> is being called from within JavaScript, we need to fulfill a function signature that takes <strong class="source-inline">js.Value</strong> and a <strong class="source-inline">[]js.Value</strong> parameters and returns <strong class="source-inline">interface{}</strong>, as follows:<p class="source-code">func (service *Service) logout(<strong class="bold">this js.Value, args </strong></p><p class="source-code"><strong class="bold">        []js.Value) interface{}</strong> {</p><p class="source-code">    service.logoutChannel &lt;- struct{}{}</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">bedroomOn</strong> function is being used as callback for the JavaScript code and will be called when the user clicks the <strong class="source-inline">On</strong> button. The code is shown in the following snippet:<p class="source-code">func (service *Service) bedroomOn(this js.Value, args </p><p class="source-code">    []js.Value) interface{} {</p></li>
				<li>When the user performs any action, we need to check if the activity timer timed out. We do so by checking the <strong class="source-inline">loggedInAt</strong> timestamp. If the user is inactive for more than 5 minutes we perform a logout, as follows:<p class="source-code">if time.Now().After(service.user.LoggedInAt.Add(5 * </p><p class="source-code">        time.Minute)) {</p><p class="source-code">    println("timeOut: perform logout")</p><p class="source-code">    service.logout(js.ValueOf(nil), nil</p><p class="source-code">    )return nil</p><p class="source-code">}</p></li>
				<li>Now, we<a id="_idIndexMarker523"/> simply need to invoke the <strong class="source-inline">publish</strong> function in the JavaScript code and reset the <strong class="source-inline">loggedInAt</strong> timer, as follows:<p class="source-code">println("turning lights on")</p><p class="source-code">// room # module # action</p><p class="source-code">js.Global().Get("publish").Invoke("home/bedroom/lights", </p><p class="source-code">    "on")</p><p class="source-code">service.user.LoggedInAt = time.Now()</p><p class="source-code">return nil</p></li>
				<li>Turning the lights off works in a similar way to turning them on. The only difference is the payload of the message. We send <strong class="source-inline">off</strong> instead of <strong class="source-inline">on</strong> here, which looks like this:<p class="source-code">func (service *Service) bedroomOff(this js.Value, args </p><p class="source-code">    []js.Value) interface{} {</p><p class="source-code">    if time.Now().After(service.user.LoggedInAt.Add(5 *</p><p class="source-code">            time.Minute)) {</p><p class="source-code">        println("timeOut: perform logout")</p><p class="source-code">        service.logout(js.ValueOf(nil), nil)</p><p class="source-code">        return nil</p><p class="source-code">    }</p><p class="source-code">    println("turning lights off")</p><p class="source-code">    js.Global().Get("publish").Invoke("home/bedroom</p><p class="source-code">        /lights","<strong class="bold">off</strong>")</p><p class="source-code">    service.user.LoggedInAt = time.Now()</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
			</ol>
			<p>We have<a id="_idIndexMarker524"/> successfully implemented the complete control logic. Now, we need to implement the logic that creates the view. These are the necessary steps to do this:</p>
			<ol>
				<li value="1">When we create the dashboard view, we have information about which user just logged in, so we store this as follows:<p class="source-code">func (service *Service) RenderDashboard(user </p><p class="source-code">        login.UserInfo) {</p><p class="source-code">    service.user = user</p></li>
				<li>Just as in the login view, we tell the browser to display another URL by pushing a new state, as follows:<p class="source-code">tinydom.GetWindow().</p><p class="source-code">    PushState(nil, "dashboard", "/dashboard")</p></li>
				<li>We create a new <strong class="source-inline">div</strong> element and set an <strong class="source-inline">Id</strong> value so that we can identify the element later on, to remove it when logging out. The code is shown in the following snippet:<p class="source-code">body := doc.GetElementById("body-component")</p><p class="source-code">div := doc.CreateElement("div").</p><p class="source-code">        SetId("dashboard-component")</p></li>
				<li>We now greet the user by their name, as follows:<p class="source-code">h1 := doc.CreateElement("h1").</p><p class="source-code">        SetInnerHTML("Dashboard")</p><p class="source-code">h2 := doc.CreateElement("h2").</p><p class="source-code">        SetInnerHTML(fmt.Sprintf("Hello %s", </p><p class="source-code">            service.user.UserName))</p></li>
				<li>As we want<a id="_idIndexMarker525"/> to have a way to easily add new components to the dashboard, we use a table to control the components. That way, we can simply add new table rows later on. Of course, we could also create new custom components or use any other kind of structure, but adding rows to a table is easy to understand. The whole process looks like this:<p class="source-code">tableElement := table.New().</p><p class="source-code">    SetHeader("Component", "Actions")</p><p class="source-code">tbody := doc.CreateElement("tbody")</p><p class="source-code">tr := doc.CreateElement("tr")</p><p class="source-code">componentNameElement := doc.CreateElement("td").</p><p class="source-code">    SetInnerHTML("Bedroom Lights")</p><p class="source-code">componentControlElement := doc.CreateElement("td")</p><p class="source-code">onButton := input.New(input.ButtonInput).</p><p class="source-code">    SetValue("On").</p><p class="source-code">    AddEventListener("click", </p><p class="source-code">        js.FuncOf(service.bedroomOn))</p><p class="source-code">offButton := input.New(input.ButtonInput).</p><p class="source-code">    SetValue("Off").</p><p class="source-code">    AddEventListener("click", </p><p class="source-code">        js.FuncOf(service.bedroomOff))</p><p class="source-code">componentControlElement.AppendChildren(onButton, </p><p class="source-code">    offButton)</p><p class="source-code">tr.AppendChildren(componentNameElement, </p><p class="source-code">    componentControlElement)</p><p class="source-code">tbody.AppendChildren(tr)</p><p class="source-code">tableElement.SetBody(tbody)</p></li>
				<li>Besides a<a id="_idIndexMarker526"/> logout based on inactivity, we want the user to have the possibility to log out manually. Here's how to set this up:<p class="source-code">logout := input.New(input.ButtonInput).</p><p class="source-code">    SetValue("logout").</p><p class="source-code">    AddEventListener("click", js.FuncOf(service.logout),</p><p class="source-code">)</p></li>
				<li>The last steps append all child elements to the <strong class="source-inline">div</strong> and append the <strong class="source-inline">div</strong> to the body, as illustrated in the following code snippet:<p class="source-code">div.AppendChildren(</p><p class="source-code">    h1,</p><p class="source-code">    h2,</p><p class="source-code">    tableElement.Element,</p><p class="source-code">    tinydom.GetDocument().CreateElement("br"),</p><p class="source-code">    logout,</p><p class="source-code">)</p><p class="source-code">body.AppendChild(div)</p><p class="source-code">}</p></li>
			</ol>
			<p>Great! We <a id="_idIndexMarker527"/>have now fully implemented the logic that is needed to create the view. When rendered by a browser, the view looks similar to this:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="Images/Figure_8.4_B16555.jpg" alt="Figure 8.4 – Dashboard view&#13;&#10;" width="289" height="216"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Dashboard view</p>
			<p>Now, we only need to implement the main logic before the app itself is complete.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Implementing the main logic</h2>
			<p>We are<a id="_idIndexMarker528"/> going to split the logic for the different components (login, dashboard) into separate files. The <strong class="source-inline">wasm.go</strong> file, which we now create inside the <strong class="source-inline">light-control</strong> folder, is going to hold the <strong class="source-inline">main()</strong> function and is used to control the flow through the app. </p>
			<p>We are now going to introduce a new library called <strong class="source-inline">tinydom</strong>. The <strong class="source-inline">tinydom</strong> library wraps the <strong class="source-inline">syscall/js</strong> API and also provides additional data types such as <strong class="source-inline">Video</strong>, <strong class="source-inline">Form</strong>, or <strong class="source-inline">Label</strong>. Using this library, we can save lots of <strong class="bold">lines of code</strong> (<strong class="bold">LOC</strong>). As <strong class="source-inline">tinydom</strong> works on <strong class="source-inline">js.Value</strong> types internally, it is fully interoperable with the <strong class="source-inline">syscall/js</strong> API. You can install <strong class="source-inline">tinydom</strong> using the following command: </p>
			<p class="source-code">go get github.com/Nerzal/tinydom</p>
			<p>As this is now set up, let's go on to implement the logic by following these steps:</p>
			<ol>
				<li value="1">Above the <strong class="source-inline">main</strong> function, we define some variables. We define them outside of the <strong class="source-inline">main</strong> function as we are going to need them inside the functions. The code is shown in the following snippet:<p class="source-code">var window = tinydom.GetWindow()</p><p class="source-code">var loginService *login.Service</p><p class="source-code">var loginState login.UserInfo</p><p class="source-code">var dashboardService dashboard.Service</p></li>
				<li>We use the <strong class="source-inline">main</strong> function to render the login screen, as well as setting up the login and logout event handler. This is done as follows:<p class="source-code">func main() {</p><p class="source-code">    loginState = login.UserInfo{}</p><p class="source-code">    loginChannel := make(chan string, 1)</p><p class="source-code">    loginService = login.NewService(loginChannel)</p><p class="source-code">    loginService.RenderLogin()</p><p class="source-code">    go onLogin(loginChannel)</p><p class="source-code">    logoutChannel := make(chan  struct{}, 1)</p><p class="source-code">    go onLogout(logoutChannel)</p><p class="source-code">    dashboardService = dashboard.New(logoutChannel)</p><p class="source-code">    wait := make(chan struct{}, 0)</p><p class="source-code">    &lt;-wait</p><p class="source-code">}</p></li>
				<li>When<a id="_idIndexMarker529"/> receiving a login event from the channel, we initialize <strong class="source-inline">loginState</strong>, connect to MQTT, and render the dashboard view, as follows:<p class="source-code">func onLogin(channel chan string) {</p><p class="source-code">    for {</p><p class="source-code">        userName := &lt;-channel</p><p class="source-code">        println(userName, "logged in!")</p><p class="source-code">        loginState.UserName = username</p><p class="source-code">        loginState.LoggedIn = true</p><p class="source-code">        loginState.LoggedInAt = time.Now()</p><p class="source-code">        removeLoginComponent()</p><p class="source-code">        dashboardService.ConnectMQTT()</p><p class="source-code">        dashboardService.RenderDashboard(loginState)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In order to remove an object from the view, we simply remove it from the DOM. We do so by fetching the body element and removing the child with the <strong class="source-inline">login-component</strong> ID, as follows:<p class="source-code">func removeLoginComponent() {</p><p class="source-code">    doc := tinydom.GetDocument()</p><p class="source-code"><strong class="bold">    doc.GetElementById("body-component").</strong></p><p class="source-code"><strong class="bold">        RemoveChild(doc.GetElementById(</strong></p><p class="source-code"><strong class="bold">            "login-component"))</strong></p><p class="source-code">}</p></li>
				<li>We also<a id="_idIndexMarker530"/> want to be able to remove the dashboard view to be able to go back to the login view. We do this by running the following code:<p class="source-code">func removeDashboardComponent() {</p><p class="source-code">    doc := tinydom.GetDocument()</p><p class="source-code">    doc.GetElementById("body-component").</p><p class="source-code">        RemoveChild(doc.GetElementById(</p><p class="source-code">            "dashboard-component"))</p><p class="source-code">}</p></li>
				<li>When we receive a logout event from the channel, we remove the dashboard view, reset the login state, and render the login view again, as follows:<p class="source-code">func onLogout(channel chan struct{}) {</p><p class="source-code">    for {</p><p class="source-code">        &lt;-channel</p><p class="source-code">        println("handling logout event")</p><p class="source-code">        removeDashboardComponent()</p><p class="source-code">        loginState = login.UserInfo{}</p><p class="source-code">        loginService.RenderLogin()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>That's <a id="_idIndexMarker531"/>everything we need for our main logic. The next step is to implement a server that serves the app to clients.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Serving the app</h2>
			<p>Serving the<a id="_idIndexMarker532"/> app works in a similar way to serving the app in <a href="B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135"><em class="italic">Chapter 7</em></a>, <em class="italic">Displaying Weather Alerts on the TinyGo Wasm Dashboard</em>, but we add an extra trick in here. When the user refreshes the page or tries to visit one of the URLs that we set by pushing a state, the server would normally be unaware of these URLs. That's why we redirect the client to the correct URL. We handle that case by simply redirecting the user to the root URL. </p>
			<p>Now, add the following code into a <strong class="source-inline">main.go</strong> file that resides in a newly created folder named <strong class="source-inline">wasm-server</strong>, which is inside the <strong class="source-inline">Chapter08</strong> folder:</p>
			<p class="source-code">const dir = "Chapter08/html"</p>
			<p class="source-code">var fs = http.FileServer(http.Dir(dir))</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    log.Print("Serving " + dir + " on http://localhost:8080")</p>
			<p class="source-code">    http.ListenAndServe(":8080", </p>
			<p class="source-code">        http.HandlerFunc(handleRequest))</p>
			<p class="source-code">}</p>
			<p class="source-code">func handleRequest(</p>
			<p class="source-code">        resp http.ResponseWriter, req *http.Request) {</p>
			<p class="source-code">    resp.Header().Add("Cache-Control", "no-cache")</p>
			<p class="source-code">    if strings.HasSuffix(req.URL.Path, ".wasm") {</p>
			<p class="source-code">        resp.Header().Set("content-type", "application/wasm")</p>
			<p class="source-code">    }</p>
			<p class="source-code">    requestURI := req.URL.RequestURI()</p>
			<p class="source-code">    if strings.Contains(requestURI, "dashboard") ||</p>
			<p class="source-code">        strings.Contains(requestURI, "login") {</p>
			<p class="source-code">        http.Redirect(resp, req, "http://localhost:8080", </p>
			<p class="source-code">            http.StatusMovedPermanently)</p>
			<p class="source-code">        return</p>
			<p class="source-code">}</p>
			<p class="source-code">fs.ServeHTTP(resp, req)</p>
			<p class="source-code">}</p>
			<p>We have<a id="_idIndexMarker533"/> completed the app and the server that serves the app. Let's now build and run everything. We will be using a <strong class="bold">Makefile</strong> for this example, but you could also use a Docker container, a shell script, or something similar. We need to build the Wasm app, copy all dependencies, and start the server. The Makefile approach looks like this:</p>
			<p class="source-code">light-control:</p>
			<p class="source-code">rm -rf Chapter08/html</p>
			<p class="source-code">mkdir Chapter08/html</p>
			<p class="source-code">tinygo build -o Chapter08/html/wasm.wasm -target wasm -no-debug Chapter08/light-control/wasm.go</p>
			<p class="source-code">cp Chapter08/light-control/wasm_exec.js Chapter08/html/</p>
			<p class="source-code">cp Chapter08/light-control/wasm.js Chapter08/html/</p>
			<p class="source-code">cp Chapter08/light-control/mqtt.js Chapter08/html/</p>
			<p class="source-code">cp Chapter08/light-control/index.html Chapter08/html/</p>
			<p class="source-code">go run Chapter08/wasm-server/main.go</p>
			<p>In order to run the server, we use the following command:</p>
			<p class="source-code">make light-control</p>
			<p>When this is<a id="_idIndexMarker534"/> successful, go on and try out our app by visiting the following URL in a browser:</p>
			<p class="source-code">localhost:8080</p>
			<p>When using the Mosquitto Docker container, don't forget to check that the container has been started and that the container does not run. Simply start it by using the following command:</p>
			<p class="source-code">docker start mosquitto</p>
			<p>As we have now successfully built a Wasm app that is able to publish messages to an MQTT broker, we can now go on and create a client that consumes these messages, and this is exactly what we are going to do in the next section.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Building the home automation client</h1>
			<p>Home <a id="_idIndexMarker535"/>automation basically consists of <em class="italic">activating and deactivating things</em> based on a <em class="italic">precondition</em>. For example, we might want to turn on a light when someone enters a room at night. Throughout this book, we have activated and deactivated many things based on preconditions, but most of them were not connected to a network. We are now going to learn how we can send signals over a network. These signals are going to be used as preconditions. After completing this section, we will be fully prepared for building our own home automation clients that can be triggered over a network. </p>
			<p>The client that is going to run on the Arduino Nano 33 IoT is simply going to connect to an MQTT broker and then subscribe to a topic. When a message comes in for the topic, we need to deserialize the message and perform the action that is defined in the message. </p>
			<p>For our<a id="_idIndexMarker536"/> example project, we are going to turn an LED on and off. Of course, a single LED might not be enough to light up a complete bedroom, so we will talk about other real-world solutions at the end of this section. Let's start by setting up the circuit.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>Setting up the circuit</h2>
			<p>The circuit for this<a id="_idIndexMarker537"/> project is fairly simple. Just follow these steps to set everything up:</p>
			<ol>
				<li value="1">Place an LED with the cathode in <em class="italic">E40</em> on the breadboard.</li>
				<li>Connect A41 (<em class="italic">GND</em>) with the <em class="italic">GND</em> lane on the power bus.</li>
				<li>Connect the anode of the LED with pin D4 and place a 68 Ohm resistor in between. If you don't have a 68 Ohm resistor, you can also use a 100 Ohm one. Connect <em class="italic">B52</em> with the <em class="italic">GND</em> lane on the power bus.</li>
			</ol>
			<p>The result should look similar to this:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="Images/Figure_8.5_B16555.jpg" alt="Figure 8.5 – Light control circuit (image is taken from Fritzing)&#13;&#10;" width="1640" height="598"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Light control circuit (image is taken from Fritzing)</p>
			<p>If you are unsure which technical specs your LEDs have because you simply do not have a datasheet, have a look at the following URL. This provides a resistor calculator, as well as good voltages<a id="_idIndexMarker538"/> for different LED colors: </p>
			<p><a href="https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor">https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor</a></p>
			<p>Great! We are now all set up and ready to implement the logic.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor162"/>Implementing the logic</h2>
			<p>For our <a id="_idIndexMarker539"/>final project, we need to create a new folder named <strong class="source-inline">light-control-client</strong> inside the <strong class="source-inline">Chapter08</strong> folder and create a new <strong class="source-inline">main.go</strong> file inside. The logic of the <strong class="source-inline">main</strong> function is just used to initialize everything, while the actual logic is going to reside in separate functions. To implement it, follow these steps:</p>
			<ol>
				<li value="1">Above the main function, we add constants for the Wi-Fi credentials and the LED pin. We simply need to replace the SSID and password with our own data, which looks like this:<p class="source-code">const ssid = ""</p><p class="source-code">const password = ""</p><p class="source-code">const bedroomLight = machine.D4</p></li>
				<li>Now, inside the main function, we want to control the LED. To do so, we need to configure the pin as output, as shown in the following code snippet:<p class="source-code">time.Sleep(5 * time.Second)</p><p class="source-code">bedroomLight.Configure(machine.PinConfig{Mode: </p><p class="source-code">    machine.PinOutput})</p></li>
				<li>The next step is to establish the Wi-Fi connection, as seen in the following code snippet: <p class="source-code">wifiClient := wifi.New(ssid, password)</p><p class="source-code">println("configuring nina wifi chip")</p><p class="source-code">err := wifiClient.Configure()</p><p class="source-code">if err != nil {</p><p class="source-code">    printError("could not configure wifi client", err)</p><p class="source-code">}</p><p class="source-code">println("checking firmware")</p><p class="source-code">wifiClient.CheckHardware()</p><p class="source-code">wifiClient.ConnectWifi()</p></li>
				<li>Now, we <a id="_idIndexMarker540"/>need to connect to the MQTT broker. You need to replace the IP address with the IP address of your MQTT broker, as follows:<p class="source-code">mqttClient := mqttclient.New("<strong class="bold">tcp://192.168.2.102:1883</strong>", </p><p class="source-code">    "lightControl")</p><p class="source-code">println("connecting to mqtt broker")</p><p class="source-code">err = mqttClient.ConnectBroker()</p><p class="source-code">if err != nil {</p><p class="source-code">    printError("could not configure mqtt", err)</p><p class="source-code">}</p><p class="source-code">println("connected to mqtt broker")</p></li>
				<li>In order to subscribe to a topic, we need to hand in the QOS level and a function that is called when a message on that topic arrives, which looks like this:<p class="source-code">err = mqttClient.Subscribe(</p><p class="source-code">      "home/bedroom/lights", </p><p class="source-code">      0, </p><p class="source-code">      HandleActionMessage,</p><p class="source-code">)</p><p class="source-code">if err != nil {</p><p class="source-code">printError("could not subscribe to topic", err)</p><p class="source-code">}</p></li>
				<li>The last <a id="_idIndexMarker541"/>step is to add in a blocking function so that the program does not terminate, which can be seen in the following code snippet:<p class="source-code">println("subscribed to topic, waiting for messages")</p><p class="source-code">select {}</p></li>
			</ol>
			<p>That's all we need to initialize everything. We now only need to implement the logic that handles the incoming messages. To do so, follow these steps:</p>
			<ol>
				<li value="1">First, we need to deserialize the incoming message by splitting the string, and then call functions depending on the room that is being delivered. If we receive an invalid message or finish handling the message, we <strong class="source-inline">Ack</strong> the message, as follows:<p class="source-code">func HandleActionMessage(client mqtt.Client, message </p><p class="source-code">        mqtt.Message) {</p><p class="source-code">    println("handling incoming message")</p><p class="source-code">    payload := string(message.Payload())</p><p class="source-code">    controlBedroom(client, payload)</p><p class="source-code"><strong class="bold">    message.Ack()</strong></p><p class="source-code">}</p></li>
				<li>In the next step, we simply execute the correct functions based on the module and action provided. The complete function is implemented in the following snippet:<p class="source-code">func controlBedroom(module, action string) {</p><p class="source-code">    switch action {</p><p class="source-code">    case "on":</p><p class="source-code">        controlBedroomlights(client, true)</p><p class="source-code">    case "off":</p><p class="source-code">        controlBedroomlights(client, false)</p><p class="source-code">    default:</p><p class="source-code">        println("unknown action:", action)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, we<a id="_idIndexMarker542"/> just need to activate or deactivate the LED, as follows:<p class="source-code">func controlBedroomlights(action bool) {</p><p class="source-code">    if action {</p><p class="source-code">        bedroomLight.High()</p><p class="source-code">    } else {</p><p class="source-code">        bedroomLight.Low()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We want to stop the execution and print the error repeated, while initializing everything. For that case, we use the following helper function:<p class="source-code">func printError(message string, err error) {</p><p class="source-code">    for {</p><p class="source-code">        println(message, err.Error())</p><p class="source-code">        time.Sleep(time.Second)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>That's everything we need to implement the client. We can now go on and flash the program, using the following command:</p>
			<p class="source-code">tinygo flash --target arduino-nano33 Chapter08/light-control-client/main.go</p>
			<p>While the <a id="_idIndexMarker543"/>program is running, we are now able to turn the LED on and off using the Wasm app. So, now go on and try that.</p>
			<p>Okay—you tried that; everything is working as expected and now you want to know what's next. What if something went wrong and the LED never activates or deactivates?</p>
			<p>In such a case, I highly recommend watching the output of the serial port in PuTTY. If everything looks fine there, the next thing you can try is to send MQTT messages to the broker by using MQTT Explorer. If you still have no luck, you should double-check your wiring; and if nothing else helps, you might want to try to directly flash the code from the GitHub repository.</p>
			<p>Now that everything is working as intended, you might think that <em class="italic">only</em> being able to activate and deactivate the light is nice, but what about displaying the current status of the light on the dashboard? Let's do this as a next step.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor163"/>Requesting data from the microcontroller</h1>
			<p>We might<a id="_idIndexMarker544"/> want to know if the light is currently<a id="_idIndexMarker545"/> turned on or off inside the living room, without having to walk all the way into the room. So, it would be great if the Wasm app <em class="italic">could request the status of the light</em> and display it. </p>
			<p>Now, let's imagine we have one or multiple microcontrollers in different rooms, listening to messages. For this example, we do not want the microcontroller to continuously report the state of the light as this would cause unnecessary network traffic. So, we go on and send a message to request the data. The microcontrollers are subscribed to the status topic and get the message delivered. After receiving the status request, they answer it by each sending a status message.</p>
			<p>This<a id="_idIndexMarker546"/> process is represented in the following <a id="_idIndexMarker547"/>diagram:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="Images/Figure_8.6_B16555.jpg" alt="Figure 8.6 – Architecture diagram&#13;&#10;" width="867" height="582"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Architecture diagram</p>
			<p>In order to implement that behavior, one microcontroller is sufficient. So, let's go on and update our code accordingly. To do so, follow these steps:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">wasm.js</strong> file, we subscribe to the <strong class="source-inline">home/status</strong> topic. This is the topic in which the microcontrollers are going to publish status messages. We also want to call a <strong class="source-inline">go</strong> function when the connection has been established. Refer to the following code:<p class="source-code">function onConnect() {</p><p class="source-code">    console.log("Successfully connected to mqtt broker");</p><p class="source-code"><strong class="bold">    mqtt.subscribe("home/status")</strong></p><p class="source-code"><strong class="bold">    handleOnConnect()</strong></p><p class="source-code">}</p></li>
				<li>Inside <a id="_idIndexMarker548"/>the <strong class="source-inline">dashboard.go</strong> file, we add a <strong class="source-inline">Boolean</strong> to save<a id="_idIndexMarker549"/> the status of the bedroom lights inside the <strong class="source-inline">Service</strong> struct, as follows:<p class="source-code">type Service struct {</p><p class="source-code">    user login.UserInfo</p><p class="source-code"><strong class="bold">    bedroomLights bool</strong></p><p class="source-code">    logoutChannel chan bool</p><p class="source-code">}</p></li>
				<li>We need to expose the <strong class="source-inline">handleMessage</strong> function to the JavaScript code so that it can be called when a new message arrives. We also expose a <strong class="source-inline">handleConnect</strong> function to the JavaScript code, which is called when the connection to the broker has been established. The code is shown in the following snippet:<p class="source-code">func New(logout chan bool) Service {</p><p class="source-code"><strong class="bold">    js.Global().</strong></p><p class="source-code"><strong class="bold">    Set("handleMessage", js.FuncOf(handleMessage))</strong></p><p class="source-code"><strong class="bold">    js.Global().</strong></p><p class="source-code"><strong class="bold">    Set("handleOnConnect", js.FuncOf(handleOnConnect))</strong></p><p class="source-code">    return Service{</p><p class="source-code">        logoutChannel: logout,</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>As we want <a id="_idIndexMarker550"/>to add a new column to the table, we<a id="_idIndexMarker551"/> need to add a new column header. We can do this with the following code:<p class="source-code">tableElement := table.New().</p><p class="source-code">    SetHeader(</p><p class="source-code">        "Component",</p><p class="source-code">        "Actions",</p><p class="source-code"><strong class="bold">        "Status",</strong></p><p class="source-code">    )</p></li>
				<li>We now want to add a new <strong class="source-inline">Status</strong> column inside the table, so we need to add some lines of code inside the <strong class="source-inline">RenderDashboard</strong> function. Right below <strong class="source-inline">controlElement</strong>, we add a new <strong class="source-inline">statusElement</strong>, as follows:<p class="source-code">componentControlElement := doc.CreateElement("td")</p><p class="source-code"><strong class="bold">statusElement := doc.CreateElement("td").</strong></p><p class="source-code"><strong class="bold">                SetId("bedroom-light-status").</strong></p><p class="source-code"><strong class="bold">                SetInnerHTML("off")</strong></p></li>
				<li>As we have added a column, we need to add it to the table row. We can do this by running the following code:<p class="source-code">tr.AppendChildren(</p><p class="source-code">    componentNameElement, </p><p class="source-code">    componentControlElement, </p><p class="source-code"><strong class="bold">    statusElement,</strong></p><p class="source-code">)</p></li>
				<li>Now, we add<a id="_idIndexMarker552"/> a new function that lets us request the <a id="_idIndexMarker553"/>status. We use the <strong class="source-inline">home/status-request</strong> topic for that purpose. This is illustrated in the following code snippet:<p class="source-code">func requestStatus() {</p><p class="source-code">    js.Global().</p><p class="source-code">    Get("publish").</p><p class="source-code">    Invoke("<strong class="bold">home/status-request</strong>", "")</p><p class="source-code">}</p></li>
				<li>As we now have the ability to request the status, we just need to invoke it to get the status updates. We do it right after the MQTT connection has been established, as follows:  <p class="source-code">func handleOnConnect(this js.Value, args []js.Value) </p><p class="source-code">        interface{} {</p><p class="source-code">    requestStatus()</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>The last thing that we need to add is handling the message. So, let's split the message into room, component, and action and call the correct function depending on room and component, as follows:<p class="source-code">func handleMessage(this js.Value, args []js.Value) </p><p class="source-code">interface{} {</p><p class="source-code">    message := args[0].String()</p><p class="source-code">    println("status message arrived:", message)</p><p class="source-code">    messageParts := strings.Split(message, "#")</p><p class="source-code">    room := messageParts[0]</p><p class="source-code">    component := messageParts[1]</p><p class="source-code">    switch room {</p><p class="source-code">        case "bedroom":</p><p class="source-code">            switch component {</p><p class="source-code">                case "lights":</p><p class="source-code">                    doc.GetElementById("bedroom-light-</p><p class="source-code">                        status").</p><p class="source-code">                    SetInnerHTML(messageParts[2])default:</p><p class="source-code">                        println("unknown component:", </p><p class="source-code">                            component)}</p><p class="source-code">        default:</p><p class="source-code">            println("unknown room:", room)}</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
			</ol>
			<p>We have<a id="_idIndexMarker554"/> successfully added all we need to the Wasm app. Let's <a id="_idIndexMarker555"/>now extend the logic of the <strong class="source-inline">light-control-client</strong> program. To do so, follow these steps:</p>
			<ol>
				<li value="1">We need to save the current status of the lights, so we add a new variable at the package level, as follows:<p class="source-code">var bedroomLightStatus = false</p></li>
				<li>In the <strong class="source-inline">main</strong> function, we subscribe to the <strong class="source-inline">home/status-request</strong> topic, as illustrated in the following code snippet: <p class="source-code">err = mqttClient.Subscribe("home/status-request", 0, </p><p class="source-code">    HandleStatusRequestMessage)</p><p class="source-code">if err != nil {</p><p class="source-code">    printError("could not subsribe to topic", err)</p><p class="source-code">}</p></li>
				<li>We now <a id="_idIndexMarker556"/>need to implement the handler for the<a id="_idIndexMarker557"/> status request. We simply report the status and <strong class="source-inline">Ack</strong> the message afterward, as illustrated in the following code snippet:<p class="source-code">func HandleStatusRequestMessage(client mqtt.Client, </p><p class="source-code">       message mqtt.Message) {</p><p class="source-code">    reportStatus(client)</p><p class="source-code">    message.Ack()</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">reportStatus</strong> function just needs to check and report the status. This can be done by running the following code:<p class="source-code">func reportStatus(client mqtt.Client) {</p><p class="source-code">    status := "off"</p><p class="source-code">    if bedroomLightStatus {</p><p class="source-code">        status = "on"</p><p class="source-code">    }</p><p class="source-code">    token := client.Publish(</p><p class="source-code">               "home/status", </p><p class="source-code">               0, </p><p class="source-code">               false, </p><p class="source-code">               fmt.Sprintf("bedroom#lights#%s", status),</p><p class="source-code">    )</p><p class="source-code">    if token.Wait() &amp;&amp; token.Error() != nil {</p><p class="source-code">        println(token.Error())</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">HandleActionMessage</strong> function, we need to pass <strong class="source-inline">mqtt.Client</strong> as an<a id="_idIndexMarker558"/> additional parameter to<a id="_idIndexMarker559"/> the <strong class="source-inline">controlBedroom</strong> function. We can do this by running the following code:<p class="source-code">controlBedroom(</p><p class="source-code"><strong class="bold">    client,</strong></p><p class="source-code">    splittedString[1],</p><p class="source-code">    splittedString[2],</p><p class="source-code">)</p></li>
				<li>We now also need to add <strong class="source-inline">mqtt.Client</strong> to the <strong class="source-inline">controlBedroom</strong> parameter list. We can do this by running the following code:<p class="source-code">func controlBedroom(client mqtt.Client, module, action </p><p class="source-code">    string) {</p></li>
				<li>We then pass the client in to the <strong class="source-inline">controlBedroomlights</strong> function, as follows:<p class="source-code">controlBedroomlights(client, true)</p></li>
				<li>The last step<a id="_idIndexMarker560"/> is to update and report the status in<a id="_idIndexMarker561"/> the <strong class="source-inline">controlBedroomLights</strong> function. We also update the status here so that we get feedback in the Wasm app after clicking on the <strong class="bold">on</strong>/<strong class="bold">off</strong> buttons. The code for this is shown in the following snippet:<p class="source-code">func controlBedroomlights(client mqtt.Client, action </p><p class="source-code">        bool) {</p><p class="source-code">    if action {</p><p class="source-code">        bedroomLight.High()</p><p class="source-code">        bedroomLightStatus = true</p><p class="source-code">    } else {</p><p class="source-code">        bedroomLight.Low()</p><p class="source-code">        bedroomLightStatus = false</p><p class="source-code">    }</p><p class="source-code">    reportStatus(client)</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>Excellent! The client can now check the status of the lights inside the Wasm app.</p>
			<p>Well, congratulations! You have finished all of the projects in this book. Let's now have a look at possible alternative solutions to our current implementation.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>Checking other implementation ideas</h2>
			<p>Lighting up a small LED by pressing a button on a Wasm app is exciting but does not really help in terms of home automation. An LED can be considered as a placeholder for literally anything you can think of. We have implemented the logic to trigger any kind of action. What possibilities do we have to control real lights or other components?</p>
			<h3>Using smart sockets</h3>
			<p>One option is to use smart <a id="_idIndexMarker562"/>sockets, which are controllable using Wi-Fi or Bluetooth. Most of them do not provide an open API and require you to reverse-engineer the signals to control them, but there are also some manufacturers that provide API references for their products.</p>
			<p>An example of this is the NETIO PowerBOX 3Px, which is a socket that supports lots of APIs <a id="_idIndexMarker563"/>such as MQTT, HTTP, <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>), and <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>), among others. Another example is <a id="_idIndexMarker564"/>WIFIPLUG—they also produce smart sockets that have open APIs available.</p>
			<h3>Using a relais</h3>
			<p>We have learned <a id="_idIndexMarker565"/>how to control a relais when building our automatic plant-watering system. Some relais and boards support voltages up to 230V and 10 <strong class="bold">amps</strong> (<strong class="bold">A</strong>), which is sufficient to power nearly any electrical device. Although the relais might be able to handle currencies of 230V or 130V, you should never work mains-voltage. Lots of nice projects can be built with currents up to 12V. </p>
			<h3>Using TLS</h3>
			<p>When <a id="_idIndexMarker566"/>developing <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) applications, it's important to consider security. At the time of <a id="_idIndexMarker567"/>writing, the Wi-Fi driver implementation of the Arduino Nano 33 IoT does not support TLS. This is a topic that is actively being worked on and will definitely be implemented soon. So, when implementing functionalities that operate outside of your local network, you should definitely aim to use TLS. Also, as mentioned, when implementing the login view, we learned that embedding credentials into Wasm is not as secure as embedding credentials into the binary file. </p>
			<p>We have now learned that there are several manufacturers for smart sockets that have an open API, which makes it easy to integrate them into our projects <strong class="bold">safely</strong>. We have also learned that we can make use of a relais to control LED stripes or other devices.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we have learned how to build a Wasm app that creates its views fully and dynamically. We have learned this by manipulating the DOM. We have also learned how to handle user input in Wasm and how to create reusable JavaScript components for use in future Wasm projects.</p>
			<p>We then learned how to publish MQTT messages from inside a Wasm app, by implementing a dashboard able to toggle lights that were represented by an LED.</p>
			<p>This book's task was to bring you closer to programming microcontrollers and Wasm and to teach you how to implement small projects with little code and—hopefully—a lot of fun. You have now learned everything you need to go on and realize your own project ideas.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Questions</h1>
			<ol>
				<li value="1">Why is validating credentials inside Wasm code not secure?</li>
				<li>What are the alternatives to validating credentials inside Wasm code? </li>
			</ol>
		</div>
	</div></body></html>