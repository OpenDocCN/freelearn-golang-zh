- en: '*Chapter 8*: Automating and Monitoring Your Home through the TinyGo Wasm Dashboard'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use the Wi-Fi chip on the Arduino
    Nano 33 IoT board in order to send **Message Queuing Telemetry** (**MQTT**) messages.
    We then consumed these messages containing weather data and weather alerts, to
    display them on a **WebAssembly** (**Wasm**) dashboard, but we were not able to
    control anything from inside the dashboard. We are now going to change this.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, we will know how to secure our Wasm apps
    by adding a login page. We're also going to learn about security aspects when
    validating credentials on a client application. After building the login view,
    we are going to learn how to send and receive data inside a dashboard that we
    are going to build. By doing so, we are also going to learn some new techniques
    that will help us by dynamically adding and removing content. By manipulating
    the **Document Object Model** (**DOM**), we will know how to use bidirectional
    communication through MQTT. Lastly, we are going to learn about possibilities
    to control devices that operate at 130V (where **V** stands for **volts**) or
    230V.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing all this will enable us to build all sorts of home automation projects
    you can think of, beyond this book. In this chapter, we''re going to cover the
    following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a home automation dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the home automation client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting data from the microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to need the following components for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Nano 33 IoT board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **light-emitting diode** (**LED**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 68 Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub at the following link: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3uPLI7X](https://bit.ly/3uPLI7X)'
  prefs: []
  type: TYPE_NORMAL
- en: Building a home automation dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you have finished this book, you might want to build lots of cool projects
    that could include LED stripes or a motion-sensor-controlled light, or you might
    add a motor to your curtains to open or close them based on the light intensity
    or the time. These would be really cool projects, but now imagine that you're
    sitting on the couch and want to watch a movie, but the sun is too bright and
    did not exceed the threshold to start the motor that controls the curtains. What
    can we do in such a situation? Do we stand up and close the curtains manually,
    or do we open a Wasm app on our smartphone or tablet in order to control the motor
    for the curtains by just pressing a button on an app? You might also want to check
    if the LED stripe in the living room is still turned on, but you do not want to
    get out of bed to check. In that case, it would be great to have a dashboard that
    informs you about its status. In this section, we are going to build a Wasm app
    that provides a login page where the user is able to enter a username and a password
    before they can log in. The page should then be transitioned to a dashboard that
    provides functionality to enable or disable the lights in a specific room.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a reusable MQTT JavaScript component that can be used until
    a TinyGo-compatible MQTT library has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable MQTT component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135), *Displaying
    Weather Alerts on the TinyGo Wasm Dashboard*, we embedded the MQTT client into
    a `wasm.js` file. This worked well for the project but is not reusable. Therefore,
    we are now going to create a reusable component.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, start off by creating a new folder named `Chapter08` for this project.
    Inside the newly created folder, create a new folder called `light-control`. This
    new folder is going to contain all the files that are needed for the Wasm app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new file inside the `light-control` folder and name the file
    `mqtt.js`. The project structure should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `mqtt.js` file, follow these steps to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a variable that holds the MQTT client and constants for the
    MQTT broker. We also use `strict` mode again, to prevent us from using undefined
    variables. Strict mode also eliminates some silent errors and exchanges them to
    throw errors instead, and enables JavaScript engines to perform optimizations
    that were otherwise not possible. Using `strict` mode could lead to faster execution.
    The `host` and `port` values *need to be set to your own MQTT broker* host and
    port if the broker is not running locally. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add a function that simply logs to the console when the connection
    to the MQTT broker has been successfully established, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the Wasm app is being executed on the client, it is possible that we will
    lose the connection to the MQTT broker. This could be caused by an unstable Wi-Fi
    connection. If that happens, we want to attempt to create a new connection. We
    can do this by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to add a callback for the `messageArrived` event. When a new message
    arrives, we want to call a message handler that is exported by the Go code. This
    works as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We next want to be able to publish messages. In this case, we set the `1` as
    we want to make sure that a message is definitely received by consumers. Furthermore,
    we do not need to retain messages. In later projects, you could also parameterize
    the QOS level and the `retain` flag. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Establish the connection to the MQTT broker, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is everything we need for our reusable MQTT component. All we need to
    do when integrating it into projects is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Expose a `handleMessage()` function in the Go code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `hostname, port, and cname` values to the MQTT broker in the JavaScript
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to set up the so-called glue code that connects the JavaScript
    code with the Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Wasm instantiation code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Wasm instantiation code is nearly the same every time. It only changes
    if we want to add some project-specific code in it. So, let''s quickly create
    a new file named `wasm.js` inside the `light-control` folder. Now, run the following
    standard code to initialize a Wasm app inside the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is nearly the same code as in [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135),
    *Displaying Weather Alerts on the TinyGo Wasm Dashboard*, in the *Implementing
    the weather app* section, but this time we did not include the MQTT client code
    inside the file. You can use this file for every project beyond this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add the `wasm_exec.js` file. We can either download it
    from the TinyGo GitHub repository or copy it from our local installation. On Unix-based
    systems, you can use the following command to copy the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The path to the `wasm_exec.js` file is different on Windows. When using the
    preceding command, you need to insert your own path to the TinyGo installation.
    The path basically follows this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's everything we need in terms of JavaScript code. We can now go on to create
    our **HyperText Markup Language** (**HTML**) template file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HTML template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135), *Displaying
    Weather Alerts on the TinyGo Wasm Dashboard*, in the *Implementing the weather
    app* section, we defined our base structure inside the HTML file, but this time
    our HTML template is going to be much shorter. We are only going to include the
    needed header and define an empty body element as we are going to create all HTML
    elements dynamically using DOM manipulation from inside the Go code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, create a new file named `index.html` inside the `light-control` folder.
    The body element needs to get an `id` value as we are going to identify the element
    using the ID. We also import all needed JavaScript files in the header. This is
    what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's everything we need for the HTML template. The next step is writing the
    login view.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login view logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The login component needs to add the login view to the HTML document and also
    implement logic to handle the user input. Let's create a new folder named `login`
    inside the `light-control` folder and create a new file named `userinfo.go` inside
    the newly created folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `userinfo.go` file simply holds the `UserInfo` element, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a new `login.go` file inside the `login` folder and implement
    the view by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need username and password values for the login, so we define them as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We only need to fetch the document a single time, so we just store it inside
    a package-level variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define a service that only needs to hold a channel. The channel is
    later being used to propagate the logged-in username to the other components.
    The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a constructor function that accepts a channel and returns a new instance
    of `Service`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to implement the logic to create the view. We want to simulate
    having a multipage app by telling the browser to change the **Uniform Resource
    Locator** (**URL**) by pushing a new state. The code to do this is shown in the
    following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now create a new `div` tag that is going to hold all subsequent elements,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set an `h1` that also tells the user the name of the component, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a form that holds the input fields. So, we simply create a new
    instance of `form` and also create a new `userName` input field with the corresponding
    label, which works as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now want to add an input field of type `password` that obscures the input.
    To do this, run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we now have both input fields, we need a button that emits `click` and `keyPress`
    events that we can use to trigger the `login` logic. Here is the code we run to
    do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have now created all components that we need inside our `loginForm`, so
    we can go on and append them to `loginForm`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing to do is to append the previous element to the `div`. We append
    everything inside a `div` so that we can easily delete the elements again. In
    order to display the newly created elements, we just append the `div` in the body,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now create the view itself. The only thing missing here is the logic
    to handle `EventListener` from the `login` button, as well as the login logic
    itself. To do so, follow these last few steps for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the `login` button, we simply want to attempt a login.
    The following code snippet illustrates this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the input button is focused and the user hits the *Enter* button, we also
    want to attempt a login. We wrap the event `args` into a `tinydom` event that
    provides us with convenience functions, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `login` function fetches the input from the `username` and `password` input
    fields and compares them to our defined credentials. When invalid credentials
    are found, we trigger an alert. The most important bit in this function is the
    need to wrap the call that writes into the channel inside a goroutine. If we did
    not wrap a goroutine around it, the code could not compile. Refer to the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Excellent! We have completed the login component. But what would this view
    look like in a browser? Let''s check the following screenshot to find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Login view rendered by a browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Login view rendered by a browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the dashboard component, we have to talk about some security
    aspects of this login component. We have defined the credentials that are needed
    to log in inside the code. This code is going to be downloaded by the browser
    in the form of a Wasm binary file. As we provide the code that includes the credentials
    to the client, this procedure is considered unsecure. Let''s have a look at the
    following screenshot that shows a part of the Wasm binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Credentials leaked in binary file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Credentials leaked in binary file
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the credentials inside the Wasm binary, I simply opened the binary
    in a text editor and searched for the password. So, what other possibilities do
    we have to keep credentials safe? Here are a couple of options:'
  prefs: []
  type: TYPE_NORMAL
- en: Make an HTTP call to a **REpresentational State Transfer** (**REST**) **application
    programming interface** (**API**) that validates credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use any JavaScript library that is able to talk to an **Open Authorization 2**
    (**OAuth 2**) service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be plenty of other possibilities, but they all boil down to moving
    the actual credential validation logic to any kind of external API. But for our
    scope, this solution is good enough to validate the credentials inside the client.
    The next step is to implement the dashboard component.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the dashboard component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to implement our home automation dashboard. The dashboard
    is going to hold a list of components with associated actions that are represented
    by buttons. We also want to log out the user after a 5-minute period of inactivity.
    Before we dive into the code, we need to create a new folder named `dashboard`
    inside the `light-control` folder and create a new `dashboard.go` file inside.
    Now, follow these steps to implement the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We save a reference to the current document, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The service object holds a channel that we use to signal a logout. The `UserInfo`
    object will later be used to check `loginTime`, which will be used as an inactivity
    timer. We also get `UserName` from `UserInfo`. The code is shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor function needs to get the channel injected as we react to logout
    events that are being sent to the channel from the `wasm.go` file. The code is
    shown in the following snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to be able to trigger a connection attempt to the MQTT broker from
    inside the Go code, so we call the `js` function that resides inside the `mqtt.js`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define a function that can be used as a callback to an eventListener.
    As this function is being called from within JavaScript, we need to fulfill a
    function signature that takes `js.Value` and a `[]js.Value` parameters and returns
    `interface{}`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `bedroomOn` function is being used as callback for the JavaScript code
    and will be called when the user clicks the `On` button. The code is shown in
    the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the user performs any action, we need to check if the activity timer timed
    out. We do so by checking the `loggedInAt` timestamp. If the user is inactive
    for more than 5 minutes we perform a logout, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we simply need to invoke the `publish` function in the JavaScript code
    and reset the `loggedInAt` timer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turning the lights off works in a similar way to turning them on. The only
    difference is the payload of the message. We send `off` instead of `on` here,
    which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have successfully implemented the complete control logic. Now, we need to
    implement the logic that creates the view. These are the necessary steps to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create the dashboard view, we have information about which user just
    logged in, so we store this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just as in the login view, we tell the browser to display another URL by pushing
    a new state, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new `div` element and set an `Id` value so that we can identify
    the element later on, to remove it when logging out. The code is shown in the
    following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now greet the user by their name, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we want to have a way to easily add new components to the dashboard, we
    use a table to control the components. That way, we can simply add new table rows
    later on. Of course, we could also create new custom components or use any other
    kind of structure, but adding rows to a table is easy to understand. The whole
    process looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Besides a logout based on inactivity, we want the user to have the possibility
    to log out manually. Here''s how to set this up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last steps append all child elements to the `div` and append the `div`
    to the body, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! We have now fully implemented the logic that is needed to create the
    view. When rendered by a browser, the view looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Dashboard view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Dashboard view
  prefs: []
  type: TYPE_NORMAL
- en: Now, we only need to implement the main logic before the app itself is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the main logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to split the logic for the different components (login, dashboard)
    into separate files. The `wasm.go` file, which we now create inside the `light-control`
    folder, is going to hold the `main()` function and is used to control the flow
    through the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to introduce a new library called `tinydom`. The `tinydom`
    library wraps the `syscall/js` API and also provides additional data types such
    as `Video`, `Form`, or `Label`. Using this library, we can save lots of `tinydom`
    works on `js.Value` types internally, it is fully interoperable with the `syscall/js`
    API. You can install `tinydom` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is now set up, let''s go on to implement the logic by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `main` function, we define some variables. We define them outside
    of the `main` function as we are going to need them inside the functions. The
    code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `main` function to render the login screen, as well as setting up
    the login and logout event handler. This is done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When receiving a login event from the channel, we initialize `loginState`,
    connect to MQTT, and render the dashboard view, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to remove an object from the view, we simply remove it from the DOM.
    We do so by fetching the body element and removing the child with the `login-component`
    ID, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want to be able to remove the dashboard view to be able to go back
    to the login view. We do this by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we receive a logout event from the channel, we remove the dashboard view,
    reset the login state, and render the login view again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's everything we need for our main logic. The next step is to implement
    a server that serves the app to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serving the app works in a similar way to serving the app in [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135),
    *Displaying Weather Alerts on the TinyGo Wasm Dashboard*, but we add an extra
    trick in here. When the user refreshes the page or tries to visit one of the URLs
    that we set by pushing a state, the server would normally be unaware of these
    URLs. That's why we redirect the client to the correct URL. We handle that case
    by simply redirecting the user to the root URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code into a `main.go` file that resides in a newly created
    folder named `wasm-server`, which is inside the `Chapter08` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have completed the app and the server that serves the app. Let''s now build
    and run everything. We will be using a **Makefile** for this example, but you
    could also use a Docker container, a shell script, or something similar. We need
    to build the Wasm app, copy all dependencies, and start the server. The Makefile
    approach looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run the server, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is successful, go on and try out our app by visiting the following
    URL in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the Mosquitto Docker container, don''t forget to check that the
    container has been started and that the container does not run. Simply start it
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we have now successfully built a Wasm app that is able to publish messages
    to an MQTT broker, we can now go on and create a client that consumes these messages,
    and this is exactly what we are going to do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building the home automation client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Home automation basically consists of *activating and deactivating things* based
    on a *precondition*. For example, we might want to turn on a light when someone
    enters a room at night. Throughout this book, we have activated and deactivated
    many things based on preconditions, but most of them were not connected to a network.
    We are now going to learn how we can send signals over a network. These signals
    are going to be used as preconditions. After completing this section, we will
    be fully prepared for building our own home automation clients that can be triggered
    over a network.
  prefs: []
  type: TYPE_NORMAL
- en: The client that is going to run on the Arduino Nano 33 IoT is simply going to
    connect to an MQTT broker and then subscribe to a topic. When a message comes
    in for the topic, we need to deserialize the message and perform the action that
    is defined in the message.
  prefs: []
  type: TYPE_NORMAL
- en: For our example project, we are going to turn an LED on and off. Of course,
    a single LED might not be enough to light up a complete bedroom, so we will talk
    about other real-world solutions at the end of this section. Let's start by setting
    up the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The circuit for this project is fairly simple. Just follow these steps to set
    everything up:'
  prefs: []
  type: TYPE_NORMAL
- en: Place an LED with the cathode in *E40* on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect A41 (*GND*) with the *GND* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode of the LED with pin D4 and place a 68 Ohm resistor in between.
    If you don't have a 68 Ohm resistor, you can also use a 100 Ohm one. Connect *B52*
    with the *GND* lane on the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Light control circuit (image is taken from Fritzing)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Light control circuit (image is taken from Fritzing)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unsure which technical specs your LEDs have because you simply do
    not have a datasheet, have a look at the following URL. This provides a resistor
    calculator, as well as good voltages for different LED colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor](https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor)'
  prefs: []
  type: TYPE_NORMAL
- en: Great! We are now all set up and ready to implement the logic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our final project, we need to create a new folder named `light-control-client`
    inside the `Chapter08` folder and create a new `main.go` file inside. The logic
    of the `main` function is just used to initialize everything, while the actual
    logic is going to reside in separate functions. To implement it, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the main function, we add constants for the Wi-Fi credentials and the
    LED pin. We simply need to replace the SSID and password with our own data, which
    looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inside the main function, we want to control the LED. To do so, we need
    to configure the pin as output, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to establish the Wi-Fi connection, as seen in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to connect to the MQTT broker. You need to replace the IP address
    with the IP address of your MQTT broker, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to subscribe to a topic, we need to hand in the QOS level and a function
    that is called when a message on that topic arrives, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to add in a blocking function so that the program does not
    terminate, which can be seen in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s all we need to initialize everything. We now only need to implement
    the logic that handles the incoming messages. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to deserialize the incoming message by splitting the string,
    and then call functions depending on the room that is being delivered. If we receive
    an invalid message or finish handling the message, we `Ack` the message, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, we simply execute the correct functions based on the module
    and action provided. The complete function is implemented in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we just need to activate or deactivate the LED, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to stop the execution and print the error repeated, while initializing
    everything. For that case, we use the following helper function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s everything we need to implement the client. We can now go on and flash
    the program, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: While the program is running, we are now able to turn the LED on and off using
    the Wasm app. So, now go on and try that.
  prefs: []
  type: TYPE_NORMAL
- en: Okay—you tried that; everything is working as expected and now you want to know
    what's next. What if something went wrong and the LED never activates or deactivates?
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, I highly recommend watching the output of the serial port in
    PuTTY. If everything looks fine there, the next thing you can try is to send MQTT
    messages to the broker by using MQTT Explorer. If you still have no luck, you
    should double-check your wiring; and if nothing else helps, you might want to
    try to directly flash the code from the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything is working as intended, you might think that *only* being
    able to activate and deactivate the light is nice, but what about displaying the
    current status of the light on the dashboard? Let's do this as a next step.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting data from the microcontroller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We might want to know if the light is currently turned on or off inside the
    living room, without having to walk all the way into the room. So, it would be
    great if the Wasm app *could request the status of the light* and display it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's imagine we have one or multiple microcontrollers in different rooms,
    listening to messages. For this example, we do not want the microcontroller to
    continuously report the state of the light as this would cause unnecessary network
    traffic. So, we go on and send a message to request the data. The microcontrollers
    are subscribed to the status topic and get the message delivered. After receiving
    the status request, they answer it by each sending a status message.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Architecture diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B16555.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Architecture diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement that behavior, one microcontroller is sufficient. So,
    let''s go on and update our code accordingly. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `wasm.js` file, we subscribe to the `home/status` topic. This is
    the topic in which the microcontrollers are going to publish status messages.
    We also want to call a `go` function when the connection has been established.
    Refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `dashboard.go` file, we add a `Boolean` to save the status of the
    bedroom lights inside the `Service` struct, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to expose the `handleMessage` function to the JavaScript code so that
    it can be called when a new message arrives. We also expose a `handleConnect`
    function to the JavaScript code, which is called when the connection to the broker
    has been established. The code is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we want to add a new column to the table, we need to add a new column header.
    We can do this with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now want to add a new `Status` column inside the table, so we need to add
    some lines of code inside the `RenderDashboard` function. Right below `controlElement`,
    we add a new `statusElement`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we have added a column, we need to add it to the table row. We can do this
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add a new function that lets us request the status. We use the `home/status-request`
    topic for that purpose. This is illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we now have the ability to request the status, we just need to invoke it
    to get the status updates. We do it right after the MQTT connection has been established,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing that we need to add is handling the message. So, let''s split
    the message into room, component, and action and call the correct function depending
    on room and component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have successfully added all we need to the Wasm app. Let''s now extend the
    logic of the `light-control-client` program. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to save the current status of the lights, so we add a new variable
    at the package level, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` function, we subscribe to the `home/status-request` topic, as
    illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to implement the handler for the status request. We simply report
    the status and `Ack` the message afterward, as illustrated in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `reportStatus` function just needs to check and report the status. This
    can be done by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `HandleActionMessage` function, we need to pass `mqtt.Client` as
    an additional parameter to the `controlBedroom` function. We can do this by running
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now also need to add `mqtt.Client` to the `controlBedroom` parameter list.
    We can do this by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then pass the client in to the `controlBedroomlights` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to update and report the status in the `controlBedroomLights`
    function. We also update the status here so that we get feedback in the Wasm app
    after clicking on the **on**/**off** buttons. The code for this is shown in the
    following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Excellent! The client can now check the status of the lights inside the Wasm
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Well, congratulations! You have finished all of the projects in this book. Let's
    now have a look at possible alternative solutions to our current implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Checking other implementation ideas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lighting up a small LED by pressing a button on a Wasm app is exciting but does
    not really help in terms of home automation. An LED can be considered as a placeholder
    for literally anything you can think of. We have implemented the logic to trigger
    any kind of action. What possibilities do we have to control real lights or other
    components?
  prefs: []
  type: TYPE_NORMAL
- en: Using smart sockets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One option is to use smart sockets, which are controllable using Wi-Fi or Bluetooth.
    Most of them do not provide an open API and require you to reverse-engineer the
    signals to control them, but there are also some manufacturers that provide API
    references for their products.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is the NETIO PowerBOX 3Px, which is a socket that supports
    lots of APIs such as MQTT, HTTP, **JavaScript Object Notation** (**JSON**), and
    **Transmission Control Protocol** (**TCP**), among others. Another example is
    WIFIPLUG—they also produce smart sockets that have open APIs available.
  prefs: []
  type: TYPE_NORMAL
- en: Using a relais
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have learned how to control a relais when building our automatic plant-watering
    system. Some relais and boards support voltages up to 230V and 10 **amps** (**A**),
    which is sufficient to power nearly any electrical device. Although the relais
    might be able to handle currencies of 230V or 130V, you should never work mains-voltage.
    Lots of nice projects can be built with currents up to 12V.
  prefs: []
  type: TYPE_NORMAL
- en: Using TLS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing **Internet of Things** (**IoT**) applications, it's important
    to consider security. At the time of writing, the Wi-Fi driver implementation
    of the Arduino Nano 33 IoT does not support TLS. This is a topic that is actively
    being worked on and will definitely be implemented soon. So, when implementing
    functionalities that operate outside of your local network, you should definitely
    aim to use TLS. Also, as mentioned, when implementing the login view, we learned
    that embedding credentials into Wasm is not as secure as embedding credentials
    into the binary file.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned that there are several manufacturers for smart sockets that
    have an open API, which makes it easy to integrate them into our projects **safely**.
    We have also learned that we can make use of a relais to control LED stripes or
    other devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to build a Wasm app that creates its views
    fully and dynamically. We have learned this by manipulating the DOM. We have also
    learned how to handle user input in Wasm and how to create reusable JavaScript
    components for use in future Wasm projects.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to publish MQTT messages from inside a Wasm app, by implementing
    a dashboard able to toggle lights that were represented by an LED.
  prefs: []
  type: TYPE_NORMAL
- en: This book's task was to bring you closer to programming microcontrollers and
    Wasm and to teach you how to implement small projects with little code and—hopefully—a
    lot of fun. You have now learned everything you need to go on and realize your
    own project ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is validating credentials inside Wasm code not secure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the alternatives to validating credentials inside Wasm code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
