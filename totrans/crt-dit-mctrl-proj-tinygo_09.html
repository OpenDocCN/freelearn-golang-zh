<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer124">
			<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Appendix – "Go"ing Ahead</h1>
			<p>In this appendix section, we are going to have a look at some concepts of the Go programming language that have not been explained in the previous chapters. </p>
			<p>The following topics are covered:</p>
			<ul>
				<li>Blocking a goroutine</li>
				<li>Finding heap allocations</li>
			</ul>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Blocking a goroutine</h1>
			<p>Blocking a <a id="_idIndexMarker568"/>goroutine can be important. The easiest example of this is the <strong class="source-inline">main</strong> function. If we have no blocking call or loop inside the <strong class="source-inline">main</strong> function, the program terminates and restarts. In most cases, we do not want a program to terminate, as we might want to wait for a signal on any input that could trigger any further action in the code.</p>
			<p>Let's now look at some possibilities for blocking a goroutine. Blocking a goroutine is sometimes necessary in order to gain time to let a scheduler work on other goroutines.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Reading from a channel</h2>
			<p>A very common<a id="_idIndexMarker569"/> way to block a goroutine is to read from a channel. Reading from a channel blocks the goroutine until a value can be read. This is illustrated in the following code example:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">      blocker := make(chan bool, 1)</p>
			<p class="source-code"><strong class="bold">     &lt;-blocker</strong></p>
			<p class="source-code">     println("this gets never printed")</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>A select statement</h2>
			<p>A <strong class="source-inline">select</strong> statement lets a goroutine wait on multiple operations. The syntax is similar to the<a id="_idIndexMarker570"/> syntax of a <strong class="source-inline">switch</strong> statement. The following code example implements a <strong class="source-inline">select</strong> statement that blocks until one of two cases can run:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    resultChannel := make(chan bool)</p>
			<p class="source-code">    errChannel := make(chan error)</p>
			<p class="source-code"><strong class="bold">    select {</strong></p>
			<p class="source-code"><strong class="bold">    case result := &lt;-resultChannel:</strong></p>
			<p class="source-code">        println(result)</p>
			<p class="source-code"><strong class="bold">    case err := &lt;-errChannel:</strong></p>
			<p class="source-code">        println(err.Error())</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If both cases happen to be ready at the same time, the <strong class="source-inline">select</strong> statement chooses a random case.</p>
			<p>We sometimes have cases where our <strong class="source-inline">main</strong> function should do nothing while other goroutines are waiting for incoming messages to handle them. In such cases, we can make use of an empty <strong class="source-inline">select</strong> statement that blocks indefinitely. An example of this can be seen in the following code snippet:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code"><strong class="bold">    select {}</strong></p>
			<p class="source-code">    println("this gets never printed")</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Sleeping is a blocking call</h2>
			<p>In some cases, we <a id="_idIndexMarker571"/>only want to gain some time for a scheduler to work on another goroutine. In such cases, we can use <strong class="source-inline">time.Sleep()</strong> in order to sleep for a brief amount of time and then continue to work on our current goroutine. This could look like the following code example:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    for {</p>
			<p class="source-code">        println("do some work")</p>
			<p class="source-code">        <strong class="bold">time.Sleep(50 * time.Millisecond)</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We have learned some different ways to block a goroutine, so let's now learn a bit about allocations.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor172"/>Finding heap allocations</h1>
			<p>The TinyGo<a id="_idIndexMarker572"/> compiler toolchain tries to optimize code in such a way that no heap allocations are left in the result, but some allocations cannot be optimized. Is there a way to know which those allocations are? Yes! We can deactivate<a id="_idIndexMarker573"/> the <strong class="bold">garbage collector</strong> (<strong class="bold">GC</strong>) by passing a flag to the <strong class="source-inline">build</strong> and <strong class="source-inline">flash</strong> commands. </p>
			<p>When the GC is deactivated, the compilation process is going to fail and throws an error, which points to the line of code that caused a heap allocation. Let's check out the following code example, which causes a heap allocation:</p>
			<p class="source-code">package main</p>
			<p class="source-code">var myString *string</p>
			<p class="source-code">func main() {</p>
			<p class="source-code"><strong class="bold">            value := "my value"</strong></p>
			<p class="source-code">            myString = &amp;value</p>
			<p class="source-code">}</p>
			<p>When building this program, we will have the GC deactivated with the following command: </p>
			<p class="source-code">tinygo build -o Appendix/allocations/hex <strong class="bold">--gc=none</strong> --target=arduino Appendix/allocations/main.go</p>
			<p>This is going<a id="_idIndexMarker574"/> to throw the following error:</p>
			<p class="source-code">/tmp/tinygo589978451/main.o: In function `main.main':</p>
			<p class="source-code">/home/tobias/go/src/github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Appendix/allocations/main.go<strong class="bold">:6: undefined reference to `runtime.alloc'</strong></p>
			<p class="source-code">collect2: Error: ld returned 1 as End-Status </p>
			<p class="source-code">error: failed to link /tmp/tinygo589978451/main: exit status 1</p>
			<p>Storing a pointer to a value in a global object results in a heap allocation. How could we improve the program to not allocate heap memory? We could simply omit using a pointer here. Check out the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code"><strong class="bold">var myString string</strong></p>
			<p class="source-code">func main() {</p>
			<p class="source-code">            value := "my value"</p>
			<p class="source-code"><strong class="bold">            myString = value</strong></p>
			<p class="source-code">}</p>
			<p>We can now try to build the program again, using the following command:</p>
			<p class="source-code">tinygo build -o Appendix/allocations/hex <strong class="bold">--gc=none</strong> --target=arduino Appendix/allocations/main.go</p>
			<p>This command<a id="_idIndexMarker575"/> is going to create the output file and will not throw any errors.</p>
			<p>If you want to <a id="_idIndexMarker576"/>check out which operations cause <strong class="bold">heap allocations</strong> and which <a id="_idIndexMarker577"/>do not, check out the following link: </p>
			<p><a href="https://tinygo.org/compiler-internals/heap-allocation/">https://tinygo.org/compiler-internals/heap-allocation/</a></p>
			<p>If you want to gain a better understanding of the <strong class="bold">heap</strong>, check out the following link: </p>
			<p><a href="https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d">https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d</a></p>
		</div>
	</div></body></html>