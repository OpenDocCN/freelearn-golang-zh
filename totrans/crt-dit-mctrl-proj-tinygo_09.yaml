- en: Appendix â€“ "Go"ing Ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix section, we are going to have a look at some concepts of the
    Go programming language that have not been explained in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Blocking a goroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding heap allocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking a goroutine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blocking a goroutine can be important. The easiest example of this is the `main`
    function. If we have no blocking call or loop inside the `main` function, the
    program terminates and restarts. In most cases, we do not want a program to terminate,
    as we might want to wait for a signal on any input that could trigger any further
    action in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at some possibilities for blocking a goroutine. Blocking a goroutine
    is sometimes necessary in order to gain time to let a scheduler work on other
    goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very common way to block a goroutine is to read from a channel. Reading from
    a channel blocks the goroutine until a value can be read. This is illustrated
    in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A select statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `select` statement lets a goroutine wait on multiple operations. The syntax
    is similar to the syntax of a `switch` statement. The following code example implements
    a `select` statement that blocks until one of two cases can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If both cases happen to be ready at the same time, the `select` statement chooses
    a random case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We sometimes have cases where our `main` function should do nothing while other
    goroutines are waiting for incoming messages to handle them. In such cases, we
    can make use of an empty `select` statement that blocks indefinitely. An example
    of this can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Sleeping is a blocking call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, we only want to gain some time for a scheduler to work on another
    goroutine. In such cases, we can use `time.Sleep()` in order to sleep for a brief
    amount of time and then continue to work on our current goroutine. This could
    look like the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have learned some different ways to block a goroutine, so let's now learn
    a bit about allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Finding heap allocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TinyGo compiler toolchain tries to optimize code in such a way that no heap
    allocations are left in the result, but some allocations cannot be optimized.
    Is there a way to know which those allocations are? Yes! We can deactivate the
    `build` and `flash` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the GC is deactivated, the compilation process is going to fail and throws
    an error, which points to the line of code that caused a heap allocation. Let''s
    check out the following code example, which causes a heap allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When building this program, we will have the GC deactivated with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing a pointer to a value in a global object results in a heap allocation.
    How could we improve the program to not allocate heap memory? We could simply
    omit using a pointer here. Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now try to build the program again, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command is going to create the output file and will not throw any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check out which operations cause **heap allocations** and which
    do not, check out the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://tinygo.org/compiler-internals/heap-allocation/](https://tinygo.org/compiler-internals/heap-allocation/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to gain a better understanding of the **heap**, check out the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d](https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d)'
  prefs: []
  type: TYPE_NORMAL
