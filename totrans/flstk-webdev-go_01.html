<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Building the Database and Model</h1>
<p>In this chapter, we will design the database that our sample application will use. We will walk through the design of the database and look at some of the tools that we are going to use to help us on our database design journey. We will be using the <strong class="bold">Postgres</strong> database and will look at how to run it locally using <strong class="bold">Docker</strong>. What is Docker? In simple terms, Docker is a tool that allows developers to run a variety of applications such as the database, the HTTP server, system tools, and so on – locally or in the cloud. Docker removes the need to install all the different dependencies required to use a particular application such as a database, and it makes it easier to manage and maintain applications than installing on bare metal in both local and cloud environments. This is possible using Docker because it packages everything into a single file similar to how a compressed file contains different <span class="No-Break">files internally.</span></p>
<p>We will learn how to design a database that supports the features that we want to build, such as <span class="No-Break">the following:</span></p>
<ul>
<li>Creating <span class="No-Break">an exercise</span></li>
<li>Creating a <span class="No-Break">workout plan</span></li>
<li> Logging in to <span class="No-Break">the system</span></li>
</ul>
<p>We will also explore tools that will help in automatic code generation based on SQL queries, which reduces the amount of database-related code that needs to be written to a large extent. Readers will learn to use the tool to also auto-generate all the relevant CRUD operations without writing a single line of <span class="No-Break">Go code.</span></p>
<p>In this chapter, we’ll be covering <span class="No-Break">the following:</span></p>
<ul>
<li><span class="No-Break">Installing Docker</span></li>
<li>Setting <span class="No-Break">up Postgres</span></li>
<li>Designing <span class="No-Break">the database</span></li>
<li><span class="No-Break">Installing sqlc</span></li>
<li><span class="No-Break">Using sqlc</span></li>
<li>Setting up <span class="No-Break">the database</span></li>
<li>Generating CRUD <span class="No-Break">with sqlc</span></li>
<li>Building <span class="No-Break">the makefile</span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Technical requirements</h1>
<p>In this book, we will be using version 1.16 of the Go programming language, but you are free to use later versions of Go, as the code will work without any changes. To make it easy, all the relevant files explained in this chapter can be checked out at <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter01">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter01</a>. To work on the sample code in this chapter, make sure you change the directory to <span class="No-Break"><strong class="source-inline">Chapter 1</strong></span> –  <strong class="source-inline">Full-Stack-Web-Development-with-Go/chapter1</strong>. If you are using Windows as a development machine, use WSL2 to perform all the different operations explained in <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Installing Docker</h1>
<p>In this book, we<a id="_idIndexMarker000"/> will be using Docker to do things such as running databases and executing database tools, among others. You can install either Docker Desktop or Docker Engine. To understand more about the difference between Docker Desktop and Engine, visit the following link: <a href="https://docs.docker.com/desktop/linux/install/#differences-between-docker-desktop-for-linux-and-docker-engine">https://docs.docker.com/desktop/linux/install/#differences-between-docker-desktop-for-linux-and-docker-engine</a>. The authors use Docker Engine in Linux and Docker Desktop <span class="No-Break">for Mac.</span></p>
<p>If you are installing Docker Desktop on your local machine, the following are the links for the <a id="_idIndexMarker001"/>different <a id="_idIndexMarker002"/><span class="No-Break">operating </span><span class="No-Break"><a id="_idIndexMarker003"/></span><span class="No-Break">systems:</span></p>
<ul>
<li>Windows – <a href="https://docs.docker.com/desktop/windows/install/"><span class="No-Break">https://docs.docker.com/desktop/windows/install/</span></a></li>
<li>Linux – <a href="https://docs.docker.com/desktop/linux/install/"><span class="No-Break">https://docs.docker.com/desktop/linux/install/</span></a></li>
<li>macOS – <a href="https://docs.docker.com/desktop/mac/install/"><span class="No-Break">https://docs.docker.com/desktop/mac/install/</span></a></li>
</ul>
<p>If you want to install Docker <a id="_idIndexMarker004"/>binaries, you can follow the following <span class="No-Break">guide: </span><a href="https://docs.docker.com/engine/install/binaries/"><span class="No-Break">https://docs.docker.com/engine/install/binaries/</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/>Setting up Postgres</h1>
<p>The database we<a id="_idIndexMarker005"/> chose for the sample application is Postgres; we chose Postgres over other databases because of the wide variety of open source tools available for building, configuring, and maintaining Postgres. Postgres has been open source from version 1 since 1989 and it is used by big tech startups worldwide. The project has a lot of community support in terms of tools and utilities, which makes it easier to manage and maintain. The database is suitable for small all the way to big replicated <span class="No-Break">data stores.</span></p>
<p>The easiest way to run it locally is to run it as a Docker container. First, use the following command to <span class="No-Break">run Postgres:</span></p>
<pre class="console">
docker run --name test-postgres \
-e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres</pre>
<p>The command will run <strong class="source-inline">postgres</strong> on port <strong class="source-inline">5432</strong>; if by any chance you have other applications or other Postgres instances listening to this port, the command will fail. If you need to run Postgres on a different port, change the <strong class="source-inline">-p</strong> parameter (for example, <strong class="source-inline">-p 5555:5432</strong>) to a different <span class="No-Break">port number.</span></p>
<p>If successful, you will see the container ID printed out. The ID will differ from what is <span class="No-Break">shown here:</span></p>
<pre class="console">
f7bdfb7d2c10c5f0c9227c9b0a720f21d3c7fa65907eb0c546b8f20f12621102</pre>
<p>Check whether Postgres is up and running by using <strong class="source-inline">docker ps</strong>. The next thing to do is use the <strong class="source-inline">psql-client</strong> tool to connect to Postgres to test it out. A list of the different Postgres client tools available<a id="_idIndexMarker006"/> on different platforms can be found <span class="No-Break">here: </span><a href="https://wiki.postgresql.org/wiki/PostgreSQL_Clients"><span class="No-Break">https://wiki.postgresql.org/wiki/PostgreSQL_Clients</span></a><span class="No-Break">.</span></p>
<p>We will use the standard <strong class="source-inline">postgres psql</strong> tool using Docker. Open another terminal and use the following Docker command to <span class="No-Break">run </span><span class="No-Break"><strong class="source-inline">psql</strong></span><span class="No-Break">:</span></p>
<pre class="console">
docker exec -it test-postgres psql -h localhost -p 5432 -U postgres -d postgres</pre>
<p>What we are doing is executing the <strong class="source-inline">psql</strong> command inside the running Postgres container. You <a id="_idIndexMarker007"/>will see output such as the following, indicating that it has successfully connected to the <span class="No-Break">Postgres database:</span></p>
<pre class="console">
psql (12.3, server 14.5 (Debian 14.5-1.pgdg110+1))
WARNING: psql major version 12, server major version 14.
         Some psql features might not work.
Type "help" for help.
postgres=#</pre>
<p>On a successful connection, you will see the following output. Note that the warning message mentions server major version 14 – this is to indicate that the server version is newer than the current <strong class="source-inline">psql</strong> version as<a id="_idIndexMarker008"/> per the documentation (<a href="https://www.postgresql.org/docs/12/app-psql.xhtml">https://www.postgresql.org/docs/12/app-psql.xhtml</a>). The <strong class="source-inline">psql</strong> client will work without any problem with the <span class="No-Break">Postgres server:</span></p>
<pre class="console">
psql (12.3, server 14.0 (Debian 14.0-1.pgdg110+1))
WARNING: psql major version 12, server major version 14.
         Some psql features might not work.
Type "help" for help.
postgres=#</pre>
<p>Exit <strong class="source-inline">psql</strong> to go back to the command prompt by <span class="No-Break">typing </span><span class="No-Break"><strong class="source-inline">exit</strong></span><span class="No-Break">.</span></p>
<p>The following is some guidance on common errors when trying to connect to <span class="No-Break">the database:</span></p>
<table class="No-Table-Style" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Error Message</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">psql: error: could not connect to server: FATAL:  password authentication failed for </strong><span class="No-Break"><strong class="source-inline">user “postgres”</strong></span></p>
</td>
<td class="No-Table-Style">
<p>The password specified when running Postgres does not match with the password passed in using <strong class="source-inline">psql</strong>. Check <span class="No-Break">the password.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>psql: error: could not connect to server: could not connect to server: Host <span class="No-Break">is unreachable</span></p>
</td>
<td class="No-Table-Style">
<p>The IP address that you use to connect to Postgres <span class="No-Break">is wrong.</span></p>
</td>
</tr>
</tbody>
</table>
<p>With this, you <a id="_idIndexMarker009"/>have completed the local setup of Postgres and are now ready to start looking into designing <span class="No-Break">the database.</span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/>Designing the database</h1>
<p>In this section, we<a id="_idIndexMarker010"/> will look at how to design the database to allow us to store information for the fitness tracking application. The following screenshot shows a mockup of <span class="No-Break">the application:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<img alt="Figure 1.1 – Screenshot of the sample application" height="481" src="image/Figure_1.01_B18295.jpg" width="609"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Screenshot of the sample application</p>
<p>Looking <a id="_idIndexMarker011"/>at these functionalities, we will look at designing a database structure that will look like the following entity <span class="No-Break">relationship diagram:</span></p>
<p class="callout-heading">Entity relationship diagram</p>
<p class="callout">An entity relationship diagram<a id="_idIndexMarker012"/> shows the relationships of entity sets stored in <span class="No-Break">a database.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<img alt="Figure 1.2 – Entity relationship diagram of our fitness application" height="535" src="image/Figure_1.02_B18295.jpg" width="602"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Entity relationship diagram of our fitness application</p>
<p>Let’s drill <a id="_idIndexMarker013"/>further into each table to understand the data that <span class="No-Break">they contain:</span></p>
<table class="No-Table-Style" id="table002">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Table Name</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Users</span></p>
</td>
<td class="No-Table-Style">
<p>This table contains user information for login purposes. Passwords will be stored as a hash, <span class="No-Break">not plaintext.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Images</span></p>
</td>
<td class="No-Table-Style">
<p>This table contains images of exercises that users want to do. This table will store all the exercise images that the <span class="No-Break">user uploads.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Exercises</span></p>
</td>
<td class="No-Table-Style">
<p>This table contains the name of the exercise that the user wants to do. Users will define what kind of exercise they want <span class="No-Break">to do.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Sets</span></p>
</td>
<td class="No-Table-Style">
<p>This table contains the number of sets of each exercise that the user wants <span class="No-Break">to do.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Workouts</span></p>
</td>
<td class="No-Table-Style">
<p>This table contains the workouts that the user wants to do. Users define a workout as a combination of exercises with the number of sets that they want <span class="No-Break">to do.</span></p>
</td>
</tr>
</tbody>
</table>
<p>The trade-off we <a id="_idIndexMarker014"/>are making to store images in the database is to simplify the design; in reality, this might not be suitable for bigger images and production. Now that we have defined the database structure and understand what kind of data it will store, we need to look at how to implement it. One of the major criteria that we want to focus on is to completely separate writing SQL from the code; this way, we have a clear separation between the two, which will allow <span class="No-Break">higher maintainability.</span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/>Installing sqlc</h1>
<p>We have defined the database structure so now it’s time to talk a bit more about the tool that we are going to be using <a id="_idIndexMarker015"/>called sqlc. <strong class="bold">sqlc</strong> is an open source tool that generates type-safe code from SQL; this allows developers to focus on writing SQL and leave the Go code to sqlc. This reduces the development time, as sqlc takes care of the mundane coding of queries <span class="No-Break">and types.</span></p>
<p>The tool is <a id="_idIndexMarker016"/>available at <a href="https://github.com/kyleconroy/sqlc">https://github.com/kyleconroy/sqlc</a>. The tool helps developers focus on writing the SQL code that is needed for the application and it will generate all the relevant code needed for the application. This way, developers will be using pure Go code for database operations. The separation is clean and <span class="No-Break">easily trackable.</span></p>
<p>The following diagram shows the flow that developers normally adopt when using the tool at a <span class="No-Break">high level.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<img alt="Figure 1.3 – Flow to use sqlc to generate Go code" height="370" src="image/Figure_1.03_B18295.jpg" width="212"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Flow to use sqlc to generate Go code</p>
<p>All SQL code will be written in <strong class="source-inline">.sql</strong> files, which will be read and converted by the sqlc tool into the different <span class="No-Break">Go code.</span></p>
<p>Download <a id="_idIndexMarker017"/>and install SQL binary by using the <span class="No-Break">following command:</span></p>
<pre class="console">
go install github.com/kyleconroy/sqlc/cmd/sqlc@latest</pre>
<p>Make sure your path includes the <strong class="source-inline">GOPATH/bin</strong> directory – for example, in our case, our path looks like <span class="No-Break">the following:</span></p>
<pre class="console">
…:/snap/bin:/home/nanik/goroot/go1.16.15/go/bin:/home/nanik/go/bin</pre>
<p>If you don’t have <strong class="source-inline">GOPATH</strong> as part of the <strong class="source-inline">PATH</strong> environment variable, then you can use the following <a id="_idIndexMarker018"/>command to <span class="No-Break">run sqlc:</span></p>
<pre class="console">
$GOPATH/bin/sqlc
Usage:
  sqlc [command]
Available Commands:
  compile     Statically check SQL for syntax and type
  errors
  completion  Generate the autocompletion script for the
  specified shell
  generate    Generate Go code from SQL
  help        Help about any command
  init        Create an empty sqlc.yaml settings file
  upload      Upload the schema, queries, and configuration
  for this project
  version     Print the sqlc version number
Flags:
  -x, --experimental   enable experimental features (default: false)
  -f, --file string    specify an alternate config file (default: sqlc.yaml)
  -h, --help           help for sqlc</pre>
<p>Use <strong class="source-inline">"sqlc [command] --help"</strong> for more information about <span class="No-Break">a command.</span></p>
<p>At the time <a id="_idIndexMarker019"/>of writing, the latest version of sqlc <span class="No-Break">is v1.13.0.</span></p>
<p>Now that we have installed the tool and understand the development workflow that we will be following when using the tool, we will look at how to use the tool for <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/>Using sqlc</h1>
<p>First, let’s take a<a id="_idIndexMarker020"/> look at the different commands provided by sqlc and how <span class="No-Break">they work.</span></p>
<table class="No-Table-Style" id="table003">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Commands</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Explanation</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">compile</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This command helps check SQL syntax and reports any <span class="No-Break">typing errors.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">completion</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This command is to generate an auto-completion script for your environment. The following are the supported environments: Bash, Fish, PowerShell, <span class="No-Break">and zsh.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">generate</strong></span></p>
</td>
<td class="No-Table-Style">
<p>A command to generate the <strong class="source-inline">.go</strong> files based on the provided SQL statements. This will be the command that we will be using a lot for <span class="No-Break">the application.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">init</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This command is the first command that is used to initialize your application to start using <span class="No-Break">this tool.</span></p>
</td>
</tr>
</tbody>
</table>
<p>The following will show how to get started with using sqlc to set up a project. Create a directory inside <strong class="source-inline">chapter1</strong> – for example, <strong class="source-inline">dbtest</strong> – and change the directory to the new directory (<strong class="source-inline">dbtest</strong>). Next, we will run sqlc with the <span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
sqlc init</pre>
<p>This will automatically generate a file called <strong class="source-inline">sqlc.yaml</strong>, which contains a blank configuration as <span class="No-Break">shown here:</span></p>
<pre class="console">
version: "1"
project:
    id: ""
packages: []</pre>
<p>The <strong class="source-inline">sqlc.yaml</strong> contains<a id="_idIndexMarker021"/> configuration information that sqlc will use to generate all the relevant <strong class="source-inline">.go</strong> code for our <span class="No-Break">SQL statements.</span></p>
<p>Let’s take a look at the structure of the <strong class="source-inline">.yaml</strong> file to understand the different properties. The following shows an example of a <span class="No-Break">completed structure:</span></p>
<pre class="console">
version: "1"
packages:
 - name: "db"
   path: "db"
   queries: "./sqlquery"
   schema: "./sqlquery/schema/"
   engine: "postgresql"
   sql_engine: "database/sql"
   emit_db_tags: "true"
   emit_prepared_queries: true
   emit_interface: false
   emit_exact_table_names: false
   emit_empty_slices: false
   emit_exported_queries: false
   emit_json_tags: true
   json_tags_case_style: "snake"
   output_db_file_name: "db.go"
   output_models_file_name: "dbmodels.go"
   output_querier_file_name: "dbquerier.go"
   output_files_suffix: "_gen"</pre>
<p>The following table<a id="_idIndexMarker022"/> explains the <span class="No-Break">different fields:</span></p>
<table class="No-Table-Style" id="table004">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Tag Name</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Name</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Any string to be used as the <span class="No-Break">package name.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Path</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Specifies the name of the directory that will host the generated <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">go</strong></span><span class="No-Break"> code.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Queries</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Specifies the directory name containing the SQL queries that sqlc will use to generate the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">go</strong></span><span class="No-Break"> code.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Schema</strong></span></p>
</td>
<td class="No-Table-Style">
<p>A directory containing SQL files that will be used to generate all the relevant <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">go</strong></span><span class="No-Break"> files.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Engine</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Specifies the database engine that will be used: sqlc supports either MySQL <span class="No-Break">or Postgres.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">emit_db_tags</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Setting this to <strong class="source-inline">true</strong> will generate the <strong class="source-inline">struct</strong> with <strong class="source-inline">db</strong> tags – <span class="No-Break">for example:</span></p>
<p><strong class="source-inline">type ExerciseTable </strong><span class="No-Break"><strong class="source-inline">struct {</strong></span></p>
<p><strong class="source-inline">  ExerciseID   int64  `</strong><span class="No-Break"><strong class="source-inline">db:"exercise_id"</strong></span></p>
<p><strong class="source-inline">  ExerciseName </strong><span class="No-Break"><strong class="source-inline">string `db:"exercise_name"</strong></span></p>
<p><strong class="source-inline">}</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">emit_prepared_queries</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Setting this to <strong class="source-inline">true</strong> instructs sqlc to support prepared queries in the <span class="No-Break">generated code.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">emit_interface</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Setting this to <strong class="source-inline">true</strong> will instruct sqlc to generate the <span class="No-Break">querier interface.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">emit_exact_table_names</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Setting this to <strong class="source-inline">true</strong> will instruct sqlc to mirror the struct name to the <span class="No-Break">table name.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">emit_empty_slices</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Setting this to <strong class="source-inline">true</strong> will instruct sqlc to return an empty slice for returning data on many sides of <span class="No-Break">the table.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">emit_exported_queries</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Setting this to <strong class="source-inline">true</strong> will instruct sqlc to allow the SQL statement used in the auto-generated code to be accessed by an <span class="No-Break">outside package.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">emit_json_tags</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Setting this to <strong class="source-inline">true</strong> will generate the struct with <span class="No-Break">JSON tags.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">json_tags_case_style</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This setting can accept the following – <strong class="source-inline">camel</strong>, <strong class="source-inline">pascal</strong>, <strong class="source-inline">snake</strong>, and <strong class="source-inline">none</strong>. The case style is used for the JSON tags used in the struct. Normally, this is used <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">emit_json_tags</strong></span><span class="No-Break">.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">output_db_file_name</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Name used as the filename for the auto-generated <span class="No-Break">database file.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">output_models_file_name</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Name used as the filename for the auto-generated <span class="No-Break">model file.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">output_querier_file_name</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Name used as the filename for the auto-generated <span class="No-Break">querier file.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">output_files_suffix</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Suffix to be used as part of the auto-generated <span class="No-Break">query file.</span></p>
</td>
</tr>
</tbody>
</table>
<p>We have looked at the <a id="_idIndexMarker023"/>different parameters available in the tool, along with how to use the <strong class="source-inline">.yaml</strong> file to specify the different properties used to generate the relevant Go files. In the next section, we will set up our sample <span class="No-Break">app database.</span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Setting up the database</h1>
<p>We need to<a id="_idIndexMarker024"/> prepare and create the database using the <strong class="source-inline">psql</strong> client tool. The SQL database script can be found inside <strong class="source-inline">schema.sql</strong> under the <strong class="source-inline">db</strong> folder in the GitHub repository, and we are going to use this to create all the relevant tables <span class="No-Break">inside Postgres.</span></p>
<p>Change the directory to <strong class="source-inline">chapter1</strong> and run the Postgres database using the following <span class="No-Break">Docker command:</span></p>
<pre class="console">
docker run --name test-postgres -e POSTGRES_PASSWORD=mysecretpassword -v $(pwd):/usr/share/chapter1 -p 5432:5432 postgres</pre>
<p>Once <strong class="source-inline">postgres</strong> is running, use the following command to enter <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">psql</strong></span><span class="No-Break">:</span></p>
<pre class="console">
docker exec -it test-postgres psql -h localhost -p 5432 -U postgres -d postgres</pre>
<p>Once inside the <strong class="source-inline">psql</strong> command, run <span class="No-Break">the following:</span></p>
<pre class="console">
\i /usr/share/chapter1/db/schema.sql</pre>
<p>This will <a id="_idIndexMarker025"/>instruct <strong class="source-inline">psql</strong> to execute the commands inside <strong class="source-inline">schema.sql</strong>, and on completion, you will see the <span class="No-Break">following output:</span></p>
<pre class="console">
postgres=# \i /usr/share/chapter1/db/schema.sql
CREATE SCHEMA
CREATE TABLE
CREATE TABLE
CREATE TABLE
CREATE TABLE
CREATE TABLE</pre>
<p>To reconfirm that everything is set up correctly, use the following command (do not forget to include the dot <span class="No-Break">after </span><span class="No-Break"><strong class="source-inline">gowebapp</strong></span><span class="No-Break">):</span></p>
<pre class="console">
<a id="_idTextAnchor025"/>\dt gowebapp.* </pre>
<p>You should see the <span class="No-Break">following output:</span></p>
<pre class="console">
postgres=# \dt gowebapp.*
            List of relations
  Schema  |   Name    | Type  |  Owner
----------+-----------+-------+----------
 gowebapp | exercises | table | postgres
 gowebapp | images    | table | postgres
 gowebapp | sets      | table | postgres
 gowebapp | users     | table | postgres
 gowebapp | workouts  | table | postgres
(5 rows)</pre>
<p>Now that we<a id="_idIndexMarker026"/> have completed setting up our database, we are ready to move to the next section, where we will be setting up sqlc to generate the <span class="No-Break">Go files.</span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor026"/>Generating CRUD with sqlc</h1>
<p><strong class="bold">CRUD</strong> stands for <strong class="bold">Create, Read, Update, and Delete</strong>, which refers to all the major functions<a id="_idIndexMarker027"/> that<a id="_idIndexMarker028"/> are inherent to relational databases. In this section, we will do the following for <span class="No-Break">the application:</span></p>
<ul>
<li>Complete the sqlc <span class="No-Break">configuration file</span></li>
<li>Create SQL <span class="No-Break">query files</span></li>
</ul>
<p>Once done, we will be able to autogenerate the different files required to allow us to perform CRUD operations to the database from the application. First, open <strong class="source-inline">sqlc.yaml</strong> and enter the <span class="No-Break">following configuration:</span></p>
<pre class="console">
---
version: '1'
packages:
 - name: chapter1
   path: gen
   schema: db/
   queries: queries/
   engine: postgresql
   emit_db_tags: true
   emit_interface: false
   emit_exact_table_names: false
   emit_empty_slices: false
   emit_exported_queries: false
   emit_json_tags: true
   json_tags_case_style: camel
   output_files_suffix: _gen
   emit_prepared_queries: false</pre>
<p>Our <a id="_idIndexMarker029"/>application is now complete with all that we need for the <a id="_idIndexMarker030"/>database, and sqlc will autogenerate the <strong class="source-inline">.go</strong> files. The following is how the application directory and files <span class="No-Break">will look:</span></p>
<pre class="console">
.
├── db
│   └── schema.sql
├── go.mod
├── queries
│   └── query.sql
└── sqlc.yaml</pre>
<p>We can run sqlc to generate the <strong class="source-inline">.go</strong> files using the <span class="No-Break">following command:</span></p>
<pre class="console">
sqlc generate </pre>
<p>By default, sqlc will look for the <strong class="source-inline">sqlc.yaml</strong> file. If the filename is different, you can specify it using the <strong class="source-inline">-f</strong> flag <span class="No-Break">as follows:</span></p>
<pre class="console">
sqlc generate -f sqlc.yaml </pre>
<p>Once the<a id="_idIndexMarker031"/> operation completes, there will be no output; however, a <a id="_idIndexMarker032"/>new directory called <strong class="source-inline">gen</strong> will be generated as <span class="No-Break">shown here:</span></p>
<pre class="console">
./gen/
├── db.go
├── models.go
└── query.sql_gen.go</pre>
<p>We have completed the auto-generation process using sqlc; now, let’s take a look at the schema and queries that sqlc uses to generate <span class="No-Break">the code.</span></p>
<p>The following is a snippet of the <strong class="source-inline">schema.sql</strong> file that is used by sqlc to understand the structure of <span class="No-Break">the database:</span></p>
<pre class="console">
CREATE SCHEMA IF NOT EXISTS gowebapp;
CREATE TABLE gowebapp.users (
User_ID        BIGSERIAL PRIMARY KEY,
User_Name      text NOT NULL,
....
);
....
CREATE TABLE gowebapp.sets (
Set_ID      BIGSERIAL PRIMARY KEY,
Exercise_ID BIGINT NOT NULL,
Weight      INT NOT NULL DEFAULT 0
);</pre>
<p>The other file sqlc uses is the query file. The query file contains all the relevant queries that will <a id="_idIndexMarker033"/>perform CRUD operations based on the database <a id="_idIndexMarker034"/>structure given here. The following is a snippet of the <span class="No-Break"><strong class="source-inline">query.sql</strong></span><span class="No-Break"> file:</span></p>
<pre class="console">
-- name: ListUsers :many
-- get all users ordered by the username
SELECT *
FROM gowebapp.users
ORDER BY user_name;
...
-- name: DeleteUserImage :exec
-- delete a particular user's image
DELETE
FROM gowebapp.images i
WHERE i.user_id = $1;
...
-- name: UpsertExercise :one
-- insert or update exercise of a particular id
INSERT INTO gowebapp.exercises (Exercise_Name)
VALUES ($1) ON CONFLICT (Exercise_ID) DO
UPDATE
    SET Exercise_Name = EXCLUDED.Exercise_Name
    RETURNING Exercise_ID;
-- name: CreateUserImage :one
-- insert a new image
INSERT INTO gowebapp.images (User_ID, Content_Type,
                             Image_Data)
values ($1,
        $2,
        $3) RETURNING *;
...</pre>
<p>Using <strong class="source-inline">query.sql</strong> and <strong class="source-inline">schema.sql</strong>, sqlc will automatically generate all the relevant <strong class="source-inline">.go</strong> files, combining information for these two files together and allowing the application to perform CRUD operations to the database by accessing it like a normal struct object <span class="No-Break">in Go.</span></p>
<p>The last<a id="_idIndexMarker035"/> piece<a id="_idIndexMarker036"/> that we want to take a look at is the generated Go files. As shown previously, there are three auto-generated files inside the <strong class="source-inline">gen</strong> folders: <strong class="source-inline">db.go</strong>, <strong class="source-inline">models.go</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">query.sql_gen.go.</strong></span></p>
<p>Let’s take a look at each one of them to understand what they contain and how they will be used in <span class="No-Break">our application:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">db.go</strong></span><span class="No-Break">:</span></li>
</ul>
<p>This file<a id="_idIndexMarker037"/> contains an interface that will be used by the other auto-generated files to make SQL calls to the database. It also contains functions to create a Go struct that is used to do <span class="No-Break">CRUD operations.</span></p>
<p>A new function is used to create a query struct, passing in a <strong class="source-inline">DBTX</strong> struct. The <strong class="source-inline">DBTX</strong> struct implementation is either <strong class="source-inline">sql.DB</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">sql.Conn</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">WithTx</strong> function is used to wrap the <strong class="source-inline">Queries</strong> object in a database transaction; this is useful in situations where there could be an update operation on multiple tables that need to <a id="_idIndexMarker038"/>be committed in a single <span class="No-Break">database transaction:</span></p>
<pre class="source-code">
func New(db DBTX) *Queries {
  return &amp;Queries{db: db}
}
func (q *Queries) WithTx(tx *sql.Tx) *Queries {
  return &amp;Queries{
    db: tx,
  }
}</pre>
<ul>
<li><span class="No-Break"><strong class="source-inline">models.go</strong></span><span class="No-Break">:</span></li>
</ul>
<p>This <a id="_idIndexMarker039"/>file<a id="_idIndexMarker040"/> contains the struct of the tables in <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker041"/></span><span class="No-Break"> database:</span></p>
<pre class="source-code">
type GowebappExercise struct {
  ExerciseID   int64  `db:"exercise_id"
    json:"exerciseID"`
  ExerciseName string `db:"exercise_name"
    json:"exerciseName"`
}
...
type GowebappWorkout struct {
  WorkoutID int64     `db:"workout_id"
    json:"workoutID"`
  UserID    int64     `db:"user_id" json:"userID"`
  SetID     int64     `db:"set_id" json:"setID"`
  StartDate time.Time `db:"start_date"
    json:"startDate"`
}</pre>
<ul>
<li><span class="No-Break"><strong class="source-inline">query.sql_gen.go</strong></span><span class="No-Break">:</span></li>
</ul>
<p>This <a id="_idIndexMarker042"/>file <a id="_idIndexMarker043"/>contains CRUD functions for the database, along with the different parameters <a id="_idIndexMarker044"/>struct that can be used to perform <span class="No-Break">the operation:</span></p>
<pre class="source-code">
const deleteUsers = `-- name: DeleteUsers :exec
DELETE FROM gowebapp.users
WHERE user_id = $1
`
func (q *Queries) DeleteUsers(ctx context.Context,
userID int64) error {
  _, err := q.db.ExecContext(ctx, deleteUsers, userID)
  return err
}
...
const getUsers = `-- name: GetUsers :one
SELECT user_id, user_name, pass_word_hash, name, config, created_at, is_enabled FROM gowebapp.users
WHERE user_id = $1 LIMIT 1
`
func (q *Queries) GetUsers(ctx context.Context, userID int64) (GowebappUser, error) {
  row := q.db.QueryRowContext(ctx, getUsers, userID)
  var i GowebappUser
  err := row.Scan(
           &amp;i.UserID,
           &amp;i.UserName,
           &amp;i.PassWordHash,
           &amp;i.Name,
           &amp;i.Config,
           &amp;i.CreatedAt,
           &amp;i.IsEnabled,
  )
  return i, err
}
...</pre>
<p>Now that<a id="_idIndexMarker045"/> the database and auto-generated data to perform CRUD operations<a id="_idIndexMarker046"/> are complete, let’s try all this by doing a simple insert operation into the <span class="No-Break">user table.</span></p>
<p>The following is a snippet <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
package main
import (
  ...
)
func main() {
  ...
  // Open the database
  db, err := sql.Open("postgres", dbURI)
  if err != nil {
    panic(err)
  }
  // Connectivity check
  if err := db.Ping(); err != nil {
    log.Fatalln("Error from database ping:", err)
  }
  // Create the store
  st := chapter1.New(db)
  st.CreateUsers(context.Background(),
  chapter1.CreateUsersParams{
    UserName:     "testuser",
    PassWordHash: "hash",
    Name:         "test",
  })
}</pre>
<p>The<a id="_idIndexMarker047"/> app is<a id="_idIndexMarker048"/> doing <span class="No-Break">the following:</span></p>
<ol>
<li>Initializing the URL and opening <span class="No-Break">the database</span></li>
<li>Pinging <span class="No-Break">the database</span></li>
<li>Creating a new user using the <span class="No-Break"><strong class="source-inline">CreateUsers(..)</strong></span><span class="No-Break"> function</span></li>
</ol>
<p>Make sure you are in the <strong class="source-inline">chapter1</strong> directory and build the application by running the <span class="No-Break">following command:</span></p>
<pre class="console">
go build -o chapter1</pre>
<p>The compiler <a id="_idIndexMarker049"/>will generate a new executable called <strong class="source-inline">chapter1</strong>. Execute<a id="_idIndexMarker050"/> the file, and on a successful run, you will see the data inserted successfully into the <span class="No-Break"><strong class="source-inline">users</strong></span><span class="No-Break"> table:</span></p>
<pre class="source-code">
2022/05/15 16:10:49 Done!
Name : test, ID : 1</pre>
<p>We have completed setting up everything from the database and using sqlc to generate the relevant Go code. In the next section, we are going to put everything together for ease <span class="No-Break">of development.</span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor027"/>Building the makefile</h1>
<p>A makefile is a<a id="_idIndexMarker051"/> file that is used by the <strong class="source-inline">make</strong> utility; it contains a set of tasks consisting of different combined shell scripts. Makefiles are most used to perform operations such as compiling source code, installing executables, performing checks, and many more. The <strong class="source-inline">make</strong> utility is available for both macOS and Linux, while in Windows, you <a id="_idIndexMarker052"/>need to use <a id="_idIndexMarker053"/>Cygwin (<a href="https://www.cygwin.com/">https://www.cygwin.com/</a>) or <span class="No-Break">NMake (</span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/nmake-reference"><span class="No-Break">https://docs.microsoft.com/en-us/cpp/build/reference/nmake-reference</span></a><span class="No-Break">).</span></p>
<p>We will create the <a id="_idIndexMarker054"/>makefile to automate the steps that we have performed in this chapter. This will make it easy to do the process repetitively when required without typing it manually. We are going to create a makefile that will do tasks such as <span class="No-Break">the following:</span></p>
<ul>
<li>Bringing <span class="No-Break">up/down Postgres</span></li>
<li>Generating code <span class="No-Break">using sqlc</span></li>
</ul>
<p>The makefile can be seen in the <strong class="source-inline">chapter1</strong> directory; the following shows a snippet of <span class="No-Break">the script:</span></p>
<pre class="console">
..
.PHONY : postgresup postgresdown psql createdb teardown_recreate generate
postgresup:
    docker run --name test-postgres -v $(PWD):/usr/share/chapter1 -e POSTGRES_PASSWORD=$(DB_PWD) -p 5432:5432 -d $(DB_NAME)
...
# task to create database without typing it manually
createdb:
    docker exec -it test-postgres psql $(PSQLURL) -c "\i /usr/share/chapter1/db/schema.sql"
...</pre>
<p>With the<a id="_idIndexMarker055"/> makefile, you can now bring up the database easily using <span class="No-Break">this command:</span></p>
<pre class="console">
make postgresup</pre>
<p>The following is used to bring down <span class="No-Break">the database:</span></p>
<pre class="console">
make postgresdown</pre>
<p>sqlc will need to be invoked to regenerate the auto-generated code whenever changes are made to <a id="_idIndexMarker056"/>the schema and SQL queries. You can use the following command to regenerate <span class="No-Break">the files:</span></p>
<pre class="console">
make generate </pre>
<h1 id="_idParaDest-27"><a id="_idTextAnchor028"/>Summary</h1>
<p>In this chapter, we have covered the different stages that we need to go through to set up the database for our fitness application. We have also written a makefile to save us time by automating different database-related tasks that will be needed for the <span class="No-Break">development process.</span></p>
<p>In the next chapter, we will look at logging for our sample application. Logging is a simple, yet crucial component. Applications use logging to provide  visibility into the running state of <span class="No-Break">an application.</span></p>
</div>
</div></body></html>