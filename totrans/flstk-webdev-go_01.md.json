["```go\ndocker run --name test-postgres \\\n-e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres\n```", "```go\nf7bdfb7d2c10c5f0c9227c9b0a720f21d3c7fa65907eb0c546b8f20f12621102\n```", "```go\ndocker exec -it test-postgres psql -h localhost -p 5432 -U postgres -d postgres\n```", "```go\npsql (12.3, server 14.5 (Debian 14.5-1.pgdg110+1))\nWARNING: psql major version 12, server major version 14.\n         Some psql features might not work.\nType \"help\" for help.\npostgres=#\n```", "```go\npsql (12.3, server 14.0 (Debian 14.0-1.pgdg110+1))\nWARNING: psql major version 12, server major version 14.\n         Some psql features might not work.\nType \"help\" for help.\npostgres=#\n```", "```go\ngo install github.com/kyleconroy/sqlc/cmd/sqlc@latest\n```", "```go\n…:/snap/bin:/home/nanik/goroot/go1.16.15/go/bin:/home/nanik/go/bin\n```", "```go\n$GOPATH/bin/sqlc\nUsage:\n  sqlc [command]\nAvailable Commands:\n  compile     Statically check SQL for syntax and type\n  errors\n  completion  Generate the autocompletion script for the\n  specified shell\n  generate    Generate Go code from SQL\n  help        Help about any command\n  init        Create an empty sqlc.yaml settings file\n  upload      Upload the schema, queries, and configuration\n  for this project\n  version     Print the sqlc version number\nFlags:\n  -x, --experimental   enable experimental features (default: false)\n  -f, --file string    specify an alternate config file (default: sqlc.yaml)\n  -h, --help           help for sqlc\n```", "```go\nsqlc init\n```", "```go\nversion: \"1\"\nproject:\n    id: \"\"\npackages: []\n```", "```go\nversion: \"1\"\npackages:\n - name: \"db\"\n   path: \"db\"\n   queries: \"./sqlquery\"\n   schema: \"./sqlquery/schema/\"\n   engine: \"postgresql\"\n   sql_engine: \"database/sql\"\n   emit_db_tags: \"true\"\n   emit_prepared_queries: true\n   emit_interface: false\n   emit_exact_table_names: false\n   emit_empty_slices: false\n   emit_exported_queries: false\n   emit_json_tags: true\n   json_tags_case_style: \"snake\"\n   output_db_file_name: \"db.go\"\n   output_models_file_name: \"dbmodels.go\"\n   output_querier_file_name: \"dbquerier.go\"\n   output_files_suffix: \"_gen\"\n```", "```go ExerciseID int64 ` ```", "```go}` |\n| `emit_prepared_queries` | Setting this to `true` instructs sqlc to support prepared queries in the generated code. |\n| `emit_interface` | Setting this to `true` will instruct sqlc to generate the querier interface. |\n| `emit_exact_table_names` | Setting this to `true` will instruct sqlc to mirror the struct name to the table name. |\n| `emit_empty_slices` | Setting this to `true` will instruct sqlc to return an empty slice for returning data on many sides of the table. |\n| `emit_exported_queries` | Setting this to `true` will instruct sqlc to allow the SQL statement used in the auto-generated code to be accessed by an outside package. |\n| `emit_json_tags` | Setting this to `true` will generate the struct with JSON tags. |\n| `json_tags_case_style` | This setting can accept the following – `camel`, `pascal`, `snake`, and `none`. The case style is used for the JSON tags used in the struct. Normally, this is used with `emit_json_tags`. |\n| `output_db_file_name` | Name used as the filename for the auto-generated database file. |\n| `output_models_file_name` | Name used as the filename for the auto-generated model file. |\n| `output_querier_file_name` | Name used as the filename for the auto-generated querier file. |\n| `output_files_suffix` | Suffix to be used as part of the auto-generated query file. |\n\nWe have looked at the different parameters available in the tool, along with how to use the `.yaml` file to specify the different properties used to generate the relevant Go files. In the next section, we will set up our sample app database.\n\n# Setting up the database\n\nWe need to prepare and create the database using the `psql` client tool. The SQL database script can be found inside `schema.sql` under the `db` folder in the GitHub repository, and we are going to use this to create all the relevant tables inside Postgres.\n\nChange the directory to `chapter1` and run the Postgres database using the following Docker command:\n\n```", "```go\n\nOnce `postgres` is running, use the following command to enter into `psql`:\n\n```", "```go\n\nOnce inside the `psql` command, run the following:\n\n```", "```go\n\nThis will instruct `psql` to execute the commands inside `schema.sql`, and on completion, you will see the following output:\n\n```", "```go\n\nTo reconfirm that everything is set up correctly, use the following command (do not forget to include the dot after `gowebapp`):\n\n```", "```go\n\nYou should see the following output:\n\n```", "```go\n\nNow that we have completed setting up our database, we are ready to move to the next section, where we will be setting up sqlc to generate the Go files.\n\n# Generating CRUD with sqlc\n\n**CRUD** stands for **Create, Read, Update, and Delete**, which refers to all the major functions that are inherent to relational databases. In this section, we will do the following for the application:\n\n*   Complete the sqlc configuration file\n*   Create SQL query files\n\nOnce done, we will be able to autogenerate the different files required to allow us to perform CRUD operations to the database from the application. First, open `sqlc.yaml` and enter the following configuration:\n\n```", "```go\n\nOur application is now complete with all that we need for the database, and sqlc will autogenerate the `.go` files. The following is how the application directory and files will look:\n\n```", "```go\n\nWe can run sqlc to generate the `.go` files using the following command:\n\n```", "```go\n\nBy default, sqlc will look for the `sqlc.yaml` file. If the filename is different, you can specify it using the `-f` flag as follows:\n\n```", "```go\n\nOnce the operation completes, there will be no output; however, a new directory called `gen` will be generated as shown here:\n\n```", "```go\n\nWe have completed the auto-generation process using sqlc; now, let’s take a look at the schema and queries that sqlc uses to generate the code.\n\nThe following is a snippet of the `schema.sql` file that is used by sqlc to understand the structure of the database:\n\n```", "```go\n\nThe other file sqlc uses is the query file. The query file contains all the relevant queries that will perform CRUD operations based on the database structure given here. The following is a snippet of the `query.sql` file:\n\n```", "```go\n\nUsing `query.sql` and `schema.sql`, sqlc will automatically generate all the relevant `.go` files, combining information for these two files together and allowing the application to perform CRUD operations to the database by accessing it like a normal struct object in Go.\n\nThe last piece that we want to take a look at is the generated Go files. As shown previously, there are three auto-generated files inside the `gen` folders: `db.go`, `models.go`, and `query.sql_gen.go.`\n\nLet’s take a look at each one of them to understand what they contain and how they will be used in our application:\n\n*   `db.go`:\n\nThis file contains an interface that will be used by the other auto-generated files to make SQL calls to the database. It also contains functions to create a Go struct that is used to do CRUD operations.\n\nA new function is used to create a query struct, passing in a `DBTX` struct. The `DBTX` struct implementation is either `sql.DB` or `sql.Conn`.\n\nThe `WithTx` function is used to wrap the `Queries` object in a database transaction; this is useful in situations where there could be an update operation on multiple tables that need to be committed in a single database transaction:\n\n```", "```go\n\n*   `models.go`:\n\nThis file contains the struct of the tables in the database:\n\n```", "```go\n\n*   `query.sql_gen.go`:\n\nThis file contains CRUD functions for the database, along with the different parameters struct that can be used to perform the operation:\n\n```", "```go\n\nNow that the database and auto-generated data to perform CRUD operations are complete, let’s try all this by doing a simple insert operation into the user table.\n\nThe following is a snippet of `main.go`:\n\n```", "```go\n\nThe app is doing the following:\n\n1.  Initializing the URL and opening the database\n2.  Pinging the database\n3.  Creating a new user using the `CreateUsers(..)` function\n\nMake sure you are in the `chapter1` directory and build the application by running the following command:\n\n```", "```go\n\nThe compiler will generate a new executable called `chapter1`. Execute the file, and on a successful run, you will see the data inserted successfully into the `users` table:\n\n```", "```go\n\nWe have completed setting up everything from the database and using sqlc to generate the relevant Go code. In the next section, we are going to put everything together for ease of development.\n\n# Building the makefile\n\nA makefile is a file that is used by the `make` utility; it contains a set of tasks consisting of different combined shell scripts. Makefiles are most used to perform operations such as compiling source code, installing executables, performing checks, and many more. The `make` utility is available for both macOS and Linux, while in Windows, you need to use Cygwin ([https://www.cygwin.com/](https://www.cygwin.com/)) or NMake ([https://docs.microsoft.com/en-us/cpp/build/reference/nmake-reference](https://docs.microsoft.com/en-us/cpp/build/reference/nmake-reference)).\n\nWe will create the makefile to automate the steps that we have performed in this chapter. This will make it easy to do the process repetitively when required without typing it manually. We are going to create a makefile that will do tasks such as the following:\n\n*   Bringing up/down Postgres\n*   Generating code using sqlc\n\nThe makefile can be seen in the `chapter1` directory; the following shows a snippet of the script:\n\n```", "```go\n\nWith the makefile, you can now bring up the database easily using this command:\n\n```", "```go\n\nThe following is used to bring down the database:\n\n```", "```go\n\nsqlc will need to be invoked to regenerate the auto-generated code whenever changes are made to the schema and SQL queries. You can use the following command to regenerate the files:\n\n```"]