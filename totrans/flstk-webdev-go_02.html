<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor029"/>2</h1>
<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Application Logging</h1>
<p>Building any kind of application to fulfill a user’s need is one piece of the puzzle; another piece is figuring out how we are going to design it so that we can support it in case there are issues in production. Logging is one of the most important things that need to be thought about thoroughly to allow some visibility when a problem arises. Application logging is the process of saving application events and errors; put simply, it produces a file that contains information about events that occur in your software application. Supporting applications in production requires a quick turnaround, and to achieve this, sufficient information should be logged by <span class="No-Break">the application.</span></p>
<p>In this chapter, we will look at building a logging server that will be used to log events (e.g., errors) from our application. We will also learn how to multiplex logging to allow us to log different events based on how we configure it. We will cover the following in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Exploring Go <span class="No-Break">standard logging</span></li>
<li><span class="No-Break">Local logging</span></li>
<li>Writing log messages to the <span class="No-Break">logging server</span></li>
<li>Configuring <span class="No-Break">multiple outputs</span></li>
</ul>
<h1 id="_idParaDest-30"><a id="_idTextAnchor031"/> Technical requirements</h1>
<p>All the source code explained in this chapter can be checked out at <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02</a>, while the logging server can be checked out <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver</span></a></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor032"/>Exploring Go standard logging</h1>
<p>In this section, we will look at the default logging library<a id="_idIndexMarker057"/> provided by the Go language. Go provides a rich set of libraries; however, like every other library, there are limitations – it does not provide leveled logging (<strong class="source-inline">INFO</strong>, <strong class="source-inline">DEBUG</strong>, etc.), file log file features, and many more. These limitations can be overcome by using open source <span class="No-Break">logging libraries.</span></p>
<p>Go provides very diverse and rich standard libraries for applications. Logging is one of them, and it is available inside the <strong class="source-inline">log</strong> package. The following documentation link provides complete information on the different functions available inside the <a href="mailto:https://pkg.go.dev/log@latest"><span class="No-Break">https://pkg.go.dev/log@latest</span></a><span class="No-Break"> </span><span class="No-Break">package.</span></p>
<p>Another package that is available in Go standard library is the <strong class="source-inline">fmt</strong> package, which provides functions for I/O operations such as printing, input, and so on. More information can be found at <strong class="source-inline">https://pkg.go.dev/fmt@latest</strong>. The available functions inside the <strong class="source-inline">log</strong> package are similar to the <strong class="source-inline">fmt</strong> package, and when going through the sample code, we will see that it is super easy <span class="No-Break">to use.</span></p>
<p>The following are some of the functions provided by the <strong class="source-inline">log</strong> <span class="No-Break">package (</span><span class="No-Break"><strong class="source-inline">https://pkg.go.dev/log)</strong></span><span class="No-Break">:</span></p>
<pre class="console">
func (l *Logger) Fatal(v ...interface{})
func (l *Logger) Fatalf(format string, v ...interface{})
func (l *Logger) Fatalln(v ...interface{})
func (l *Logger) Panic(v ...interface{})
func (l *Logger) Prefix() string
func (l *Logger) Print(v ...interface{})
func (l *Logger) Printf(format string, v ...interface{})
func (l *Logger) Println(v ...interface{})
func (l *Logger) SetFlags(flag int)
func (l *Logger) SetOutput(w io.Writer)
func (l *Logger) SetPrefix(prefix string)</pre>
<p>Let’s take a look at the example<a id="_idIndexMarker058"/> code from the sample repository, <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02</a>. The <strong class="source-inline">main.go</strong> file resides inside <strong class="source-inline">example/stdlog</strong>. To understand how to use the <strong class="source-inline">log</strong> package, build and run <span class="No-Break">the code:</span></p>
<pre class="console">
go run .</pre>
<p>On a successful run, you will get the <span class="No-Break">following output:</span></p>
<pre class="console">
2021/10/15 10:12:38 Just a log text
main.go:38: This is number 1
10:12:38 {
        «name»: «Cake»,
        «batters»: {
                «batter»: [
                        {
                                «id»: «001»,
                                «type»: «Good Food»
                        }
                ]
        },
        «topping»: [
                {
                        «id»: «002»,
                        «type»: «Syrup»
                }
        ]
}</pre>
<p>The output shows that the standard logging<a id="_idIndexMarker059"/> library is configurable to allow different log output formats – for example, you can see in the following that the message is prefixed with the formatted date <span class="No-Break">and time:</span></p>
<pre class="console">
2021/10/15 10:12:38 Just a log text</pre>
<p>The function that takes care of formatting the prefix for logging is the <span class="No-Break"><strong class="source-inline">SetFlags(..)</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
func main() {
  ...
  // set log format to - dd/mm/yy hh:mm:ss
  ol.SetFlags(log.LstdFlags)
  ol.Println(«Just a log text»)
  ...
}</pre>
<p>The code sets the flag to use <strong class="source-inline">LstdFlags</strong>, which is a combination of date and time. The following table shows the different flags that can <span class="No-Break">be used:</span></p>
<table class="No-Table-Style" id="table001-2">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Flag</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Explanation</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Ldate</strong></span></p>
</td>
<td class="No-Table-Style">
<p>A flag to specify the date in the local time zone in the <span class="No-Break">format YYYY/MM/DD</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Ltime</strong></span></p>
</td>
<td class="No-Table-Style">
<p>A flag to specify time using the local time zone in the <span class="No-Break">format HH:MM:SS</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Lmicroseconds</strong></span></p>
</td>
<td class="No-Table-Style">
<p>A flag to specify <span class="No-Break">in microseconds</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Llongfile</strong></span></p>
</td>
<td class="No-Table-Style">
<p>A flag to specify the filename and <span class="No-Break">line number</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Lshortfile</strong></span></p>
</td>
<td class="No-Table-Style">
<p>The final filename element and <span class="No-Break">line number</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">LUTC</strong></span></p>
</td>
<td class="No-Table-Style">
<p>When using the <strong class="source-inline">Ldate</strong> or <strong class="source-inline">Ltime</strong> flag, we can use this flag to specify using UTC instead of the local <span class="No-Break">time zone</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Lmsgprefix</strong></span></p>
</td>
<td class="No-Table-Style">
<p>A flag to specify the prefix text to be shown before <span class="No-Break">the message</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">LstdFlags</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This flag uses the standard flag that has been defined, which is basically <strong class="source-inline">Ldate</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Ltime</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p>The standard library can cover some use cases for application log requirements, but there are times when applications require more features that are not available from the standard library – for example, sending log information to multiple outputs will require extra functionality to be built, or in another scenario, you might need to convert<a id="_idIndexMarker060"/> nested error logs into JSON format. In the next section, we will explore another alternative for our <span class="No-Break">sample application.</span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Using golog</h1>
<p>Now that we understand<a id="_idIndexMarker061"/> what is available in the standard library, we want to explore the option of using a library that can provide us with more flexibility. We will look at the <strong class="source-inline">golog</strong> open source project (<a href="https://github.com/kataras/golog">https://github.com/kataras/golog</a>). The <strong class="source-inline">golog</strong> library is a dependency-free logging library that provides functionality such as leveled logging (<strong class="source-inline">INFO</strong>, <strong class="source-inline">ERROR</strong>, etc.), JSON-based output, and configurable <span class="No-Break">color output.</span></p>
<p>One of the most<a id="_idIndexMarker062"/> used features of logging<a id="_idIndexMarker063"/> is log levels, also known as leveled logging. Log levels are used to categorize output information from an application into different severity levels. The following table shows the different <span class="No-Break">severity levels:</span></p>
<table class="No-Table-Style" id="table002-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">INFO</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Just for <span class="No-Break">information purposes</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">WARN</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Something is not running correctly, so keep an eye out for it in case there are more <span class="No-Break">severe errors</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ERROR</strong></span></p>
</td>
<td class="No-Table-Style">
<p>There is an error that will need <span class="No-Break">some attention</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">DEBUG</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Information that is important to assist in troubleshooting in production, or added into the application for <span class="No-Break">tracing purposes</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">FATAL</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Something bad happened in the application that <span class="No-Break">requires immediate</span>
<span class="No-Break">response/investigation</span></p>
</td>
</tr>
</tbody>
</table>
<p>Example code can be found inside the <strong class="source-inline">example/golog</strong> directory. Build and run the code, and you will get the <span class="No-Break">following output:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="Figure 2.1 – Example of golog output" height="201" src="image/Figure_2.1_B18295.jpg" width="1068"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Example of golog output</p>
<p>Each prefix of the log messages<a id="_idIndexMarker064"/> is of a different color, which corresponds to the different severity levels; this is useful when you are going through a long list of log messages. Different log levels are assigned different colors to make it easy to go <span class="No-Break">through them.</span></p>
<p>The code to generate this log is similar to the standard library code, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
func main() {
  golog.SetLevel(«error»)
  golog.Println(«This is a raw message, no levels, no
                 colors.»)
  golog.Info(«This is an info message, with colors (if the
              output is terminal)»)
  golog.Warn(«This is a warning message»)
  golog.Error(«This is an error message»)
  golog.Debug(«This is a debug message»)
  golog.Fatal(`Fatal will exit no matter what,
              but it will also print the log message if
              logger›s Level is &gt;=FatalLevel`)
}</pre>
<p>The library provides level-based logging. This means that the library can show log messages based on what is configured to be shown; for example, for development, we want to configure the logger to show all log messages, while in production, we want to show only error messages. The following table shows what the output will look like when different levels<a id="_idIndexMarker065"/> are configured <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">golog</strong></span><span class="No-Break">:</span></p>
<table class="No-Table-Style" id="table003-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Level</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Output</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">golog.SetLevel("info")</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">2021/10/15 12:07 This is a raw message, no levels, </strong><span class="No-Break"><strong class="source-inline">no colors.</strong></span></p>
<p><strong class="source-inline">[INFO] 2021/10/15 12:07 This is an info message, with colors (if the output </strong><span class="No-Break"><strong class="source-inline">is terminal)</strong></span></p>
<p><strong class="source-inline">[WARN] 2021/10/15 12:07 This is a </strong><span class="No-Break"><strong class="source-inline">warning message</strong></span></p>
<p><strong class="source-inline">[ERRO] 2021/10/15 12:07 This is an </strong><span class="No-Break"><strong class="source-inline">error message</strong></span></p>
<p><strong class="source-inline">[FTAL] 2021/10/15 12:07 Fatal will exit no </strong><span class="No-Break"><strong class="source-inline">matter what</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">golog.SetLevel("debug")</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">2021/10/15 12:08 This is a raw message, no levels, </strong><span class="No-Break"><strong class="source-inline">no colors.</strong></span></p>
<p><strong class="source-inline">[INFO] 2021/10/15 12:08 This is an info message, with colors (if the output </strong><span class="No-Break"><strong class="source-inline">is terminal)</strong></span></p>
<p><strong class="source-inline">[WARN] 2021/10/15 12:08 This is a </strong><span class="No-Break"><strong class="source-inline">warning message</strong></span></p>
<p><strong class="source-inline">[ERRO] 2021/10/15 12:08 This is an </strong><span class="No-Break"><strong class="source-inline">error message</strong></span></p>
<p><strong class="source-inline">[DBUG] 2021/10/15 12:08 This is a </strong><span class="No-Break"><strong class="source-inline">debug message</strong></span></p>
<p><strong class="source-inline">[FTAL] 2021/10/15 12:08 Fatal will exit no </strong><span class="No-Break"><strong class="source-inline">matter what</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">golog.SetLevel("warn")</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">2021/10/15 12:08 This is a raw message, no levels, </strong><span class="No-Break"><strong class="source-inline">no colors.</strong></span></p>
<p><strong class="source-inline">[WARN] 2021/10/15 12:08 This is a </strong><span class="No-Break"><strong class="source-inline">warning message</strong></span></p>
<p><strong class="source-inline">[ERRO] 2021/10/15 12:08 This is an </strong><span class="No-Break"><strong class="source-inline">error message</strong></span></p>
<p><strong class="source-inline">[FTAL] 2021/10/15 12:08 Fatal will exit no </strong><span class="No-Break"><strong class="source-inline">matter what</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">golog.SetLevel("error")</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">2021/10/15 12:11 This is a raw message, no levels, </strong><span class="No-Break"><strong class="source-inline">no colors.</strong></span></p>
<p><strong class="source-inline">[ERRO] 2021/10/15 12:11 This is an </strong><span class="No-Break"><strong class="source-inline">error message</strong></span></p>
<p><strong class="source-inline">[FTAL] 2021/10/15 12:11 Fatal will exit no </strong><span class="No-Break"><strong class="source-inline">matter what</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">golog.SetLevel("fatal")</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">2021/10/15 12:11 This is a raw message, no levels, </strong><span class="No-Break"><strong class="source-inline">no colors.</strong></span></p>
<p><strong class="source-inline">[FTAL] 2021/10/15 12:11 Fatal will exit no </strong><span class="No-Break"><strong class="source-inline">matter what</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p>We covered golog and its features in this section, and now we have a good understanding of the different options <a id="_idIndexMarker066"/>available for us to use for logging. In the next section, we will look at golog a <span class="No-Break">bit more.</span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>Local logging</h1>
<p>Now that we have an idea<a id="_idIndexMarker067"/> of how to use golog, we are going to use more of its features to extend it. The library provides a function allowing applications to handle writing the log messages for each log level – for example, an application wants to write all errors into a file while the rest print out into <span class="No-Break">the console.</span></p>
<p>We are going to take a look at the example code inside the <strong class="source-inline">example/gologmoutput</strong> directory. Build and run it and you will see two new files created called <strong class="source-inline">infoerr.txt</strong> and <strong class="source-inline">infolog.txt</strong>. The output from both files will look <span class="No-Break">as follows:</span></p>
<pre class="console">
[ERRO] 2021/11/26 21:11 This is an error message [INFO] 2021/11/26 21:11 This is an info message, with colors (if the output is terminal)</pre>
<p>The app uses the <strong class="source-inline">os.OpenFile</strong> standard library<a id="_idIndexMarker068"/> to create or append files called <strong class="source-inline">infolog.txt</strong> and <strong class="source-inline">infoerr.txt</strong>, which will contain different log information that is configured using the golog <strong class="source-inline">SetLevelOutput</strong> function. The following is the snippet of the function that configured the different logging output <span class="No-Break">using golog:</span></p>
<pre class="source-code">
func configureLogger() {
  // open infolog.txt  append if exist (os.O_APPEND) or
  // create if not (os.O_CREATE) and read write
  // (os.O_WRONLY)
  infof, err := os.OpenFile(logFile,
                  os.O_APPEND|os.O_CREATE|os.O_WRONLY,
                  0666)
  ...
  golog.SetLevelOutput(«info», infof)
   // open infoerr.txt  append if exist (os.O_APPEND) or
      create if not (os.O_CREATE) and read write
   // (os.O_WRONLY)
   // errf, err := os.OpenFile(«infoerr.txt»,
                 os.O_APPEND|os.O_CREATE|os.O_WRONLY,
                 0666)
    ...
  golog.SetLevelOutput(«error», errf)
}</pre>
<p>The rest of the log-level messages<a id="_idIndexMarker069"/> are written to <strong class="source-inline">stdout</strong>, which is configured by default by <span class="No-Break">the library.</span></p>
<p>In this section, we learned how to configure golog to allow us to log errors and information separately. This is super useful as, in production, we will have a hard time if we log everything into a single file. In the next section, we will look at building our own simple logging server to accept log requests from <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor035"/>Writing log messages to the logging server</h1>
<p>In the modern cloud environment, there are multiple<a id="_idIndexMarker070"/> instances of the same application running on different servers. Due to the distributed nature of the cloud environment, it will be hard to keep track of the different logs produced by the different application instances. This will require using a centralized logging system that will be able to capture all the different log messages from the different applications <span class="No-Break">and systems.</span></p>
<p>For our needs, we will build our own logging server to capture all log messages in one single place; the code can be found at <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver</a>. The logging server will be a central place that will collate log information from our application, which will help in troubleshooting when our applications are deployed in a cloud environment. The downside of having a central logging server is that when the logging server goes down, we have no visibility of the logging information except by going to the server that hosts <span class="No-Break">the applications.</span></p>
<p><strong class="bold">REST</strong> stands for <strong class="bold">representational state transfer</strong>; in layman’s terms, it describes a server<a id="_idIndexMarker071"/> that uses the HTTP protocol and methods to communicate to resources in the server. Information is delivered in different formats, with JSON being the most popular format. It is language agnostic, which means that the logging server can be used by any application that can send and receive <span class="No-Break">over HTTP.</span></p>
<p>On a successful build, the logging server will display the <span class="No-Break">following message:</span></p>
<pre class="console">
2021/10/15 23:37:31 Initializing logging server at port 8010</pre>
<p>Once the logging server<a id="_idIndexMarker072"/> is up, go back to the <strong class="source-inline">chapter2</strong> root directory where the sample app resides and test the app by running the <span class="No-Break">following command:</span></p>
<pre class="console">
make build</pre>
<p>On completion, run the new binary called <strong class="source-inline">sampledb</strong>. The <strong class="source-inline">sampledb</strong> app will send log messages to the <span class="No-Break">logging server:</span></p>
<pre class="console">
"{\n  \"timestamp\": 1634301479,\n  \"level\": \"info\",\n  \"message\": \"Starting the application...\"\n}\n"
"{\n  \"timestamp\": 1634301479,\n  \"level\": \"info\",\n  \"message\": \"Database connection fine\"\n}\n"
"{\n  \"timestamp\": 1634301479,\n  \"level\": \"info\",\n  \"message\": \"Success - user creation\"\n}\n"
"{\n  \"timestamp\": 1634301479,\n  \"level\": \"info\",\n  \"message\": \"Success - exercise creation\"\n}\n"
"{\n  \"timestamp\": 1634301479,\n  \"level\": \"info\",\n  \"message\": \"Application complete\"\n}\n"
"{\n  \"timestamp\": 1634301479,\n  \"level\": \"info\",\n  \"message\": \"Application complete\"\n}\nut\"\n}\n"</pre>
<p>The logging server runs as a normal HTTP server that listens on port <strong class="source-inline">8010</strong>, registering a single endpoint, <strong class="source-inline">/log</strong>, to accept incoming log messages. Let’s go through it and try to understand how the logging server works. But before that, let’s take a look at how the server <span class="No-Break">code works:</span></p>
<pre class="source-code">
import (
  ...
  «github.com/gorilla/mux»
  ...
)
func runServer(addr string) {
  router = mux.NewRouter()
  initializeRoutes()
  ...
  log.Fatal(http.ListenAndServe(addr, router))
}</pre>
<p>The server<a id="_idIndexMarker073"/> is using a framework called Gorilla Mux (<a href="http://github.com/gorilla/mux">github.com/gorilla/mux</a>), which is responsible for accepting and dispatching<a id="_idIndexMarker074"/> incoming requests to their respective handler. The <strong class="source-inline">gorilla/mux</strong> package that we are using for this sample is used actively by the open source community; however, it is, at the moment, looking for a maintainer to continue <span class="No-Break">the project.</span></p>
<p>The handler that takes care of handling the request is inside<strong class="source-inline"> initializeRoutes()</strong>, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
func initializeRoutes() {
  router.HandleFunc(«/log», loghandler).Methods(http.    MethodPost)
}</pre>
<p>The <strong class="source-inline">router.HandleFunc(..)</strong> function configured the <strong class="source-inline">/log</strong> endpoint, which will be handled by the <strong class="source-inline">loghandler</strong> function. <strong class="source-inline">Methods("POST")</strong> is instructing the framework that it should accept only the <strong class="source-inline">POST</strong> HTTP method for incoming requests that hit the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">log</strong></span><span class="No-Break"> endpoint.</span></p>
<p>Now we are going to take a look at the <strong class="source-inline">loghandler</strong> function, which is responsible for processing the incoming <span class="No-Break">log messages:</span></p>
<pre class="source-code">
func loghandler(w http.ResponseWriter, r *http.Request) {
  body, err := ioutil.ReadAll(r.Body)
  ...
  w.WriteHeader(http.StatusCreated)
}</pre>
<p>The <strong class="source-inline">http.ResponseWriter</strong> parameter is a type that is defined as an interface to be used to construct an HTTP response – for example, it contains the <strong class="source-inline">WriteHeader</strong> method, which allows writing header into the response. The <strong class="source-inline">http.Request</strong> parameter provides an interface for the function to interact with the request received by the server – for example, it provides a <strong class="source-inline">Referer</strong> function to obtain a <span class="No-Break">referring URL.</span></p>
<p>The <strong class="source-inline">loghandler</strong> function does <span class="No-Break">the following:</span></p>
<ol>
<li>Reads the request body as it contains the <span class="No-Break">log message.</span></li>
<li>On successful reading of the body, the handler will return HTTP status code <strong class="source-inline">201</strong> (<strong class="source-inline">StatusCreated</strong>). Code <strong class="source-inline">201</strong> means the request has been processed successfully and the resource (in this case, the log JSON message) has been created successfully, or in our case, <span class="No-Break">printed successfully.</span></li>
<li>Prints out the log message <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">.</span></li>
</ol>
<p>For more detailed<a id="_idIndexMarker075"/> information about the different<a id="_idIndexMarker076"/> standard HTTP status codes, refer to the following <span class="No-Break">website: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</span></a><span class="No-Break">.</span></p>
<p>We have learned how to add logs to an application and how to build a simple logging server that can be hosted separately from our application. In the next section, we will create a logging wrapper that will allow our application to choose whether it wants to log locally or log to <span class="No-Break">a server.</span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor036"/>Configuring multiple outputs</h1>
<p>Why do we want to configure multiple<a id="_idIndexMarker077"/> outputs? Well, it is useful as, during development, it is easier to look at logs locally for troubleshooting purposes, but in production, it’s not possible to look at a log file, as everything will be inside the <span class="No-Break">logging server.</span></p>
<p>We are going to write a thin layer of wrapper code that will wrap the <strong class="source-inline">golog</strong> library; the code that we are going to look at is inside the <strong class="source-inline">chapter2/</strong> directory, inside the <strong class="source-inline">logger/log.go</strong> file. The benefit of having a wrapper code for the <strong class="source-inline">golog</strong> library is to isolate the application for interfacing directly with the library; this will make it easy to swap to different logging libraries when and if required. The app configured the wrapper code by passing the parsed flag to the <span class="No-Break"><strong class="source-inline">SetLoggingOutput(..)</strong></span><span class="No-Break"> function.</span></p>
<p>Build the application by running <span class="No-Break">the following:</span></p>
<pre class="console">
make build</pre>
<p>Then, run it, passing the flag to <strong class="source-inline">true</strong> as follows to write the log message <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">:</span></p>
<pre class="console">
./sampledb -local=true</pre>
<p>The debug log will be printed out <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="Figure 2.2 – Log output from sampledb" height="36" src="image/Figure_2.2_B18295.jpg" width="746"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Log output from sampledb</p>
<p>All info log messages will be printed out into the <span class="No-Break"><strong class="source-inline">logs.txt</strong></span><span class="No-Break"> file:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="Figure 2.3 – Log messages inside logs.txt" height="206" src="image/Figure_2.3_B18295.jpg" width="666"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Log messages inside logs.txt</p>
<p>The logger is configured by the application<a id="_idIndexMarker078"/> using the <strong class="source-inline">local</strong> flag by calling the <span class="No-Break"><strong class="source-inline">SetLoggingOutput(..)</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
func main() {
  l := flag.Bool(«local», false, «true - send to stdout, false                      - send to logging server»)
  flag.Parse()
  logger.SetLoggingOutput(*l)
  logger.Logger.Debugf(«Application logging to stdout =
                        %v», *l)
  ...</pre>
<p>Two main functions in the wrapper code do most of the wrapping of the <span class="No-Break"><strong class="source-inline">golog</strong></span><span class="No-Break"> framework:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">configureLocal()</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">configureRemote()</strong></span></li>
</ul>
<pre class="source-code">
...
func configureLocal() {
  file, err := os.OpenFile(«logs.txt»,
                 os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
  ...
  Logger.SetOutput(os.Stdout)
  Logger.SetLevel(«debug»)
  Logger.SetLevelOutput(«info», file)
}
...</pre>
<p>The <strong class="source-inline">configureLocal()</strong> function is responsible for configuring logging to write to both <strong class="source-inline">stdout</strong> and the configured<a id="_idIndexMarker079"/> file named <strong class="source-inline">logs.txt</strong>. The function configured golog to set the output to <strong class="source-inline">stdout</strong> and the level to <strong class="source-inline">debug</strong>, which means that everything will be going <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">.</span></p>
<p>The other function is <strong class="source-inline">configureRemote()</strong>, which configures golog to send all messages to the remote server in JSON format. The <strong class="source-inline">SetLevelOutput()</strong> function accepts the <strong class="source-inline">io.Writer </strong>interface, which the sample app has implemented to send all info <span class="No-Break">log messages:</span></p>
<pre class="source-code">
//configureRemote for remote logger configuration
func configureRemote() {
  r := remote{}
  Logger.SetLevelFormat(«info», «json»)
  Logger.SetLevelOutput(«info», r)</pre>
<p>The <strong class="source-inline">Write(data []byte)</strong> function performs a <strong class="source-inline">POST</strong> operation, passing the log message to the <span class="No-Break">logging server:</span></p>
<pre class="source-code">
func (r remote) Write(data []byte) (n int, err error) {
  go func() {
     req, err := http.NewRequest("POST",
        «http://localhost:8010/log»,
        bytes.NewBuffer(data),
     )
     ...
        resp, _ := client.Do(req)
        defer resp.Body.Close()
     }
  }()
  return len(data), nil
}</pre>
<p>In this final section, we have<a id="_idIndexMarker080"/> learned how to create configurable logging that will allow applications to log either locally or remotely. This helps our application to be prepared and deployable in <span class="No-Break">different environments.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor037"/>Summary</h1>
<p>In this chapter, we have looked at different ways of adding log functionality to applications. We also learned about the <strong class="source-inline">golog</strong> library, which provides more flexibility and features than the standard library can offer. We looked at creating our own simple logging server that enables our application to send log information that can be used in a <span class="No-Break">multi-service environment.</span></p>
<p>In the next chapter, we will look at how to add observability functionality to applications. We will look at tracing and metrics and go through the <span class="No-Break">OpenTelemetry specification.</span></p>
</div>
</div></body></html>