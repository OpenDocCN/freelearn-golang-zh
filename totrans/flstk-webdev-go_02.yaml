- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Application Logging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序日志记录
- en: Building any kind of application to fulfill a user’s need is one piece of the
    puzzle; another piece is figuring out how we are going to design it so that we
    can support it in case there are issues in production. Logging is one of the most
    important things that need to be thought about thoroughly to allow some visibility
    when a problem arises. Application logging is the process of saving application
    events and errors; put simply, it produces a file that contains information about
    events that occur in your software application. Supporting applications in production
    requires a quick turnaround, and to achieve this, sufficient information should
    be logged by the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建任何类型的应用程序以满足用户需求是拼图的一部分；另一部分是弄清楚我们如何设计它，以便在出现生产问题的情况下支持它。日志记录是在出现问题时提供可见性的最重要的事情之一。应用程序日志记录是保存应用程序事件和错误的过程；简单来说，它生成一个包含关于软件应用程序中发生的事件信息的文件。在生产中支持应用程序需要快速响应，而为了实现这一点，应用程序应该记录足够的信息。
- en: 'In this chapter, we will look at building a logging server that will be used
    to log events (e.g., errors) from our application. We will also learn how to multiplex
    logging to allow us to log different events based on how we configure it. We will
    cover the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨构建一个用于记录事件（例如错误）的应用程序日志服务器。我们还将学习如何进行多路复用日志记录，以便根据我们的配置记录不同的事件。本章将涵盖以下内容：
- en: Exploring Go standard logging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Go标准日志记录
- en: Local logging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地日志记录
- en: Writing log messages to the logging server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志消息写入日志服务器
- en: Configuring multiple outputs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置多个输出
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02),
    while the logging server can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02)中查看，而日志服务器可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver)中查看
- en: Exploring Go standard logging
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Go标准日志记录
- en: In this section, we will look at the default logging library provided by the
    Go language. Go provides a rich set of libraries; however, like every other library,
    there are limitations – it does not provide leveled logging (`INFO`, `DEBUG`,
    etc.), file log file features, and many more. These limitations can be overcome
    by using open source logging libraries.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Go语言提供的默认日志库。Go提供了一套丰富的库；然而，就像其他库一样，它也有局限性——它不提供分级日志记录（`INFO`、`DEBUG`等）、文件日志文件功能等。这些局限性可以通过使用开源日志库来克服。
- en: Go provides very diverse and rich standard libraries for applications. Logging
    is one of them, and it is available inside the `log` package. The following documentation
    link provides complete information on the different functions available inside
    the [https://pkg.go.dev/log@latest](mailto:https://pkg.go.dev/log@latest) package.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go为应用程序提供了非常多样化和丰富的标准库。日志记录是其中之一，它位于`log`包中。以下文档链接提供了关于[https://pkg.go.dev/log@latest](mailto:https://pkg.go.dev/log@latest)包内不同函数的完整信息。
- en: Another package that is available in Go standard library is the `fmt` package,
    which provides functions for I/O operations such as printing, input, and so on.
    More information can be found at `https://pkg.go.dev/fmt@latest`. The available
    functions inside the `log` package are similar to the `fmt` package, and when
    going through the sample code, we will see that it is super easy to use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go标准库中可用的另一个包是`fmt`包，它提供了打印、输入等I/O操作的功能。更多信息可以在`https://pkg.go.dev/fmt@latest`中找到。`log`包内的可用函数与`fmt`包类似，在阅读示例代码时，我们会看到它使用起来非常简单。
- en: 'The following are some of the functions provided by the `log` package (`https://pkg.go.dev/log)`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些由`log`包（`https://pkg.go.dev/log`）提供的功能：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s take a look at the example code from the sample repository, [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02).
    The `main.go` file resides inside `example/stdlog`. To understand how to use the
    `log` package, build and run the code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看示例代码，来自样本仓库[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02)。`main.go`文件位于`example/stdlog`目录下。为了了解如何使用`log`包，请构建并运行以下代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On a successful run, you will get the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功运行后，您将得到以下输出：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output shows that the standard logging library is configurable to allow
    different log output formats – for example, you can see in the following that
    the message is prefixed with the formatted date and time:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示标准日志库是可配置的，允许不同的日志输出格式 - 例如，您可以在以下内容中看到消息前面带有格式化的日期和时间：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function that takes care of formatting the prefix for logging is the `SetFlags(..)`
    function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 负责格式化日志前缀的函数是`SetFlags(..)`函数：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code sets the flag to use `LstdFlags`, which is a combination of date and
    time. The following table shows the different flags that can be used:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将标志设置为使用`LstdFlags`，这是一个日期和时间的组合。以下表格显示了可以使用的不同标志：
- en: '| **Flag** | **Explanation** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **Flag** | **说明** |'
- en: '| `Ldate` | A flag to specify the date in the local time zone in the format
    YYYY/MM/DD |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `Ldate` | 一个用于指定以YYYY/MM/DD格式显示本地时区的日期的标志 |'
- en: '| `Ltime` | A flag to specify time using the local time zone in the format
    HH:MM:SS |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Ltime` | 一个用于指定以HH:MM:SS格式使用本地时区的时间的标志 |'
- en: '| `Lmicroseconds` | A flag to specify in microseconds |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `Lmicroseconds` | 一个用于指定微秒的标志 |'
- en: '| `Llongfile` | A flag to specify the filename and line number |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `Llongfile` | 一个用于指定文件名和行号的标志 |'
- en: '| `Lshortfile` | The final filename element and line number |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Lshortfile` | 最后的文件名元素和行号 |'
- en: '| `LUTC` | When using the `Ldate` or `Ltime` flag, we can use this flag to
    specify using UTC instead of the local time zone |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `LUTC` | 当使用`Ldate`或`Ltime`标志时，我们可以使用此标志来指定使用UTC而不是本地时区 |'
- en: '| `Lmsgprefix` | A flag to specify the prefix text to be shown before the message
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Lmsgprefix` | 一个用于指定在消息之前显示的前缀文本的标志 |'
- en: '| `LstdFlags` | This flag uses the standard flag that has been defined, which
    is basically `Ldate` or `Ltime` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `LstdFlags` | 此标志使用已定义的标准标志，基本上是`Ldate`或`Ltime` |'
- en: The standard library can cover some use cases for application log requirements,
    but there are times when applications require more features that are not available
    from the standard library – for example, sending log information to multiple outputs
    will require extra functionality to be built, or in another scenario, you might
    need to convert nested error logs into JSON format. In the next section, we will
    explore another alternative for our sample application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库可以覆盖一些应用程序日志需求的使用场景，但有时应用程序需要更多标准库中没有的功能 - 例如，将日志信息发送到多个输出将需要构建额外的功能，或者在某些情况下，您可能需要将嵌套的错误日志转换为JSON格式。在下一节中，我们将探索为我们样本应用程序的另一个替代方案。
- en: Using golog
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用golog
- en: Now that we understand what is available in the standard library, we want to
    explore the option of using a library that can provide us with more flexibility.
    We will look at the `golog` open source project ([https://github.com/kataras/golog](https://github.com/kataras/golog)).
    The `golog` library is a dependency-free logging library that provides functionality
    such as leveled logging (`INFO`, `ERROR`, etc.), JSON-based output, and configurable
    color output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了标准库中有什么可用，我们想要探索使用一个可以为我们提供更多灵活性的库。我们将查看`golog`开源项目([https://github.com/kataras/golog](https://github.com/kataras/golog))。`golog`库是一个无依赖的日志库，它提供了诸如分级日志(`INFO`、`ERROR`等)、基于JSON的输出和可配置的彩色输出等功能。
- en: 'One of the most used features of logging is log levels, also known as leveled
    logging. Log levels are used to categorize output information from an application
    into different severity levels. The following table shows the different severity
    levels:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 日志功能中最常用的特性之一是日志级别，也称为分级日志。日志级别用于将应用程序的输出信息分类到不同的严重级别。以下表格显示了不同的严重级别：
- en: '| `INFO` | Just for information purposes |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | 仅用于信息目的 |'
- en: '| `WARN` | Something is not running correctly, so keep an eye out for it in
    case there are more severe errors |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `WARN` | 有某些东西运行不正确，所以请留意，以防出现更严重的错误 |'
- en: '| `ERROR` | There is an error that will need some attention |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR` | 存在一个需要关注的错误 |'
- en: '| `DEBUG` | Information that is important to assist in troubleshooting in production,
    or added into the application for tracing purposes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `DEBUG` | 用于在生产环境中协助故障排除或添加到应用程序中用于跟踪目的的重要信息 |'
- en: '| `FATAL` | Something bad happened in the application that requires immediate
    response/investigation |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `FATAL` | 应用程序中发生了需要立即响应/调查的严重问题 |'
- en: 'Example code can be found inside the `example/golog` directory. Build and run
    the code, and you will get the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在 `example/golog` 目录中找到。构建并运行代码，你将得到以下输出：
- en: '![Figure 2.1 – Example of golog output](img/Figure_2.1_B18295.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – golog 输出示例](img/Figure_2.1_B18295.jpg)'
- en: Figure 2.1 – Example of golog output
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – golog 输出示例
- en: Each prefix of the log messages is of a different color, which corresponds to
    the different severity levels; this is useful when you are going through a long
    list of log messages. Different log levels are assigned different colors to make
    it easy to go through them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息的前缀颜色各不相同，这对应着不同的严重级别；当你浏览大量日志消息时，这非常有用。不同的日志级别被分配了不同的颜色，以便于查看。
- en: 'The code to generate this log is similar to the standard library code, as shown
    here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此日志的代码与标准库代码类似，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The library provides level-based logging. This means that the library can show
    log messages based on what is configured to be shown; for example, for development,
    we want to configure the logger to show all log messages, while in production,
    we want to show only error messages. The following table shows what the output
    will look like when different levels are configured for `golog`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供基于级别的日志记录。这意味着库可以根据配置显示日志消息；例如，对于开发，我们希望配置记录器显示所有日志消息，而在生产中，我们只想显示错误消息。以下表格显示了为
    `golog` 配置不同级别时的输出外观：
- en: '| **Level** | **Output** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **输出** |'
- en: '| `golog.SetLevel("info")` | `2021/10/15 12:07 This is a raw message, no levels,`
    `no colors.``[INFO] 2021/10/15 12:07 This is an info message, with colors (if
    the output` `is terminal)``[WARN] 2021/10/15 12:07 This is a` `warning message``[ERRO]
    2021/10/15 12:07 This is an` `error message``[FTAL] 2021/10/15 12:07 Fatal will
    exit no` `matter what` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `golog.SetLevel("info")` | `2021/10/15 12:07 这是一条原始消息，没有级别，` `没有颜色。``[INFO]
    2021/10/15 12:07 这是一条 info 消息，带有颜色（如果输出` `是终端）``[WARN] 2021/10/15 12:07 这是一条`
    `警告消息``[ERRO] 2021/10/15 12:07 这是一条` `错误消息``[FTAL] 2021/10/15 12:07 致命错误将退出，无论什么情况`
    |'
- en: '| `golog.SetLevel("debug")` | `2021/10/15 12:08 This is a raw message, no levels,`
    `no colors.``[INFO] 2021/10/15 12:08 This is an info message, with colors (if
    the output` `is terminal)``[WARN] 2021/10/15 12:08 This is a` `warning message``[ERRO]
    2021/10/15 12:08 This is an` `error message``[DBUG] 2021/10/15 12:08 This is a`
    `debug message``[FTAL] 2021/10/15 12:08 Fatal will exit no` `matter what` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `golog.SetLevel("debug")` | `2021/10/15 12:08 这是一条原始消息，没有级别，` `没有颜色。``[INFO]
    2021/10/15 12:08 这是一条 info 消息，带有颜色（如果输出` `是终端）``[WARN] 2021/10/15 12:08 这是一条`
    `警告消息``[ERRO] 2021/10/15 12:08 这是一条` `错误消息``[DBUG] 2021/10/15 12:08 这是一条` `调试消息``[FTAL]
    2021/10/15 12:08 致命错误将退出，无论什么情况` |'
- en: '| `golog.SetLevel("warn")` | `2021/10/15 12:08 This is a raw message, no levels,`
    `no colors.``[WARN] 2021/10/15 12:08 This is a` `warning message``[ERRO] 2021/10/15
    12:08 This is an` `error message``[FTAL] 2021/10/15 12:08 Fatal will exit no`
    `matter what` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `golog.SetLevel("warn")` | `2021/10/15 12:08 这是一条原始消息，没有级别，` `没有颜色。``[WARN]
    2021/10/15 12:08 这是一条` `警告消息``[ERRO] 2021/10/15 12:08 这是一条` `错误消息``[FTAL] 2021/10/15
    12:08 致命错误将退出，无论什么情况` |'
- en: '| `golog.SetLevel("error")` | `2021/10/15 12:11 This is a raw message, no levels,`
    `no colors.``[ERRO] 2021/10/15 12:11 This is an` `error message``[FTAL] 2021/10/15
    12:11 Fatal will exit no` `matter what` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `golog.SetLevel("error")` | `2021/10/15 12:11 这是一条原始消息，没有级别，` `没有颜色。``[ERRO]
    2021/10/15 12:11 这是一条` `错误消息``[FTAL] 2021/10/15 12:11 致命错误将退出，无论什么情况` |'
- en: '| `golog.SetLevel("fatal")` | `2021/10/15 12:11 This is a raw message, no levels,`
    `no colors.``[FTAL] 2021/10/15 12:11 Fatal will exit no` `matter what` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `golog.SetLevel("fatal")` | `2021/10/15 12:11 这是一条原始消息，没有级别，` `没有颜色。``[FTAL]
    2021/10/15 12:11 致命错误将退出，无论什么情况` |'
- en: We covered golog and its features in this section, and now we have a good understanding
    of the different options available for us to use for logging. In the next section,
    we will look at golog a bit more.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中介绍了 golog 及其功能，现在我们对可用于日志记录的不同选项有了很好的理解。在下一节中，我们将更深入地探讨 golog。
- en: Local logging
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地日志记录
- en: Now that we have an idea of how to use golog, we are going to use more of its
    features to extend it. The library provides a function allowing applications to
    handle writing the log messages for each log level – for example, an application
    wants to write all errors into a file while the rest print out into the console.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用golog，我们将使用其更多功能来扩展它。库提供了一个函数，允许应用程序处理每个日志级别的日志消息写入——例如，一个应用程序希望将所有错误写入文件，其余的打印到控制台。
- en: 'We are going to take a look at the example code inside the `example/gologmoutput`
    directory. Build and run it and you will see two new files created called `infoerr.txt`
    and `infolog.txt`. The output from both files will look as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看`example/gologmoutput`目录内的示例代码。构建并运行它，你会看到创建了两个新文件，分别命名为`infoerr.txt`和`infolog.txt`。这两个文件的内容输出如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The app uses the `os.OpenFile` standard library to create or append files called
    `infolog.txt` and `infoerr.txt`, which will contain different log information
    that is configured using the golog `SetLevelOutput` function. The following is
    the snippet of the function that configured the different logging output using
    golog:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用`os.OpenFile`标准库创建或追加名为`infolog.txt`和`infoerr.txt`的文件，这些文件将包含使用golog的`SetLevelOutput`函数配置的不同日志信息。以下是用golog配置不同日志输出的函数片段：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rest of the log-level messages are written to `stdout`, which is configured
    by default by the library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的日志级别消息将被写入`stdout`，这是库默认配置的。
- en: In this section, we learned how to configure golog to allow us to log errors
    and information separately. This is super useful as, in production, we will have
    a hard time if we log everything into a single file. In the next section, we will
    look at building our own simple logging server to accept log requests from our
    application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何配置golog以允许我们分别记录错误和信息。这在生产环境中非常有用，因为如果我们将所有内容都记录到单个文件中，我们将很难处理。在下一节中，我们将探讨构建自己的简单日志服务器以接收应用程序的日志请求。
- en: Writing log messages to the logging server
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将日志消息写入日志服务器
- en: In the modern cloud environment, there are multiple instances of the same application
    running on different servers. Due to the distributed nature of the cloud environment,
    it will be hard to keep track of the different logs produced by the different
    application instances. This will require using a centralized logging system that
    will be able to capture all the different log messages from the different applications
    and systems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代云环境中，同一应用程序的多个实例在不同的服务器上运行。由于云环境的分布式特性，跟踪不同应用程序实例产生的不同日志将很困难。这需要使用集中式日志系统，该系统能够捕获来自不同应用程序和系统的所有不同日志消息。
- en: For our needs, we will build our own logging server to capture all log messages
    in one single place; the code can be found at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver).
    The logging server will be a central place that will collate log information from
    our application, which will help in troubleshooting when our applications are
    deployed in a cloud environment. The downside of having a central logging server
    is that when the logging server goes down, we have no visibility of the logging
    information except by going to the server that hosts the applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足我们的需求，我们将构建自己的日志服务器来捕获所有日志消息在一个地方；代码可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver)找到。日志服务器将成为一个中心位置，将汇总应用程序的日志信息，这有助于在应用程序部署在云环境中时的故障排除。拥有集中日志服务器的缺点是，当日志服务器宕机时，我们除了访问托管应用程序的服务器外，无法看到任何日志信息。
- en: '**REST** stands for **representational state transfer**; in layman’s terms,
    it describes a server that uses the HTTP protocol and methods to communicate to
    resources in the server. Information is delivered in different formats, with JSON
    being the most popular format. It is language agnostic, which means that the logging
    server can be used by any application that can send and receive over HTTP.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表示状态转移**；用通俗易懂的话来说，它描述了一个使用HTTP协议和方法与服务器中的资源进行通信的服务器。信息以不同的格式交付，其中JSON是最流行的格式。它是语言无关的，这意味着任何可以发送和接收HTTP的应用程序都可以使用日志服务器。'
- en: 'On a successful build, the logging server will display the following message:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功后，日志服务器将显示以下消息：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the logging server is up, go back to the `chapter2` root directory where
    the sample app resides and test the app by running the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦日志服务器启动，返回到包含示例应用的`chapter2`根目录，并通过运行以下命令来测试应用：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On completion, run the new binary called `sampledb`. The `sampledb` app will
    send log messages to the logging server:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，运行名为`sampledb`的新二进制文件。`sampledb`应用会将日志消息发送到日志服务器：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The logging server runs as a normal HTTP server that listens on port `8010`,
    registering a single endpoint, `/log`, to accept incoming log messages. Let’s
    go through it and try to understand how the logging server works. But before that,
    let’s take a look at how the server code works:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 日志服务器作为一个普通的HTTP服务器运行，监听端口`8010`，注册一个单一端点`/log`以接收传入的日志消息。让我们来了解一下，并尝试理解日志服务器是如何工作的。但在那之前，让我们看看服务器代码是如何工作的：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The server is using a framework called Gorilla Mux ([github.com/gorilla/mux](http://github.com/gorilla/mux)),
    which is responsible for accepting and dispatching incoming requests to their
    respective handler. The `gorilla/mux` package that we are using for this sample
    is used actively by the open source community; however, it is, at the moment,
    looking for a maintainer to continue the project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用一个名为Gorilla Mux的框架([github.com/gorilla/mux](http://github.com/gorilla/mux))，该框架负责接收和分发传入请求到相应的处理器。我们在这个示例中使用的`gorilla/mux`包被开源社区积极使用；然而，目前它正在寻找维护者以继续该项目。
- en: 'The handler that takes care of handling the request is inside `initializeRoutes()`,
    as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 负责处理请求的处理器位于`initializeRoutes()`函数内部，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `router.HandleFunc(..)` function configured the `/log` endpoint, which will
    be handled by the `loghandler` function. `Methods("POST")` is instructing the
    framework that it should accept only the `POST` HTTP method for incoming requests
    that hit the `/``log` endpoint.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`router.HandleFunc(..)`函数配置了`/log`端点，该端点将由`loghandler`函数处理。`Methods("POST")`指示框架它应该只接受针对`/log`端点的传入请求的`POST`
    HTTP方法。'
- en: 'Now we are going to take a look at the `loghandler` function, which is responsible
    for processing the incoming log messages:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看`loghandler`函数，该函数负责处理传入的日志消息：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `http.ResponseWriter` parameter is a type that is defined as an interface
    to be used to construct an HTTP response – for example, it contains the `WriteHeader`
    method, which allows writing header into the response. The `http.Request` parameter
    provides an interface for the function to interact with the request received by
    the server – for example, it provides a `Referer` function to obtain a referring
    URL.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.ResponseWriter`参数是一个定义为一个接口的类型，用于构建HTTP响应 – 例如，它包含`WriteHeader`方法，允许将标题写入响应。`http.Request`参数提供了一个接口，使函数能够与服务器接收到的请求进行交互
    – 例如，它提供了一个`Referer`函数来获取引用URL。'
- en: 'The `loghandler` function does the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`loghandler`函数执行以下操作：'
- en: Reads the request body as it contains the log message.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取请求体，因为它包含日志消息。
- en: On successful reading of the body, the handler will return HTTP status code
    `201` (`StatusCreated`). Code `201` means the request has been processed successfully
    and the resource (in this case, the log JSON message) has been created successfully,
    or in our case, printed successfully.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功读取体后，处理器将返回HTTP状态码`201`（`StatusCreated`）。状态码`201`表示请求已成功处理，资源（在本例中为日志JSON消息）已成功创建，或者在我们的情况下，已成功打印。
- en: Prints out the log message to `stdout`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将日志消息打印到`stdout`。
- en: 'For more detailed information about the different standard HTTP status codes,
    refer to the following website: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不同标准HTTP状态码的更详细信息，请参考以下网站：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)。
- en: We have learned how to add logs to an application and how to build a simple
    logging server that can be hosted separately from our application. In the next
    section, we will create a logging wrapper that will allow our application to choose
    whether it wants to log locally or log to a server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何向应用程序添加日志，以及如何构建一个可以独立于我们的应用程序托管的基础日志服务器。在下一节中，我们将创建一个日志包装器，允许我们的应用程序选择是本地记录还是记录到服务器。
- en: Configuring multiple outputs
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置多个输出
- en: Why do we want to configure multiple outputs? Well, it is useful as, during
    development, it is easier to look at logs locally for troubleshooting purposes,
    but in production, it’s not possible to look at a log file, as everything will
    be inside the logging server.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要配置多个输出？嗯，在开发过程中，它有助于更容易地本地查看日志以进行故障排除，但在生产环境中，无法查看日志文件，因为所有内容都将位于日志服务器内部。
- en: We are going to write a thin layer of wrapper code that will wrap the `golog`
    library; the code that we are going to look at is inside the `chapter2/` directory,
    inside the `logger/log.go` file. The benefit of having a wrapper code for the
    `golog` library is to isolate the application for interfacing directly with the
    library; this will make it easy to swap to different logging libraries when and
    if required. The app configured the wrapper code by passing the parsed flag to
    the `SetLoggingOutput(..)` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一层薄薄的包装代码，该代码将包装`golog`库；我们将要查看的代码位于`chapter2/`目录下的`logger/log.go`文件中。为`golog`库编写包装代码的好处是隔离应用程序，以便直接与库进行接口；这将使得在需要时轻松切换到不同的日志库变得容易。应用程序通过将解析标志传递给`SetLoggingOutput(..)`函数来配置包装代码。
- en: 'Build the application by running the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来构建应用程序：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, run it, passing the flag to `true` as follows to write the log message
    to `stdout`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行它，将标志传递给`true`，如下所示，以将日志消息写入`stdout`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The debug log will be printed out in `stdout`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 调试日志将被打印到`stdout`：
- en: '![Figure 2.2 – Log output from sampledb](img/Figure_2.2_B18295.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – sampledb 的日志输出](img/Figure_2.2_B18295.jpg)'
- en: Figure 2.2 – Log output from sampledb
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – sampledb 的日志输出
- en: 'All info log messages will be printed out into the `logs.txt` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有信息日志消息将被打印到`logs.txt`文件中：
- en: '![Figure 2.3 – Log messages inside logs.txt](img/Figure_2.3_B18295.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – logs.txt 中的日志消息](img/Figure_2.3_B18295.jpg)'
- en: Figure 2.3 – Log messages inside logs.txt
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – logs.txt 中的日志消息
- en: 'The logger is configured by the application using the `local` flag by calling
    the `SetLoggingOutput(..)` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过调用`SetLoggingOutput(..)`函数使用`local`标志配置日志记录器：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Two main functions in the wrapper code do most of the wrapping of the `golog`
    framework:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 包装代码中的两个主要函数执行了`golog`框架的大部分包装：
- en: '`configureLocal()`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configureLocal()`'
- en: '`configureRemote()`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configureRemote()`'
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `configureLocal()` function is responsible for configuring logging to write
    to both `stdout` and the configured file named `logs.txt`. The function configured
    golog to set the output to `stdout` and the level to `debug`, which means that
    everything will be going to `stdout`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`configureLocal()`函数负责配置日志记录以写入`stdout`和配置的文件名为`logs.txt`。该函数将golog的输出设置为`stdout`并将级别设置为`debug`，这意味着所有内容都将发送到`stdout`。'
- en: 'The other function is `configureRemote()`, which configures golog to send all
    messages to the remote server in JSON format. The `SetLevelOutput()` function
    accepts the `io.Writer` interface, which the sample app has implemented to send
    all info log messages:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数是`configureRemote()`，它配置golog将所有消息以JSON格式发送到远程服务器。`SetLevelOutput()`函数接受`io.Writer`接口，这是示例应用程序实现以发送所有信息日志消息的接口：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Write(data []byte)` function performs a `POST` operation, passing the
    log message to the logging server:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write(data []byte)`函数执行`POST`操作，将日志消息传递给日志服务器：'
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this final section, we have learned how to create configurable logging that
    will allow applications to log either locally or remotely. This helps our application
    to be prepared and deployable in different environments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节最后，我们学习了如何创建可配置的日志记录，这将允许应用程序在本地或远程进行日志记录。这有助于我们的应用程序在不同环境中做好准备和部署。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at different ways of adding log functionality
    to applications. We also learned about the `golog` library, which provides more
    flexibility and features than the standard library can offer. We looked at creating
    our own simple logging server that enables our application to send log information
    that can be used in a multi-service environment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了向应用程序添加日志功能的不同方法。我们还了解了`golog`库，它提供的灵活性和功能比标准库所能提供的更多。我们研究了创建自己的简单日志服务器，使我们的应用程序能够发送在多服务环境中使用的日志信息。
- en: In the next chapter, we will look at how to add observability functionality
    to applications. We will look at tracing and metrics and go through the OpenTelemetry
    specification.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何向应用程序添加可观察性功能。我们将探讨跟踪和指标，并介绍OpenTelemetry规范。
