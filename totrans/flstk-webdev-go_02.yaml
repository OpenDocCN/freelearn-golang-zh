- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building any kind of application to fulfill a user’s need is one piece of the
    puzzle; another piece is figuring out how we are going to design it so that we
    can support it in case there are issues in production. Logging is one of the most
    important things that need to be thought about thoroughly to allow some visibility
    when a problem arises. Application logging is the process of saving application
    events and errors; put simply, it produces a file that contains information about
    events that occur in your software application. Supporting applications in production
    requires a quick turnaround, and to achieve this, sufficient information should
    be logged by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at building a logging server that will be used
    to log events (e.g., errors) from our application. We will also learn how to multiplex
    logging to allow us to log different events based on how we configure it. We will
    cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Go standard logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing log messages to the logging server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring multiple outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02),
    while the logging server can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver)
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Go standard logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the default logging library provided by the
    Go language. Go provides a rich set of libraries; however, like every other library,
    there are limitations – it does not provide leveled logging (`INFO`, `DEBUG`,
    etc.), file log file features, and many more. These limitations can be overcome
    by using open source logging libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides very diverse and rich standard libraries for applications. Logging
    is one of them, and it is available inside the `log` package. The following documentation
    link provides complete information on the different functions available inside
    the [https://pkg.go.dev/log@latest](mailto:https://pkg.go.dev/log@latest) package.
  prefs: []
  type: TYPE_NORMAL
- en: Another package that is available in Go standard library is the `fmt` package,
    which provides functions for I/O operations such as printing, input, and so on.
    More information can be found at `https://pkg.go.dev/fmt@latest`. The available
    functions inside the `log` package are similar to the `fmt` package, and when
    going through the sample code, we will see that it is super easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the functions provided by the `log` package (`https://pkg.go.dev/log)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at the example code from the sample repository, [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter02).
    The `main.go` file resides inside `example/stdlog`. To understand how to use the
    `log` package, build and run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On a successful run, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that the standard logging library is configurable to allow
    different log output formats – for example, you can see in the following that
    the message is prefixed with the formatted date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function that takes care of formatting the prefix for logging is the `SetFlags(..)`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code sets the flag to use `LstdFlags`, which is a combination of date and
    time. The following table shows the different flags that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `Ldate` | A flag to specify the date in the local time zone in the format
    YYYY/MM/DD |'
  prefs: []
  type: TYPE_TB
- en: '| `Ltime` | A flag to specify time using the local time zone in the format
    HH:MM:SS |'
  prefs: []
  type: TYPE_TB
- en: '| `Lmicroseconds` | A flag to specify in microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `Llongfile` | A flag to specify the filename and line number |'
  prefs: []
  type: TYPE_TB
- en: '| `Lshortfile` | The final filename element and line number |'
  prefs: []
  type: TYPE_TB
- en: '| `LUTC` | When using the `Ldate` or `Ltime` flag, we can use this flag to
    specify using UTC instead of the local time zone |'
  prefs: []
  type: TYPE_TB
- en: '| `Lmsgprefix` | A flag to specify the prefix text to be shown before the message
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LstdFlags` | This flag uses the standard flag that has been defined, which
    is basically `Ldate` or `Ltime` |'
  prefs: []
  type: TYPE_TB
- en: The standard library can cover some use cases for application log requirements,
    but there are times when applications require more features that are not available
    from the standard library – for example, sending log information to multiple outputs
    will require extra functionality to be built, or in another scenario, you might
    need to convert nested error logs into JSON format. In the next section, we will
    explore another alternative for our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Using golog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand what is available in the standard library, we want to
    explore the option of using a library that can provide us with more flexibility.
    We will look at the `golog` open source project ([https://github.com/kataras/golog](https://github.com/kataras/golog)).
    The `golog` library is a dependency-free logging library that provides functionality
    such as leveled logging (`INFO`, `ERROR`, etc.), JSON-based output, and configurable
    color output.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most used features of logging is log levels, also known as leveled
    logging. Log levels are used to categorize output information from an application
    into different severity levels. The following table shows the different severity
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `INFO` | Just for information purposes |'
  prefs: []
  type: TYPE_TB
- en: '| `WARN` | Something is not running correctly, so keep an eye out for it in
    case there are more severe errors |'
  prefs: []
  type: TYPE_TB
- en: '| `ERROR` | There is an error that will need some attention |'
  prefs: []
  type: TYPE_TB
- en: '| `DEBUG` | Information that is important to assist in troubleshooting in production,
    or added into the application for tracing purposes |'
  prefs: []
  type: TYPE_TB
- en: '| `FATAL` | Something bad happened in the application that requires immediate
    response/investigation |'
  prefs: []
  type: TYPE_TB
- en: 'Example code can be found inside the `example/golog` directory. Build and run
    the code, and you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Example of golog output](img/Figure_2.1_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Example of golog output
  prefs: []
  type: TYPE_NORMAL
- en: Each prefix of the log messages is of a different color, which corresponds to
    the different severity levels; this is useful when you are going through a long
    list of log messages. Different log levels are assigned different colors to make
    it easy to go through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to generate this log is similar to the standard library code, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The library provides level-based logging. This means that the library can show
    log messages based on what is configured to be shown; for example, for development,
    we want to configure the logger to show all log messages, while in production,
    we want to show only error messages. The following table shows what the output
    will look like when different levels are configured for `golog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| `golog.SetLevel("info")` | `2021/10/15 12:07 This is a raw message, no levels,`
    `no colors.``[INFO] 2021/10/15 12:07 This is an info message, with colors (if
    the output` `is terminal)``[WARN] 2021/10/15 12:07 This is a` `warning message``[ERRO]
    2021/10/15 12:07 This is an` `error message``[FTAL] 2021/10/15 12:07 Fatal will
    exit no` `matter what` |'
  prefs: []
  type: TYPE_TB
- en: '| `golog.SetLevel("debug")` | `2021/10/15 12:08 This is a raw message, no levels,`
    `no colors.``[INFO] 2021/10/15 12:08 This is an info message, with colors (if
    the output` `is terminal)``[WARN] 2021/10/15 12:08 This is a` `warning message``[ERRO]
    2021/10/15 12:08 This is an` `error message``[DBUG] 2021/10/15 12:08 This is a`
    `debug message``[FTAL] 2021/10/15 12:08 Fatal will exit no` `matter what` |'
  prefs: []
  type: TYPE_TB
- en: '| `golog.SetLevel("warn")` | `2021/10/15 12:08 This is a raw message, no levels,`
    `no colors.``[WARN] 2021/10/15 12:08 This is a` `warning message``[ERRO] 2021/10/15
    12:08 This is an` `error message``[FTAL] 2021/10/15 12:08 Fatal will exit no`
    `matter what` |'
  prefs: []
  type: TYPE_TB
- en: '| `golog.SetLevel("error")` | `2021/10/15 12:11 This is a raw message, no levels,`
    `no colors.``[ERRO] 2021/10/15 12:11 This is an` `error message``[FTAL] 2021/10/15
    12:11 Fatal will exit no` `matter what` |'
  prefs: []
  type: TYPE_TB
- en: '| `golog.SetLevel("fatal")` | `2021/10/15 12:11 This is a raw message, no levels,`
    `no colors.``[FTAL] 2021/10/15 12:11 Fatal will exit no` `matter what` |'
  prefs: []
  type: TYPE_TB
- en: We covered golog and its features in this section, and now we have a good understanding
    of the different options available for us to use for logging. In the next section,
    we will look at golog a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Local logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of how to use golog, we are going to use more of its
    features to extend it. The library provides a function allowing applications to
    handle writing the log messages for each log level – for example, an application
    wants to write all errors into a file while the rest print out into the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to take a look at the example code inside the `example/gologmoutput`
    directory. Build and run it and you will see two new files created called `infoerr.txt`
    and `infolog.txt`. The output from both files will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The app uses the `os.OpenFile` standard library to create or append files called
    `infolog.txt` and `infoerr.txt`, which will contain different log information
    that is configured using the golog `SetLevelOutput` function. The following is
    the snippet of the function that configured the different logging output using
    golog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the log-level messages are written to `stdout`, which is configured
    by default by the library.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to configure golog to allow us to log errors
    and information separately. This is super useful as, in production, we will have
    a hard time if we log everything into a single file. In the next section, we will
    look at building our own simple logging server to accept log requests from our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing log messages to the logging server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the modern cloud environment, there are multiple instances of the same application
    running on different servers. Due to the distributed nature of the cloud environment,
    it will be hard to keep track of the different logs produced by the different
    application instances. This will require using a centralized logging system that
    will be able to capture all the different log messages from the different applications
    and systems.
  prefs: []
  type: TYPE_NORMAL
- en: For our needs, we will build our own logging server to capture all log messages
    in one single place; the code can be found at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/logserver).
    The logging server will be a central place that will collate log information from
    our application, which will help in troubleshooting when our applications are
    deployed in a cloud environment. The downside of having a central logging server
    is that when the logging server goes down, we have no visibility of the logging
    information except by going to the server that hosts the applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**REST** stands for **representational state transfer**; in layman’s terms,
    it describes a server that uses the HTTP protocol and methods to communicate to
    resources in the server. Information is delivered in different formats, with JSON
    being the most popular format. It is language agnostic, which means that the logging
    server can be used by any application that can send and receive over HTTP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a successful build, the logging server will display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the logging server is up, go back to the `chapter2` root directory where
    the sample app resides and test the app by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On completion, run the new binary called `sampledb`. The `sampledb` app will
    send log messages to the logging server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The logging server runs as a normal HTTP server that listens on port `8010`,
    registering a single endpoint, `/log`, to accept incoming log messages. Let’s
    go through it and try to understand how the logging server works. But before that,
    let’s take a look at how the server code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The server is using a framework called Gorilla Mux ([github.com/gorilla/mux](http://github.com/gorilla/mux)),
    which is responsible for accepting and dispatching incoming requests to their
    respective handler. The `gorilla/mux` package that we are using for this sample
    is used actively by the open source community; however, it is, at the moment,
    looking for a maintainer to continue the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler that takes care of handling the request is inside `initializeRoutes()`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `router.HandleFunc(..)` function configured the `/log` endpoint, which will
    be handled by the `loghandler` function. `Methods("POST")` is instructing the
    framework that it should accept only the `POST` HTTP method for incoming requests
    that hit the `/``log` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to take a look at the `loghandler` function, which is responsible
    for processing the incoming log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `http.ResponseWriter` parameter is a type that is defined as an interface
    to be used to construct an HTTP response – for example, it contains the `WriteHeader`
    method, which allows writing header into the response. The `http.Request` parameter
    provides an interface for the function to interact with the request received by
    the server – for example, it provides a `Referer` function to obtain a referring
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loghandler` function does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the request body as it contains the log message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On successful reading of the body, the handler will return HTTP status code
    `201` (`StatusCreated`). Code `201` means the request has been processed successfully
    and the resource (in this case, the log JSON message) has been created successfully,
    or in our case, printed successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prints out the log message to `stdout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For more detailed information about the different standard HTTP status codes,
    refer to the following website: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to add logs to an application and how to build a simple
    logging server that can be hosted separately from our application. In the next
    section, we will create a logging wrapper that will allow our application to choose
    whether it wants to log locally or log to a server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring multiple outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we want to configure multiple outputs? Well, it is useful as, during
    development, it is easier to look at logs locally for troubleshooting purposes,
    but in production, it’s not possible to look at a log file, as everything will
    be inside the logging server.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to write a thin layer of wrapper code that will wrap the `golog`
    library; the code that we are going to look at is inside the `chapter2/` directory,
    inside the `logger/log.go` file. The benefit of having a wrapper code for the
    `golog` library is to isolate the application for interfacing directly with the
    library; this will make it easy to swap to different logging libraries when and
    if required. The app configured the wrapper code by passing the parsed flag to
    the `SetLoggingOutput(..)` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the application by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it, passing the flag to `true` as follows to write the log message
    to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The debug log will be printed out in `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Log output from sampledb](img/Figure_2.2_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Log output from sampledb
  prefs: []
  type: TYPE_NORMAL
- en: 'All info log messages will be printed out into the `logs.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Log messages inside logs.txt](img/Figure_2.3_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Log messages inside logs.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'The logger is configured by the application using the `local` flag by calling
    the `SetLoggingOutput(..)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Two main functions in the wrapper code do most of the wrapping of the `golog`
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configureLocal()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configureRemote()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `configureLocal()` function is responsible for configuring logging to write
    to both `stdout` and the configured file named `logs.txt`. The function configured
    golog to set the output to `stdout` and the level to `debug`, which means that
    everything will be going to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other function is `configureRemote()`, which configures golog to send all
    messages to the remote server in JSON format. The `SetLevelOutput()` function
    accepts the `io.Writer` interface, which the sample app has implemented to send
    all info log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Write(data []byte)` function performs a `POST` operation, passing the
    log message to the logging server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this final section, we have learned how to create configurable logging that
    will allow applications to log either locally or remotely. This helps our application
    to be prepared and deployable in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at different ways of adding log functionality
    to applications. We also learned about the `golog` library, which provides more
    flexibility and features than the standard library can offer. We looked at creating
    our own simple logging server that enables our application to send log information
    that can be used in a multi-service environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to add observability functionality
    to applications. We will look at tracing and metrics and go through the OpenTelemetry
    specification.
  prefs: []
  type: TYPE_NORMAL
