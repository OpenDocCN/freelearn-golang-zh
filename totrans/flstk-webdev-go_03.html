<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer031">
<h1 class="chapter-number" id="_idParaDest-37"><a id="_idTextAnchor038"/>3</h1>
<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/>Application Metrics and Tracing</h1>
<p>In <a href="B18295_02.xhtml#_idTextAnchor029"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Application Logging</em>, we looked at logging, and how we use logging inside our backend Go code. In this chapter, we will proceed to look at monitoring and tracing. To monitor and trace the application, we will look into different open source tools <span class="No-Break">and libraries.</span></p>
<p>We have started building our application, and now we need to start looking into how we are going to support it. Once an application is running in production, we need to see what’s happening in the application. Having this kind of visibility will allow us to understand problems that come up. In software systems, we will often come across the concept of <em class="italic">observability</em>. The<a id="_idIndexMarker081"/> concept refers to the ability of software systems to capture and store data used for analysis and troubleshooting purposes. This includes the processes and tools used in order to achieve the goal of allowing users to observe what’s happening in <span class="No-Break">the system.</span></p>
<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding the <span class="No-Break">OpenTelemetry specification</span></li>
<li><span class="No-Break">Tracing applications</span></li>
<li>Adding metrics to our application <span class="No-Break">using Prometheus</span></li>
<li><span class="No-Break">Running </span><span class="No-Break"><strong class="source-inline">docker-compose</strong></span></li>
</ul>
<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Technical requirements</h1>
<p>All the source code explained in this chapter is available from GitHub <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03</span></a><span class="No-Break">.</span></p>
<p>We will be using another tool called OpenTelemetry, which will be explained in the next section, and the version that we use in this book is v1.2.0, available <span class="No-Break">here: </span><a href="https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0"><span class="No-Break">https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor041"/>Understanding OpenTelemetry</h1>
<p>OpenTelemetry<a id="_idIndexMarker082"/> is an open source project that enables developers to provide observability capability to their applications. The project provides a Software Development Kit (SDK) for different programming languages, with Go as one of the supported languages, which is integrated with the application. The SDK is<a id="_idIndexMarker083"/> for metric collection and reporting, as it provides integration with different open source frameworks, making the integration process seamless. OpenTelemetry also provides a common standard, providing the application flexibility to report the collected data to different observability backend systems. OpenTelemetry’s website <a id="_idIndexMarker084"/>is <span class="No-Break">at </span><a href="https://opentelemetry.io/"><span class="No-Break">https://opentelemetry.io/</span></a><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="" height="683" src="image/Figure_3.1_B18295.jpg" width="1125"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – OpenTelemetry logo</p>
<p><strong class="bold">OpenTelemetry</strong> is<a id="_idIndexMarker085"/> actually the merging of the OpenTracing and OpenCensus projects. The project is used to instrument, collect, and export metrics, logs, and traces. OpenTelemetry can be used across several languages, and Go is one of the <span class="No-Break">supported languages.</span></p>
<p>The main benefit of following the OpenTelemetry specification<a id="_idIndexMarker086"/> is that it is vendor-agnostic, which means that applications written using their APIs are portable across different observability vendors. For example, applications that are written to write metrics into a filesystem will require a few lines of code changes to allow it to store metrics in Prometheus, which we will discuss in the <em class="italic">Adding metrics using </em><span class="No-Break"><em class="italic">Prometheus</em></span><span class="No-Break"> section.</span></p>
<p>The two main components of OpenTelemetry are <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Tracing</strong>: This <a id="_idIndexMarker087"/>provides applications with the capability to track service requests as they flow through systems by collecting data. For example, with the tracing capability, we can see how an HTTP request flows through the different systems in <span class="No-Break">the network.</span></li>
<li><strong class="bold">Metrics</strong>: This <a id="_idIndexMarker088"/>provides applications with the ability to collect and store measurements for detecting performance anomalies and forecasting. For example, collecting metrics in our application will give us visibility into how long a database query takes or how long it takes to process a certain <span class="No-Break">batch job.</span></li>
</ul>
<p>You can find the<a id="_idIndexMarker089"/> OpenTelemetry specification at the following <span class="No-Break">link: </span><a href="https://opentelemetry.io/docs/reference/specification/"><span class="No-Break">https://opentelemetry.io/docs/reference/specification/</span></a><span class="No-Break">.</span></p>
<p>The specification<a id="_idIndexMarker090"/> allows users to plug-and-play different OpenTelemetry implementations easily without any dependency on single-vendor libraries. This means that all the relevant contracts that are outlined in the specification document can be implemented. Some concepts are important to understand in order to use OpenTelemetry effectively. The following are the concepts that are relevant to <span class="No-Break">the specification:</span></p>
<ul>
<li><strong class="bold">Components</strong>: These <a id="_idIndexMarker091"/>are basically the core vendor-agnostic specifications, outlining the different parts of the system that need to be implemented. The components are collectors, the APIs, the SDK, and <span class="No-Break">instrumenting libraries.</span></li>
<li><strong class="bold">Data sources</strong>: This <a id="_idIndexMarker092"/>is the data that the specification supports: traces, logs, metrics, <span class="No-Break">and baggage.</span></li>
<li><strong class="bold">Instrumenting and libraries</strong>: There are <a id="_idIndexMarker093"/>two ways to integrate the provided library – either automatically by using the library provided by the vendor or open source contribution, or manually as per the <span class="No-Break">application requirements.</span></li>
</ul>
<p>In the next section, we are going to look at the implementation side of the specification, which involves both the APIs and <span class="No-Break">the SDK.</span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>The OpenTelemetry APIs and SDK</h2>
<p>OpenTelemetry is made of several components, and two of the main components that we are going to talk about are the APIs and SDK. The specification defines cross-language requirements that any implementation must adhere to as part of <span class="No-Break">the requirements:</span></p>
<ul>
<li>The <strong class="bold">APIs</strong>: This <a id="_idIndexMarker094"/>defines the data types and operations that will be used to generate <span class="No-Break">telemetry data</span></li>
<li>The <strong class="bold">SDK</strong>: This <a id="_idIndexMarker095"/>defines the implementation of the APIs for processing and <span class="No-Break">exporting capabilities</span></li>
</ul>
<p>There is a clear distinction between the APIs and SDK – it’s clear that the APIs are contracts that are provided by the specification, while the SDK provides the different functionalities required to allow metrics data to be processed and exported. Metrics data contains information such as memory used, CPU <span class="No-Break">usage, etc.</span></p>
<p>The specification provides an API for <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Context</strong>: This<a id="_idIndexMarker096"/> contains the values that are carried around across API calls. This is data that can be passed between system calls and carry <span class="No-Break">application information.</span></li>
<li><strong class="bold">Baggage</strong>: A set <a id="_idIndexMarker097"/>of name-value pairs describing <span class="No-Break">user-defined properties.</span></li>
<li><strong class="bold">Tracing</strong>: An API <a id="_idIndexMarker098"/>definition that provides the <span class="No-Break">tracing functionality</span></li>
<li><strong class="bold">Metrics</strong>: An API<a id="_idIndexMarker099"/> definition that provides the metric <span class="No-Break">recording functionality</span></li>
</ul>
<p>We will look at how the OpenTelemetry tracing API looks and how to add the tracing capability <span class="No-Break">to applications.</span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor043"/>Tracing applications</h1>
<p>In the previous chapter, we learned <a id="_idIndexMarker100"/>about logging and how logging can give us visibility into what’s going on inside our application. The line between logging and tracing is blurry; what we need to understand is that logging just provides information on what a process is currently doing, while tracing gives us cross-cutting visibility across different components, allowing us to get a better understanding of the data flow and time taken for a process <span class="No-Break">to complete.</span></p>
<p>For example, with tracing, we can answer questions such as <span class="No-Break">the following:</span></p>
<ul>
<li>How long does the add-to-cart <span class="No-Break">process take?</span></li>
<li>How long does it take to download a <span class="No-Break">payment file?</span></li>
</ul>
<p>We will go through the<a id="_idIndexMarker101"/> different APIs that are outlined in the specification and implement those APIs using the implementation provided by the <span class="No-Break">OpenTelemetry library.</span></p>
<p>The following figure shows the links between <span class="No-Break">different entities.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="" height="162" src="image/Figure_3.2_B18295.jpg" width="505"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Tracing an API relationship</p>
<p><strong class="bold">TracerProvider</strong> is the<a id="_idIndexMarker102"/> entry point to use the tracing API and it provides access to <strong class="bold">Tracer</strong>, which is responsible for creating <strong class="bold">Span</strong>. <strong class="bold">Span</strong> is used to trace an operation in our application. Before we move further to the next layer, which is the SDK, we will take a look briefly at <strong class="bold">Jaeger</strong>, which is one of the support tools provided by the OpenTelemetry library <span class="No-Break">for tracing.</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Installing Jaeger</h2>
<p>Jaeger (<a href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a>) is a <a id="_idIndexMarker103"/>popular open source distributed tracing platform; it <a id="_idIndexMarker104"/>provides its own client libraries for a wide variety of programming languages, which can be seen at <a href="https://github.com/orgs/jaegertracing/repositories">https://github.com/orgs/jaegertracing/repositories</a>. We will be running Jaeger as a Docker container to reduce the amount of setup that is required when installing the application manually. Let’s start up Jaeger using the following <span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
docker run --name jaeger \
  -p 5775:5775/udp \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 14268:14268 \
  -p 14250:14250 \
  -p 9411:9411 \
  jaegertracing/all-in-one:latest</pre>
<p>On successful launch, there will be a lot of logs printed that look like <span class="No-Break">the following:</span></p>
<pre class="console">
{"level":"info","ts":1637930923.8576558,"caller":"flags/service.go:117","msg":"Mounting metrics handler on admin server","route":"/metrics"}
{"level":"info","ts":1637930923.857689,"caller":"flags/service.go:123","msg":"Mounting expvar handler on admin server","route":"/debug/vars"}
{"level":"info","ts":1637930923.8579082,"caller":"flags/admin.go:104","msg":"Mounting health check on admin server","route":"/"}
{"level":"info","ts":1637930923.8579528,"caller":"flags/admin.go:115","msg":"Starting admin HTTP server","http-addr":":14269"}
…
…
{"level":"info","ts":1637930923.8850179,"caller":"app/server.go:258","msg":"Starting HTTP server","port":16686,"addr":":16686"}
{"level":"info","ts":1637930923.8850145,"caller":"healthcheck/handler.go:129","msg":"Health Check state change","status":"ready"}
{"level":"info","ts":1637930923.8850334,"caller":"app/server.go:277","msg":"Starting GRPC server","port":16685,"addr":":16685"}
{"level":"info","ts":1637930924.8854718,"caller":"channelz/logging.go:50","msg":"[core]Subchannel Connectivity change to IDLE","system":"grpc","grpc_log":true}
{"level":"info","ts":1637930924.8855824,"caller":"grpclog/component.go:71","msg":"[core]pickfirstBalancer: UpdateSubConnState: 0xc00003af30, {IDLE connection error: desc = \"transport: Error while dialing dial tcp :16685: connect: connection refused\"}","system":"grpc","grpc_log":true}
{"level":"info","ts":1637930924.885613,"caller":"channelz/logging.go:50","msg":"[core]Channel Connectivity change to IDLE","system":"grpc","grpc_log":true}</pre>
<p>Jaeger is<a id="_idIndexMarker105"/> now ready, the tool is not a desktop application but it provides a user interface that is accessible using the browser. Open your browser and type in the following URL: http://localhost:16686. It will open the Jaeger main page (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="" height="1153" src="image/Figure_3.3_B18295.jpg" width="1545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Jaeger main page</p>
<p>At the moment, Jaeger does<a id="_idIndexMarker106"/> not contain anything, as there are no applications that are <span class="No-Break">using it.</span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor045"/>Integrating the Jaeger SDK</h1>
<p>Now that Jaeger is ready, let’s<a id="_idIndexMarker107"/> look at how we are going to write tracing information using OpenTelemetry. The library provides support for the Jaeger SDK out of the box; this allows applications to use the API to write tracing <span class="No-Break">to Jaeger.</span></p>
<p>The example that we will be using in this section is inside the <strong class="source-inline">jaeger/opentelem/trace</strong> directory in the chapter’s GitHub repository. The file that we want to look at is <strong class="source-inline">tracing.go</strong> as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
  package trace
  import (
           «context»
           «go.opentelemetry.io/otel"
           «go.opentelemetry.io/otel/exporters/jaeger"
           «go.opentelemetry.io/otel/sdk/resource"
           «go.opentelemetry.io/otel/sdk/trace"
           sc "go.opentelemetry.io/otel/semconv/v1.4.0"
  )
  type ShutdownTracing func(ctx context.Context) error
  func InitTracing(service string) (ShutdownTracing, error)
  {
    // Create the Jaeger exporter.
    exp, err := jaeger.New(jaeger.WithCollectorEndpoint())
    if err != nil {
     return func(ctx context.Context) error { return nil },
       err
    }
    // Create the TracerProvider.
    tp := trace.NewTracerProvider(
            trace.WithBatcher(exp),
            trace.WithResource(resource.NewWithAttributes(
                    sc.SchemaURL,
                    sc.ServiceNameKey.String(service),
            )),
    )
    otel.SetTracerProvider(tp)
    return tp.Shutdown, nil
  }</pre>
<p>Let’s take a look at what each part of the code is doing. Line 18 is initializing the Jaeger SDK inside the OpenTelemetry library. On successfully initializing the Jaeger SDK, the code continues to provide the newly created Jaeger and uses it with the OpenTelemetry library to create a new <strong class="source-inline">TracerProvider</strong> API. As discussed in the previous section, <strong class="source-inline">TracerProvider</strong> is the API that is used as the main entry for OpenTelemetry. This is performed on <span class="No-Break">lines 24-30.</span></p>
<p>On obtaining <strong class="source-inline">TracerProvider</strong>, we will need to call the global <strong class="source-inline">SetTracerProvider</strong> to let OpenTelemetry know about it, which is done on line 32. Once the Jaeger SDK has <a id="_idIndexMarker108"/>been successfully initialized, now it’s a matter of using it in <span class="No-Break">the application.</span></p>
<p>Let’s take a look at the code sample for using the tracing functionality. The sample application that we are going to look at can be found inside the <strong class="source-inline">jaeger/opentelem</strong> directory <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Integration with Jaeger</h2>
<p>We are going to go <a id="_idIndexMarker109"/>through section by section to explain what the code is doing. The following code section shows the <strong class="source-inline">InitTracing</strong> function that takes care the initialization process <span class="No-Break">being called:</span></p>
<pre class="source-code">
  package main
  import (
           t "chapter.3/trace/trace"
           "context"
           "fmt"
           "go.opentelemetry.io/otel"
           "go.opentelemetry.io/otel/attribute"
           "go.opentelemetry.io/otel/trace"
           "log"
           "sync"
           "time"
  )
  const serviceName = "tracing"
  func main() {
    sTracing, err := t.InitTracing(serviceName)
    if err != nil {
      log.Fatalf("Failed to setup tracing: %v\n", err)
    }
    defer func() {
      if err := sTracing(context.Background()); err != nil
      {
        log.Printf("Failed to shutdown tracing: %v\n", err)
      }
    }()
    ctx, span := otel.Tracer(serviceName)
                 .Start(context.Background(), "outside")
    defer span.End()
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
      _, s := otel.Tracer(serviceName).Start(ctx, "inside")
      ...
      wg.Done()
    }()
      wg.Add(1)
      go func() {
        _, ss := otel.Tracer(serviceName).Start(ctx,
                                                "inside")
       ...
        wg.Done()
      }()
      wg.Wait()
      fmt.Println("\nDone!")
  }</pre>
<p>Once the<a id="_idIndexMarker110"/> SDK completes the initialization process, the code can start using the API to write tracing information and this is done by getting a <strong class="source-inline">Span</strong> using the <strong class="source-inline">Tracer</strong> API as shown on lines 27-29. The code uses <strong class="source-inline">sync.WaitGroup</strong> (lines 35 and 45) to ensure that the <strong class="source-inline">main</strong> thread does not finish before the goroutine completes – the goroutine is added to simulate some kind of processing to be done to generate a trace that will be reported <span class="No-Break">to Jaeger.</span></p>
<p>The <strong class="source-inline">Tracer</strong> API only has one <strong class="source-inline">Start</strong> function, which is called to initiate the tracing operation, and the tracing operation is considered complete when the <strong class="source-inline">End</strong> function is called on <strong class="source-inline">Span</strong> – so, what is <strong class="source-inline">Span</strong>? <strong class="source-inline">Span</strong> is an API for tracing an operation; it has the following <span class="No-Break">interface declaration:</span></p>
<pre class="source-code">
type Span interface {
  End(options ...SpanEndOption)
  AddEvent(name string, options ...EventOption)
  IsRecording() bool
  RecordError(err error, options ...EventOption)
  SpanContext() SpanContext
  SetStatus(code codes.Code, description string)
  SetName(name string)
  SetAttributes(kv ...attribute.KeyValue)
  TracerProvider() TracerProvider
}</pre>
<p>Multiple spans are pieced together to create a trace; it can be thought of as a <strong class="bold">Directed Acyclic Graph</strong> (<strong class="bold">DAG</strong>) <span class="No-Break">of spans.</span></p>
<p class="callout-heading">DAGs</p>
<p class="callout">A DAG is<a id="_idIndexMarker111"/> a term used in mathematics and computer science. It is a graph that shows dependencies, which, in our case, are the dependencies of <span class="No-Break">application traces.</span></p>
<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em> shows what the composition of the trace <span class="No-Break">looks like:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="" height="306" src="image/Figure_3.4_B18295.jpg" width="987"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – A DAG of a simple trace</p>
<p>The<a id="_idIndexMarker112"/> sample code creates two goroutines to perform a <strong class="source-inline">sleep</strong> operation and write trace information as <span class="No-Break">shown below:</span></p>
<pre class="source-code">
go func() {
  _, s := otel.Tracer(serviceName).Start(ctx, "inside")
  defer s.End()
  time.Sleep(1 * time.Second)
  s.SetAttributes(attribute.String("sleep", "done"))
  s.SetAttributes(attribute.String("go func", "1"))
  wg.Done()
}()
...
...
go func() {
  _, ss := otel.Tracer(serviceName).Start(ctx, "inside")
  defer ss.End()
  time.Sleep(2 * time.Second)
  ss.SetAttributes(attribute.String("sleep", "done"))
  ss.SetAttributes(attribute.String("go func", "2"))
  wg.Done()
}()</pre>
<p>Run the <a id="_idIndexMarker113"/>complete sample application in <strong class="source-inline">main.go</strong> inside the <strong class="source-inline">jaeger/opentelem</strong> directory using the <span class="No-Break">following command:</span></p>
<pre class="console">
go run main.go</pre>
<p>Upon completion, the application will write tracing information into Jaeger. Open Jaeger by accessing http://localhost:16686 in your browser. Once it’s opened, you will see a new entry under the <strong class="bold">Service</strong> dropdown as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="" height="1184" src="image/Figure_3.5_B18295.jpg" width="765"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Application trace search</p>
<p>The sample application tracing information is registered with the same string defined in the code, which is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">tracing</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const serviceName = "tracing"</pre>
<p>Clicking on the <strong class="bold">Find Traces</strong> button will read the trace information that is stored (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<img alt="" height="623" src="image/Figure_3.6_B18295.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Application traces</p>
<p>As can be seen in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em>, there is only one entry and if you click on it, it will expand more information that the app has submitted via the <span class="No-Break"><strong class="source-inline">Span</strong></span><span class="No-Break"> API.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<img alt="" height="182" src="image/Figure_3.7_B18295.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Tracing information</p>
<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.7</em> shows the complete tracing information, which is a composition of spans from the application. Clicking on <a id="_idIndexMarker114"/>each of the graphs will bring up more information included in the span, which is included as shown in the <span class="No-Break">code here:</span></p>
<pre class="source-code">
go func() {
  ...
  s.SetAttributes(attribute.String("sleep", "done"))
  s.SetAttributes(attribute.String("go func", "1"))
  ...
}()
...
go func() {
  ...
  ss.SetAttributes(attribute.String("sleep", "done"))
  ss.SetAttributes(attribute.String("go func", "2"))
  ...
}()</pre>
<p>Now that we know how to add tracing to our application, in the next section, we will look at adding metric instrumentation that will give us visibility into some of the performance metrics relevant to <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor047"/>Adding metrics using Prometheus</h1>
<p>As OpenTelemetry is vendor-agnostic, it provides a wide variety of support for monitoring, exporting, and collecting metrics and one option is Prometheus. A complete list of different projects supported by OpenTelemetry<a id="_idIndexMarker115"/> can be found at <a href="https://opentelemetry.io/registry/">https://opentelemetry.io/registry/</a>. Prometheus<a id="_idIndexMarker116"/> is an open source monitoring and alerting system server that is widely used in cloud environments; it also provides libraries for a variety of <span class="No-Break">programming languages.</span></p>
<p>In the previous section, we saw how to add tracing capabilities to our application and how to retrieve the traces by using Jaeger. In this section, we are going to take a look at how to create metrics using the <strong class="source-inline">OpenTelemetry</strong> library. Metrics<a id="_idIndexMarker117"/> allow us to get instrumentation information for our applications; it can provide answers to questions such as <span class="No-Break">the following:</span></p>
<ul>
<li>What is the total number of requests processed in <span class="No-Break">service A?</span></li>
<li>How many total transactions are processed via payment <span class="No-Break">gateway B?</span></li>
</ul>
<p>Normally, collected metrics are stored for a certain amount of time to give us better insights into how the applications are performing by looking at a <span class="No-Break">specific metric.</span></p>
<p>We will use the<a id="_idIndexMarker118"/> Prometheus open source project (<a href="https://prometheus.io/">https://prometheus.io/</a>), which<a id="_idIndexMarker119"/> provides a complete monitoring solution stack and is very easy to use. The project provides a lot of features that are useful for collecting and storing metrics and monitoring <span class="No-Break">our applications.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<img alt="" height="1123" src="image/Figure_3.8_B18295.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – The Prometheus monitoring stack</p>
<p>Similar <a id="_idIndexMarker120"/>to tracing, the OpenTelemetry specification <a id="_idIndexMarker121"/>specifies the API and SDK for metrics, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<img alt="" height="162" src="image/Figure_3.9_B18295.jpg" width="505"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Metrics API</p>
<p>The following are explanations of the <span class="No-Break">metrics APIs:</span></p>
<ul>
<li><strong class="bold">MeterProvider</strong>: This is <a id="_idIndexMarker122"/>an API for providing access <span class="No-Break">to meters.</span></li>
<li><strong class="bold">Meter</strong>: This is <a id="_idIndexMarker123"/>responsible for creating instruments, and is unique to the instrumentation <span class="No-Break">in question.</span></li>
<li><strong class="bold">Instrument</strong>: This <a id="_idIndexMarker124"/>contains the metric that we want to report; it can be synchronous <span class="No-Break">or asynchronous.</span></li>
</ul>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>Adding metrics using Prometheus</h2>
<p>Let’s start<a id="_idIndexMarker125"/> up Prometheus; make sure from your terminal<a id="_idIndexMarker126"/> that you are inside the <strong class="source-inline">chapter3/prom/opentelem</strong> directory and execute the following <span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
docker run --name prom \
-v $PWD/config.yml:/etc/prometheus/prometheus.yml \
-p 9090:9090 prom/prometheus:latest</pre>
<p class="callout-heading">NOTE:</p>
<p class="callout">If you are using a Linux machine, use the <span class="No-Break">following command:</span></p>
<pre class="console">
 docker run --name prom \
 -v $PWD/config.yml:/etc/prometheus/prometheus.yml\
 -p 9090:9090  --add-host=host.docker.internal:host-gateway prom/prometheus:latest</pre>
<p class="callout">The extra parameter, <strong class="source-inline">--add-host=host.docker.internal:host-gateway</strong>, will allow Prometheus to access the host machine using the <strong class="source-inline">host.docker.internal</strong> <span class="No-Break">machine name.</span></p>
<p>The <strong class="source-inline">config.yml</strong> file used for configuring Prometheus is inside the <strong class="source-inline">prom/opentelem</strong> directory and looks like <span class="No-Break">the following:</span></p>
<pre class="source-code">
scrape_configs:
 - job_name: 'prometheus'
   scrape_interval: 5s
   static_configs:
     - targets:
         - host.docker.internal:2112</pre>
<p>We will not <a id="_idIndexMarker127"/>go through the different available <a id="_idIndexMarker128"/>Prometheus configuration options in this section. The configuration we are using informs Prometheus that we want to get metrics from the container host, which is known internally in the container as <strong class="source-inline">host.docker.internal</strong>, at port <strong class="source-inline">2112</strong>, at an interval of <span class="No-Break">5 seconds.</span></p>
<p>Once Prometheus successfully runs, you will see the <span class="No-Break">following log:</span></p>
<pre class="console">
….
ts=2021-11-30T11:13:56.688Z caller=main.go:451 level=info fd_limits="(soft=1048576, hard=1048576)"
...
ts=2021-11-30T11:13:56.694Z caller=main.go:996 level=info msg="Loading configuration file" filename=/etc/prometheus/prometheus.yml
ts=2021-11-30T11:13:56.694Z caller=main.go:1033 level=info msg="Completed loading of configuration file" filename=/etc/prometheus/prometheus.yml totalDuration=282.112µs db_storage=537ns remote_storage=909ns web_handler=167ns query_engine=888ns scrape=126.942µs scrape_sd=14.003µs notify=608ns notify_sd=1.207µs rules=862ns
ts=2021-11-30T11:13:56.694Z caller=main.go:811 level=info msg="Server is ready to receive web requests."</pre>
<p>Next, open your browser and type in the following: http://localhost:9090. You will be shown the main <span class="No-Break">Prometheus UI:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<img alt="" height="615" src="image/Figure_3.10_B18295.jpg" width="1552"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – The Prometheus UI</p>
<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.11</em> shows<a id="_idIndexMarker129"/> the way Prometheus collects metrics via a <a id="_idIndexMarker130"/>pulling mechanism where it <em class="italic">pulls</em> metric information from your application by connecting to port <strong class="source-inline">2112</strong>, which is exposed by the HTTP server running in the application. We will see later that most of the heavy lifting is done by the <strong class="source-inline">OpenTelemetry</strong> library; our application will just have to provide the metric that we want to <span class="No-Break">report on.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<img alt="" height="116" src="image/Figure_3.11_B18295.jpg" width="507"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Prometheus metric collection</p>
<p>Now that Prometheus is ready, we can start recording metrics to for our application. Run the application inside the <strong class="source-inline">prom/opentelem</strong> directory <span class="No-Break">as follows:</span></p>
<pre class="console">
go run main.go</pre>
<p>Let the application run for a bit and you will see the <span class="No-Break">following log:</span></p>
<pre class="console">
2021/11/30 22:42:08 Starting up server on port 8000
2021/11/30 22:42:12 Reporting metric metric.random
2021/11/30 22:42:22 Reporting metric metric.random
2021/11/30 22:42:32 Reporting metric metric.random
2021/11/30 22:42:47 Reporting metric metric.random
2021/11/30 22:42:57 Reporting metric metric.random</pre>
<ul>
<li><strong class="source-inline">metric.totalrequest</strong>: This metric reports the total number of requests processed by the application; the sample application has an HTTP server running on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">8000</strong></span></li>
<li><strong class="source-inline">metric.random</strong>: This metric reports a <span class="No-Break">random number</span></li>
</ul>
<p>With the <a id="_idIndexMarker131"/>successful run of the sample application, we<a id="_idIndexMarker132"/> can now see the metric in the Prometheus UI. Open your browser and head to http://localhost:9090 and type in <strong class="source-inline">metric_random</strong> and you will see something such as that shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.12</em>; click on the <span class="No-Break"><strong class="bold">Execute</strong></span><span class="No-Break"> button.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="" height="141" src="image/Figure_3.12_B18295.jpg" width="869"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – metric_random metric</p>
<p>Select the <strong class="bold">Graph</strong> tab and you will see the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="" height="718" src="image/Figure_3.13_B18295.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – metric_random graph</p>
<p>The<a id="_idIndexMarker133"/> other metric that we want to show is the total<a id="_idIndexMarker134"/> number of requests processed by the sample application’s HTTP server. In order to generate some metrics, open the browser and enter http://localhost:8000; do so a few times so that some metrics will <span class="No-Break">be generated.</span></p>
<p>Open the Prometheus UI again (http://localhost:9090), add the <strong class="source-inline">metric_totalrequest </strong>metric as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.14</em>, and click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">Execute</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="" height="192" src="image/Figure_3.14_B18295.jpg" width="1655"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – metric_totalrequest metric</p>
<p>The graph will look <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="" height="726" src="image/Figure_3.15_B18295.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – metric_totalrequest graph</p>
<p>If you are <a id="_idIndexMarker135"/>having problems and cannot see the metrics, change<a id="_idIndexMarker136"/> the Prometheus configuration file, <strong class="source-inline">config.yml</strong>, inside the <strong class="source-inline">chapter3/prom/opentelem</strong> directory and change the target from <strong class="source-inline">host.docker.internal</strong> to <strong class="source-inline">localhost</strong> as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
scrape_configs:
 - job_name: 'prometheus'
   scrape_interval: 5s
   static_configs:
     - targets:
     - localhost:2112</pre>
<p>The <strong class="source-inline">metrics.go</strong> source contains the code that initializes the <strong class="source-inline">otel</strong> SDK to configure it for Prometheus, which is shown in the code <span class="No-Break">snippet here:</span></p>
<pre class="source-code">
package metric
...
type ShutdownMetrics func(ctx context.Context) error
// InitMetrics use Prometheus exporter
func InitMetrics(service string) (ShutdownMetrics, error) {
    config := prometheus.Config{}
    c := controller.New(
        processor.NewFactory(
            selector.NewWithExactDistribution(),
            aggregation.CumulativeTemporalitySelector(),
            processor.WithMemory(true),
        ),
        controller.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceNameKey.String(service),
        )),
    )
    exporter, err := prometheus.New(config, c)
    if err != nil {
      return func(ctx context.Context) error { return nil},
        err
    }
    global.SetMeterProvider(exporter.MeterProvider())
    srv := &amp;http.Server{Addr: ":2112", Handler: exporter}
    go func() {
        _ = srv.ListenAndServe()
    }()
    return srv.Shutdown, nil</pre>
<p>The<a id="_idIndexMarker137"/> following code snippet shows how it sends the <a id="_idIndexMarker138"/>metrics to Prometheus – the code can be found in <strong class="source-inline">main.go</strong> inside the <span class="No-Break"><strong class="source-inline">chapter3/prom/opentelem</strong></span><span class="No-Break"> directory:</span></p>
<pre class="source-code">
package main
...
const serviceName = "samplemetrics"
func main() {
    ...
    //setup handler for rqeuest
    r.HandleFunc("/", func(rw http.ResponseWriter, r
      *http.Request) {
        log.Println("Reporting metric metric.totalrequest")
        ctx := r.Context()
        //add request metric counter
        ctr.Add(ctx, 1)
        ...
    }).Methods("GET")
    ...
}</pre>
<p>Now that we have successfully added metrics and tracing to our applications and can view them using both Jaeger and Prometheus; in the next section, we will look at putting all the tools together to make it easy to run them as a <span class="No-Break">single unit.</span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/>Running docker-compose</h1>
<p>We normally run<a id="_idIndexMarker139"/> containers using the <strong class="source-inline">docker</strong> command, but what if we want to run more than one container in one go? This is where <strong class="source-inline">docker-compose</strong> comes to the rescue. The tool allows you to configure the different containers that you want to run as a single unit. It also allows different kinds of configurations for different containers – for example, container A can communicate via the network with container B but not with <span class="No-Break">container C.</span></p>
<p>The <strong class="source-inline">docker-compose</strong> tool that we are using in this book is v2, which is the recommended version. You can find instructions for installing the tool for different operating systems here – <a href="https://docs.docker.com/compose/install/other/"><span class="No-Break">https://docs.docker.com/compose/install/other/</span></a><span class="No-Break">.</span></p>
<p>To make it easy to run both Prometheus and Jaeger, you can use <strong class="source-inline">docker-compose</strong>. The <strong class="source-inline">docker-compose.yml</strong> file looks <span class="No-Break">as follows:</span></p>
<pre class="source-code">
version: '3.3'
services:
 jaeger:
   image: jaegertracing/all-in-one:latest
   ports:
     - "6831:6831/udp"
     - "16686:16686"
     - "14268:14268"
 prometheus:
   image: prom/prometheus:latest
   volumes:
     -./prom/opentelem/config.yml:/etc/prometheus/
      prometheus.yml
   command:
     - '--config.file=/etc/prometheus/prometheus.yml'
     - '--web.console.libraries=/usr/share/prometheus/
       console_libraries'
     - '--web.console.templates=/usr/share/prometheus/
       consoles›
   ports:
     - 9090:9090
   network_mode: "host"</pre>
<p>Run <strong class="source-inline">docker-compose</strong> using <a id="_idIndexMarker140"/>the <span class="No-Break">following command:</span></p>
<pre class="console">
docker-compose -f docker-compose.yml  up</pre>
<p>On a successful run, you will see the <span class="No-Break">following log:</span></p>
<pre class="console">
prometheus_1  | ts=2021-12-04T07:45:02.443Z caller=main.go:406 level=info msg="No time or size retention was set so using the default time retention" duration=15d
prometheus_1  | ts=2021-12-04T07:45:02.443Z caller=main.go:444 level=info msg="Starting Prometheus" version="(version=2.31.1, branch=HEAD, revision=411021ada9ab41095923b8d2df9365b632fd40c3)"
prometheus_1  | ts=2021-12-04T07:45:02.443Z caller=main.go:449 level=info build_context="(go=go1.17.3, user=root@9419c9c2d4e0, date=20211105-20:35:02)"
prometheus_1  | ts=2021-12-04T07:45:02.443Z caller=main.go:450 level=info host_details="(Linux 5.3.0-22-generic #24+system76~1573659475~19.10~26b2022-Ubuntu SMP Wed Nov 13 20:0 x86_64 pop-os (none))"
prometheus_1  | ts=2021-12-04T07:45:02.444Z caller=main.go:451 level=info fd_limits="(soft=1048576, hard=1048576)"
prometheus_1  | ts=2021-12-04T07:45:02.444Z caller=main.go:452 level=info vm_limits="(soft=unlimited, hard=unlimited)"
jaeger_1      | 2021/12/04 07:45:02 maxprocs: Leaving GOMAXPROCS=12: CPU quota undefined
prometheus_1  | ts=2021-12-04T07:45:02.445Z caller=web.go:542 level=info component=web msg="Start listening for connections" address=0.0.0.0:9090
....
....
....
jaeger_1      | {"level":"info","ts":1638603902.657881,"caller":"healthcheck/handler.go:129","msg":"Health Check state change","status":"ready"}
jaeger_1      | {"level":"info","ts":1638603902.657897,"caller":"app/server.go:277","msg":"Starting GRPC server","port":16685,"addr":":16685"}
jaeger_1      | {"level":"info","ts":1638603902.6579142,"caller":"app/server.go:258","msg":"Starting HTTP server","port":16686,"addr":":16686"}</pre>
<p>The <strong class="source-inline">up</strong><a id="_idIndexMarker141"/> parameter we are using will start the container in the terminal and run in attached mode, which allows you to show all the logs on the screen. You also can run in detached mode to run the container in the background <span class="No-Break">as <a id="_idTextAnchor050"/>follows:</span></p>
<pre class="console">
docker-compose -f docker-compose.yml  up -d</pre>
<h1 id="_idParaDest-49"><a id="_idTextAnchor051"/>Summary</h1>
<p>In this section, we looked at how to add metrics and tracing into an application using the <strong class="source-inline">OpenTelemetry</strong> library. Having this observability in an application will enable us to troubleshoot issues faster and also keep track of the performance of our application from the provided metrics. We also took a look at using two different open source projects that allow us to look at the data collected from <span class="No-Break">our application.</span></p>
<p>In this chapter, we looked at the plumbing and infrastructure required to monitor and trace our application. In the next chapter, we will look at different aspects of building both dynamic and static content for our web application and how to package the application to make it easier to <span class="No-Break">deploy anywhere.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer032">
<h1 id="_idParaDest-50"><a id="_idTextAnchor052"/>Part 2:Serving Web Content</h1>
<p>Upon completing this part of the book, you will be able to create server-rendered pages using an  HTML/template and Gorilla Mux. You will also learn how to create and expose an API that will be used by the frontend. Securing the API will be discussed, <span class="No-Break">including middleware.</span></p>
<p>This part includes the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18295_04.xhtml#_idTextAnchor053"><em class="italic">Chapter 4</em></a><em class="italic">, Serving and Embedding HTML Content</em></li>
<li><a href="B18295_05.xhtml#_idTextAnchor070"><em class="italic">Chapter 5</em></a><em class="italic">, Securing the Backend and Middleware</em></li>
<li><a href="B18295_06.xhtml#_idTextAnchor093"><em class="italic">Chapter 6</em></a><em class="italic">, Moving to API-First</em></li>
</ul>
</div>
<div>
<div id="_idContainer033">
</div>
</div>
<div>
<div id="_idContainer034">
</div>
</div>
</div></body></html>