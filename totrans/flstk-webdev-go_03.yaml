- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application Metrics and Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18295_02.xhtml#_idTextAnchor029), *Application Logging*, we
    looked at logging, and how we use logging inside our backend Go code. In this
    chapter, we will proceed to look at monitoring and tracing. To monitor and trace
    the application, we will look into different open source tools and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We have started building our application, and now we need to start looking into
    how we are going to support it. Once an application is running in production,
    we need to see what’s happening in the application. Having this kind of visibility
    will allow us to understand problems that come up. In software systems, we will
    often come across the concept of *observability*. The concept refers to the ability
    of software systems to capture and store data used for analysis and troubleshooting
    purposes. This includes the processes and tools used in order to achieve the goal
    of allowing users to observe what’s happening in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OpenTelemetry specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding metrics to our application using Prometheus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running `docker-compose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the source code explained in this chapter is available from GitHub here:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using another tool called OpenTelemetry, which will be explained
    in the next section, and the version that we use in this book is v1.2.0, available
    here: [https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0](https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OpenTelemetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenTelemetry is an open source project that enables developers to provide observability
    capability to their applications. The project provides a Software Development
    Kit (SDK) for different programming languages, with Go as one of the supported
    languages, which is integrated with the application. The SDK is for metric collection
    and reporting, as it provides integration with different open source frameworks,
    making the integration process seamless. OpenTelemetry also provides a common
    standard, providing the application flexibility to report the collected data to
    different observability backend systems. OpenTelemetry’s website is at [https://opentelemetry.io/](https://opentelemetry.io/).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.1_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – OpenTelemetry logo
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenTelemetry** is actually the merging of the OpenTracing and OpenCensus
    projects. The project is used to instrument, collect, and export metrics, logs,
    and traces. OpenTelemetry can be used across several languages, and Go is one
    of the supported languages.'
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of following the OpenTelemetry specification is that it is
    vendor-agnostic, which means that applications written using their APIs are portable
    across different observability vendors. For example, applications that are written
    to write metrics into a filesystem will require a few lines of code changes to
    allow it to store metrics in Prometheus, which we will discuss in the *Adding
    metrics using* *Prometheus* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two main components of OpenTelemetry are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracing**: This provides applications with the capability to track service
    requests as they flow through systems by collecting data. For example, with the
    tracing capability, we can see how an HTTP request flows through the different
    systems in the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics**: This provides applications with the ability to collect and store
    measurements for detecting performance anomalies and forecasting. For example,
    collecting metrics in our application will give us visibility into how long a
    database query takes or how long it takes to process a certain batch job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the OpenTelemetry specification at the following link: [https://opentelemetry.io/docs/reference/specification/](https://opentelemetry.io/docs/reference/specification/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification allows users to plug-and-play different OpenTelemetry implementations
    easily without any dependency on single-vendor libraries. This means that all
    the relevant contracts that are outlined in the specification document can be
    implemented. Some concepts are important to understand in order to use OpenTelemetry
    effectively. The following are the concepts that are relevant to the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Components**: These are basically the core vendor-agnostic specifications,
    outlining the different parts of the system that need to be implemented. The components
    are collectors, the APIs, the SDK, and instrumenting libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data sources**: This is the data that the specification supports: traces,
    logs, metrics, and baggage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumenting and libraries**: There are two ways to integrate the provided
    library – either automatically by using the library provided by the vendor or
    open source contribution, or manually as per the application requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we are going to look at the implementation side of the
    specification, which involves both the APIs and the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenTelemetry APIs and SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenTelemetry is made of several components, and two of the main components
    that we are going to talk about are the APIs and SDK. The specification defines
    cross-language requirements that any implementation must adhere to as part of
    the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **APIs**: This defines the data types and operations that will be used
    to generate telemetry data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **SDK**: This defines the implementation of the APIs for processing and
    exporting capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between the APIs and SDK – it’s clear that the
    APIs are contracts that are provided by the specification, while the SDK provides
    the different functionalities required to allow metrics data to be processed and
    exported. Metrics data contains information such as memory used, CPU usage, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification provides an API for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**: This contains the values that are carried around across API calls.
    This is data that can be passed between system calls and carry application information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Baggage**: A set of name-value pairs describing user-defined properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracing**: An API definition that provides the tracing functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics**: An API definition that provides the metric recording functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at how the OpenTelemetry tracing API looks and how to add the tracing
    capability to applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about logging and how logging can give us
    visibility into what’s going on inside our application. The line between logging
    and tracing is blurry; what we need to understand is that logging just provides
    information on what a process is currently doing, while tracing gives us cross-cutting
    visibility across different components, allowing us to get a better understanding
    of the data flow and time taken for a process to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with tracing, we can answer questions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How long does the add-to-cart process take?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long does it take to download a payment file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go through the different APIs that are outlined in the specification
    and implement those APIs using the implementation provided by the OpenTelemetry
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the links between different entities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.2_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Tracing an API relationship
  prefs: []
  type: TYPE_NORMAL
- en: '**TracerProvider** is the entry point to use the tracing API and it provides
    access to **Tracer**, which is responsible for creating **Span**. **Span** is
    used to trace an operation in our application. Before we move further to the next
    layer, which is the SDK, we will take a look briefly at **Jaeger**, which is one
    of the support tools provided by the OpenTelemetry library for tracing.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jaeger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)) is
    a popular open source distributed tracing platform; it provides its own client
    libraries for a wide variety of programming languages, which can be seen at [https://github.com/orgs/jaegertracing/repositories](https://github.com/orgs/jaegertracing/repositories).
    We will be running Jaeger as a Docker container to reduce the amount of setup
    that is required when installing the application manually. Let’s start up Jaeger
    using the following `docker` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On successful launch, there will be a lot of logs printed that look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Jaeger is now ready, the tool is not a desktop application but it provides
    a user interface that is accessible using the browser. Open your browser and type
    in the following URL: http://localhost:16686\. It will open the Jaeger main page
    (*Figure 3**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.3_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Jaeger main page
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, Jaeger does not contain anything, as there are no applications
    that are using it.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Jaeger SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Jaeger is ready, let’s look at how we are going to write tracing information
    using OpenTelemetry. The library provides support for the Jaeger SDK out of the
    box; this allows applications to use the API to write tracing to Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example that we will be using in this section is inside the `jaeger/opentelem/trace`
    directory in the chapter’s GitHub repository. The file that we want to look at
    is `tracing.go` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at what each part of the code is doing. Line 18 is initializing
    the Jaeger SDK inside the OpenTelemetry library. On successfully initializing
    the Jaeger SDK, the code continues to provide the newly created Jaeger and uses
    it with the OpenTelemetry library to create a new `TracerProvider` API. As discussed
    in the previous section, `TracerProvider` is the API that is used as the main
    entry for OpenTelemetry. This is performed on lines 24-30.
  prefs: []
  type: TYPE_NORMAL
- en: On obtaining `TracerProvider`, we will need to call the global `SetTracerProvider`
    to let OpenTelemetry know about it, which is done on line 32\. Once the Jaeger
    SDK has been successfully initialized, now it’s a matter of using it in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the code sample for using the tracing functionality. The
    sample application that we are going to look at can be found inside the `jaeger/opentelem`
    directory inside `main.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Jaeger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to go through section by section to explain what the code is doing.
    The following code section shows the `InitTracing` function that takes care the
    initialization process being called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the SDK completes the initialization process, the code can start using
    the API to write tracing information and this is done by getting a `Span` using
    the `Tracer` API as shown on lines 27-29\. The code uses `sync.WaitGroup` (lines
    35 and 45) to ensure that the `main` thread does not finish before the goroutine
    completes – the goroutine is added to simulate some kind of processing to be done
    to generate a trace that will be reported to Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Tracer` API only has one `Start` function, which is called to initiate
    the tracing operation, and the tracing operation is considered complete when the
    `End` function is called on `Span` – so, what is `Span`? `Span` is an API for
    tracing an operation; it has the following interface declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Multiple spans are pieced together to create a trace; it can be thought of as
    a **Directed Acyclic Graph** (**DAG**) of spans.
  prefs: []
  type: TYPE_NORMAL
- en: DAGs
  prefs: []
  type: TYPE_NORMAL
- en: A DAG is a term used in mathematics and computer science. It is a graph that
    shows dependencies, which, in our case, are the dependencies of application traces.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.4* shows what the composition of the trace looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.4_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – A DAG of a simple trace
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code creates two goroutines to perform a `sleep` operation and write
    trace information as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the complete sample application in `main.go` inside the `jaeger/opentelem`
    directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon completion, the application will write tracing information into Jaeger.
    Open Jaeger by accessing http://localhost:16686 in your browser. Once it’s opened,
    you will see a new entry under the **Service** dropdown as shown in *Figure 3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.5_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Application trace search
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample application tracing information is registered with the same string
    defined in the code, which is called `tracing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on the **Find Traces** button will read the trace information that
    is stored (*Figure 3**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.6_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Application traces
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in *Figure 3**.6*, there is only one entry and if you click on
    it, it will expand more information that the app has submitted via the `Span`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.7_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Tracing information
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.7* shows the complete tracing information, which is a composition
    of spans from the application. Clicking on each of the graphs will bring up more
    information included in the span, which is included as shown in the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to add tracing to our application, in the next section,
    we will look at adding metric instrumentation that will give us visibility into
    some of the performance metrics relevant to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding metrics using Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As OpenTelemetry is vendor-agnostic, it provides a wide variety of support for
    monitoring, exporting, and collecting metrics and one option is Prometheus. A
    complete list of different projects supported by OpenTelemetry can be found at
    [https://opentelemetry.io/registry/](https://opentelemetry.io/registry/). Prometheus
    is an open source monitoring and alerting system server that is widely used in
    cloud environments; it also provides libraries for a variety of programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to add tracing capabilities to our application
    and how to retrieve the traces by using Jaeger. In this section, we are going
    to take a look at how to create metrics using the `OpenTelemetry` library. Metrics
    allow us to get instrumentation information for our applications; it can provide
    answers to questions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the total number of requests processed in service A?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many total transactions are processed via payment gateway B?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, collected metrics are stored for a certain amount of time to give
    us better insights into how the applications are performing by looking at a specific
    metric.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Prometheus open source project ([https://prometheus.io/](https://prometheus.io/)),
    which provides a complete monitoring solution stack and is very easy to use. The
    project provides a lot of features that are useful for collecting and storing
    metrics and monitoring our applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.8_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The Prometheus monitoring stack
  prefs: []
  type: TYPE_NORMAL
- en: Similar to tracing, the OpenTelemetry specification specifies the API and SDK
    for metrics, as shown in *Figure 3**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.9_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Metrics API
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are explanations of the metrics APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MeterProvider**: This is an API for providing access to meters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meter**: This is responsible for creating instruments, and is unique to the
    instrumentation in question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrument**: This contains the metric that we want to report; it can be
    synchronous or asynchronous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding metrics using Prometheus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start up Prometheus; make sure from your terminal that you are inside
    the `chapter3/prom/opentelem` directory and execute the following `docker` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'NOTE:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a Linux machine, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The extra parameter, `--add-host=host.docker.internal:host-gateway`, will allow
    Prometheus to access the host machine using the `host.docker.internal` machine
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `config.yml` file used for configuring Prometheus is inside the `prom/opentelem`
    directory and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will not go through the different available Prometheus configuration options
    in this section. The configuration we are using informs Prometheus that we want
    to get metrics from the container host, which is known internally in the container
    as `host.docker.internal`, at port `2112`, at an interval of 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Prometheus successfully runs, you will see the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open your browser and type in the following: http://localhost:9090\.
    You will be shown the main Prometheus UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.10_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The Prometheus UI
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.11* shows the way Prometheus collects metrics via a pulling mechanism
    where it *pulls* metric information from your application by connecting to port
    `2112`, which is exposed by the HTTP server running in the application. We will
    see later that most of the heavy lifting is done by the `OpenTelemetry` library;
    our application will just have to provide the metric that we want to report on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.11_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Prometheus metric collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Prometheus is ready, we can start recording metrics to for our application.
    Run the application inside the `prom/opentelem` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let the application run for a bit and you will see the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`metric.totalrequest`: This metric reports the total number of requests processed
    by the application; the sample application has an HTTP server running on port
    `8000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metric.random`: This metric reports a random number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the successful run of the sample application, we can now see the metric
    in the Prometheus UI. Open your browser and head to http://localhost:9090 and
    type in `metric_random` and you will see something such as that shown in *Figure
    3**.12*; click on the **Execute** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.12_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – metric_random metric
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Graph** tab and you will see the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.13_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – metric_random graph
  prefs: []
  type: TYPE_NORMAL
- en: The other metric that we want to show is the total number of requests processed
    by the sample application’s HTTP server. In order to generate some metrics, open
    the browser and enter http://localhost:8000; do so a few times so that some metrics
    will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Prometheus UI again (http://localhost:9090), add the `metric_totalrequest`
    metric as shown in *Figure 3**.14*, and click on **Execute**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.14_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – metric_totalrequest metric
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.15_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – metric_totalrequest graph
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are having problems and cannot see the metrics, change the Prometheus
    configuration file, `config.yml`, inside the `chapter3/prom/opentelem` directory
    and change the target from `host.docker.internal` to `localhost` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `metrics.go` source contains the code that initializes the `otel` SDK to
    configure it for Prometheus, which is shown in the code snippet here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows how it sends the metrics to Prometheus – the
    code can be found in `main.go` inside the `chapter3/prom/opentelem` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have successfully added metrics and tracing to our applications
    and can view them using both Jaeger and Prometheus; in the next section, we will
    look at putting all the tools together to make it easy to run them as a single
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: Running docker-compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We normally run containers using the `docker` command, but what if we want to
    run more than one container in one go? This is where `docker-compose` comes to
    the rescue. The tool allows you to configure the different containers that you
    want to run as a single unit. It also allows different kinds of configurations
    for different containers – for example, container A can communicate via the network
    with container B but not with container C.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker-compose` tool that we are using in this book is v2, which is the
    recommended version. You can find instructions for installing the tool for different
    operating systems here – [https://docs.docker.com/compose/install/other/](https://docs.docker.com/compose/install/other/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easy to run both Prometheus and Jaeger, you can use `docker-compose`.
    The `docker-compose.yml` file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `docker-compose` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On a successful run, you will see the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `up` parameter we are using will start the container in the terminal and
    run in attached mode, which allows you to show all the logs on the screen. You
    also can run in detached mode to run the container in the background as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we looked at how to add metrics and tracing into an application
    using the `OpenTelemetry` library. Having this observability in an application
    will enable us to troubleshoot issues faster and also keep track of the performance
    of our application from the provided metrics. We also took a look at using two
    different open source projects that allow us to look at the data collected from
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at the plumbing and infrastructure required to monitor
    and trace our application. In the next chapter, we will look at different aspects
    of building both dynamic and static content for our web application and how to
    package the application to make it easier to deploy anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Serving Web Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Upon completing this part of the book, you will be able to create server-rendered
    pages using an HTML/template and Gorilla Mux. You will also learn how to create
    and expose an API that will be used by the frontend. Securing the API will be
    discussed, including middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18295_04.xhtml#_idTextAnchor053)*, Serving and Embedding HTML
    Content*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18295_05.xhtml#_idTextAnchor070)*, Securing the Backend and
    Middleware*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18295_06.xhtml#_idTextAnchor093)*, Moving to API-First*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
