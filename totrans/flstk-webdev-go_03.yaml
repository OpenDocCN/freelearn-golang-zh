- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Application Metrics and Tracing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序指标和跟踪
- en: In [*Chapter 2*](B18295_02.xhtml#_idTextAnchor029), *Application Logging*, we
    looked at logging, and how we use logging inside our backend Go code. In this
    chapter, we will proceed to look at monitoring and tracing. To monitor and trace
    the application, we will look into different open source tools and libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B18295_02.xhtml#_idTextAnchor029) *应用程序日志*中，我们探讨了日志记录以及如何在我们的后端 Go
    代码中使用日志记录。在本章中，我们将继续探讨监控和跟踪。为了监控和跟踪应用程序，我们将研究不同的开源工具和库。
- en: We have started building our application, and now we need to start looking into
    how we are going to support it. Once an application is running in production,
    we need to see what’s happening in the application. Having this kind of visibility
    will allow us to understand problems that come up. In software systems, we will
    often come across the concept of *observability*. The concept refers to the ability
    of software systems to capture and store data used for analysis and troubleshooting
    purposes. This includes the processes and tools used in order to achieve the goal
    of allowing users to observe what’s happening in the system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始构建我们的应用程序，现在我们需要开始考虑如何支持它。一旦应用程序在生产环境中运行，我们需要了解应用程序中发生了什么。拥有这种可见性将使我们能够理解出现的问题。在软件系统中，我们经常会遇到*可观察性*的概念。这个概念指的是软件系统捕获和存储用于分析和故障排除目的的数据的能力。这包括用于实现允许用户观察系统中发生情况的目标的过程和工具。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Understanding the OpenTelemetry specification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 OpenTelemetry 规范
- en: Tracing applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪应用程序
- en: Adding metrics to our application using Prometheus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Prometheus 为我们的应用程序添加指标
- en: Running `docker-compose`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `docker-compose`
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the source code explained in this chapter is available from GitHub here:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以从 GitHub 这里获取：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter03)。
- en: 'We will be using another tool called OpenTelemetry, which will be explained
    in the next section, and the version that we use in this book is v1.2.0, available
    here: [https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0](https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用另一个名为 OpenTelemetry 的工具，它将在下一节中解释，我们在这本书中使用的是 v1.2.0 版本，可在以下链接找到：[https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0](https://github.com/open-telemetry/opentelemetry-go/tree/v1.2.0)。
- en: Understanding OpenTelemetry
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OpenTelemetry
- en: OpenTelemetry is an open source project that enables developers to provide observability
    capability to their applications. The project provides a Software Development
    Kit (SDK) for different programming languages, with Go as one of the supported
    languages, which is integrated with the application. The SDK is for metric collection
    and reporting, as it provides integration with different open source frameworks,
    making the integration process seamless. OpenTelemetry also provides a common
    standard, providing the application flexibility to report the collected data to
    different observability backend systems. OpenTelemetry’s website is at [https://opentelemetry.io/](https://opentelemetry.io/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 是一个开源项目，它使开发者能够为他们的应用程序提供可观察性能力。该项目为不同的编程语言提供了软件开发工具包（SDK），其中
    Go 是支持的语言之一，它与应用程序集成。SDK 用于指标收集和报告，因为它与不同的开源框架集成了，使得集成过程无缝。OpenTelemetry 还提供了一个通用标准，为应用程序提供了灵活性，可以将收集到的数据报告到不同的可观察性后端系统。OpenTelemetry
    的网站是 [https://opentelemetry.io/](https://opentelemetry.io/)。
- en: '![](img/Figure_3.1_B18295.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_3.1_B18295.jpg)'
- en: Figure 3.1 – OpenTelemetry logo
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – OpenTelemetry 标志
- en: '**OpenTelemetry** is actually the merging of the OpenTracing and OpenCensus
    projects. The project is used to instrument, collect, and export metrics, logs,
    and traces. OpenTelemetry can be used across several languages, and Go is one
    of the supported languages.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenTelemetry** 实际上是 OpenTracing 和 OpenCensus 项目的合并。该项目用于对应用程序进行仪器化、收集和导出指标、日志和跟踪。OpenTelemetry
    可以跨多种语言使用，Go 是支持的语言之一。'
- en: The main benefit of following the OpenTelemetry specification is that it is
    vendor-agnostic, which means that applications written using their APIs are portable
    across different observability vendors. For example, applications that are written
    to write metrics into a filesystem will require a few lines of code changes to
    allow it to store metrics in Prometheus, which we will discuss in the *Adding
    metrics using* *Prometheus* section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循OpenTelemetry规范的主要好处是它是供应商无关的，这意味着使用它们的API编写的应用程序可以在不同的可观察性供应商之间移植。例如，编写写入文件系统的应用程序将需要几行代码更改，以便将其指标存储在Prometheus中，我们将在“使用Prometheus添加指标”部分讨论。
- en: 'The two main components of OpenTelemetry are the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry的两个主要组件如下：
- en: '**Tracing**: This provides applications with the capability to track service
    requests as they flow through systems by collecting data. For example, with the
    tracing capability, we can see how an HTTP request flows through the different
    systems in the network.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**: 这为应用程序提供了通过收集数据跟踪服务请求在系统中流动的能力。例如，使用跟踪功能，我们可以看到HTTP请求如何通过网络中的不同系统流动。'
- en: '**Metrics**: This provides applications with the ability to collect and store
    measurements for detecting performance anomalies and forecasting. For example,
    collecting metrics in our application will give us visibility into how long a
    database query takes or how long it takes to process a certain batch job.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**: 这为应用程序提供了收集和存储测量数据的能力，用于检测性能异常和预测。例如，在我们的应用程序中收集指标将使我们能够了解数据库查询需要多长时间，或者处理某个特定批处理作业需要多长时间。'
- en: 'You can find the OpenTelemetry specification at the following link: [https://opentelemetry.io/docs/reference/specification/](https://opentelemetry.io/docs/reference/specification/).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到OpenTelemetry规范：[https://opentelemetry.io/docs/reference/specification/](https://opentelemetry.io/docs/reference/specification/)。
- en: 'The specification allows users to plug-and-play different OpenTelemetry implementations
    easily without any dependency on single-vendor libraries. This means that all
    the relevant contracts that are outlined in the specification document can be
    implemented. Some concepts are important to understand in order to use OpenTelemetry
    effectively. The following are the concepts that are relevant to the specification:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 规范允许用户轻松地插入和播放不同的OpenTelemetry实现，而无需依赖单一供应商的库。这意味着规范文档中概述的所有相关合同都可以实现。为了有效地使用OpenTelemetry，以下是一些重要的概念：
- en: '**Components**: These are basically the core vendor-agnostic specifications,
    outlining the different parts of the system that need to be implemented. The components
    are collectors, the APIs, the SDK, and instrumenting libraries.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**: 这些基本上是核心供应商无关的规范，概述了需要实现的不同系统部分。组件包括收集器、API、SDK和仪器库。'
- en: '**Data sources**: This is the data that the specification supports: traces,
    logs, metrics, and baggage.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据源**: 这是规范支持的数据：跟踪、日志、指标和行李。'
- en: '**Instrumenting and libraries**: There are two ways to integrate the provided
    library – either automatically by using the library provided by the vendor or
    open source contribution, or manually as per the application requirements.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器化和库**: 有两种方法可以集成提供的库——要么通过使用供应商提供的库或开源贡献自动进行，要么根据应用程序要求手动进行。'
- en: In the next section, we are going to look at the implementation side of the
    specification, which involves both the APIs and the SDK.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨规范的实施方面，这涉及到API和SDK两个方面。
- en: The OpenTelemetry APIs and SDK
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenTelemetry的API和SDK
- en: 'OpenTelemetry is made of several components, and two of the main components
    that we are going to talk about are the APIs and SDK. The specification defines
    cross-language requirements that any implementation must adhere to as part of
    the requirements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry由几个组件组成，我们将讨论的两个主要组件是API和SDK。规范定义了任何实现都必须遵守的跨语言要求，作为要求的一部分：
- en: 'The **APIs**: This defines the data types and operations that will be used
    to generate telemetry data'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APIs**: 这定义了将用于生成遥测数据的数据类型和操作'
- en: 'The **SDK**: This defines the implementation of the APIs for processing and
    exporting capabilities'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDK**: 这定义了API的处理和导出功能的实现'
- en: There is a clear distinction between the APIs and SDK – it’s clear that the
    APIs are contracts that are provided by the specification, while the SDK provides
    the different functionalities required to allow metrics data to be processed and
    exported. Metrics data contains information such as memory used, CPU usage, etc.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: API 和 SDK 之间存在明显的区别——很明显，API 是由规范提供的合约，而 SDK 提供了允许处理和导出指标数据的所需的不同功能。指标数据包含诸如内存使用、CPU
    使用率等信息。
- en: 'The specification provides an API for the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 规范为以下内容提供了 API：
- en: '**Context**: This contains the values that are carried around across API calls.
    This is data that can be passed between system calls and carry application information.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：这包含在 API 调用之间携带的值。这是可以在系统调用之间传递并携带应用程序信息的数据。'
- en: '**Baggage**: A set of name-value pairs describing user-defined properties.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Baggage**：一组描述用户定义属性的键值对。'
- en: '**Tracing**: An API definition that provides the tracing functionality'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：一个提供跟踪功能的 API 定义'
- en: '**Metrics**: An API definition that provides the metric recording functionality'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**：一个提供指标记录功能的 API 定义'
- en: We will look at how the OpenTelemetry tracing API looks and how to add the tracing
    capability to applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨 OpenTelemetry 跟踪 API 的外观以及如何将跟踪功能添加到应用程序中。
- en: Tracing applications
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪应用程序
- en: In the previous chapter, we learned about logging and how logging can give us
    visibility into what’s going on inside our application. The line between logging
    and tracing is blurry; what we need to understand is that logging just provides
    information on what a process is currently doing, while tracing gives us cross-cutting
    visibility across different components, allowing us to get a better understanding
    of the data flow and time taken for a process to complete.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了日志记录以及日志如何让我们了解应用程序内部正在发生的事情。日志和跟踪之间的界限模糊；我们需要理解的是，日志只是提供了关于进程当前正在做什么的信息，而跟踪则提供了跨不同组件的横切可见性，使我们能够更好地理解数据流和进程完成所需的时间。
- en: 'For example, with tracing, we can answer questions such as the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用跟踪，我们可以回答以下问题：
- en: How long does the add-to-cart process take?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加到购物车的过程需要多长时间？
- en: How long does it take to download a payment file?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载支付文件需要多长时间？
- en: We will go through the different APIs that are outlined in the specification
    and implement those APIs using the implementation provided by the OpenTelemetry
    library.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨规范中概述的不同 API，并使用 OpenTelemetry 库提供的实现来实现这些 API。
- en: The following figure shows the links between different entities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了不同实体之间的链接。
- en: '![](img/Figure_3.2_B18295.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.2_B18295.jpg)'
- en: Figure 3.2 – Tracing an API relationship
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 跟踪 API 关系
- en: '**TracerProvider** is the entry point to use the tracing API and it provides
    access to **Tracer**, which is responsible for creating **Span**. **Span** is
    used to trace an operation in our application. Before we move further to the next
    layer, which is the SDK, we will take a look briefly at **Jaeger**, which is one
    of the support tools provided by the OpenTelemetry library for tracing.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**TracerProvider** 是使用跟踪 API 的入口点，它提供了对 **Tracer** 的访问，**Tracer** 负责创建 **Span**。**Span**
    用于跟踪我们应用程序中的操作。在我们进一步探讨下一层，即 SDK 之前，我们将简要了解一下 **Jaeger**，这是 OpenTelemetry 库提供的用于跟踪的支持工具之一。'
- en: Installing Jaeger
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Jaeger
- en: 'Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)) is
    a popular open source distributed tracing platform; it provides its own client
    libraries for a wide variety of programming languages, which can be seen at [https://github.com/orgs/jaegertracing/repositories](https://github.com/orgs/jaegertracing/repositories).
    We will be running Jaeger as a Docker container to reduce the amount of setup
    that is required when installing the application manually. Let’s start up Jaeger
    using the following `docker` command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)) 是一个流行的开源分布式跟踪平台；它为各种编程语言提供了自己的客户端库，可以在
    [https://github.com/orgs/jaegertracing/repositories](https://github.com/orgs/jaegertracing/repositories)
    上看到。我们将以 Docker 容器的形式运行 Jaeger，以减少手动安装应用程序时所需的设置量。让我们使用以下 `docker` 命令启动 Jaeger：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On successful launch, there will be a lot of logs printed that look like the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功启动后，将打印出大量的日志，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Jaeger is now ready, the tool is not a desktop application but it provides
    a user interface that is accessible using the browser. Open your browser and type
    in the following URL: http://localhost:16686\. It will open the Jaeger main page
    (*Figure 3**.3*):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger现在已准备好，这个工具不是一个桌面应用程序，但它提供了一个可以通过浏览器访问的用户界面。打开您的浏览器，输入以下URL：http://localhost:16686。它将打开Jaeger主页面（*图3.3**.3*）：
- en: '![](img/Figure_3.3_B18295.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.3_B18295.jpg)'
- en: Figure 3.3 – Jaeger main page
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – Jaeger主页面
- en: At the moment, Jaeger does not contain anything, as there are no applications
    that are using it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Jaeger没有任何内容，因为没有应用程序在使用它。
- en: Integrating the Jaeger SDK
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Jaeger SDK
- en: Now that Jaeger is ready, let’s look at how we are going to write tracing information
    using OpenTelemetry. The library provides support for the Jaeger SDK out of the
    box; this allows applications to use the API to write tracing to Jaeger.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Jaeger已经准备好了，让我们看看我们如何使用OpenTelemetry来编写跟踪信息。该库为Jaeger SDK提供了开箱即用的支持；这使得应用程序可以使用API将跟踪信息写入Jaeger。
- en: 'The example that we will be using in this section is inside the `jaeger/opentelem/trace`
    directory in the chapter’s GitHub repository. The file that we want to look at
    is `tracing.go` as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中将使用的示例位于章节GitHub仓库的`jaeger/opentelem/trace`目录中。我们想要查看的文件是`tracing.go`，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s take a look at what each part of the code is doing. Line 18 is initializing
    the Jaeger SDK inside the OpenTelemetry library. On successfully initializing
    the Jaeger SDK, the code continues to provide the newly created Jaeger and uses
    it with the OpenTelemetry library to create a new `TracerProvider` API. As discussed
    in the previous section, `TracerProvider` is the API that is used as the main
    entry for OpenTelemetry. This is performed on lines 24-30.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码的每一部分在做什么。第18行在OpenTelemetry库内部初始化Jaeger SDK。在成功初始化Jaeger SDK后，代码继续提供新创建的Jaeger，并使用它与OpenTelemetry库一起创建一个新的`TracerProvider`
    API。如前所述，`TracerProvider`是作为OpenTelemetry主要入口的API。这是在第24-30行执行的。
- en: On obtaining `TracerProvider`, we will need to call the global `SetTracerProvider`
    to let OpenTelemetry know about it, which is done on line 32\. Once the Jaeger
    SDK has been successfully initialized, now it’s a matter of using it in the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取`TracerProvider`后，我们需要调用全局的`SetTracerProvider`来让OpenTelemetry了解它，这是在第32行完成的。一旦Jaeger
    SDK成功初始化，现在就是将其用于应用程序中的时候了。
- en: Let’s take a look at the code sample for using the tracing functionality. The
    sample application that we are going to look at can be found inside the `jaeger/opentelem`
    directory inside `main.go`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用跟踪功能的代码示例。我们将要查看的示例应用程序位于`jaeger/opentelem`目录内的`main.go`中。
- en: Integration with Jaeger
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Jaeger的集成
- en: 'We are going to go through section by section to explain what the code is doing.
    The following code section shows the `InitTracing` function that takes care the
    initialization process being called:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐节解释代码的功能。以下代码部分显示了负责初始化过程的`InitTracing`函数被调用的情况：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the SDK completes the initialization process, the code can start using
    the API to write tracing information and this is done by getting a `Span` using
    the `Tracer` API as shown on lines 27-29\. The code uses `sync.WaitGroup` (lines
    35 and 45) to ensure that the `main` thread does not finish before the goroutine
    completes – the goroutine is added to simulate some kind of processing to be done
    to generate a trace that will be reported to Jaeger.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SDK完成初始化过程，代码就可以开始使用API来编写跟踪信息，这是通过使用`Tracer` API获取`Span`来完成的，如第27-29行所示。代码使用`sync.WaitGroup`（第35和45行）确保在goroutine完成之前`main`线程不会结束——goroutine被添加来模拟一些需要完成的处理，以生成将被报告给Jaeger的跟踪。
- en: 'The `Tracer` API only has one `Start` function, which is called to initiate
    the tracing operation, and the tracing operation is considered complete when the
    `End` function is called on `Span` – so, what is `Span`? `Span` is an API for
    tracing an operation; it has the following interface declaration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tracer` API只有一个`Start`函数，用于启动跟踪操作，当在`Span`上调用`End`函数时，跟踪操作被认为是完成的——那么，什么是`Span`？`Span`是一个用于跟踪操作的API；它具有以下接口声明：'
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Multiple spans are pieced together to create a trace; it can be thought of as
    a **Directed Acyclic Graph** (**DAG**) of spans.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 多个`Span`被拼接在一起以创建一个跟踪；它可以被认为是一个**有向无环图**（**DAG**）的`Span`。
- en: DAGs
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: DAGs
- en: A DAG is a term used in mathematics and computer science. It is a graph that
    shows dependencies, which, in our case, are the dependencies of application traces.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: DAG 是数学和计算机科学中的一个术语。它是一个显示依赖关系的图，在我们的案例中，是应用追踪的依赖关系。
- en: '*Figure 3**.4* shows what the composition of the trace looks like:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.4* 展示了追踪成分的组成：'
- en: '![](img/Figure_3.4_B18295.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.4_B18295.jpg)'
- en: Figure 3.4 – A DAG of a simple trace
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 简单追踪的 DAG
- en: 'The sample code creates two goroutines to perform a `sleep` operation and write
    trace information as shown below:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码创建了两个 goroutines 来执行 `sleep` 操作并写入追踪信息，如下所示：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the complete sample application in `main.go` inside the `jaeger/opentelem`
    directory using the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在 `jaeger/opentelem` 目录中的 `main.go` 内运行完整的示例应用：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Upon completion, the application will write tracing information into Jaeger.
    Open Jaeger by accessing http://localhost:16686 in your browser. Once it’s opened,
    you will see a new entry under the **Service** dropdown as shown in *Figure 3**.5*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，应用将追踪信息写入 Jaeger。通过在浏览器中访问 http://localhost:16686 打开 Jaeger。打开后，您将在 **服务**
    下拉菜单中看到一个新条目，如 *图 3**.5* 所示：
- en: '![](img/Figure_3.5_B18295.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.5_B18295.jpg)'
- en: Figure 3.5 – Application trace search
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 应用追踪搜索
- en: 'The sample application tracing information is registered with the same string
    defined in the code, which is called `tracing`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用的追踪信息使用代码中定义的相同字符串注册，称为 `tracing`：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clicking on the **Find Traces** button will read the trace information that
    is stored (*Figure 3**.6*):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **查找追踪** 按钮将读取存储的追踪信息（*图 3**.6*）：
- en: '![](img/Figure_3.6_B18295.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.6_B18295.jpg)'
- en: Figure 3.6 – Application traces
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 应用追踪
- en: As can be seen in *Figure 3**.6*, there is only one entry and if you click on
    it, it will expand more information that the app has submitted via the `Span`
    API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 3**.6* 所示，只有一个条目，如果您点击它，它将展开应用通过 `Span` API 提交的更多信息。
- en: '![](img/Figure_3.7_B18295.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.7_B18295.jpg)'
- en: Figure 3.7 – Tracing information
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 追踪信息
- en: '*Figure 3**.7* shows the complete tracing information, which is a composition
    of spans from the application. Clicking on each of the graphs will bring up more
    information included in the span, which is included as shown in the code here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.7* 展示了完整的追踪信息，这是从应用中获取的跨度组合。点击每个图表将显示包含在跨度中的更多信息，如代码所示：'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we know how to add tracing to our application, in the next section,
    we will look at adding metric instrumentation that will give us visibility into
    some of the performance metrics relevant to our application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何向我们的应用添加追踪，在下一节中，我们将探讨添加指标仪表化，这将使我们能够了解与应用相关的某些性能指标。
- en: Adding metrics using Prometheus
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Prometheus 添加指标
- en: As OpenTelemetry is vendor-agnostic, it provides a wide variety of support for
    monitoring, exporting, and collecting metrics and one option is Prometheus. A
    complete list of different projects supported by OpenTelemetry can be found at
    [https://opentelemetry.io/registry/](https://opentelemetry.io/registry/). Prometheus
    is an open source monitoring and alerting system server that is widely used in
    cloud environments; it also provides libraries for a variety of programming languages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenTelemetry 是供应商无关的，它为监控、导出和收集指标提供了广泛的支持，其中一种选择是 Prometheus。OpenTelemetry
    支持的不同项目的完整列表可以在 [https://opentelemetry.io/registry/](https://opentelemetry.io/registry/)
    找到。Prometheus 是一个开源的监控和警报系统服务器，在云环境中被广泛使用；它还提供了各种编程语言的库。
- en: 'In the previous section, we saw how to add tracing capabilities to our application
    and how to retrieve the traces by using Jaeger. In this section, we are going
    to take a look at how to create metrics using the `OpenTelemetry` library. Metrics
    allow us to get instrumentation information for our applications; it can provide
    answers to questions such as the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何向我们的应用添加追踪功能以及如何使用 Jaeger 检索追踪。在本节中，我们将探讨如何使用 `OpenTelemetry` 库创建指标。指标使我们能够获取应用的仪表化信息；它可以回答以下问题：
- en: What is the total number of requests processed in service A?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务 A 中处理了多少个总请求？
- en: How many total transactions are processed via payment gateway B?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过支付网关 B 处理了多少笔总交易？
- en: Normally, collected metrics are stored for a certain amount of time to give
    us better insights into how the applications are performing by looking at a specific
    metric.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，收集的指标会存储一段时间，以便我们通过查看特定指标来更好地了解应用的性能。
- en: We will use the Prometheus open source project ([https://prometheus.io/](https://prometheus.io/)),
    which provides a complete monitoring solution stack and is very easy to use. The
    project provides a lot of features that are useful for collecting and storing
    metrics and monitoring our applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Prometheus 开源项目 ([https://prometheus.io/](https://prometheus.io/))，它提供了一个完整的监控解决方案堆栈，并且非常易于使用。该项目提供了许多用于收集和存储指标以及监控我们的应用程序的有用功能。
- en: '![](img/Figure_3.8_B18295.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.8_B18295.jpg)'
- en: Figure 3.8 – The Prometheus monitoring stack
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – Prometheus 监控堆栈
- en: Similar to tracing, the OpenTelemetry specification specifies the API and SDK
    for metrics, as shown in *Figure 3**.9*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与跟踪类似，OpenTelemetry 规范指定了指标和 SDK 的 API，如图 *图 3.9* 所示。
- en: '![](img/Figure_3.9_B18295.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.9_B18295.jpg)'
- en: Figure 3.9 – Metrics API
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 指标 API
- en: 'The following are explanations of the metrics APIs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对指标 API 的解释：
- en: '**MeterProvider**: This is an API for providing access to meters.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计量器提供者**：这是一个提供对计量器访问的 API。'
- en: '**Meter**: This is responsible for creating instruments, and is unique to the
    instrumentation in question.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计量器**：这是负责创建仪表的，并且对于所涉及的仪表是唯一的。'
- en: '**Instrument**: This contains the metric that we want to report; it can be
    synchronous or asynchronous.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：它包含我们想要报告的指标；它可以是同步的或异步的。'
- en: Adding metrics using Prometheus
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Prometheus 添加指标
- en: 'Let’s start up Prometheus; make sure from your terminal that you are inside
    the `chapter3/prom/opentelem` directory and execute the following `docker` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 Prometheus；请确保您在终端中位于 `chapter3/prom/opentelem` 目录内，并执行以下 `docker` 命令：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'NOTE:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: 'If you are using a Linux machine, use the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Linux 机器，请使用以下命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The extra parameter, `--add-host=host.docker.internal:host-gateway`, will allow
    Prometheus to access the host machine using the `host.docker.internal` machine
    name.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的参数 `--add-host=host.docker.internal:host-gateway` 将允许 Prometheus 使用 `host.docker.internal`
    主机名访问主机机器。
- en: 'The `config.yml` file used for configuring Prometheus is inside the `prom/opentelem`
    directory and looks like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用于配置 Prometheus 的 `config.yml` 文件位于 `prom/opentelem` 目录中，其外观如下：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will not go through the different available Prometheus configuration options
    in this section. The configuration we are using informs Prometheus that we want
    to get metrics from the container host, which is known internally in the container
    as `host.docker.internal`, at port `2112`, at an interval of 5 seconds.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中不会详细介绍不同可用的 Prometheus 配置选项。我们使用的配置通知 Prometheus，我们想要从容器主机获取指标，在容器内部称为
    `host.docker.internal`，在端口 `2112`，以 5 秒的间隔。
- en: 'Once Prometheus successfully runs, you will see the following log:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Prometheus 成功运行，您将看到以下日志：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, open your browser and type in the following: http://localhost:9090\.
    You will be shown the main Prometheus UI:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开您的浏览器并输入以下内容：http://localhost:9090。您将看到 Prometheus 的主 UI：
- en: '![](img/Figure_3.10_B18295.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.10_B18295.jpg)'
- en: Figure 3.10 – The Prometheus UI
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – Prometheus UI
- en: '*Figure 3**.11* shows the way Prometheus collects metrics via a pulling mechanism
    where it *pulls* metric information from your application by connecting to port
    `2112`, which is exposed by the HTTP server running in the application. We will
    see later that most of the heavy lifting is done by the `OpenTelemetry` library;
    our application will just have to provide the metric that we want to report on.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.11* 展示了 Prometheus 通过拉取机制收集指标的方式，它通过连接到应用程序中运行的 HTTP 服务器暴露的端口 `2112`，从您的应用程序中
    *拉取* 指标信息。我们稍后将看到，大部分繁重的工作都是由 `OpenTelemetry` 库完成的；我们的应用程序只需提供我们想要报告的指标。'
- en: '![](img/Figure_3.11_B18295.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.11_B18295.jpg)'
- en: Figure 3.11 – Prometheus metric collection
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – Prometheus 指标收集
- en: 'Now that Prometheus is ready, we can start recording metrics to for our application.
    Run the application inside the `prom/opentelem` directory as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Prometheus 已经准备就绪，我们可以开始记录应用程序的指标。按照以下步骤在 `prom/opentelem` 目录内运行应用程序：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let the application run for a bit and you will see the following log:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让应用程序运行一段时间，您将看到以下日志：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`metric.totalrequest`: This metric reports the total number of requests processed
    by the application; the sample application has an HTTP server running on port
    `8000`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metric.totalrequest`：此指标报告应用程序处理的总请求数量；示例应用程序在端口 `8000` 上运行一个 HTTP 服务器'
- en: '`metric.random`: This metric reports a random number'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metric.random`：此指标报告一个随机数'
- en: With the successful run of the sample application, we can now see the metric
    in the Prometheus UI. Open your browser and head to http://localhost:9090 and
    type in `metric_random` and you will see something such as that shown in *Figure
    3**.12*; click on the **Execute** button.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在样本应用程序成功运行后，我们可以在Prometheus UI中看到这个指标。打开你的浏览器，转到http://localhost:9090，并输入`metric_random`，你将看到类似于*图3.12*所示的输出；点击**执行**按钮。
- en: '![](img/Figure_3.12_B18295.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.12_B18295.jpg)'
- en: Figure 3.12 – metric_random metric
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – `metric_random`指标
- en: 'Select the **Graph** tab and you will see the following figure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**图形**选项卡，你将看到以下图示：
- en: '![](img/Figure_3.13_B18295.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.13_B18295.jpg)'
- en: Figure 3.13 – metric_random graph
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – `metric_random`图形
- en: The other metric that we want to show is the total number of requests processed
    by the sample application’s HTTP server. In order to generate some metrics, open
    the browser and enter http://localhost:8000; do so a few times so that some metrics
    will be generated.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要展示的另一个指标是样本应用程序的HTTP服务器处理的总请求数。为了生成一些指标，打开浏览器并输入http://localhost:8000；多次这样做，以便生成一些指标。
- en: 'Open the Prometheus UI again (http://localhost:9090), add the `metric_totalrequest`
    metric as shown in *Figure 3**.14*, and click on **Execute**:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开Prometheus UI（http://localhost:9090），添加`metric_totalrequest`指标，如图*图3.14*所示，然后点击**执行**：
- en: '![](img/Figure_3.14_B18295.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.14_B18295.jpg)'
- en: Figure 3.14 – metric_totalrequest metric
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – `metric_totalrequest`指标
- en: 'The graph will look as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图形将如下所示：
- en: '![](img/Figure_3.15_B18295.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.15_B18295.jpg)'
- en: Figure 3.15 – metric_totalrequest graph
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – `metric_totalrequest`图形
- en: 'If you are having problems and cannot see the metrics, change the Prometheus
    configuration file, `config.yml`, inside the `chapter3/prom/opentelem` directory
    and change the target from `host.docker.internal` to `localhost` as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到问题并且看不到指标，请更改`chapter3/prom/opentelem`目录中的Prometheus配置文件`config.yml`，将目标从`host.docker.internal`更改为`localhost`，如下所示：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `metrics.go` source contains the code that initializes the `otel` SDK to
    configure it for Prometheus, which is shown in the code snippet here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`metrics.go`源代码包含初始化`otel` SDK并为其配置Prometheus的代码，如下面的代码片段所示：'
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following code snippet shows how it sends the metrics to Prometheus – the
    code can be found in `main.go` inside the `chapter3/prom/opentelem` directory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了它如何将指标发送到Prometheus – 代码可以在`chapter3/prom/opentelem`目录中的`main.go`文件中找到：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have successfully added metrics and tracing to our applications
    and can view them using both Jaeger and Prometheus; in the next section, we will
    look at putting all the tools together to make it easy to run them as a single
    unit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地将指标和跟踪添加到我们的应用程序中，并且可以使用Jaeger和Prometheus查看它们；在下一节中，我们将探讨如何将这些工具组合在一起，以便作为一个单一单元运行。
- en: Running docker-compose
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行docker-compose
- en: We normally run containers using the `docker` command, but what if we want to
    run more than one container in one go? This is where `docker-compose` comes to
    the rescue. The tool allows you to configure the different containers that you
    want to run as a single unit. It also allows different kinds of configurations
    for different containers – for example, container A can communicate via the network
    with container B but not with container C.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用`docker`命令运行容器，但如果我们想一次性运行多个容器怎么办？这就是`docker-compose`发挥作用的地方。这个工具允许你配置你想要作为一个单一单元运行的容器。它还允许为不同的容器设置不同的配置
    – 例如，容器A可以通过网络与容器B通信，但不能与容器C通信。
- en: The `docker-compose` tool that we are using in this book is v2, which is the
    recommended version. You can find instructions for installing the tool for different
    operating systems here – [https://docs.docker.com/compose/install/other/](https://docs.docker.com/compose/install/other/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的`docker-compose`工具是v2，这是推荐的版本。你可以在这里找到为不同操作系统安装工具的说明 – [https://docs.docker.com/compose/install/other/](https://docs.docker.com/compose/install/other/)。
- en: 'To make it easy to run both Prometheus and Jaeger, you can use `docker-compose`.
    The `docker-compose.yml` file looks as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便运行Prometheus和Jaeger，你可以使用`docker-compose`。`docker-compose.yml`文件如下所示：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run `docker-compose` using the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行`docker-compose`：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On a successful run, you will see the following log:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功运行后，你将看到以下日志：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `up` parameter we are using will start the container in the terminal and
    run in attached mode, which allows you to show all the logs on the screen. You
    also can run in detached mode to run the container in the background as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`up`参数将在终端中启动容器并以附加模式运行，这允许您在屏幕上显示所有日志。您也可以以分离模式运行，如下所示，让容器在后台运行：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we looked at how to add metrics and tracing into an application
    using the `OpenTelemetry` library. Having this observability in an application
    will enable us to troubleshoot issues faster and also keep track of the performance
    of our application from the provided metrics. We also took a look at using two
    different open source projects that allow us to look at the data collected from
    our application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用`OpenTelemetry`库将指标和跟踪添加到应用程序中。在应用程序中拥有这种可观察性将使我们能够更快地解决问题，并从提供的指标中跟踪我们应用程序的性能。我们还查看了一些开源项目，这些项目允许我们查看从我们的应用程序收集的数据。
- en: In this chapter, we looked at the plumbing and infrastructure required to monitor
    and trace our application. In the next chapter, we will look at different aspects
    of building both dynamic and static content for our web application and how to
    package the application to make it easier to deploy anywhere.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了监控和跟踪我们的应用程序所需的管道和基础设施。在下一章中，我们将探讨为我们的Web应用程序构建动态和静态内容的不同方面，以及如何打包应用程序以使其更容易部署到任何地方。
- en: Part 2:Serving Web Content
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：服务网页内容
- en: Upon completing this part of the book, you will be able to create server-rendered
    pages using an HTML/template and Gorilla Mux. You will also learn how to create
    and expose an API that will be used by the frontend. Securing the API will be
    discussed, including middleware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本书的这一部分后，您将能够使用HTML/template和Gorilla Mux创建服务器端渲染的页面。您还将学习如何创建和公开一个将被前端使用的API。将讨论保护API，包括中间件。
- en: 'This part includes the following chapters:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 4*](B18295_04.xhtml#_idTextAnchor053)*, Serving and Embedding HTML
    Content*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第四章*](B18295_04.xhtml#_idTextAnchor053)*，服务并嵌入HTML内容*'
- en: '[*Chapter 5*](B18295_05.xhtml#_idTextAnchor070)*, Securing the Backend and
    Middleware*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18295_05.xhtml#_idTextAnchor070)*，保护后端和中间件*'
- en: '[*Chapter 6*](B18295_06.xhtml#_idTextAnchor093)*, Moving to API-First*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B18295_06.xhtml#_idTextAnchor093)*，转向API优先*'
