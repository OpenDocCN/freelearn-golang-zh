<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer039">
<h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor053"/>4</h1>
<h1 id="_idParaDest-52"><a id="_idTextAnchor054"/>Serving and Embedding HTML Content</h1>
<p>As we build on our foundations, it is important that we look at another aspect of processing HTTP user requests, routing. Routing is useful as it allows us to structure our application to handle <a id="_idIndexMarker142"/>different functionality for certain HTTP methods, such as a <strong class="source-inline">GET</strong> that can retrieve and a <strong class="source-inline">POST</strong> on the same route that can replace the data. This concept is the fundamental principle of designing a REST-based application. We’ll end the chapter by looking at how we can use the new <strong class="source-inline">embed</strong> directive introduced in Go version 1.16 to bundle our web app as a single self-contained executable. This chapter will provide us with the tools to handle user data and create the interface for <span class="No-Break">the user.</span></p>
<p>By the end of this chapter, you will have learned how static and dynamic content is served by the application. You will also have learned how to embed all the different assets (icons, <strong class="source-inline">.xhtml</strong>, <strong class="source-inline">.css</strong>, etc.) that will be served by the web application in the application using a single binary. In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Handling HTTP functions and <span class="No-Break">Gorilla Mux</span></li>
<li>Rendering static and <span class="No-Break">dynamic content</span></li>
<li>Using Go embed to bundle <span class="No-Break">your content</span></li>
</ul>
<h1 id="_idParaDest-53"><a id="_idTextAnchor055"/>Technical requirements</h1>
<p>All the source code for this chapter can be accessed <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04</span></a><span class="No-Break">.</span><a id="_idTextAnchor056"/></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor057"/>Handling HTTP functions and Gorilla Mux</h1>
<p>When we look at the <strong class="bold">Go standard library</strong>, we <a id="_idIndexMarker143"/>can see that a lot of thought has gone into <a id="_idIndexMarker144"/>the <strong class="bold">HTTP library</strong>. You can check out the documentation for the <a id="_idIndexMarker145"/>Go standard library here: <a href="https://pkg.go.dev/net/http">https://pkg.go.dev/net/http</a>. However, we’ll cover the foundations and look at how we can build upon them. It’s interesting to Note that the Go standard library covers both client- and server-side implementations. We will only be focusing on the parts we require to <span class="No-Break">serve content.</span></p>
<p>We will create a simple app that replies with <strong class="screen-inline">Hello, World</strong>, as well as look at returning <strong class="source-inline">POST</strong> data once we have expanded <span class="No-Break">our rout<a id="_idTextAnchor058"/>es.</span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor059"/>Hello, World with defaults</h2>
<p>The <a id="_idIndexMarker146"/>basic concepts of creating a server <a id="_idIndexMarker147"/>in <strong class="bold">Golang</strong> are <span class="No-Break">as follows:</span></p>
<pre class="source-code">
     1    package main
     2
     3    import (
     4        "fmt"
     5        "log"
     6        "net/http"
     7        "os"
     8        "time"
     9    )
    10
    11    func handlerGetHelloWorld(wr http.ResponseWriter,
                                    req *http.Request) {
    12        fmt.Fprintf(wr, "Hello, World\n")
    13        log.Println(req.Method) // request method
    14        log.Println(req.URL)    // request URL
    15        log.Println(req.Header) // request headers
    16        log.Println(req.Body)   // request body)
    17    }
    18
...
    29
    30    func main() {
...
    43        router := http.NewServeMux()
    44
    45        srv := http.Server{
    46            Addr:           ":" + port,
    47            Handler:        router,
    48            ReadTimeout:    10 * time.Second,
    49            WriteTimeout:   120 * time.Second,
    50            MaxHeaderBytes: 1 &lt;&lt; 20,
    51        }
    52
...
    57        router.HandleFunc("/", handlerGetHelloWorld)
    58        router.Handle("/1", dummyHandler)
    59        err := srv.ListenAndServe()
    60        if err != nil {
    61            log.Fatalln("Couldnt ListenAndServe()",
                              err)
    62        }
    63    }</pre>
<p>You can see this code in the <a id="_idIndexMarker148"/>Git repository under the <span class="No-Break"><strong class="source-inline">library-mux</strong></span><span class="No-Break"> sub-folder.</span></p>
<p>How this works is we define a <strong class="source-inline">handlerGetHelloWorld</strong> handler function (row 11) that is passed as a parameter to the <strong class="source-inline">router.HandleFunc</strong> function. The <strong class="source-inline">HandleFunc</strong> parameter requires a function parameter that has the following signature: <span class="No-Break"><strong class="source-inline">func(ResponseWriter</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">*Request</strong></span><span class="No-Break">).</span></p>
<p>The handler’s job is to take in a request type and a <strong class="source-inline">ResponseWriter</strong> and make a decision based on the request; that is, what to write to <strong class="source-inline">ResponseWriter</strong>. In our case, the <strong class="source-inline">handlerGetHelloWorld</strong> handler will send the <strong class="source-inline">Hello, World</strong> string as a response, using the <strong class="source-inline">fmt.Fprintf(...)</strong> function. The reason why it is possible for the response to be sent back is that the <strong class="source-inline">http.ResponseWriter</strong> implements the <strong class="source-inline">Write()</strong> function, which is used inside the <span class="No-Break"><strong class="source-inline">fmt.Fprintf(...)</strong></span><span class="No-Break"> function.</span></p>
<p>We now define the following steps for the <span class="No-Break">main function:</span></p>
<ol>
<li>First, we create a router: this is what our handlers will connect to. We create our own router with <strong class="source-inline">NewServeMux</strong> (line 43). We could use the <strong class="source-inline">DefaultServeMux</strong> found in the default library, but as you will see at <a href="https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334">https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334</a>, it contains a few additional debugging endpoints that we may not want to expose publicly. By registering our own, we gain more control and can add the same endpoints ourselves if we <span class="No-Break">want them.</span></li>
<li>Second, we create an instance of our server and bind it to an available port. The <strong class="source-inline">Addr</strong> field on the server specifies the address and port to bind to. In our example, we are using <strong class="source-inline">9002</strong>. Different operating systems have different restrictions on what port can be used. For example, Linux systems only allow the admin or root user to run applications that use ports between <strong class="source-inline">1</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">1023</strong></span><span class="No-Break">.</span></li>
<li>The final step is to attach our router, start the server, and get it to begin listening. This is accomplished in line 57. What we’re doing here is telling the router that when it gets any HTTP request for <strong class="source-inline">"/"</strong>, known as the document root, it should handle the request by passing it to <span class="No-Break">our handler.</span></li>
<li>The final function, <strong class="source-inline">srv.ListenAndServe()</strong> (line 59), is a blocking function that starts our server up and starts listening for incoming requests on the<a id="_idIndexMarker149"/> server’s defined port. When a valid HTTP request is found, it is passed to the <strong class="bold">mux</strong>, which then <a id="_idIndexMarker150"/>pattern matches the route – that is, the given sequence is checked against the patterns known by the mux, and if a pattern is found for <strong class="source-inline">"/"</strong>, then our handler is invoked. We can run our app and visit <strong class="source-inline">http://localhost:9002/</strong>; we should be met with the following response from <span class="No-Break">the server:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer035">
<img alt="Figure 4.1 – Hello, World from Go!" height="749" src="image/Figure_4.1_B18295.jpg" width="1588"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Hello, World from Go!</p>
<p>It’s good to note <a id="_idIndexMarker151"/>here that each request is given its own goroutine to execute concurrently, and each request’s life cycle is managed by the server so we don’t need to do anything explicitly to <span class="No-Break">leverage this.</span></p>
<p>In the next section, we will explore building different functionalities using <strong class="bold">Gorilla Mux</strong>. In particular, we will look at implementing handlers and the different ways to handle HTTP methods, such as <strong class="source-inline">GET</strong> <span class="No-Break">a<a id="_idTextAnchor060"/>nd </span><span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor061"/>Building on the basics with Gorilla Mux</h2>
<p>Gorilla Mux, accessible <a id="_idIndexMarker152"/>at <a href="https://github.com/gorilla/mux">https://github.com/gorilla/mux</a>, is a subproject of the <strong class="bold">Gorilla project</strong>. Gorilla Mux is an <em class="italic">HTTP request multiplexer</em> that makes it easy to match different <a id="_idIndexMarker153"/>handlers with matching incoming requests. Developers gain a lot of benefits from using the library, as it makes writing lots of boilerplate code unnecessary. The library provides advanced capabilities to match requests based on different criteria, such as schemes and <span class="No-Break">dynamic URLs.</span></p>
<p>The server and router <a id="_idIndexMarker154"/>provided as part of Go’s standard library are incredibly powerful for “freebies”, but we’re going to look at adding Gorilla Mux to our project and some of the benefits <span class="No-Break">it provides.</span></p>
<p>Uses of the web consist of more than just returning <em class="italic">Hello World</em>, and generally, most web apps accept data provided by users, update the data, and even delete the data, and this is possible because the browser accepts a variety of content such as images, video, data fields, and plain text. The previous exercise focused on what is known as a <strong class="source-inline">GET</strong> method, which is the default sent when you load a page in your web browser, but there are <span class="No-Break">many more.</span></p>
<p>The standard library implementation makes it easy to explicitly handle other types of methods, such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, and more, which are defined in the HTTP standard. This is typically done in the handler function as we can <span class="No-Break">see below:</span></p>
<pre class="source-code">
func methodFunc(wr http.ResponseWriter, req http.Request) {
   ...
   switch req.Method {
   case http.MethodGet:
       // Serve page - GET is the default when you visit a
       // site.
   case http.MethodPost:
       // Take user provided data and create a record.
   case http.MethodPut:
       // Update an existing record.
   case http.MethodDelete:
       // Remove the record.
   default:
       http.Error(wr, "Unsupported Method!",
                  http.StatusMethodNotAllowed)
   }
}</pre>
<p>Let’s look at an<a id="_idIndexMarker155"/> example of how we can separate two handlers, <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong>, and some of the helpers provided by <span class="No-Break">Gorilla Mux:</span></p>
<pre class="source-code">
         1    package main
     2
     3    import (
     4        "bytes"
     5        "fmt"
     6        "io"
     7        "io/ioutil"
     8        "log"
     9        "net/http"
    10        "os"
    11
    12        "github.com/gorilla/mux"
    13    )
    14
    15    func handlerSlug(wr http.ResponseWriter, req
                           *http.Request) {
    16        slug := mux.Vars(req)["slug"]
    17        if slug == "" {
    18            log.Println("Slug not provided")
    19            return
    20        }
    21        log.Println("Got slug", slug)
    22    }
    23
    24    func handlerGetHelloWorld(wr http.ResponseWriter,
                                    req *http.Request) {
    25        fmt.Fprintf(wr, "Hello, World\n")
              // request method
    26        log.Println("Request via", req.Method)
              // request URL
    27        log.Println(req.URL)
              // request headers
    28        log.Println(req.Header)
              // request body)
    29        log.Println(req.Body)
    30    }
    31
    32    func handlerPostEcho(wr http.ResponseWriter,
                               req *http.Request) {
              // request method
    33        log.Println("Request via", req.Method)
              // request URL
    34        log.Println(req.URL)
              // request headers
    35        log.Println(req.Header)
    36
    37        // We are going to read it into a buffer
    38        // as the request body is an io.ReadCloser
    39        // and so we should only read it once.
    40        body, err := ioutil.ReadAll(req.Body)
    41
    42        log.Println("read &gt;", string(body), "&lt;")
    43
    44        n, err := io.Copy(wr, bytes.NewReader(body))
    45        if err != nil {
    46            log.Println("Error echoing response",
                               err)
    47        }
    48        log.Println("Wrote back", n, "bytes")
    49    }
    50
    51    func main() {
    52        // Set some flags for easy debugging
    53        log.SetFlags(log.Lshortfile | log.Ldate |
                           log.Lmicroseconds)
    54
    55        // Get a port from ENV var or default to 9002
    56        port := "9002"
    57        if value, exists :=
                os.LookupEnv("SERVER_PORT"); exists {
    58            port = value
    59        }
    60
    61        // Off the bat, we can enforce StrictSlash
    62        // This is a nice helper function that means
    63        // When true, if the route path is "/foo/",
              // accessing "/foo" will perform a 301
              // redirect to the former and vice versa.
    64        // In other words, your application will
              // always see the path as specified in the
              // route.
    65        // When false, if the route path is "/foo",
              // accessing "/foo/" will not match this
              // route and vice versa.
    66
    67        router := mux.NewRouter().StrictSlash(true)
    68
    69        srv := http.Server{
    70            Addr:    ":" + port, // Addr optionally
                  // specifies the listen address for the
                  // server in the form of "host:port".
    71            Handler: router,
    72        }
    73
    74        router.HandleFunc("/", handlerGetHelloWorld)
                .Methods(http.MethodGet)
    75        router.HandleFunc("/", handlerPostEcho)
                .Methods(http.MethodPost)
    76        router.HandleFunc("/{slug}", handlerSlug)
                .Methods(http.MethodGet)
    77
    78        log.Println("Starting on", port)
    79        err := srv.ListenAndServe()
    80        if err != nil {
    81            log.Fatalln("Couldnt ListenAndServe()", err)
    82        }
    83    }</pre>
<p>We’ve imported the<a id="_idIndexMarker156"/> Gorilla Mux library as <strong class="source-inline">mux</strong> and set up two different handlers: <strong class="source-inline">handlerGetHelloWorld</strong> (line 24) and <strong class="source-inline">handlerPostEcho</strong> (line 32). <strong class="source-inline">handlerGetHelloWorld</strong> is the same handler we defined in the previous example that responds with <em class="italic">Hello, World</em>. Here, thanks to the extended functionality of the router, we’ve specified explicitly that the handler can only resolve if the user performs a <strong class="source-inline">GET</strong> method on the <strong class="source-inline">"/"</strong> endpoint (<span class="No-Break">line 74).</span></p>
<p>Let’s start the sample by first changing to the <strong class="source-inline">chapter4/gorilla-mux</strong> directory and running the <span class="No-Break">following command:</span></p>
<pre class="console">
go run main.go</pre>
<p>We can use<a id="_idIndexMarker157"/> cURL, which is a standard utility available on Windows (use cmd instead of PowerShell) and installed by default on Linux (depending on your Linux distribution) and macOS. The tool allows users to make HTTP requests from a terminal without using a browser. Use the <strong class="source-inline">curl localhost:9002</strong> command in a separate terminal to test whether the server is up <span class="No-Break">and running:</span></p>
<pre class="console">
$ curl localhost:9002
Hello, World
$ # Specify DELETE as the option...
$ curl localhost:9002 -v -X DELETE</pre>
<p>We can see that <strong class="source-inline">GET</strong> works as expected but using <strong class="source-inline">-X DELETE</strong> to tell cURL to use the <strong class="source-inline">HTTP DELETE </strong>method results in no content being returned. Under the hood, the endpoint is responding with a <strong class="source-inline">405 Method Not Allowed</strong> error message. The 405 error message reported to the user comes from the library <span class="No-Break">by default.</span></p>
<p>We’ve added a second handler (line 75) to take data from a <strong class="source-inline">POST</strong> request. The handler for the <strong class="source-inline">POST</strong> method, <strong class="source-inline">handlerPostEcho</strong> (line 32), performs in a similar manner to the <strong class="source-inline">GET</strong> request, but we’ve added some additional code to read the user-provided data, store it, print it, and then return <span class="No-Break">it unaltered.</span></p>
<p>We can see how this works using cURL <span class="No-Break">as before:</span></p>
<pre class="console">
$ curl -X POST localhost:9002 -d "Echo this back"
Echo this back</pre>
<p>We’re skipping a lot of validation and explicitly checking/handling data formats, such as JSON, at this point, but we’ll build towards this in <span class="No-Break">later sections.</span></p>
<p>Another benefit of using <a id="_idIndexMarker158"/>Gorilla Mux is how easy it makes pattern matching in paths. These path variables, or <strong class="source-inline">slugs</strong>, are defined using the <strong class="source-inline">{name}</strong> format or <strong class="source-inline">{name:pattern}</strong>. The following table shows different <strong class="source-inline">slugs</strong> <span class="No-Break">with examples:</span></p>
<table class="No-Table-Style" id="table001-3">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">books/{pagetitle}/page/{pageno}</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">books/mytitle/page/1, /books/anothertitle/page/100</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">posts/{slug}</strong></span></p>
</td>
<td class="No-Table-Style">
<p>/<span class="No-Break">posts/titlepage</span></p>
<p>/<span class="No-Break">posts/anothertitle</span></p>
</td>
</tr>
</tbody>
</table>
<p>Pattern can be a type of<a id="_idIndexMarker159"/> regular expression. For example, in our sample code we added a <strong class="source-inline">handlerSlug</strong> handler (line 15) to perform a simple capture. We can use cURL to test this, as shown in the <span class="No-Break">following code:</span></p>
<pre class="console">
$ curl localhost:9002/full-stack-go
…
$ # Our server will show the captured variable in its output
...
2022/01/15 14:58:36.171821 main.go:21: Got slug &gt; full-stack-go &lt;</pre>
<p>In this section, we have learned how to write handlers and use them with Gorilla Mux. We have also looked at configuring Gorilla Mux to handle dynamic paths that will be processed by handlers. In the next section, we will look at serving content to users from our application. The served content will contain static and <span class="No-Break">dynamic content.</span><a id="_idTextAnchor062"/></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor063"/>Rendering static content</h1>
<p>In this section, we will<a id="_idIndexMarker160"/> learn how to serve the web pages we have created as static content. We will use the standard Go <strong class="source-inline">net/http</strong> package to serve up the web pages. All the code and HTML files can be found inside the <strong class="source-inline">static/web</strong> <span class="No-Break">directory (</span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web</span></a><span class="No-Break">).</span></p>
<p>Execute the server using the <span class="No-Break">following command:</span></p>
<pre class="console">
go run main.go</pre>
<p>You will see the following message on <span class="No-Break">the screen:</span></p>
<pre class="console">
2022/01/11 22:22:03 Starting up server on port 3333 ...</pre>
<p>Open your <a id="_idIndexMarker161"/>browser and enter <strong class="source-inline">http://localhost:3333</strong> as the URL. You will see the login page, as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 4.2 – The login page" height="665" src="image/Figure_4.2_B18295.jpg" width="983"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The login page</p>
<p>To access the dashboard page, you can use the URL <strong class="source-inline">http://localhost:3333/dashboard.xhtml</strong>. You will see like the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<img alt=" Figure 4.3 – The dashboard page" height="977" src="image/Figure_4.3_B18295.jpg" width="1150"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 4.3 – The dashboard page</p>
<p>Let’s take a <a id="_idIndexMarker162"/>quick look at the code that serves up the <span class="No-Break">static pages:</span></p>
<pre class="source-code">
    1    package main
     2
     3    import (
     4        "log"
     5        "net/http"
     6    )
     7
     8    func main() {
     9        fs := http.FileServer(http.Dir("./static"))
    10        http.Handle("/", fs)
    11
    12        log.Println("Starting up server on port 3333
                           ...")
    13        err := http.ListenAndServe(":3333", nil)
    14        if err != nil {
    15            log.Fatal("error occurred starting up
                            server : ", err)
    16        }
    17    }</pre>
<p>As can be seen, this <a id="_idIndexMarker163"/>is a simple HTTP server that uses the <strong class="source-inline">http.FileServer(..)</strong> Go standard library function (shown in line 9). The function is called by passing in the <strong class="source-inline">(./static)</strong> parameter to the directory that we want to serve (line 9). The example code can be found inside the <span class="No-Break"><strong class="source-inline">chapter4/static/web/static</strong></span><span class="No-Break"> folde<a id="_idTextAnchor064"/>r.</span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor065"/>Rendering dynamic content</h1>
<p>Now that we understand how to<a id="_idIndexMarker164"/> serve static content using the <strong class="source-inline">net/http</strong> package, let’s take a look at adding some dynamic content using Gorilla Mux found here: <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic</a>. Execute the server using the <span class="No-Break">following command:</span></p>
<pre class="console">
go run main.go</pre>
<p>Launch your browser and enter <strong class="source-inline">http://localhost:3333</strong> as the address; you will see a login screen similar to the static content. Perform the following steps on the <span class="No-Break">login screen:</span></p>
<ol>
<li value="1">Enter any combination of username and password on the <span class="No-Break">login screen.</span></li>
<li>Click the <span class="No-Break"><strong class="screen-inline">Login</strong></span><span class="No-Break"> button.</span></li>
</ol>
<p>You will get<a id="_idIndexMarker165"/> a <strong class="bold">Login unsuccessful</strong> message, as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt=" Figure 4.4 – Message screen after login" height="290" src="image/Figure_4.4_B18295.jpg" width="628"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 4.4 – Message screen after login</p>
<p>We have<a id="_idIndexMarker166"/> introduced dynamic content for our login operation, which means the application will serve pages based on certain conditions, in this case, the successful validation of the username/password combination. To achieve a successful validation, enter <strong class="source-inline">admin/admin</strong> as the username/password combination, as this exists in <span class="No-Break">the database.</span></p>
<p>Let’s explore the code a bit further to understand how <span class="No-Break">it works:</span></p>
<pre class="source-code">
     1    package main
     2
     3    import (
     4        "fmt"
     5        "github.com/gorilla/mux"
     6        "html/template"
     7        "log"
     8        "net/http"
     9        "os"
    10        "path/filepath"
    11        "time"
    12    )
    13
    14    type staticHandler struct {
    15        staticPath string
    16        indexPage  string
    17    }
    18
    19    func (h staticHandler) ServeHTTP(w
                http.ResponseWriter, r *http.Request) {
    20        path, err := filepath.Abs(r.URL.Path)
    21        log.Println(r.URL.Path)
    22        if err != nil {
    23            http.Error(w, err.Error(),
                             http.StatusBadRequest)
    24            return
    25        }
    26
    27        path = filepath.Join(h.staticPath, path)
    28
    29        _, err = os.Stat(path)
    30
    31        http.FileServer(
                http.Dir(h.staticPath)).ServeHTTP(w, r)
    32    }
    33
    34    func postHandler(w http.ResponseWriter,
                           r *http.Request) {
    35        result := "Login "
    36        r.ParseForm()
    37
    38        if validateUser(r.FormValue("username"),
                              r.FormValue("password")) {
    39            result = result + "successfull"
    40        } else {
    41            result = result + "unsuccessful"
    42        }
    43
    44        t, err :=
                template.ParseFiles("static/tmpl/msg.xhtml")
    45
    46        if err != nil {
    47            fmt.Fprintf(w, "error processing")
    48            return
    49        }
    50
    51        tpl := template.Must(t, err)
    52
    53        tpl.Execute(w, result)
    54    }
    55
    56    func validateUser(username string,
                            password string) bool {
    57        return (username == "admin") &amp;&amp;
                (password == "admin")
    58    }
    59
    60    func main() {
    61        router := mux.NewRouter()
    62
    63        router.HandleFunc("/login",
                postHandler).Methods("POST")
    64
    65        spa := staticHandler{staticPath: "static",
                                   indexPage: "index.xhtml"}
    66        router.PathPrefix("/").Handler(spa)
    67
    68        srv := &amp;http.Server{
    69            Handler:      router,
    70            Addr:         "127.0.0.1:3333",
    71            WriteTimeout: 15 * time.Second,
    72            ReadTimeout:  15 * time.Second,
    73        }
    74
    75        log.Fatal(srv.ListenAndServe())
    76    }</pre>
<p>The <strong class="source-inline">ServeHTTP</strong> function (line 19) serves the content specified by the directory defined in the <strong class="source-inline">staticHandler</strong> struct (line 65), which points to the <strong class="source-inline">static</strong> directory with the index page showing as <strong class="source-inline">index.xhtml</strong>. The handler configuration is registered using the Gorilla Mux attached to the <strong class="source-inline">/</strong> path prefix (<span class="No-Break">line 66).</span></p>
<p>The next part is the code that takes care of the registration of the <strong class="source-inline">/login</strong> endpoint (line 63). The <strong class="source-inline">postHandler</strong> function (line 34) extracts and validates the username and password information passed from <span class="No-Break">the request.</span></p>
<p>The web <a id="_idIndexMarker167"/>page contains two input elements, the username and password, which are sent by the browser when the user clicks on the <strong class="bold">Login</strong> button. When the handler (line 34) receives the data, it parses it using the <strong class="source-inline">ParseForm()</strong> function (line 36) and then extracts the value passed by referencing the field names <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> (line 38), which corresponds to the name of the HTML element specified inside the file <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter04/dynamic/static/index.xhtml</strong></span><span class="No-Break">.</span></p>
<p>On completing the validation process, the app then uses the Go <strong class="source-inline">html/template</strong> package (line 44) to parse another HTML file (<strong class="source-inline">static/tmpl/msg.xhtml</strong>). The app will parse the HTML file and will insert all the relevant information to be included as part of the HTML page using the <strong class="source-inline">template.Must</strong> function (<span class="No-Break">line 51).</span></p>
<p>This <strong class="source-inline">msg.xhtml</strong> file contains a <strong class="source-inline">{{.}}</strong> placeholder string that is understood by the <strong class="source-inline">html/template</strong> package (<span class="No-Break">line 18):</span></p>
<pre class="source-code">
     1    &lt;!DOCTYPE html&gt;
     2    &lt;html&gt;
     3      &lt;head&gt;
    ...
    18                &lt;p class="text-xs text-gray-50"&gt;{{.}}
                      &lt;/p&gt;
 ...
    24    &lt;/html&gt;</pre>
<p>In this section, we have learned how to render dynamic content. In the next section, we will look at bundling both our static and dynamic content to allow us to run the application as a <span class="No-Break">single <a id="_idTextAnchor066"/>file.</span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor067"/>Using Go embed to bundle your content</h1>
<p>In this section, we will <a id="_idIndexMarker168"/>look at how to package applications<a id="_idIndexMarker169"/> into a single binary. Packaging everything the application needs into a single binary makes it easier to deploy the application anywhere in the cloud. We are going to use the <strong class="source-inline">embed</strong> package that is provided by the <em class="italic">Go standard library</em>. The following link provides further detail on the different functions available inside the embed <span class="No-Break">package: </span><a href="https://pkg.go.dev/embed"><span class="No-Break">https://pkg.go.dev/embed</span></a><span class="No-Break">.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">The embed package is only available in Go version 1.16 <span class="No-Break">and upwards.</span></p>
<p>The following code provides a simple example of using the embed package in three different ways – to embed a specific file, embed the full contents of a folder, and embed a specific <span class="No-Break">file type:</span></p>
<pre class="source-code">
     1    package main
     2
     3    import (
     4        "embed"
     5        "fmt"
     6        "github.com/gorilla/mux"
     7        "html/template"
     8        "io/fs"
     9        "log"
    10        "net/http"
    11        "os"
    12        "path/filepath"
    13        "strings"
    14        "time"
    15    )
    16
    17    var (
    18        Version string = strings.TrimSpace(version)
    19        //go:embed version/version.txt
    20        version string
    21
    22        //go:embed static/*
    23        staticEmbed embed.FS
    24
    25        //go:embed tmpl/*.xhtml
    26        tmplEmbed embed.FS
    27    )
    28
    29    type staticHandler struct {
    30        staticPath string
    31        indexPage  string
    32    }
    33
    34    func (h staticHandler) ServeHTTP(w
                http.ResponseWriter, r *http.Request) {
    35        path, err := filepath.Abs(r.URL.Path)
    36        log.Println(r.URL.Path)
    37        if err != nil {
    38            http.Error(w, err.Error(),
                             http.StatusBadRequest)
    39            return
    40        }
    41
    42        path = filepath.Join(h.staticPath, path)
    43
    44        _, err = os.Stat(path)
    45
    46        log.Print("using embed mode")
    47        fsys, err := fs.Sub(staticEmbed, "static")
    48        if err != nil {
    49            panic(err)
    50        }
    51
    52        http.FileServer(http.FS(fsys)).ServeHTTP(w,
                                                       r)
    53    }
    54
    55    //renderFiles renders file and push data (d) into
          // the templates to be rendered
    56    func renderFiles(tmpl string, w
            http.ResponseWriter, d interface{}) {
    57        t, err := template.ParseFS(tmplEmbed,
                fmt.Sprintf("tmpl/%s.xhtml", tmpl))
    58        if err != nil {
    59            log.Fatal(err)
    60        }
    61
    62        if err := t.Execute(w, d); err != nil {
    63            log.Fatal(err)
    64        }
    65    }
    66
    67    func postHandler(w http.ResponseWriter,
                           r *http.Request) {
    68        result := "Login "
    69        r.ParseForm()
    70
    71        if validateUser(r.FormValue("username"),
                              r.FormValue("password")) {
    72            result = result + "successfull"
    73        } else {
    74            result = result + "unsuccessful"
    75        }
    76
    77        renderFiles("msg", w, result)
    78    }
    79
    80    func validateUser(username string,
                            password string) bool {
    81        return (username == "admin") &amp;&amp;
                     (password == "admin")
    82    }
    83
    84    func main() {
    85        log.Println("Server Version :", Version)
    86
    87        router := mux.NewRouter()
    88
    89        router.HandleFunc("/login", postHandler)
                .Methods("POST")
    90
    91        spa := staticHandler{staticPath: "static",
                                   indexPage: "index.xhtml"}
    92        router.PathPrefix("/").Handler(spa)
    93
    94        srv := &amp;http.Server{
    95            Handler:      router,
    96            Addr:         "127.0.0.1:3333",
    97            WriteTimeout: 15 * time.Second,
    98            ReadTimeout:  15 * time.Second,
    99        }
   100
   101        log.Fatal(srv.ListenAndServe())
   102    }</pre>
<p>The <a id="_idIndexMarker170"/>source code resides inside the <strong class="source-inline">chapter4/embed</strong> folder. The code uses the <strong class="source-inline">//go:embed</strong> directive (lines 19, 22, and 25). This<a id="_idIndexMarker171"/> tells the compiler that the <strong class="source-inline">version string</strong> (line 20) will get the content from <strong class="source-inline">version/version.txt</strong>, which contains the version information that we want to display to <span class="No-Break">the user.</span></p>
<p>We also declare the <strong class="source-inline">//go:embed</strong> directive telling the compiler that we want to include everything inside the <strong class="source-inline">static/</strong> (line 22) and <strong class="source-inline">tmpl/</strong> (line 25) folders. During the compilation process, the compiler detects the preceding directives and automatically includes all the different files into <span class="No-Break">the binary.</span></p>
<p>The <strong class="source-inline">tmpl</strong> directory contains the template that will render dynamic content, and since we have embedded it into the binary, we need to use a different way to render it (line 56). The new <strong class="source-inline">renderFiles</strong> function uses the <strong class="source-inline">template.ParseFS</strong> function (line 57), which renders the template declared in the <span class="No-Break"><strong class="source-inline">tmplEmbed</strong></span><span class="No-Break"> variable.</span></p>
<p>The <strong class="source-inline">renderFiles</strong> function is called from the <strong class="source-inline">postHandler</strong> function (line 77), passing in the template name and <span class="No-Break">other parameters.</span></p>
<p>Now, this time when building our application, the final executable file contains the different files (HTML, CSS, etc.) in a single file. We can now compile the application, <span class="No-Break">as follows:</span></p>
<pre class="console">
go build -o embed</pre>
<p>This will generate an executable file – for example, in Linux, it will be called <strong class="source-inline">embed</strong> and in Windows, it will be called <strong class="source-inline">embed.exe</strong>. Next, run the application <span class="No-Break">as follows:</span></p>
<pre class="console">
./emded</pre>
<p>Open your<a id="_idIndexMarker172"/> browser and go to <strong class="source-inline">http://localhost:3333/</strong>. It should look the same as before, except that everything is being retrieved via <strong class="source-inline">embed.FS</strong>. You now have a fully embedded application that can be deployed as a single binary in<a id="_idTextAnchor068"/> <span class="No-Break">the cloud.</span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor069"/>Summary</h1>
<p>This pretty big chapter served as our first look at interacting with user-provided data and handling web requests. We’ve seen how we can add RESTful endpoints using the Go standard library and have learned how we can use the utility functions of Gorilla Mux to quickly add more power and functionality to our application. We’ve also explored the different ways we can handle requests. In one method, we can now utilize Go’s <strong class="source-inline">html/template</strong> library to dynamically create content and package it as a directory read from disk. Alternatively, we can use the new Go <strong class="source-inline">e</strong><strong class="source-inline">mbed</strong> directive to give us a single binary that packages up all our assets and makes for <span class="No-Break">simple deployments.</span></p>
<p>In the next chapter, we will look at adding middleware to help process the request pipeline and introduce security to ensure that content can be <span class="No-Break">accessed securely.</span></p>
</div>
</div></body></html>