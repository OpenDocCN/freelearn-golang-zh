["```go\n     1    package main\n     2\n     3    import (\n     4        \"fmt\"\n     5        \"log\"\n     6        \"net/http\"\n     7        \"os\"\n     8        \"time\"\n     9    )\n    10\n    11    func handlerGetHelloWorld(wr http.ResponseWriter,\n                                    req *http.Request) {\n    12        fmt.Fprintf(wr, \"Hello, World\\n\")\n    13        log.Println(req.Method) // request method\n    14        log.Println(req.URL)    // request URL\n    15        log.Println(req.Header) // request headers\n    16        log.Println(req.Body)   // request body)\n    17    }\n    18\n...\n    29\n    30    func main() {\n...\n    43        router := http.NewServeMux()\n    44\n    45        srv := http.Server{\n    46            Addr:           \":\" + port,\n    47            Handler:        router,\n    48            ReadTimeout:    10 * time.Second,\n    49            WriteTimeout:   120 * time.Second,\n    50            MaxHeaderBytes: 1 << 20,\n    51        }\n    52\n...\n    57        router.HandleFunc(\"/\", handlerGetHelloWorld)\n    58        router.Handle(\"/1\", dummyHandler)\n    59        err := srv.ListenAndServe()\n    60        if err != nil {\n    61            log.Fatalln(\"Couldnt ListenAndServe()\",\n                              err)\n    62        }\n    63    }\n```", "```go\nfunc methodFunc(wr http.ResponseWriter, req http.Request) {\n   ...\n   switch req.Method {\n   case http.MethodGet:\n       // Serve page - GET is the default when you visit a\n       // site.\n   case http.MethodPost:\n       // Take user provided data and create a record.\n   case http.MethodPut:\n       // Update an existing record.\n   case http.MethodDelete:\n       // Remove the record.\n   default:\n       http.Error(wr, \"Unsupported Method!\",\n                  http.StatusMethodNotAllowed)\n   }\n}\n```", "```go\n         1    package main\n     2\n     3    import (\n     4        \"bytes\"\n     5        \"fmt\"\n     6        \"io\"\n     7        \"io/ioutil\"\n     8        \"log\"\n     9        \"net/http\"\n    10        \"os\"\n    11\n    12        \"github.com/gorilla/mux\"\n    13    )\n    14\n    15    func handlerSlug(wr http.ResponseWriter, req\n                           *http.Request) {\n    16        slug := mux.Vars(req)[\"slug\"]\n    17        if slug == \"\" {\n    18            log.Println(\"Slug not provided\")\n    19            return\n    20        }\n    21        log.Println(\"Got slug\", slug)\n    22    }\n    23\n    24    func handlerGetHelloWorld(wr http.ResponseWriter,\n                                    req *http.Request) {\n    25        fmt.Fprintf(wr, \"Hello, World\\n\")\n              // request method\n    26        log.Println(\"Request via\", req.Method)\n              // request URL\n    27        log.Println(req.URL)\n              // request headers\n    28        log.Println(req.Header)\n              // request body)\n    29        log.Println(req.Body)\n    30    }\n    31\n    32    func handlerPostEcho(wr http.ResponseWriter,\n                               req *http.Request) {\n              // request method\n    33        log.Println(\"Request via\", req.Method)\n              // request URL\n    34        log.Println(req.URL)\n              // request headers\n    35        log.Println(req.Header)\n    36\n    37        // We are going to read it into a buffer\n    38        // as the request body is an io.ReadCloser\n    39        // and so we should only read it once.\n    40        body, err := ioutil.ReadAll(req.Body)\n    41\n    42        log.Println(\"read >\", string(body), \"<\")\n    43\n    44        n, err := io.Copy(wr, bytes.NewReader(body))\n    45        if err != nil {\n    46            log.Println(\"Error echoing response\",\n                               err)\n    47        }\n    48        log.Println(\"Wrote back\", n, \"bytes\")\n    49    }\n    50\n    51    func main() {\n    52        // Set some flags for easy debugging\n    53        log.SetFlags(log.Lshortfile | log.Ldate |\n                           log.Lmicroseconds)\n    54\n    55        // Get a port from ENV var or default to 9002\n    56        port := \"9002\"\n    57        if value, exists :=\n                os.LookupEnv(\"SERVER_PORT\"); exists {\n    58            port = value\n    59        }\n    60\n    61        // Off the bat, we can enforce StrictSlash\n    62        // This is a nice helper function that means\n    63        // When true, if the route path is \"/foo/\",\n              // accessing \"/foo\" will perform a 301\n              // redirect to the former and vice versa.\n    64        // In other words, your application will\n              // always see the path as specified in the\n              // route.\n    65        // When false, if the route path is \"/foo\",\n              // accessing \"/foo/\" will not match this\n              // route and vice versa.\n    66\n    67        router := mux.NewRouter().StrictSlash(true)\n    68\n    69        srv := http.Server{\n    70            Addr:    \":\" + port, // Addr optionally\n                  // specifies the listen address for the\n                  // server in the form of \"host:port\".\n    71            Handler: router,\n    72        }\n    73\n    74        router.HandleFunc(\"/\", handlerGetHelloWorld)\n                .Methods(http.MethodGet)\n    75        router.HandleFunc(\"/\", handlerPostEcho)\n                .Methods(http.MethodPost)\n    76        router.HandleFunc(\"/{slug}\", handlerSlug)\n                .Methods(http.MethodGet)\n    77\n    78        log.Println(\"Starting on\", port)\n    79        err := srv.ListenAndServe()\n    80        if err != nil {\n    81            log.Fatalln(\"Couldnt ListenAndServe()\", err)\n    82        }\n    83    }\n```", "```go\ngo run main.go\n```", "```go\n$ curl localhost:9002\nHello, World\n$ # Specify DELETE as the option...\n$ curl localhost:9002 -v -X DELETE\n```", "```go\n$ curl -X POST localhost:9002 -d \"Echo this back\"\nEcho this back\n```", "```go\n$ curl localhost:9002/full-stack-go\n…\n$ # Our server will show the captured variable in its output\n...\n2022/01/15 14:58:36.171821 main.go:21: Got slug > full-stack-go <\n```", "```go\ngo run main.go\n```", "```go\n2022/01/11 22:22:03 Starting up server on port 3333 ...\n```", "```go\n    1    package main\n     2\n     3    import (\n     4        \"log\"\n     5        \"net/http\"\n     6    )\n     7\n     8    func main() {\n     9        fs := http.FileServer(http.Dir(\"./static\"))\n    10        http.Handle(\"/\", fs)\n    11\n    12        log.Println(\"Starting up server on port 3333\n                           ...\")\n    13        err := http.ListenAndServe(\":3333\", nil)\n    14        if err != nil {\n    15            log.Fatal(\"error occurred starting up\n                            server : \", err)\n    16        }\n    17    }\n```", "```go\ngo run main.go\n```", "```go\n     1    package main\n     2\n     3    import (\n     4        \"fmt\"\n     5        \"github.com/gorilla/mux\"\n     6        \"html/template\"\n     7        \"log\"\n     8        \"net/http\"\n     9        \"os\"\n    10        \"path/filepath\"\n    11        \"time\"\n    12    )\n    13\n    14    type staticHandler struct {\n    15        staticPath string\n    16        indexPage  string\n    17    }\n    18\n    19    func (h staticHandler) ServeHTTP(w\n                http.ResponseWriter, r *http.Request) {\n    20        path, err := filepath.Abs(r.URL.Path)\n    21        log.Println(r.URL.Path)\n    22        if err != nil {\n    23            http.Error(w, err.Error(),\n                             http.StatusBadRequest)\n    24            return\n    25        }\n    26\n    27        path = filepath.Join(h.staticPath, path)\n    28\n    29        _, err = os.Stat(path)\n    30\n    31        http.FileServer(\n                http.Dir(h.staticPath)).ServeHTTP(w, r)\n    32    }\n    33\n    34    func postHandler(w http.ResponseWriter,\n                           r *http.Request) {\n    35        result := \"Login \"\n    36        r.ParseForm()\n    37\n    38        if validateUser(r.FormValue(\"username\"),\n                              r.FormValue(\"password\")) {\n    39            result = result + \"successfull\"\n    40        } else {\n    41            result = result + \"unsuccessful\"\n    42        }\n    43\n    44        t, err :=\n                template.ParseFiles(\"static/tmpl/msg.xhtml\")\n    45\n    46        if err != nil {\n    47            fmt.Fprintf(w, \"error processing\")\n    48            return\n    49        }\n    50\n    51        tpl := template.Must(t, err)\n    52\n    53        tpl.Execute(w, result)\n    54    }\n    55\n    56    func validateUser(username string,\n                            password string) bool {\n    57        return (username == \"admin\") &&\n                (password == \"admin\")\n    58    }\n    59\n    60    func main() {\n    61        router := mux.NewRouter()\n    62\n    63        router.HandleFunc(\"/login\",\n                postHandler).Methods(\"POST\")\n    64\n    65        spa := staticHandler{staticPath: \"static\",\n                                   indexPage: \"index.xhtml\"}\n    66        router.PathPrefix(\"/\").Handler(spa)\n    67\n    68        srv := &http.Server{\n    69            Handler:      router,\n    70            Addr:         \"127.0.0.1:3333\",\n    71            WriteTimeout: 15 * time.Second,\n    72            ReadTimeout:  15 * time.Second,\n    73        }\n    74\n    75        log.Fatal(srv.ListenAndServe())\n    76    }\n```", "```go\n     1    <!DOCTYPE html>\n     2    <html>\n     3      <head>\n    ...\n    18                <p class=\"text-xs text-gray-50\">{{.}}\n                      </p>\n ...\n    24    </html>\n```", "```go\n     1    package main\n     2\n     3    import (\n     4        \"embed\"\n     5        \"fmt\"\n     6        \"github.com/gorilla/mux\"\n     7        \"html/template\"\n     8        \"io/fs\"\n     9        \"log\"\n    10        \"net/http\"\n    11        \"os\"\n    12        \"path/filepath\"\n    13        \"strings\"\n    14        \"time\"\n    15    )\n    16\n    17    var (\n    18        Version string = strings.TrimSpace(version)\n    19        //go:embed version/version.txt\n    20        version string\n    21\n    22        //go:embed static/*\n    23        staticEmbed embed.FS\n    24\n    25        //go:embed tmpl/*.xhtml\n    26        tmplEmbed embed.FS\n    27    )\n    28\n    29    type staticHandler struct {\n    30        staticPath string\n    31        indexPage  string\n    32    }\n    33\n    34    func (h staticHandler) ServeHTTP(w\n                http.ResponseWriter, r *http.Request) {\n    35        path, err := filepath.Abs(r.URL.Path)\n    36        log.Println(r.URL.Path)\n    37        if err != nil {\n    38            http.Error(w, err.Error(),\n                             http.StatusBadRequest)\n    39            return\n    40        }\n    41\n    42        path = filepath.Join(h.staticPath, path)\n    43\n    44        _, err = os.Stat(path)\n    45\n    46        log.Print(\"using embed mode\")\n    47        fsys, err := fs.Sub(staticEmbed, \"static\")\n    48        if err != nil {\n    49            panic(err)\n    50        }\n    51\n    52        http.FileServer(http.FS(fsys)).ServeHTTP(w,\n                                                       r)\n    53    }\n    54\n    55    //renderFiles renders file and push data (d) into\n          // the templates to be rendered\n    56    func renderFiles(tmpl string, w\n            http.ResponseWriter, d interface{}) {\n    57        t, err := template.ParseFS(tmplEmbed,\n                fmt.Sprintf(\"tmpl/%s.xhtml\", tmpl))\n    58        if err != nil {\n    59            log.Fatal(err)\n    60        }\n    61\n    62        if err := t.Execute(w, d); err != nil {\n    63            log.Fatal(err)\n    64        }\n    65    }\n    66\n    67    func postHandler(w http.ResponseWriter,\n                           r *http.Request) {\n    68        result := \"Login \"\n    69        r.ParseForm()\n    70\n    71        if validateUser(r.FormValue(\"username\"),\n                              r.FormValue(\"password\")) {\n    72            result = result + \"successfull\"\n    73        } else {\n    74            result = result + \"unsuccessful\"\n    75        }\n    76\n    77        renderFiles(\"msg\", w, result)\n    78    }\n    79\n    80    func validateUser(username string,\n                            password string) bool {\n    81        return (username == \"admin\") &&\n                     (password == \"admin\")\n    82    }\n    83\n    84    func main() {\n    85        log.Println(\"Server Version :\", Version)\n    86\n    87        router := mux.NewRouter()\n    88\n    89        router.HandleFunc(\"/login\", postHandler)\n                .Methods(\"POST\")\n    90\n    91        spa := staticHandler{staticPath: \"static\",\n                                   indexPage: \"index.xhtml\"}\n    92        router.PathPrefix(\"/\").Handler(spa)\n    93\n    94        srv := &http.Server{\n    95            Handler:      router,\n    96            Addr:         \"127.0.0.1:3333\",\n    97            WriteTimeout: 15 * time.Second,\n    98            ReadTimeout:  15 * time.Second,\n    99        }\n   100\n   101        log.Fatal(srv.ListenAndServe())\n   102    }\n```", "```go\ngo build -o embed\n```", "```go\n./emded\n```"]