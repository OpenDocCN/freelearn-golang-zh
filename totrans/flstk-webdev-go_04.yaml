- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serving and Embedding HTML Content
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we build on our foundations, it is important that we look at another aspect
    of processing HTTP user requests, routing. Routing is useful as it allows us to
    structure our application to handle different functionality for certain HTTP methods,
    such as a `GET` that can retrieve and a `POST` on the same route that can replace
    the data. This concept is the fundamental principle of designing a REST-based
    application. We’ll end the chapter by looking at how we can use the new `embed`
    directive introduced in Go version 1.16 to bundle our web app as a single self-contained
    executable. This chapter will provide us with the tools to handle user data and
    create the interface for the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have learned how static and dynamic content
    is served by the application. You will also have learned how to embed all the
    different assets (icons, `.xhtml`, `.css`, etc.) that will be served by the web
    application in the application using a single binary. In this chapter, we’ll cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP functions and Gorilla Mux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering static and dynamic content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Go embed to bundle your content
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code for this chapter can be accessed at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP functions and Gorilla Mux
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we look at the **Go standard library**, we can see that a lot of thought
    has gone into the **HTTP library**. You can check out the documentation for the
    Go standard library here: [https://pkg.go.dev/net/http](https://pkg.go.dev/net/http).
    However, we’ll cover the foundations and look at how we can build upon them. It’s
    interesting to Note that the Go standard library covers both client- and server-side
    implementations. We will only be focusing on the parts we require to serve content.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: We will create a simple app that replies with `Hello, World`, as well as look
    at returning `POST` data once we have expanded our routes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World with defaults
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic concepts of creating a server in **Golang** are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see this code in the Git repository under the `library-mux` sub-folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'How this works is we define a `handlerGetHelloWorld` handler function (row
    11) that is passed as a parameter to the `router.HandleFunc` function. The `HandleFunc`
    parameter requires a function parameter that has the following signature: `func(ResponseWriter`,
    `*Request`).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The handler’s job is to take in a request type and a `ResponseWriter` and make
    a decision based on the request; that is, what to write to `ResponseWriter`. In
    our case, the `handlerGetHelloWorld` handler will send the `Hello, World` string
    as a response, using the `fmt.Fprintf(...)` function. The reason why it is possible
    for the response to be sent back is that the `http.ResponseWriter` implements
    the `Write()` function, which is used inside the `fmt.Fprintf(...)` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'We now define the following steps for the main function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a router: this is what our handlers will connect to. We create
    our own router with `NewServeMux` (line 43). We could use the `DefaultServeMux`
    found in the default library, but as you will see at [https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334](https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334),
    it contains a few additional debugging endpoints that we may not want to expose
    publicly. By registering our own, we gain more control and can add the same endpoints
    ourselves if we want them.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we create an instance of our server and bind it to an available port.
    The `Addr` field on the server specifies the address and port to bind to. In our
    example, we are using `9002`. Different operating systems have different restrictions
    on what port can be used. For example, Linux systems only allow the admin or root
    user to run applications that use ports between `1` and `1023`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to attach our router, start the server, and get it to begin
    listening. This is accomplished in line 57\. What we’re doing here is telling
    the router that when it gets any HTTP request for `"/"`, known as the document
    root, it should handle the request by passing it to our handler.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final function, `srv.ListenAndServe()` (line 59), is a blocking function
    that starts our server up and starts listening for incoming requests on the server’s
    defined port. When a valid HTTP request is found, it is passed to the `"/"`, then
    our handler is invoked. We can run our app and visit `http://localhost:9002/`;
    we should be met with the following response from the server:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Hello, World from Go!](img/Figure_4.1_B18295.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Hello, World from Go!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: It’s good to note here that each request is given its own goroutine to execute
    concurrently, and each request’s life cycle is managed by the server so we don’t
    need to do anything explicitly to leverage this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore building different functionalities using
    `GET` and `POST`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Building on the basics with Gorilla Mux
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gorilla Mux, accessible at [https://github.com/gorilla/mux](https://github.com/gorilla/mux),
    is a subproject of the **Gorilla project**. Gorilla Mux is an *HTTP request multiplexer*
    that makes it easy to match different handlers with matching incoming requests.
    Developers gain a lot of benefits from using the library, as it makes writing
    lots of boilerplate code unnecessary. The library provides advanced capabilities
    to match requests based on different criteria, such as schemes and dynamic URLs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The server and router provided as part of Go’s standard library are incredibly
    powerful for “freebies”, but we’re going to look at adding Gorilla Mux to our
    project and some of the benefits it provides.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Uses of the web consist of more than just returning *Hello World*, and generally,
    most web apps accept data provided by users, update the data, and even delete
    the data, and this is possible because the browser accepts a variety of content
    such as images, video, data fields, and plain text. The previous exercise focused
    on what is known as a `GET` method, which is the default sent when you load a
    page in your web browser, but there are many more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library implementation makes it easy to explicitly handle other
    types of methods, such as `GET`, `POST`, `PUT`, `DELETE`, and more, which are
    defined in the HTTP standard. This is typically done in the handler function as
    we can see below:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s look at an example of how we can separate two handlers, `GET` and `POST`,
    and some of the helpers provided by Gorilla Mux:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ve imported the Gorilla Mux library as `mux` and set up two different handlers:
    `handlerGetHelloWorld` (line 24) and `handlerPostEcho` (line 32). `handlerGetHelloWorld`
    is the same handler we defined in the previous example that responds with *Hello,
    World*. Here, thanks to the extended functionality of the router, we’ve specified
    explicitly that the handler can only resolve if the user performs a `GET` method
    on the `"/"` endpoint (line 74).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start the sample by first changing to the `chapter4/gorilla-mux` directory
    and running the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use cURL, which is a standard utility available on Windows (use cmd
    instead of PowerShell) and installed by default on Linux (depending on your Linux
    distribution) and macOS. The tool allows users to make HTTP requests from a terminal
    without using a browser. Use the `curl localhost:9002` command in a separate terminal
    to test whether the server is up and running:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that `GET` works as expected but using `-X DELETE` to tell cURL to
    use the `HTTP DELETE` method results in no content being returned. Under the hood,
    the endpoint is responding with a `405 Method Not Allowed` error message. The
    405 error message reported to the user comes from the library by default.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a second handler (line 75) to take data from a `POST` request. The
    handler for the `POST` method, `handlerPostEcho` (line 32), performs in a similar
    manner to the `GET` request, but we’ve added some additional code to read the
    user-provided data, store it, print it, and then return it unaltered.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how this works using cURL as before:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’re skipping a lot of validation and explicitly checking/handling data formats,
    such as JSON, at this point, but we’ll build towards this in later sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Another benefit of using Gorilla Mux is how easy it makes pattern matching
    in paths. These path variables, or `slugs`, are defined using the `{name}` format
    or `{name:pattern}`. The following table shows different `slugs` with examples:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '| `/``books/{pagetitle}/page/{pageno}` | `/``books/mytitle/page/1, /books/anothertitle/page/100`
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `/``posts/{slug}` | /posts/titlepage/posts/anothertitle |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: 'Pattern can be a type of regular expression. For example, in our sample code
    we added a `handlerSlug` handler (line 15) to perform a simple capture. We can
    use cURL to test this, as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this section, we have learned how to write handlers and use them with Gorilla
    Mux. We have also looked at configuring Gorilla Mux to handle dynamic paths that
    will be processed by handlers. In the next section, we will look at serving content
    to users from our application. The served content will contain static and dynamic
    content.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Rendering static content
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to serve the web pages we have created as
    static content. We will use the standard Go `net/http` package to serve up the
    web pages. All the code and HTML files can be found inside the `static/web` directory
    ([https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the server using the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will see the following message on the screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open your browser and enter `http://localhost:3333` as the URL. You will see
    the login page, as shown in *Figure 4**.2*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The login page](img/Figure_4.2_B18295.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The login page
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the dashboard page, you can use the URL `http://localhost:3333/dashboard.xhtml`.
    You will see like the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 4.3 – The dashboard page](img/Figure_4.3_B18295.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The dashboard page
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a quick look at the code that serves up the static pages:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As can be seen, this is a simple HTTP server that uses the `http.FileServer(..)`
    Go standard library function (shown in line 9). The function is called by passing
    in the `(./static)` parameter to the directory that we want to serve (line 9).
    The example code can be found inside the `chapter4/static/web/static` folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Rendering dynamic content
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand how to serve static content using the `net/http` package,
    let’s take a look at adding some dynamic content using Gorilla Mux found here:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic).
    Execute the server using the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Launch your browser and enter `http://localhost:3333` as the address; you will
    see a login screen similar to the static content. Perform the following steps
    on the login screen:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Enter any combination of username and password on the login screen.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Login` button.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get a **Login unsuccessful** message, as shown in *Figure 4**.4*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 4.4 – Message screen after login](img/Figure_4.4_B18295.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Message screen after login
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: We have introduced dynamic content for our login operation, which means the
    application will serve pages based on certain conditions, in this case, the successful
    validation of the username/password combination. To achieve a successful validation,
    enter `admin/admin` as the username/password combination, as this exists in the
    database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the code a bit further to understand how it works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ServeHTTP` function (line 19) serves the content specified by the directory
    defined in the `staticHandler` struct (line 65), which points to the `static`
    directory with the index page showing as `index.xhtml`. The handler configuration
    is registered using the Gorilla Mux attached to the `/` path prefix (line 66).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The next part is the code that takes care of the registration of the `/login`
    endpoint (line 63). The `postHandler` function (line 34) extracts and validates
    the username and password information passed from the request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The web page contains two input elements, the username and password, which are
    sent by the browser when the user clicks on the `ParseForm()` function (line 36)
    and then extracts the value passed by referencing the field names `username` and
    `password` (line 38), which corresponds to the name of the HTML element specified
    inside the file in `chapter04/dynamic/static/index.xhtml`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: On completing the validation process, the app then uses the Go `html/template`
    package (line 44) to parse another HTML file (`static/tmpl/msg.xhtml`). The app
    will parse the HTML file and will insert all the relevant information to be included
    as part of the HTML page using the `template.Must` function (line 51).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'This `msg.xhtml` file contains a `{{.}}` placeholder string that is understood
    by the `html/template` package (line 18):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this section, we have learned how to render dynamic content. In the next
    section, we will look at bundling both our static and dynamic content to allow
    us to run the application as a single file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Using Go embed to bundle your content
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to package applications into a single
    binary. Packaging everything the application needs into a single binary makes
    it easier to deploy the application anywhere in the cloud. We are going to use
    the `embed` package that is provided by the *Go standard library*. The following
    link provides further detail on the different functions available inside the embed
    package: [https://pkg.go.dev/embed](https://pkg.go.dev/embed).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The embed package is only available in Go version 1.16 and upwards.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides a simple example of using the embed package in
    three different ways – to embed a specific file, embed the full contents of a
    folder, and embed a specific file type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The source code resides inside the `chapter4/embed` folder. The code uses the
    `//go:embed` directive (lines 19, 22, and 25). This tells the compiler that the
    `version string` (line 20) will get the content from `version/version.txt`, which
    contains the version information that we want to display to the user.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: We also declare the `//go:embed` directive telling the compiler that we want
    to include everything inside the `static/` (line 22) and `tmpl/` (line 25) folders.
    During the compilation process, the compiler detects the preceding directives
    and automatically includes all the different files into the binary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The `tmpl` directory contains the template that will render dynamic content,
    and since we have embedded it into the binary, we need to use a different way
    to render it (line 56). The new `renderFiles` function uses the `template.ParseFS`
    function (line 57), which renders the template declared in the `tmplEmbed` variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The `renderFiles` function is called from the `postHandler` function (line 77),
    passing in the template name and other parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this time when building our application, the final executable file contains
    the different files (HTML, CSS, etc.) in a single file. We can now compile the
    application, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will generate an executable file – for example, in Linux, it will be called
    `embed` and in Windows, it will be called `embed.exe`. Next, run the application
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open your browser and go to `http://localhost:3333/`. It should look the same
    as before, except that everything is being retrieved via `embed.FS`. You now have
    a fully embedded application that can be deployed as a single binary in the cloud.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pretty big chapter served as our first look at interacting with user-provided
    data and handling web requests. We’ve seen how we can add RESTful endpoints using
    the Go standard library and have learned how we can use the utility functions
    of Gorilla Mux to quickly add more power and functionality to our application.
    We’ve also explored the different ways we can handle requests. In one method,
    we can now utilize Go’s `html/template` library to dynamically create content
    and package it as a directory read from disk. Alternatively, we can use the new
    Go `e``mbed` directive to give us a single binary that packages up all our assets
    and makes for simple deployments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这章内容相当丰富，它作为我们首次了解与用户提供的数据进行交互和处理Web请求的起点。我们看到了如何使用Go标准库添加RESTful端点，并学习了如何利用Gorilla
    Mux的实用函数快速为我们的应用程序添加更多功能和强大功能。我们还探索了处理请求的不同方法。在一种方法中，我们现在可以利用Go的`html/template`库动态创建内容并将其打包为从磁盘读取的目录。或者，我们可以使用新的Go
    `embed`指令来获得一个包含所有资源的单个二进制文件，从而实现简单的部署。
- en: In the next chapter, we will look at adding middleware to help process the request
    pipeline and introduce security to ensure that content can be accessed securely.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何添加中间件以帮助处理请求管道，并引入安全机制以确保内容可以安全访问。
