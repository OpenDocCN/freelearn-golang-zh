["```go\nCREATE TABLE gowebapp.users (\nUser_ID        BIGSERIAL PRIMARY KEY,\nUser_Name      text NOT NULL,\nPassword_Hash text NOT NULL,\nName           text NOT NULL,\nConfig         JSONB DEFAULT '{}'::JSONB NOT NULL,\nCreated_At     TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\nIs_Enabled     BOOLEAN DEFAULT TRUE NOT NULL\n```", "```go\nmake generate\n```", "```go\n...\nfunc (q *Queries) GetUserByName(ctx context.Context, userName string) (GowebappUser, error) {\n  row := q.db.QueryRowContext(ctx, getUserByName, userName)\n  var i GowebappUser\n  err := row.Scan(\n     &i.UserID,\n     &i.UserName,\n     &i.PasswordHash,\n     &i.Name,\n     &i.Config,\n     &i.CreatedAt,\n     &i.IsEnabled,\n  )\n  return i, err\n}\n...\n```", "```go\nconst getUserByName = `-- name: GetUserByName :one\nSELECT user_id, user_name, pass_word_hash, name, config, created_at, is_enabled\nFROM gowebapp.users\nWHERE user_name = $1\n`\n```", "```go\nfunc createUserDb(ctx context.Context) {\n  //has the user been created\n  u, _ := dbQuery.GetUserByName(ctx, \"user@user\")\n  if u.UserName == \"user@user\" {\n     log.Println(\"user@user exist...\")\n     return\n  }\n  log.Println(\"Creating user@user...\")\n  hashPwd, _ := pkg.HashPassword(\"password\")\n  _, err := dbQuery.CreateUsers(ctx,\n                                chapter5.CreateUsersParams{\n     UserName:     \"user@user\",\n     PassWordHash: hashPwd,\n     Name:         \"Dummy user\",\n  })\n...\n}\n```", "```go\nhashPwd, _ := pkg.HashPassword(\"password\")\n```", "```go\nfunc HashPassword(password string) (string, error) {\n  bytes, err := \n    bcrypt.GenerateFromPassword([]byte(password), 14)\n  return string(bytes), err\n}\n```", "```go\nfunc validateUser(username string, password string) bool {\n  ...\n  u, _ := dbQuery.GetUserByName(ctx, username)\n  ...\n  return pkg.CheckPasswordHash(password, u.PassWordHash)\n}\n```", "```go\nfunc CheckPasswordHash(password, hash string) bool {\n  err := bcrypt.CompareHashAndPassword([]byte(hash), \n                                       []byte(password))\nreturn err == nil\n}\n```", "```go\nfunc basicMiddleware(h http.Handler) http.Handler {\n   return http.HandlerFunc(func(wr http.ResponseWriter,\n                                   req *http.Request) {\n       log.Println(\"Middleware called on\", req.URL.Path)\n       // do stuff\n       h.ServeHTTP(wr, req)\n   })\n}\n```", "```go\nfunc (*mux.Router).Use(mwf ...mux.MiddlewareFunc)\n```", "```go\nfunc main() {\n    ...\n    // Use our basicMiddleware\n    router.Use(basicMiddleware)\n    ...\n}\n```", "```go\ngo build && ./chapter5 \n2022/01/24 19:51:56 Server Version : 0.0.2\n2022/01/24 19:51:56 user@user exists...\n2022/01/24 19:52:02 Middleware called on /app\n2022/01/24 19:52:02 Middleware called on /css/minified.css\n…\n```", "```go\n//sessionValid check whether the session is a valid session\nfunc sessionValid(w http.ResponseWriter, r *http.Request) bool {\n  session, _ := store.Get(r, \"session_token\")\n  return !session.IsNew\n}\n```", "```go\nfunc hasBeenAuthenticated(w http.ResponseWriter, r *http.Request) bool {\n  session, _ := store.Get(r, \"session_token\")\n  a, _ := session.Values[\"authenticated\"]\n  ...\n}\n```", "```go\n//if it does have a valid session make sure it has been //authenticated\nif hasBeenAuthenticated(w, r) {\n  ...\n}\n//otherwise it will need to be redirected to /login\n...\nhttp.Redirect(w, r, \"/login\", 307)\n```", "```go\nfunc storeAuthenticated(w http.ResponseWriter, r *http.Request, v bool) {\n  session, _ := store.Get(r, \"session_token\")\n  session.Values[\"authenticated\"] = v\n  err := session.Save(r, w)\n  ...\n}\n```", "```go\nmake redis\n```", "```go\ndocker run -v $(PWD)/redisdata:/data --name local-redis -p 6379:6379 -d redis --loglevel verbose\n```", "```go\nmake teardown_recreate\n```", "```go\nfunc initRedis() {\n  var err error\n  client = redis.NewClient(&redis.Options{\n     Addr: \"localhost:6379\",\n  })\n  store, err = rstore.NewRedisStore(context.Background(), \n                                    client)\n  if err != nil {\n     log.Fatal(\"failed to create redis store: \", err)\n  }\n  store.KeyPrefix(\"session_token\")\n}\n```", "```go\nfunc logoutHandler(w http.ResponseWriter, r *http.Request) {\n  if hasBeenAuthenticated(w, r) {\n     session, _ := store.Get(r, \"session_token\")\n     session.Options.MaxAge = -1\n     err := session.Save(r, w)\n     if err != nil {\n        log.Println(\"failed to delete session\", err)\n}\n  }\n  http.Redirect(w, r, \"/login\", 307)\n}\n```"]