- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing the Backend and Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we learned how to build our database, run our web application
    as a server, and serve dynamic content. In this chapter, we will discuss security
    – in particular, we will look at securing the web app. Security is a vast topic
    so for this chapter, we will just look at the security aspects that are relevant
    to our application. Another topic that we will look at is middleware and using
    it as part of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is software that is introduced into an application to provide generic
    functionality that is used for incoming and outgoing traffic in our application.
    Middleware makes it easy to centralize features that are used across different
    parts of our applications, and this will be discussed more in upcoming sections
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding cookies and sessions with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon completing this chapter, you will have learned how to set up a user database
    and add authentication to the app. We will also learn about middleware and how
    to add it to an existing app. Lastly, you will learn about cookies, storing information
    in sessions, and using Redis as persistence storage for these sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Becoming-a-Full-Stack-Go-Developer/tree/main/Chapter05](https://github.com/PacktPublishing/Becoming-a-Full-Stack-Go-Developer/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the application requires some consideration in terms of designing the
    application, and one of the key pieces that needs to be thought of ahead of time
    is security. There are many facets of security but in this section of our application,
    we will look at authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is the process of validating that a user is who they claim to
    be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add authentication to our app, we will need to store the user information
    in the database first. The user information will be used to authenticate the user
    before using the application. The database user table can be found inside the
    `db/schema.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table outlines the data types that are used for the user table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `BIGSERIAL` | An auto-incrementing data type that is normally used as a primary
    key. |'
  prefs: []
  type: TYPE_TB
- en: '| `TEXT` | A variable-length character string. |'
  prefs: []
  type: TYPE_TB
- en: '| `JSONB` | The JSON binary data type is suitable for JSON data. The database
    provides this data type to make it easier to index, parse, and query JSON data
    directly. |'
  prefs: []
  type: TYPE_TB
- en: '| `TIMESTAMP` | A date and time data type. |'
  prefs: []
  type: TYPE_TB
- en: '| `BOOLEAN` | A logical data type that contains true or false. |'
  prefs: []
  type: TYPE_TB
- en: The authentication will be performed by checking the `User_Name` and `Pass_Word_Hash`
    fields. One thing to note – the `Pass_Word_Hash` field contains an encrypted password,
    and we will look further into encrypting the password a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in [*Chapter 1*](B18295_01.xhtml#_idTextAnchor016), *Building
    the Database and Model*, we are using sqlc to generate the Go code that will talk
    to the database. To generate the Go code, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that will read the user information will be stored under the `gen/query.sql_gen.go`
    file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetUserByName` function queries the database by calling the `QueryRowContext()`
    function, passing in the query that we want to use, which is defined as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The query uses the `WHERE` clause and expects one parameter, which is the `user_name`
    field. This is populated by passing the `userName` parameter into the `QueryRowContext()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at how to create a dummy user when we start the application in
    the next section. A dummy user is a user that is normally used for testing purposes
    – in our case, we want to create a dummy user to test the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our dummy user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our database is empty so we will need to populate it with a dummy user and
    in this section, we will look at how to create one. We will add code to create
    a dummy user when the application starts up. The following function inside `main.go`
    creates the dummy user, and this user will be used to log in to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the application starts up it will first check whether an existing test
    user exists and if none exists, it will automatically create one. This is put
    inside the application to make it easier for us to test the application. The `createUserDb()`
    function uses the `CreateUsers()` generated sqlc function to create the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things you will notice is the password is created by the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The password is passed to a `HashPassword` function that will return a hashed
    version of the clear text password.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HashPassword` function uses the Go `crypto` or `bcrypt` standard libraries
    that provide a function to return a hash of a plain string as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The hash generated from the string password will be different whenever the `bcrypt.GenerateFromPassword`
    function is called. The `GenerateFromPassword()` function uses the standard cryptography
    library to generate the hash value of the password.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography is the practice of ensuring text messages are converted into a
    form that is not easy to read or deconstruct. This provides data security to make
    it hard to deconstruct what the data is all about. Go provides a standard library
    that provides cryptography functions, which is available in the `golang.org/x/crypto`
    package. The `crypto` library provides a number of cryptography functions that
    you can choose from – it all depends on what you need for your application. In
    our example, we use `bcrypt`, which is a password-hashing function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added a function to create a dummy user in the database, in
    the next section, we will look at how to authenticate with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'User authentication is simple, as the application will use the function generated
    by sqlc, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `GetUserByName` function is used, with the username passed as a parameter
    to obtain the user information. Once that has been retrieved successfully, it
    will check whether the password is correct by calling `CheckPasswordHash`.
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckPasswordHash` function uses the same `crypto` or `bcrypt` package
    and it calls the `CompareHashAndPassword` function, which will compare the hashed
    password with the password sent by the client. The function returns `true` if
    the password matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `validateUser` function will return `true` if the username and password
    combination exists in the database and is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Start your application and navigate your web browser to `http://127.0.0.1:3333/`
    and you should see a login prompt. Try logging in with incorrect credentials before
    entering `user@user / password` – you should now be sent to the successful login
    screen! Congratulations – you successfully authenticated!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at middleware, what it is, and how to add
    it to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware is a piece of code that is configured as an HTTP handler. The middleware
    will pre-process and post-process the request, and it sits between the main Go
    server and the actual HTTP handlers that have been declared.
  prefs: []
  type: TYPE_NORMAL
- en: Adding middleware as part of our application helps take care of tasks that are
    outside of the main application features. Middleware can take care of authentication,
    logging, and rate limiting, among other things. In the next section, we will look
    at adding a simple logging middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Basic middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a simple basic middleware to our application.
    The basic middleware is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Gorilla Mux makes it incredibly easy to use our middleware. This is done by
    exposing a function on the router called `Use()`, which is implemented with a
    variadic number of parameters that can be used to stack multiple pieces of middleware
    to be executed in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows how we implement the `Use()` function to register
    the middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`mux.MiddwareFunc` is simply a type alias for `func(http.Handler) http.Handler`
    so that anything that meets that interface can work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see our function in action, we simply call `router.Use()`, pass in our middleware,
    navigate to our web app, and there we can see that it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be wondering why you can see it being called multiple times with different
    paths – the reason is that when requesting our app, it’s performing a number of
    `GET` requests for the numerous hosted resources. Each of these is passing through
    our middleware as shown in *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Request passing through middleware](img/Figure_5.01_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Request passing through middleware
  prefs: []
  type: TYPE_NORMAL
- en: The `handlers` library – available at [https://github.com/gorilla/handlers](https://github.com/gorilla/handlers)
    – contains many other useful middleware methods and we’ll be using some of them
    later, including the `handlers.CORS()` middleware to allow us to handle **Cross-Origin
    Resource Sharing** (**CORS**). We will look at CORS and using this middleware
    in more detail in [*Chapter 9*](B18295_09.xhtml#_idTextAnchor184), *Tailwind,
    Middleware,* *and CORS.*
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about middleware, the different functionality that
    it can provide, and how to add it to an app. In the next section, we will look
    at session handling and using cookies to track user information as they use the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding cookies and sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to take a look at how we are going to keep track
    of the users when using our application. We are going to take a look at session
    management and how it can help our application understand whether a user is allowed
    to access our application. We are also going to take a look at cookies, which
    are a session management tool that we are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: The session management discussed in this chapter is part of the Gorilla project,
    which can be found at [https://github.com/gorilla/sessions](https://github.com/gorilla/sessions).
  prefs: []
  type: TYPE_NORMAL
- en: Cookies and session handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to look at session handling and how to use it
    to store information relevant to a particular user. The web as we know is stateless
    in nature, which means that requests are not actually tied to any other previous
    requests. This makes it hard to know which requests belong to which user. Hence,
    the need arises to keep track of this and store information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A web session is used to facilitate interaction between users and the different
    services that are used in the sequence of requests and responses. The session
    is unique to a particular user.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions are stored in memory, with each session belonging to a particular user.
    Session information will be lost if the application stops running or when the
    application decides to remove the session information. There are different ways
    to store session information permanently in storage to be used at a future time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.2* shows the high-level flow of how a session is created and used
    for each incoming request. New sessions are created when one does not exist and
    once one is made available, the application can use it to store relevant user
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Session check flow](img/Figure_5.02_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Session check flow
  prefs: []
  type: TYPE_NORMAL
- en: We know that a session is used to store user-specific information – the question
    is how the application knows which session to use for which user. The answer is
    a key that is sent back and forth between the application and the browser. This
    key is called a session key, which is added to the cookie header as shown in *Figure
    5**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Cookie containing a session token](img/Figure_5.03_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Cookie containing a session token
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 5**.3*, the cookie with the `session_token` label contains
    the key that will be sent back to the server to identify the user stored in the
    session. *Figure 5**.3* shows the developer console of the browser. For Firefox,
    you can open it using the **Tools** > **Web Developer** > **Web Developer Tool**
    menu, and if you are using Chrome, you can access it using *Ctrl* + *Shift* +
    *J*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the `sessionValid` function, which checks whether
    the incoming request contains a valid `session_token` key. The `store.Get` function
    will automatically create a new one if an existing session is not available for
    the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the application finds a session for the user, it will check the authentication
    status of the user as shown here. The session information is stored as a map,
    and the map type stores information as key and value, so in our case, we are checking
    whether the session contains the `authenticated` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a failure to obtain the `authenticated` key, the application will
    automatically redirect the request to display the login page as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have learned about sessions and how we can use them to check whether a user
    has been authenticated. We will explore this further.
  prefs: []
  type: TYPE_NORMAL
- en: Storing session information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned about sessions and cookie handling. In this
    section, we will look at how to store session information pertaining to the user.
    The information stored inside the session is stored in the server memory, which
    means that this data will be temporarily available as long as the server is still
    running. Once the server stops running, all the data stored in memory will not
    available anymore. This is why we will look at persisting the data in a separate
    storage system in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample application, we are storing information on whether the user has
    been authenticated successfully. Users are allowed to access other parts of the
    application only when they have been successfully authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the sample application and open your browser in private mode (Firefox)
    or incognito mode (Chrome) and type `http://localhost:3333/dashboard.xhtml` as
    the address. The application will redirect you to the login page because the session
    does not exist. The operation to check for the existence of the `authenticated`
    key is performed inside the `storeAuthenticated` function shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `session.Save` function saves the session into memory after creating the
    `authenticated` key with a new value pass as part of the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis for a session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous section, the sessions are stored in memory. In
    this section, we will look at storing the session information permanently using
    Redis. The code samples for this section can be found at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter05-redis](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter05-redis).
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we want to use Redis is because of its simplicity in terms of
    data storage, only containing key values. It also can be configured for both in-memory
    and permanent external storage. For our application, we will need to configure
    `redis` to store information on the disk to make it permanent. Execute the following
    `make` command to run `redis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the full Docker command used to run `redis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The command runs `redis` using Docker and specifies the `redisdata` local directory
    as the location of the permanent file storage for the data. To run the sample
    application, make sure you also run `postgres` using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once both `redis` and `postgres` are up and running, you can now run the sample
    app and use the web application. The following code snippet shows the `initRedis()`
    function, which takes care of initializing Redis. The function uses two different
    packages, which you can find at [https://github.com/redis/go-redis](https://github.com/redis/go-redis)
    and [https://github.com/rbcervilla/redisstore](https://github.com/rbcervilla/redisstore).
    The `go-redis/redis` package contains the driver and API to communicate with Redis
    while `rbcervilla/redisstore` contains a simple API to read, write, and delete
    data from Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once the initialization has been completed, the `store` variable will be used
    to write data to and read it from Redis. Inside the `gorilla` library, the `sessions`
    package automatically uses the configured `client` object to handle all writing
    and reading of information to and from `redis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new additional handler is added to allow the user to log out from the application
    as shown in the handler snippet here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The logout operation is done by setting the `Options.MaxAge` field for a session.
    This indicates to the library that the next time the same `session_token` is passed
    to the server, it is considered an invalid/expired session and it will redirect
    to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about a few new things that can help our application
    better. We learned how to add an authentication layer to our application to secure
    it, which helps protect our application from being accessed anonymously. We also
    looked at adding middleware to our application and showed how easy it was to add
    different middleware to our application without changing much code.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at session handling and learned how to use it to track user
    information and a user’s journey with our application. Since session handling
    is not stored permanently, we looked at using the `redis` data store to store
    the user session information, which allows the application to remember user information
    anytime the application is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at writing code that will process information
    back and forth between the browser and our application. We will look at building
    a REST API that will be used to perform different operations on our data.
  prefs: []
  type: TYPE_NORMAL
