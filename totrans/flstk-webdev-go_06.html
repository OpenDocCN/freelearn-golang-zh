<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer046">
<h1 class="chapter-number" id="_idParaDest-74"><a id="_idTextAnchor093"/>6</h1>
<h1 id="_idParaDest-75"><a id="_idTextAnchor094"/>Moving to API-First</h1>
<p>In the previous chapters, we learned about building databases, adding monitoring to applications, using middleware, and session handling. In this chapter, we will learn about building an API in our application, and why an API is an important part of writing applications as it forms the interface between the frontend and the backend. Building the API first is important, as it forms the bridge for data exchanges and can be thought of as a contract between the frontend and the backend. Having the proper and correct form of contract is important before building <span class="No-Break">an application.</span></p>
<p>We will also explore the concepts of REST and JSON to get a better understanding of what they are and how they are used throughout <span class="No-Break">our application.</span></p>
<p>Upon completion of this chapter, you will know how to design a REST API using Gorilla Mux and also how to process requests to perform operations by converting data to and from JSON. You will also learn how to take care of <span class="No-Break">error handling.</span></p>
<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>Structuring <span class="No-Break">API-first applications</span></li>
<li>Exposing <span class="No-Break">REST APIs</span></li>
<li>Converting data to and from JSON <span class="No-Break">using Go</span></li>
<li>Error handling <span class="No-Break">using JSON</span></li>
</ul>
<h1 id="_idParaDest-76"><a id="_idTextAnchor095"/>Technical requirements</h1>
<p>All the source code explained in this chapter can be checked out <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor096"/>Structuring an application</h1>
<p>Go <a id="_idIndexMarker217"/>applications are structured inside directories, with each directory containing Go source code that means something for those applications. There are many ways to structure your Go application in different kinds of directories; however, one thing that you have to remember is to always give a directory a name that will be easy for others to understand. As an application grows with time, the chosen directory structure and where code is placed has a big impact on how easily other developers in your team will be able to work with the <span class="No-Break">code base.</span><a id="_idTextAnchor097"/></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor098"/>Defining packages</h2>
<p>Up to<a id="_idIndexMarker218"/> this point, we’ve kept things fairly simple, but we’re going to up our game a little and move to a fairly common layout. We won’t use the term “standard layout,” as there’s no such thing in Go, but we’ll look at how we’re structuring our new project and talk about how we reason them through to best structure our Go application for clarity and understanding, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 6.1: Chapter 6 package structure" height="531" src="image/Figure_6.01_B18295.jpg" width="237"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Chapter 6 package structure</p>
<p>Let’s examine some of these files in a bit more detail to understand <span class="No-Break">these decisions.</span></p>
<h3>generate.go</h3>
<p>If you take a look<a id="_idIndexMarker219"/> at this file, it can appear confusing at first, but we’ve used a neat Go feature called <strong class="source-inline">go generate</strong> that <span class="No-Break">can help:</span></p>
<pre class="console">
package main
//go:generate echo Generating SQL Schemas
//go:generate sqlc generate</pre>
<p>At a glance, it looks like a comment because comments in Go start with the <strong class="source-inline">//</strong> character. However, this one starts with the word <strong class="source-inline">go:generate</strong>. This is called the <strong class="source-inline">go:generate</strong> directive; what this means is that when <strong class="source-inline">go generate</strong> is executed (as shown in the following code block), it will execute the command specified – in our example, it will print the text <strong class="source-inline">Generating SQL Schemas</strong> and execute the sqlc command-line tool (<span class="No-Break"><strong class="source-inline">sqlc generate</strong></span><span class="No-Break">):</span></p>
<pre class="console">
$ go generate
Generating SQL Schemas
$</pre>
<p>This is a useful technique to easily generate your build prerequisites; this can be done as part of your workflow, performed by <strong class="source-inline">Makefile</strong>, or done by your CI/CD. <strong class="source-inline">Makefile</strong> is a file containing sets of rules to determine which parts of a program need to be compiled and what command to use to compile the source code. It can be used to compile all kinds of programming language <span class="No-Break">source code.</span></p>
<p>All we’re doing in our <strong class="source-inline">generate.go</strong> file is simply ensuring that we generate the latest schema files for sqlc. We could add mock generation, more informational messages, or generate archives or any manner of other useful things that might make up <span class="No-Break">our build.</span></p>
<h3>handlers.go</h3>
<p>This name comes purely <a id="_idIndexMarker220"/>from our experience in using the same pattern of naming files after the functionality defined therein. Our <strong class="source-inline">handlers</strong> file provides a single place (for now) where our HTTP handlers can be found. Ours contains login, logout, and all kinds of handlers and their request and response types needed to interact with our app. We don’t do anything outside of our handlers in this file; all connectivity and addition of middleware are performed as part of <strong class="source-inline">main.go</strong> to ensure the separation <span class="No-Break">of concerns.</span></p>
<h3>internal/</h3>
<p>In the “old days” of Go – back<a id="_idIndexMarker221"/> before 1.0 was released – the Go source code featured a directory called <strong class="source-inline">pkg</strong>, which was for internal-only code and became an idiom for the community, as well as a way to mark subfolders/packages as internal to a <span class="No-Break">particular project.</span></p>
<p>The <strong class="source-inline">pkg</strong> folder was eventually removed from the Go project but it left a bit of an unfulfilled need, and to that end, the <strong class="source-inline">internal</strong> directory was created. <strong class="source-inline">internal</strong> is a special directory in so much as it is recognized by the Go tool itself, which allows an author to restrict importing the package unless they share a common ancestor. To demonstrate this, we’re storing our API package here as well as <strong class="source-inline">env.go</strong> (used to simplify a way to read environmental variables in the app) and <strong class="source-inline">auth.go</strong> (our specific way to handle authorization) – the <strong class="source-inline">auth.go</strong> or <strong class="source-inline">handlers.go</strong> files in particular are good options to prevent others from importing, while others like the <strong class="source-inline">env</strong> package are more general and can be moved up <span class="No-Break">and out.</span></p>
<h3>migrations, queries, and store</h3>
<p>Using <strong class="source-inline">sqlc</strong> and <strong class="source-inline">golang-migrate</strong>, we’ve given <a id="_idIndexMarker222"/>ourselves a leg up in making things easy to organize and<a id="_idIndexMarker223"/> increasing our ability to rapidly create our apps. We’re just separating <a id="_idIndexMarker224"/>things to make life a bit easier, as shown in the <strong class="source-inline">sqlc.yaml</strong> configuration <span class="No-Break">file here:</span></p>
<pre class="console">
path: store/
schema: migrations/
queries: queries/</pre>
<p>To see how this works in practice, take a look at the <strong class="source-inline">readme</strong> file provided in <span class="No-Break">the repo.</span></p>
<p>We have looked at structuring applications by separating different parts of an application into different folders. Grouping source code into different folders allows easier navigation of the application when doing maintenance and development. In the next section, we will explore building an API that will be used to <span class="No-Break">consume<a id="_idTextAnchor099"/> data.</span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor100"/>Exposing our REST API</h1>
<p>Let’s understand a few concepts that we are going to use in <span class="No-Break">this sec<a id="_idTextAnchor101"/>tion:</span></p>
<ul>
<li>REST – <strong class="bold">REST</strong> stands for <strong class="bold">Representational State Transfer</strong>. It is a widely accepted set of guidelines for <a id="_idIndexMarker225"/>creating web services. REST is independent of the protocol used, but most of the time, it is tied to the HTTP protocol that normal web browsers use. Some of the design principles behind REST include <span class="No-Break">the fol<a id="_idTextAnchor102"/>lowing:</span><ul><li>A resource has an identifier – for example, the URI for a particular order might <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">https://what-ever-shop.com/or<a id="_idTextAnchor103"/>ders/1</strong></span><span class="No-Break">.</span></li><li>Uses JSON as the exchange format – for example, a <strong class="source-inline">GET</strong> request to <strong class="source-inline">https://what-ever-shop.com/orders/1</strong> might return the following <span class="No-Break">response body:</span><pre class="source-code">
<strong class="bold">{"orderId":1,"orderValue":0.99,"productId":100,"quanti<a id="_idTextAnchor104"/>ty":10}</strong></pre></li><li>REST APIs built on HTTP are called using standard HTTP verbs to perform operations on resources. The most common operations are <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, <span class="No-Break">and <a id="_idTextAnchor105"/></span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">.</span></li></ul></li>
<li>API – <strong class="bold">API</strong> is an <a id="_idIndexMarker226"/>acronym for <strong class="bold">Application Programming Interface</strong>, a software intermediary that allows two applications to talk to each other. For example, if you are using the Google search engine, you are using an API that <span class="No-Break">it p<a id="_idTextAnchor106"/>rovides.</span></li>
</ul>
<p>Combining both the preceding concepts, we come up with <a id="_idIndexMarker227"/>a REST API, and the software that we are building is called a <a id="_idIndexMarker228"/>RESTful API, which means that the API that we provide can be accessed <span class="No-Break">u<a id="_idTextAnchor107"/>sing REST.</span></p>
<p>In this section, we will look at exposing our RESTful handlers, a pattern for an API server, and discuss our new <strong class="source-inline">middleware.Main</strong> session and the <span class="No-Break">API package.</span></p>
<p>We’ve done some rework to prepare our new API-first project. We’ve abstracted the API server into its own package in <strong class="source-inline">internal/api</strong>. Its responsibility is to provide a server that accepts a port to bind on and the ability to start the server, stop it, and add routes with <span class="No-Break">optional middleware.</span></p>
<p>The following is a snippet (from <strong class="source-inline">chapter06/main.go</strong>) of our new main function showing <span class="No-Break">this approach:</span></p>
<pre class="source-code">
     1    func main() {
     2        ...
     3        server := api.NewServer(internal.GetAsInt(
                                      "SERVER_PORT", 9002))
     4
     5        server.MustStart()
     6        defer server.Stop()
     7
     8        defaultMiddleware := []mux.MiddlewareFunc{
     9            api.JSONMiddleware,
    10            api.CORSMiddleware(internal.GetAsSlice(
                      "CORS_WHITELIST",
    11                []string{
    12                    "http://localhost:9000",
    13                    "http://0.0.0.0:9000",
    14                }, ","),
    15            ),
    16        }
    17
    18        // Handlers
    19        server.AddRoute("/login", handleLogin(db),
                http.MethodPost, defaultMiddleware...)
    20        server.AddRoute("/logout", handleLogout(),
                http.MethodGet, defaultMiddleware...)
    21
    22        // Our session protected middleware
    23        protectedMiddleware :=
                append(defaultMiddleware,
                       validCookieMiddleware(db))
    24        server.AddRoute("/checkSecret",
                 checkSecret(db), http.MethodGet,
                 protectedMiddleware...)
    25
    26        ...
    27    }</pre>
<p>Pay special attention to how we’ve created our default middleware, which is declared in the <strong class="source-inline">defaultMiddleware</strong> variable (line 8). For our protected routes, we are appending the <strong class="source-inline">protectedMiddleware</strong> variable (line 23) into the existing <strong class="source-inline">defaultMiddleware</strong> variable. Our custom session verification middleware is added to the middleware chain (line 23) to ensure a valid login before allowing access to our <span class="No-Break">other handlers.</span></p>
<p>We’ve also pushed two types of middleware into this <strong class="source-inline">api</strong> package, <strong class="source-inline">JSONMiddleware</strong> (line 9) and <strong class="source-inline">CORSMiddleware</strong> (line 10), which takes a slice of strings for a <strong class="bold">CORS</strong> allow-list, which we’ll look at in more depth in the <span class="No-Break">nex<a id="_idTextAnchor108"/>t section.</span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor109"/>Cross-Origin Resource Sharing (CORS)</h2>
<p>Anyone working with API-first applications will encounter the<a id="_idIndexMarker229"/> concept of CORS. It’s a security feature of modern browsers to ensure that web apps on one domain have permission to request APIs on a different origin. The way it does this is by performing what is called a preflight request, which is basically just a normal <strong class="source-inline">OPTIONS</strong> request. This returns information, telling our app that it is allowed to talk to the API endpoint, along with the methods it supports and the origins. Origins contain the same domain sent by the client in the <strong class="source-inline">origin</strong> header, or it could be a wildcard (<strong class="source-inline">*</strong>), which means that all origins are allowed, as explained in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
<p class="IMG---Figure"><img alt="Figure 6.2: CORS flow (sourced from Mozilla MDN and licensed under Creative Commons)" height="478" src="image/Figure_6.02_B18295.png" width="456"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: CORS flow (sourced from Mozilla MDN and licensed under Creative Commons)</p>
<p>Our middleware wraps the Gorilla Mux <a id="_idIndexMarker230"/>CORS middleware to make it a little easier for us to provide our CORS whitelisted domains (the domains we’re happy to respond to requests on) and all the HTTP methods for those <span class="No-Break">sam<a id="_idTextAnchor110"/>e domains.</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor111"/>JSON middleware</h2>
<p>Another piece of middleware that is functionally needed to enforce our requirements for an API-powered application is<a id="_idIndexMarker231"/> JSON middleware. <strong class="bold">JSON</strong>, short for <strong class="bold">Javascript Object Notation</strong>, is an open standard file format that is used to represent data in a <a id="_idIndexMarker232"/>key-value pair <span class="No-Break">and arrays.</span></p>
<p>JSON middleware <a id="_idIndexMarker233"/>uses HTTP headers to check what kind of data is being sent in a request. It checks the <strong class="source-inline">Content-Type</strong> header key, which should contain the <span class="No-Break"><strong class="source-inline">application/json</strong></span><span class="No-Break"> value.</span></p>
<p>If it cannot find the value that it requires, then the middleware will check the value of the <strong class="source-inline">Accept</strong> header to see whether it can find the <strong class="source-inline">application/json</strong> value. Once the check is done and it cannot find the value that it is looking for, it replies that it’s not a suitable content type for us to work with. We also add that header to our <strong class="source-inline">ResponseWriter</strong> so that we can ensure we’re telling the consumer we only support JSON and send that back <span class="No-Break">to them.</span></p>
<p>The following code snippet shows the <span class="No-Break">JSON middleware:</span></p>
<pre class="source-code">
     1    func JSONMiddleware(next http.Handler)
            http.Handler {
     2        return http.HandlerFunc(func(wr
                http.ResponseWriter, req *http.Request) {
     3            contentType :=
                    req.Header.Get("Content-Type")
     4
     5            if strings.TrimSpace(contentType) == "" {
     6                var parseError error
     7                contentType, _, parseError =
                        mime.ParseMediaType(contentType)
     8                if parseError != nil {
     9                    JSONError(wr,
                            http.StatusBadRequest,
                            "Bad or no content-type header
                             found")
    10                    return
    11                }
    12            }
    13
    14            if contentType != "application/json" {
    15                JSONError(wr,
                        http.StatusUnsupportedMediaType,
                        "Content-Type not
                         application/json")
    16                return
    17            }
    18            // Tell the client we're talking JSON as
                  // well.
    19            wr.Header().Add("Content-Type",
                                  "application/json")
    20            next.ServeHTTP(wr, req)
    21        })
    22    }</pre>
<p>Line 14 checks whether the <a id="_idIndexMarker234"/>Content-Type header contains an <strong class="source-inline">application/json</strong> value; otherwise, it will return an error as part of the response (<span class="No-Break">line 15).</span></p>
<p>Now that we understand the concept of middleware, we’ll develop some middleware to make handling our <span class="No-Break">sessions easier.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor112"/>Session middleware</h2>
<p>This session middleware<a id="_idIndexMarker235"/> does not fit into our <strong class="source-inline">api</strong> package as it’s closely tied to our session-handling functionality, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
     1    session, err := cookieStore.Get(req,
                                          "session-name")
     2    if err != nil {
     3       api.JSONError(wr,
                           http.StatusInternalServerError,
                           "Session Error")
     4       return
     5    }
     6
     7    userID, userIDOK :=
            session.Values["userID"].(int64)
     8    isAuthd, isAuthdOK :=
            session.Values["userAuthenticated"].(bool)
     9    if !userIDOK || !isAuthdOK {
    10       api.JSONError(wr,
               http.StatusInternalServerError,
               "Session Error")
    11       return
    12    }
    13
    14    if !isAuthd || userID &lt; 1 {
    15       api.JSONError(wr, http.StatusForbidden,
                           "Bad Credentials")
    16       return
    17    }
    18    ...
    19    ctx := context.WithValue(req.Context(),
                                   SessionKey, UserSession{
    20       UserID: user.UserID,
    21    })
    22    h.ServeHTTP(wr, req.WithContext(ctx))
    23</pre>
<p>What the preceding middleware does is attempt to retrieve our session from <strong class="source-inline">cookiestore</strong> (line 1), which we covered in the previous chapter. From the returned session map, we perform an assertion on two values (line 7) that assigns <strong class="source-inline">userID</strong> the <strong class="source-inline">int64</strong> value and the <span class="No-Break">Boolean </span><span class="No-Break"><strong class="source-inline">userIDOK</strong></span><span class="No-Break">.</span></p>
<p>Finally, if everything checks out, including a check of the database for the user, we use <strong class="source-inline">context.WithValue()</strong> (line 19) to provide a new context with our <strong class="source-inline">sessionKey</strong>, which is a unique type to <span class="No-Break">our package.</span></p>
<p>We then provide a <a id="_idIndexMarker236"/>simple function called <strong class="source-inline">userFromSession</strong> that our handlers can call to check the validity of the key type and the incoming <span class="No-Break">session data.</span></p>
<p>In this section, we learned about middleware and looked at adding different types of middleware to an application. Also, we looked at CORS and how it works when developing web applications. In the next section, we will look in more detail at JSON and use models to represent JSON for reques<a id="_idTextAnchor113"/>ts <span class="No-Break">and responses.</span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor114"/>Converting to and from JSON</h1>
<p>In this section, we will look at getting and sending data from and to JSON. We will also look at creating a structure to handle data and how the JSON conversion <span class="No-Break">is done.</span></p>
<p>When dealing with <a id="_idIndexMarker237"/>JSON in Golang via the standard library, we’ve got two <a id="_idIndexMarker238"/>primary options –<strong class="source-inline">json.Marshal/Unmarshal</strong> and <strong class="source-inline">json.NewEncoder(io.Writer)/NewDecoder(io.Reader)</strong>. In this chapter, we will look at using the <strong class="source-inline">Encoder</strong>/<strong class="source-inline">Decoder</strong> methods. The reason for using these methods is that we can chain a function to the encoder/decoder that’s returned and call the <strong class="source-inline">.Encode</strong> and <strong class="source-inline">.Decode</strong> functions with ease. Another benefit of this approach is that it uses the streaming interface (namely <strong class="source-inline">io.Reader</strong> and <strong class="source-inline">io.Writer</strong>, used to represent an entity from/to which you can read or write a stream of bytes – the <strong class="source-inline">Reader</strong> and <strong class="source-inline">Writer</strong> interfaces are accepted as input and output by many utilities and functions in the standard library), so we have other choices than <strong class="source-inline">Marshal</strong>, which works with preallocated bytes, meaning we’re more efficient with our allocations and <span class="No-Break">also faster.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor115"/>Defining request model</h2>
<p>Data that flows<a id="_idIndexMarker239"/> through our application will be wrapped inside a struct. A struct is a structure that is defined <a id="_idIndexMarker240"/>to hold data. This makes it easier to transport data across different parts of the application; it does not make sense, if you have to transport 10 different pieces of data to different parts of the application, to do this by calling a function with 10 parameters, but if it is inside a struct, the function will only have to accept one parameter of that type. For simplicity, structs that hold data are also called models, as the field defined inside the struct is modeled on the data that <span class="No-Break">it represents.</span></p>
<p>Let’s take a look at the model that we defined to wrap the login data (username and password) in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
func handleLogin(db *sql.DB) http.HandlerFunc {
 return http.HandlerFunc(func(wr http.ResponseWriter, req    *http.Request) {
   type loginRequest struct {
    Username string `json:"username"`
    Password string `json:"password"`
   }
  ...
}</pre>
<p>As seen in the preceding code, the <strong class="source-inline">loginRequest</strong> model is declared with a <strong class="source-inline">json:"username"</strong> definition. This tells the standard library JSON converter <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="source-inline">username</strong> – the key name used when converted to a <span class="No-Break">JSON string</span></li>
<li><strong class="source-inline">omitempty</strong> – if the value is empty, the key will not be included in the <span class="No-Break">JSON string</span></li>
</ul>
<p>More information can be found at <a href="https://pkg.go.dev/encoding/json#Marshal">https://pkg.go.dev/encoding/json#Marshal</a>, where you can see the different configurations that a model can have to convert <span class="No-Break">from/to JSON.</span></p>
<p>Now that we have <a id="_idIndexMarker241"/>defined the model inside the function, we want to use it. The <strong class="source-inline">handleLogin</strong> function uses the <strong class="source-inline">Decode</strong> function that exists inside the <strong class="source-inline">json</strong> standard library to decode the data, as shown in the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
payload := loginRequest{}
if err := json.NewDecoder(req.Body).Decode(&amp;payload); err != nil {
 ...
}</pre>
<p>Once successfully converted, the code can use the <strong class="source-inline">payload</strong> variable to access the values that were passed as part of the <span class="No-Break">HTTP request.</span></p>
<p>Let’s take a look at another model that the code defines to store exercise set information that is passed by the user. The way to convert the data into <strong class="source-inline">newSetRequest</strong> is the same as <strong class="source-inline">loginRequest</strong> using the <span class="No-Break"><strong class="source-inline">Decode</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
   1    func handleAddSet(db *sql.DB) http.HandlerFunc {
   2     return http.HandlerFunc(func(wr
           http.ResponseWriter,
           req *http.Request) {
   3
   4       ...
   5
   6       type newSetRequest struct {
   7        ExerciseName string
             `json:"exercise_name,omitempty"`
   8        Weight    int  `json:"weight,omitempty"`
   9       }
  10
  11       payload := newSetRequest{}
  12       if err := json.NewDecoder(req.Body)
             .Decode(&amp;payload); err != nil {
  13         ...
  14        return
  15       }
  16
  17       ...
  18     })
  19    }
  20</pre>
<p>The function declares a new struct (line 6) called <strong class="source-inline">newSetRequest</strong>, and this will be populated by calling the <strong class="source-inline">json.NewDecoder()</strong> function (line 12), which will be populated into <a id="_idIndexMarker242"/>the <strong class="source-inline">payload</strong> (line <span class="No-Break">11) variable.</span></p>
<p>In this section, we looked at using a model to host the information that is passed by the user. In the next section, we will look at sending response<a id="_idTextAnchor116"/>s back using <span class="No-Break">the model.</span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor117"/>Defining a response model</h2>
<p>In this section, we will <a id="_idIndexMarker243"/>look at how to use a model to host information that will be sent back as a response to the user. In <a href="B18295_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Building the Database and Model</em>, we learned about sqlc tools that generate the different database models that will be used by our application. We will use the same database model defined by sqlc, converted to a JSON string as a response back to the user. The <strong class="source-inline">json</strong> package library is smart enough to convert models into <span class="No-Break">JSON strings.</span></p>
<p>Let’s look at the response sent back when a user creates a new workout – in this case, the <strong class="source-inline">handleAddSet</strong> function, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
func handleAddSet(db *sql.DB) http.HandlerFunc {
 return http.HandlerFunc(func(wr http.ResponseWriter,
                              req *http.Request) {
   ...
   set, err :=
     querier.CreateDefaultSetForExercise(req.Context(),
       store.CreateDefaultSetForExerciseParams{
      WorkoutID:  int64(workoutID),
      ExerciseName: payload.ExerciseName,
      Weight:    int32(payload.Weight),
    })
   ...
   json.NewEncoder(wr).Encode(&amp;set)
 })
}</pre>
<p>As you can see, the function calls the <strong class="source-inline">CreateDefaultSetForExercise</strong> function and uses the <strong class="source-inline">set</strong> variable as a response back to the user by using the <strong class="source-inline">Encode</strong> function. The returned set variable is of type <strong class="source-inline">GowebappSet</strong>, which is defined <span class="No-Break">as follows:</span></p>
<pre class="source-code">
type GowebappSet struct {
 SetID    int64 `json:"set_id"`
 WorkoutID  int64 `json:"workout_id"`
 ExerciseName string `json:"exercise_name"`
 Weight    int32 `json:"weight"`
 Set1     int64 `json:"set1"`
 Set2     int64 `json:"set2"`
 Set3     int64 `json:"set3"`
}</pre>
<p>When the <a id="_idIndexMarker244"/>model is converted using <strong class="source-inline">Encode</strong> and sent back as a response, this is how it <span class="No-Break">will look:</span></p>
<pre class="source-code">
{
 "set_id": 1,
 "workout_id": 1,
 "exercise_name": "Barbell",
 "weight": 700,
 "set1": 0,
 "set2": 0,
 "set3": 0
}</pre>
<p>In this section, we looked at a model generated by sqlc that is not only used to host read/write data to and from a database but also used to send responses back to the user as a JSON string. In the next section, we will look at another important feature that we need to add to the application, error handling, which wil<a id="_idTextAnchor118"/>l be reported <span class="No-Break">using JSON.</span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor119"/>Reporting errors with JSON</h1>
<p>There are many ways to<a id="_idIndexMarker245"/> handle errors when writing web applications. In our sample <a id="_idIndexMarker246"/>application, we handle errors to inform users of what’s happening with their request. When reporting errors to users about their request, remember not to expose too much information about what’s happening to the system. The following are some examples of error messages reported to users that contain <span class="No-Break">such information:</span></p>
<ul>
<li>There is a connection error to <span class="No-Break">the database</span></li>
<li>The username and password are not valid for connecting to <span class="No-Break">the database</span></li>
<li>Username <span class="No-Break">validation failed</span></li>
<li>The password cannot be converted to <span class="No-Break">plain text</span></li>
</ul>
<p>The preceding <a id="_idIndexMarker247"/>JSON error use cases are normally used in scenarios where more<a id="_idIndexMarker248"/> information needs to be provided to the frontend to inform users. Simpler error messages containing err<a id="_idTextAnchor120"/>or codes can also <span class="No-Break">be used.</span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor121"/>Using JSONError</h2>
<p>Standardizing error messages<a id="_idIndexMarker249"/> is as important as writing proper code to ensure application maintainability. At the same time, it makes it easier for others to read and understand your code <span class="No-Break">when troubleshooting.</span></p>
<p>In our sample application, we will use JSON to wrap error messages that are reported to the user. This ensures consistency in the format and content of the error. The following code snippet can be found inside the <span class="No-Break"><strong class="source-inline">internal/api/wrappers.go</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
   1    func JSONError(wr http.ResponseWriter,
          errorCode int, errorMessages ...string) {
   2     wr.WriteHeader(errorCode)
   3     if len(errorMessages) &gt; 1 {
   4       json.NewEncoder(wr).Encode(struct {
   5        Status string  `json:"status,omitempty"`
   6        Errors []string `json:"errors,omitempty"`
   7       }{
   8        Status: fmt.Sprintf("%d / %s", errorCode,
              http.StatusText(errorCode)),
   9        Errors: errorMessages,
  10       })
  11       return
  12     }
  13
  14     json.NewEncoder(wr).Encode(struct {
  15       Status string `json:"status,omitempty"`
  16       Error string `json:"error,omitempty"`
  17     }{
  18       Status: fmt.Sprintf("%d / %s", errorCode,
             http.StatusText(errorCode)),
  19       Error: errorMessages[0],
  20     })
  21    }</pre>
<p>The <strong class="source-inline">JSONError</strong> function <a id="_idIndexMarker250"/>will use the passed <strong class="source-inline">errorCode</strong> parameter and <strong class="source-inline">errorMessages(line 1)</strong> as part of the JSON reported to the user – for example, let’s say we call the <strong class="source-inline">/login</strong> endpoint with the wrong credentials using the following <span class="No-Break">cURL command:</span></p>
<pre class="console">
curl http://localhost:9002/login -H 'Content-Type: application/json' -X POST -d '{"username" : "user@user", "password" : "wrongpassword"}</pre>
<p>You will get the following JSON <span class="No-Break">error message:</span></p>
<pre class="source-code">
{"status":"403 / Forbidden","error":"Bad Credentials"}</pre>
<p>The error is <a id="_idIndexMarker251"/>constructed by using the struct that is defined when enc<a id="_idTextAnchor122"/>oding the JSON string (<span class="No-Break">line 14).</span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor123"/>Using JSONMessage</h2>
<p>The sample application uses <a id="_idIndexMarker252"/>JSON not only for reporting error messages but also for reporting successful messages. Let’s take a look at the output of a successful message. Log in using the following <span class="No-Break">cURL command:</span></p>
<pre class="console">
curl http://localhost:9002/login -v -H 'Content-Type: application/json' -X POST -d '{"username" : "user@user", "password" : "password"}'</pre>
<p>You will get output that looks <span class="No-Break">like this:</span></p>
<pre class="console">
*  Trying ::1:9002...
* TCP_NODELAY set
* Connected to localhost (::1) port 9002 (#0)
&gt; POST /login HTTP/1.1
&gt; Host: localhost:9002
…
&lt; Set-Cookie: session-name=MTY0NTM0OTI1OXxEdi1CQkFFQ180SUFBUkFCRUFBQVJQLUNBQUlHYzNSeWFXNW5EQk1BRVhWelpYSkJkWFJvWlc1MGFXTmhkR1ZrQkdKdmIyd0NBZ0FCQm5OMGNtbHVad3dJQUFaMWMyVnlTVVFGYVc1ME5qUUVBZ0FDfHMy75qzLVPoMZ3BbNY17qBWd_puOhl6jpgY-d29ULUV; Path=/; Expires=Sun, 20 Feb 2022 09:42:39 GMT; Max-Age=900; HttpOnly
…
* Connection #0 to host localhost left intact</pre>
<p>Using<a id="_idIndexMarker253"/> the <strong class="source-inline">session-name</strong> token, use the following cURL command to create <span class="No-Break">a workout:</span></p>
<pre class="console">
curl http://localhost:9002/workout -H 'Content-Type: application/json' -X POST --cookie 'session-name=MTY0NTM0OTI1OXxEdi1CQkFFQ180SUFBUkFCRUFBQVJQLUNBQUlHYzNSeWFXNW 5EQk1BRVhWelpYSkJkWFJvWlc1MGFXTmhkR1ZrQkdKdmIyd0NBZ0FCQm5OM
GNtbHVad3dJQUFaMWMyVnlTVVFGYVc1ME5qUUVBZ0FDfHMy75qzLVPoMZ3BbNY 17qBWd_puOhl6jpgY-d29ULUV'</pre>
<p>On successfully creating the workout, you will see a JSON message that looks like <span class="No-Break">the following:</span></p>
<pre class="console">
{"workout_id":3,"user_id":1,"start_da<a id="_idTextAnchor124"/>te":"2022-02-20T09:29:25.406523Z"}</pre>
<h1 id="_idParaDest-89"><a id="_idTextAnchor125"/>Summary</h1>
<p>In this chapter, we’ve looked at creating and leveraging our own middleware for session handling as well as enforcing JSON usage on our API. We’ve also reworked our project to use a common package layout to help separate our concerns and set ourselves up for future work <span class="No-Break">and iteration.</span></p>
<p>Also in this chapter, we’ve introduced a number of helper functions, including two for creating and reporting errors and messages to the user via JSON and an API package to abstract our server handling, making it easy to understand and preparing us to <span class="No-Break">accommodate CORS.</span></p>
<p>In the next chapter, we will discuss writing frontends in more detail and learn how to write frontend applications using a <span class="No-Break">frontend framework.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer047">
<h1 id="_idParaDest-90"><a id="_idTextAnchor126"/>Part 3:Single-Page Apps with Vue and Go</h1>
<p><a id="_idTextAnchor127"/>In <em class="italic">Part 3</em>, we introduce frontend frameworks before diving into how we can combine Vue with Go and explore different frontend technologies to power our sample applications. We will look at implementing <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>) and using JWT for sessions in our application to simplify and secure our app from <span class="No-Break">bad actors!</span></p>
<p>This part includes the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18295_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a><em class="italic">, Frontend Frameworks</em></li>
<li><a href="B18295_08.xhtml#_idTextAnchor153"><em class="italic">Chapter 8</em></a><em class="italic">, Frontend Libraries</em></li>
<li><a href="B18295_09.xhtml#_idTextAnchor184"><em class="italic">Chapter 9</em></a><em class="italic">, Tailwind, Middleware, and CORS</em></li>
<li><a href="B18295_10.xhtml#_idTextAnchor198"><em class="italic">Chapter 10</em></a><em class="italic">, Session Management </em></li>
</ul>
</div>
<div>
<div id="_idContainer048">
</div>
</div>
<div>
<div id="_idContainer049">
</div>
</div>
</div></body></html>