- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving to API-First
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned about building databases, adding monitoring
    to applications, using middleware, and session handling. In this chapter, we will
    learn about building an API in our application, and why an API is an important
    part of writing applications as it forms the interface between the frontend and
    the backend. Building the API first is important, as it forms the bridge for data
    exchanges and can be thought of as a contract between the frontend and the backend.
    Having the proper and correct form of contract is important before building an
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We will also explore the concepts of REST and JSON to get a better understanding
    of what they are and how they are used throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: Upon completion of this chapter, you will know how to design a REST API using
    Gorilla Mux and also how to process requests to perform operations by converting
    data to and from JSON. You will also learn how to take care of error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring API-first applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting data to and from JSON using Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling using JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code explained in this chapter can be checked out from [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Structuring an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go applications are structured inside directories, with each directory containing
    Go source code that means something for those applications. There are many ways
    to structure your Go application in different kinds of directories; however, one
    thing that you have to remember is to always give a directory a name that will
    be easy for others to understand. As an application grows with time, the chosen
    directory structure and where code is placed has a big impact on how easily other
    developers in your team will be able to work with the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Defining packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we’ve kept things fairly simple, but we’re going to up our
    game a little and move to a fairly common layout. We won’t use the term “standard
    layout,” as there’s no such thing in Go, but we’ll look at how we’re structuring
    our new project and talk about how we reason them through to best structure our
    Go application for clarity and understanding, as shown in *Figure 6**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Chapter 6 package structure](img/Figure_6.01_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Chapter 6 package structure'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine some of these files in a bit more detail to understand these decisions.
  prefs: []
  type: TYPE_NORMAL
- en: generate.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you take a look at this file, it can appear confusing at first, but we’ve
    used a neat Go feature called `go generate` that can help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At a glance, it looks like a comment because comments in Go start with the
    `//` character. However, this one starts with the word `go:generate`. This is
    called the `go:generate` directive; what this means is that when `go generate`
    is executed (as shown in the following code block), it will execute the command
    specified – in our example, it will print the text `Generating SQL Schemas` and
    execute the sqlc command-line tool (`sqlc generate`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful technique to easily generate your build prerequisites; this
    can be done as part of your workflow, performed by `Makefile`, or done by your
    CI/CD. `Makefile` is a file containing sets of rules to determine which parts
    of a program need to be compiled and what command to use to compile the source
    code. It can be used to compile all kinds of programming language source code.
  prefs: []
  type: TYPE_NORMAL
- en: All we’re doing in our `generate.go` file is simply ensuring that we generate
    the latest schema files for sqlc. We could add mock generation, more informational
    messages, or generate archives or any manner of other useful things that might
    make up our build.
  prefs: []
  type: TYPE_NORMAL
- en: handlers.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This name comes purely from our experience in using the same pattern of naming
    files after the functionality defined therein. Our `handlers` file provides a
    single place (for now) where our HTTP handlers can be found. Ours contains login,
    logout, and all kinds of handlers and their request and response types needed
    to interact with our app. We don’t do anything outside of our handlers in this
    file; all connectivity and addition of middleware are performed as part of `main.go`
    to ensure the separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: internal/
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the “old days” of Go – back before 1.0 was released – the Go source code
    featured a directory called `pkg`, which was for internal-only code and became
    an idiom for the community, as well as a way to mark subfolders/packages as internal
    to a particular project.
  prefs: []
  type: TYPE_NORMAL
- en: The `pkg` folder was eventually removed from the Go project but it left a bit
    of an unfulfilled need, and to that end, the `internal` directory was created.
    `internal` is a special directory in so much as it is recognized by the Go tool
    itself, which allows an author to restrict importing the package unless they share
    a common ancestor. To demonstrate this, we’re storing our API package here as
    well as `env.go` (used to simplify a way to read environmental variables in the
    app) and `auth.go` (our specific way to handle authorization) – the `auth.go`
    or `handlers.go` files in particular are good options to prevent others from importing,
    while others like the `env` package are more general and can be moved up and out.
  prefs: []
  type: TYPE_NORMAL
- en: migrations, queries, and store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `sqlc` and `golang-migrate`, we’ve given ourselves a leg up in making
    things easy to organize and increasing our ability to rapidly create our apps.
    We’re just separating things to make life a bit easier, as shown in the `sqlc.yaml`
    configuration file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To see how this works in practice, take a look at the `readme` file provided
    in the repo.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at structuring applications by separating different parts of
    an application into different folders. Grouping source code into different folders
    allows easier navigation of the application when doing maintenance and development.
    In the next section, we will explore building an API that will be used to consume
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing our REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s understand a few concepts that we are going to use in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: REST – `https://what-ever-shop.com/orders/1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uses JSON as the exchange format – for example, a `GET` request to `https://what-ever-shop.com/orders/1`
    might return the following response body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: API – **API** is an acronym for **Application Programming Interface**, a software
    intermediary that allows two applications to talk to each other. For example,
    if you are using the Google search engine, you are using an API that it provides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining both the preceding concepts, we come up with a REST API, and the software
    that we are building is called a RESTful API, which means that the API that we
    provide can be accessed using REST.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at exposing our RESTful handlers, a pattern for
    an API server, and discuss our new `middleware.Main` session and the API package.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve done some rework to prepare our new API-first project. We’ve abstracted
    the API server into its own package in `internal/api`. Its responsibility is to
    provide a server that accepts a port to bind on and the ability to start the server,
    stop it, and add routes with optional middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a snippet (from `chapter06/main.go`) of our new main function
    showing this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pay special attention to how we’ve created our default middleware, which is
    declared in the `defaultMiddleware` variable (line 8). For our protected routes,
    we are appending the `protectedMiddleware` variable (line 23) into the existing
    `defaultMiddleware` variable. Our custom session verification middleware is added
    to the middleware chain (line 23) to ensure a valid login before allowing access
    to our other handlers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also pushed two types of middleware into this `api` package, `JSONMiddleware`
    (line 9) and `CORSMiddleware` (line 10), which takes a slice of strings for a
    **CORS** allow-list, which we’ll look at in more depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anyone working with API-first applications will encounter the concept of CORS.
    It’s a security feature of modern browsers to ensure that web apps on one domain
    have permission to request APIs on a different origin. The way it does this is
    by performing what is called a preflight request, which is basically just a normal
    `OPTIONS` request. This returns information, telling our app that it is allowed
    to talk to the API endpoint, along with the methods it supports and the origins.
    Origins contain the same domain sent by the client in the `origin` header, or
    it could be a wildcard (`*`), which means that all origins are allowed, as explained
    in *Figure 6**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: CORS flow (sourced from Mozilla MDN and licensed under Creative
    Commons)](img/Figure_6.02_B18295.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: CORS flow (sourced from Mozilla MDN and licensed under Creative
    Commons)'
  prefs: []
  type: TYPE_NORMAL
- en: Our middleware wraps the Gorilla Mux CORS middleware to make it a little easier
    for us to provide our CORS whitelisted domains (the domains we’re happy to respond
    to requests on) and all the HTTP methods for those same domains.
  prefs: []
  type: TYPE_NORMAL
- en: JSON middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another piece of middleware that is functionally needed to enforce our requirements
    for an API-powered application is JSON middleware. **JSON**, short for **Javascript
    Object Notation**, is an open standard file format that is used to represent data
    in a key-value pair and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: JSON middleware uses HTTP headers to check what kind of data is being sent in
    a request. It checks the `Content-Type` header key, which should contain the `application/json`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: If it cannot find the value that it requires, then the middleware will check
    the value of the `Accept` header to see whether it can find the `application/json`
    value. Once the check is done and it cannot find the value that it is looking
    for, it replies that it’s not a suitable content type for us to work with. We
    also add that header to our `ResponseWriter` so that we can ensure we’re telling
    the consumer we only support JSON and send that back to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the JSON middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Line 14 checks whether the Content-Type header contains an `application/json`
    value; otherwise, it will return an error as part of the response (line 15).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the concept of middleware, we’ll develop some middleware
    to make handling our sessions easier.
  prefs: []
  type: TYPE_NORMAL
- en: Session middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This session middleware does not fit into our `api` package as it’s closely
    tied to our session-handling functionality, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding middleware does is attempt to retrieve our session from `cookiestore`
    (line 1), which we covered in the previous chapter. From the returned session
    map, we perform an assertion on two values (line 7) that assigns `userID` the
    `int64` value and the Boolean `userIDOK`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if everything checks out, including a check of the database for the
    user, we use `context.WithValue()` (line 19) to provide a new context with our
    `sessionKey`, which is a unique type to our package.
  prefs: []
  type: TYPE_NORMAL
- en: We then provide a simple function called `userFromSession` that our handlers
    can call to check the validity of the key type and the incoming session data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about middleware and looked at adding different
    types of middleware to an application. Also, we looked at CORS and how it works
    when developing web applications. In the next section, we will look in more detail
    at JSON and use models to represent JSON for requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to and from JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at getting and sending data from and to JSON.
    We will also look at creating a structure to handle data and how the JSON conversion
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with JSON in Golang via the standard library, we’ve got two primary
    options –`json.Marshal/Unmarshal` and `json.NewEncoder(io.Writer)/NewDecoder(io.Reader)`.
    In this chapter, we will look at using the `Encoder`/`Decoder` methods. The reason
    for using these methods is that we can chain a function to the encoder/decoder
    that’s returned and call the `.Encode` and `.Decode` functions with ease. Another
    benefit of this approach is that it uses the streaming interface (namely `io.Reader`
    and `io.Writer`, used to represent an entity from/to which you can read or write
    a stream of bytes – the `Reader` and `Writer` interfaces are accepted as input
    and output by many utilities and functions in the standard library), so we have
    other choices than `Marshal`, which works with preallocated bytes, meaning we’re
    more efficient with our allocations and also faster.
  prefs: []
  type: TYPE_NORMAL
- en: Defining request model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data that flows through our application will be wrapped inside a struct. A struct
    is a structure that is defined to hold data. This makes it easier to transport
    data across different parts of the application; it does not make sense, if you
    have to transport 10 different pieces of data to different parts of the application,
    to do this by calling a function with 10 parameters, but if it is inside a struct,
    the function will only have to accept one parameter of that type. For simplicity,
    structs that hold data are also called models, as the field defined inside the
    struct is modeled on the data that it represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the model that we defined to wrap the login data (username
    and password) in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding code, the `loginRequest` model is declared with a
    `json:"username"` definition. This tells the standard library JSON converter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`username` – the key name used when converted to a JSON string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`omitempty` – if the value is empty, the key will not be included in the JSON
    string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information can be found at [https://pkg.go.dev/encoding/json#Marshal](https://pkg.go.dev/encoding/json#Marshal),
    where you can see the different configurations that a model can have to convert
    from/to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the model inside the function, we want to use it.
    The `handleLogin` function uses the `Decode` function that exists inside the `json`
    standard library to decode the data, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once successfully converted, the code can use the `payload` variable to access
    the values that were passed as part of the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at another model that the code defines to store exercise
    set information that is passed by the user. The way to convert the data into `newSetRequest`
    is the same as `loginRequest` using the `Decode` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function declares a new struct (line 6) called `newSetRequest`, and this
    will be populated by calling the `json.NewDecoder()` function (line 12), which
    will be populated into the `payload` (line 11) variable.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at using a model to host the information that is
    passed by the user. In the next section, we will look at sending responses back
    using the model.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a response model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at how to use a model to host information that
    will be sent back as a response to the user. In [*Chapter 1*](B18295_01.xhtml#_idTextAnchor016),
    *Building the Database and Model*, we learned about sqlc tools that generate the
    different database models that will be used by our application. We will use the
    same database model defined by sqlc, converted to a JSON string as a response
    back to the user. The `json` package library is smart enough to convert models
    into JSON strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the response sent back when a user creates a new workout – in
    this case, the `handleAddSet` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the function calls the `CreateDefaultSetForExercise` function
    and uses the `set` variable as a response back to the user by using the `Encode`
    function. The returned set variable is of type `GowebappSet`, which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the model is converted using `Encode` and sent back as a response, this
    is how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we looked at a model generated by sqlc that is not only used
    to host read/write data to and from a database but also used to send responses
    back to the user as a JSON string. In the next section, we will look at another
    important feature that we need to add to the application, error handling, which
    will be reported using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting errors with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways to handle errors when writing web applications. In our
    sample application, we handle errors to inform users of what’s happening with
    their request. When reporting errors to users about their request, remember not
    to expose too much information about what’s happening to the system. The following
    are some examples of error messages reported to users that contain such information:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a connection error to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username and password are not valid for connecting to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username validation failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password cannot be converted to plain text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding JSON error use cases are normally used in scenarios where more
    information needs to be provided to the frontend to inform users. Simpler error
    messages containing error codes can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSONError
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standardizing error messages is as important as writing proper code to ensure
    application maintainability. At the same time, it makes it easier for others to
    read and understand your code when troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our sample application, we will use JSON to wrap error messages that are
    reported to the user. This ensures consistency in the format and content of the
    error. The following code snippet can be found inside the `internal/api/wrappers.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JSONError` function will use the passed `errorCode` parameter and `errorMessages(line
    1)` as part of the JSON reported to the user – for example, let’s say we call
    the `/login` endpoint with the wrong credentials using the following cURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following JSON error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The error is constructed by using the struct that is defined when encoding the
    JSON string (line 14).
  prefs: []
  type: TYPE_NORMAL
- en: Using JSONMessage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample application uses JSON not only for reporting error messages but
    also for reporting successful messages. Let’s take a look at the output of a successful
    message. Log in using the following cURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `session-name` token, use the following cURL command to create a
    workout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On successfully creating the workout, you will see a JSON message that looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at creating and leveraging our own middleware
    for session handling as well as enforcing JSON usage on our API. We’ve also reworked
    our project to use a common package layout to help separate our concerns and set
    ourselves up for future work and iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Also in this chapter, we’ve introduced a number of helper functions, including
    two for creating and reporting errors and messages to the user via JSON and an
    API package to abstract our server handling, making it easy to understand and
    preparing us to accommodate CORS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss writing frontends in more detail and learn
    how to write frontend applications using a frontend framework.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Single-Page Apps with Vue and Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 3*, we introduce frontend frameworks before diving into how we can
    combine Vue with Go and explore different frontend technologies to power our sample
    applications. We will look at implementing **Cross-Origin Resource Sharing** (**CORS**)
    and using JWT for sessions in our application to simplify and secure our app from
    bad actors!
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18295_07.xhtml#_idTextAnchor128)*, Frontend Frameworks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18295_08.xhtml#_idTextAnchor153)*, Frontend Libraries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18295_09.xhtml#_idTextAnchor184)*, Tailwind, Middleware, and
    CORS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18295_10.xhtml#_idTextAnchor198)*, Session Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
