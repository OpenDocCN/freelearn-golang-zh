- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Moving to API-First
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向API优先
- en: In the previous chapters, we learned about building databases, adding monitoring
    to applications, using middleware, and session handling. In this chapter, we will
    learn about building an API in our application, and why an API is an important
    part of writing applications as it forms the interface between the frontend and
    the backend. Building the API first is important, as it forms the bridge for data
    exchanges and can be thought of as a contract between the frontend and the backend.
    Having the proper and correct form of contract is important before building an
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何构建数据库、向应用程序添加监控、使用中间件以及处理会话。在本章中，我们将学习如何在我们的应用程序中构建API，以及为什么API是编写应用程序的重要部分，因为它构成了前端和后端之间的接口。首先构建API很重要，因为它形成了数据交换的桥梁，可以将其视为前端和后端之间的合同。在构建应用程序之前，拥有正确和正确的合同形式很重要。
- en: We will also explore the concepts of REST and JSON to get a better understanding
    of what they are and how they are used throughout our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨REST和JSON的概念，以更好地理解它们是什么以及如何在我们的应用程序中应用。
- en: Upon completion of this chapter, you will know how to design a REST API using
    Gorilla Mux and also how to process requests to perform operations by converting
    data to and from JSON. You will also learn how to take care of error handling.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章后，你将了解如何使用Gorilla Mux设计REST API，以及如何通过将数据转换为JSON和从JSON转换回来来处理请求以执行操作。你还将学习如何处理错误。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Structuring API-first applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化API优先应用程序
- en: Exposing REST APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露REST API
- en: Converting data to and from JSON using Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go将数据转换为JSON以及从JSON转换回来
- en: Error handling using JSON
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON进行错误处理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code explained in this chapter can be checked out from [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以从[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter06)获取。
- en: Structuring an application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化应用程序
- en: Go applications are structured inside directories, with each directory containing
    Go source code that means something for those applications. There are many ways
    to structure your Go application in different kinds of directories; however, one
    thing that you have to remember is to always give a directory a name that will
    be easy for others to understand. As an application grows with time, the chosen
    directory structure and where code is placed has a big impact on how easily other
    developers in your team will be able to work with the code base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序在目录内结构化，每个目录包含对应用程序有意义的Go源代码。有多种方式可以在不同的目录中结构化你的Go应用程序；然而，你必须记住的是，始终给目录起一个易于他人理解的名字。随着应用程序随着时间的推移而增长，所选的目录结构和代码放置的位置对其他开发人员如何轻松地与代码库一起工作有重大影响。
- en: Defining packages
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义包
- en: Up to this point, we’ve kept things fairly simple, but we’re going to up our
    game a little and move to a fairly common layout. We won’t use the term “standard
    layout,” as there’s no such thing in Go, but we’ll look at how we’re structuring
    our new project and talk about how we reason them through to best structure our
    Go application for clarity and understanding, as shown in *Figure 6**.1*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们保持事情相对简单，但我们将提高我们的水平，转向一个相当常见的布局。我们不会使用“标准布局”这个术语，因为在Go中并没有这样的东西，但我们将查看我们如何构建我们的新项目，并讨论我们如何通过最佳结构化我们的Go应用程序来推理它们，以便清晰和易于理解，如图*6**.1*所示。
- en: '![Figure 6.1: Chapter 6 package structure](img/Figure_6.01_B18295.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：第6章包结构](img/Figure_6.01_B18295.jpg)'
- en: 'Figure 6.1: Chapter 6 package structure'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：第6章包结构
- en: Let’s examine some of these files in a bit more detail to understand these decisions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查一些这些文件，以了解这些决策。
- en: generate.go
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: generate.go
- en: 'If you take a look at this file, it can appear confusing at first, but we’ve
    used a neat Go feature called `go generate` that can help:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个文件，一开始可能会觉得有些混乱，但我们使用了一个叫做`go generate`的整洁的Go特性，它可以提供帮助：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At a glance, it looks like a comment because comments in Go start with the
    `//` character. However, this one starts with the word `go:generate`. This is
    called the `go:generate` directive; what this means is that when `go generate`
    is executed (as shown in the following code block), it will execute the command
    specified – in our example, it will print the text `Generating SQL Schemas` and
    execute the sqlc command-line tool (`sqlc generate`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它看起来像一条注释，因为 Go 中的注释以 `//` 字符开始。然而，这个以单词 `go:generate` 开始。这被称为 `go:generate`
    指令；这意味着当执行 `go generate`（如下面的代码块所示）时，它将执行指定的命令——在我们的例子中，它将打印文本 `Generating SQL
    Schemas` 并执行 sqlc 命令行工具（`sqlc generate`）：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a useful technique to easily generate your build prerequisites; this
    can be done as part of your workflow, performed by `Makefile`, or done by your
    CI/CD. `Makefile` is a file containing sets of rules to determine which parts
    of a program need to be compiled and what command to use to compile the source
    code. It can be used to compile all kinds of programming language source code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的技术，可以轻松地生成你的构建前提条件；这可以作为你的工作流程的一部分来完成，由 `Makefile` 执行，或者由 CI/CD 执行。`Makefile`
    是一个包含规则集的文件，用于确定程序哪些部分需要编译以及编译源代码时使用什么命令。它可以用来编译各种编程语言的源代码。
- en: All we’re doing in our `generate.go` file is simply ensuring that we generate
    the latest schema files for sqlc. We could add mock generation, more informational
    messages, or generate archives or any manner of other useful things that might
    make up our build.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `generate.go` 文件中，我们只是确保为 sqlc 生成最新的模式文件。我们可以添加模拟生成、更多的信息性消息，或者生成存档或其他任何可能构成我们构建的有用事物。
- en: handlers.go
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: handlers.go
- en: This name comes purely from our experience in using the same pattern of naming
    files after the functionality defined therein. Our `handlers` file provides a
    single place (for now) where our HTTP handlers can be found. Ours contains login,
    logout, and all kinds of handlers and their request and response types needed
    to interact with our app. We don’t do anything outside of our handlers in this
    file; all connectivity and addition of middleware are performed as part of `main.go`
    to ensure the separation of concerns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字纯粹来源于我们使用相同命名模式的经验，即根据其中定义的功能来命名文件。我们的 `handlers` 文件提供了一个单一的位置（目前是这样），我们的
    HTTP 处理器可以在这里找到。我们的包含登录、注销以及与我们的应用程序交互所需的所有类型的处理程序及其请求和响应类型。我们在这个文件中不做任何超出处理程序的事情；所有连接性和中间件的添加都是作为
    `main.go` 的一部分来执行的，以确保关注点的分离。
- en: internal/
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: internal/
- en: In the “old days” of Go – back before 1.0 was released – the Go source code
    featured a directory called `pkg`, which was for internal-only code and became
    an idiom for the community, as well as a way to mark subfolders/packages as internal
    to a particular project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 的“旧时代”——在 1.0 版本发布之前——Go 源代码中有一个名为 `pkg` 的目录，它是仅限内部使用的代码，成为社区的习惯用语，同时也是标记子目录/包为特定项目内部的方式。
- en: The `pkg` folder was eventually removed from the Go project but it left a bit
    of an unfulfilled need, and to that end, the `internal` directory was created.
    `internal` is a special directory in so much as it is recognized by the Go tool
    itself, which allows an author to restrict importing the package unless they share
    a common ancestor. To demonstrate this, we’re storing our API package here as
    well as `env.go` (used to simplify a way to read environmental variables in the
    app) and `auth.go` (our specific way to handle authorization) – the `auth.go`
    or `handlers.go` files in particular are good options to prevent others from importing,
    while others like the `env` package are more general and can be moved up and out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg` 文件夹最终被从 Go 项目中移除，但它留下了一丝未满足的需求，因此创建了 `internal` 目录。`internal` 是一个特殊的目录，因为它被
    Go 工具本身所识别，这允许作者限制导入包，除非它们共享一个共同的祖先。为了演示这一点，我们将我们的 API 包以及 `env.go`（用于简化在应用程序中读取环境变量的方式）和
    `auth.go`（我们处理授权的特定方式）存储在这里——特别是 `auth.go` 或 `handlers.go` 文件是防止他人导入的好选择，而像 `env`
    包这样的其他包则更为通用，可以将其移动到更高层次。'
- en: migrations, queries, and store
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迁移、查询和存储
- en: 'Using `sqlc` and `golang-migrate`, we’ve given ourselves a leg up in making
    things easy to organize and increasing our ability to rapidly create our apps.
    We’re just separating things to make life a bit easier, as shown in the `sqlc.yaml`
    configuration file here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sqlc` 和 `golang-migrate`，我们为自己在使事情易于组织和提高快速创建应用程序的能力方面提供了优势。我们只是将事物分开，使生活变得更容易，正如这里所示的
    `sqlc.yaml` 配置文件所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To see how this works in practice, take a look at the `readme` file provided
    in the repo.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解实际应用中的工作原理，请查看仓库中提供的`readme`文件。
- en: We have looked at structuring applications by separating different parts of
    an application into different folders. Grouping source code into different folders
    allows easier navigation of the application when doing maintenance and development.
    In the next section, we will explore building an API that will be used to consume
    data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过将应用程序的不同部分分别放入不同的文件夹来研究了应用程序的结构化。将源代码分组到不同的文件夹中，使得在维护和开发过程中更容易导航应用程序。在下一节中，我们将探讨构建一个用于消费数据的API。
- en: Exposing our REST API
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露我们的REST API
- en: 'Let’s understand a few concepts that we are going to use in this section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些在本节中将要使用到的概念：
- en: REST – `https://what-ever-shop.com/orders/1`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST – `https://what-ever-shop.com/orders/1`。
- en: 'Uses JSON as the exchange format – for example, a `GET` request to `https://what-ever-shop.com/orders/1`
    might return the following response body:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON作为交换格式 – 例如，对`https://what-ever-shop.com/orders/1`的`GET`请求可能会返回以下响应体：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: API – **API** is an acronym for **Application Programming Interface**, a software
    intermediary that allows two applications to talk to each other. For example,
    if you are using the Google search engine, you are using an API that it provides.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API – **API**是**应用程序编程接口**（Application Programming Interface）的缩写，是一种软件中介，允许两个应用程序相互通信。例如，如果你正在使用谷歌搜索引擎，你正在使用它提供的API。
- en: Combining both the preceding concepts, we come up with a REST API, and the software
    that we are building is called a RESTful API, which means that the API that we
    provide can be accessed using REST.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结合上述两个概念，我们得到了REST API，我们正在构建的软件被称为RESTful API，这意味着我们提供的API可以使用REST进行访问。
- en: In this section, we will look at exposing our RESTful handlers, a pattern for
    an API server, and discuss our new `middleware.Main` session and the API package.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨暴露我们的RESTful处理器，这是一种API服务器的模式，并讨论我们的新`middleware.Main`会话和API包。
- en: We’ve done some rework to prepare our new API-first project. We’ve abstracted
    the API server into its own package in `internal/api`. Its responsibility is to
    provide a server that accepts a port to bind on and the ability to start the server,
    stop it, and add routes with optional middleware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对新的API-first项目进行了一些重构。我们将API服务器抽象为`internal/api`中的独立包。其责任是提供一个服务器，该服务器接受一个要绑定的端口，并具有启动服务器、停止服务器和添加带有可选中间件的路由的能力。
- en: 'The following is a snippet (from `chapter06/main.go`) of our new main function
    showing this approach:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`chapter06/main.go`中提取的我们的新主函数片段，展示了这种方法：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pay special attention to how we’ve created our default middleware, which is
    declared in the `defaultMiddleware` variable (line 8). For our protected routes,
    we are appending the `protectedMiddleware` variable (line 23) into the existing
    `defaultMiddleware` variable. Our custom session verification middleware is added
    to the middleware chain (line 23) to ensure a valid login before allowing access
    to our other handlers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细注意我们是如何创建默认中间件的，它声明在`defaultMiddleware`变量（第8行）中。对于我们的受保护路由，我们将`protectedMiddleware`变量（第23行）追加到现有的`defaultMiddleware`变量中。我们的自定义会话验证中间件被添加到中间件链中（第23行），以确保在允许访问我们的其他处理器之前进行有效的登录。
- en: We’ve also pushed two types of middleware into this `api` package, `JSONMiddleware`
    (line 9) and `CORSMiddleware` (line 10), which takes a slice of strings for a
    **CORS** allow-list, which we’ll look at in more depth in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向这个`api`包中推入了两种类型的中间件，`JSONMiddleware`（第9行）和`CORSMiddleware`（第10行），它接受一个字符串切片作为**CORS**允许列表，我们将在下一节中更深入地探讨。
- en: Cross-Origin Resource Sharing (CORS)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨源资源共享（CORS）
- en: Anyone working with API-first applications will encounter the concept of CORS.
    It’s a security feature of modern browsers to ensure that web apps on one domain
    have permission to request APIs on a different origin. The way it does this is
    by performing what is called a preflight request, which is basically just a normal
    `OPTIONS` request. This returns information, telling our app that it is allowed
    to talk to the API endpoint, along with the methods it supports and the origins.
    Origins contain the same domain sent by the client in the `origin` header, or
    it could be a wildcard (`*`), which means that all origins are allowed, as explained
    in *Figure 6**.2*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用API优先应用程序的人都会遇到CORS的概念。这是现代浏览器的一个安全特性，确保一个域上的Web应用程序有权限请求不同源上的API。它是通过执行所谓的预检请求来做到这一点的，这基本上就是一个普通的`OPTIONS`请求。这会返回信息，告诉我们的应用程序它被允许与API端点通信，以及它支持的方法和源。源包含客户端在`origin`头中发送的相同域名，或者它可能是一个通配符（`*`），这意味着所有源都被允许，如*图6.2*所示。
- en: '![Figure 6.2: CORS flow (sourced from Mozilla MDN and licensed under Creative
    Commons)](img/Figure_6.02_B18295.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：CORS流程（来源：Mozilla MDN，授权于Creative Commons）](img/Figure_6.02_B18295.png)'
- en: 'Figure 6.2: CORS flow (sourced from Mozilla MDN and licensed under Creative
    Commons)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：CORS流程（来源：Mozilla MDN，授权于Creative Commons）
- en: Our middleware wraps the Gorilla Mux CORS middleware to make it a little easier
    for us to provide our CORS whitelisted domains (the domains we’re happy to respond
    to requests on) and all the HTTP methods for those same domains.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的中间件包装了Gorilla Mux CORS中间件，使我们更容易提供我们的CORS白名单域名（我们愿意响应请求的域名）以及这些域的所有HTTP方法。
- en: JSON middleware
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON中间件
- en: Another piece of middleware that is functionally needed to enforce our requirements
    for an API-powered application is JSON middleware. **JSON**, short for **Javascript
    Object Notation**, is an open standard file format that is used to represent data
    in a key-value pair and arrays.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个功能上需要的中间件是JSON中间件，用于强制执行我们为API应用程序设定的要求。**JSON**，即**JavaScript对象表示法**，是一个开放标准文件格式，用于以键值对和数组的形式表示数据。
- en: JSON middleware uses HTTP headers to check what kind of data is being sent in
    a request. It checks the `Content-Type` header key, which should contain the `application/json`
    value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JSON中间件使用HTTP头检查请求中发送的数据类型。它检查`Content-Type`头键，该键应该包含`application/json`值。
- en: If it cannot find the value that it requires, then the middleware will check
    the value of the `Accept` header to see whether it can find the `application/json`
    value. Once the check is done and it cannot find the value that it is looking
    for, it replies that it’s not a suitable content type for us to work with. We
    also add that header to our `ResponseWriter` so that we can ensure we’re telling
    the consumer we only support JSON and send that back to them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它找不到所需的值，那么中间件将检查`Accept`头的值，看看是否可以找到`application/json`值。一旦检查完成并且找不到它正在寻找的值，它就会回复说这不是我们工作的合适内容类型。我们还添加了该头到我们的`ResponseWriter`中，这样我们就可以确保我们告诉消费者我们只支持JSON，并将它发送回他们。
- en: 'The following code snippet shows the JSON middleware:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了JSON中间件：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Line 14 checks whether the Content-Type header contains an `application/json`
    value; otherwise, it will return an error as part of the response (line 15).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第14行检查Content-Type头是否包含`application/json`值；如果不是，它将作为响应的一部分返回错误（第15行）。
- en: Now that we understand the concept of middleware, we’ll develop some middleware
    to make handling our sessions easier.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了中间件的概念，我们将开发一些中间件来简化我们的会话处理。
- en: Session middleware
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话中间件
- en: 'This session middleware does not fit into our `api` package as it’s closely
    tied to our session-handling functionality, as shown in the following code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个会话中间件不适合我们的`api`包，因为它与我们的会话处理功能紧密相关，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What the preceding middleware does is attempt to retrieve our session from `cookiestore`
    (line 1), which we covered in the previous chapter. From the returned session
    map, we perform an assertion on two values (line 7) that assigns `userID` the
    `int64` value and the Boolean `userIDOK`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的中间件所做的是尝试从`cookiestore`（第1行）中检索我们的会话，这部分我们在上一章中已经讨论过。从返回的会话映射中，我们在第7行对两个值进行断言，将`userID`赋值为`int64`类型，以及布尔值`userIDOK`。
- en: Finally, if everything checks out, including a check of the database for the
    user, we use `context.WithValue()` (line 19) to provide a new context with our
    `sessionKey`, which is a unique type to our package.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切检查无误，包括对用户数据库的检查，我们使用 `context.WithValue()`（第 19 行）提供一个带有我们的 `sessionKey`
    的新上下文，这是我们包中唯一的类型。
- en: We then provide a simple function called `userFromSession` that our handlers
    can call to check the validity of the key type and the incoming session data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提供了一个简单的函数 `userFromSession`，我们的处理程序可以调用它来检查键类型的有效性和传入的会话数据。
- en: In this section, we learned about middleware and looked at adding different
    types of middleware to an application. Also, we looked at CORS and how it works
    when developing web applications. In the next section, we will look in more detail
    at JSON and use models to represent JSON for requests and responses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了中间件，并探讨了向应用程序添加不同类型的中间件。我们还探讨了 CORS 以及在开发 Web 应用程序时它的工作方式。在下一节中，我们将更详细地探讨
    JSON，并使用模型来表示请求和响应的 JSON。
- en: Converting to and from JSON
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为和从 JSON
- en: In this section, we will look at getting and sending data from and to JSON.
    We will also look at creating a structure to handle data and how the JSON conversion
    is done.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨从和向 JSON 获取和发送数据。我们还将探讨创建一个结构来处理数据以及如何进行 JSON 转换。
- en: When dealing with JSON in Golang via the standard library, we’ve got two primary
    options –`json.Marshal/Unmarshal` and `json.NewEncoder(io.Writer)/NewDecoder(io.Reader)`.
    In this chapter, we will look at using the `Encoder`/`Decoder` methods. The reason
    for using these methods is that we can chain a function to the encoder/decoder
    that’s returned and call the `.Encode` and `.Decode` functions with ease. Another
    benefit of this approach is that it uses the streaming interface (namely `io.Reader`
    and `io.Writer`, used to represent an entity from/to which you can read or write
    a stream of bytes – the `Reader` and `Writer` interfaces are accepted as input
    and output by many utilities and functions in the standard library), so we have
    other choices than `Marshal`, which works with preallocated bytes, meaning we’re
    more efficient with our allocations and also faster.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Golang 标准库处理 JSON 时，我们有两个主要选项——`json.Marshal/Unmarshal` 和 `json.NewEncoder(io.Writer)/NewDecoder(io.Reader)`。在本章中，我们将探讨使用
    `Encoder`/`Decoder` 方法。使用这些方法的原因在于我们可以将一个函数链接到返回的编码器/解码器上，并轻松地调用 `.Encode` 和 `.Decode`
    函数。这种方法的另一个好处是它使用了流式接口（即 `io.Reader` 和 `io.Writer`，用于表示可以从中读取或写入字节流的对象——`Reader`
    和 `Writer` 接口被标准库中的许多实用程序和函数作为输入和输出接受），因此我们除了 `Marshal`（它使用预分配的字节）之外还有其他选择，这意味着我们在分配上更加高效，而且速度也更快。
- en: Defining request model
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义请求模型
- en: Data that flows through our application will be wrapped inside a struct. A struct
    is a structure that is defined to hold data. This makes it easier to transport
    data across different parts of the application; it does not make sense, if you
    have to transport 10 different pieces of data to different parts of the application,
    to do this by calling a function with 10 parameters, but if it is inside a struct,
    the function will only have to accept one parameter of that type. For simplicity,
    structs that hold data are also called models, as the field defined inside the
    struct is modeled on the data that it represents.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中流动的数据将被封装在一个结构体中。结构体是一个定义用来保存数据的结构。这使得在不同部分之间传输数据变得更加容易；如果你需要将 10 个不同的数据片段传输到应用程序的不同部分，通过调用一个带有
    10 个参数的函数来做这件事是没有意义的，但如果它在一个结构体内部，该函数只需要接受一个该类型的参数。为了简单起见，保存数据的结构体也被称为模型，因为结构体内部定义的字段是根据它所表示的数据来建模的。
- en: 'Let’s take a look at the model that we defined to wrap the login data (username
    and password) in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中定义的用于封装登录数据（用户名和密码）的模型：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As seen in the preceding code, the `loginRequest` model is declared with a
    `json:"username"` definition. This tells the standard library JSON converter the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`loginRequest` 模型使用 `json:"username"` 定义声明。这告诉标准库 JSON 转换器以下内容：
- en: '`username` – the key name used when converted to a JSON string'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username` – 转换为 JSON 字符串时使用的键名'
- en: '`omitempty` – if the value is empty, the key will not be included in the JSON
    string'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`omitempty` – 如果值是空的，则该键将不会包含在 JSON 字符串中'
- en: More information can be found at [https://pkg.go.dev/encoding/json#Marshal](https://pkg.go.dev/encoding/json#Marshal),
    where you can see the different configurations that a model can have to convert
    from/to JSON.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在[https://pkg.go.dev/encoding/json#Marshal](https://pkg.go.dev/encoding/json#Marshal)找到，在那里您可以查看模型可以具有的不同配置，以从/转换为JSON。
- en: 'Now that we have defined the model inside the function, we want to use it.
    The `handleLogin` function uses the `Decode` function that exists inside the `json`
    standard library to decode the data, as shown in the following snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在函数内部定义了模型，我们想要使用它。`handleLogin`函数使用存在于`json`标准库中的`Decode`函数来解码数据，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once successfully converted, the code can use the `payload` variable to access
    the values that were passed as part of the HTTP request.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功转换，代码可以使用`payload`变量来访问作为HTTP请求一部分传递的值。
- en: 'Let’s take a look at another model that the code defines to store exercise
    set information that is passed by the user. The way to convert the data into `newSetRequest`
    is the same as `loginRequest` using the `Decode` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码定义的另一个模型，用于存储用户传递的锻炼集合信息。将数据转换为`newSetRequest`的方式与`loginRequest`相同，使用`Decode`函数：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function declares a new struct (line 6) called `newSetRequest`, and this
    will be populated by calling the `json.NewDecoder()` function (line 12), which
    will be populated into the `payload` (line 11) variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明了一个新的结构体（第6行）称为`newSetRequest`，它将通过调用`json.NewDecoder()`函数（第12行）来填充，该函数将填充到`payload`（第11行）变量中。
- en: In this section, we looked at using a model to host the information that is
    passed by the user. In the next section, we will look at sending responses back
    using the model.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们查看使用模型来托管用户传递的信息。在下一节中，我们将查看使用模型发送响应。
- en: Defining a response model
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义响应模型
- en: In this section, we will look at how to use a model to host information that
    will be sent back as a response to the user. In [*Chapter 1*](B18295_01.xhtml#_idTextAnchor016),
    *Building the Database and Model*, we learned about sqlc tools that generate the
    different database models that will be used by our application. We will use the
    same database model defined by sqlc, converted to a JSON string as a response
    back to the user. The `json` package library is smart enough to convert models
    into JSON strings.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看如何使用模型来托管将作为响应发送给用户的信息。在[*第1章*](B18295_01.xhtml#_idTextAnchor016)，*构建数据库和模型*中，我们学习了sqlc工具，它生成我们将要使用应用程序的不同数据库模型。我们将使用sqlc定义的相同数据库模型，将其转换为JSON字符串作为对用户的响应。`json`包库足够智能，可以将模型转换为JSON字符串。
- en: 'Let’s look at the response sent back when a user creates a new workout – in
    this case, the `handleAddSet` function, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当用户创建一个新的锻炼计划时返回的响应——在这个例子中，是`handleAddSet`函数，如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the function calls the `CreateDefaultSetForExercise` function
    and uses the `set` variable as a response back to the user by using the `Encode`
    function. The returned set variable is of type `GowebappSet`, which is defined
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数调用了`CreateDefaultSetForExercise`函数，并使用`set`变量作为响应通过`Encode`函数发送给用户。返回的`set`变量是`GowebappSet`类型，其定义如下：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the model is converted using `Encode` and sent back as a response, this
    is how it will look:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型使用`Encode`转换并发送作为响应时，它将看起来是这样的：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this section, we looked at a model generated by sqlc that is not only used
    to host read/write data to and from a database but also used to send responses
    back to the user as a JSON string. In the next section, we will look at another
    important feature that we need to add to the application, error handling, which
    will be reported using JSON.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们查看了一个由sqlc生成的模型，它不仅用于在数据库中读取/写入数据，而且还用于将响应作为JSON字符串发送给用户。在下一节中，我们将探讨需要添加到应用程序中的另一个重要功能，即错误处理，它将使用JSON进行报告。
- en: Reporting errors with JSON
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON报告错误
- en: 'There are many ways to handle errors when writing web applications. In our
    sample application, we handle errors to inform users of what’s happening with
    their request. When reporting errors to users about their request, remember not
    to expose too much information about what’s happening to the system. The following
    are some examples of error messages reported to users that contain such information:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Web应用程序时，处理错误有许多方法。在我们的示例应用程序中，我们处理错误以通知用户他们的请求发生了什么。在向用户报告关于他们请求的错误时，请记住不要过多地暴露有关系统正在发生的事情的信息。以下是一些包含此类信息的错误消息示例，报告给用户：
- en: There is a connection error to the database
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username and password are not valid for connecting to the database
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username validation failed
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password cannot be converted to plain text
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding JSON error use cases are normally used in scenarios where more
    information needs to be provided to the frontend to inform users. Simpler error
    messages containing error codes can also be used.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Using JSONError
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standardizing error messages is as important as writing proper code to ensure
    application maintainability. At the same time, it makes it easier for others to
    read and understand your code when troubleshooting.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'In our sample application, we will use JSON to wrap error messages that are
    reported to the user. This ensures consistency in the format and content of the
    error. The following code snippet can be found inside the `internal/api/wrappers.go`
    file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `JSONError` function will use the passed `errorCode` parameter and `errorMessages(line
    1)` as part of the JSON reported to the user – for example, let’s say we call
    the `/login` endpoint with the wrong credentials using the following cURL command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will get the following JSON error message:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The error is constructed by using the struct that is defined when encoding the
    JSON string (line 14).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Using JSONMessage
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample application uses JSON not only for reporting error messages but
    also for reporting successful messages. Let’s take a look at the output of a successful
    message. Log in using the following cURL command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will get output that looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the `session-name` token, use the following cURL command to create a
    workout:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On successfully creating the workout, you will see a JSON message that looks
    like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at creating and leveraging our own middleware
    for session handling as well as enforcing JSON usage on our API. We’ve also reworked
    our project to use a common package layout to help separate our concerns and set
    ourselves up for future work and iteration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Also in this chapter, we’ve introduced a number of helper functions, including
    two for creating and reporting errors and messages to the user via JSON and an
    API package to abstract our server handling, making it easy to understand and
    preparing us to accommodate CORS.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss writing frontends in more detail and learn
    how to write frontend applications using a frontend framework.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Single-Page Apps with Vue and Go
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 3*, we introduce frontend frameworks before diving into how we can
    combine Vue with Go and explore different frontend technologies to power our sample
    applications. We will look at implementing **Cross-Origin Resource Sharing** (**CORS**)
    and using JWT for sessions in our application to simplify and secure our app from
    bad actors!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18295_07.xhtml#_idTextAnchor128)*, Frontend Frameworks*'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18295_08.xhtml#_idTextAnchor153)*, Frontend Libraries*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18295_09.xhtml#_idTextAnchor184)*, Tailwind, Middleware, and
    CORS*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18295_09.xhtml#_idTextAnchor184)*，Tailwind，中间件和CORS*'
- en: '[*Chapter 10*](B18295_10.xhtml#_idTextAnchor198)*, Session Management*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18295_10.xhtml#_idTextAnchor198)*，会话管理*'
