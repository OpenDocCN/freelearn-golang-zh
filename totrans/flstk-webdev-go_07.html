<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer055">
<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor128"/>7</h1>
<h1 id="_idParaDest-92"><a id="_idTextAnchor129"/>Frontend Frameworks</h1>
<p>In this chapter, we will take a high-level look at the current JavaScript frameworks available to modern web developers. We will compare some of the popular ones, Svelte, React, and Vue, before creating a simple app in Vue and ending by adding navigation using the popular Vue Router. This will lay the foundations needed to later talk to our API server from <a href="B18295_06.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Moving </em><span class="No-Break"><em class="italic">to API-First</em></span><span class="No-Break">.</span></p>
<p> Upon completion of this chapter, we will have covered <span class="No-Break">the following:</span></p>
<ul>
<li>Understanding the difference between server-side rendering and <span class="No-Break">single-page applications</span></li>
<li>Looking at different <span class="No-Break">frontend frameworks</span></li>
<li>Creating applications using the <span class="No-Break">Vue framework</span></li>
<li>Understanding routing inside the <span class="No-Break">Vue framework</span></li>
</ul>
<p>This chapter paves the way to the land of the frontend. We will learn about the different parts of frontend development in this and the <span class="No-Break">next chapters.</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor130"/>Technical requirements</h1>
<p>All the source code used in this chapter can be checked out <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07</span></a><span class="No-Break">.</span></p>
<p>Make sure you have all the necessary tools installed on your local machine by following the instructions from the <span class="No-Break">Node.js documentation:</span><a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm"><span class="No-Break">https://docs.npmjs.com/downloading-and-installing-node-js-and-npm</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor131"/>Server-side rendering versus single-page apps</h1>
<p>In <a href="B18295_04.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Serving and Embedding HTML Content</em>, we created our app as a server-side rendered app. What this means is that all of the content and assets, including the HTML, are generated on the backend and sent on each page request. There’s nothing wrong with this; our publisher, Packt, uses <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>) for <a id="_idIndexMarker254"/>its own site at <a href="https://www.packtpub.com/">https://www.packtpub.com/</a>. SSR as a technique is used by technologies such as WordPress and many other sites that host content that changes less frequently and may have <span class="No-Break">less interactivity.</span></p>
<p>The alternative to SSR we’re going to use for our<a id="_idIndexMarker255"/> app is <strong class="bold">client-side rendering</strong> (<strong class="bold">CSR</strong>). CSR works by having the client fetch the app as a <em class="italic">bundle</em> of JavaScript and other assets, executing the JavaScript and the app dynamically, and binding to an element that takes over the page rendering. The app creates and renders each route dynamically in the browser. This is all done without requiring any reloading of the bundle <span class="No-Break">or content.</span></p>
<p>By moving to client-side rendering, it improves the app's interactivity and responsiveness by allowing it to manipulate the document model, fetch additional content and data via the API, and generally perform closer to what a user might expect from a desktop app without constant <span class="No-Break">page reloads.</span></p>
<p>When we talk about reactivity, we’re describing the situation in which changes in the application state are automatically reflected in <a id="_idIndexMarker256"/>the <strong class="bold">document object model</strong> (<strong class="bold">DOM</strong>). This is a key attribute of all of the frameworks we’ll be exploring in this chapter, including React, Vue, <span class="No-Break">and Svelte.</span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor132"/>Introducing React, Vue, and more</h1>
<p>If there’s one thing that the JavaScript community enjoys doing, it’s creating <span class="No-Break">new frameworks!</span></p>
<p>We’re going to explore and contrast a few of the most popular ones and look at the common parts they all share and the main points <span class="No-Break">of differenc<a id="_idTextAnchor133"/>e.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor134"/>React</h2>
<p>React<a id="_idIndexMarker257"/> is one of the most popular JavaScript libraries available. It was created, and is still maintained, by Meta (formerly Facebook) and was inspired heavily by a predecessor used internally within Facebook for creating <span class="No-Break">PHP components.</span></p>
<p>React uses <a id="_idIndexMarker258"/>the <strong class="bold">JavaScript Syntax eXtension</strong> (<strong class="bold">JSX</strong>) as a syntax, which looks like a combination of HTML and <a id="_idIndexMarker259"/>Java Script. Although you can use React without compilation, most React developers are used to the process common to most modern frameworks, which is to combine and build the source files, the <strong class="source-inline">.jsx</strong> and <strong class="source-inline">.vue</strong> files, and build them into a final bundle that can be deployed as a static file. We’ll look at this in a <span class="No-Break">later chapter.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 7.1: Modern JavaScript SPA build process" height="271" src="image/Figure_7.01_B18295.jpg" width="604"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Modern JavaScript SPA build process</p>
<p>React is a very popular option for creating apps and one of its strengths is the fact that there are a number of different options to choose from when building your app, such as Redux, Flux, BrowserRouter, or React Router. This flexibility is great but can cause conflict and strong opinions on the “one true way.” The React team avoids this issue by continually calling out that React is a library, not a framework, so choosing the components of your app is down to <span class="No-Break">the individual.</span></p>
<p>React<a id="_idIndexMarker260"/> is similar to other frameworks in that it has a full life cycle model that can be “hooked” at runtime to override defaults (for example, <strong class="source-inline">render</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">shouldComponentUpda<a id="_idTextAnchor135"/>te</strong></span><span class="No-Break">).</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor136"/>Svelte</h2>
<p>Svelte <a id="_idIndexMarker261"/>straddles an interesting middle ground and is included as an alternative to the two heavy hitters of React and Vue. Svelte takes the approach of pushing more into the compilation step, removing the need for techniques such as diffing the virtual DOM to transpile the code into vanilla JavaScript. This approach means less work is done by the browser but it still has a similar build process to both React and Vue for building bundles. Svelte provides its own preferred router, called SvelteKit, but alternatives exist and Svelte can represent a nice, lightweight alternative to the others. Svelte is quite a new project when looking at the more established players and doesn’t have as many resources behind it, but it is still viable for <span class="No-Break">smaller pro<a id="_idTextAnchor137"/>jects.</span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor138"/>Vue</h2>
<p>The final framework we’re going to<a id="_idIndexMarker262"/> introduce is Vue, which is what we use as our preferred framework for building our <span class="No-Break">frontend application.</span></p>
<p>The big appeal initially for me was the fact that the previous version of Vue (version 2) could be loaded and run directly via<a id="_idIndexMarker263"/> a <strong class="bold">content domain network</strong> (<strong class="bold">CDN</strong>), which made experimentation and prototyping incredibly easy back in 2016 when it was <span class="No-Break">first released.</span></p>
<p>Vue offers a very familiar syntax that makes it easy to learn – it separates out the presentation from the logic and the <a id="_idIndexMarker264"/>styling, it’s very lightweight, and it uses the concept of <strong class="bold">single-file </strong><span class="No-Break"><strong class="bold">components</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SFCs</strong></span><span class="No-Break">).</span></p>
<p>The concept of SFC makes it incredibly easy to build simple, scoped components that can be reused from project to project without the addition of learning the “not-quite-JavaScript” JSX used <span class="No-Break">by React.</span></p>
<p>The following code is a simple component that displays a greeting using the Options API. When Vue was first released, it used the Options API by default, but in later iterations, it has moved to include a newer Composition API, which we’ll <span class="No-Break">explore later:</span></p>
<pre class="source-code">
&lt;template&gt;
  &lt;div&gt;
    &lt;Thing @click="greetLog" /&gt;
    &lt;p class="greeting"&gt;{{ greeting }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Thing from '@/components/thing.vue';
export default {
  name: 'Greeter',
  components: ['Thing'],
  props:{},
  mounted(){},
  methods: {
    greetLog() {  console.log('Greeter') };
  },
  data() {
    return {
      greeting: 'Hello World!'
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;
.greeting {
  color: red;
  font-weight: bold;
}
&lt;/style&gt;</pre>
<p><strong class="bold">Example of a </strong><span class="No-Break"><strong class="bold">SFC Greeter.vue</strong></span></p>
<p>As you can see in the <a id="_idIndexMarker265"/>preceding code block, the approach of Vue’s SFC design has three parts: the HTML, the JavaScript, and the style (usually CSS, often “scoped”). This means you can combine the HTML<strong class="source-inline">-esque</strong> style of the <strong class="source-inline">&lt;template&gt;</strong> with small Vue-specific additions, such as <strong class="source-inline">@click="functionName"</strong>, to easily create our  components. The <strong class="source-inline">@click</strong> annotation featured here, which looks close to HTML, is the syntax used by Vue to extend and bind HTML events to our objects – in this case, replacing the native <span class="No-Break"><strong class="source-inline">onClick</strong></span><span class="No-Break"> attribute.</span></p>
<p>The <strong class="source-inline">&lt;script&gt;</strong> contained instance includes a name; props, used to provide properties to the component from parents;  <strong class="source-inline">mounted()</strong>, a function called when the component is first added to the DOM; components, that is, the components being imported for use by the component; assorted other methods; and finally, the <strong class="source-inline">data()</strong> object, which can hold our <span class="No-Break">components' state.</span></p>
<p>The final part of the SFC is the <strong class="source-inline">&lt;style&gt;</strong> part – we can specify non-CSS languages here. For example,  we could use <strong class="source-inline">lang="scss"</strong> if we wanted to use SCSS rather than CSS. We can also add the <strong class="source-inline">scoped</strong> keyword, which means that Vue will use name mangling to ensure that our CSS styles are scoped only to this <span class="No-Break">component instance.</span></p>
<p>A final benefit of using Vue is the opinionated approach taken to build tools (preferring to create Vite, which leverages the incredibly fast esbuild to reduce bundle build times to milliseconds compared to the slower React), component layout, and routers (Vue Router), which we’ll explore in later chapters. The opinionated nature of Vue works nicely with the opinionated nature of Golang itself, which helps remove a lot of debate on which approach and components to choose to build your app, ensuring that when you bring in more team members and hand over your successful full stack app, you can be safe in the knowledge that another Vue developer wouldn’t argue with you on how you did it, nor on the technology chosen – mainly as they would’ve chosen <span class="No-Break">the same!</span></p>
<p>So far in this section, we have looked at what the Vue framework is all about. In the next section, we will learn by creating some simple apps using the <span class="No-Break">Vue <a id="_idTextAnchor139"/>framework.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor140"/>Creating a Vue app</h1>
<p>In the previous section, we <a id="_idIndexMarker266"/>discussed different frontend frameworks, so for this section, we are going to try to use Vue to build our frontend. In this section, we will look at writing our UI in Vue and discuss how we migrate the login page to Vue. This section will not teach you how to use Vue but rather will look at the way we use Vue to write the frontend components for our <span class="No-Break">sample ap<a id="_idTextAnchor141"/>plication.</span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor142"/> Application and components</h1>
<p>When writing software using Vue, the application will start up by creating an application instance. This instance is the main object in our Vue-based application. Once we have an instance, then we can start using<a id="_idIndexMarker267"/> components. Components are reusable UI pieces that contain three parts – a template (which is like HTML), styles, and JavaScript. Normally, when designing a frontend, we think about HTML elements –  div,  href, and so on – but now we need to think about components that contain all the different parts. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em> shows an example of the login page that we rewrite <span class="No-Break">using Vue.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 7.2: Vue-based login" height="198" src="image/Figure_7.02_B18295.jpg" width="239"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Vue-based login</p>
<p>The concept of an <a id="_idIndexMarker268"/>application inside Vue can be thought of as a self-isolated container containing different components that can share data. Any web page can contain a number of applications displaying different kinds of data, and even if they are isolated, they can also share data if and <span class="No-Break">wh<a id="_idTextAnchor143"/>en required.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor144"/>Login page using Vue</h2>
<p>In this section, we will <a id="_idIndexMarker269"/>look at how we use the login page as is without converting it into a component and use it as a Vue application rendered by the browser. We need to install the dependencies first by running the <span class="No-Break">following command:</span></p>
<pre class="console">
npm install</pre>
<p>This will install all the different dependencies, including the <strong class="source-inline">http-server</strong> module, which we will be using to serve the login page. Start the server by running the following command, making sure you are inside the <span class="No-Break"><strong class="source-inline">chapter7/login</strong></span><span class="No-Break"> directory:</span></p>
<pre class="console">
npm run start</pre>
<p> You will see the output shown in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 7.3: Serving using http-server" height="223" src="image/Figure_7.03_B18295.jpg" width="295"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Serving using http-server</p>
<p>Open your browser and type http://127.0.0.1:3000/login.xhtml into the address bar, and you will see the <span class="No-Break">login page.</span></p>
<p>Let’s dig through the code and see how it works together. The following snippet inside <strong class="source-inline">login.xhtml</strong> shows the application <span class="No-Break">initialization code:</span></p>
<pre class="source-code">
&lt;script type="module"&gt;
   import {createApp} from 'vue'
   const app = createApp({
       data() {
           return {
               loginText: 'Login to your account',
               ...
           }
       },
       methods: {
           handleSubmit: function () {
               ...
           }
       }
   }).mount('#app')
&lt;/script&gt;</pre>
<p>The code<a id="_idIndexMarker270"/> imports <strong class="source-inline">createApp</strong> from the Vue library and uses it to create an application that contains <strong class="source-inline">data()</strong> and <strong class="source-inline">methods</strong> used inside the page. The <strong class="source-inline">data()</strong> block declares the variables that will be used inside the page while <strong class="source-inline">methods</strong> contains functions used. The application is mounted into the element with the ID “app” app, in this case, the <strong class="source-inline">&lt;div&gt;</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">id=app</strong></span><span class="No-Break">.</span></p>
<p>The following code snippet shows the part of the page that uses <span class="No-Break">the data:</span></p>
<pre class="source-code">
&lt;body class="bg-gray-900"&gt;
           ...
               &lt;p class="text-xs text-gray-50"&gt;{{ loginText
                 }}&lt;/p&gt;
           ...
               &lt;p class="text-xs text-gray-50"&gt;
                 {{ emailText }}&lt;/p&gt;
           ...
               &lt;p class="text-xs font-bold text-white"&gt;
                 {{ passwordText }}&lt;/p&gt;
               ...
&lt;/body&gt;</pre>
<p>The variable inside the curly brackets (<strong class="source-inline">{{}}</strong>) will be populated with the data defined previously when we initialize <span class="No-Break">the application.</span></p>
<p>The following code<a id="_idIndexMarker271"/> snippet shows the part of the page that uses the <span class="No-Break"><strong class="source-inline">handleSubmit</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
&lt;body class="bg-gray-900"&gt;
                   ...
               &lt;button @click="handleSubmit"
                       class="px-4 pt-2 pb-2.5 w-full
                              rounded-lg bg-red-500
                              hover:bg-red-600"&gt;
                   ...
&lt;/body&gt;</pre>
<p><strong class="source-inline">@click</strong> on the button element will trigger the function that was defined when creating the Vue application object, which will write to the console log the data in the <span class="No-Break">u<a id="_idTextAnchor145"/>sername field.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor146"/>Using Vite</h2>
<p>Referring back to <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em>, one of the<a id="_idIndexMarker272"/> parts of the build process is that of the bundler. In this section, we will look at Vite, which is a bundler for Vue. What is a bundler? It is a build tool that combines all your different assets (HTML, CSS, and so on) into one file, making it easy <span class="No-Break">for distribution.</span></p>
<p>In the previous section, we linked to a CDN-hosted version of the Vue runtime. In this section, we’ll be using Vite to build our application and generate our <span class="No-Break">bundled code.</span></p>
<p>Vite – French for “quick” – was built by the same team behind Vue itself and was designed to provide a faster development experience with extremely fast hot reload and combine it with a powerful build stage that transpiles, minifies, and bundles your code into optimized static assets ready for deployment. Refer back to <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em> to see all the stages used to <span class="No-Break">build SPAs.</span></p>
<p>In this section, we will look at writing our login page as a component and using it as a Vue application rendered by the browser. The code can be seen inside the <span class="No-Break"><strong class="source-inline">chapter7/npmvue</strong></span><span class="No-Break"> folder.</span></p>
<p>Open your terminal and run the <span class="No-Break">following commands:</span></p>
<pre class="console">
npm install
npm run dev</pre>
<p>Once the server is up and running, you will get the output shown in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 7.4: Vite server output" height="108" src="image/Figure_7.04_B18295.jpg" width="237"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Vite server output</p>
<p>Open the browser and access the login page by entering <strong class="source-inline">http://localhost:3000</strong> into the address bar. Let’s investigate further and look at how the code is structured. We will start by looking at the <strong class="source-inline">index.xhtml</strong> page, as shown in the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
 &lt;head&gt;
   ...
 &lt;/head&gt;
 &lt;body&gt;
   &lt;div id="app"&gt;&lt;/div&gt;
   &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre>
<p>The preceding <strong class="source-inline">index.xhtml</strong> references the <strong class="source-inline">main.js</strong> script, which is how we inject the Vue <span class="No-Break">initialization code.</span></p>
<p>The <strong class="source-inline">&lt;div..&gt;</strong> declaration is <a id="_idIndexMarker273"/>where the application will be mounted when rendered in the browser, and the page also includes a script found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/main.js</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">main.js</strong> contains the Vue application initialization code, <span class="No-Break">as shown:</span></p>
<pre class="source-code">
import { createApp } from 'vue'
import App from './App.vue'
createApp(App).mount('#app')</pre>
<p><strong class="source-inline">createApp</strong> will create an application using the <strong class="source-inline">App</strong> object imported from <strong class="source-inline">App.vue</strong>, which will be the starting component for our application. Vue-related code is normally stored inside a file with the <strong class="source-inline">.vue</strong> extension. The <strong class="source-inline">App.vue</strong> file acts as an app container that hosts the components that it will use. In this case, it will use the <strong class="source-inline">Login</strong> component, as shown in the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
&lt;script setup&gt;
import Login from './components/Login.vue'
&lt;/script&gt;
&lt;template&gt;
   &lt;Login /&gt;
&lt;/template&gt;</pre>
<p>The <strong class="source-inline">&lt;script setup&gt;</strong> tag is known as the Composition API, which is a set of APIs that allows Vue components to be imported. In our case, we are importing the components from the <span class="No-Break"><strong class="source-inline">Login.vue</strong></span><span class="No-Break"> file.</span></p>
<p>The code imports the <strong class="source-inline">Login.Vue</strong> file as a component and uses it inside the <strong class="source-inline">&lt;template&gt;</strong> block. Looking at the <strong class="source-inline">Login.vue</strong> file, you will see that it contains the HTML elements to create the <span class="No-Break">login page.</span></p>
<p>The <strong class="source-inline">Login.vue</strong> snippet can <a id="_idIndexMarker274"/>be seen in the following <span class="No-Break">code block:</span></p>
<pre class="source-code">
&lt;script&gt;
export default {
 data() {
   return {
     loginText: 'Login to your account',
     ...
   }
 },
 methods: {
   handleSubmit: function () {
     ...
   }
 }
}
&lt;/script&gt;
&lt;style&gt;
@import "../assets/minified.css";
&lt;/style&gt;
&lt;template&gt;
   ...
       &lt;button @click="handleSubmit"
               class="px-4 pt-2 pb-2.5 w-full rounded-lg
                      bg-red-500 hover:bg-red-600"&gt;
     ...
&lt;/template&gt;</pre>
<p>The class used for the<a id="_idIndexMarker275"/> button in the preceding example is declared inside a <strong class="source-inline">minified.css</strong> file inside the <span class="No-Break"><strong class="source-inline">assets</strong></span><span class="No-Break"> folder.</span></p>
<p>We have learned how to create apps using the Vue framework and wired all the different components together. We also looked at how to use the Vite tool to write a Vue-based application. In the next section, we will look at routing requests to differen<a id="_idTextAnchor147"/>t <span class="No-Break">Vue components.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor148"/>Using Vue Router to move around</h1>
<p>In this section, we will look at Vue Router and learn how to use it. Vue Router helps in structuring the frontend code when<a id="_idIndexMarker276"/> designing a <strong class="bold">single-page application</strong> (<strong class="bold">SPA</strong>). An SPA is a web application that is presented to the user as a single HTML page, which makes it more responsive as the content inside the HTML page is updated without refreshing the page. The SPA requires the use of a router that will route to the different endpoints when updating data from <span class="No-Break">the backend.</span></p>
<p>Using a router allows easier<a id="_idIndexMarker277"/> mapping between the URL path and components simulating page navigation. There are two types of routes that can be configured using Vue Router – dynamic and static routes. Dynamic routes are used when the URL path is dynamic based on some kind of data. For example, in <strong class="source-inline">/users/:id</strong>, <strong class="source-inline">id</strong> in the path will be populated with a value, which will be something such as <strong class="source-inline">/users/johnny</strong> or <strong class="source-inline">users/acme</strong>. Static routes are routes that do not contain any dynamic data, for example, <strong class="source-inline">/users</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">/orders</strong></span><span class="No-Break">.</span></p>
<p> In this section, we will look at static routes. The examples for this section can be found in the <strong class="source-inline">chapter7/router</strong> folder. Run the following command from the <strong class="source-inline">router</strong> folder to run the <span class="No-Break">sample application:</span></p>
<pre class="console">
npm install
npm run server</pre>
<p>The command will run a <a id="_idIndexMarker278"/>server listening on port <strong class="source-inline">8080</strong>. Open your browser and enter <strong class="source-inline">http://localhost:8080</strong> in the address bar. You will see the output shown in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 7.5: Router sample application" height="208" src="image/Figure_7.05_B18295.jpg" width="602"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: Router sample application</p>
<p>The <strong class="source-inline">App.vue</strong> file contains the Vue Router information, which can be seen <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;template&gt;
 &lt;div id="routerdiv"&gt;
   &lt;table&gt;
      ...
         &lt;router-link :to="{ name: 'Home'}"&gt;Home
         &lt;/router-link&gt;
      ...
         &lt;router-link :to="{ name: 'Login'}"&gt;Login
         &lt;/router-link&gt;
      ...
   &lt;/table&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
 &lt;/div&gt;
&lt;/template&gt;</pre>
<p>The preceding <strong class="source-inline">router-link</strong> route is defined inside <strong class="source-inline">router/index.js</strong>, <span class="No-Break">as shown:</span></p>
<pre class="source-code">
const routes = [
   {
       path: '/',
       name: 'Home',
       component: Home
   },
   {
       path: '/login',
       name: 'Login',
       component: Login
   },
];</pre>
<p>The <strong class="source-inline">&lt;router-link/&gt;</strong> tag defines<a id="_idIndexMarker279"/> the router configuration that the application has, and in our case, this is pointing to the <strong class="source-inline">Home</strong> and <strong class="source-inline">Login</strong> components declared inside the <strong class="source-inline">index.js</strong> file under the <strong class="source-inline">router</strong> folder, <span class="No-Break">as shown:</span></p>
<pre class="source-code">
import Vue from 'vue';
import { createRouter, createWebHashHistory } from 'vue-router'
import Home from '../views/Home.vue';
import Login from "../views/Login.vue";
Vue.use(VueRouter);
const routes = [
   {
       path: '/',
       name: 'Home',
       component: Home
   },
   {
       path: '/login',
       name: 'Login',
       component: Login
   },
];
const router = createRouter({
   history: createWebHashHistory(),
   base: process.env.BASE_URL,
   routes
})
export default router</pre>
<p>Each of the <a id="_idIndexMarker280"/>defined routes is mapped to its respective components, which are the <strong class="source-inline">Home</strong> and <strong class="source-inline">Login</strong> components, which can be found ins<a id="_idTextAnchor149"/>ide the <span class="No-Break"><strong class="source-inline">views</strong></span><span class="No-Break"> folder.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor150"/>Routing the login page</h2>
<p>We know <a id="_idIndexMarker281"/>that the <strong class="source-inline">/login</strong> path is mapped to the <strong class="source-inline">Login</strong> component, which is the same component that we looked at in the previous section, <em class="italic">Login page using Vue</em>. The difference in the router example is in the way the script is defined, <span class="No-Break">as shown:</span></p>
<pre class="source-code">
&lt;template&gt;
 ...
&lt;/template&gt;
&lt;script type="module"&gt;
export default {
 data() {
   return {
     loginText: 'Login to your account',
     emailText: 'Email Address',
     passwordText: 'Password',
     username: 'enter username',
     password: 'enter password',
   };
 },
 methods: {
   handleSubmit: function () {
     console.log(this.$data.username)
   }
 }
};
&lt;/script&gt;</pre>
<p>Unlike in the previous<a id="_idIndexMarker282"/> section, the Vue initialization code has been moved into <strong class="source-inline">main.js</strong>, <span class="No-Break">as shown:</span></p>
<pre class="source-code">
...
const myApp = createApp(App)
myApp.use(router)
myApp.mount('#app')</pre>
<p>In this section, we looked at how to restructure the application to work as a S<a id="_idTextAnchor151"/>PA by using <span class="No-Break">Vue Router.</span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor152"/>Summary</h1>
<p>In this chapter, we learned about Vue and how to structure our frontend to make it easy to transition into components and applications. We looked at the different frontend frameworks and discussed what each of <span class="No-Break">them provides.</span></p>
<p>We looked at how components and applications work together when writing a Vue-based web page. We tested what we learned by migrating the login page that we created as a simple HTML page to a Vue-based application. Lastly, we learned about Vue Router and how to use it to make it easier to route to different parts of <span class="No-Break">a SPA.</span></p>
<p>Taking on board all this learning, in the next chapter, we will look at writing our application as a Vue- based application that will communicate with the REST API that we <span class="No-Break">have built.</span></p>
</div>
</div></body></html>