- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frontend Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a high-level look at the current JavaScript frameworks
    available to modern web developers. We will compare some of the popular ones,
    Svelte, React, and Vue, before creating a simple app in Vue and ending by adding
    navigation using the popular Vue Router. This will lay the foundations needed
    to later talk to our API server from [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093),
    *Moving* *to API-First*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completion of this chapter, we will have covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between server-side rendering and single-page applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at different frontend frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating applications using the Vue framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding routing inside the Vue framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter paves the way to the land of the frontend. We will learn about
    the different parts of frontend development in this and the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code used in this chapter can be checked out from [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have all the necessary tools installed on your local machine by
    following the instructions from the Node.js documentation:[https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering versus single-page apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18295_04.xhtml#_idTextAnchor053), *Serving and Embedding HTML
    Content*, we created our app as a server-side rendered app. What this means is
    that all of the content and assets, including the HTML, are generated on the backend
    and sent on each page request. There’s nothing wrong with this; our publisher,
    Packt, uses **server-side rendering** (**SSR**) for its own site at [https://www.packtpub.com/](https://www.packtpub.com/).
    SSR as a technique is used by technologies such as WordPress and many other sites
    that host content that changes less frequently and may have less interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to SSR we’re going to use for our app is **client-side rendering**
    (**CSR**). CSR works by having the client fetch the app as a *bundle* of JavaScript
    and other assets, executing the JavaScript and the app dynamically, and binding
    to an element that takes over the page rendering. The app creates and renders
    each route dynamically in the browser. This is all done without requiring any
    reloading of the bundle or content.
  prefs: []
  type: TYPE_NORMAL
- en: By moving to client-side rendering, it improves the app's interactivity and
    responsiveness by allowing it to manipulate the document model, fetch additional
    content and data via the API, and generally perform closer to what a user might
    expect from a desktop app without constant page reloads.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about reactivity, we’re describing the situation in which changes
    in the application state are automatically reflected in the **document object
    model** (**DOM**). This is a key attribute of all of the frameworks we’ll be exploring
    in this chapter, including React, Vue, and Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React, Vue, and more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there’s one thing that the JavaScript community enjoys doing, it’s creating
    new frameworks!
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to explore and contrast a few of the most popular ones and look
    at the common parts they all share and the main points of difference.
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React is one of the most popular JavaScript libraries available. It was created,
    and is still maintained, by Meta (formerly Facebook) and was inspired heavily
    by a predecessor used internally within Facebook for creating PHP components.
  prefs: []
  type: TYPE_NORMAL
- en: React uses the `.jsx` and `.vue` files, and build them into a final bundle that
    can be deployed as a static file. We’ll look at this in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Modern JavaScript SPA build process](img/Figure_7.01_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Modern JavaScript SPA build process'
  prefs: []
  type: TYPE_NORMAL
- en: React is a very popular option for creating apps and one of its strengths is
    the fact that there are a number of different options to choose from when building
    your app, such as Redux, Flux, BrowserRouter, or React Router. This flexibility
    is great but can cause conflict and strong opinions on the “one true way.” The
    React team avoids this issue by continually calling out that React is a library,
    not a framework, so choosing the components of your app is down to the individual.
  prefs: []
  type: TYPE_NORMAL
- en: React is similar to other frameworks in that it has a full life cycle model
    that can be “hooked” at runtime to override defaults (for example, `render` and
    `shouldComponentUpdate`).
  prefs: []
  type: TYPE_NORMAL
- en: Svelte
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Svelte straddles an interesting middle ground and is included as an alternative
    to the two heavy hitters of React and Vue. Svelte takes the approach of pushing
    more into the compilation step, removing the need for techniques such as diffing
    the virtual DOM to transpile the code into vanilla JavaScript. This approach means
    less work is done by the browser but it still has a similar build process to both
    React and Vue for building bundles. Svelte provides its own preferred router,
    called SvelteKit, but alternatives exist and Svelte can represent a nice, lightweight
    alternative to the others. Svelte is quite a new project when looking at the more
    established players and doesn’t have as many resources behind it, but it is still
    viable for smaller projects.
  prefs: []
  type: TYPE_NORMAL
- en: Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final framework we’re going to introduce is Vue, which is what we use as
    our preferred framework for building our frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: The big appeal initially for me was the fact that the previous version of Vue
    (version 2) could be loaded and run directly via a **content domain network**
    (**CDN**), which made experimentation and prototyping incredibly easy back in
    2016 when it was first released.
  prefs: []
  type: TYPE_NORMAL
- en: Vue offers a very familiar syntax that makes it easy to learn – it separates
    out the presentation from the logic and the styling, it’s very lightweight, and
    it uses the concept of **single-file** **components** (**SFCs**).
  prefs: []
  type: TYPE_NORMAL
- en: The concept of SFC makes it incredibly easy to build simple, scoped components
    that can be reused from project to project without the addition of learning the
    “not-quite-JavaScript” JSX used by React.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a simple component that displays a greeting using the
    Options API. When Vue was first released, it used the Options API by default,
    but in later iterations, it has moved to include a newer Composition API, which
    we’ll explore later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Example of a** **SFC Greeter.vue**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding code block, the approach of Vue’s SFC design
    has three parts: the HTML, the JavaScript, and the style (usually CSS, often “scoped”).
    This means you can combine the HTML`-esque` style of the `<template>` with small
    Vue-specific additions, such as `@click="functionName"`, to easily create our
    components. The `@click` annotation featured here, which looks close to HTML,
    is the syntax used by Vue to extend and bind HTML events to our objects – in this
    case, replacing the native `onClick` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<script>` contained instance includes a name; props, used to provide properties
    to the component from parents; `mounted()`, a function called when the component
    is first added to the DOM; components, that is, the components being imported
    for use by the component; assorted other methods; and finally, the `data()` object,
    which can hold our components' state.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the SFC is the `<style>` part – we can specify non-CSS languages
    here. For example, we could use `lang="scss"` if we wanted to use SCSS rather
    than CSS. We can also add the `scoped` keyword, which means that Vue will use
    name mangling to ensure that our CSS styles are scoped only to this component
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: A final benefit of using Vue is the opinionated approach taken to build tools
    (preferring to create Vite, which leverages the incredibly fast esbuild to reduce
    bundle build times to milliseconds compared to the slower React), component layout,
    and routers (Vue Router), which we’ll explore in later chapters. The opinionated
    nature of Vue works nicely with the opinionated nature of Golang itself, which
    helps remove a lot of debate on which approach and components to choose to build
    your app, ensuring that when you bring in more team members and hand over your
    successful full stack app, you can be safe in the knowledge that another Vue developer
    wouldn’t argue with you on how you did it, nor on the technology chosen – mainly
    as they would’ve chosen the same!
  prefs: []
  type: TYPE_NORMAL
- en: So far in this section, we have looked at what the Vue framework is all about.
    In the next section, we will learn by creating some simple apps using the Vue
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Vue app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed different frontend frameworks, so for
    this section, we are going to try to use Vue to build our frontend. In this section,
    we will look at writing our UI in Vue and discuss how we migrate the login page
    to Vue. This section will not teach you how to use Vue but rather will look at
    the way we use Vue to write the frontend components for our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Application and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing software using Vue, the application will start up by creating an
    application instance. This instance is the main object in our Vue-based application.
    Once we have an instance, then we can start using components. Components are reusable
    UI pieces that contain three parts – a template (which is like HTML), styles,
    and JavaScript. Normally, when designing a frontend, we think about HTML elements
    – div, href, and so on – but now we need to think about components that contain
    all the different parts. *Figure 7**.2* shows an example of the login page that
    we rewrite using Vue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Vue-based login](img/Figure_7.02_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Vue-based login'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of an application inside Vue can be thought of as a self-isolated
    container containing different components that can share data. Any web page can
    contain a number of applications displaying different kinds of data, and even
    if they are isolated, they can also share data if and when required.
  prefs: []
  type: TYPE_NORMAL
- en: Login page using Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at how we use the login page as is without converting
    it into a component and use it as a Vue application rendered by the browser. We
    need to install the dependencies first by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install all the different dependencies, including the `http-server`
    module, which we will be using to serve the login page. Start the server by running
    the following command, making sure you are inside the `chapter7/login` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output shown in *Figure 7**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Serving using http-server](img/Figure_7.03_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Serving using http-server'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser and type http://127.0.0.1:3000/login.xhtml into the address
    bar, and you will see the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dig through the code and see how it works together. The following snippet
    inside `login.xhtml` shows the application initialization code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code imports `createApp` from the Vue library and uses it to create an application
    that contains `data()` and `methods` used inside the page. The `data()` block
    declares the variables that will be used inside the page while `methods` contains
    functions used. The application is mounted into the element with the ID “app”
    app, in this case, the `<div>` with `id=app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the part of the page that uses the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The variable inside the curly brackets (`{{}}`) will be populated with the data
    defined previously when we initialize the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the part of the page that uses the `handleSubmit`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`@click` on the button element will trigger the function that was defined when
    creating the Vue application object, which will write to the console log the data
    in the username field.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Vite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referring back to *Figure 7**.1*, one of the parts of the build process is that
    of the bundler. In this section, we will look at Vite, which is a bundler for
    Vue. What is a bundler? It is a build tool that combines all your different assets
    (HTML, CSS, and so on) into one file, making it easy for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we linked to a CDN-hosted version of the Vue runtime.
    In this section, we’ll be using Vite to build our application and generate our
    bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Vite – French for “quick” – was built by the same team behind Vue itself and
    was designed to provide a faster development experience with extremely fast hot
    reload and combine it with a powerful build stage that transpiles, minifies, and
    bundles your code into optimized static assets ready for deployment. Refer back
    to *Figure 7**.1* to see all the stages used to build SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at writing our login page as a component and using
    it as a Vue application rendered by the browser. The code can be seen inside the
    `chapter7/npmvue` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once the server is up and running, you will get the output shown in *Figure
    7**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Vite server output](img/Figure_7.04_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Vite server output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the browser and access the login page by entering `http://localhost:3000`
    into the address bar. Let’s investigate further and look at how the code is structured.
    We will start by looking at the `index.xhtml` page, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `index.xhtml` references the `main.js` script, which is how we
    inject the Vue initialization code.
  prefs: []
  type: TYPE_NORMAL
- en: The `<div..>` declaration is where the application will be mounted when rendered
    in the browser, and the page also includes a script found in `src/main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`main.js` contains the Vue application initialization code, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`createApp` will create an application using the `App` object imported from
    `App.vue`, which will be the starting component for our application. Vue-related
    code is normally stored inside a file with the `.vue` extension. The `App.vue`
    file acts as an app container that hosts the components that it will use. In this
    case, it will use the `Login` component, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `<script setup>` tag is known as the Composition API, which is a set of
    APIs that allows Vue components to be imported. In our case, we are importing
    the components from the `Login.vue` file.
  prefs: []
  type: TYPE_NORMAL
- en: The code imports the `Login.Vue` file as a component and uses it inside the
    `<template>` block. Looking at the `Login.vue` file, you will see that it contains
    the HTML elements to create the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Login.vue` snippet can be seen in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The class used for the button in the preceding example is declared inside a
    `minified.css` file inside the `assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to create apps using the Vue framework and wired all the
    different components together. We also looked at how to use the Vite tool to write
    a Vue-based application. In the next section, we will look at routing requests
    to different Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vue Router to move around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at Vue Router and learn how to use it. Vue Router
    helps in structuring the frontend code when designing a **single-page application**
    (**SPA**). An SPA is a web application that is presented to the user as a single
    HTML page, which makes it more responsive as the content inside the HTML page
    is updated without refreshing the page. The SPA requires the use of a router that
    will route to the different endpoints when updating data from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Using a router allows easier mapping between the URL path and components simulating
    page navigation. There are two types of routes that can be configured using Vue
    Router – dynamic and static routes. Dynamic routes are used when the URL path
    is dynamic based on some kind of data. For example, in `/users/:id`, `id` in the
    path will be populated with a value, which will be something such as `/users/johnny`
    or `users/acme`. Static routes are routes that do not contain any dynamic data,
    for example, `/users` or `/orders`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at static routes. The examples for this section
    can be found in the `chapter7/router` folder. Run the following command from the
    `router` folder to run the sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will run a server listening on port `8080`. Open your browser and
    enter `http://localhost:8080` in the address bar. You will see the output shown
    in *Figure 7**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Router sample application](img/Figure_7.05_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Router sample application'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App.vue` file contains the Vue Router information, which can be seen as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `router-link` route is defined inside `router/index.js`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<router-link/>` tag defines the router configuration that the application
    has, and in our case, this is pointing to the `Home` and `Login` components declared
    inside the `index.js` file under the `router` folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each of the defined routes is mapped to its respective components, which are
    the `Home` and `Login` components, which can be found inside the `views` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Routing the login page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that the `/login` path is mapped to the `Login` component, which is
    the same component that we looked at in the previous section, *Login page using
    Vue*. The difference in the router example is in the way the script is defined,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike in the previous section, the Vue initialization code has been moved
    into `main.js`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we looked at how to restructure the application to work as
    a SPA by using Vue Router.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Vue and how to structure our frontend to make
    it easy to transition into components and applications. We looked at the different
    frontend frameworks and discussed what each of them provides.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how components and applications work together when writing a Vue-based
    web page. We tested what we learned by migrating the login page that we created
    as a simple HTML page to a Vue-based application. Lastly, we learned about Vue
    Router and how to use it to make it easier to route to different parts of a SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Taking on board all this learning, in the next chapter, we will look at writing
    our application as a Vue- based application that will communicate with the REST
    API that we have built.
  prefs: []
  type: TYPE_NORMAL
