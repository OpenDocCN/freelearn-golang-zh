- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Frontend Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端库
- en: 'In the previous chapter, we looked at different frameworks for building frontend
    applications. In this chapter, we will look at the different frontend libraries
    that are useful for building web applications. Frontend libraries are predefined
    functions and classes that can help speed up the development time when building
    frontend applications by providing functionality we’d otherwise have to build
    and develop ourselves. In this chapter, we will be looking at the following libraries:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了构建前端应用程序的不同框架。在本章中，我们将探讨对构建网络应用程序有用的不同前端库。前端库是预定义的函数和类，可以在构建前端应用程序时提供功能，否则我们可能需要自己构建和开发。在本章中，我们将探讨以下库：
- en: '`Vuetify`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vuetify`'
- en: '`Buefy`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buefy`'
- en: '`Vuelidate`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vuelidate`'
- en: '`Cleave.js`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cleave.js`'
- en: 'Having completed this chapter, you will have explored the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将探索以下内容：
- en: Validating data with `Vuelidate`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Vuelidate` 验证数据
- en: Better input handling with `Cleave.js`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Cleave.js` 进行更好的输入处理
- en: Working with different UI components using `Vuetify`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Vuetify` 处理不同的 UI 组件
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter08).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter08)中检出。
- en: 'Make sure you have all the necessary tools installed on your local machine
    by following the instructions from the `node.js` documentation available here:
    [https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经按照以下链接中提供的 `node.js` 文档说明在你的本地机器上安装了所有必要的工具：[https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)。
- en: In this chapter, there will be sample code that is shared using [codesandbox.io](http://codesandbox.io)
    and [jsfiddle.net](http://jsfiddle.net), which will make it easier for you to
    experiment with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，将有使用 [codesandbox.io](http://codesandbox.io) 和 [jsfiddle.net](http://jsfiddle.net)
    分享的示例代码，这将使你更容易进行实验。
- en: Let’s begin our journey by looking into Vuetify in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过下一节了解 Vuetify 来开始我们的旅程。
- en: Understanding Vuetify
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Vuetify
- en: In [*Chapter 7*](B18295_07.xhtml#_idTextAnchor128), *Frontend Frameworks*, we
    learned about the Vue framework, which is a rich frontend framework that allows
    frontend code to be extended and maintained easily. Vuetify ([https://vuetifyjs.com](https://vuetifyjs.com))
    provides a lot of user interface components out of the box, ready to be used by
    applications. The framework also allows developers to style the user interfaces
    to their needs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 7 章*](B18295_07.xhtml#_idTextAnchor128)“前端框架”中，我们学习了 Vue 框架，这是一个丰富的前端框架，它允许前端代码易于扩展和维护。Vuetify
    ([https://vuetifyjs.com](https://vuetifyjs.com)) 提供了许多用户界面组件，可以直接用于应用程序。该框架还允许开发者根据需要定制用户界面。
- en: In this section, we will learn about Vuetify, which is a Material-based design
    framework that is built on top of Vue. Material is the Design Language made popular
    by Google across their web apps and Android applications – you can find out more
    at [https://m3.material.io/](https://m3.material.io/) –and is a very popular choice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 Vuetify，这是一个基于 Vue 构建的 Material 设计框架。Material 是由 Google 在其网络应用和 Android
    应用中推广的设计语言 – 你可以在[https://m3.material.io/](https://m3.material.io/)上了解更多信息 – 并且是一个非常受欢迎的选择。
- en: Setting up Vuetify
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Vuetify
- en: 'We are going to take a look at the example code inside the `chapter08/vuetify/components`
    directory. The example code demonstrates how to use the `Vuetify` framework. Before
    running the sample code, make sure you run the following command from inside the
    `chapter08/vuetify/components` directory to install all the necessary components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 `chapter08/vuetify/components` 目录内的示例代码。示例代码演示了如何使用 `Vuetify` 框架。在运行示例代码之前，请确保你从
    `chapter08/vuetify/components` 目录中运行以下命令来安装所有必要的组件：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the installation is complete, run the sample code using the following
    command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，使用以下命令运行示例代码：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the server is up and running, you will get an output as shown in *Figure
    8**.1*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动并运行，你将得到如图 8**.1** 所示的输出：
- en: '![Figure 8.1: Output from running npx](img/Figure_8.01_B18295.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：运行 npx 的输出](img/Figure_8.01_B18295.jpg)'
- en: 'Figure 8.1: Output from running npx'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：运行 npx 的输出
- en: 'You can access the application using the URL specified in the output – for
    example, http://localhost:8080\. *Figure 8**.2* shows the output of the application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用输出中指定的URL访问应用程序——例如，http://localhost:8080。*图8.2*显示了应用程序的输出：
- en: '![Figure 8.2: Output from the sample app](img/Figure_8.02_B18295.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：示例应用的输出](img/Figure_8.02_B18295.jpg)'
- en: 'Figure 8.2: Output from the sample app'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：示例应用的输出
- en: The sample app displays the different components that are available inside Vuetify.
    As you can see, there are components available for radio button groups and color
    pickers, among many others.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序显示了Vuetify内部可用的不同组件。如您所见，除了单选按钮组和颜色选择器之外，还有许多其他组件。
- en: In the next section, we will look at how we use Vuetify in the sample app and
    how things are wired up together.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在示例应用程序中使用Vuetify以及如何连接各个部分。
- en: Using UI components
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UI组件
- en: There are many components provided with Vuetify but in this section, we will
    just talk about a few of them to get an idea of how to use them. The example code
    uses components such as a color picker, button, badge, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Vuetify提供了许多组件，但在这个部分，我们将只讨论其中的一些，以便了解如何使用它们。示例代码使用了颜色选择器、按钮、徽章等组件。
- en: '*Figure 8**.3* shows the directory structure of the example. All of the source
    files are inside the `src/` folder:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.3*显示了示例的目录结构。所有源文件都位于`src/`文件夹中：'
- en: '![Figure 8.3: The directory structure of a Vuetify sample app](img/Figure_8.03_B18295.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：Vuetify示例应用的目录结构](img/Figure_8.03_B18295.jpg)'
- en: 'Figure 8.3: The directory structure of a Vuetify sample app'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：Vuetify示例应用的目录结构
- en: 'The `main.js` host code for initializing Vue and Vuetify is shown in the following
    snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化Vue和Vuetify的`main.js`宿主代码如下片段所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code looks like any other Vue-based application except it adds the Vuetify
    framework, which is imported from the `plugins/vuetify` directory, as shown in
    this snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像任何其他基于Vue的应用程序，除了它添加了从`plugins/vuetify`目录导入的Vuetify框架，如本片段所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Vuetify is initialized in the code as a plugin using the `Vue.use()` function
    call and exported to be made available to other parts of the code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Vuetify通过`Vue.use()`函数调用作为插件初始化，并导出以供代码的其他部分使用。
- en: 'Now that the initialization is out of the way, let’s take a look at how the
    sample is using the Vuetify components. The code snippet here from `App.vue` shows
    how the sample code uses the Color Picker component of Vuetify:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初始化已完成，让我们看看示例是如何使用Vuetify组件的。这里从`App.vue`中的代码片段显示了示例代码如何使用Vuetify的颜色选择器组件：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The tags that can be seen in the snippet – `<v-row>`, `<v-col>`, `<v-container>`,
    and so on – are all Vuetify components. The components can be configured through
    the available properties; for example, if we look at the component documentation
    ([https://vuetifyjs.com/en/api/v-row/#props](https://vuetifyjs.com/en/api/v-row/#props))
    for `<v-row>`, we can see that we can set different parameters, such as alignment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段中可以看到的标签——`<v-row>`、`<v-col>`、`<v-container>`等——都是Vuetify组件。组件可以通过可用的属性进行配置；例如，如果我们查看`<v-row>`的组件文档([https://vuetifyjs.com/en/api/v-row/#props](https://vuetifyjs.com/en/api/v-row/#props))，我们可以看到我们可以设置不同的参数，例如对齐。
- en: In this section, we learned about Vuetify and how to use the components provided,
    and also how to wire things together to use it in a Vue-based application. In
    the next section, we will look at different user interface libraries that are
    more lightweight compared to Vuetify. We will start by looking at Buefy in the
    next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了Vuetify及其组件的使用方法，以及如何将它们连接起来以在Vue应用程序中使用。在下一节中，我们将探讨与Vuetify相比更轻量级的不同用户界面库。下一节我们将从Buefy开始。
- en: Understanding Buefy
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Buefy
- en: 'Buefy is another user interface framework that is built on top of Bulma. Bulma
    ([https://bulma.io/](https://bulma.io/)) is an open source CSS project that provides
    different kinds of styles for HTML elements; the CSS file can be viewed at the
    following link: [https://github.com/jgthms/bulma/blob/master/css/bulma.css](https://github.com/jgthms/bulma/blob/master/css/bulma.css).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Buefy是建立在Bulma之上的另一个用户界面框架。Bulma([https://bulma.io/](https://bulma.io/))是一个开源CSS项目，为HTML元素提供不同类型的样式；CSS文件可以在以下链接查看：[https://github.com/jgthms/bulma/blob/master/css/bulma.css](https://github.com/jgthms/bulma/blob/master/css/bulma.css)。
- en: Let’s take a quick look at an example web page that uses Bulma CSS. This will
    give us a better idea of what Bulma is all about and also give us a better understanding
    of how Buefy is using it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一个使用Bulma CSS的网页示例。这将让我们更好地了解Bulma是什么，以及Buefy是如何使用它的。
- en: Bulma sample
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bulma示例
- en: 'Open the sample `chapter08/bulma/bulma_sample.xhtml` file in your browser,
    and the HTML page will look like *Figure 8**.4*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开示例文件`chapter08/bulma/bulma_sample.xhtml`，HTML页面将看起来像*图8.4*：
- en: '![Figure 8.4: Bulma example page](img/Figure_8.04_B18295.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：Bulma示例页面](img/Figure_8.04_B18295.jpg)'
- en: 'Figure 8.4: Bulma example page'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：Bulma示例页面
- en: 'The following code snippet shows the Bulma CSS file used in the web page:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了网页中使用的Bulma CSS文件：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The web page uses different HTML elements tags styled using the Bulma CSS,
    as seen in the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 网页使用Bulma CSS样式化的不同HTML元素标签，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have an idea about what Bulma is and how to use it for a web page,
    we will take a look at setting up Buefy in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Bulma是什么以及如何将其用于网页，我们将在下一节中查看如何设置Buefy。
- en: Setting up Buefy
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Buefy
- en: 'We are going to look at the Buefy example that is found inside the `chapter8/buefy`
    directory. Make sure you are inside the directory and run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看位于`chapter8/buefy`目录中的Buefy示例。请确保您位于该目录中，并运行以下命令：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open the server in your browser and you will see output like *Figure 8**.5*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开服务器，您将看到类似于*图8.5*的输出：
- en: '![Figure 8.5: Buefy sample output](img/Figure_8.05_B18295.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：Buefy示例输出](img/Figure_8.05_B18295.jpg)'
- en: 'Figure 8.5: Buefy sample output'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：Buefy示例输出
- en: UI components
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI组件
- en: The web page displays different components available in Buefy, such as a slider,
    a clickable button with a dropdown, and a breadcrumb.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 网页显示了Buefy中可用的不同组件，例如滑块、带下拉菜单的可点击按钮和面包屑。
- en: 'Initializing Buefy is the same as initializing any other Vue plugin. It looks
    the same as what we went through in the previous section when we looked at Vuetify.
    The code will initialize Vue by using Buefy as stated in the `Vue.use(Buefy)`
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化Buefy与初始化任何其他Vue插件相同。它看起来与我们在上一节中查看Vuetify时看到的一样。代码将通过使用`Vue.use(Buefy)`初始化Vue：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One of the components that we are using in our sample app is `carousel`, which
    displays a user interface like a slideshow. To create `carousel`, it is just a
    few lines of code, as shown in the following code snippet, using the `<``b-carousel>`
    tag:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例应用程序中使用的一个组件是`carousel`，它显示一个类似于幻灯片的用户界面。要创建`carousel`，只需几行代码，如下面的代码片段所示，使用`<b-carousel>`标签：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Like `carousel`, there are many different pre-built components available in
    Buefy that can help design complex user interfaces.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`carousel`，Buefy提供了许多不同的预构建组件，可以帮助设计复杂用户界面。
- en: In the next section, we will look at how we can use the Vuelidate library as
    a way to perform validation on the data we capture and present in our user interface
    to ensure we interpret our customers’ data correctly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用Vuelidate库来验证我们在用户界面中捕获和展示的数据，以确保我们正确地解释了客户的数据。
- en: Validating data entry with Vuelidate
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuelidate验证数据输入
- en: If your app does anything interactive, it’s likely that it will handle user-entered
    data, which means you must check whether what the users are providing is valid
    input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序有任何交互功能，它很可能会处理用户输入的数据，这意味着您必须检查用户提供的输入是否有效。
- en: Input validation libraries can be used to ensure only valid data is entered
    by the user and provide feedback as soon as data is received. This means we’re
    validating as soon our user hits that input field!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证库可以用来确保用户只输入有效数据，并在数据接收时立即提供反馈。这意味着我们在用户点击输入字段时就开始验证！
- en: We’re going to explore HTML form validation in the frontend and the difference
    between input and value validation. It’s also important to note that no matter
    the validation in the frontend, it’s no substitute for validation in the backend
    and of the API endpoints. Our goal in the frontend is to prevent the user from
    making errors; however, you’ll never stop bad guys from submitting bad data to
    your app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索前端中的HTML表单验证以及输入和值验证之间的区别。同样重要的是要注意，无论前端验证如何，它都不能替代后端和API端点的验证。我们在前端的目标是防止用户犯错误；然而，您永远无法阻止坏人向您的应用程序提交不良数据。
- en: We can look at frontend validation through two lenses, as there’s a myriad of
    solutions out there, but we’ll contrast two options and show a working solution
    – the first is that of validating input, and the other is the validation of values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两个角度来观察前端验证，因为市面上有无数种解决方案，但我们将对比两种选项并展示一个可行的解决方案——第一个是验证输入，另一个是验证值。
- en: 'If we only want to validate the input, we could use the `vee-validate` library,
    which works by having you write the rules inside the `<template>` of your code.
    For example, see the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想验证输入，我们可以使用 `vee-validate` 库，它通过让你在代码的 `<template>` 中编写规则来实现。例如，请看以下内容：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This inline validation – wherein we perform `ValidateAll()` on submitting data
    – will allow us to validate the contents of the data using predefined rules, such
    as a field being required, its minimum length, or that it must be a valid email
    ID, for example. If invalid data is entered, we can iterate through the errors
    and present them to the user:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内联验证——在我们提交数据时执行 `ValidateAll()`——将允许我们使用预定义的规则来验证数据内容，例如字段是必需的、其最小长度，或者它必须是一个有效的电子邮件
    ID 等。如果输入了无效数据，我们可以遍历错误并将它们展示给用户：
- en: '![Figure 8.6: Validation error message](img/Figure_8.06_B18295.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6：验证错误信息](img/Figure_8.06_B18295.jpg)'
- en: 'Figure 8.6: Validation error message'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：验证错误信息
- en: 'You can see this on the JS Playground website `JSFiddle` at the following link:
    [https://jsfiddle.net/vteudms5/](https://jsfiddle.net/vteudms5/).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 JS Playground 网站的 `JSFiddle` 上看到这一点：[https://jsfiddle.net/vteudms5/](https://jsfiddle.net/vteudms5/)。
- en: This is useful for simple validation, but when we want to add additional logic
    against values and collections of values, rather than just individual inputs,
    this is where libraries such as Vuelidate become powerful.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于简单的验证很有用，但当我们想要对值和值的集合添加额外的逻辑，而不仅仅是单个输入时，这就是像 Vuelidate 这样的库变得强大的地方。
- en: With Vuelidate, you’ll notice that the validation is decoupled from the template
    code we write, unlike the inline validation done in the `vee-validate` example.
    This allows us to write the rules against the data model rather than the inputs
    in our template.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vuelidate，你会注意到验证与我们所编写的模板代码解耦，这与 `vee-validate` 示例中的内联验证不同。这允许我们针对数据模型编写规则，而不是针对模板中的输入。
- en: 'In Vuelidate, the validation results in a validation object referenced as `this.$v,`
    which we can use to validate our model state. Let’s rebuild our previous example
    to demonstrate how we going to use Vuelidate to validate the data – this sample
    is at [https://jsfiddle.net/34gr7vq0/3/](https://jsfiddle.net/34gr7vq0/3/):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vuelidate 中，验证结果会生成一个名为 `this.$v` 的验证对象，我们可以用它来验证我们的模型状态。让我们重新构建之前的示例，以展示我们将如何使用
    Vuelidate 验证数据——这个示例可以在 [https://jsfiddle.net/34gr7vq0/3/](https://jsfiddle.net/34gr7vq0/3/)
    找到：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting output shows us the `$v` object. The `required`, `email`, and
    `minLength` fields are firing when you type in the box. In our example, when we
    type in [nick@bar.com](mailto:nick@bar.com), the fields change value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出显示了 `$v` 对象。当你在框中输入时，`required`、`email` 和 `minLength` 字段会被触发。在我们的例子中，当我们输入
    [nick@bar.com](mailto:nick@bar.com) 时，字段值会改变：
- en: '![Figure 8.7: Illustration of the browser output from our JSFiddle sample](img/Figure_8.07_B18295.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7：JSFiddle 示例的浏览器输出示意图](img/Figure_8.07_B18295.jpg)'
- en: 'Figure 8.7: Illustration of the browser output from our JSFiddle sample'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：JSFiddle 示例的浏览器输出示意图
- en: 'Although similar to the `vee-validate` implementation in style, by utilizing
    the `$v` object concept and allowing that to be the source of validation, we can
    connect it to additional inputs across multiple forms and validate the entire
    collection. For example, if we had multiple fields, such as a name, email, users,
    and tags across `formA` and `formB`, we would be able to create the validation
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在风格上与 `vee-validate` 的实现相似，但通过利用 `$v` 对象概念并允许其为验证的来源，我们可以将其连接到多个表单的额外输入，并验证整个集合。例如，如果我们有多个字段，如
    `formA` 和 `formB` 中的名称、电子邮件、用户和标签，我们就能创建如下验证：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There’s a large collection of available validators for Vuelidate that we can
    import. This gives us access to validators such as conditionally required fields;
    length validators; email, alpha/alphanum, regex, decimal, integer, and URL options;
    and many more that are accessible by importing the `validators` library:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Vuelidate 有一个庞大的验证器集合可供导入。这使我们能够访问诸如条件性必需字段；长度验证器；电子邮件、字母/字母数字、正则表达式、十进制、整数和
    URL 选项等验证器，以及通过导入 `validators` 库可以访问的更多验证器：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The full list is available on the Vuelidate website at [https://vuelidate-next.netlify.app/validators.xhtml](https://vuelidate-next.netlify.app/validators.xhtml).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完整列表可在Vuelidate网站上找到，网址为[https://vuelidate-next.netlify.app/validators.xhtml](https://vuelidate-next.netlify.app/validators.xhtml)。
- en: Better input handling with Cleave.JS
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cleave.JS进行更好的输入处理
- en: As we’ve just seen, getting data from your users in the right shape and form
    can be a challenge – be it a date in a YYYY/MM format, a phone number with a prefix,
    or other more structured input types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，以正确的形状和形式从用户那里获取数据可能是一个挑战 - 不论是YYYY/MM格式的日期，带有前缀的电话号码，还是其他更结构化的输入类型。
- en: We looked at validation previously, but you can further help your users by providing
    visual clues and feedback as they type to prevent them from reaching the end with
    validation errors – libraries such as those provided by the popular credit card
    and online payments processor. Stripe does a great job at helping users enter
    their credit card info correctly, but for those of us on a budget, we can use
    Cleave. js for a similar experience.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论了验证，但你可以通过提供视觉线索和反馈来进一步帮助用户，在他们输入时防止他们因为验证错误而到达终点 - 例如，那些由流行的信用卡和在线支付处理器提供的库。Stripe在帮助用户正确输入信用卡信息方面做得很好，但对我们预算有限的人来说，我们可以使用Cleave.js来获得类似体验。
- en: '![Figure 8.7: Credit card validation (image from https://nosir.github.io/cleave.js/)](img/Figure_8.08_B18295.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：信用卡验证（图片来自https://nosir.github.io/cleave.js/）](img/Figure_8.08_B18295.png)'
- en: 'Figure 8.7: Credit card validation (image from https://nosir.github.io/cleave.js/)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：信用卡验证（图片来自https://nosir.github.io/cleave.js/）
- en: 'Frustratingly, Vue isn’t supported as a first-class citizen but there’s no
    reason we can’t set up the directive, which is available at [codesandbox.io](http://codesandbox.io)
    here – [https://bit.ly/3Ntvv27](https://bit.ly/3Ntvv27). *Figure 8**.8* shows
    how the validation will work for [codesandbox.io](http://codesandbox.io):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 令人沮丧的是，Vue不是作为一等公民得到支持，但我们没有理由不能设置这个指令，该指令可在[codesandbox.io](http://codesandbox.io)这里找到
    - [https://bit.ly/3Ntvv27](https://bit.ly/3Ntvv27)。*图8**.8*显示了[https://bit.ly/3Ntvv27](https://bit.ly/3Ntvv27)中验证的工作方式：
- en: '![Figure 8.8: Example of our Cleave.js example on codesandbox.io](img/Figure_8.09_B18295.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：codesandbox.io上我们的Cleave.js示例示例](img/Figure_8.09_B18295.jpg)'
- en: 'Figure 8.8: Example of our Cleave.js example on codesandbox.io'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：codesandbox.io上我们的Cleave.js示例示例
- en: 'It’s not as pretty in my hardcoded sample (the CSS is left as an exercise for
    you!) but the key part from the sandbox sample is how we overload `custom-input`
    with our `cleave` directive by doing the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的硬编码示例中（CSS留作你的练习！）它并不那么漂亮，但关键部分是从沙盒示例中如何通过以下方式对`custom-input`进行重载，使用我们的`cleave`指令：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the future, it would be great to see Cleave.js incorporate a first-party
    implementation for Vue but until then, a number of npm packages exist to skip
    over the setup for our sample and provide a similar effect that will allow us
    to create beautiful experiences for our users.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，看到Cleave.js为Vue提供第一方实现将非常棒，但在此之前，存在许多npm包可以跳过我们的示例设置，并提供类似的效果，这将使我们能够为用户提供美好的体验。
- en: To follow the status of Cleave.js official support, you can check out [https://github.com/nosir/cleave.js/blob/master/doc/vue.md](https://github.com/nosir/cleave.js/blob/master/doc/vue.md).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪Cleave.js官方支持的状态，你可以查看[https://github.com/nosir/cleave.js/blob/master/doc/vue.md](https://github.com/nosir/cleave.js/blob/master/doc/vue.md)。
- en: With Cleave.js, we have reached the end of this chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cleave.js，我们已经到达了本章的结尾。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about several frontend libraries and tools to help
    us to iterate through code and design faster when building the frontend user interface
    for our product.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了几个前端库和工具，帮助我们更快地迭代代码和设计，以便为我们的产品构建前端用户界面。
- en: We’ve looked at using Vuetify to create customizable user interfaces, and looked
    at Buefy, which provides a huge collection of UI components to allow us to build
    our apps rapidly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了使用Vuetify来创建可定制的用户界面，并探讨了Buefy，它提供了一个庞大的UI组件集合，使我们能够快速构建我们的应用程序。
- en: We then finished up by providing an introduction to and contrast between input
    and value validation using Vuelidate and VeeValidate, respectively, and finally,
    explained how we can use Cleave.js to create smarter interfaces to help our users
    understand what our app expects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过介绍和对比使用Vuelidate和VeeValidate进行输入和值验证，以及最后解释如何使用Cleave.js创建更智能的界面来帮助用户理解我们的应用程序期望的内容，结束了本章。
- en: In the next chapter, we will look at middleware pieces that will form the bridge
    between the frontend and the backend.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨那些将前端和后端连接起来的中间件组件。
