<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer072">
<h1 class="chapter-number" id="_idParaDest-119"><a id="_idTextAnchor184"/>9</h1>
<h1 id="_idParaDest-120"><a id="_idTextAnchor185"/>Tailwind, Middleware, and CORS</h1>
<p>In this chapter, we will build on the frontend principles we introduced previously by introducing Tailwind CSS, explore how we can consume our backend services via an API from our frontend app, see how we can leverage middleware to transform our JSON requests, and look at how we can provide a secure <strong class="bold">Single-Page App</strong> (<strong class="bold">SPA</strong>) with a <span class="No-Break">user login.</span></p>
<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Creating and designing frontend applications using the Tailwind <span class="No-Break">CSS framework</span></li>
<li>Getting an understanding of how to use the Vite CLI to create new <span class="No-Break">Vue applications</span></li>
<li>Configuring our Go service <span class="No-Break">for CORS</span></li>
<li>Setting up a JavaScript <span class="No-Break">Axios library</span></li>
<li>Creating middleware to manage JSON formatting between the frontend and <span class="No-Break">the backend</span></li>
</ul>
<h1 id="_idParaDest-121"><a id="_idTextAnchor186"/>Technical requirements</h1>
<p>All the source code explained in this chapter can be checked out <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor187"/>Introducing Tailwind</h1>
<p>In the previous chapter, we looked at a number of different frontend frameworks to help us go faster, but we’ve been ignoring an elephant in the room of a modern web ecosystem – <span class="No-Break">Tailwind CSS.</span></p>
<p>Frameworks such as Buefy and Vuetify have a major disadvantage. Due to increasing demand for more and more<a id="_idIndexMarker318"/> features, growth, and usage, they became a victim of their own success and ended up too big, giving us less control over our <span class="No-Break">component styles.</span></p>
<p>Learning about frameworks such as<a id="_idIndexMarker319"/> Buefy has become increasingly challenging. Developers have to learn about hundreds of classes and components and then potentially rebuild them just for small style tweaks that were simply not envisioned by the <span class="No-Break">upstream community.</span></p>
<p>Tailwind is<a id="_idIndexMarker320"/> a CSS framework that, unlike other frameworks, does not come prebuilt with classes to add to HTML tags. Instead, it uses a different approach. It brings a much lower level of control by removing ALL default styling from the stylesheet and using utility-based classes to compose and build your app. These utility-based classes provide ways to directly manipulate certain CSS attributes individually, such as text size, margins, spacing, padding, and colors, as well as behavior for mobile, desktop, and other viewports. By applying different tailwind modifiers, we have granular control over the final appearance of an element while ensuring consistent styling and an easy escape route if we need to build slight variations. This really helps in building our <span class="No-Break">Vue components.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Figure 9.1: A button sample" height="134" src="image/Figure_9.01_B18295.jpg" width="254"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: A button sample</p>
<p>A quick example of creating a blue button can be seen with <span class="No-Break">the following:</span></p>
<pre class="source-code">
&lt;button type="button" class="
 inline-block px-6 py-2.5 bg-blue-600
 text-white font-medium text-lg leading-tight
 rounded shadow-md
 hover:bg-blue-700 hover:shadow-lg
 focus:bg-blue-700 focus:shadow-lg
 focus:outline-none focus:ring-0
 active:bg-blue-800 active:shadow-lg
 transition duration-150 ease-in-out
"&gt;Button&lt;/button&gt;</pre>
<p>You may be saying to yourself, “Wow, that’s a lot of CSS for a button,” but when you consider how Vue helps us build reusable <a id="_idIndexMarker321"/><strong class="bold">Single-File Components</strong> (<strong class="bold">SFCs</strong>), we would only need to style this once, and all of our components would share that same utility-based CSS approach – whether it’s a <strong class="source-inline">button</strong>, <strong class="source-inline">link</strong>, <strong class="source-inline">image</strong>, <strong class="source-inline">div</strong>, or <strong class="source-inline">paragraph</strong>. You can check the official docs at <a href="https://tailwindcss.com/docs/utility-first">https://tailwindcss.com/docs/utility-first</a> to dive further into the concepts behind “utility-first” CSS and what the individual <span class="No-Break">classes do<a id="_idTextAnchor188"/>.</span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor189"/>Creating a new Tailwind and Vite project</h2>
<p>To create our <a id="_idIndexMarker322"/>project, we’re going to first generate it with the <strong class="source-inline">Vite CLI</strong>. This<a id="_idIndexMarker323"/> will give us the familiar “<strong class="source-inline">Hello World</strong>” output you <span class="No-Break">see here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 9.2: Hello World web output" height="342" src="image/Figure_9.02_B18295.jpg" width="402"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Hello World web output</p>
<p>Let’s create a new Vue project with Vite using the <span class="No-Break">following command:</span></p>
<pre class="console">
npm create vite@latest</pre>
<p>For each<a id="_idIndexMarker324"/> of the questions asked, enter the information <span class="No-Break">shown</span><span class="No-Break"><a id="_idIndexMarker325"/></span><span class="No-Break"> here:</span></p>
<pre class="console">
✔ Project name: … vue-frontend
✔ Select a framework: › vue
✔ Select a variant: › vue
Scaffolding project in /Users/.../vue-frontend...
Done. Now run:
  cd vue-frontend
  npm install
  npm run dev
$ npm install
$ npm run dev
&gt; vue-frontend@0.0.0 dev
&gt; vite
  vite v2.9.12 dev server running at:
  &gt; Local: http://localhost:3000/
  &gt; Network: use `--host` to expose
  ready in 332ms.</pre>
<p>Going to <strong class="source-inline">http://localhost:3000</strong> will now show the screenshot from <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em>. Our project is enabled with “hot reload” or “live reload” so as you change the project code, you <a id="_idIndexMarker326"/>will be able to see the design in the browser update <a id="_idIndexMarker327"/>when you save <span class="No-Break">the file.</span></p>
<p>Previous versions of Tailwind CSS had a bit of a reputation for generating large stylesheets (between 3 and 15 MB!) and slowing down <span class="No-Break">build times.</span></p>
<p>At the end of the Tailwind CSS version 2 era, the team introduced a new <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) compiler that automatically generates only the necessary CSS required to style your design. This was originally available as an optional plugin but brought massive improvements by reducing bloat, and with JIT, the CSS in development is the same as your final code, which meant no post-processing of the CSS is required for your final builds. Since Tailwind CSS version 3 and above, the JIT compiler has been enabled by default when we install Tailwind CSS, so we don’t have to worry about altering anything in our config file other than what is needed to lay out <span class="No-Break">our project.</span></p>
<p>We’re going to now <a id="_idIndexMarker328"/>add Tailwind CSS to our project and make some <a id="_idIndexMarker329"/>changes to the default Vue <strong class="source-inline">Hello World</strong> output provided by the scaffolding from both the Vue and <span class="No-Break">Tailwind packages:</span></p>
<pre class="source-code">
$ npm install -D tailwindcss postcss autoprefixer
$ npx tailwindcss init -p
Created Tailwind CSS config file: tailwind.config.js
Created PostCSS config file: postcss.config.js
$ cat &lt;&lt; EOF &gt; tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.xhtml",
    "./src/**/*.{vue,js}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
EOF
$ cat &lt;&lt; EOF &gt; ./src/tailwind.css
@tailwind base;
@tailwind components;
@tailwind utilities;
EOF
$ cat &lt;&lt; EOF &gt; ./src/main.js
import { createApp } from 'vue'
import App from './App.vue'
import './tailwind.css'
createApp(App).mount('#app')
EOF</pre>
<p>The directives<a id="_idIndexMarker330"/> beginning with <strong class="source-inline">@tailwind</strong>  in the <strong class="source-inline">tailwind.css</strong> file<a id="_idIndexMarker331"/> are part of how we tell the JIT compiler what to apply to generate the CSS – we will only leverage the base, component and utility directives and refer you to the Tailwind CSS official docs for more on this – <a href="https://tailwindcss.com/docs/functions-and-directives"><span class="No-Break">https://tailwindcss.com/docs/functions-and-directives</span></a><span class="No-Break">.</span></p>
<p>We can now open up our <strong class="source-inline">HelloWorld.vue</strong> file and replace the contents with the following to create our button. The cool part with our dev server still running is that you should be able to see the changes in real time if you save your file as you manipulate the <span class="No-Break"><strong class="source-inline">button</strong></span><span class="No-Break"> classes:</span></p>
<pre class="source-code">
&lt;template&gt;
  &lt;div class="flex space-x-2 justify-center"&gt;
    &lt;button
      @click="count++"
      type="button"
      class="inline-block px-6 py-2.5 bg-blue-600
             text-white font-medium text-lg leading-tight
             normal-case rounded shadow-md hover:bg-blue-
             700 hover:shadow-lg focus:bg-blue-700
             focus:shadow-lg focus:outline-none
             focus:ring-0 active:bg-blue-800
             active:shadow-lg transition duration-150
             ease-in-out"
    &gt;
      Click me - my count is {{ count }}
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>
<p>You should end up with something <span class="No-Break">like this:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 9.3: The Click me button" height="104" src="image/Figure_9.03_B18295.jpg" width="343"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: The Click me button</p>
<p>Congratulations! You’ve <a id="_idIndexMarker332"/>created your first Tailwind and Vite project. You<a id="_idIndexMarker333"/> can see the complete example inside the <span class="No-Break"><strong class="source-inline">chapter9/tailwind-vite-demo</strong></span><span class="No-Break"> folder.</span></p>
<p>In the next section, we will look at how to use the API that we developed in Golang from <span class="No-Break">o<a id="_idTextAnchor190"/>ur frontend.</span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor191"/>Consuming your Golang APIs</h1>
<p>We’re going to build on our<a id="_idIndexMarker334"/> previous frontend example to add some functions to <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> from a simple backend service. The source code can be found inside the <strong class="source-inline">chapter9/backend</strong> folder; it focuses on two simplified functions that do little more than return a fixed string for <strong class="source-inline">GET</strong> and a reversed string based on the <strong class="source-inline">POST</strong> request that <span class="No-Break">we sent.</span></p>
<p>The <strong class="source-inline">appGET()</strong> function provides the functionality to perform a <strong class="source-inline">GET</strong> operation, while the <strong class="source-inline">appPOST()</strong> function provides it for a <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> operation:</span></p>
<pre class="source-code">
func appGET() http.HandlerFunc {
    type ResponseBody struct {
        Message string
    }
    return func(rw http.ResponseWriter, req *http.Request) {
        log.Println("GET", req)
        json.NewEncoder(rw).Encode(ResponseBody{
            Message: "Hello World",
        })
    }
}
func appPOST() http.HandlerFunc {
    type RequestBody struct {
        Inbound string
    }
    type ResponseBody struct {
        OutBound string
    }
    return func(rw http.ResponseWriter, req *http.Request) {
        log.Println("POST", req)
        var rb RequestBody
        if err := json.NewDecoder(req.Body).Decode(&amp;rb);
                  err != nil {
            log.Println("apiAdminPatchUser: Decode
                         failed:", err)
            rw.WriteHeader(http.StatusBadRequest)
            return
        }
        log.Println("We received an inbound value of",
                     rb.Inbound)
        json.NewEncoder(rw).Encode(ResponseBody{
            OutBound: stringutil.Reverse(rb.Inbound),
        })
    }
}</pre>
<p>We’ll start our<a id="_idIndexMarker335"/> service by using <strong class="source-inline">go run server.go</strong>, with a view to consuming this data from our <span class="No-Break">frontend application.</span></p>
<p>We’re going to create two utility functions in our frontend app to allow us to interact with our frontend app, and we’re going to be building these on top of Axios. Axios is a Promise-based HTTP client for the browser that abstracts all the browser-specific code needed to interact with backend services and does an incredible job in providing a single interface for web requests across all browsers , which you can read more about at the official docs <span class="No-Break">here: </span><a href="https://axios-http.com/"><span class="No-Break">https://axios-http.com/</span></a><span class="No-Break">.</span></p>
<p>We’re going to first install <strong class="source-inline">axios</strong>, then set up our Axios instance, and then we can layer <span class="No-Break">on functionality:</span></p>
<pre class="console">
$ npm install axios</pre>
<p>With <strong class="source-inline">axios</strong> installed, you’ll now want to create a <strong class="source-inline">lib/api.js</strong> file containing <span class="No-Break">the following:</span></p>
<pre class="source-code">
import axios from 'axios';
// Create our "axios" object and export
// to the general namespace. This lets us call it as
// api.post(), api.get() etc
export default axios.create({
  baseURL: import.meta.env.VITE_BASE_API_URL,
  withCredentials: true,
});</pre>
<p>There’s a couple of interesting things to note here; the first is the <strong class="source-inline">baseURL</strong> value, and the second <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">withCredentials</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">baseURL</strong> value is<a id="_idIndexMarker336"/> what Axios uses to build all subsequent requests on top of. If we called <strong class="source-inline">axios.Patch('/foo')</strong> with a <strong class="source-inline">baseURL</strong> value of <a href="https://www.packtpub.com/">https://www.packtpub.com/</a>, it would perform a <strong class="source-inline">PATCH</strong> call to <a href="https://www.packtpub.com/foo">https://www.packtpub.com/foo</a>. This is a great way to switch between development and production and ensure you <span class="No-Break">reduce typos.</span></p>
<p>But what are we doing with <strong class="source-inline">import.meta.env</strong>? This is partly how Vite imports and exposes environment variables. We’re going to add our <strong class="source-inline">VITE_BASE_API_URL</strong> to a <strong class="source-inline">.env</strong> file situated at the base of our project containing <span class="No-Break">the following:</span></p>
<pre class="console">
VITE_BASE_API_URL="http://0.0.0.0:8000"</pre>
<p>Combined with this and our new <strong class="source-inline">lib/api.js</strong> file, we can now call <strong class="source-inline">axios.Put('/test')</strong> from our code, and by default, it will reference http://0.0.0.0:8000/test. You can see more about how Vite handles environment variables and more <span class="No-Break">at </span><a href="https://vitejs.dev/guide/env-and-mode.xhtml"><span class="No-Break">https://vitejs.dev/guide/env-and-mode.xhtml</span></a><span class="No-Break">.</span></p>
<p>The other part to note is the <strong class="source-inline">withCredentials</strong> property. This value indicates whether or not cross-site access control requests should be made using credentials such as cookies and <span class="No-Break">authorization headers.</span></p>
<p>The reason we want this property is that we want all our cookie settings to be consistent, but we’ll need to ensure our backend app understands it, which we’ll cover shortly. Setting <strong class="source-inline">withCredentials</strong> has no effect on <span class="No-Break">same-site requests.</span></p>
<p>Now that we’ve used this to instantiate our <strong class="source-inline">axios</strong> instance, we can leverage this by creating our own <strong class="source-inline">api/demo.js</strong> file inside our frontend application’s <strong class="source-inline">src</strong> folder. It’s not a very original name but it works <span class="No-Break">for us:</span></p>
<pre class="source-code">
import api from '<strong class="bold">@/lib/api'</strong>;
export function getFromServer() {
    return api.get(`/`);
}
export function postToServer(data) {
    return api.post(`/`, data );
}</pre>
<p>This code exports <a id="_idIndexMarker337"/>two functions called <strong class="source-inline">getFromServer</strong> and <strong class="source-inline">postToServer</strong>, with an additional <strong class="source-inline">data</strong> parameter being sent as the <strong class="source-inline">POST</strong> body on the <span class="No-Break">latter function.</span></p>
<p>A neat trick here is the usage of the <strong class="source-inline">@</strong> import – this is common in a lot of setups to allow us to quickly specify the base path for our code to keep things clean and remove relative/absolute pathing with lots of <strong class="source-inline">../..</strong>  referenced everywhere. If you forget this, you’ll see errors such <span class="No-Break">as this:</span></p>
<pre class="source-code">
12:23:46 [vite] Internal server error: Failed to resolve import "@/api/demo" from "src/components/HelloWorld.vue". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/nickglynn/Projects/Becoming-a-Full-Stack-Go-
        Developer/chapter 9/frontend/src/components/
        HelloWorld.vue
  1  |  import { ref } from 'vue';
  2  |  import * as demoAPI from '@/api/demo';
     |                            ^
  3  |
  4  |  // Sample to show how we can inspect mode</pre>
<p>Not great! To <a id="_idIndexMarker338"/>fix this, open up your <strong class="source-inline">vite.config.js</strong> file and replace the contents with <span class="No-Break">the following:</span></p>
<pre class="source-code">
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path';
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  // <strong class="bold">Add the '@' resolver</strong>
<strong class="bold">  resolve: {</strong>
<strong class="bold">    alias: {</strong>
<strong class="bold">      '@': path.resolve(__dirname, 'src'),</strong>
    },
  },
})</pre>
<p>I’ve bolded the key parts that we’re adding. We’re telling Vite to use the <strong class="source-inline">@</strong> symbol as an alias so that when we use <strong class="source-inline">@</strong> in a path, it calls <strong class="source-inline">path.resolve()</strong> to resolve the path segments into an <span class="No-Break">absolute path.</span></p>
<p>With all of this now set up, we’re going to open up our <strong class="source-inline">HelloWorld.vue</strong> and update it, the goal being to create something that looks like <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em> </p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 9.4: The UI for GET and POST" height="190" src="image/Figure_9.04_B18295.jpg" width="461"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: The UI for GET and POST</p>
<p>Here is the<a id="_idIndexMarker339"/> full code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">HelloWorld.vue</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script setup&gt;
import { ref } from 'vue';
<strong class="bold">import * as demoAPI from '@/api/demo'</strong>;
// Sample to show how we can inspect mode
// and import env variables
const deploymentMode = import.meta.env.MODE;
const myBaseURL = import.meta.env.VITE_BASE_API_URL;
<strong class="bold">async function getData() {</strong>
<strong class="bold">  const { data } = await demoAPI.getFromServer()</strong>
<strong class="bold">  result.value.push(data.Message)</strong>
<strong class="bold">}</strong>
<strong class="bold">async function postData() {</strong>
<strong class="bold">  const { data } = await demoAPI.postToServer({ Inbound: msg.     value })</strong>
<strong class="bold">  result.value.push(data.OutBound)</strong>
<strong class="bold">}</strong>
const result = ref([])
const msg = ref("")
defineProps({
  sampleProp: String,
});
&lt;/script&gt;
&lt;template&gt;
  &lt;div class="flex space-2 justify-center"&gt;
    &lt;button
      @<strong class="bold">click="getData()"</strong>
      type="button"
      class="inline-block px-6 py-2.5 bg-blue-600
             text-white font-medium text-lg leading-tight
             normal-case rounded shadow-md hover:bg-blue-
             700 hover:shadow-lg focus:bg-blue-700
             focus:shadow-lg focus:outline-none
             focus:ring-0 active:bg-blue-800
             active:shadow-lg transition              duration-150 ease-in-out"
    &gt;
      Click to Get
    &lt;/button&gt;
  &lt;/div&gt;
  &lt;div class="flex mt-4 space-2 justify-center"&gt;
    &lt;input type="text"
      class="inline-block px-6 py-2.5 text-blue-600
             font-medium text-lg leading-tight
             rounded shadow-md border-2 border-solid
             border-black focus:shadow-lg  focus:ring-1 "
      <strong class="bold">v-model="msg" /&gt;</strong>
    &lt;button
      <strong class="bold">@click="postData()"</strong>
      type="button"
      class="inline-block px-6 py-2.5 bg-blue-600
             text-white font-medium text-lg leading-tight
             normal-case rounded shadow-md hover:bg-blue-
             700 hover:shadow-lg focus:bg-blue-700
             focus:shadow-lg focus:outline-none
             focus:ring-0 active:bg-blue-800
             active:shadow-lg transition
             duration-150 ease-in-out"
    &gt;
      Click to Post
    &lt;/button&gt;
  &lt;/div&gt;
  <strong class="bold">&lt;p&gt;You are in {{ deploymentMode }} mode&lt;/p&gt;</strong>
<strong class="bold">  &lt;p&gt;Your API is at {{ myBaseURL }}&lt;/p&gt;</strong>
<strong class="bold">  &lt;li v-for="(r, index) in result"&gt;</strong>
<strong class="bold">    {{ r }}</strong>
<strong class="bold">  &lt;/li&gt;</strong>
&lt;/template&gt;
&lt;style scoped&gt;&lt;/style&gt;</pre>
<p>The parts in bold are the<a id="_idIndexMarker340"/> most interesting parts. These show how we can use <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> with our data, using our libraries and API calls from the backend server that we set up, as well as how we can bind the data and reference it in our <span class="No-Break">Vue modules.</span></p>
<p>Hopefully, after making all these changes, your Vite instance is still running; if not, start it with <strong class="source-inline">npm run dev</strong>, and you should get the screenshot from <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em>. Click the <strong class="bold">Click to Get</strong> button and enter some data to send via the <strong class="bold">Click to </strong><span class="No-Break"><strong class="bold">post</strong></span><span class="No-Break"><strong class="bold"> </strong></span><span class="No-Break">button.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 9.5: Peeking into the HTTP traffic" height="191" src="image/Figure_9.05_B18295.jpg" width="603"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5: Peeking into the HTTP traffic</p>
<p>It doesn’t work! We’re so close, but first, we have to revisit CORS from one of our <span class="No-Break">p<a id="_idTextAnchor192"/>revious chapters.</span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor193"/>CORS for secure applications</h1>
<p>In <a href="B18295_06.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>,<em class="italic"> Moving to API-First</em>, we introduced the CORS <a id="_idIndexMarker341"/>middleware for our backend. We’ve now got to update our new backend service. It will need to respond to <strong class="source-inline">OPTION</strong> preflight requests, as we discussed in <a href="B18295_06.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Moving to API-First</em>, and will also need to identify the URLs that we’re going to allow to talk to our service. This is necessary to ensure our browsers aren’t being tricked into submitting/modifying applications from <span class="No-Break">other sources.</span></p>
<p>Open up the <strong class="source-inline">backend/server.go</strong> sample you’ve been running and review the <span class="No-Break">main function:</span></p>
<pre class="source-code">
...
    port := ":8000"
    rtr := mux.NewRouter()
    rtr.Handle("/", appGET()).Methods(http.MethodGet)
    rtr.Handle("/", appPOST()).Methods(http.MethodPost,
                                       <strong class="bold">http.MethodOptions</strong>)
    // Apply the CORS middleware to our top-level router, with     // the defaults.
    <strong class="bold">rtr.Use(</strong>
<strong class="bold">        handlers.CORS(</strong>
<strong class="bold">          handlers.AllowedHeaders(</strong>
<strong class="bold">           []string{"X-Requested-With",            "Origin", "Content-Type",}),</strong>
<strong class="bold">          handlers.AllowedOrigins([]string{</strong>
<strong class="bold">           "http://0.0.0.0:3000",            "http://localhost:3000"}),</strong>
<strong class="bold">            handlers.AllowCredentials(),</strong>
<strong class="bold">            handlers.AllowedMethods([]string{</strong>
<strong class="bold">                http.MethodGet,</strong>
<strong class="bold">                http.MethodPost,</strong>
<strong class="bold">            })),</strong>
<strong class="bold">    )</strong>
    log.Printf("Listening on http://0.0.0.0%s/", port)
    http.ListenAndServe(port, rtr)</pre>
<p>As before, I’ve <a id="_idIndexMarker342"/>put the key parts in bold. You can see we’ve appended <strong class="source-inline">http.MethodOptions</strong> to our <strong class="source-inline">POST</strong> handler, and we’ve also layered in some <span class="No-Break">additional middleware.</span></p>
<p><strong class="source-inline">AllowedHeaders</strong> has been included, and we’re specifically accepting <strong class="source-inline">Content-Type</strong> as, by default, we won’t accept JSON – only <strong class="source-inline">application/x-www-form-urlencoded</strong>, <strong class="source-inline">multipart/form-data</strong>, or <strong class="source-inline">text/plain</strong> <span class="No-Break">are accepted.</span></p>
<p>We also use <strong class="source-inline">AllowCredentials</strong> to specify that the user agent may pass authentication details along with the request, and finally, we’re specifying our dev server’s location, both for <strong class="source-inline">localhost</strong> and the <strong class="source-inline">0.0.0.0</strong> address. This might be slight overkill but can help if your backend and frontend <span class="No-Break">start differently.</span></p>
<p>For a production-ready <a id="_idIndexMarker343"/>version of our project, you will want to inject these as environment variables to avoid mixing development and production config files. If you leverage <span class="No-Break"><strong class="source-inline">env.go</strong></span><span class="No-Break"> from</span>
<a href="B18295_06.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Moving to API - First</em> – available at <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go</a> – you will do something like <span class="No-Break">the following:</span></p>
<pre class="source-code">
rtr.Use(
    handlers.CORS(
        handlers.AllowedHeaders(
            env.GetAsSlice("ALLOWED_HEADERS")),
        handlers.AllowedOrigins(
            env.GetAsSlice("ORIGIN_WHITELIST")),
        handlers.AllowCredentials(),
        handlers.AllowedMethods([]string{
            http.MethodGet,
            http.MethodPost,
        })),
    )</pre>
<p>Once your server is configured correctly, (re)start both the backend and the frontend, and you should now be able to call your backend service to use <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong>. You’ve now completed a <a id="_idTextAnchor194"/><span class="No-Break">full-stack project!</span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="Figure 9.6: UI displaying output from the server" height="379" src="image/Figure_9.06_B18295.jpg" width="603"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6: UI displaying output from the server</p>
<p>In this section, we looked at adding<a id="_idIndexMarker344"/> CORS functionality to our application, allowing the frontend to access our API. In the next section, we will look at exploring Vue middleware that will help to provide common data <span class="No-Break">transformation functionality.</span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor195"/>Creating Vue middleware</h1>
<p>Working with Vue (and Axios) and <a id="_idIndexMarker345"/>Golang, we’ve shown we can bring all of learning so far all together, but we’ve missed one small aspect. We’ve deliberately omitted the JSON <strong class="source-inline">struct</strong> tags from our Golang code. If we add them back into our <strong class="source-inline">backend/server.go</strong> and rerun both the server and app, our requests no <span class="No-Break">longer work!</span></p>
<pre class="source-code">
func appPOST() http.HandlerFunc {
    type RequestBody struct {
        InboundMsg string `<strong class="bold">json:"inbound_msg,omitempty</strong>"`
    }
    type ResponseBody struct {
        OutboundMsg string `<strong class="bold">json:"outbound_msg,omitempty</strong>"`
    }
...</pre>
<p>Our frontend and backend can no longer communicate as the contract has changed; the frontend is communicating in CamelCase, while the backend is communicating <span class="No-Break">in snake_case.</span></p>
<p>This isn’t a show-stopper, as we’ve proven we can work around it, but sometimes we don’t have the luxury of telling the backend service what format to use. Thankfully, Axios can be modified to add transformers to our requests that will modify inbound and outbound requests to match whichever backend formatting <span class="No-Break">we’re given.</span></p>
<p>To build our <a id="_idIndexMarker346"/>transformers, we’ll install and use two new packages to help us to create our transformers. These will be used to convert between the different <span class="No-Break">formats/case types:</span></p>
<pre class="console">
$ npm install snakecase-keys camelcase-keys</pre>
<p>Finally, we’ll modify our <strong class="source-inline">lib/api.js</strong> file to use these libraries to format <span class="No-Break">our payloads:</span></p>
<pre class="source-code">
import axios from 'axios';
import camelCaseKeys from 'camelcase-keys';
<strong class="bold">import snakeCaseKeys from 'snakecase-keys'</strong>;
<strong class="bold">function isObject(value) {</strong>
<strong class="bold">  return typeof value === 'object' &amp;&amp; value instanceof</strong>
<strong class="bold">    Object;</strong>
<strong class="bold">}</strong>
<strong class="bold">export function transformSnakeCase(data) {</strong>
<strong class="bold">  if (isObject(data) || Array.isArray(data)) {</strong>
<strong class="bold">    return snakeCaseKeys(data, { deep: true });</strong>
<strong class="bold">  }</strong>
<strong class="bold">  if (typeof data === 'string') {</strong>
<strong class="bold">    try {</strong>
<strong class="bold">      const parsedString = JSON.parse(data);</strong>
<strong class="bold">      const snakeCase = snakeCaseKeys(parsedString, { deep:</strong>
<strong class="bold">                                      true });</strong>
<strong class="bold">      return JSON.stringify(snakeCase);</strong>
<strong class="bold">    } catch (error) {</strong>
<strong class="bold">      // Bailout with no modification</strong>
<strong class="bold">      return data;</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
<strong class="bold">  return data;</strong>
<strong class="bold">}</strong>
<strong class="bold">export function transformCamelCase(data) {</strong>
<strong class="bold">  if (isObject(data) || Array.isArray(data)) {</strong>
<strong class="bold">    return camelCaseKeys(data, { deep: true });</strong>
<strong class="bold">  }</strong>
<strong class="bold">  return data;</strong>
<strong class="bold">}</strong>
export default axios.create({
  baseURL: import.meta.env.VITE_BASE_API_URL,
  withCredentials: true,
<strong class="bold">  transformRequest: [...axios.defaults.transformRequest,</strong>
<strong class="bold">                     transformSnakeCase],</strong>
<strong class="bold">  transformResponse: [...axios.defaults.transformResponse,</strong>
<strong class="bold">                      transformCamelCase],</strong>
});</pre>
<p>This code might look like a lot, but it’s what we need to create our transformers. We create a <strong class="source-inline">to</strong> function and a <strong class="source-inline">from</strong> function to add as transformers to the Axios instantiation. We transform the requests into snake_case on the outbound/request and transform them to CamelCase on the inbound/response. If you want to dive into the specifics of creating transformers for Axios, you can find more on the<a id="_idIndexMarker347"/> website at <a href="https://axios-http.com/docs/req_config">https://axios-http.com/docs/req_config</a>, which includes a look at all the other numerous configs and parameters that can be provided for the <span class="No-Break">Axios library.</span></p>
<p>There are a few <a id="_idIndexMarker348"/>different methods/libraries we could use to accomplish the same goal – for example, the <strong class="source-inline">humps</strong> package from <a href="https://www.npmjs.com/package/humps">https://www.npmjs.com/package/humps</a> is another library we could use to expose similar functionality, but what we are using work<a id="_idTextAnchor196"/>s well for our <span class="No-Break">use case.</span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor197"/>Summary</h1>
<p>This chapter introduced Tailwind CSS and discussed its utility-first approach. We’ve previously seen samples of it in <a href="B18295_04.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Serving and Embedding HTML Content</em>, where we were provided with the HTML/CSS, but this is our first look at using it and how we can rapidly create components outside of heavier frameworks, as well as how we can rapidly integrate it with our frontend Vue application with configuration and how we can test its <span class="No-Break">successful installation.</span></p>
<p>In this chapter, we created a full-stack application, bringing our expertise together thus far. We’ve successfully built a frontend application in Vue that communicates with our backend in Golang; as part of this, we also looked at how to configure and use Axios and how to mitigate common CORS issues, before concluding with a brief look at using middleware in our Vue app to allow us to communicate across different JSON schemas in <span class="No-Break">the backend.</span></p>
<p>In the next chapter, we’ll look into securing our sessions, using JWTs for sessions, middleware, and creating and using navigation guards <span class="No-Break">in Vue.</span></p>
</div>
</div></body></html>