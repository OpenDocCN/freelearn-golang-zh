- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Tailwind, Middleware, and CORS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tailwind、中间件和 CORS
- en: In this chapter, we will build on the frontend principles we introduced previously
    by introducing Tailwind CSS, explore how we can consume our backend services via
    an API from our frontend app, see how we can leverage middleware to transform
    our JSON requests, and look at how we can provide a secure **Single-Page App**
    (**SPA**) with a user login.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于之前介绍的前端原则，引入 Tailwind CSS，探讨我们如何通过前端应用中的 API 消费后端服务，了解我们如何利用中间件来转换我们的
    JSON 请求，以及如何提供一个具有用户登录功能的**单页应用**（**SPA**）。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating and designing frontend applications using the Tailwind CSS framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tailwind CSS 框架创建和设计前端应用程序
- en: Getting an understanding of how to use the Vite CLI to create new Vue applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 Vite CLI 创建新的 Vue 应用程序
- en: Configuring our Go service for CORS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们的 Go 服务以支持 CORS
- en: Setting up a JavaScript Axios library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 JavaScript Axios 库
- en: Creating middleware to manage JSON formatting between the frontend and the backend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建中间件以管理前端和后端之间的 JSON 格式化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09)上查看。
- en: Introducing Tailwind
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Tailwind
- en: In the previous chapter, we looked at a number of different frontend frameworks
    to help us go faster, but we’ve been ignoring an elephant in the room of a modern
    web ecosystem – Tailwind CSS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们查看了一些不同的前端框架，以帮助我们更快地开发，但我们一直忽略了一个现代网络生态系统中显而易见的“大象”——Tailwind CSS。
- en: Frameworks such as Buefy and Vuetify have a major disadvantage. Due to increasing
    demand for more and more features, growth, and usage, they became a victim of
    their own success and ended up too big, giving us less control over our component
    styles.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Buefy 和 Vuetify 这样的框架有一个主要缺点。由于对更多和更多功能的日益增长的需求，增长和使用，它们成为了自己成功的受害者，最终变得过于庞大，使我们对自己的组件样式控制减少。
- en: Learning about frameworks such as Buefy has become increasingly challenging.
    Developers have to learn about hundreds of classes and components and then potentially
    rebuild them just for small style tweaks that were simply not envisioned by the
    upstream community.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解像 Buefy 这样的框架变得越来越具有挑战性。开发者必须学习数百个类和组件，然后可能只是为了对上游社区没有预想的微小样式调整而重新构建它们。
- en: Tailwind is a CSS framework that, unlike other frameworks, does not come prebuilt
    with classes to add to HTML tags. Instead, it uses a different approach. It brings
    a much lower level of control by removing ALL default styling from the stylesheet
    and using utility-based classes to compose and build your app. These utility-based
    classes provide ways to directly manipulate certain CSS attributes individually,
    such as text size, margins, spacing, padding, and colors, as well as behavior
    for mobile, desktop, and other viewports. By applying different tailwind modifiers,
    we have granular control over the final appearance of an element while ensuring
    consistent styling and an easy escape route if we need to build slight variations.
    This really helps in building our Vue components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他框架不同，Tailwind 是一个 CSS 框架，它不预先内置类以添加到 HTML 标签中。相反，它采用不同的方法。通过从样式表中移除所有默认样式并使用基于实用性的类来组合和构建您的应用程序，它提供了更低的控制级别。这些基于实用性的类提供了直接操作某些
    CSS 属性的方法，例如文本大小、边距、间距、填充和颜色，以及针对移动、桌面和其他视口的交互行为。通过应用不同的 Tailwind 修饰符，我们可以在确保一致样式的同时，对元素的最终外观进行细粒度控制，并在需要构建微小变化时提供简单的解决方案。这真有助于构建我们的
    Vue 组件。
- en: '![Figure 9.1: A button sample](img/Figure_9.01_B18295.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：按钮示例](img/Figure_9.01_B18295.jpg)'
- en: 'Figure 9.1: A button sample'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：按钮示例
- en: 'A quick example of creating a blue button can be seen with the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建蓝色按钮的快速示例如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may be saying to yourself, “Wow, that’s a lot of CSS for a button,” but
    when you consider how Vue helps us build reusable `button`, `link`, `image`, `div`,
    or `paragraph`. You can check the official docs at [https://tailwindcss.com/docs/utility-first](https://tailwindcss.com/docs/utility-first)
    to dive further into the concepts behind “utility-first” CSS and what the individual
    classes do.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对自己说，“哇，对于一个按钮来说，CSS 真的很多，”但当你考虑到 Vue 如何帮助我们构建可重用的 `button`、`link`、`image`、`div`
    或 `paragraph` 时，你会这样想。你可以查看官方文档[https://tailwindcss.com/docs/utility-first](https://tailwindcss.com/docs/utility-first)以深入了解“实用优先”CSS
    的概念以及各个类的作用。
- en: Creating a new Tailwind and Vite project
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的 Tailwind 和 Vite 项目
- en: 'To create our project, we’re going to first generate it with the `Vite CLI`.
    This will give us the familiar “`Hello World`” output you see here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的项目，我们首先将使用 `Vite CLI` 生成它。这将给我们带来熟悉的“`Hello World`”输出，如下所示：
- en: '![Figure 9.2: Hello World web output](img/Figure_9.02_B18295.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2：Hello World 网页输出](img/Figure_9.02_B18295.jpg)'
- en: 'Figure 9.2: Hello World web output'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：Hello World 网页输出
- en: 'Let’s create a new Vue project with Vite using the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令使用 Vite 创建一个新的 Vue 项目：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For each of the questions asked, enter the information shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个提出的问题，请输入此处显示的信息：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Going to `http://localhost:3000` will now show the screenshot from *Figure 9**.2*.
    Our project is enabled with “hot reload” or “live reload” so as you change the
    project code, you will be able to see the design in the browser update when you
    save the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:3000` 现在将显示图 9**.2** 的截图。我们的项目启用了“热重载”或“实时重载”，所以当你更改项目代码时，你将在保存文件时看到浏览器中的设计更新。
- en: Previous versions of Tailwind CSS had a bit of a reputation for generating large
    stylesheets (between 3 and 15 MB!) and slowing down build times.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之前版本的 Tailwind CSS 有一点点以生成大型样式表（3 到 15 MB！）和减慢构建时间为特点。
- en: At the end of the Tailwind CSS version 2 era, the team introduced a new **Just-In-Time**
    (**JIT**) compiler that automatically generates only the necessary CSS required
    to style your design. This was originally available as an optional plugin but
    brought massive improvements by reducing bloat, and with JIT, the CSS in development
    is the same as your final code, which meant no post-processing of the CSS is required
    for your final builds. Since Tailwind CSS version 3 and above, the JIT compiler
    has been enabled by default when we install Tailwind CSS, so we don’t have to
    worry about altering anything in our config file other than what is needed to
    lay out our project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tailwind CSS 版本 2 时代的末期，团队引入了一个新的**即时编译器**（**JIT**），它会自动生成仅用于样式化设计的必要 CSS。最初这作为一个可选插件提供，但通过减少冗余，带来了巨大的改进，并且有了
    JIT，开发中的 CSS 与最终代码相同，这意味着最终构建不需要对 CSS 进行后处理。自从 Tailwind CSS 版本 3 及以上，JIT 编译器在安装
    Tailwind CSS 时默认启用，所以我们不需要担心在配置文件中更改任何东西，除了我们需要的布局项目之外。
- en: 'We’re going to now add Tailwind CSS to our project and make some changes to
    the default Vue `Hello World` output provided by the scaffolding from both the
    Vue and Tailwind packages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向我们的项目添加 Tailwind CSS 并对来自 Vue 和 Tailwind 包的脚手架提供的默认 Vue `Hello World`
    输出进行一些修改：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The directives beginning with `@tailwind` in the `tailwind.css` file are part
    of how we tell the JIT compiler what to apply to generate the CSS – we will only
    leverage the base, component and utility directives and refer you to the Tailwind
    CSS official docs for more on this – [https://tailwindcss.com/docs/functions-and-directives](https://tailwindcss.com/docs/functions-and-directives).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tailwind.css` 文件中，以 `@tailwind` 开头的指令是告诉我们即时编译器应用什么以生成 CSS 的一部分——我们将仅利用基础、组件和实用指令，并将你指引到
    Tailwind CSS 官方文档以了解更多信息——[https://tailwindcss.com/docs/functions-and-directives](https://tailwindcss.com/docs/functions-and-directives)。
- en: 'We can now open up our `HelloWorld.vue` file and replace the contents with
    the following to create our button. The cool part with our dev server still running
    is that you should be able to see the changes in real time if you save your file
    as you manipulate the `button` classes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以打开我们的 `HelloWorld.vue` 文件，将其内容替换为以下内容以创建我们的按钮。由于我们的开发服务器仍在运行，所以在你操作 `button`
    类时，如果你将文件保存为实时，你应该能够看到变化：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should end up with something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终应该得到类似这样的结果：
- en: '![Figure 9.3: The Click me button](img/Figure_9.03_B18295.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：点击我按钮](img/Figure_9.03_B18295.jpg)'
- en: 'Figure 9.3: The Click me button'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：点击我按钮
- en: Congratulations! You’ve created your first Tailwind and Vite project. You can
    see the complete example inside the `chapter9/tailwind-vite-demo` folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建了您的第一个 Tailwind 和 Vite 项目。您可以在 `chapter9/tailwind-vite-demo` 文件夹内看到完整的示例。
- en: In the next section, we will look at how to use the API that we developed in
    Golang from our frontend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何从我们的前端使用我们用 Golang 开发的 API。
- en: Consuming your Golang APIs
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费您的 Golang API
- en: We’re going to build on our previous frontend example to add some functions
    to `GET` and `POST` from a simple backend service. The source code can be found
    inside the `chapter9/backend` folder; it focuses on two simplified functions that
    do little more than return a fixed string for `GET` and a reversed string based
    on the `POST` request that we sent.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在之前的前端示例基础上添加一些功能，以从简单的后端服务中实现 `GET` 和 `POST`。源代码可以在 `chapter9/backend` 文件夹内找到；它主要关注两个简化的函数，这两个函数除了为
    `GET` 返回一个固定的字符串外，还基于我们发送的 `POST` 请求返回一个反转的字符串。
- en: 'The `appGET()` function provides the functionality to perform a `GET` operation,
    while the `appPOST()` function provides it for a `POST` operation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`appGET()` 函数提供了执行 `GET` 操作的功能，而 `appPOST()` 函数提供了 `POST` 操作的功能：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ll start our service by using `go run server.go`, with a view to consuming
    this data from our frontend application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `go run server.go` 来启动我们的服务，目的是从我们的前端应用程序中消费这些数据。
- en: 'We’re going to create two utility functions in our frontend app to allow us
    to interact with our frontend app, and we’re going to be building these on top
    of Axios. Axios is a Promise-based HTTP client for the browser that abstracts
    all the browser-specific code needed to interact with backend services and does
    an incredible job in providing a single interface for web requests across all
    browsers , which you can read more about at the official docs here: [https://axios-http.com/](https://axios-http.com/).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的前端应用程序中创建两个实用函数，以便我们能够与之交互，并且我们将基于 Axios 来构建这些函数。Axios 是一个基于 Promise
    的浏览器 HTTP 客户端，它抽象了与后端服务交互所需的浏览器特定代码，并在提供跨所有浏览器的单一接口进行网络请求方面做得非常出色，您可以在官方文档中了解更多信息：[https://axios-http.com/](https://axios-http.com/)。
- en: 'We’re going to first install `axios`, then set up our Axios instance, and then
    we can layer on functionality:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装 `axios`，然后设置我们的 Axios 实例，然后我们可以添加功能层：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With `axios` installed, you’ll now want to create a `lib/api.js` file containing
    the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 `axios` 后，您现在将想要创建一个包含以下内容的 `lib/api.js` 文件：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s a couple of interesting things to note here; the first is the `baseURL`
    value, and the second is `withCredentials`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个有趣的地方需要注意；第一个是 `baseURL` 值，第二个是 `withCredentials`。
- en: The `baseURL` value is what Axios uses to build all subsequent requests on top
    of. If we called `axios.Patch('/foo')` with a `baseURL` value of [https://www.packtpub.com/](https://www.packtpub.com/),
    it would perform a `PATCH` call to [https://www.packtpub.com/foo](https://www.packtpub.com/foo).
    This is a great way to switch between development and production and ensure you
    reduce typos.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseURL` 值是 Axios 用于构建所有后续请求的基础。如果我们使用 `baseURL` 值为 [https://www.packtpub.com/](https://www.packtpub.com/)
    调用 `axios.Patch(''/foo'')`，它将执行一个 `PATCH` 调用到 [https://www.packtpub.com/foo](https://www.packtpub.com/foo)。这是一种在开发和生产之间切换并确保您减少错误的好方法。'
- en: 'But what are we doing with `import.meta.env`? This is partly how Vite imports
    and exposes environment variables. We’re going to add our `VITE_BASE_API_URL`
    to a `.env` file situated at the base of our project containing the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们是如何使用 `import.meta.env` 的呢？这部分是 Vite 如何导入和暴露环境变量的方式。我们将把我们的 `VITE_BASE_API_URL`
    添加到项目根目录下的 `.env` 文件中，包含以下内容：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Combined with this and our new `lib/api.js` file, we can now call `axios.Put('/test')`
    from our code, and by default, it will reference http://0.0.0.0:8000/test. You
    can see more about how Vite handles environment variables and more at [https://vitejs.dev/guide/env-and-mode.xhtml](https://vitejs.dev/guide/env-and-mode.xhtml).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这一点和我们的新 `lib/api.js` 文件，我们现在可以从我们的代码中调用 `axios.Put('/test')`，默认情况下，它将引用 http://0.0.0.0:8000/test。您可以在
    [https://vitejs.dev/guide/env-and-mode.xhtml](https://vitejs.dev/guide/env-and-mode.xhtml)
    了解更多关于 Vite 处理环境变量和更多信息。
- en: The other part to note is the `withCredentials` property. This value indicates
    whether or not cross-site access control requests should be made using credentials
    such as cookies and authorization headers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是 `withCredentials` 属性。此值指示是否应使用诸如 cookies 和授权头之类的凭据进行跨站访问控制请求。
- en: The reason we want this property is that we want all our cookie settings to
    be consistent, but we’ll need to ensure our backend app understands it, which
    we’ll cover shortly. Setting `withCredentials` has no effect on same-site requests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 加粗的部分是最有趣的部分。这些展示了我们如何使用 `GET` 和 `POST` 与我们的数据一起使用，使用我们后端服务器上设置的库和API调用，以及我们如何在Vue模块中绑定数据和引用它。
- en: 'Now that we’ve used this to instantiate our `axios` instance, we can leverage
    this by creating our own `api/demo.js` file inside our frontend application’s
    `src` folder. It’s not a very original name but it works for us:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 安全应用的CORS
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code exports two functions called `getFromServer` and `postToServer`, with
    an additional `data` parameter being sent as the `POST` body on the latter function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用它来实例化我们的 `axios` 实例，我们可以在我们的前端应用程序的 `src` 文件夹内创建自己的 `api/demo.js` 文件。这个名字可能不是非常原创，但对我们来说很适用：
- en: 'A neat trick here is the usage of the `@` import – this is common in a lot
    of setups to allow us to quickly specify the base path for our code to keep things
    clean and remove relative/absolute pathing with lots of `../..` referenced everywhere.
    If you forget this, you’ll see errors such as this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小技巧，就是使用 `@` 导入——这在很多设置中很常见，允许我们快速指定代码的基础路径，使事情保持整洁，并移除到处都有很多 `../..` 的相对/绝对路径。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Not great! To fix this, open up your `vite.config.js` file and replace the
    contents with the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错！为了解决这个问题，打开你的 `vite.config.js` 文件，并用以下内容替换其内容：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I’ve bolded the key parts that we’re adding. We’re telling Vite to use the `@`
    symbol as an alias so that when we use `@` in a path, it calls `path.resolve()`
    to resolve the path segments into an absolute path.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第6章*](B18295_06.xhtml#_idTextAnchor093) 中，*转向API-First*，我们介绍了我们的后端CORS中间件。现在我们需要更新我们的新后端服务。它需要响应
    `OPTION` 预检请求，正如我们在 [*第6章*](B18295_06.xhtml#_idTextAnchor093) 中讨论的，*转向API-First*，还需要确定我们将允许与我们的服务通信的URL。这是必要的，以确保我们的浏览器不会被欺骗提交/修改来自其他来源的应用程序。
- en: With all of this now set up, we’re going to open up our `HelloWorld.vue` and
    update it, the goal being to create something that looks like *Figure 9**.4*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些都设置好了，我们将打开我们的 `HelloWorld.vue` 并更新它，目标是创建一个看起来像 *图9**.4* 的东西。
- en: '![Figure 9.4: The UI for GET and POST](img/Figure_9.04_B18295.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：GET和POST的UI](img/Figure_9.04_B18295.jpg)'
- en: 'Figure 9.4: The UI for GET and POST'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要这个属性的原因是我们希望所有的cookie设置都是一致的，但我们需要确保我们的后端应用理解它，这我们将在稍后讨论。设置 `withCredentials`
    对同站请求没有影响。
- en: 'Here is the full code for `HelloWorld.vue`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它不起作用！我们非常接近，但首先，我们必须回顾一下我们之前章节中提到的CORS。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The parts in bold are the most interesting parts. These show how we can use
    `GET` and `POST` with our data, using our libraries and API calls from the backend
    server that we set up, as well as how we can bind the data and reference it in
    our Vue modules.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你一直在运行的 `backend/server.go` 示例并审查主函数：
- en: Hopefully, after making all these changes, your Vite instance is still running;
    if not, start it with `npm run dev`, and you should get the screenshot from *Figure
    9**.4*. Click the **Click to Get** button and enter some data to send via the
    **Click to** **post**button.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了这一点，你会看到这样的错误：
- en: '![Figure 9.5: Peeking into the HTTP traffic](img/Figure_9.05_B18295.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：窥视HTTP流量](img/Figure_9.05_B18295.jpg)'
- en: 'Figure 9.5: Peeking into the HTTP traffic'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：窥视HTTP流量
- en: It doesn’t work! We’re so close, but first, we have to revisit CORS from one
    of our previous chapters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导出了两个函数，分别称为 `getFromServer` 和 `postToServer`，在后者函数中，还有一个额外的 `data` 参数作为POST主体的发送。
- en: CORS for secure applications
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图9.4：GET和POST的UI
- en: In [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093), *Moving to API-First*, we
    introduced the CORS middleware for our backend. We’ve now got to update our new
    backend service. It will need to respond to `OPTION` preflight requests, as we
    discussed in [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093), *Moving to API-First*,
    and will also need to identify the URLs that we’re going to allow to talk to our
    service. This is necessary to ensure our browsers aren’t being tricked into submitting/modifying
    applications from other sources.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在做出所有这些更改后，你的 Vite 实例仍然在运行；如果不是，请使用 `npm run dev` 启动它，你应该会得到 *图9**.4* 的截图。点击
    **点击获取** 按钮并输入一些要通过 **点击** **POST** 按钮发送的数据。
- en: 'Open up the `backend/server.go` sample you’ve been running and review the main
    function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经加粗了我们要添加的关键部分。我们告诉 Vite 使用 `@` 符号作为别名，这样当我们使用 `@` 在路径中时，它就会调用 `path.resolve()`
    将路径段解析为绝对路径。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As before, I’ve put the key parts in bold. You can see we’ve appended `http.MethodOptions`
    to our `POST` handler, and we’ve also layered in some additional middleware.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我将关键部分加粗。你可以看到我们向我们的 `POST` 处理器添加了 `http.MethodOptions`，并且我们还添加了一些额外的中间件。
- en: '`AllowedHeaders` has been included, and we’re specifically accepting `Content-Type`
    as, by default, we won’t accept JSON – only `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain` are accepted.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了 `AllowedHeaders`，我们特别接受 `Content-Type`，因为我们默认不接受 JSON – 只接受 `application/x-www-form-urlencoded`、`multipart/form-data`
    或 `text/plain`。
- en: We also use `AllowCredentials` to specify that the user agent may pass authentication
    details along with the request, and finally, we’re specifying our dev server’s
    location, both for `localhost` and the `0.0.0.0` address. This might be slight
    overkill but can help if your backend and frontend start differently.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `AllowCredentials` 来指定用户代理可以将身份验证详情与请求一起传递，并且最后，我们指定了我们的开发服务器的位置，包括 `localhost`
    和 `0.0.0.0` 地址。这可能有点过度，但如果你的后端和前端以不同的方式启动，这可能会很有帮助。
- en: 'For a production-ready version of our project, you will want to inject these
    as environment variables to avoid mixing development and production config files.
    If you leverage `env.go` from [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093),
    *Moving to API - First* – available at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go)
    – you will do something like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们项目的生产版本，你将想要将这些作为环境变量注入，以避免混合开发和生产配置文件。如果你利用来自 [*第 6 章*](B18295_06.xhtml#_idTextAnchor093)
    的 `env.go` – 可在 [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go)
    获取 – 你将做如下操作：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once your server is configured correctly, (re)start both the backend and the
    frontend, and you should now be able to call your backend service to use `GET`
    and `POST`. You’ve now completed a full-stack project!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的服务器配置正确，重新启动后端和前端，你现在应该能够调用你的后端服务以使用 `GET` 和 `POST`。你现在已经完成了一个全栈项目！
- en: '![Figure 9.6: UI displaying output from the server](img/Figure_9.06_B18295.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6：显示服务器输出的 UI](img/Figure_9.06_B18295.jpg)'
- en: 'Figure 9.6: UI displaying output from the server'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：显示服务器输出的 UI
- en: In this section, we looked at adding CORS functionality to our application,
    allowing the frontend to access our API. In the next section, we will look at
    exploring Vue middleware that will help to provide common data transformation
    functionality.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了向我们的应用程序添加 CORS 功能，允许前端访问我们的 API。在下一节中，我们将探讨探索 Vue 中间件，这将有助于提供常见的数据转换功能。
- en: Creating Vue middleware
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Vue 中间件
- en: Working with Vue (and Axios) and Golang, we’ve shown we can bring all of learning
    so far all together, but we’ve missed one small aspect. We’ve deliberately omitted
    the JSON `struct` tags from our Golang code. If we add them back into our `backend/server.go`
    and rerun both the server and app, our requests no longer work!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vue（和 Axios）以及 Golang，我们展示了我们可以将迄今为止的所有学习内容整合在一起，但我们遗漏了一个小的方面。我们故意从我们的 Golang
    代码中省略了 JSON `struct` 标签。如果我们将它们添加回我们的 `backend/server.go` 并重新运行服务器和应用程序，我们的请求将不再工作！
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our frontend and backend can no longer communicate as the contract has changed;
    the frontend is communicating in CamelCase, while the backend is communicating
    in snake_case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于合约已更改，我们的前端和后端无法再进行通信；前端使用 CamelCase 进行通信，而后端使用 snake_case 进行通信。
- en: This isn’t a show-stopper, as we’ve proven we can work around it, but sometimes
    we don’t have the luxury of telling the backend service what format to use. Thankfully,
    Axios can be modified to add transformers to our requests that will modify inbound
    and outbound requests to match whichever backend formatting we’re given.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个阻止我们前进的问题，因为我们已经证明我们可以绕过它，但有时我们没有告诉后端服务使用什么格式的奢侈。幸运的是，Axios 可以修改以添加转换器到我们的请求中，这将修改传入和传出的请求以匹配我们给出的任何后端格式。
- en: 'To build our transformers, we’ll install and use two new packages to help us
    to create our transformers. These will be used to convert between the different
    formats/case types:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的转换器，我们将安装并使用两个新的包来帮助我们创建转换器。这些将被用于在不同的格式/大小写类型之间进行转换：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we’ll modify our `lib/api.js` file to use these libraries to format
    our payloads:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改我们的 `lib/api.js` 文件以使用这些库来格式化我们的有效载荷：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code might look like a lot, but it’s what we need to create our transformers.
    We create a `to` function and a `from` function to add as transformers to the
    Axios instantiation. We transform the requests into snake_case on the outbound/request
    and transform them to CamelCase on the inbound/response. If you want to dive into
    the specifics of creating transformers for Axios, you can find more on the website
    at [https://axios-http.com/docs/req_config](https://axios-http.com/docs/req_config),
    which includes a look at all the other numerous configs and parameters that can
    be provided for the Axios library.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能看起来很多，但这是我们创建转换器所需的内容。我们创建一个`to`函数和一个`from`函数，将其作为转换器添加到Axios实例化中。我们将请求转换为snake_case（蛇形命名），在出站/请求时，并将它们转换为CamelCase（驼峰命名），在入站/响应时。如果您想深入了解为Axios创建转换器的具体细节，您可以在网站[https://axios-http.com/docs/req_config](https://axios-http.com/docs/req_config)上找到更多信息，其中包含了对所有其他众多可以提供给Axios库的配置和参数的查看。
- en: There are a few different methods/libraries we could use to accomplish the same
    goal – for example, the `humps` package from [https://www.npmjs.com/package/humps](https://www.npmjs.com/package/humps)
    is another library we could use to expose similar functionality, but what we are
    using works well for our use case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几种不同的方法/库来实现相同的目标——例如，来自[https://www.npmjs.com/package/humps](https://www.npmjs.com/package/humps)的`humps`包是我们可以使用来提供类似功能的另一个库，但我们所使用的方法非常适合我们的用例。
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced Tailwind CSS and discussed its utility-first approach.
    We’ve previously seen samples of it in [*Chapter 4*](B18295_04.xhtml#_idTextAnchor053),
    *Serving and Embedding HTML Content*, where we were provided with the HTML/CSS,
    but this is our first look at using it and how we can rapidly create components
    outside of heavier frameworks, as well as how we can rapidly integrate it with
    our frontend Vue application with configuration and how we can test its successful
    installation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Tailwind CSS，并讨论了其以实用工具为先的方法。我们之前在[*第4章*](B18295_04.xhtml#_idTextAnchor053)中看到了它的示例，*服务和嵌入HTML内容*，在那里我们提供了HTML/CSS，但这是我们第一次使用它，以及我们如何快速创建组件，以及如何快速将其与我们的前端Vue应用程序集成，包括配置，以及如何测试其成功的安装。
- en: In this chapter, we created a full-stack application, bringing our expertise
    together thus far. We’ve successfully built a frontend application in Vue that
    communicates with our backend in Golang; as part of this, we also looked at how
    to configure and use Axios and how to mitigate common CORS issues, before concluding
    with a brief look at using middleware in our Vue app to allow us to communicate
    across different JSON schemas in the backend.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个全栈应用程序，将迄今为止的专长结合起来。我们成功地在Vue中构建了一个前端应用程序，并与我们的Golang后端进行通信；作为其中的一部分，我们还探讨了如何配置和使用Axios，以及如何减轻常见的CORS问题，最后简要地查看如何在Vue应用程序中使用中间件，以便我们能够在后端的不同JSON模式之间进行通信。
- en: In the next chapter, we’ll look into securing our sessions, using JWTs for sessions,
    middleware, and creating and using navigation guards in Vue.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何确保我们的会话安全，使用JWT进行会话、中间件，以及在Vue中创建和使用导航守卫。
