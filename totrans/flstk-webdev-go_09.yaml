- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tailwind, Middleware, and CORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build on the frontend principles we introduced previously
    by introducing Tailwind CSS, explore how we can consume our backend services via
    an API from our frontend app, see how we can leverage middleware to transform
    our JSON requests, and look at how we can provide a secure **Single-Page App**
    (**SPA**) with a user login.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and designing frontend applications using the Tailwind CSS framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting an understanding of how to use the Vite CLI to create new Vue applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring our Go service for CORS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a JavaScript Axios library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating middleware to manage JSON formatting between the frontend and the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Tailwind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at a number of different frontend frameworks
    to help us go faster, but we’ve been ignoring an elephant in the room of a modern
    web ecosystem – Tailwind CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks such as Buefy and Vuetify have a major disadvantage. Due to increasing
    demand for more and more features, growth, and usage, they became a victim of
    their own success and ended up too big, giving us less control over our component
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about frameworks such as Buefy has become increasingly challenging.
    Developers have to learn about hundreds of classes and components and then potentially
    rebuild them just for small style tweaks that were simply not envisioned by the
    upstream community.
  prefs: []
  type: TYPE_NORMAL
- en: Tailwind is a CSS framework that, unlike other frameworks, does not come prebuilt
    with classes to add to HTML tags. Instead, it uses a different approach. It brings
    a much lower level of control by removing ALL default styling from the stylesheet
    and using utility-based classes to compose and build your app. These utility-based
    classes provide ways to directly manipulate certain CSS attributes individually,
    such as text size, margins, spacing, padding, and colors, as well as behavior
    for mobile, desktop, and other viewports. By applying different tailwind modifiers,
    we have granular control over the final appearance of an element while ensuring
    consistent styling and an easy escape route if we need to build slight variations.
    This really helps in building our Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: A button sample](img/Figure_9.01_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: A button sample'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick example of creating a blue button can be seen with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may be saying to yourself, “Wow, that’s a lot of CSS for a button,” but
    when you consider how Vue helps us build reusable `button`, `link`, `image`, `div`,
    or `paragraph`. You can check the official docs at [https://tailwindcss.com/docs/utility-first](https://tailwindcss.com/docs/utility-first)
    to dive further into the concepts behind “utility-first” CSS and what the individual
    classes do.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Tailwind and Vite project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create our project, we’re going to first generate it with the `Vite CLI`.
    This will give us the familiar “`Hello World`” output you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Hello World web output](img/Figure_9.02_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Hello World web output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new Vue project with Vite using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For each of the questions asked, enter the information shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Going to `http://localhost:3000` will now show the screenshot from *Figure 9**.2*.
    Our project is enabled with “hot reload” or “live reload” so as you change the
    project code, you will be able to see the design in the browser update when you
    save the file.
  prefs: []
  type: TYPE_NORMAL
- en: Previous versions of Tailwind CSS had a bit of a reputation for generating large
    stylesheets (between 3 and 15 MB!) and slowing down build times.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the Tailwind CSS version 2 era, the team introduced a new **Just-In-Time**
    (**JIT**) compiler that automatically generates only the necessary CSS required
    to style your design. This was originally available as an optional plugin but
    brought massive improvements by reducing bloat, and with JIT, the CSS in development
    is the same as your final code, which meant no post-processing of the CSS is required
    for your final builds. Since Tailwind CSS version 3 and above, the JIT compiler
    has been enabled by default when we install Tailwind CSS, so we don’t have to
    worry about altering anything in our config file other than what is needed to
    lay out our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to now add Tailwind CSS to our project and make some changes to
    the default Vue `Hello World` output provided by the scaffolding from both the
    Vue and Tailwind packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The directives beginning with `@tailwind` in the `tailwind.css` file are part
    of how we tell the JIT compiler what to apply to generate the CSS – we will only
    leverage the base, component and utility directives and refer you to the Tailwind
    CSS official docs for more on this – [https://tailwindcss.com/docs/functions-and-directives](https://tailwindcss.com/docs/functions-and-directives).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now open up our `HelloWorld.vue` file and replace the contents with
    the following to create our button. The cool part with our dev server still running
    is that you should be able to see the changes in real time if you save your file
    as you manipulate the `button` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The Click me button](img/Figure_9.03_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The Click me button'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve created your first Tailwind and Vite project. You can
    see the complete example inside the `chapter9/tailwind-vite-demo` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to use the API that we developed in
    Golang from our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming your Golang APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to build on our previous frontend example to add some functions
    to `GET` and `POST` from a simple backend service. The source code can be found
    inside the `chapter9/backend` folder; it focuses on two simplified functions that
    do little more than return a fixed string for `GET` and a reversed string based
    on the `POST` request that we sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `appGET()` function provides the functionality to perform a `GET` operation,
    while the `appPOST()` function provides it for a `POST` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ll start our service by using `go run server.go`, with a view to consuming
    this data from our frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to create two utility functions in our frontend app to allow us
    to interact with our frontend app, and we’re going to be building these on top
    of Axios. Axios is a Promise-based HTTP client for the browser that abstracts
    all the browser-specific code needed to interact with backend services and does
    an incredible job in providing a single interface for web requests across all
    browsers , which you can read more about at the official docs here: [https://axios-http.com/](https://axios-http.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to first install `axios`, then set up our Axios instance, and then
    we can layer on functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With `axios` installed, you’ll now want to create a `lib/api.js` file containing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There’s a couple of interesting things to note here; the first is the `baseURL`
    value, and the second is `withCredentials`.
  prefs: []
  type: TYPE_NORMAL
- en: The `baseURL` value is what Axios uses to build all subsequent requests on top
    of. If we called `axios.Patch('/foo')` with a `baseURL` value of [https://www.packtpub.com/](https://www.packtpub.com/),
    it would perform a `PATCH` call to [https://www.packtpub.com/foo](https://www.packtpub.com/foo).
    This is a great way to switch between development and production and ensure you
    reduce typos.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what are we doing with `import.meta.env`? This is partly how Vite imports
    and exposes environment variables. We’re going to add our `VITE_BASE_API_URL`
    to a `.env` file situated at the base of our project containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Combined with this and our new `lib/api.js` file, we can now call `axios.Put('/test')`
    from our code, and by default, it will reference http://0.0.0.0:8000/test. You
    can see more about how Vite handles environment variables and more at [https://vitejs.dev/guide/env-and-mode.xhtml](https://vitejs.dev/guide/env-and-mode.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The other part to note is the `withCredentials` property. This value indicates
    whether or not cross-site access control requests should be made using credentials
    such as cookies and authorization headers.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we want this property is that we want all our cookie settings to
    be consistent, but we’ll need to ensure our backend app understands it, which
    we’ll cover shortly. Setting `withCredentials` has no effect on same-site requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve used this to instantiate our `axios` instance, we can leverage
    this by creating our own `api/demo.js` file inside our frontend application’s
    `src` folder. It’s not a very original name but it works for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code exports two functions called `getFromServer` and `postToServer`, with
    an additional `data` parameter being sent as the `POST` body on the latter function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A neat trick here is the usage of the `@` import – this is common in a lot
    of setups to allow us to quickly specify the base path for our code to keep things
    clean and remove relative/absolute pathing with lots of `../..` referenced everywhere.
    If you forget this, you’ll see errors such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Not great! To fix this, open up your `vite.config.js` file and replace the
    contents with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I’ve bolded the key parts that we’re adding. We’re telling Vite to use the `@`
    symbol as an alias so that when we use `@` in a path, it calls `path.resolve()`
    to resolve the path segments into an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this now set up, we’re going to open up our `HelloWorld.vue` and
    update it, the goal being to create something that looks like *Figure 9**.4*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: The UI for GET and POST](img/Figure_9.04_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The UI for GET and POST'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code for `HelloWorld.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The parts in bold are the most interesting parts. These show how we can use
    `GET` and `POST` with our data, using our libraries and API calls from the backend
    server that we set up, as well as how we can bind the data and reference it in
    our Vue modules.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, after making all these changes, your Vite instance is still running;
    if not, start it with `npm run dev`, and you should get the screenshot from *Figure
    9**.4*. Click the **Click to Get** button and enter some data to send via the
    **Click to** **post**button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Peeking into the HTTP traffic](img/Figure_9.05_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Peeking into the HTTP traffic'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t work! We’re so close, but first, we have to revisit CORS from one
    of our previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: CORS for secure applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093), *Moving to API-First*, we
    introduced the CORS middleware for our backend. We’ve now got to update our new
    backend service. It will need to respond to `OPTION` preflight requests, as we
    discussed in [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093), *Moving to API-First*,
    and will also need to identify the URLs that we’re going to allow to talk to our
    service. This is necessary to ensure our browsers aren’t being tricked into submitting/modifying
    applications from other sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `backend/server.go` sample you’ve been running and review the main
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As before, I’ve put the key parts in bold. You can see we’ve appended `http.MethodOptions`
    to our `POST` handler, and we’ve also layered in some additional middleware.
  prefs: []
  type: TYPE_NORMAL
- en: '`AllowedHeaders` has been included, and we’re specifically accepting `Content-Type`
    as, by default, we won’t accept JSON – only `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain` are accepted.'
  prefs: []
  type: TYPE_NORMAL
- en: We also use `AllowCredentials` to specify that the user agent may pass authentication
    details along with the request, and finally, we’re specifying our dev server’s
    location, both for `localhost` and the `0.0.0.0` address. This might be slight
    overkill but can help if your backend and frontend start differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a production-ready version of our project, you will want to inject these
    as environment variables to avoid mixing development and production config files.
    If you leverage `env.go` from [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093),
    *Moving to API - First* – available at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/blob/main/Chapter06/internal/env.go)
    – you will do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once your server is configured correctly, (re)start both the backend and the
    frontend, and you should now be able to call your backend service to use `GET`
    and `POST`. You’ve now completed a full-stack project!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: UI displaying output from the server](img/Figure_9.06_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: UI displaying output from the server'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at adding CORS functionality to our application,
    allowing the frontend to access our API. In the next section, we will look at
    exploring Vue middleware that will help to provide common data transformation
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Vue middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Vue (and Axios) and Golang, we’ve shown we can bring all of learning
    so far all together, but we’ve missed one small aspect. We’ve deliberately omitted
    the JSON `struct` tags from our Golang code. If we add them back into our `backend/server.go`
    and rerun both the server and app, our requests no longer work!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our frontend and backend can no longer communicate as the contract has changed;
    the frontend is communicating in CamelCase, while the backend is communicating
    in snake_case.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a show-stopper, as we’ve proven we can work around it, but sometimes
    we don’t have the luxury of telling the backend service what format to use. Thankfully,
    Axios can be modified to add transformers to our requests that will modify inbound
    and outbound requests to match whichever backend formatting we’re given.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build our transformers, we’ll install and use two new packages to help us
    to create our transformers. These will be used to convert between the different
    formats/case types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll modify our `lib/api.js` file to use these libraries to format
    our payloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code might look like a lot, but it’s what we need to create our transformers.
    We create a `to` function and a `from` function to add as transformers to the
    Axios instantiation. We transform the requests into snake_case on the outbound/request
    and transform them to CamelCase on the inbound/response. If you want to dive into
    the specifics of creating transformers for Axios, you can find more on the website
    at [https://axios-http.com/docs/req_config](https://axios-http.com/docs/req_config),
    which includes a look at all the other numerous configs and parameters that can
    be provided for the Axios library.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different methods/libraries we could use to accomplish the same
    goal – for example, the `humps` package from [https://www.npmjs.com/package/humps](https://www.npmjs.com/package/humps)
    is another library we could use to expose similar functionality, but what we are
    using works well for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced Tailwind CSS and discussed its utility-first approach.
    We’ve previously seen samples of it in [*Chapter 4*](B18295_04.xhtml#_idTextAnchor053),
    *Serving and Embedding HTML Content*, where we were provided with the HTML/CSS,
    but this is our first look at using it and how we can rapidly create components
    outside of heavier frameworks, as well as how we can rapidly integrate it with
    our frontend Vue application with configuration and how we can test its successful
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we created a full-stack application, bringing our expertise
    together thus far. We’ve successfully built a frontend application in Vue that
    communicates with our backend in Golang; as part of this, we also looked at how
    to configure and use Axios and how to mitigate common CORS issues, before concluding
    with a brief look at using middleware in our Vue app to allow us to communicate
    across different JSON schemas in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look into securing our sessions, using JWTs for sessions,
    middleware, and creating and using navigation guards in Vue.
  prefs: []
  type: TYPE_NORMAL
