<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer076">
<h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor198"/>10</h1>
<h1 id="_idParaDest-129"><a id="_idTextAnchor199"/>Session Management</h1>
<p>In <a href="B18295_09.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><em class="italic">, Tailwind, Middleware, and CORS</em>, we created a full-stack app with an independent frontend and backend talking to each other via <span class="No-Break">an API.</span></p>
<p>In this chapter, we’ll bring all of our existing knowledge together, introduce how to create and validate JSON Web Tokens (JWTs) for session management and middleware, set up the basic tenets of using Vue Router with navigation guards, and learn about errors and “catch-all” <span class="No-Break">navigation guards.</span></p>
<p>We’ll cover the following topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Session management <span class="No-Break">and JWTs</span></li>
<li>(Re)introducing <span class="No-Break">Vue Router</span></li>
<li><span class="No-Break">Navigation guards</span></li>
<li>Defaults and <span class="No-Break">error pages</span></li>
</ul>
<p>By the end of this chapter, we’ll have an understanding of how to complete and secure a project ready for our <span class="No-Break">waiting users.</span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor200"/>Technical requirements</h1>
<p>All the source code explained in this chapter can be checked out <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter10"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter10</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor201"/>Session management and JWTs</h1>
<p>We<a id="_idIndexMarker349"/> looked at <a id="_idIndexMarker350"/>session management using cookies previously in <a href="B18295_06.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, Moving to API-First, using the Gorilla Mux middleware. In our app, we created an in-memory cookie store via the functionality provided by Gorilla <span class="No-Break">sessions: </span><a href="https://github.com/gorilla/sessions"><span class="No-Break">https://github.com/gorilla/sessions</span></a><span class="No-Break">.</span></p>
<p>We previously implemented our middleware to validate that our user was approved by encoding two values – a user ID we looked up from the database and a <strong class="source-inline">userAuthenticated</strong> Boolean value. This worked well for our use case, but our implementation<a id="_idIndexMarker351"/> meant that every call to our API backend <a id="_idIndexMarker352"/>required a round trip to the database to check that the user ID was still present, before letting the <span class="No-Break">call continue.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 10.1: An illustration of login and save API workflows using a session cookie" height="773" src="image/Figure_10.01_B18295.jpg" width="934"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: An illustration of login and save API workflows using a session cookie</p>
<p>This approach is fine and the Gorilla sessions library provides a number of alternative backends to speed things up, such as using Redis and SQLite, but we’re going to look at an alternative approach <span class="No-Break">using JWTs.</span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor202"/>What’s a JWT?</h2>
<p>JWT stands <a id="_idIndexMarker353"/>for JSON Web Token. A JWT is a standard for creating data <a id="_idIndexMarker354"/>with optional signatures (public or public/private) and/or encryption, with a payload consisting of JSON that asserts a number of what the JWT specification calls claims. You can generate and examine JWTs on the web at <strong class="source-inline">jwt.io</strong>, and these are broken down into three parts, consisting of the header, the payload (with the claims), and the signature. These are then base64-encoded and concatenated together using a . separator, which you can <span class="No-Break">see here.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 10.2: Color-coded illustration showing the parts of a JWT" height="161" src="image/Figure_10.02_B18295.jpg" width="503"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: Color-coded illustration showing the parts of a JWT</p>
<p>The part that is of interest to us is the payload and the claims. A number of reserved claims exist that we should respect as part of the specification, which are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">iss</strong> (<strong class="bold">issuer</strong>): The issuer of <span class="No-Break">the JWT.</span></li>
<li><strong class="bold">sub</strong> (<strong class="bold">subject</strong>): The subject of the JWT (<span class="No-Break">the user).</span></li>
<li><strong class="bold">aud</strong> (<strong class="bold">audience</strong>): The recipient for which the JWT <span class="No-Break">is intended.</span></li>
<li><strong class="bold">exp</strong> (<strong class="bold">expiration time</strong>): The time after which the <span class="No-Break">JWT expires.</span></li>
<li><strong class="bold">nbf</strong> (<strong class="bold">not before time</strong>): The time before which the JWT must not be accepted <span class="No-Break">for processing.</span></li>
<li><strong class="bold">iat</strong> (<strong class="bold">issued at time</strong>): The time at which the JWT was issued. This can be used to determine the age of <span class="No-Break">the JWT.</span></li>
<li><strong class="bold">jti</strong> (<strong class="bold">JWT ID</strong>): A unique identifier. This can be used to prevent the JWT from being replayed (allows a token to be used <span class="No-Break">only once).</span></li>
</ul>
<p>In the library, we’re going to use <strong class="source-inline">go-jwt</strong>, available at <a href="https://github.com/golang-jwt/jwt">https://github.com/golang-jwt/jwt</a>. These standard claims are provided via a Go struct, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
// Structured version of Claims Section, as referenced at
// https://tools.ietf.org/html/rfc7519#section-4.1
type StandardClaims struct {
    Audience  string `json:"aud,omitempty"`
    ExpiresAt int64  `json:"exp,omitempty"`
    Id        string `json:"jti,omitempty"`
    IssuedAt  int64  `json:"iat,omitempty"`
    Issuer    string `json:"iss,omitempty"`
    NotBefore int64  `json:"nbf,omitempty"`
    Subject   string `json:"sub,omitempty"`
}</pre>
<p>We can add to these claims to provide our own additional claims, and in typical Go style, we do so by embedding <strong class="source-inline">StandardClaims</strong> into our own struct, which I’ve called <strong class="source-inline">MyCustomClaims</strong>, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
    mySigningKey := []byte("PacktPub")
    // Your claims above and beyond the default
    type MyCustomClaims struct {
        Foo string `json:"foo"`
        jwt.StandardClaims
    }
    // Create the Claims
    claims := MyCustomClaims{
        "bar",
        // Note we embed the standard claims here
        jwt.StandardClaims{
            ExpiresAt: time.Now().Add(time.Minute *
                                      1).Unix(),
            Issuer:    "FullStackGo",
        },
    }
    // Encode to token
    token := jwt.NewWithClaims(jwt.SigningMethodHS256,
                               claims)
    tokenString, err := token.SignedString(mySigningKey)
    fmt.Printf("Your JWT as a string is %v\n", tokenString)</pre>
<p>If you execute this code, you will get the <span class="No-Break">following output:</span></p>
<pre class="console">
$ go run chapter10/jwt-example.go
Your JWT as a string is eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ey Jmb28iOiJiYXIiLCJleHAiOjE2NTY3MzY2NDIsImlzcyI6IkZ1bGxTdGFja0dv In0.o4YUzyw1BUukYg5H6CP_nz9gAmI2AylvNXG0YC5OE0M</pre>
<p>When you run the sample code or write your own, it will look slightly different because of the relative expiration in <strong class="source-inline">StandardClaims</strong>, and if you tried decoding the preceding string, chances are that it will show as expired by quite a <span class="No-Break">few seconds!</span></p>
<p>You may be asking why you should care about JWTs when you've already seen your database-based middleware working. The reason is that we can save a round trip to our database, saving us time <span class="No-Break">and bandwidth.</span></p>
<p>Because JWTs are signed, we can confidently assume that the provided claims can be asserted to be true so long as the JWT is decoded as we expect. With our JWT-based model, we can instead encode the user details and permissions into the claims on the <span class="No-Break">JWT itself.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 10.3: An illustration of login and save API workflows using a JWT secured session" height="447" src="image/Figure_10.03_B18295.jpg" width="528"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: An illustration of login and save API workflows using a JWT secured session</p>
<p>This all seems great, but there are a number of “gotchas” when working with JWTs, and it’s worth covering them before we start using them in <span class="No-Break">every situation.</span></p>
<h3>The “none algorithm” gotcha</h3>
<p>An <a id="_idIndexMarker355"/>unsecured JWT can be created where the “<strong class="source-inline">alg</strong>” header parameter value is set to “<strong class="source-inline">none</strong>” with an empty string for its <span class="No-Break">signature value.</span></p>
<p>Given that<a id="_idIndexMarker356"/> our JWTs are simply base64-encoded payloads, a malicious hacker could decode our JWT, strip off the signature, change the alg parameter to “none” and try to present it back to our API as a <span class="No-Break">valid JWT.</span></p>
<pre class="console">
$ Pipe our encoded JWT through the base64 command to decode it
$ echo eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 | base64 -D
{"alg":"HS256","typ":"JWT"}
$ echo '{"alg":"none","typ":"JWT"}' | base64
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0K</pre>
<p>It’s important that the library you’re using verifies that you’re receiving your JWTs back with the same alg you provided, and you should verify this yourself before <span class="No-Break">using it.</span></p>
<h3>The “logout” gotcha</h3>
<p>When<a id="_idIndexMarker357"/> you click to log out of your web app, the<a id="_idIndexMarker358"/> common thing to do is to set the cookie expiration to a date in the past, and then the browser will delete the cookie. You should also remove any active session information from your database and/or app.  The issue is that with JWTs, it may not work how you expect it to. Because a JWT is self-contained, it will continue to work and be considered valid until it expires – the JWT expiration, not that of the cookie – so if someone were to intercept your JWT, they could continue to access the platform until the <span class="No-Break">JWT expired.</span></p>
<h3>The “banlist” or “stale data” gotcha</h3>
<p>Similar<a id="_idIndexMarker359"/> to <a id="_idIndexMarker360"/>the logout gotcha, because our JWTs are self-contained, the data stored in them can be stale until refreshed. This can manifest as access rights/permissions becoming out of sync or, worse still, someone being<a id="_idIndexMarker361"/> able to<a id="_idIndexMarker362"/> continue to log in to your application after you’ve banned them. This is worse in scenarios where you need to be able to block a user in real time – for example, in situations of abuse or poor behavior. Instead, with the JWT model, the user will continue to have access until the <span class="No-Break">token expires.</span></p>
<h3>Using JWTs with cookies and our middleware</h3>
<p>With all <a id="_idIndexMarker363"/>of our previous gotchas understood, we’re going to write some simple middleware and cookie handling to build on <a id="_idIndexMarker364"/>our simple API service from <a href="B18295_09.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, Tailwind, Middleware, and CORS, combining it with our knowledge from <a href="B18295_05.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Securing the Backend </em><span class="No-Break"><em class="italic">and Middleware</em></span><span class="No-Break">.</span></p>
<p>This code is all provided on GitHub <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">chapter10/simple-backend</strong></span><span class="No-Break">.</span></p>
<h3>Setting cookies and validation middleware</h3>
<p>In order to<a id="_idIndexMarker365"/> start using our new JWTs, we’re going to write some middleware for the mux to consume that we will inject into all our protected routes. As before, we’re using a signature that the default library uses, where we take in <strong class="source-inline">http.Handler</strong> and return <strong class="source-inline">handlerFunc</strong>. When successful, we call <strong class="source-inline">next.ServerHTTP(http.ResponseWriter, *http.Request</strong>) to continue and indicate the successful handling of <span class="No-Break">a request:</span></p>
<pre class="source-code">
// JWTProtectedMiddleware verifies a valid JWT exists in
// our cookie and if not, encourages the consumer to login
// again.
func JWTProtectedMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter,
                                 r *http.Request) {
        // Grab jwt-token cookie
        jwtCookie, err := r.Cookie("jwt-token")
        if err != nil {
            log.Println("Error occurred reading cookie", err)
            w.WriteHeader(http.StatusUnauthorized)
            json.NewEncoder(w).Encode(struct {
                Message string `json:"message,omitempty"`
            }{
                Message: "Your session is not valid –
                          please login",
            })
            return
        }
        // Decode and validate JWT if there is one
        userEmail, err := decodeJWTToUser(jwtCookie.Value)
        if userEmail == "" || err != nil {
            log.Println("Error decoding token", err)
            w.WriteHeader(http.StatusUnauthorized)
            json.NewEncoder(w).Encode(struct {
                Message string `json:"message,omitempty"`
            }{
                Message: "Your session is not valid –
                          please login",
            })
            return
        }
        // If it's good, update the expiry time
        freshToken := createJWTTokenForUser(userEmail)
        // Set the new cookie and continue into the handler
        w.Header().Add("Content-Type", "application/json")
        http.SetCookie(w, authCookie(freshToken))
        next.ServeHTTP(w, r)
    })
}</pre>
<p>This code is <a id="_idIndexMarker366"/>checking for our cookie, named <strong class="source-inline">jwt-token</strong>, and decodes it with our new <strong class="source-inline">decodeJWTToUser</strong>, checking the value for a valid entry. In our case, we expect <strong class="source-inline">userEmail</strong>, and if it is not present, we simply return an invalid session message. In this example, we then update the expiry time for the JWT and exit the function after setting the <span class="No-Break">latest cookie.</span></p>
<p>In practice, we would check more strictly to ensure that a small window is kept for valid claims, and we’d then go back to the database to check whether the user still had permission to access <span class="No-Break">our platform.</span></p>
<p>The functionality we use for setup and manipulation of our cookies is very similar to our previous work in <a href="B18295_05.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Securing the Backend and Middleware</em> including with the domain, same-site mode, and, most importantly, HttpOnly <span class="No-Break">and Secure.</span></p>
<p>We use Secure as good practice to ensure that it’s only ever sent via secure HTTPS (except on localhost for development) as, although we can be confident our JWT is secure, it can still be decoded with tools such <span class="No-Break">as jwt.io:</span></p>
<pre class="source-code">
var jwtSigningKey []byte
var defaultCookie http.Cookie
var jwtSessionLength time.Duration
var jwtSigningMethod = jwt.SigningMethodHS256
func init() {
    jwtSigningKey = []byte(env.GetAsString(
      "JWT_SIGNING_KEY", "PacktPub"))
    defaultSecureCookie = http.Cookie{
        HttpOnly: true,
        SameSite: http.SameSiteLaxMode,
        Domain:   env.GetAsString("COOKIE_DOMAIN",
                                  "localhost"),
        Secure:   env.GetAsBool("COOKIE_SECURE", true),
    }
    jwtSessionLength = time.Duration(env.GetAsInt(
      "JWT_SESSION_LENGTH", 5))
}
...
func authCookie(token string) *http.Cookie {
    d := defaultSecureCookie
    d.Name = "jwt-token"
    d.Value = token
    d.Path = "/"
    return &amp;d
}
func expiredAuthCookie() *http.Cookie {
    d := defaultSecureCookie
    d.Name = "jwt-token"
    d.Value = ""
    d.Path = "/"
    d.MaxAge = -1
      // set our expiration to some date in the distant
      // past
    d.Expires = time.Date(1983, 7, 26, 20, 34, 58,
                          651387237, time.UTC)
    return &amp;d
}</pre>
<p>The <strong class="source-inline">HttpOnly</strong> flag is used for us in our cookie package and hasn’t been mentioned before – so, what <span class="No-Break">is it?</span></p>
<p>Well, by <a id="_idIndexMarker367"/>default, when we don’t use <strong class="source-inline">HttpOnly</strong>, our frontend Javascript can read and inspect cookie values. This is useful for setting a temporary state via the frontend and for storing a state that the frontend needs to manipulate. This is fine for a number of scenarios, and your application may have a combination of <span class="No-Break">cookie-handling techniques.</span></p>
<p>When you use <strong class="source-inline">HttpOnly</strong>, the browser prevents access to the cookie, typically returning an empty string as the result of any values read. This is useful for preventing <strong class="bold">Cross-Site Scripting</strong> (<strong class="bold">XSS</strong>), where malicious sites try to access your values, and prevents you from sending data to a <span class="No-Break">third-party/attacker’s website.</span></p>
<p>This doesn’t <a id="_idIndexMarker368"/>prevent us from logging in (which wouldn’t be very helpful!). All our API/backend requests can still be performed with all cookies, but we do need to tell our frontend application to <span class="No-Break">do so.</span></p>
<p>After providing the ability to log in with these additions to our backend, we’re now going to revisit routing so that we can move around within <span class="No-Break">our app.</span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor203"/>(Re)introducing Vue Router</h1>
<p>Before we dive in, we <a id="_idIndexMarker369"/>need to quickly refresh our understanding of how our frontend and backend communicate and ensure that we know how <span class="No-Break">things work.</span></p>
<p>You may recall from <a href="B18295_09.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Tailwind, Middleware, and CORS</em> that we set up our <strong class="source-inline">axios</strong> instance (under <strong class="source-inline">src/lib/api.js</strong>). With a few defaults, this is where the <strong class="source-inline">withCredentials</strong> value comes <span class="No-Break">into play:</span></p>
<pre class="source-code">
export default axios.create({
  baseURL: import.meta.env.VITE_BASE_API_URL,
  withCredentials: true,
  transformRequest: [...axios.defaults.transformRequest,
                     transformSnakeCase],
  transformResponse: [...axios.defaults.transformResponse,
                      transformCamelCase],
});</pre>
<p>We want to ensure that all our hard work with the Secure and <strong class="source-inline">HttpOnly</strong> cookies is preserved when the frontend and backend communicate, and <strong class="source-inline">withCredentials</strong> ensures that all requests to the backend should be made, complete with cookies, auth headers, and <span class="No-Break">so on.</span></p>
<p>We’re going to be building on this <strong class="source-inline">axios</strong> instance as we introduce the concept of navigation guards. What we’re going to do before we navigate around our application is fetch/refresh our data from the backend before rendering. This gives us the ability to check <a id="_idIndexMarker370"/>whether users should be looking at certain pages, whether they need to be logged in, or whether they shouldn’t <span class="No-Break">be snooping!</span></p>
<p>With our app now passing our cookies into every request, we can now move into utilizing permissions as we navigate our app using <span class="No-Break">navigation guards.</span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor204"/>Navigation guards</h1>
<p>Navigation guards in<a id="_idIndexMarker371"/> Vue are fundamental for logged-in users. As with any core functionality of Vue, it’s worth diving into the amazing documentation provided by the Vue team <span class="No-Break">here: </span><a href="https://router.vuejs.org/guide/advanced/navigation-guards.xhtml"><span class="No-Break">https://router.vuejs.org/guide/advanced/navigation-guards.xhtml</span></a><span class="No-Break">.</span></p>
<p>A navigation guard<a id="_idIndexMarker372"/> is, as the name suggests, a way to cancel or reroute users depending on the results of certain guard rails checks. They can be installed globally – for example, everything is behind a login/paywall – or they can be placed on <span class="No-Break">individual routes.</span></p>
<p>They are called on a navigation request, in order, and before a component is loaded. They can also be used to retrieve props to be provided to the next pages components and use the syntax of <strong class="source-inline">router.beforeEach</strong> (<span class="No-Break"><strong class="bold">to, from</strong></span><span class="No-Break">).</span></p>
<p>Previous versions also provided a <strong class="source-inline">next</strong> parameter, but this has been deprecated and shouldn’t be used in <span class="No-Break">modern code.</span></p>
<p>The functionality <a id="_idIndexMarker373"/>of a navigation guard is <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">to</strong>: Provides the target location, where the user is trying to <span class="No-Break">navigate to</span></li>
<li><strong class="source-inline">from</strong>: The current location where the user is <span class="No-Break">coming from</span></li>
</ul>
<p>The job of the guard handler is to assess whether to allow navigation <span class="No-Break">or not.</span></p>
<p>The handler can do this by returning <strong class="source-inline">false</strong>, a new route location, which is used to manipulate the browser history via a <strong class="source-inline">router.push(</strong><strong class="source-inline">)</strong> to allow additional props, or simply <strong class="source-inline">true</strong> to indicate the navigation <span class="No-Break">is allowed.</span></p>
<p>Using a simple example from the docs, we can install a global navigation guard on our routes to check the value of the <strong class="source-inline">isAuthenticated</strong> variable <span class="No-Break">before navigating:</span></p>
<pre class="source-code">
router.beforeEach(async (to, from) =&gt; {
  if (
    // make sure the user is authenticated
    !isAuthenticated &amp;&amp;
    // Avoid an infinite redirect
    to.name !== 'Login'
  ) {
    // redirect the user to the login page
    return { name: 'Login' }
  }
  // Otherwise navigation succeeds to 'from'
})</pre>
<p>Putting the <a id="_idIndexMarker374"/>logic into each route can be a bit ugly. What we will do is expose an endpoint in the backend that returns either a value or even just a 20x HTTP successful response, check for this in our middleware, and if that works, we will <span class="No-Break">allow navigation.</span></p>
<p>In the following<a id="_idIndexMarker375"/> code, we’ve got an endpoint, <strong class="source-inline">/profile</strong>, exposed on our backend. This can return data or, in this simple case, just a 200/OK response, and we can check that with our <span class="No-Break"><strong class="source-inline">getCheckLogin(</strong></span><span class="No-Break">) function.</span></p>
<p>Our <strong class="source-inline">checkAuth(</strong>) function now checks a meta value for an optional Boolean value called <strong class="source-inline">requiresAuth</strong>. If there’s no authorization required, we navigate successfully; otherwise, we try to access our endpoint. If there’s an error (non-successful) request, we redirect to our login page; otherwise, we allow the navigation <span class="No-Break">to continue:</span></p>
<pre class="source-code">
export function getCheckLogin() {
  return api.get('/profile');
}
export default function checkAuth() {
  return async function checkAuthOrRedirect(to, from) {
    if (!to?.meta?.requiresAuth) {
      // non protected route, allow it
      return;
    }
    try {
      const { data } = await getCheckLogin();
      return;
    } catch (error) {
      return { name: 'Login'};
    }
  };
}</pre>
<p>These<a id="_idIndexMarker376"/> checks can be as complicated as we want in our navigation<a id="_idIndexMarker377"/> guards, but remember that you’re calling these on every navigation. You might want to look at state management if you find yourself doing this a lot, such as Pinia (Vue 3) or Vuex (if you’re using <span class="No-Break">Vue 2).</span></p>
<p>To install these checks and values, we simply install the global handler, and for protected routes, we provide the <strong class="source-inline">meta</strong> Boolean. This is shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
...
const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
{
    path: '/login',
    Name: 'Login',
    meta: {
      requiresAuth: false,
    },
    props: true,
    component: () =&gt; import('@/views/login.vue'),
  },{
    path: '/dashboard,
    Name: 'Dashboard',
    meta: {
      requiresAuth: true,
    },
    props: true,
    component: () =&gt; import('@/views/dashboard.vue'),
  }]
});
...
router.beforeEach(checkAuth());</pre>
<p>Meta fields are a useful feature. They allow us to attach arbitrary information to our routes, in our<a id="_idIndexMarker378"/> situation we’re using the meta information as an indicator to check the authorization. You can find out more about meta <span class="No-Break">here: </span><a href="https://v3.router.vuejs.org/guide/advanced/meta.xhtml"><span class="No-Break">https://v3.router.vuejs.org/guide/advanced/meta.xhtml</span></a><span class="No-Break">.</span></p>
<p>With the ability to <a id="_idIndexMarker379"/>provide for logged-in and logged-out statuses, we now have a functioning app. One final thing to really polish our app is to provide default and error pages for our users if our app goes wrong or if they land on the wrong page <span class="No-Break">in it.</span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor205"/>Defaults and error pages</h1>
<p>With our<a id="_idIndexMarker380"/> application now securely communicating to the backend and routing correctly based on authorization, we are almost finished with our core <span class="No-Break">functional requirements.</span></p>
<p>There’s one final scenario that may arise for our users – the dreaded 404 – the page not found error! Thankfully, Vue Router makes it easy to create a wildcarded “catch-all” route that will be set to redirect users to a specific page if they navigate to somewhere that <span class="No-Break">doesn’t exist.</span></p>
<p>As you know, in Vue, all routes are defined by creating rules on the specific URL path. So, for example, creating a route for a path of <strong class="source-inline">/user</strong> would be caught if the user entered packt.com/user, but it wouldn’t if the user entered <strong class="source-inline">packt.com/my-user</strong> or any other word that is not precisely the one set in the <span class="No-Break">path rule.</span></p>
<p>To define our catch-all rule in version 4 of the Vue <strong class="source-inline">routervue</strong>-router 4, we will use the following <span class="No-Break">route entry:</span></p>
<pre class="console">
{ path: '/:pathMatch(.*)*', name: 'not-found', component: NotFound }</pre>
<p>We will inject this as the final route in our <strong class="source-inline">router.routes</strong>. The wildcard at the end of the path match means we can navigate to this page and catch the expected route. Alternatively, if that’s too much magic, you can use <strong class="source-inline">path: ‘/*’</strong> and don’t need to worry about catching the <span class="No-Break">intended route.</span></p>
<p>The best practice for a 404 page not found error would be to provide hints of what went wrong and give the user a way to get home or navigate to a similar page, but that’s a choice you can make for your <span class="No-Break"><strong class="source-inline">NotFound</strong></span><span class="No-Break"> component.</span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor206"/>Summary</h1>
<p>Excitedly, we’ve now got enough knowledge to complete the development of our full-stack app. In this chapter, we introduced JWT-based tokens, talked about when and why to use them, and covered a few “gotchas.” We then revisited cookie handling between our front and backend parts before, finally, moving on to <span class="No-Break">Vue Router.</span></p>
<p>Closing off the chapter with Vue Router, we looked at adding navigation guards, looked at how we can use meta values to enhance our development experience and mark pages for authorization, before finishing off by setting up our catch-all error-handling route so that our users have a <span class="No-Break">great experience.</span></p>
<p>In the next chapters, we’ll look at getting our app into production and getti<a id="_idTextAnchor207"/><a id="_idTextAnchor208"/><a id="_idTextAnchor209"/><a id="_idTextAnchor210"/><a id="_idTextAnchor211"/><a id="_idTextAnchor212"/><a id="_idTextAnchor213"/><a id="_idTextAnchor214"/><a id="_idTextAnchor215"/><a id="_idTextAnchor216"/><a id="_idTextAnchor217"/><a id="_idTextAnchor218"/><a id="_idTextAnchor219"/><a id="_idTextAnchor220"/><a id="_idTextAnchor221"/>ng ready for our <span class="No-Break">first users.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer077">
<h1 id="_idParaDest-137"><a id="_idTextAnchor222"/>Part 4:Release and Deployment</h1>
<p>The objective of this part of the book is to learn about the application release process and cloud deployments as part of the development process. </p>
<p>This part includes the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18295_11.xhtml#_idTextAnchor223"><em class="italic">Chapter 11</em></a>,<em class="italic"> Feature Flags</em></li>
<li><a href="B18295_12.xhtml#_idTextAnchor241"><em class="italic">Chapter 12</em></a>,<em class="italic"> Building Continuous Integration</em></li>
<li><a href="B18295_13.xhtml#_idTextAnchor261"><em class="italic">Chapter 13</em></a>,<em class="italic"> Dockerizing an Application</em></li>
<li><a href="B18295_14.xhtml#_idTextAnchor278"><em class="italic">Chapter 14</em></a>,<em class="italic"> Cloud Deployment</em></li>
</ul>
</div>
<div>
<div id="_idContainer078">
</div>
</div>
</div></body></html>