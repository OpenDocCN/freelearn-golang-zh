["```go\n// Structured version of Claims Section, as referenced at\n// https://tools.ietf.org/html/rfc7519#section-4.1\ntype StandardClaims struct {\n    Audience  string `json:\"aud,omitempty\"`\n    ExpiresAt int64  `json:\"exp,omitempty\"`\n    Id        string `json:\"jti,omitempty\"`\n    IssuedAt  int64  `json:\"iat,omitempty\"`\n    Issuer    string `json:\"iss,omitempty\"`\n    NotBefore int64  `json:\"nbf,omitempty\"`\n    Subject   string `json:\"sub,omitempty\"`\n}\n```", "```go\n    mySigningKey := []byte(\"PacktPub\")\n    // Your claims above and beyond the default\n    type MyCustomClaims struct {\n        Foo string `json:\"foo\"`\n        jwt.StandardClaims\n    }\n    // Create the Claims\n    claims := MyCustomClaims{\n        \"bar\",\n        // Note we embed the standard claims here\n        jwt.StandardClaims{\n            ExpiresAt: time.Now().Add(time.Minute *\n                                      1).Unix(),\n            Issuer:    \"FullStackGo\",\n        },\n    }\n    // Encode to token\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256,\n                               claims)\n    tokenString, err := token.SignedString(mySigningKey)\n    fmt.Printf(\"Your JWT as a string is %v\\n\", tokenString)\n```", "```go\n$ go run chapter10/jwt-example.go\nYour JWT as a string is eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ey Jmb28iOiJiYXIiLCJleHAiOjE2NTY3MzY2NDIsImlzcyI6IkZ1bGxTdGFja0dv In0.o4YUzyw1BUukYg5H6CP_nz9gAmI2AylvNXG0YC5OE0M\n```", "```go\n$ Pipe our encoded JWT through the base64 command to decode it\n$ echo eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 | base64 -D\n{\"alg\":\"HS256\",\"typ\":\"JWT\"}\n$ echo '{\"alg\":\"none\",\"typ\":\"JWT\"}' | base64\neyJhbGciOiJub25lIiwidHlwIjoiSldUIn0K\n```", "```go\n// JWTProtectedMiddleware verifies a valid JWT exists in\n// our cookie and if not, encourages the consumer to login\n// again.\nfunc JWTProtectedMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter,\n                                 r *http.Request) {\n        // Grab jwt-token cookie\n        jwtCookie, err := r.Cookie(\"jwt-token\")\n        if err != nil {\n            log.Println(\"Error occurred reading cookie\", err)\n            w.WriteHeader(http.StatusUnauthorized)\n            json.NewEncoder(w).Encode(struct {\n                Message string `json:\"message,omitempty\"`\n            }{\n                Message: \"Your session is not valid –\n                          please login\",\n            })\n            return\n        }\n        // Decode and validate JWT if there is one\n        userEmail, err := decodeJWTToUser(jwtCookie.Value)\n        if userEmail == \"\" || err != nil {\n            log.Println(\"Error decoding token\", err)\n            w.WriteHeader(http.StatusUnauthorized)\n            json.NewEncoder(w).Encode(struct {\n                Message string `json:\"message,omitempty\"`\n            }{\n                Message: \"Your session is not valid –\n                          please login\",\n            })\n            return\n        }\n        // If it's good, update the expiry time\n        freshToken := createJWTTokenForUser(userEmail)\n        // Set the new cookie and continue into the handler\n        w.Header().Add(\"Content-Type\", \"application/json\")\n        http.SetCookie(w, authCookie(freshToken))\n        next.ServeHTTP(w, r)\n    })\n}\n```", "```go\nvar jwtSigningKey []byte\nvar defaultCookie http.Cookie\nvar jwtSessionLength time.Duration\nvar jwtSigningMethod = jwt.SigningMethodHS256\nfunc init() {\n    jwtSigningKey = []byte(env.GetAsString(\n      \"JWT_SIGNING_KEY\", \"PacktPub\"))\n    defaultSecureCookie = http.Cookie{\n        HttpOnly: true,\n        SameSite: http.SameSiteLaxMode,\n        Domain:   env.GetAsString(\"COOKIE_DOMAIN\",\n                                  \"localhost\"),\n        Secure:   env.GetAsBool(\"COOKIE_SECURE\", true),\n    }\n    jwtSessionLength = time.Duration(env.GetAsInt(\n      \"JWT_SESSION_LENGTH\", 5))\n}\n...\nfunc authCookie(token string) *http.Cookie {\n    d := defaultSecureCookie\n    d.Name = \"jwt-token\"\n    d.Value = token\n    d.Path = \"/\"\n    return &d\n}\nfunc expiredAuthCookie() *http.Cookie {\n    d := defaultSecureCookie\n    d.Name = \"jwt-token\"\n    d.Value = \"\"\n    d.Path = \"/\"\n    d.MaxAge = -1\n      // set our expiration to some date in the distant\n      // past\n    d.Expires = time.Date(1983, 7, 26, 20, 34, 58,\n                          651387237, time.UTC)\n    return &d\n}\n```", "```go\nexport default axios.create({\n  baseURL: import.meta.env.VITE_BASE_API_URL,\n  withCredentials: true,\n  transformRequest: [...axios.defaults.transformRequest,\n                     transformSnakeCase],\n  transformResponse: [...axios.defaults.transformResponse,\n                      transformCamelCase],\n});\n```", "```go\nrouter.beforeEach(async (to, from) => {\n  if (\n    // make sure the user is authenticated\n    !isAuthenticated &&\n    // Avoid an infinite redirect\n    to.name !== 'Login'\n  ) {\n    // redirect the user to the login page\n    return { name: 'Login' }\n  }\n  // Otherwise navigation succeeds to 'from'\n})\n```", "```go\nexport function getCheckLogin() {\n  return api.get('/profile');\n}\nexport default function checkAuth() {\n  return async function checkAuthOrRedirect(to, from) {\n    if (!to?.meta?.requiresAuth) {\n      // non protected route, allow it\n      return;\n    }\n    try {\n      const { data } = await getCheckLogin();\n      return;\n    } catch (error) {\n      return { name: 'Login'};\n    }\n  };\n}\n```", "```go\n...\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes: [\n{\n    path: '/login',\n    Name: 'Login',\n    meta: {\n      requiresAuth: false,\n    },\n    props: true,\n    component: () => import('@/views/login.vue'),\n  },{\n    path: '/dashboard,\n    Name: 'Dashboard',\n    meta: {\n      requiresAuth: true,\n    },\n    props: true,\n    component: () => import('@/views/dashboard.vue'),\n  }]\n});\n...\nrouter.beforeEach(checkAuth());\n```", "```go\n{ path: '/:pathMatch(.*)*', name: 'not-found', component: NotFound }\n```"]