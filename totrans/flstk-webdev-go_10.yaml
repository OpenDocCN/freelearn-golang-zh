- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Session Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理
- en: In [*Chapter 9*](B18295_09.xhtml#_idTextAnchor184)*, Tailwind, Middleware, and
    CORS*, we created a full-stack app with an independent frontend and backend talking
    to each other via an API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18295_09.xhtml#_idTextAnchor184)*，Tailwind，中间件和CORS*中，我们创建了一个全栈应用程序，具有独立的前端和后端，通过API相互通信。
- en: In this chapter, we’ll bring all of our existing knowledge together, introduce
    how to create and validate JSON Web Tokens (JWTs) for session management and middleware,
    set up the basic tenets of using Vue Router with navigation guards, and learn
    about errors and “catch-all” navigation guards.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把所有现有的知识结合起来，介绍如何创建和验证用于会话管理和中间件的JSON Web Tokens (JWTs)，设置使用Vue Router的基本原则和导航守卫，以及了解错误和“捕获所有”导航守卫。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Session management and JWTs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理和JWTs
- en: (Re)introducing Vue Router
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （重新）介绍Vue Router
- en: Navigation guards
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航守卫
- en: Defaults and error pages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认页面和错误页面
- en: By the end of this chapter, we’ll have an understanding of how to complete and
    secure a project ready for our waiting users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解如何完成并确保一个为等待用户准备的项目。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter10](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter10](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter10)中查看。
- en: Session management and JWTs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理和JWTs
- en: 'We looked at session management using cookies previously in [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093),
    Moving to API-First, using the Gorilla Mux middleware. In our app, we created
    an in-memory cookie store via the functionality provided by Gorilla sessions:
    [https://github.com/gorilla/sessions](https://github.com/gorilla/sessions).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在[*第6章*](B18295_06.xhtml#_idTextAnchor093)*，转向API-First，使用Gorilla Mux中间件，查看过使用cookie进行会话管理。在我们的应用程序中，我们通过Gorilla会话提供的功能创建了一个内存中的cookie存储：[https://github.com/gorilla/sessions](https://github.com/gorilla/sessions)。
- en: We previously implemented our middleware to validate that our user was approved
    by encoding two values – a user ID we looked up from the database and a `userAuthenticated`
    Boolean value. This worked well for our use case, but our implementation meant
    that every call to our API backend required a round trip to the database to check
    that the user ID was still present, before letting the call continue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前实现了我们的中间件，以验证我们的用户是否被批准，通过编码两个值——我们从数据库中查找的用户ID和一个`userAuthenticated`布尔值。这对于我们的用例来说效果很好，但我们的实现意味着每次调用我们的API后端都需要往返数据库，以检查用户ID是否仍然存在，然后才能让调用继续。
- en: '![Figure 10.1: An illustration of login and save API workflows using a session
    cookie](img/Figure_10.01_B18295.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：使用会话cookie的登录和保存API工作流程示意图](img/Figure_10.01_B18295.jpg)'
- en: 'Figure 10.1: An illustration of login and save API workflows using a session
    cookie'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：使用会话cookie的登录和保存API工作流程示意图
- en: This approach is fine and the Gorilla sessions library provides a number of
    alternative backends to speed things up, such as using Redis and SQLite, but we’re
    going to look at an alternative approach using JWTs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是可以的，Gorilla会话库提供了一些替代后端来加速这个过程，例如使用Redis和SQLite，但我们将探讨使用JWT的替代方法。
- en: What’s a JWT?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是JWT？
- en: JWT stands for JSON Web Token. A JWT is a standard for creating data with optional
    signatures (public or public/private) and/or encryption, with a payload consisting
    of JSON that asserts a number of what the JWT specification calls claims. You
    can generate and examine JWTs on the web at `jwt.io`, and these are broken down
    into three parts, consisting of the header, the payload (with the claims), and
    the signature. These are then base64-encoded and concatenated together using a
    . separator, which you can see here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JWT代表JSON Web Token。JWT是一个创建带有可选签名（公共或公共/私有）和/或加密的数据的标准，其有效载荷由JSON组成，声明了JWT规范中称为声明的多个内容。您可以在`jwt.io`上生成和检查JWTs，它们被分解为三个部分，包括头部、有效载荷（包含声明）和签名。然后，它们使用.分隔符进行base64编码并连接在一起，您可以看到这里。
- en: '![Figure 10.2: Color-coded illustration showing the parts of a JWT](img/Figure_10.02_B18295.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：使用颜色编码的JWT各部分示意图](img/Figure_10.02_B18295.jpg)'
- en: 'Figure 10.2: Color-coded illustration showing the parts of a JWT'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：使用颜色编码的JWT各部分示意图
- en: 'The part that is of interest to us is the payload and the claims. A number
    of reserved claims exist that we should respect as part of the specification,
    which are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的部分是有效载荷和声明。存在一些保留的声明，我们应该将其视为规范的一部分，具体如下：
- en: '**iss** (**issuer**): The issuer of the JWT.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iss**（**发行者**）：JWT的发行者。'
- en: '**sub** (**subject**): The subject of the JWT (the user).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sub**（**主题**）：JWT的主题（用户）。'
- en: '**aud** (**audience**): The recipient for which the JWT is intended.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aud**（**受众**）：JWT的目标接收者。'
- en: '**exp** (**expiration time**): The time after which the JWT expires.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exp**（**过期时间**）：JWT过期后的时间。'
- en: '**nbf** (**not before time**): The time before which the JWT must not be accepted
    for processing.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nbf**（**不可用时间**）：JWT必须在此时间之前不接受处理。'
- en: '**iat** (**issued at time**): The time at which the JWT was issued. This can
    be used to determine the age of the JWT.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iat**（**发行时间**）：JWT被发行的时间。这可以用来确定JWT的年龄。'
- en: '**jti** (**JWT ID**): A unique identifier. This can be used to prevent the
    JWT from being replayed (allows a token to be used only once).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jti**（**JWT ID**）：一个唯一的标识符。这可以用来防止JWT被重放（允许令牌只使用一次）。'
- en: 'In the library, we’re going to use `go-jwt`, available at [https://github.com/golang-jwt/jwt](https://github.com/golang-jwt/jwt).
    These standard claims are provided via a Go struct, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中，我们将使用`go-jwt`，可在[https://github.com/golang-jwt/jwt](https://github.com/golang-jwt/jwt)找到。这些标准声明通过Go结构体提供，如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can add to these claims to provide our own additional claims, and in typical
    Go style, we do so by embedding `StandardClaims` into our own struct, which I’ve
    called `MyCustomClaims`, as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向这些声明中添加自己的附加声明，并且按照典型的Go风格，我们通过将`StandardClaims`嵌入到我们自己的结构体中来实现，我将其称为`MyCustomClaims`，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you execute this code, you will get the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码，你将得到以下输出：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the sample code or write your own, it will look slightly different
    because of the relative expiration in `StandardClaims`, and if you tried decoding
    the preceding string, chances are that it will show as expired by quite a few
    seconds!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行示例代码或编写自己的代码时，由于`StandardClaims`中的相对过期时间，它看起来会有所不同，如果你尝试解码前面的字符串，很可能会显示已经过期了几秒钟！
- en: You may be asking why you should care about JWTs when you've already seen your
    database-based middleware working. The reason is that we can save a round trip
    to our database, saving us time and bandwidth.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么你应该关心JWT，因为你已经看到了基于数据库的中介工作。原因是我们可以节省一次往返数据库，节省时间和带宽。
- en: Because JWTs are signed, we can confidently assume that the provided claims
    can be asserted to be true so long as the JWT is decoded as we expect. With our
    JWT-based model, we can instead encode the user details and permissions into the
    claims on the JWT itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JWT是经过签名的，我们可以自信地假设，只要JWT按照我们的预期被解码，提供的声明就可以被断言为真实。在我们的基于JWT的模型中，我们可以将用户详情和权限编码到JWT本身的声明中。
- en: '![Figure 10.3: An illustration of login and save API workflows using a JWT
    secured session](img/Figure_10.03_B18295.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：使用JWT安全会话的登录和保存API工作流程的说明](img/Figure_10.03_B18295.jpg)'
- en: 'Figure 10.3: An illustration of login and save API workflows using a JWT secured
    session'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：使用JWT安全会话的登录和保存API工作流程的说明
- en: This all seems great, but there are a number of “gotchas” when working with
    JWTs, and it’s worth covering them before we start using them in every situation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来都很不错，但在使用JWT时存在一些“陷阱”，在我们开始在每个场景中使用它们之前，值得先了解它们。
- en: The “none algorithm” gotcha
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “无算法”陷阱
- en: An unsecured JWT can be created where the “`alg`” header parameter value is
    set to “`none`” with an empty string for its signature value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个未加密的JWT，其中“`alg`”头参数值设置为“`none`”，其签名值为空字符串。
- en: Given that our JWTs are simply base64-encoded payloads, a malicious hacker could
    decode our JWT, strip off the signature, change the alg parameter to “none” and
    try to present it back to our API as a valid JWT.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的JWT仅仅是base64编码的有效载荷，恶意黑客可以解码我们的JWT，移除签名，将算法参数更改为“none”，然后尝试将其作为有效的JWT呈现给我们的API。
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s important that the library you’re using verifies that you’re receiving
    your JWTs back with the same alg you provided, and you should verify this yourself
    before using it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你使用的库要验证你收到的JWT与你提供的算法相同，并且在使用它之前你应该自己验证这一点。
- en: The “logout” gotcha
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “注销”陷阱
- en: When you click to log out of your web app, the common thing to do is to set
    the cookie expiration to a date in the past, and then the browser will delete
    the cookie. You should also remove any active session information from your database
    and/or app. The issue is that with JWTs, it may not work how you expect it to.
    Because a JWT is self-contained, it will continue to work and be considered valid
    until it expires – the JWT expiration, not that of the cookie – so if someone
    were to intercept your JWT, they could continue to access the platform until the
    JWT expired.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击退出你的web应用时，常见的做法是将cookie过期时间设置为过去的日期，然后浏览器将删除cookie。你还应该从你的数据库和/或应用中删除任何活动的会话信息。问题是，使用JWT，它可能不会按你预期的样子工作。因为JWT是自包含的，它将继续工作并被认为有效，直到它过期——是JWT的过期，而不是cookie的过期——所以如果有人拦截你的JWT，他们可以继续访问平台，直到JWT过期。
- en: The “banlist” or “stale data” gotcha
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “黑名单”或“过时数据”陷阱
- en: Similar to the logout gotcha, because our JWTs are self-contained, the data
    stored in them can be stale until refreshed. This can manifest as access rights/permissions
    becoming out of sync or, worse still, someone being able to continue to log in
    to your application after you’ve banned them. This is worse in scenarios where
    you need to be able to block a user in real time – for example, in situations
    of abuse or poor behavior. Instead, with the JWT model, the user will continue
    to have access until the token expires.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与退出时的陷阱类似，因为我们的JWT是自包含的，存储在其中的数据可以直到刷新时仍然过时。这可能导致访问权限/权限不同步，或者更糟糕的是，在你禁止他们之后，有人仍然能够继续登录你的应用。这在需要实时阻止用户的情况下更糟——例如，在滥用或不良行为的情况下。相反，使用JWT模型，用户将继续有权访问，直到令牌过期。
- en: Using JWTs with cookies and our middleware
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JWT和cookie以及我们的中间件
- en: With all of our previous gotchas understood, we’re going to write some simple
    middleware and cookie handling to build on our simple API service from [*Chapter
    9*](B18295_09.xhtml#_idTextAnchor184), Tailwind, Middleware, and CORS, combining
    it with our knowledge from [*Chapter 5*](B18295_05.xhtml#_idTextAnchor070)*, Securing
    the Backend* *and Middleware*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了我们所有的陷阱之后，我们将编写一些简单的中间件和cookie处理，以构建来自[*第9章*](B18295_09.xhtml#_idTextAnchor184)，Tailwind，中间件和CORS的简单API服务，结合我们在[*第5章*](B18295_05.xhtml#_idTextAnchor070)*，保护后端和中间件*中的知识。
- en: This code is all provided on GitHub under `chapter10/simple-backend`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码全部在GitHub上的`chapter10/simple-backend`提供。
- en: Setting cookies and validation middleware
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置cookie和验证中间件
- en: 'In order to start using our new JWTs, we’re going to write some middleware
    for the mux to consume that we will inject into all our protected routes. As before,
    we’re using a signature that the default library uses, where we take in `http.Handler`
    and return `handlerFunc`. When successful, we call `next.ServerHTTP(http.ResponseWriter,
    *http.Request`) to continue and indicate the successful handling of a request:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用我们新的JWT，我们将为mux编写一些中间件以供消费，并将它们注入到我们所有的受保护路由中。和之前一样，我们使用默认库使用的签名，其中我们接收`http.Handler`并返回`handlerFunc`。当成功时，我们调用`next.ServerHTTP(http.ResponseWriter,
    *http.Request`)以继续并指示请求处理成功：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is checking for our cookie, named `jwt-token`, and decodes it with
    our new `decodeJWTToUser`, checking the value for a valid entry. In our case,
    we expect `userEmail`, and if it is not present, we simply return an invalid session
    message. In this example, we then update the expiry time for the JWT and exit
    the function after setting the latest cookie.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在检查我们的名为`jwt-token`的cookie，并使用我们新的`decodeJWTToUser`对其进行解码，检查其值是否为有效的条目。在我们的情况下，我们期望`userEmail`，如果它不存在，我们简单地返回一个无效会话消息。在这个例子中，然后我们更新JWT的过期时间，并在设置最新的cookie后退出函数。
- en: In practice, we would check more strictly to ensure that a small window is kept
    for valid claims, and we’d then go back to the database to check whether the user
    still had permission to access our platform.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们会更加严格地检查，以确保保留一个小的有效声明窗口，然后我们会回数据库检查用户是否仍然有权访问我们的平台。
- en: The functionality we use for setup and manipulation of our cookies is very similar
    to our previous work in [*Chapter 5*](B18295_05.xhtml#_idTextAnchor070)*, Securing
    the Backend and Middleware* including with the domain, same-site mode, and, most
    importantly, HttpOnly and Secure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于设置和操作cookie的功能与我们之前在[*第5章*](B18295_05.xhtml#_idTextAnchor070)*，保护后端和中间件*中的工作非常相似，包括域名、same-site模式，以及最重要的是HttpOnly和Secure。
- en: 'We use Secure as good practice to ensure that it’s only ever sent via secure
    HTTPS (except on localhost for development) as, although we can be confident our
    JWT is secure, it can still be decoded with tools such as jwt.io:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Secure作为良好实践来确保它始终通过安全的HTTPS发送（除了在本地主机上进行开发时），因为尽管我们可以对我们的JWT的安全性有信心，但它仍然可以用诸如jwt.io之类的工具进行解码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `HttpOnly` flag is used for us in our cookie package and hasn’t been mentioned
    before – so, what is it?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpOnly`标志在我们的cookie包中为我们使用，之前还没有提到——那么，它是什么？'
- en: Well, by default, when we don’t use `HttpOnly`, our frontend Javascript can
    read and inspect cookie values. This is useful for setting a temporary state via
    the frontend and for storing a state that the frontend needs to manipulate. This
    is fine for a number of scenarios, and your application may have a combination
    of cookie-handling techniques.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，默认情况下，当我们不使用`HttpOnly`时，我们的前端JavaScript可以读取和检查cookie值。这对于通过前端设置临时状态和存储前端需要操作的状态很有用。这在许多场景下都是可行的，你的应用程序可能结合了多种cookie处理技术。
- en: When you use `HttpOnly`, the browser prevents access to the cookie, typically
    returning an empty string as the result of any values read. This is useful for
    preventing **Cross-Site Scripting** (**XSS**), where malicious sites try to access
    your values, and prevents you from sending data to a third-party/attacker’s website.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`HttpOnly`时，浏览器会阻止对cookie的访问，通常将任何读取值的返回结果作为空字符串。这对于防止**跨站脚本攻击**（**XSS**）很有用，恶意网站试图访问你的值，并阻止你向第三方/攻击者的网站发送数据。
- en: This doesn’t prevent us from logging in (which wouldn’t be very helpful!). All
    our API/backend requests can still be performed with all cookies, but we do need
    to tell our frontend application to do so.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不会阻止我们登录（这不会很有帮助！）。我们仍然可以使用所有cookie执行所有API/后端请求，但我们需要告诉我们的前端应用程序这样做。
- en: After providing the ability to log in with these additions to our backend, we’re
    now going to revisit routing so that we can move around within our app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的后端添加了登录功能之后，我们现在将重新审视路由，以便我们可以在我们的应用程序中移动。
- en: (Re)introducing Vue Router
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （重新）介绍Vue Router
- en: Before we dive in, we need to quickly refresh our understanding of how our frontend
    and backend communicate and ensure that we know how things work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，我们需要快速回顾一下我们的前端和后端是如何通信的，并确保我们知道事情是如何工作的。
- en: 'You may recall from [*Chapter 9*](B18295_09.xhtml#_idTextAnchor184), *Tailwind,
    Middleware, and CORS* that we set up our `axios` instance (under `src/lib/api.js`).
    With a few defaults, this is where the `withCredentials` value comes into play:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从[*第9章*](B18295_09.xhtml#_idTextAnchor184)，*Tailwind, Middleware, and
    CORS*，我们设置了我们的`axios`实例（在`src/lib/api.js`下）。通过一些默认设置，这就是`withCredentials`值发挥作用的地方：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We want to ensure that all our hard work with the Secure and `HttpOnly` cookies
    is preserved when the frontend and backend communicate, and `withCredentials`
    ensures that all requests to the backend should be made, complete with cookies,
    auth headers, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保在前后端通信时，我们所有的Secure和`HttpOnly`cookie的工作都得到了保留，`withCredentials`确保所有对后端的请求都应该带有cookie、认证头等信息。
- en: We’re going to be building on this `axios` instance as we introduce the concept
    of navigation guards. What we’re going to do before we navigate around our application
    is fetch/refresh our data from the backend before rendering. This gives us the
    ability to check whether users should be looking at certain pages, whether they
    need to be logged in, or whether they shouldn’t be snooping!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在介绍导航守卫概念时构建这个`axios`实例。在我们导航应用程序之前，我们将从后端获取/刷新我们的数据，以便在渲染之前。这使我们能够检查用户是否应该查看某些页面，他们是否需要登录，或者他们是否不应该窥探！
- en: With our app now passing our cookies into every request, we can now move into
    utilizing permissions as we navigate our app using navigation guards.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序现在将我们的cookie传递到每个请求中，我们可以现在利用权限，在导航应用程序时使用导航守卫。
- en: Navigation guards
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航守卫
- en: 'Navigation guards in Vue are fundamental for logged-in users. As with any core
    functionality of Vue, it’s worth diving into the amazing documentation provided
    by the Vue team here: [https://router.vuejs.org/guide/advanced/navigation-guards.xhtml](https://router.vuejs.org/guide/advanced/navigation-guards.xhtml).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Vue中的导航守卫对于已登录用户来说是基本的。与Vue的任何核心功能一样，深入研究Vue团队提供的出色文档是值得的：[https://router.vuejs.org/guide/advanced/navigation-guards.xhtml](https://router.vuejs.org/guide/advanced/navigation-guards.xhtml)。
- en: A navigation guard is, as the name suggests, a way to cancel or reroute users
    depending on the results of certain guard rails checks. They can be installed
    globally – for example, everything is behind a login/paywall – or they can be
    placed on individual routes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，导航守卫是一种根据某些守卫检查结果取消或重新路由用户的方式。它们可以被全局安装——例如，所有内容都在登录/付费墙后面——或者它们可以被放置在单个路由上。
- en: They are called on a navigation request, in order, and before a component is
    loaded. They can also be used to retrieve props to be provided to the next pages
    components and use the syntax of `router.beforeEach` (**to, from**).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在导航请求中按顺序被调用，在组件加载之前。它们也可以用来检索要提供给下一页组件的属性，并使用`router.beforeEach`（**to, from**）的语法。
- en: Previous versions also provided a `next` parameter, but this has been deprecated
    and shouldn’t be used in modern code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的版本也提供了一个`next`参数，但这个参数已经被弃用，不应该在现代代码中使用。
- en: 'The functionality of a navigation guard is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 导航守卫的功能如下：
- en: '`to`: Provides the target location, where the user is trying to navigate to'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 提供目标位置，即用户试图导航到的位置'
- en: '`from`: The current location where the user is coming from'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 用户当前所在的位置'
- en: The job of the guard handler is to assess whether to allow navigation or not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫处理器的任务是评估是否允许导航。
- en: The handler can do this by returning `false`, a new route location, which is
    used to manipulate the browser history via a `router.push(``)` to allow additional
    props, or simply `true` to indicate the navigation is allowed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器可以通过返回`false`，一个新的路由位置，用于通过`router.push()`操作浏览器历史记录以允许额外的属性，或者简单地返回`true`来表示导航是被允许的。
- en: 'Using a simple example from the docs, we can install a global navigation guard
    on our routes to check the value of the `isAuthenticated` variable before navigating:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文档中的简单示例，我们可以在我们的路由上安装一个全局导航守卫，以便在导航之前检查`isAuthenticated`变量的值：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Putting the logic into each route can be a bit ugly. What we will do is expose
    an endpoint in the backend that returns either a value or even just a 20x HTTP
    successful response, check for this in our middleware, and if that works, we will
    allow navigation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑放入每个路由可能会有些丑陋。我们将做的是在后端公开一个端点，该端点返回一个值，甚至只是一个20x HTTP成功响应，在我们的中间件中检查这一点，如果一切顺利，我们将允许导航。
- en: In the following code, we’ve got an endpoint, `/profile`, exposed on our backend.
    This can return data or, in this simple case, just a 200/OK response, and we can
    check that with our `getCheckLogin(`) function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们在后端公开了一个`/profile`端点。这个端点可以返回数据，或者在这个简单的例子中，只返回200/OK响应，我们可以用我们的`getCheckLogin()`函数来检查这一点。
- en: 'Our `checkAuth(`) function now checks a meta value for an optional Boolean
    value called `requiresAuth`. If there’s no authorization required, we navigate
    successfully; otherwise, we try to access our endpoint. If there’s an error (non-successful)
    request, we redirect to our login page; otherwise, we allow the navigation to
    continue:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`checkAuth()`函数现在检查一个名为`requiresAuth`的可选布尔值元值。如果没有授权要求，我们就可以成功导航；否则，我们尝试访问我们的端点。如果请求出错（非成功），我们将重定向到我们的登录页面；否则，我们允许导航继续：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These checks can be as complicated as we want in our navigation guards, but
    remember that you’re calling these on every navigation. You might want to look
    at state management if you find yourself doing this a lot, such as Pinia (Vue
    3) or Vuex (if you’re using Vue 2).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查可以在我们的导航守卫中变得非常复杂，但请记住，你会在每次导航时调用这些检查。如果你发现自己经常这样做，你可能需要考虑状态管理，比如Pinia（Vue
    3）或Vuex（如果你使用Vue 2）。
- en: 'To install these checks and values, we simply install the global handler, and
    for protected routes, we provide the `meta` Boolean. This is shown in the following
    code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些检查和值，我们只需安装全局处理器，对于受保护的路线，我们提供`meta`布尔值。这在上面的代码片段中显示：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Meta fields are a useful feature. They allow us to attach arbitrary information
    to our routes, in our situation we’re using the meta information as an indicator
    to check the authorization. You can find out more about meta here: [https://v3.router.vuejs.org/guide/advanced/meta.xhtml](https://v3.router.vuejs.org/guide/advanced/meta.xhtml).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 元字段是一个有用的功能。它们允许我们将任意信息附加到我们的路由上，在我们的情况下，我们使用元信息作为检查授权的指示器。您可以在[这里](https://v3.router.vuejs.org/guide/advanced/meta.xhtml)了解更多关于元的信息。
- en: With the ability to provide for logged-in and logged-out statuses, we now have
    a functioning app. One final thing to really polish our app is to provide default
    and error pages for our users if our app goes wrong or if they land on the wrong
    page in it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供登录和注销状态的能力，我们现在有一个功能齐全的应用程序。为了真正完善我们的应用程序，我们需要为用户提供默认页面和错误页面，以防我们的应用程序出错或他们在其中误入歧途。
- en: Defaults and error pages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认页面和错误页面
- en: With our application now securely communicating to the backend and routing correctly
    based on authorization, we are almost finished with our core functional requirements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的现在与后端安全通信，并根据授权正确路由，我们几乎完成了核心功能需求。
- en: There’s one final scenario that may arise for our users – the dreaded 404 –
    the page not found error! Thankfully, Vue Router makes it easy to create a wildcarded
    “catch-all” route that will be set to redirect users to a specific page if they
    navigate to somewhere that doesn’t exist.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用户来说，可能还会出现一个最终的场景——可怕的404——页面未找到错误！幸运的是，Vue Router使得创建一个通配符的“通配符”路由变得容易，如果用户导航到一个不存在的页面，它将重定向用户到特定的页面。
- en: As you know, in Vue, all routes are defined by creating rules on the specific
    URL path. So, for example, creating a route for a path of `/user` would be caught
    if the user entered packt.com/user, but it wouldn’t if the user entered `packt.com/my-user`
    or any other word that is not precisely the one set in the path rule.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在Vue中，所有路由都是通过在特定的URL路径上创建规则来定义的。例如，为`/user`路径创建一个路由，如果用户输入packt.com/user，就会被捕获，但如果用户输入`packt.com/my-user`或任何其他与路径规则设置不精确的词，则不会被捕获。
- en: 'To define our catch-all rule in version 4 of the Vue `routervue`-router 4,
    we will use the following route entry:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue `routervue`-router 4的版本4中定义我们的通配符规则，我们将使用以下路由条目：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will inject this as the final route in our `router.routes`. The wildcard
    at the end of the path match means we can navigate to this page and catch the
    expected route. Alternatively, if that’s too much magic, you can use `path: ‘/*’`
    and don’t need to worry about catching the intended route.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将把这个作为最后的路由注入到我们的`router.routes`中。路径末尾的通配符匹配意味着我们可以导航到这个页面并捕获预期的路由。或者，如果你觉得这太神奇了，你可以使用`path:
    ‘/*’`并且不需要担心捕获预期的路由。'
- en: The best practice for a 404 page not found error would be to provide hints of
    what went wrong and give the user a way to get home or navigate to a similar page,
    but that’s a choice you can make for your `NotFound` component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于404页面未找到错误的最佳实践是提供错误提示，并给用户一个返回主页或导航到类似页面的方法，但这是你可以为你的`NotFound`组件做出的选择。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Excitedly, we’ve now got enough knowledge to complete the development of our
    full-stack app. In this chapter, we introduced JWT-based tokens, talked about
    when and why to use them, and covered a few “gotchas.” We then revisited cookie
    handling between our front and backend parts before, finally, moving on to Vue
    Router.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 激动人心的，我们现在已经拥有了足够的知识来完成全栈应用程序的开发。在本章中，我们介绍了基于JWT的令牌，讨论了何时以及为什么要使用它们，并涵盖了一些“陷阱”。然后我们回顾了前后端之间的cookie处理，最后转向Vue
    Router。
- en: Closing off the chapter with Vue Router, we looked at adding navigation guards,
    looked at how we can use meta values to enhance our development experience and
    mark pages for authorization, before finishing off by setting up our catch-all
    error-handling route so that our users have a great experience.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们使用Vue Router，探讨了添加导航守卫，讨论了如何使用元值来增强我们的开发体验并标记页面以进行授权，最后通过设置我们的通配符错误处理路由来完成，以确保我们的用户有良好的体验。
- en: In the next chapters, we’ll look at getting our app into production and getting
    ready for our first users.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将我们的应用程序投入生产并为我们的第一批用户做好准备。
- en: Part 4:Release and Deployment
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：发布和部署
- en: The objective of this part of the book is to learn about the application release
    process and cloud deployments as part of the development process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本部分的目的是了解应用程序发布过程和作为开发过程一部分的云部署。
- en: 'This part includes the following chapters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 11*](B18295_11.xhtml#_idTextAnchor223), *Feature Flags*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18295_11.xhtml#_idTextAnchor223)，*功能标志*'
- en: '[*Chapter 12*](B18295_12.xhtml#_idTextAnchor241), *Building Continuous Integration*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18295_12.xhtml#_idTextAnchor241)，*构建持续集成*'
- en: '[*Chapter 13*](B18295_13.xhtml#_idTextAnchor261), *Dockerizing an Application*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18295_13.xhtml#_idTextAnchor261)，*Docker化应用程序*'
- en: '[*Chapter 14*](B18295_14.xhtml#_idTextAnchor278), *Cloud Deployment*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18295_14.xhtml#_idTextAnchor278)，*云部署*'
