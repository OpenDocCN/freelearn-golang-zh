<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer086">
<h1 class="chapter-number" id="_idParaDest-138"><a id="_idTextAnchor223"/>11</h1>
<h1 id="_idParaDest-139"><a id="_idTextAnchor224"/>Feature Flags</h1>
<p>In this chapter, we will learn about feature flags, what they are, how to use them, and the benefits of using them. Using feature flags is not mandatory for applications. However, as application complexity increases, the need for feature flags <span class="No-Break">will arise.</span></p>
<p>There are many different features provided by feature flags, but in this chapter, we will focus on how to use feature flags to enable/disable certain features in an application. We will be using an open source, simple version of the feature flag server to demonstrate the integration for both frontend and <span class="No-Break">backend services.</span></p>
<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding what feature flags are <span class="No-Break">all about</span></li>
<li>Installing an open source feature <span class="No-Break">flag server</span></li>
<li>Enabling/disabling features using <span class="No-Break">feature flags</span></li>
<li>Integrating feature flags for frontend and <span class="No-Break">backend services</span></li>
</ul>
<h1 id="_idParaDest-140"><a id="_idTextAnchor225"/>Technical requirements</h1>
<p>All the source code explained in this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter11"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter11</span></a><span class="No-Break">.</span></p>
<p>This chapter uses the cURL tool to perform HTTP operations. The tool is available for different operating systems and can be downloaded <span class="No-Break">from </span><a href="https://curl.se/download.xhtml"><span class="No-Break">https://curl.se/download.xhtml</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor226"/>An introduction to feature flags</h1>
<p>In the current rapidly changing world, developers need to make changes and roll out new features almost every single day, if not quicker. Sometimes, this requires features to be built even before there are any user needs. Having the ability to deploy features into production without disruption is the holy grail of <span class="No-Break">software development.</span></p>
<p>Features that are deployed to production may or may not be made available to users; this all depends on tactical decisions on the business side. Developers will keep on releasing features to production and, when the time is right, the feature will be made available with a click of a button from the business side. This kind of facility is provided by the <span class="No-Break">feature flag.</span></p>
<p>In simple terms, feature flags<a id="_idIndexMarker381"/> are like on/off switches that we can use to enable/disable features in our applications without creating disruption. Enabling features will also allow companies to strategically enable or disable features depending on the market and users’ needs, which can impact the bottom line of <span class="No-Break">a company.</span></p>
<p>As a tool, feature flags not only provide the ability to run on/off features but there are also many other benefits<a id="_idIndexMarker382"/> you can also get out <span class="No-Break">of it:</span></p>
<ul>
<li>Testing features for certain demographics based on certain conditions such as geographical location, user’s age, and <span class="No-Break">so on</span></li>
<li>Splitting of the traffic request based on <span class="No-Break">network condition</span></li>
<li>Conducting UX experiments <a id="_idIndexMarker383"/>to understand which design <span class="No-Break">works well</span></li>
</ul>
<p>In this chapter, we will look at an open source project feature flag tool to demonstrate how to use and <span class="No-Break">integrate i<a id="_idTextAnchor227"/>t.</span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor228"/>Feature flag configuration</h1>
<p>You can use feature flags by <a id="_idIndexMarker384"/>deploying them in your infrastructure or by using software-as-a-service solutions such as LaunchDarkly, Flagsmith, and many other available solutions. Each of the solutions provides its own API, which needs to be integrated into your application. This means that your application is tied to the solution that you choose. There is no one-size-fits-all solution; it all depends on what kind of features you need for <span class="No-Break">your application.</span></p>
<p>Let’s take a look at different kinds of configuration for using feature flags. <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em> shows the simplest way to use <span class="No-Break">feature flags.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 11.1: A web client using feature flags" height="104" src="image/Figure_11.01_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: A web client using feature flags</p>
<p>The web client will enable or disable the user interface depending on the feature flag. For example, in an application, a particular menu selection can be enabled when the feature flag related to the menu is <span class="No-Break">turned on.</span></p>
<p><span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.2</em> shows a different<a id="_idIndexMarker385"/> configuration where the web client will call different microservices, depending on which feature flag is <span class="No-Break">turned on/off:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 11.2: Feature flag microservices" height="244" src="image/Figure_11.02_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Feature flag microservices</p>
<p>In the preceding example, the web client calls microservice A when feature flag A is <span class="No-Break">turned on.</span></p>
<p>Another interesting configuration is shown in <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.3</em>, where the main microservice will determine which user interface will be returned back to the web client, depending on which feature flag has <span class="No-Break">been configured:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 11.3: The feature flags for microservices" height="179" src="image/Figure_11.03_B18295_to_be_Redrawn.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: The feature flags for microservices</p>
<p>In the above example, the web client will get a different response to render if the main microservice detects that feature flag C has been enabled, which will get the response from <span class="No-Break">MicroService C.</span></p>
<p>So, as we can see, there <a id="_idIndexMarker386"/>are different ways to use feature flags and different places to use them. It all comes down to what will be needed for <span class="No-Break">your application.</span></p>
<p>In the next section, we will look at using an open source feature flag server to enable/disable buttons in a sample <span class="No-Break">web ap<a id="_idTextAnchor229"/>p.</span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor230"/>Use cases for using feature flags</h1>
<p>Feature flags are not limited to flags that can be configured to turn on/off features inside applications; there are many more features and capabilities. In this section, we will look at the features provided in a full-blown feature <span class="No-Break">flag server:</span></p>
<ul>
<li><strong class="bold">Segment targeting</strong> – Imagine <a id="_idIndexMarker387"/>you are building a feature that you want to test on a group of users in your application. For example, you may want a certain group of users that are based in the USA to use the checkout feature based <span class="No-Break">on PayPal.</span></li>
<li><strong class="bold">Risk mitigation</strong> – Building <a id="_idIndexMarker388"/>product features does not guarantee that a feature will bring in more users. New features can be released and, with time and more analysis, if it is found that the feature is providing a bad user experience, it will be turned off as part of the risk <span class="No-Break">mitigation process.</span></li>
<li><strong class="bold">Gathering feedback before launch</strong> – Using a targeted rollout for a certain group of users, it is possible to get feedback as early as possible from the user. The feedback<a id="_idIndexMarker389"/> will provide insight for the team to decide whether the feature indeed provides any additional benefit to the user <span class="No-Break">or not.</span></li>
</ul>
<p>Now we have a good understanding of the use cases for feature flag, we will look at installing the feature flag server in the <span class="No-Break">next se<a id="_idTextAnchor231"/>ction.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor232"/>Installing the feature flag server</h2>
<p>We are going to use an <a id="_idIndexMarker390"/>open source feature flag server. Clone the project from the <a href="http://github.com/nanikjava/feature-flags">github.com/nanikjava/feature-flags</a> repository <span class="No-Break">as follows:</span></p>
<pre class="console">
git clone https://github.com/nanikjava/feature-flags</pre>
<p>From your terminal, change the directory into the project directory and build the server using the <span class="No-Break">following command:</span></p>
<pre class="console">
go build -o fflag .</pre>
<p>We are using the <strong class="source-inline">-o</strong> flag to compile the application and output it to a filename called <strong class="source-inline">fflag</strong>. Now that the server has been compiled and is ready to use, open a separate terminal window and run the server <span class="No-Break">as follows:</span></p>
<pre class="console">
./fflag</pre>
<p>You will see the <span class="No-Break">following output:</span></p>
<pre class="console">
2022/07/30 15:10:38 Feature flag is up listening on  :8080</pre>
<p>The server is now listening on port <strong class="source-inline">8080</strong>. Now, we need to add a new feature flag for our web app, and the key is called <strong class="source-inline">disable_get</strong>. The way to do this is to use the <strong class="source-inline">curl</strong> command line to send data using <strong class="source-inline">POST</strong> <span class="No-Break">as follows:</span></p>
<pre class="console">
curl -v -X POST http://localhost:8080/features -H "Content-Type:application/json" -d '{"key":"disable_get","enabled":false,"users":[],"groups":["dev","admin"],"percentage":0}' </pre>
<p>The <strong class="source-inline">curl</strong> <a id="_idIndexMarker391"/>command is calling the <strong class="source-inline">/features</strong> endpoint and passing the JSON data. Once this has completed successfully, you will see the <span class="No-Break">following output:</span></p>
<pre class="console">
{
  "key": "disable_get",
  "enabled": false,
  "users": [],
  "groups": [
    "dev",
    "admin"
  ],
  "percentage": 0
} </pre>
<p>The JSON output shows that the feature flag server now has a new key called <strong class="source-inline">disable_get</strong>, and it is disabled, as indicated by the flag <strong class="source-inline">enabled: false</strong>. The output should look as follows, showing that the data has been <span class="No-Break">successfully added:</span></p>
<pre class="console">
*   Trying 127.0.0.1:8080...
* Connected to localhost (127.0.0.1) port 8080 (#0)
…
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 201 Created
…
&lt; Content-Length: 89
&lt;
{"key":"disable_get","enabled":false,"users":[],"groups":["dev","admin"],"percentage":0}
* Connection #0 to host localhost left intact</pre>
<p>The feature<a id="_idIndexMarker392"/> flag server is ready with the data we need. In the next section, we will look at using the flag inside our <span class="No-Break">web app.</span><a id="_idTextAnchor233"/></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor234"/>The high-level architecture of feature flags</h1>
<p><span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.4</em> shows the architecture <a id="_idIndexMarker393"/>of the open source feature flag server at a <span class="No-Break">high level.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 11.4: The high-level architecture" height="267" src="image/Figure_11.04_to_be_redrawn_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: The high-level architecture</p>
<p>Looking at the diagram, the server uses mux.Router to route for different HTTP requests such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">PATCH</strong>. The server uses an internal database as persistent storage for the feature flags that the <span class="No-Break">application requires.</span></p>
<p>The server is accessible via<a id="_idIndexMarker394"/> HTTP request calls that can be made from both web clients and microservices using the normal <span class="No-Break">HTTP protocol<a id="_idTextAnchor235"/>.</span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor236"/>Integration of the feature flag</h1>
<p>After we have installed the<a id="_idIndexMarker395"/> feature flag server, we want to start using it in our application. In this section, we will look at integrating the feature flag to enable/disable certain user interface elements in the frontend and to call only the backend services from our server that <span class="No-Break">are enable<a id="_idTextAnchor237"/>d.</span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor238"/>Web application</h2>
<p>The sample app we are going to use<a id="_idIndexMarker396"/> can be found inside the <strong class="source-inline">chapter11/frontend-enable-disable</strong> folder; the sample app demonstrates how to use the feature flag to enable/disable the user interface button. Open the terminal and change into the <strong class="source-inline">chapter11/frontend-enable-disable</strong> directory to run the web app <span class="No-Break">as follows:</span></p>
<pre class="console">
npm install
npm run dev</pre>
<p>The commands will install all the necessary packages and then run the web app. Once the command completes, open your browser and type <strong class="source-inline">http://localhost:3000</strong> in the address bar. You will see the web app shown in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="Figure 11.5: The initial view of the web app using the feature flag" height="114" src="image/Figure_11.05_B18295.jpg" width="526"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: The initial view of the web app using the feature flag</p>
<p>What you are<a id="_idIndexMarker397"/> seeing in <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.5</em> is that one of the buttons has been disabled. This is based on the flag value that we set in the previous section. The flag data looks <span class="No-Break">as follows:</span></p>
<pre class="source-code">
{
  "key": "disable_get",
  "enabled": false,
  "users": [],
  "groups": [
    "dev",
    "admin"
  ],
  "percentage": 0
}</pre>
<p>The <strong class="source-inline">disable_get</strong> key is the flag key we added to the server and the <strong class="source-inline">enabled</strong> field is set to <strong class="source-inline">false</strong>, which means that the button is disabled. Let’s change the <strong class="source-inline">enabled</strong> field to <strong class="source-inline">true</strong> and let’s see how the web <span class="No-Break">page changes.</span></p>
<p>Use the following command in a terminal to update <span class="No-Break">the data:</span></p>
<pre class="console">
curl -v -X PATCH http://localhost:8080/features/disable_get -H "Content-Type: application/json" -d '{"key":"disable_get","enabled":true}'</pre>
<p>The <strong class="source-inline">curl</strong> command <a id="_idIndexMarker398"/>updates the <strong class="source-inline">enabled</strong> field to <strong class="source-inline">true</strong>. Refresh the browser page and you will see the button is enabled, as shown in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 11.6: The Click to Get button is enabled" height="120" src="image/Figure_11.06_B18295.jpg" width="556"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6: The Click to Get button is enabled</p>
<p>The following code snippet from the <strong class="source-inline">HelloWorld.vue</strong> file takes care of reading the key from the server, using it to enable/disable <span class="No-Break">the button:</span></p>
<pre class="source-code">
...
&lt;script&gt;
import axios from 'axios';
export default {
 data() {
   return {
     enabled: true
   }
 },
 mounted() {
   axios({method: "GET", "url":
     "http://localhost:8080/features/disable_get"}).then(result        =&gt; {
     this.enabled = result.data.enabled
     console.log(result);
   }, error =&gt; {
     console.error(error);
   });
 }
}
&lt;/script&gt;
&lt;template&gt;
 &lt;div  v-if="enabled" class="flex space-2 justify-center"&gt;
   ...
   &lt;/button&gt;
 &lt;/div&gt;
 ...</pre>
<p>In the next section, we will look at using the feature flag to enable/disable certain features on the <span class="No-Break">backend service.</span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor239"/>Microservice integration</h2>
<p>In this section, we will use the feature<a id="_idIndexMarker399"/> flag to enable/disable certain services. This will give the application the flexibility to access only the services that are currently enabled. <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.7</em> shows how the microservice will be structured. The application is inside the <span class="No-Break"><strong class="source-inline">chapter11/multiple-service</strong></span><span class="No-Break"> folder.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="Figure 11.7: The microservice structure for the feature flag" height="260" src="image/Figure_11.07_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7: The microservice structure for the feature flag</p>
<p>Following the steps from the previous section to run the feature flag server, use the following command to create <span class="No-Break">the flags:</span></p>
<pre class="console">
curl -v -X POST http://localhost:8080/features -H "Content-Type: application/json" -d '{"key":"serviceb", "enabled":true,"users":[],"groups":["dev","admin"],"percentage":0}'
curl -v -X POST http://localhost:8080/features -H "Content-Type: application/json" -d '{"key":"servicea", "enabled":false,"users":[],"groups":["dev","admin"],"percentage":0}' </pre>
<p>The command creates <a id="_idIndexMarker400"/>two keys: <strong class="source-inline">servicea</strong> and <strong class="source-inline">serviceb</strong>. For now, <strong class="source-inline">servicea</strong> is disabled, while <strong class="source-inline">serviceb</strong> is enabled. Once the feature flags have been set up, we are going to run <span class="No-Break">different services:</span></p>
<ul>
<li><strong class="bold">Main server</strong> – open the terminal and make sure you are inside the <strong class="source-inline">chapter11/multiple-service/mainserver</strong> directory. Run the main server with the <span class="No-Break">following command:</span><pre class="source-code">
go run main.go </pre></li>
</ul>
<p>The main server will run on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">8080</strong></span><span class="No-Break">.</span></p>
<ul>
<li><strong class="source-inline">servicea</strong> – open the terminal and change the directory to <strong class="source-inline">chapter11/multiple-service/servicea</strong>. Run the service with the <span class="No-Break">following command:</span><pre class="source-code">
go run main.go  </pre></li>
</ul>
<p><strong class="source-inline">servicea</strong> will run on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">8081</strong></span><span class="No-Break">.</span></p>
<ul>
<li><strong class="source-inline">serviceb</strong> – open the terminal and change the directory to <strong class="source-inline">chapter11/multiple-service/serviceb</strong>. Run the service with the <span class="No-Break">following command:</span><pre class="source-code">
go run main.go </pre></li>
</ul>
<p><strong class="source-inline">serviceb</strong> will run on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">8082</strong></span><span class="No-Break">.</span></p>
<p>We now have three different services running on ports <strong class="source-inline">8080</strong>, <strong class="source-inline">8081</strong>, and <strong class="source-inline">8082</strong>. Open your browser and access the service using <strong class="source-inline">http://localhost:8000</strong>. You will get a response like <span class="No-Break">the following:</span></p>
<pre class="console">
{"Message":"-ServiceB active"}</pre>
<p>The response sent back came from <strong class="source-inline">serviceb</strong> as <strong class="source-inline">servicea</strong> is disabled, as per the configuration from the feature flag server. Now, let’s turn on the flag for <strong class="source-inline">servicea</strong> using the <span class="No-Break">following command:</span></p>
<pre class="console">
curl -v -X PATCH http://localhost:8080/features/servicea -H "Content-Type: application/json" -d '{"enabled":true}'</pre>
<p>Restart the main<a id="_idIndexMarker401"/> server by force-stopping it using <em class="italic">Ctrl + C</em>. Re-run it using the same command discussed previously. Open your browser and access the service using <strong class="source-inline">http://localhost:8000</strong>. You should get a result like <span class="No-Break">the following:</span></p>
<pre class="console">
{"Message":"ServiceA active-ServiceB active"}</pre>
<p>We get responses from both services now that both have <span class="No-Break">been enabled.</span></p>
<p>Let’s take a look at the code to understand how the feature flag is used. The following snippet shows part of the code to start <span class="No-Break">the server:</span></p>
<pre class="source-code">
...
func main() {
  port := ":8000"
  ...
  wg := &amp;sync.WaitGroup{}
  wg.Add(1)
  go func(w *sync.WaitGroup) {
     defer w.Done()
     serviceA = checkFlags("servicea")
     serviceB = checkFlags("serviceb")
  }(wg)
  wg.Wait()
  http.ListenAndServe(port, rtr)
}</pre>
<p>The code calls the <a id="_idIndexMarker402"/>feature flag server to get flag information for <strong class="source-inline">servicea</strong> and <strong class="source-inline">serviceb</strong> in a goroutine. Once completed, it starts the server to listen on port <strong class="source-inline">8000</strong>. The state of the services is stored inside the <strong class="source-inline">servicea</strong> and <strong class="source-inline">serviceb</strong> variables, which will be used in other parts of the code, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
func handler() http.HandlerFunc {
  type ResponseBody struct {
     Message string
  }
  return func(rw http.ResponseWriter, req *http.Request) {
     var a, b string
     if serviceA {
        a = callService("8081")
     }
     if serviceB {
        b = callService("8082")
     }
     json.NewEncoder(rw).Encode(ResponseBody{
        Message: a + "-" + b,
     })
  }
}</pre>
<p>The <strong class="source-inline">handler()</strong> method is called when you access the server on port <strong class="source-inline">8000</strong>. Inside the code, as can be seen, it calls the service only when it is enabled. Once the service is called, the results from the service are combined and sent back to the client as a single <span class="No-Break">JSON response.</span></p>
<p>The following code<a id="_idIndexMarker403"/> snippet shows how to access the feature flag server to extract the different flags. It uses a normal HTTP <span class="No-Break">GET call:</span></p>
<pre class="source-code">
func checkFlags(key string) bool {
  ...
  requestURL := fmt.Sprintf("http://localhost:%d/features/%s",    8080, key)
  res, err := http.Get(requestURL)
  ...
  resBody, err := ioutil.ReadAll(res.Body)
  if err != nil {
     log.Printf("client: could not read response body: %s\n",       err)
     os.Exit(1)
  }
  ...
  return f.Enabled
}</pre>
<p>The code is calling<a id="_idIndexMarker404"/> the feature flag server by getting each key that we are interested in. So, in the case of the sample, we are calling using the <span class="No-Break">following URLs:</span></p>
<pre class="console">
http://localhost:8080/features/servicea
http://localhost:8080/features/serviceb</pre>
<p>For example, when calling <strong class="source-inline">http://localhost:8080/features/servicea</strong>, the code will get the following JSON response from the feature <span class="No-Break">flag server:</span></p>
<pre class="console">
{
  "key": "servicea",
  "enabled": true,
  "users": [],
  "groups": [
    "dev",
    "admin"
  ],
  "percentage": 0
} </pre>
<p>The <strong class="source-inline">checkFlags()</strong> function <a id="_idIndexMarker405"/>is interested only in the <strong class="source-inline">enabled</strong> field, which will be unmarshalled into the <strong class="source-inline">FeatureFlagServerResponse</strong> struct as <span class="No-Break">shown below:</span></p>
<pre class="source-code">
func checkFlags(key string) bool {
  type FeatureFlagServerResponse struct {
     Enabled bool `json:"enabled"`
  }
  ...
  var f FeatureFlagServerResponse
  err = json.Unmarshal(resBody, &amp;f)
  ...
}</pre>
<p>After successfully converting the JSON to a struct, it will return the <strong class="source-inline">Enabled</strong> value as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
func checkFlags(key string) bool {
  ...
  return f.Enabled
}</pre>
<p>We have come to the end of the chapter. In this section, we looked at integrating the feature flag in different scenarios such as inside web applications as well as using it as a feature toggle for accessing different microservices. There are other use cases where feature flags can be used, such as enabling/disabling performance metrics in production and enabling tracing in production for <span class="No-Break">troubleshooting bugs.</span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor240"/>Summary</h1>
<p>In this chapter, we learned about feature flags, including what they are used for and how to use them. We learned how to install a simple feature flag server and saw how to integrate it with our <span class="No-Break">sample application.</span></p>
<p>We went through the steps of using feature flags in two different use cases – integrating it by checking on the flag to enable/disable a button in our frontend and in the backend to call different microservices. Using feature flags to enable or disable certain services gives the application flexibility on what response will be sent back to the frontend, which gives developers the ability to allow access to certain services as and <span class="No-Break">when needed.</span></p>
<p>In the next chapter, we will look at building continuous integration by exploring the different features provided <span class="No-Break">by GitHub.</span></p>
</div>
</div></body></html>