<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer101">
<h1 class="chapter-number" id="_idParaDest-150"><a id="_idTextAnchor241"/>12</h1>
<h1 id="_idParaDest-151"><a id="_idTextAnchor242"/>Building Continuous Integration</h1>
<p>Building web applications to solve a problem is great, but we also need to make the applications available to users so they can start using them. As developers, we write code. But, at the same time, this code will need to be built or compiled so that it can be deployed, allowing users to use it. We need to understand how we can build our web application automatically, without requiring any manual process to work through. This is what we are going to talk about in this chapter. We will look at what is known as <strong class="bold">continuous </strong><span class="No-Break"><strong class="bold">integration</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CI</strong></span><span class="No-Break">).</span></p>
<p>CI is a practice or process for automating the integration of code from different contributors into a project. CI allows developers to frequently merge code into a code repository where it will be tested and built automatically. </p>
<p>In this chapter, we will learn about the following <span class="No-Break">for CI:</span></p>
<ul>
<li><span class="No-Break">GitHub workflows</span></li>
<li>Using <span class="No-Break">GitHub Actions</span></li>
<li>Publishing to <span class="No-Break">GitHub Packages</span></li>
</ul>
<h1 id="_idParaDest-152"><a id="_idTextAnchor243"/>Technical requirements</h1>
<p>The source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12</a>. In this chapter, we will also be using another repository when setting up CI for explanatory purposes. The repository <span class="No-Break">is </span><a href="https://GitHub.com/nanikjava/golangci"><span class="No-Break">https://GitHub.com/nanikjava/golangci</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor244"/>Importance of CI</h1>
<p>You can think of CI as <a id="_idIndexMarker406"/>one aspect of your development process. The main reason why this is important is to allow you, as developers, to ensure that all code that is committed into a central code repository is tested and validated. </p>
<p>This becomes crucial when you are working in a team environment where multiple developers are working on the same project. Having proper CI will give developers peace of mind and assurance that all code they are using can be compiled properly and that automated test cases have been run successfully. Imagine that you have to check out some projects from GitHub, but when you try to compile and run some test cases, it fails; it would be a disaster as you would have to spend time fixing things, but if the project had a proper CI process set up, it would ensure all the committed code would compile correctly and test cases <span class="No-Break">would pass.</span></p>
<p>Even when working as a solo developer on a project, it is highly recommended to have CI in place. The minimum benefit you will get from this is the assurance that your code can be built correctly. This also makes sure that any local dependencies related to your local machine that have been accidentally added to the code are detected when a build <span class="No-Break">failure occurs.</span></p>
<p>In the next section, we will look at building our CI using GitHub by going through the different steps required to have CI for our <span class="No-Break">web application.</span><a id="_idTextAnchor245"/></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor246"/>Setting up GitHub</h2>
<p>In this section, we will <a id="_idIndexMarker407"/>explain the different things that need to be prepared to get automated CI in GitHub. To gain a better understanding of the CI process, it is recommended that you create your own separate GitHub repository and copy everything inside the <strong class="source-inline">chapter12</strong> directory to the new repository. Initially, when the <strong class="source-inline">nanikjava/golangci</strong> repository is created, it will look similar to <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<img alt=" Figure 12.1: A fresh GitHub repo" height="264" src="image/Figure_12.01_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 12.1: A fresh GitHub repo</p>
<p>For this chapter, we have set up a separate repository (<a href="https://GitHub.com/nanikjava/golangci">https://GitHub.com/nanikjava/golangci</a>) that we will use as a reference guide for the discussions in this chapter. We will go through the steps of creating a simple GitHub workflow in the repository. A <a id="_idIndexMarker408"/>GitHub workflow is a set of instructions that run one or more jobs. The instructions are defined in a YAML file with the extension of <strong class="source-inline">.yaml</strong> in the <strong class="source-inline">.GitHub/workflows</strong> directory of the repository. </p>
<p>You can define multiple workflows for your repository that perform different automated processes. For example, you can have one workflow file to build and test your application and another for deploying the application to a central location. </p>
<p>Let’s create a simple workflow file inside the new repository by following the <span class="No-Break">steps below:</span></p>
<ol>
<li>From your repository, click on the <strong class="bold">Actions</strong> menu. This will bring you to the <strong class="bold">Get Started with GitHub Actions</strong> page, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer088">
<img alt="Figure 12.2: The Get started with GitHub Actions page" height="133" src="image/Figure_12.02_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: The Get started with GitHub Actions page</p>
<ol>
<li value="2">Click on the <strong class="bold">set up a workflow yourself</strong> link. This will take to you a new page where you can <a id="_idIndexMarker409"/>start writing your <a id="_idIndexMarker410"/>workflow, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer089">
<img alt="Figure 12.3: The create a new workflow screen" height="197" src="image/Figure_12.03_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: The create a new workflow screen</p>
<p>For now, we are going to create a simple workflow that we can use from GitHub. The workflow can be found at <a href="https://docs.GitHub.com/en/actions/quickstart">https://docs.GitHub.com/en/actions/quickstart</a>. Copy and paste the workflow, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="Figure 12.4: A sample GitHub workflow .yaml file" height="285" src="image/Figure_12.04_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: A sample GitHub workflow .yaml file</p>
<ol>
<li value="3">Commit the file <a id="_idIndexMarker411"/>by clicking on the <strong class="bold">Start commit</strong> button, as <a id="_idIndexMarker412"/>shown in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.5</em>. After filling in all the commit information, click on the <strong class="bold">Commit new </strong><span class="No-Break"><strong class="bold">file</strong></span><span class="No-Break"> button.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer091">
<img alt="Figure 12.5: The commit message for a .yaml file" height="195" src="image/Figure_12.05_B18295.jpg" width="625"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5: The commit message for a .yaml file</p>
<p>Your repo now has a new GitHub workflow file. If you select the <strong class="bold">Actions</strong> menu again, this time you will see that your screen looks like <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.6</em>. The screen shows that GitHub has run the <span class="No-Break">workflow successfully.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<img alt="Figure 12.6: GitHub has successfully run the workflow" height="173" src="image/Figure_12.06_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6: GitHub has successfully run the workflow</p>
<p>We can look at the <a id="_idIndexMarker413"/>workflow results by<a id="_idIndexMarker414"/> clicking on the <strong class="bold">Create main.yaml</strong> link. You will see that the output indicates that the <strong class="bold">Explore-GitHub-Actions</strong> job was successfully run, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<img alt="Figure 12.7: The Explore-GitHub-Actions step has been successfully run" height="213" src="image/Figure_12.07_B18295.jpg" width="467"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7: The Explore-GitHub-Actions step has been successfully run</p>
<p>After clicking on the <strong class="bold">Explore-GitHub-Actions</strong> jobs link, the output will be as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 12.8: The Explore-GitHub-Actions job output" height="240" src="image/Figure_12.08_B18295.jpg" width="405"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8: The Explore-GitHub-Actions job output</p>
<p>The workflow that <a id="_idIndexMarker415"/>we created in this section is actually the <a id="_idIndexMarker416"/>GitHub Actions workflow. We will look at this in more depth in the <span class="No-Break">next secti<a id="_idTextAnchor247"/>on.</span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor248"/>GitHub Actions</h1>
<p>What is GitHub Actions? It is a platform that allows you to automate the complete integration and delivery of your <a id="_idIndexMarker417"/>project by automating the build, test, and deployment processes. GitHub Actions also gives you the ability to automate workflow processes such as pull requests, issue creation, <span class="No-Break">and others.</span></p>
<p>We have now successfully created our first GitHub workflow. Let’s take a look at the workflow file to get an understanding of which GitHub Actions we are using. The workflow file we will use is <span class="No-Break">as follows:</span></p>
<pre class="console">
name: GitHub Actions Demo
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "🎉 The job was automatically triggered by a 
                   ${{ GitHub.event_name }} event."
      - run: echo "🐧 This job is now running on a ${{ runner.                   os }} 
                     server hosted by GitHub!"
      - run: echo "🔎 The name of your branch is ${{ GitHub.                   ref }} and your repository is ${{ GitHub.                   repository }}."
      - name: Check out repository code
        uses: actions/checkout@v3
      - run: echo "💡 The ${{ GitHub.repository }} repository                     has been cloned to the runner."
      - run: echo "🖥 The workflow is now ready to test your                    code on the runner."
      - name: List files in the repository
        run: |
          ls ${{ GitHub.workspace }}
      - run: echo "🍏 This job's status is ${{ job.status }}."</pre>
<p>The following table explains<a id="_idIndexMarker418"/> the different configurations in <span class="No-Break">the file:</span></p>
<table class="No-Table-Style" id="table001-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Configuration key</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Explanation</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Name</span></p>
</td>
<td class="No-Table-Style">
<p>The generic name we give to the workflow that will be used as a label for viewing the results on the <span class="No-Break">Actions page.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">On</span></p>
</td>
<td class="No-Table-Style">
<p>Indicates to GitHub what kind of Git operation will trigger the workflow. In the example, it’s <strong class="source-inline">push</strong><em class="italic">.</em> This means that the workflow will be triggered every time the Git <strong class="source-inline">push</strong> operation is detected in the repository. Different Git event operations can be seen in the GitHub <span class="No-Break">docs: </span><a href="https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows"><span class="No-Break">https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows</span></a><span class="No-Break">.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Jobs</span></p>
</td>
<td class="No-Table-Style">
<p>The workflow is made up of one or more jobs. These jobs are run in parallel by default. Jobs can be thought of as a single task that you want to do on your code. In our example, we named the job <strong class="source-inline">Explore-GitHub-Actions</strong> and it performs tasks defined by the <span class="No-Break"><em class="italic">run</em></span><span class="No-Break"> configuration.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">runs-on</span></p>
</td>
<td class="No-Table-Style">
<p>Defines the runner that we want to use. The runner is the machine that you choose to run your workflow on. In our example, we are using the <em class="italic">ubuntu-latest</em> machine, or, in other words, we want to use a machine that runs the latest version of Ubuntu. A complete list of runners can be seen in the following <span class="No-Break">link: </span><a href="https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job"><span class="No-Break">https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job</span></a><span class="No-Break">.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Steps</span></p>
</td>
<td class="No-Table-Style">
<p>Each job contains a sequence of tasks called steps. A step is where you define the operation you want to perform for the workflow. In our example, we defined several steps such as <strong class="source-inline">run</strong> where we just print <span class="No-Break">out information.</span></p>
</td>
</tr>
</tbody>
</table>
<p>Now, we are going to<a id="_idIndexMarker419"/> take a look at the GitHub Action workflow we have for the sample application. The workflow can be found inside the <strong class="source-inline">chapter12/.GitHub/workflows/build.yml</strong> file, as <span class="No-Break">shown here:</span></p>
<pre class="console">
name: Build and Package
on:
 push:
   branches:
     - main
 pull_request:
jobs:
 lint:
   name: Lint
   runs-on: ubuntu-latest
   steps:
     - name: Set up Go
       uses: actions/setup-go@v1
       with:
         go-version: 1.18
     - name: Check out code
       uses: actions/checkout@v1
     - name: Lint Go Code
       run: |
         curl -sSfL 
         https://raw.GitHubusercontent.com/golangci/golangci-           lint/
         master/install.sh | sh -s -- -b $(go env GOPATH)/bin
         $(go env GOPATH)/bin/golangci-lint run
 build:
   name: Build
   runs-on: ubuntu-latest
   needs: [ lint ]
   steps:
     - name: Set up Go
       uses: actions/setup-go@v1
       with:
         go-version: 1.18
     - name: Check out code
       uses: actions/checkout@v1
     - name: Build
       run: make build</pre>
<p>We will go now through this line<a id="_idIndexMarker420"/> by line to understand what the workflow is doing. The following snippet tells GitHub that the workflow will be triggered when source code is pushed to the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> branch:</span></p>
<pre class="console">
name: Build and Package
on:
 push:
   branches:
     - main</pre>
<p>The next snippet shows<a id="_idIndexMarker421"/> the different jobs that GitHub will run when the event is detected; in this case, the <strong class="source-inline">lint</strong> and <strong class="source-inline">build</strong> jobs. The job will be run on an Ubuntu machine, as specified by the <span class="No-Break"><strong class="source-inline">runs-on</strong></span><span class="No-Break"> configuration:</span></p>
<pre class="console">
jobs:
 lint:
   name: Lint
   runs-on: ubuntu-latest
   steps:
     ...
 build:
   name: Build
   runs-on: ubuntu-latest
   needs: [ lint ]
   steps:
     ...</pre>
<p>The defined jobs are made up of the steps shown in the <span class="No-Break">following snippet:</span></p>
<pre class="console">
...
jobs:
 lint:
   ...
   steps:
     - name: Set up Go
       uses: actions/setup-go@v1
       with:
         go-version: 1.18
     - name: Check out code
       uses: actions/checkout@v1
     - name: Lint Go Code
       run: |
         curl -sSfL  
         https://raw.GitHubusercontent.com/golangci/golangci-           lint/
         master/install.sh | sh -s -- -b $(go env GOPATH)/bin
         $(go env GOPATH)/bin/golangci-lint run
 build:
   ...
   steps:
     - name: Set up Go
       uses: actions/setup-go@v1
       with:
         go-version: 1.18
     - name: Check out code
       uses: actions/checkout@v1
     - name: Build
       run: make build</pre>
<p>The explanation of the steps<a id="_idIndexMarker422"/> performed for the <strong class="source-inline">lint</strong> job is <span class="No-Break">as follows:</span></p>
<ol>
<li value="1">Set up a Go 1.18 environment using the <strong class="source-inline">actions/setup-go</strong> GitHub Action. </li>
<li>Check out the source code using the <strong class="source-inline">actions/checkout</strong> <span class="No-Break">GitHub Action.</span></li>
<li>Perform a linting operation on the source code. The shell script will install the <strong class="source-inline">golangci-lint</strong> tool and run it using the <strong class="source-inline">golangci-lint </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command.</span></li>
</ol>
<p>The other <strong class="source-inline">build</strong> job will perform the <span class="No-Break">following steps:</span></p>
<ol>
<li value="1">Set up a Go 1.18 environment using the <strong class="source-inline">actions/setup-go</strong> <span class="No-Break">GitHub Action.</span></li>
<li>Check out the source code using the <strong class="source-inline">actions/checkout</strong> <span class="No-Break">GitHub Action.</span></li>
<li>Build the application by executing the <strong class="source-inline">make </strong><span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> command.</span></li>
</ol>
<p>Each step defined inside a job uses GitHub Actions that perform different operations such as checking out code, running shell script, and setting up the environment for compiling the <span class="No-Break">Go application.</span></p>
<p>In the next section, we will look at GitHub Packages and how to use them to deploy the Docker image that we will build for <span class="No-Break">our application.</span><a id="_idTextAnchor249"/></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor250"/>Publishing Docker images</h1>
<p>After developing your <a id="_idIndexMarker423"/>application, the next step is to deploy the application so that your user can start using it. To do this, you need to package your application. This is where Docker comes into the picture. Docker is a tool that is used to package your application into a single file, making it easy to deploy into a cloud environment such as Amazon, Google, and so on. We will look at Docker images and containers in depth in <a href="B18295_13.xhtml#_idTextAnchor261"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><em class="italic">, Dockerizing an Application</em>. We will look at the file with which we configure Docker, called the <strong class="source-inline">Dockerfile</strong>. We will briefly look at what this <span class="No-Break">file does<a id="_idTextAnchor251"/>.</span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor252"/>Dockerfile</h2>
<p><strong class="source-inline">Dockerfile</strong> is the default filename <a id="_idIndexMarker424"/>used to name a file that contains instructions for building an image for your application. The <strong class="source-inline">Dockerfile</strong> contains instructions on steps for Docker to perform to package your application into a <span class="No-Break">Docker image.</span></p>
<p>Let’s take a look at the <strong class="source-inline">Dockerfile</strong> that we have inside the <span class="No-Break"><strong class="source-inline">Chapter12</strong></span><span class="No-Break"> directory:</span></p>
<pre class="console">
# 1. Compile the app.
FROM golang:1.18  as builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -o bin/embed
# 2. Create final environment for the compiled binary.
FROM alpine:latest
RUN apk --update upgrade &amp;&amp; apk --no-cache add curl ca-certificates &amp;&amp; rm -rf /var/cache/apk/*
RUN mkdir -p /app
# 3. Copy the binary from step 1 and set it as the default command.
COPY --from=builder /app/bin/embed /app
WORKDIR /app
CMD /app/embed</pre>
<p>There are three major steps to<a id="_idIndexMarker425"/> package <span class="No-Break">the application:</span></p>
<ol>
<li value="1">Compile our Go application into a binary file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">embed</strong></span><span class="No-Break">.</span></li>
<li>Create an environment that will be used to run our application. In our example, we are using an environment or operating system called <strong class="source-inline">alpine</strong>. </li>
<li>Copy the binary that was built in the first step into the new environment that we set up in the <span class="No-Break">second step.</span></li>
</ol>
<p>We will use the <strong class="source-inline">Dockerfile</strong> in the next section to store the image in <span class="No-Break">GitHub Packages.</span><a id="_idTextAnchor253"/></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor254"/>GitHub Packages</h1>
<p>GitHub Packages is a service provided <a id="_idIndexMarker426"/>by GitHub that allows developers to host their packages. These packages can be accessed either by your team or made available to the general public. We will use this service to publish our Docker image and make it available to be consumed by <span class="No-Break">the public.</span></p>
<p>There are a few things we need to set up before we can deploy our Docker image into GitHub Packages. This section will walk you through the steps required to set up your repository. We will use <strong class="source-inline">GitHub.com/nanikjava/golangci</strong> as a reference in <span class="No-Break">this section.</span></p>
<p>You can access GitHub Packages from your repository by clicking on the <strong class="bold">Packages</strong> link, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 12.9: Access to GitHub Packages" height="259" src="image/Figure_12.09_B18295.jpg" width="279"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9: Access to GitHub Packages</p>
<p>Once you click on the <strong class="bold">Packages</strong> link, you will <a id="_idIndexMarker427"/>be shown a screen similar to that in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.10</em>. There will be no <strong class="bold">Packages</strong> displayed as we have not yet <span class="No-Break">published any.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 12.10: The GitHub Packages page" height="267" src="image/Figure_12.10_B18295.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10: The GitHub Packages page<a id="_idTextAnchor255"/></p>
<p>In the next section, we will look at how to publish the Docker images that we turn into packages on <span class="No-Break">GitHub</span><span class="No-Break"><a id="_idIndexMarker428"/></span><span class="No-Break"> Packages<a id="_idTextAnchor256"/>.</span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor257"/>Publishing to GitHub Packages</h2>
<p>Security is an important <a id="_idIndexMarker429"/>part of GitHub. In order to be able to write Docker images into GitHub Packages, let’s try to understand what is required. Every time GitHub runs a workflow, a temporary token is assigned to the workflow<a id="_idIndexMarker430"/> that can be used as an authentication key, allowing GitHub Actions to perform certain operations. This key is known as <span class="No-Break"><strong class="source-inline">GITHUB_TOKEN</strong></span><span class="No-Break"> internally.</span></p>
<p>The <strong class="source-inline">GITHUB_TOKEN</strong> key has default permissions that can be made restrictive, depending on your organization’s needs. To see the default permissions, click on the <strong class="bold">Settings </strong>tab from your repository, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.11</em>. </p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 12.11: The Actions menu from Settings" height="323" src="image/Figure_12.11_B18295.jpg" width="475"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11: The Actions menu from Settings</p>
<p>Click on the <strong class="bold">Actions</strong> menu and select <strong class="bold">General</strong>. You will be shown the default permissions, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.12</em>. As you can see, the default permissions are <strong class="bold">Read and write</strong> for <span class="No-Break">the workflow.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 12.12: The GITHUB_TOKEN default permissions" height="159" src="image/Figure_12.12_B18295.jpg" width="413"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12: The GITHUB_TOKEN default permissions</p>
<p>The workflow that <a id="_idIndexMarker431"/>we going to look at can be found inside <strong class="source-inline">chapter12/.GitHub/workflows/builddocker.yml</strong> and<a id="_idIndexMarker432"/> looks like <span class="No-Break">the following:</span></p>
<pre class="console">
name: Build Docker Image
on:
 push:
   branches:
     - main
 pull_request:
env:
 REGISTRY: ghcr.io
 IMAGE_NAME: ${{ GitHub.repository }}
jobs:
 push_to_GitHub_registry:
   name: Push Docker image to Docker Hub
   runs-on: ubuntu-latest
   steps:
     ...
     - name: Log in to the Container registry
       uses: docker/login-action@v2
       with:
         registry: ${{ env.REGISTRY }}
         username: ${{ GitHub.actor }}
         password: ${{ secrets.GITHUB_TOKEN }}
     - name: Build and push Docker image
       uses: docker/build-push-action@v3
       with:
         context: .
         file: ./Dockerfile
         push: true
         tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME 
               }}/chapter12:latest</pre>
<p>The workflow performs the following steps in order to publish the <span class="No-Break">Docker image:</span></p>
<ol>
<li value="1">The workflow logs in to<a id="_idIndexMarker433"/> the registry (GitHub Packages) using the <strong class="source-inline">docker/login-action@v2</strong> GitHub Action. The parameters supplied to the GitHub Action are <strong class="source-inline">username</strong>, <strong class="source-inline">password</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">registry</strong></span><span class="No-Break">.</span></li>
<li>The <strong class="source-inline">username</strong> is the GitHub <a id="_idIndexMarker434"/>username, which triggers the workflow process. The <strong class="source-inline">registry</strong> parameter will be value from the <strong class="source-inline">REGISTRY</strong> environment variable, which will be <strong class="source-inline">- ghcr.io</strong>. The <strong class="source-inline">password</strong> field will be automatically populated <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">secrets.GITHUB_TOKEN</strong></span><span class="No-Break">.</span></li>
<li>The last step is to build and publish the Docker image using the <strong class="source-inline">docker/build-push-action@v3</strong> GitHub Action. The parameter passed to the GitHub Action is the <em class="italic">file</em> that will be used to build the Docker image. In our case, it’s called <strong class="source-inline">Dockerfile</strong>. The tag name used to tag or label the Docker image will look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">ghcr.io/golangci/chapter12:latest</strong></span><span class="No-Break">.</span></li>
</ol>
<p>Now that we have everything <a id="_idIndexMarker435"/>set up, the next time you push any code changes into the <strong class="source-inline">main</strong> branch, the workflow will run. An example of a successful run can be seen in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.13</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 12.13: A successful workflow run publishing a Docker image" height="260" src="image/Figure_12.13_B18295.jpg" width="391"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13: A successful workflow run publishing a Docker image</p>
<p>The Docker image can be <a id="_idIndexMarker436"/>seen on the GitHub Packages page, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<img alt="Figure 12.14: The chapter12 Docker image inside GitHub Packages" height="289" src="image/Figure_12.14_B18295.jpg" width="320"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14: The chapter12 Docker image inside GitHub Packages</p>
<p>In the next section, we will look <a id="_idIndexMarker437"/>at downloading our newly created Docker image and using <a id="_idIndexMarker438"/><span class="No-Break">it local<a id="_idTextAnchor258"/>ly.</span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor259"/>Pulling from GitHub Packages</h2>
<p>We have successfully set <a id="_idIndexMarker439"/>up CI for our application. Now, we have to test whether the Docker image that was run as part of the CI process has <a id="_idIndexMarker440"/>successfully built our application's Docker image. </p>
<p>Our Docker image is hosted inside GitHub Packages, which is made public by default as our repository is a public repository. <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.14</em> shows the Docker images that are available to be used, including the command to pull the image locally. Open your terminal, then run the <span class="No-Break">following command:</span></p>
<pre class="console">
docker pull ghcr.io/nanikjava/golangci/chapter12:latest</pre>
<p>You will get the <span class="No-Break">following output:</span></p>
<pre class="console">
latest: Pulling from nanikjava/golangci/chapter12
213ec9aee27d: Already exists 
3a904afc80b3: Pull complete 
561cc7c7d83b: Pull complete 
aee36b390937: Pull complete 
4f4fb700ef54: Pull complete 
Digest: sha256:a355f55c33a400290776faf20b33d45096eb19a6431fb0b3 f723c17236e8b03e
Status: Downloaded newer image for ghcr.io/nanikjava/golangci/chapter12:latest</pre>
<p>The image has been downloaded <a id="_idIndexMarker441"/>to your local machine. Run the Docker image using the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker442"/></span><span class="No-Break">command:</span></p>
<pre class="console">
docker run -p 3333:3333 ghcr.io/nanikjava/golangci/chapter12</pre>
<p>You know that the container is running when you see the <span class="No-Break">following output:</span></p>
<pre class="console">
2022/08/18 08:03:10 Server Version : 0.0.1</pre>
<p>Open your browser and enter <strong class="source-inline">http://localhost:3333</strong> into the browser address bar. You will see the login page. We have successfully completed our CI process and are able to run the Docker image that we <span class="No-Break">have built.</span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor260"/>Summary</h1>
<p>In this chapter, we explored CI, developed an understanding of why it is important, and the benefits we get by setting up an automated CI process for a project. We learned to set up a GitHub repository to prepare our CI process and also learned to write a GitHub Actions workflow that enables us to automate a number of steps for <span class="No-Break">our application.</span></p>
<p>Using GitHub Actions, we were able to build our application into an executable binary. This is performed every time we push code into the repository. We learned about building Docker images for our application and the benefits we get by packaging our application as a <span class="No-Break">Docker image.</span></p>
<p>We learned about GitHub Packages and how to configure it to allow us to push our Docker images to a central location. Having our application packaged as a Docker image makes it easy for us to test our application anywhere. We don’t have to worry about building the source code as everything is packaged together into a single Docker image file. </p>
<p>In the next chapter we will learn on how to package our application as container, which will make it easy to deploy as a single image and allow us to deploy application in the cloud using different <span class="No-Break">cloud providers.</span></p>
</div>
</div></body></html>