- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Building Continuous Integration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建持续集成
- en: Building web applications to solve a problem is great, but we also need to make
    the applications available to users so they can start using them. As developers,
    we write code. But, at the same time, this code will need to be built or compiled
    so that it can be deployed, allowing users to use it. We need to understand how
    we can build our web application automatically, without requiring any manual process
    to work through. This is what we are going to talk about in this chapter. We will
    look at what is known as **continuous** **integration** (**CI**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建解决问题的 Web 应用程序是很好的，但我们还需要让这些应用程序对用户可用，以便他们可以开始使用它们。作为开发者，我们编写代码。但是，同时，这段代码需要被构建或编译，以便它可以部署，使用户能够使用它。我们需要了解我们如何自动构建我们的
    Web 应用程序，而不需要任何手动过程来工作。这就是我们将在本章中讨论的内容。我们将探讨所谓的**持续****集成**（**CI**）。
- en: CI is a practice or process for automating the integration of code from different
    contributors into a project. CI allows developers to frequently merge code into
    a code repository where it will be tested and built automatically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一种自动化将不同贡献者的代码集成到项目中的实践或过程。CI 允许开发者频繁地将代码合并到代码库中，在那里它将被自动测试和构建。
- en: 'In this chapter, we will learn about the following for CI:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 CI 的以下内容：
- en: GitHub workflows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 工作流程
- en: Using GitHub Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions
- en: Publishing to GitHub Packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到 GitHub Packages
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12).
    In this chapter, we will also be using another repository when setting up CI for
    explanatory purposes. The repository is [https://GitHub.com/nanikjava/golangci](https://GitHub.com/nanikjava/golangci).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12)找到。在本章中，我们还将使用另一个存储库来设置
    CI 以进行说明。该存储库是[https://GitHub.com/nanikjava/golangci](https://GitHub.com/nanikjava/golangci)。
- en: Importance of CI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI 的重要性
- en: You can think of CI as one aspect of your development process. The main reason
    why this is important is to allow you, as developers, to ensure that all code
    that is committed into a central code repository is tested and validated.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 CI 视为你的开发过程中的一个方面。这之所以重要，主要是因为它允许你作为开发者确保所有提交到中央代码库的代码都经过测试和验证。
- en: This becomes crucial when you are working in a team environment where multiple
    developers are working on the same project. Having proper CI will give developers
    peace of mind and assurance that all code they are using can be compiled properly
    and that automated test cases have been run successfully. Imagine that you have
    to check out some projects from GitHub, but when you try to compile and run some
    test cases, it fails; it would be a disaster as you would have to spend time fixing
    things, but if the project had a proper CI process set up, it would ensure all
    the committed code would compile correctly and test cases would pass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在团队环境中工作时，多个开发者正在同一个项目上工作，这一点变得至关重要。拥有适当的 CI 将会给开发者带来安心和保证，即他们所使用的所有代码都可以正确编译，并且自动测试用例已经成功运行。想象一下，你必须从
    GitHub 检出一些项目，但当你尝试编译和运行一些测试用例时，它失败了；这将是一场灾难，因为你将不得不花时间修复问题，但如果项目有一个适当的 CI 流程，它将确保所有提交的代码都能正确编译，测试用例都能通过。
- en: Even when working as a solo developer on a project, it is highly recommended
    to have CI in place. The minimum benefit you will get from this is the assurance
    that your code can be built correctly. This also makes sure that any local dependencies
    related to your local machine that have been accidentally added to the code are
    detected when a build failure occurs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使作为一个独立开发者在一个项目上工作，也强烈建议设置 CI。你从这得到的最小好处是确保你的代码可以正确构建。这也确保了当构建失败发生时，任何意外添加到代码中的与你的本地机器相关的本地依赖项被检测到。
- en: In the next section, we will look at building our CI using GitHub by going through
    the different steps required to have CI for our web application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过查看构建我们 Web 应用程序的 CI 所需的不同步骤，来探讨使用 GitHub 构建 CI。
- en: Setting up GitHub
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 GitHub
- en: In this section, we will explain the different things that need to be prepared
    to get automated CI in GitHub. To gain a better understanding of the CI process,
    it is recommended that you create your own separate GitHub repository and copy
    everything inside the `chapter12` directory to the new repository. Initially,
    when the `nanikjava/golangci` repository is created, it will look similar to *Figure
    12**.1*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释为了在GitHub中获得自动化CI需要准备的不同事项。为了更好地理解CI过程，建议您创建一个单独的GitHub仓库，并将`chapter12`目录中的所有内容复制到新仓库中。最初，当创建`nanikjava/golangci`仓库时，它将类似于*图12.1*。
- en: '![ Figure 12.1: A fresh GitHub repo](img/Figure_12.01_B18295.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：一个全新的GitHub仓库](img/Figure_12.01_B18295.jpg)'
- en: 'Figure 12.1: A fresh GitHub repo'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：一个全新的GitHub仓库
- en: For this chapter, we have set up a separate repository ([https://GitHub.com/nanikjava/golangci](https://GitHub.com/nanikjava/golangci))
    that we will use as a reference guide for the discussions in this chapter. We
    will go through the steps of creating a simple GitHub workflow in the repository.
    A GitHub workflow is a set of instructions that run one or more jobs. The instructions
    are defined in a YAML file with the extension of `.yaml` in the `.GitHub/workflows`
    directory of the repository.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们已设置一个单独的仓库([https://GitHub.com/nanikjava/golangci](https://GitHub.com/nanikjava/golangci))，我们将将其用作本章讨论的参考指南。我们将通过在仓库中创建简单GitHub工作流程的步骤进行说明。GitHub工作流程是一组运行一个或多个作业的指令。这些指令定义在仓库`.GitHub/workflows`目录中扩展名为`.yaml`的YAML文件中。
- en: You can define multiple workflows for your repository that perform different
    automated processes. For example, you can have one workflow file to build and
    test your application and another for deploying the application to a central location.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为您的仓库定义多个工作流程，以执行不同的自动化过程。例如，您可以有一个工作流程文件来构建和测试您的应用程序，另一个用于将应用程序部署到中央位置。
- en: 'Let’s create a simple workflow file inside the new repository by following
    the steps below:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤在新的仓库中创建一个简单的工作流程文件：
- en: From your repository, click on the **Actions** menu. This will bring you to
    the **Get Started with GitHub Actions** page, as shown in *Figure 12**.2*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的仓库中，点击**操作**菜单。这将带您到**GitHub操作入门**页面，如图*图12.2*所示。
- en: '![Figure 12.2: The Get started with GitHub Actions page](img/Figure_12.02_B18295.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：GitHub操作入门页面](img/Figure_12.02_B18295.jpg)'
- en: 'Figure 12.2: The Get started with GitHub Actions page'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：GitHub操作入门页面
- en: Click on the **set up a workflow yourself** link. This will take to you a new
    page where you can start writing your workflow, as shown in *Figure 12**.3*.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**自行设置工作流程**链接。这将带您到一个新页面，您可以在其中开始编写工作流程，如图*图12.3*所示。
- en: '![Figure 12.3: The create a new workflow screen](img/Figure_12.03_B18295.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：创建新工作流程屏幕](img/Figure_12.03_B18295.jpg)'
- en: 'Figure 12.3: The create a new workflow screen'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：创建新工作流程屏幕
- en: For now, we are going to create a simple workflow that we can use from GitHub.
    The workflow can be found at [https://docs.GitHub.com/en/actions/quickstart](https://docs.GitHub.com/en/actions/quickstart).
    Copy and paste the workflow, as shown in *Figure 12**.4*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的可以用于GitHub的工作流程。该工作流程可以在[https://docs.GitHub.com/en/actions/quickstart](https://docs.GitHub.com/en/actions/quickstart)找到。按照*图12.4*所示复制并粘贴工作流程。
- en: '![Figure 12.4: A sample GitHub workflow .yaml file](img/Figure_12.04_B18295.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：一个示例GitHub工作流程.yaml文件](img/Figure_12.04_B18295.jpg)'
- en: 'Figure 12.4: A sample GitHub workflow .yaml file'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：一个示例GitHub工作流程.yaml文件
- en: Commit the file by clicking on the **Start commit** button, as shown in *Figure
    12**.5*. After filling in all the commit information, click on the **Commit new**
    **file** button.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**开始提交**按钮来提交文件，如图*图12.3*所示。在填写完所有提交信息后，点击**提交新文件**按钮。
- en: '![Figure 12.5: The commit message for a .yaml file](img/Figure_12.05_B18295.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：.yaml文件的提交信息](img/Figure_12.05_B18295.jpg)'
- en: 'Figure 12.5: The commit message for a .yaml file'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：.yaml文件的提交信息
- en: Your repo now has a new GitHub workflow file. If you select the **Actions**
    menu again, this time you will see that your screen looks like *Figure 12**.6*.
    The screen shows that GitHub has run the workflow successfully.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您的仓库现在有一个新的GitHub工作流程文件。如果您再次选择**操作**菜单，这次您将看到屏幕看起来像*图12.6*。屏幕显示GitHub已成功运行工作流程。
- en: '![Figure 12.6: GitHub has successfully run the workflow](img/Figure_12.06_B18295.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6：GitHub已成功运行工作流程](img/Figure_12.06_B18295.jpg)'
- en: 'Figure 12.6: GitHub has successfully run the workflow'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：GitHub已成功运行工作流程
- en: We can look at the workflow results by clicking on the **Create main.yaml**
    link. You will see that the output indicates that the **Explore-GitHub-Actions**
    job was successfully run, as shown in *Figure 12**.7*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击**创建main.yaml**链接来查看工作流程结果。您将看到输出指示**Explore-GitHub-Actions**作业已成功运行，如图*12.7*所示。
- en: '![Figure 12.7: The Explore-GitHub-Actions step has been successfully run](img/Figure_12.07_B18295.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7：Explore-GitHub-Actions步骤已成功运行](img/Figure_12.07_B18295.jpg)'
- en: 'Figure 12.7: The Explore-GitHub-Actions step has been successfully run'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：Explore-GitHub-Actions步骤已成功运行
- en: After clicking on the **Explore-GitHub-Actions** jobs link, the output will
    be as shown in *Figure 12**.8*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Explore-GitHub-Actions**作业链接后，输出将如图*12.8*所示。
- en: '![Figure 12.8: The Explore-GitHub-Actions job output](img/Figure_12.08_B18295.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8：Explore-GitHub-Actions作业输出](img/Figure_12.08_B18295.jpg)'
- en: 'Figure 12.8: The Explore-GitHub-Actions job output'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：Explore-GitHub-Actions作业输出
- en: The workflow that we created in this section is actually the GitHub Actions
    workflow. We will look at this in more depth in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中创建的工作流程实际上是GitHub Actions工作流程。我们将在下一节中更深入地探讨它。
- en: GitHub Actions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: What is GitHub Actions? It is a platform that allows you to automate the complete
    integration and delivery of your project by automating the build, test, and deployment
    processes. GitHub Actions also gives you the ability to automate workflow processes
    such as pull requests, issue creation, and others.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是GitHub Actions？它是一个允许您通过自动化构建、测试和部署过程来自动化项目完整集成和交付的平台。GitHub Actions还赋予您自动化工作流程过程，如拉取请求、问题创建等的能力。
- en: 'We have now successfully created our first GitHub workflow. Let’s take a look
    at the workflow file to get an understanding of which GitHub Actions we are using.
    The workflow file we will use is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功创建了我们的第一个GitHub工作流程。让我们查看工作流程文件，了解我们正在使用哪些GitHub Actions。我们将使用的工作流程文件如下：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following table explains the different configurations in the file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下表解释了文件中的不同配置：
- en: '| **Configuration key** | **Explanation** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **配置键** | **说明** |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name | The generic name we give to the workflow that will be used as a label
    for viewing the results on the Actions page. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Name | 我们为将用作在Actions页面查看结果标签的工作流程提供的通用名称。|'
- en: '| On | Indicates to GitHub what kind of Git operation will trigger the workflow.
    In the example, it’s `push`*.* This means that the workflow will be triggered
    every time the Git `push` operation is detected in the repository. Different Git
    event operations can be seen in the GitHub docs: [https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows](https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows).
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| On | 告知GitHub哪种Git操作将触发工作流程。在示例中，它是`push`。这意味着每当在存储库中检测到Git `push`操作时，工作流程将被触发。不同的Git事件操作可以在GitHub文档中查看：[https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows](https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows)。|'
- en: '| Jobs | The workflow is made up of one or more jobs. These jobs are run in
    parallel by default. Jobs can be thought of as a single task that you want to
    do on your code. In our example, we named the job `Explore-GitHub-Actions` and
    it performs tasks defined by the *run* configuration. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Jobs | 工作流程由一个或多个作业组成。默认情况下，作业会并行运行。作业可以被视为您想在代码上执行的单个任务。在我们的例子中，我们命名作业为`Explore-GitHub-Actions`，它执行由*run*配置定义的任务。|'
- en: '| runs-on | Defines the runner that we want to use. The runner is the machine
    that you choose to run your workflow on. In our example, we are using the *ubuntu-latest*
    machine, or, in other words, we want to use a machine that runs the latest version
    of Ubuntu. A complete list of runners can be seen in the following link: [https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job](https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job).
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| runs-on | 定义了我们想要使用的运行者。运行者是您选择在之上运行工作流程的机器。在我们的例子中，我们使用的是*ubuntu-latest*机器，换句话说，我们想要使用运行最新版Ubuntu的机器。完整的运行者列表可以在以下链接中查看：[https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job](https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job)。|'
- en: '| Steps | Each job contains a sequence of tasks called steps. A step is where
    you define the operation you want to perform for the workflow. In our example,
    we defined several steps such as `run` where we just print out information. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 每个作业包含一系列称为步骤的任务。步骤是您定义要为工作流程执行的操作的地方。在我们的示例中，我们定义了几个步骤，例如 `run`，我们只是打印出信息。|'
- en: 'Now, we are going to take a look at the GitHub Action workflow we have for
    the sample application. The workflow can be found inside the `chapter12/.GitHub/workflows/build.yml`
    file, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看针对示例应用程序的 GitHub Action 工作流程。工作流程可以在 `chapter12/.GitHub/workflows/build.yml`
    文件中找到，如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will go now through this line by line to understand what the workflow is
    doing. The following snippet tells GitHub that the workflow will be triggered
    when source code is pushed to the `main` branch:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将逐行分析，了解工作流程正在做什么。以下代码片段告诉 GitHub，当源代码推送到 `main` 分支时，将触发工作流程：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next snippet shows the different jobs that GitHub will run when the event
    is detected; in this case, the `lint` and `build` jobs. The job will be run on
    an Ubuntu machine, as specified by the `runs-on` configuration:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了当检测到事件时，GitHub 将运行的不同作业；在这种情况下，是 `lint` 和 `build` 作业。作业将在由 `runs-on`
    配置指定的 Ubuntu 机器上运行：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The defined jobs are made up of the steps shown in the following snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的工作由以下代码片段中显示的步骤组成：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The explanation of the steps performed for the `lint` job is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `lint` 作业执行的步骤的解释如下：
- en: Set up a Go 1.18 environment using the `actions/setup-go` GitHub Action.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/setup-go` GitHub Action 设置 Go 1.18 环境。
- en: Check out the source code using the `actions/checkout` GitHub Action.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/checkout` GitHub Action 检出源代码。
- en: Perform a linting operation on the source code. The shell script will install
    the `golangci-lint` tool and run it using the `golangci-lint` `run` command.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对源代码执行 linting 操作。shell 脚本将安装 `golangci-lint` 工具并使用 `golangci-lint run` 命令运行它。
- en: 'The other `build` job will perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `build` 作业将执行以下步骤：
- en: Set up a Go 1.18 environment using the `actions/setup-go` GitHub Action.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/setup-go` GitHub Action 设置 Go 1.18 环境。
- en: Check out the source code using the `actions/checkout` GitHub Action.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/checkout` GitHub Action 检出源代码。
- en: Build the application by executing the `make` `build` command.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `make build` 命令构建应用程序。
- en: Each step defined inside a job uses GitHub Actions that perform different operations
    such as checking out code, running shell script, and setting up the environment
    for compiling the Go application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在作业中定义的每个步骤都使用 GitHub Actions 执行不同的操作，例如检出代码、运行 shell 脚本和设置编译 Go 应用程序的环境。
- en: In the next section, we will look at GitHub Packages and how to use them to
    deploy the Docker image that we will build for our application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 GitHub Packages 以及如何使用它们来部署我们将为应用程序构建的 Docker 镜像。
- en: Publishing Docker images
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布 Docker 镜像
- en: After developing your application, the next step is to deploy the application
    so that your user can start using it. To do this, you need to package your application.
    This is where Docker comes into the picture. Docker is a tool that is used to
    package your application into a single file, making it easy to deploy into a cloud
    environment such as Amazon, Google, and so on. We will look at Docker images and
    containers in depth in [*Chapter 13*](B18295_13.xhtml#_idTextAnchor261)*, Dockerizing
    an Application*. We will look at the file with which we configure Docker, called
    the `Dockerfile`. We will briefly look at what this file does.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发完您的应用程序后，下一步是部署应用程序，以便用户可以开始使用它。为此，您需要打包您的应用程序。这就是 Docker 出现的地方。Docker 是一个用于将您的应用程序打包到单个文件的工具，使其易于部署到云环境，如
    Amazon、Google 等。我们将在 [*第 13 章*](B18295_13.xhtml#_idTextAnchor261)*，应用程序 Docker
    化* 中深入了解 Docker 镜像和容器。我们将查看配置 Docker 的文件，称为 `Dockerfile`。我们将简要地看看这个文件的作用。
- en: Dockerfile
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '`Dockerfile` is the default filename used to name a file that contains instructions
    for building an image for your application. The `Dockerfile` contains instructions
    on steps for Docker to perform to package your application into a Docker image.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 是用于命名包含构建应用程序镜像指令的文件的默认文件名。`Dockerfile` 包含 Docker 执行的步骤，以便将您的应用程序打包到
    Docker 镜像中。'
- en: 'Let’s take a look at the `Dockerfile` that we have inside the `Chapter12` directory:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Chapter12` 目录中我们拥有的 `Dockerfile`：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are three major steps to package the application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打包应用程序有三个主要步骤：
- en: Compile our Go application into a binary file called `embed`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 Go 应用程序编译成一个名为 `embed` 的二进制文件。
- en: Create an environment that will be used to run our application. In our example,
    we are using an environment or operating system called `alpine`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将用于运行我们的应用程序的环境。在我们的示例中，我们使用一个名为 `alpine` 的环境或操作系统。
- en: Copy the binary that was built in the first step into the new environment that
    we set up in the second step.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一步中构建的二进制文件复制到我们在第二步中设置的新环境中。
- en: We will use the `Dockerfile` in the next section to store the image in GitHub
    Packages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 `Dockerfile` 将镜像存储在 GitHub Packages 中。
- en: GitHub Packages
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub Packages
- en: GitHub Packages is a service provided by GitHub that allows developers to host
    their packages. These packages can be accessed either by your team or made available
    to the general public. We will use this service to publish our Docker image and
    make it available to be consumed by the public.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Packages 是 GitHub 提供的一项服务，允许开发者托管他们的包。这些包可以通过您的团队访问，或者对公众开放。我们将使用这项服务来发布我们的
    Docker 镜像，使其可供公众使用。
- en: There are a few things we need to set up before we can deploy our Docker image
    into GitHub Packages. This section will walk you through the steps required to
    set up your repository. We will use `GitHub.com/nanikjava/golangci` as a reference
    in this section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以将 Docker 镜像部署到 GitHub Packages 之前，我们需要设置一些东西。本节将指导您完成设置仓库所需的步骤。在本节中，我们将使用
    `GitHub.com/nanikjava/golangci` 作为参考。
- en: You can access GitHub Packages from your repository by clicking on the **Packages**
    link, as shown in *Figure 12**.9*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击 **包** 链接从您的仓库访问 GitHub Packages，如图 *图 12**.9* 所示。
- en: '![Figure 12.9: Access to GitHub Packages](img/Figure_12.09_B18295.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9：访问 GitHub Packages](img/Figure_12.09_B18295.jpg)'
- en: 'Figure 12.9: Access to GitHub Packages'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9：访问 GitHub Packages
- en: Once you click on the **Packages** link, you will be shown a screen similar
    to that in *Figure 12**.10*. There will be no **Packages** displayed as we have
    not yet published any.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击 **包** 链接，您将看到一个类似于 *图 12**.10* 的屏幕。由于我们尚未发布任何包，因此将不会显示 **包**。
- en: '![Figure 12.10: The GitHub Packages page](img/Figure_12.10_B18295.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10：GitHub Packages 页面](img/Figure_12.10_B18295.jpg)'
- en: 'Figure 12.10: The GitHub Packages page'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10：GitHub Packages 页面
- en: In the next section, we will look at how to publish the Docker images that we
    turn into packages on GitHub Packages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将我们转换成包的 Docker 镜像发布到 GitHub Packages。
- en: Publishing to GitHub Packages
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到 GitHub Packages
- en: Security is an important part of GitHub. In order to be able to write Docker
    images into GitHub Packages, let’s try to understand what is required. Every time
    GitHub runs a workflow, a temporary token is assigned to the workflow that can
    be used as an authentication key, allowing GitHub Actions to perform certain operations.
    This key is known as `GITHUB_TOKEN` internally.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是 GitHub 的重要组成部分。为了能够将 Docker 镜像写入 GitHub Packages，让我们尝试了解所需的内容。每次 GitHub
    运行工作流程时，都会分配一个临时令牌给工作流程，该令牌可以用作认证密钥，允许 GitHub Actions 执行某些操作。这个密钥在内部被称为 `GITHUB_TOKEN`。
- en: The `GITHUB_TOKEN` key has default permissions that can be made restrictive,
    depending on your organization’s needs. To see the default permissions, click
    on the **Settings** tab from your repository, as shown in *Figure 12**.11*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`GITHUB_TOKEN` 密钥具有默认权限，可以根据您组织的需要设置为限制性。要查看默认权限，请从您的仓库点击 **设置** 选项卡，如图 *图
    12**.11* 所示。'
- en: '![Figure 12.11: The Actions menu from Settings](img/Figure_12.11_B18295.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11：设置中的操作菜单](img/Figure_12.11_B18295.jpg)'
- en: 'Figure 12.11: The Actions menu from Settings'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11：设置中的操作菜单
- en: Click on the **Actions** menu and select **General**. You will be shown the
    default permissions, as shown in *Figure 12**.12*. As you can see, the default
    permissions are **Read and write** for the workflow.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **操作** 菜单并选择 **常规**。您将看到默认权限，如图 *图 12**.12* 所示。如您所见，默认权限是工作流程的 **读和写**。
- en: '![Figure 12.12: The GITHUB_TOKEN default permissions](img/Figure_12.12_B18295.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12：GITHUB_TOKEN 默认权限](img/Figure_12.12_B18295.jpg)'
- en: 'Figure 12.12: The GITHUB_TOKEN default permissions'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12：GITHUB_TOKEN 默认权限
- en: 'The workflow that we going to look at can be found inside `chapter12/.GitHub/workflows/builddocker.yml`
    and looks like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的工作流程位于 `chapter12/.GitHub/workflows/builddocker.yml` 内，其外观如下：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The workflow performs the following steps in order to publish the Docker image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程按照以下步骤顺序执行以发布 Docker 镜像：
- en: The workflow logs in to the registry (GitHub Packages) using the `docker/login-action@v2`
    GitHub Action. The parameters supplied to the GitHub Action are `username`, `password`,
    and `registry`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作流程使用`docker/login-action@v2` GitHub Action登录到注册表（GitHub Packages）。传递给GitHub
    Action的参数是`username`、`password`和`registry`。
- en: The `username` is the GitHub username, which triggers the workflow process.
    The `registry` parameter will be value from the `REGISTRY` environment variable,
    which will be `- ghcr.io`. The `password` field will be automatically populated
    using `secrets.GITHUB_TOKEN`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`username`是GitHub用户名，它触发工作流程过程。`registry`参数将是`REGISTRY`环境变量的值，即`- ghcr.io`。`password`字段将自动使用`secrets.GITHUB_TOKEN`填充。'
- en: The last step is to build and publish the Docker image using the `docker/build-push-action@v3`
    GitHub Action. The parameter passed to the GitHub Action is the *file* that will
    be used to build the Docker image. In our case, it’s called `Dockerfile`. The
    tag name used to tag or label the Docker image will look like `ghcr.io/golangci/chapter12:latest`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用`docker/build-push-action@v3` GitHub Action构建并发布Docker镜像。传递给GitHub Action的参数是用于构建Docker镜像的*文件*。在我们的例子中，它被称为`Dockerfile`。用于标记或标签Docker镜像的标签名称将类似于`ghcr.io/golangci/chapter12:latest`。
- en: Now that we have everything set up, the next time you push any code changes
    into the `main` branch, the workflow will run. An example of a successful run
    can be seen in *Figure 12**.13*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，下次你将任何代码更改推送到`main`分支时，工作流程将运行。一个成功的运行示例可以在*图12.13*中看到。
- en: '![Figure 12.13: A successful workflow run publishing a Docker image](img/Figure_12.13_B18295.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13：成功运行的工作流程发布Docker镜像](img/Figure_12.13_B18295.jpg)'
- en: 'Figure 12.13: A successful workflow run publishing a Docker image'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：成功运行的工作流程发布Docker镜像
- en: The Docker image can be seen on the GitHub Packages page, as shown in *Figure
    12**.14*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像可以在GitHub Packages页面上看到，如图*图12.14*所示。
- en: '![Figure 12.14: The chapter12 Docker image inside GitHub Packages](img/Figure_12.14_B18295.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14：GitHub Packages中的chapter12 Docker镜像](img/Figure_12.14_B18295.jpg)'
- en: 'Figure 12.14: The chapter12 Docker image inside GitHub Packages'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：GitHub Packages中的chapter12 Docker镜像
- en: In the next section, we will look at downloading our newly created Docker image
    and using it locally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看下载我们新创建的Docker镜像并本地使用它。
- en: Pulling from GitHub Packages
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从GitHub Packages拉取
- en: We have successfully set up CI for our application. Now, we have to test whether
    the Docker image that was run as part of the CI process has successfully built
    our application's Docker image.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功为我们的应用程序设置了CI。现在，我们必须测试作为CI过程一部分运行的Docker镜像是否成功构建了我们的应用程序的Docker镜像。
- en: 'Our Docker image is hosted inside GitHub Packages, which is made public by
    default as our repository is a public repository. *Figure 12**.14* shows the Docker
    images that are available to be used, including the command to pull the image
    locally. Open your terminal, then run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Docker镜像托管在GitHub Packages中，默认情况下是公开的，因为我们的仓库是公开仓库。*图12.14*显示了可用的Docker镜像，包括拉取镜像到本地的命令。打开你的终端，然后运行以下命令：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will get the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The image has been downloaded to your local machine. Run the Docker image using
    the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像已下载到你的本地机器。使用以下命令运行Docker镜像：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You know that the container is running when you see the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到以下输出时，你知道容器正在运行：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open your browser and enter `http://localhost:3333` into the browser address
    bar. You will see the login page. We have successfully completed our CI process
    and are able to run the Docker image that we have built.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器，并在浏览器地址栏中输入`http://localhost:3333`。你会看到登录页面。我们已经成功完成了我们的CI过程，并且能够运行我们构建的Docker镜像。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored CI, developed an understanding of why it is important,
    and the benefits we get by setting up an automated CI process for a project. We
    learned to set up a GitHub repository to prepare our CI process and also learned
    to write a GitHub Actions workflow that enables us to automate a number of steps
    for our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了持续集成（CI），了解了为什么它很重要，以及通过为项目设置自动化的CI流程所获得的益处。我们学习了如何设置GitHub仓库以准备我们的CI流程，还学习了如何编写GitHub
    Actions工作流程，使我们能够自动化应用程序的多个步骤。
- en: Using GitHub Actions, we were able to build our application into an executable
    binary. This is performed every time we push code into the repository. We learned
    about building Docker images for our application and the benefits we get by packaging
    our application as a Docker image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 GitHub Actions，我们能够将我们的应用程序构建成一个可执行的二进制文件。这在我们每次将代码推送到仓库时都会执行。我们学习了如何为我们的应用程序构建
    Docker 镜像，以及将应用程序打包成 Docker 镜像所带来的好处。
- en: We learned about GitHub Packages and how to configure it to allow us to push
    our Docker images to a central location. Having our application packaged as a
    Docker image makes it easy for us to test our application anywhere. We don’t have
    to worry about building the source code as everything is packaged together into
    a single Docker image file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 GitHub Packages 以及如何配置它，以便我们可以将我们的 Docker 镜像推送到一个中央位置。将我们的应用程序打包成 Docker
    镜像使得我们可以在任何地方轻松测试我们的应用程序。我们不必担心构建源代码，因为所有内容都已打包成一个单独的 Docker 镜像文件。
- en: In the next chapter we will learn on how to package our application as container,
    which will make it easy to deploy as a single image and allow us to deploy application
    in the cloud using different cloud providers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将我们的应用程序打包成容器，这将使得将其作为单个镜像部署变得容易，并允许我们使用不同的云提供商在云中部署应用程序。
