- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building web applications to solve a problem is great, but we also need to make
    the applications available to users so they can start using them. As developers,
    we write code. But, at the same time, this code will need to be built or compiled
    so that it can be deployed, allowing users to use it. We need to understand how
    we can build our web application automatically, without requiring any manual process
    to work through. This is what we are going to talk about in this chapter. We will
    look at what is known as **continuous** **integration** (**CI**).
  prefs: []
  type: TYPE_NORMAL
- en: CI is a practice or process for automating the integration of code from different
    contributors into a project. CI allows developers to frequently merge code into
    a code repository where it will be tested and built automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following for CI:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing to GitHub Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter12).
    In this chapter, we will also be using another repository when setting up CI for
    explanatory purposes. The repository is [https://GitHub.com/nanikjava/golangci](https://GitHub.com/nanikjava/golangci).
  prefs: []
  type: TYPE_NORMAL
- en: Importance of CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of CI as one aspect of your development process. The main reason
    why this is important is to allow you, as developers, to ensure that all code
    that is committed into a central code repository is tested and validated.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes crucial when you are working in a team environment where multiple
    developers are working on the same project. Having proper CI will give developers
    peace of mind and assurance that all code they are using can be compiled properly
    and that automated test cases have been run successfully. Imagine that you have
    to check out some projects from GitHub, but when you try to compile and run some
    test cases, it fails; it would be a disaster as you would have to spend time fixing
    things, but if the project had a proper CI process set up, it would ensure all
    the committed code would compile correctly and test cases would pass.
  prefs: []
  type: TYPE_NORMAL
- en: Even when working as a solo developer on a project, it is highly recommended
    to have CI in place. The minimum benefit you will get from this is the assurance
    that your code can be built correctly. This also makes sure that any local dependencies
    related to your local machine that have been accidentally added to the code are
    detected when a build failure occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at building our CI using GitHub by going through
    the different steps required to have CI for our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explain the different things that need to be prepared
    to get automated CI in GitHub. To gain a better understanding of the CI process,
    it is recommended that you create your own separate GitHub repository and copy
    everything inside the `chapter12` directory to the new repository. Initially,
    when the `nanikjava/golangci` repository is created, it will look similar to *Figure
    12**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 12.1: A fresh GitHub repo](img/Figure_12.01_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: A fresh GitHub repo'
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we have set up a separate repository ([https://GitHub.com/nanikjava/golangci](https://GitHub.com/nanikjava/golangci))
    that we will use as a reference guide for the discussions in this chapter. We
    will go through the steps of creating a simple GitHub workflow in the repository.
    A GitHub workflow is a set of instructions that run one or more jobs. The instructions
    are defined in a YAML file with the extension of `.yaml` in the `.GitHub/workflows`
    directory of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can define multiple workflows for your repository that perform different
    automated processes. For example, you can have one workflow file to build and
    test your application and another for deploying the application to a central location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple workflow file inside the new repository by following
    the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: From your repository, click on the **Actions** menu. This will bring you to
    the **Get Started with GitHub Actions** page, as shown in *Figure 12**.2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2: The Get started with GitHub Actions page](img/Figure_12.02_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The Get started with GitHub Actions page'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **set up a workflow yourself** link. This will take to you a new
    page where you can start writing your workflow, as shown in *Figure 12**.3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3: The create a new workflow screen](img/Figure_12.03_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The create a new workflow screen'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we are going to create a simple workflow that we can use from GitHub.
    The workflow can be found at [https://docs.GitHub.com/en/actions/quickstart](https://docs.GitHub.com/en/actions/quickstart).
    Copy and paste the workflow, as shown in *Figure 12**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: A sample GitHub workflow .yaml file](img/Figure_12.04_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: A sample GitHub workflow .yaml file'
  prefs: []
  type: TYPE_NORMAL
- en: Commit the file by clicking on the **Start commit** button, as shown in *Figure
    12**.5*. After filling in all the commit information, click on the **Commit new**
    **file** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5: The commit message for a .yaml file](img/Figure_12.05_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: The commit message for a .yaml file'
  prefs: []
  type: TYPE_NORMAL
- en: Your repo now has a new GitHub workflow file. If you select the **Actions**
    menu again, this time you will see that your screen looks like *Figure 12**.6*.
    The screen shows that GitHub has run the workflow successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: GitHub has successfully run the workflow](img/Figure_12.06_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: GitHub has successfully run the workflow'
  prefs: []
  type: TYPE_NORMAL
- en: We can look at the workflow results by clicking on the **Create main.yaml**
    link. You will see that the output indicates that the **Explore-GitHub-Actions**
    job was successfully run, as shown in *Figure 12**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: The Explore-GitHub-Actions step has been successfully run](img/Figure_12.07_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: The Explore-GitHub-Actions step has been successfully run'
  prefs: []
  type: TYPE_NORMAL
- en: After clicking on the **Explore-GitHub-Actions** jobs link, the output will
    be as shown in *Figure 12**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: The Explore-GitHub-Actions job output](img/Figure_12.08_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: The Explore-GitHub-Actions job output'
  prefs: []
  type: TYPE_NORMAL
- en: The workflow that we created in this section is actually the GitHub Actions
    workflow. We will look at this in more depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is GitHub Actions? It is a platform that allows you to automate the complete
    integration and delivery of your project by automating the build, test, and deployment
    processes. GitHub Actions also gives you the ability to automate workflow processes
    such as pull requests, issue creation, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now successfully created our first GitHub workflow. Let’s take a look
    at the workflow file to get an understanding of which GitHub Actions we are using.
    The workflow file we will use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table explains the different configurations in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Configuration key** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Name | The generic name we give to the workflow that will be used as a label
    for viewing the results on the Actions page. |'
  prefs: []
  type: TYPE_TB
- en: '| On | Indicates to GitHub what kind of Git operation will trigger the workflow.
    In the example, it’s `push`*.* This means that the workflow will be triggered
    every time the Git `push` operation is detected in the repository. Different Git
    event operations can be seen in the GitHub docs: [https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows](https://docs.GitHub.com/en/actions/using-workflows/triggering-a-workflow#using-events-to-trigger-workflows).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Jobs | The workflow is made up of one or more jobs. These jobs are run in
    parallel by default. Jobs can be thought of as a single task that you want to
    do on your code. In our example, we named the job `Explore-GitHub-Actions` and
    it performs tasks defined by the *run* configuration. |'
  prefs: []
  type: TYPE_TB
- en: '| runs-on | Defines the runner that we want to use. The runner is the machine
    that you choose to run your workflow on. In our example, we are using the *ubuntu-latest*
    machine, or, in other words, we want to use a machine that runs the latest version
    of Ubuntu. A complete list of runners can be seen in the following link: [https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job](https://docs.GitHub.com/en/actions/using-jobs/choosing-the-runner-for-a-job).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Steps | Each job contains a sequence of tasks called steps. A step is where
    you define the operation you want to perform for the workflow. In our example,
    we defined several steps such as `run` where we just print out information. |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we are going to take a look at the GitHub Action workflow we have for
    the sample application. The workflow can be found inside the `chapter12/.GitHub/workflows/build.yml`
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will go now through this line by line to understand what the workflow is
    doing. The following snippet tells GitHub that the workflow will be triggered
    when source code is pushed to the `main` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next snippet shows the different jobs that GitHub will run when the event
    is detected; in this case, the `lint` and `build` jobs. The job will be run on
    an Ubuntu machine, as specified by the `runs-on` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The defined jobs are made up of the steps shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of the steps performed for the `lint` job is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a Go 1.18 environment using the `actions/setup-go` GitHub Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the source code using the `actions/checkout` GitHub Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a linting operation on the source code. The shell script will install
    the `golangci-lint` tool and run it using the `golangci-lint` `run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The other `build` job will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a Go 1.18 environment using the `actions/setup-go` GitHub Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the source code using the `actions/checkout` GitHub Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the application by executing the `make` `build` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each step defined inside a job uses GitHub Actions that perform different operations
    such as checking out code, running shell script, and setting up the environment
    for compiling the Go application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at GitHub Packages and how to use them to
    deploy the Docker image that we will build for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After developing your application, the next step is to deploy the application
    so that your user can start using it. To do this, you need to package your application.
    This is where Docker comes into the picture. Docker is a tool that is used to
    package your application into a single file, making it easy to deploy into a cloud
    environment such as Amazon, Google, and so on. We will look at Docker images and
    containers in depth in [*Chapter 13*](B18295_13.xhtml#_idTextAnchor261)*, Dockerizing
    an Application*. We will look at the file with which we configure Docker, called
    the `Dockerfile`. We will briefly look at what this file does.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Dockerfile` is the default filename used to name a file that contains instructions
    for building an image for your application. The `Dockerfile` contains instructions
    on steps for Docker to perform to package your application into a Docker image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `Dockerfile` that we have inside the `Chapter12` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three major steps to package the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile our Go application into a binary file called `embed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an environment that will be used to run our application. In our example,
    we are using an environment or operating system called `alpine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the binary that was built in the first step into the new environment that
    we set up in the second step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use the `Dockerfile` in the next section to store the image in GitHub
    Packages.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Packages is a service provided by GitHub that allows developers to host
    their packages. These packages can be accessed either by your team or made available
    to the general public. We will use this service to publish our Docker image and
    make it available to be consumed by the public.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things we need to set up before we can deploy our Docker image
    into GitHub Packages. This section will walk you through the steps required to
    set up your repository. We will use `GitHub.com/nanikjava/golangci` as a reference
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: You can access GitHub Packages from your repository by clicking on the **Packages**
    link, as shown in *Figure 12**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Access to GitHub Packages](img/Figure_12.09_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Access to GitHub Packages'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click on the **Packages** link, you will be shown a screen similar
    to that in *Figure 12**.10*. There will be no **Packages** displayed as we have
    not yet published any.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: The GitHub Packages page](img/Figure_12.10_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: The GitHub Packages page'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to publish the Docker images that we
    turn into packages on GitHub Packages.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to GitHub Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security is an important part of GitHub. In order to be able to write Docker
    images into GitHub Packages, let’s try to understand what is required. Every time
    GitHub runs a workflow, a temporary token is assigned to the workflow that can
    be used as an authentication key, allowing GitHub Actions to perform certain operations.
    This key is known as `GITHUB_TOKEN` internally.
  prefs: []
  type: TYPE_NORMAL
- en: The `GITHUB_TOKEN` key has default permissions that can be made restrictive,
    depending on your organization’s needs. To see the default permissions, click
    on the **Settings** tab from your repository, as shown in *Figure 12**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11: The Actions menu from Settings](img/Figure_12.11_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: The Actions menu from Settings'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Actions** menu and select **General**. You will be shown the
    default permissions, as shown in *Figure 12**.12*. As you can see, the default
    permissions are **Read and write** for the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: The GITHUB_TOKEN default permissions](img/Figure_12.12_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: The GITHUB_TOKEN default permissions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow that we going to look at can be found inside `chapter12/.GitHub/workflows/builddocker.yml`
    and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The workflow performs the following steps in order to publish the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: The workflow logs in to the registry (GitHub Packages) using the `docker/login-action@v2`
    GitHub Action. The parameters supplied to the GitHub Action are `username`, `password`,
    and `registry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `username` is the GitHub username, which triggers the workflow process.
    The `registry` parameter will be value from the `REGISTRY` environment variable,
    which will be `- ghcr.io`. The `password` field will be automatically populated
    using `secrets.GITHUB_TOKEN`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step is to build and publish the Docker image using the `docker/build-push-action@v3`
    GitHub Action. The parameter passed to the GitHub Action is the *file* that will
    be used to build the Docker image. In our case, it’s called `Dockerfile`. The
    tag name used to tag or label the Docker image will look like `ghcr.io/golangci/chapter12:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have everything set up, the next time you push any code changes
    into the `main` branch, the workflow will run. An example of a successful run
    can be seen in *Figure 12**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: A successful workflow run publishing a Docker image](img/Figure_12.13_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: A successful workflow run publishing a Docker image'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker image can be seen on the GitHub Packages page, as shown in *Figure
    12**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: The chapter12 Docker image inside GitHub Packages](img/Figure_12.14_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: The chapter12 Docker image inside GitHub Packages'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at downloading our newly created Docker image
    and using it locally.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling from GitHub Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully set up CI for our application. Now, we have to test whether
    the Docker image that was run as part of the CI process has successfully built
    our application's Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Docker image is hosted inside GitHub Packages, which is made public by
    default as our repository is a public repository. *Figure 12**.14* shows the Docker
    images that are available to be used, including the command to pull the image
    locally. Open your terminal, then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The image has been downloaded to your local machine. Run the Docker image using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You know that the container is running when you see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser and enter `http://localhost:3333` into the browser address
    bar. You will see the login page. We have successfully completed our CI process
    and are able to run the Docker image that we have built.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored CI, developed an understanding of why it is important,
    and the benefits we get by setting up an automated CI process for a project. We
    learned to set up a GitHub repository to prepare our CI process and also learned
    to write a GitHub Actions workflow that enables us to automate a number of steps
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub Actions, we were able to build our application into an executable
    binary. This is performed every time we push code into the repository. We learned
    about building Docker images for our application and the benefits we get by packaging
    our application as a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about GitHub Packages and how to configure it to allow us to push
    our Docker images to a central location. Having our application packaged as a
    Docker image makes it easy for us to test our application anywhere. We don’t have
    to worry about building the source code as everything is packaged together into
    a single Docker image file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn on how to package our application as container,
    which will make it easy to deploy as a single image and allow us to deploy application
    in the cloud using different cloud providers.
  prefs: []
  type: TYPE_NORMAL
