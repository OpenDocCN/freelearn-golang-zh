<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer104">
<h1 class="chapter-number" id="_idParaDest-162"><a id="_idTextAnchor261"/>13</h1>
<h1 id="_idParaDest-163"><a id="_idTextAnchor262"/>Dockerizing an Application</h1>
<p>In this chapter, we will learn about Docker and how to package applications as Docker images. Understanding how to package your application as a Docker image will allow you to deploy the application in any kind of environment and infrastructure without having to worry about setting up the infrastructure to build your application. Building a Docker image will allow you to run your application anywhere you like: build once and <span class="No-Break">deploy anywhere.</span></p>
<p>In this chapter, we will learn about the following <span class="No-Break">key topics:</span></p>
<ul>
<li>Building a <span class="No-Break">Docker image</span></li>
<li>Running a <span class="No-Break">Docker image</span></li>
<li>Creating a Docker image <span class="No-Break">from scratch</span></li>
<li>Understanding the Docker <span class="No-Break">image filesystem</span></li>
<li>Looking at <span class="No-Break">Docker Compose</span></li>
</ul>
<h1 id="_idParaDest-164"><a id="_idTextAnchor263"/>Technical requirements</h1>
<p>All the source code explained in this chapter can be checked out <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13"><span class="No-Break">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor264"/>Installing Docker</h1>
<p>Docker<a id="_idIndexMarker443"/> is an open source platform that is used for software development, making it easy to package and ship programs. Docker enables you to package your application and run it in different kinds of infrastructure such as <span class="No-Break">cloud environments.</span></p>
<p>In this section, we will look at<a id="_idIndexMarker444"/> installing Docker on a local machine. Different operating systems have different steps for installing it. Refer to the Docker documentation for an in-depth installation guide relevant to your operating system, which can be found <span class="No-Break">at </span><a href="https://docs.docker.com/engine/install/"><span class="No-Break">https://docs.docker.com/engine/install/</span></a><span class="No-Break">.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">This chapter was written on a Linux machine, so most of the command-line applications that are outlined are only available <span class="No-Break">for Linux.</span></p>
<p>After taking the steps to install Docker on our development machine, the following are some of the things we do to ensure that everything is <span class="No-Break">working fine.</span></p>
<p>Use the following commands to check that the Docker engine <span class="No-Break">is running:</span></p>
<pre class="console">
systemctl list-units --type=service --state=running   | grep -i docker &amp;&amp; systemctl list-units --type=service --state=active  | grep -i containerd</pre>
<p>You will see the following output if the engine has been <span class="No-Break">installed correctly:</span></p>
<pre class="console">
  docker.service                     loaded    active running Docker Application Container Engine
  containerd.service             loaded    active running containerd container runtime</pre>
<p>The output shows two different services running – <strong class="source-inline">docker.service</strong> and <strong class="source-inline">containerd.service</strong>. The <strong class="source-inline">containerd.service</strong> service takes care of launching the Docker image into a container and ensuring that all the local machine services are set up to allow the container to run while the <strong class="source-inline">docker.service</strong> service takes care of the management of the image and communication with the Docker <span class="No-Break">command-line tools.</span></p>
<p>Now that we know both services are running, let’s use the command-line tools to check the communication with the engine. Use the following command to communicate with the engine to list all the locally available images – note you may need to have root privileges to do this so prefixing with <strong class="source-inline">sudo</strong> might <span class="No-Break">be required:</span></p>
<pre class="console">
docker images</pre>
<p>In our case, we get the<a id="_idIndexMarker445"/> output as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em>, showing we have downloaded two images. In your case, if this is your first time installing Docker, it will <span class="No-Break">be empty.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<img alt="Figure 13.1: Docker images on a local machine" height="64" src="image/Figure_13.01_B18295.jpg" width="460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: Docker images on a local machine</p>
<p>We have successfully completed the Docker installation on the local machine. In the next section, we will go into more detail about using Docker and understanding <span class="No-Break">Docker images<a id="_idTextAnchor265"/>.</span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor266"/>Using Docker</h1>
<p>In this section, we <a id="_idIndexMarker446"/>will look at how to use Docker for day-to-day operations. Let’s understand the concepts that are talked about when using Docker – images and <span class="No-Break">the container:</span></p>
<ul>
<li><strong class="bold">Docker image</strong>: This <a id="_idIndexMarker447"/>image is a file that contains our application, including all the relevant operating <span class="No-Break">system files.</span></li>
<li><strong class="bold">Container</strong>: The image file is read and executed by the Docker engine. Once it runs on the local machine it is called a <a id="_idIndexMarker448"/>container. You can interact with the container using the Docker <span class="No-Break">command-line tools.</span></li>
</ul>
<p>We will look at using Docker to download and run a simple <em class="italic">Hello World</em> application using the <span class="No-Break">following command:</span></p>
<pre class="console">
docker run hello-world</pre>
<p>Open your terminal and run the <span class="No-Break">following command:</span></p>
<pre class="console">
$ docker run hello-world</pre>
<p>This command will download the image file (if none exists locally) and execute it. You will then see the <span class="No-Break">following message:</span></p>
<pre class="console">
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
2db29710123e: Pull complete
Digest: sha256:10d7d58d5ebd2a652f4d93fdd86da8f265f5318c6a73cc5b 6a9798ff6d2b2e67
Status: Downloaded newer image for hello-world:latest</pre>
<p>Once the <a id="_idIndexMarker449"/>image has been downloaded and run as a container, it will print out the <span class="No-Break">following output:</span></p>
<pre class="console">
Hello from Docker!
This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 …
 …
 https://docs.docker.com/get-started/</pre>
<p>Now that we have had a taste of how to run an image file as a container, we will explore Docker images more in the <span class="No-Break">next sec<a id="_idTextAnchor267"/>tion.</span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor268"/>Docker images</h1>
<p>Docker image<a id="_idIndexMarker450"/> files look like any other file on your local machine, except they are stored in a special format that can only be understood by Docker. Locally the image files are stored inside the <strong class="source-inline">/var/lib/docker/image/overlay2</strong> directory. To see what images are available, you can take a look at the <strong class="source-inline">repositories.json</strong> file, which looks <span class="No-Break">as follows:</span></p>
<pre class="source-code">
{
  "Repositories": {
    "hello-world": {
      "hello-world:latest":
        "sha256:feb5d9fea6a5e9606aa995e879d862b82
         5965ba48de054caab5ef356dc6b3412",
      "hello-world@sha256:
        10d7d58d5ebd2a652f4d93fdd86da8f265f5318c6a7
       3cc5b6a9798ff6d2b2e67":
         "sha256:feb5d9fea6a5e9606aa995e879d862
          b825965ba48de054caab5ef356dc6b3412"
    },
    "...
    "redis": {
      "redis:latest":
        "sha256:bba24acba395b778d9522a1adf5f0d6bba3e609
         4b2d298e71ab08828b880a01b",
      "redis@sha256:69a3ab2516b560690e37197b71bc61ba24
                    5aafe4525ebdec
       e1d8a0bc5669e3e2":
         "sha256:bba24acba395b778d9522a1adf5f0d6bba3
          e6094b2d298e71ab08828b880a01b"
    }
  }
}</pre>
<p>Let’s explore the <a id="_idIndexMarker451"/>Docker directories that host the image files further. We can get the image information using the <span class="No-Break">following command:</span></p>
<pre class="console">
docker images</pre>
<p>The following output shows some information about the <span class="No-Break"><strong class="source-inline">hello-world</strong></span><span class="No-Break"> container:</span></p>
<pre class="console">
REPOSITORY    TAG       IMAGE ID           CREATED           SIZE
..
hello-world      latest    feb5d9fea6a5   7 months ago   13.3kB
..</pre>
<p>The image ID for <strong class="source-inline">hello-world</strong> is <strong class="source-inline">feb5d9fea6a5</strong>. Let's try to find the image file inside <strong class="source-inline">/var/lib/docker</strong> using the <span class="No-Break">following command:</span></p>
<pre class="console">
sudo find /var/lib/docker -name 'feb5d9fea6a5*'</pre>
<p>We will get the <span class="No-Break">following output:</span></p>
<pre class="console">
/var/lib/docker/image/overlay2/imagedb/content/sha256/feb5d9fea 6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412</pre>
<p>Let's now look <a id="_idIndexMarker452"/>inside that file using the <span class="No-Break">following command:</span></p>
<pre class="console">
sudo cat /var/lib/docker/image/overlay2/imagedb/content/sha256/feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412</pre>
<p>You will see the <span class="No-Break">following output:</span></p>
<pre class="console">
{
  "architecture": "amd64",
  "config": {
    …
    ],
        …
  },
      …
    "Cmd": [
      "/bin/sh",
      "-c",
      "#(nop) ",
      "CMD [\"/hello\"]"
    ],
    "Image": "sha256:b9935d4e8431fb1a7f0989304ec8
              6b3329a99a25f5efdc7f09f3f8c41434ca6d",
    "Volumes": null,
    "WorkingDir": "",
    "Entrypoint": null,
    "OnBuild": null,
    "Labels": {}
  },
  "created": "2021-09-23T23:47:57.442225064Z",
  "docker_version": "20.10.7",
  "history": [
    {
       …
  ],
  "os": "linux",
  "rootfs": {
    "type": "layers",
    "diff_ids": [
      "sha256:e07ee1baac5fae6a26f30cabfe54a36d3402f96afda3
              18fe0a96cec4ca393359"
    ]
  }
}</pre>
<p>The following <a id="_idIndexMarker453"/>table outlines the meanings of some relevant fields from the preceding <span class="No-Break">JSON output:</span></p>
<table class="No-Table-Style" id="table001-6">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Field Name</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Cmd</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This is the command that will be executed when the image file is run as a container. For the <strong class="source-inline">hello-world</strong> example, it will execute the <strong class="source-inline">hello</strong> executable when the container <span class="No-Break">is launched.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">rootfs</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">rootfs</strong> stands for <em class="italic">root filesystem</em>, which means it contains all the necessary operating system files that are required to start itself as a <span class="No-Break">normal machine.</span></p>
</td>
</tr>
</tbody>
</table>
<p>The JSON information we saw previously can also be viewed using the <span class="No-Break">following command:</span></p>
<pre class="console">
docker image inspect hello-world:latest</pre>
<p>You will get output that looks <span class="No-Break">as follows:</span></p>
<pre class="console">
[
    {
        "Id": "sha256:feb5d9fea6a5e9606aa995e879d862b825
               965ba48de054caab5ef356dc6b3412",
        "RepoTags": [
            "hello-world:latest"
        ],
        "RepoDigests": [
            "hello-world@sha256:10d7d58d5ebd2a652
           f4d93fdd86da8f265f5318c6a73cc5b6a9798ff6d2b2e67"
        ],
        "Parent": "",
        "Comment": "",
        "Created": "2021-09-23T23:47:57.442225064Z",
        "Container": "8746661ca3c2f215da94e6d3f7dfdcafaff5
                      ec0b21c9aff6af3dc379a82fbc72",
        "ContainerConfig": {
            …
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) ",
                "CMD [\"/hello\"]"
            ],
            "Image": "sha256:b9935d4e8431fb1a7f0989304ec86b
                      3329a99a25f5efdc7f09f3f8c41434ca6d",
            …
        },
      …
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 13256,
        "VirtualSize": 13256,
        "GraphDriver": {
            "Data": {
                "MergedDir":
                  "/var/lib/docker/overlay2/c0d9b295437ab
                   cdeb9caeec51dcbde1b11b0aeb3dd9e469f35
                   7889defed757d9/merged",
                "UpperDir":
                  "/var/lib/docker/overlay2/c0d9b295437ab
                   cdeb9caeec51dcbde1b11b0aeb3dd9e469f357
                   889defed757d9/diff",
                "WorkDir":
                  "/var/lib/docker/overlay2/c0d9b295437ab
                   cdeb9caeec51dcbde1b11b0aeb3dd9e469f357
                   889defed757d9/work"
            },
            "Name": "overlay2"
        },
                    …]</pre>
<p>One of the interesting pieces of information in the output is the <strong class="source-inline">GraphDriver</strong> field that points to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">/var/lib/docker/overlay2/c0d9b295437abcdeb9caeec51dcbde1b11b</strong></span><strong class="source-inline">
0aeb3dd9e469f357889defed757d9</strong> directory containing the extracted Docker image. For hello-world, it will be the <strong class="source-inline">hello</strong> executable file, as <span class="No-Break">shown next:</span></p>
<pre class="console">
total 16
drwx--x---  3 root root 4096 Apr 30 18:36 ./
drwx--x--- 30 root root 4096 Apr 30 19:21 ../
-rw-------  1 root root    0 Apr 30 19:21 committed
drwxr-xr-x  2 root root 4096 Apr 30 18:36 diff/
-rw-r--r--  1 root root   26 Apr 30 18:36 link</pre>
<p>Taking a look inside the <strong class="source-inline">diff/</strong> directory, we see the following <span class="No-Break">executable file:</span></p>
<pre class="console">
drwxr-xr-x 2 root root  4096 Apr 30 18:36 .
drwx--x--- 3 root root  4096 Apr 30 18:36 ..
-rwxrwxr-x 1 root root 13256 Sep 24  2021 hello</pre>
<p>Now that we have a good understanding of how Docker images are stored locally, in the next section, we will look at using Docker to run the image locally as <span class="No-Break">a container.</span><a id="_idTextAnchor269"/></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor270"/>Running images as containers</h1>
<p>In this section, we will look at running Docker images as containers and examine the different <a id="_idIndexMarker454"/>information that we can see when a <a id="_idIndexMarker455"/>container <span class="No-Break">is running.</span></p>
<p>Start by running a database Docker image and look at what information we can get about the state of the container. Open the terminal window and run the following command to run Redis locally. Redis is an open source memory-based data store used to store data. Since data is stored in memory, it is fast compared to storing on disk. The command will run Redis, listening on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">7777</strong></span><span class="No-Break">:</span></p>
<pre class="console">
docker run -p 7777:7777  -v /home/user/Downloads/redis-7.0-rc3/data:/data redis --port 7777</pre>
<p>Make sure you change the <strong class="source-inline">/home/user/Downloads/redis-7.0-rc3/data</strong> directory to your own local directory, as Docker will use this to store the Redis <span class="No-Break">data file.</span></p>
<p>You will see the <a id="_idIndexMarker456"/>following message when the container <a id="_idIndexMarker457"/>is up <span class="No-Break">and running:</span></p>
<pre class="console">
1:C 05 May 2022 11:20:08.723 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
1:C 05 May 2022 11:20:08.723 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started
1:C 05 May 2022 11:20:08.723 # Configuration loaded
1:M 05 May 2022 11:20:08.724 * monotonic clock: POSIX clock_gettime
1:M 05 May 2022 11:20:08.724 * Running mode=standalone, port=7777.
…
1:M 05 May 2022 11:20:08.724 * Ready to accept connections</pre>
<p>Let’s use the Docker command-line tool to look at the running state of this container. In order to do that, we need to get the ID of the container by running the <strong class="source-inline">docker ps</strong> command; in our case, the output looks <span class="No-Break">as follows:</span></p>
<pre class="console">
CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS                                                 NAMES
e1f58f395d06   redis      "docker-entrypoint.s…"   5 minutes ago   Up 5 minutes   6379/tcp, 0.0.0.0:7777-&gt;7777/tcp, :::7777-&gt;7777/tcp   reverent_dhawan</pre>
<p>The Redis container ID is <strong class="source-inline">e1f58f395d06</strong>. Using this information, we will use <strong class="source-inline">docker inspect</strong> to look at the different properties of the running container. Use <strong class="source-inline">docker inspect</strong> <span class="No-Break">as follows:</span></p>
<pre class="console">
docker inspect e1f58f395d06</pre>
<p>You will get<a id="_idIndexMarker458"/> output that <a id="_idIndexMarker459"/>looks like <span class="No-Break">the following:</span></p>
<pre class="console">
[[
    {
        ...
        "Mounts": [
            {
                "Type": "bind",
                "Source": "/home/user/Downloads/redis-7.0-
                           rc3/data",
                "Destination": "/data",
                "Mode": "",
                "RW": true,
                "Propagation": "rprivate"
            }
        ],
        "Config": {
            ...
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:
                      /usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.14",
                ...
            ],
            ...
        },
        "NetworkSettings": {
            ...
            "Ports": {
                "6379/tcp": null,
                "7777/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "7777"
                    },
                    {
                        "HostIp": "::",
                        "HostPort": "7777"
                    }
                ]
            },
            ...
            "Networks": {
                "bridge": {
                    ...
                }
            }
        }
    }
]</pre>
<p>The output shows a lot of information about the running state of the Redis container. The main things that we are interested in are the network and the mount. The <strong class="source-inline">NetworkSettings</strong> section shows the network configuration of the container, indicating the network mapping parameter of the host to the container – the container is using port <strong class="source-inline">7777</strong>, and the same port is exposed on the <span class="No-Break">local machine.</span></p>
<p>The other interesting thing is the <strong class="source-inline">Mounts</strong> parameter, which points to the mapping of <strong class="source-inline">/home/user/Downloads/redis-7.0-rc3/data</strong> to the <strong class="source-inline">/data</strong> local host directory inside the container. The mount is like a redirection from the container directory to the local machine directory. Using the mount ensures that all data is saved to <a id="_idIndexMarker460"/>the local machine when the container <a id="_idIndexMarker461"/><span class="No-Break">shuts down.</span></p>
<p>We have seen what a container is all about and how to look at the running state of the container. Now that we have a good understanding of images and containers, we will look at creating our own image in the <span class="No-Break">next <a id="_idTextAnchor271"/>section.</span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor272"/>Building and packaging images</h1>
<p>In the previous section, we learned about Docker images and how to look at the state of a running container; we also looked at how Docker images are stored locally. In this section, we will look at how to create our own Docker image by writing <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Do<a id="_idTextAnchor273"/>ckerfile</strong></span><span class="No-Break">.</span></p>
<p>We will<a id="_idIndexMarker462"/> look at building the sample application inside the <strong class="source-inline">chapter13/embed</strong> folder. The sample application is the same one we discussed in <a href="B18295_04.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic">, Serving and Embedding HTML Content</em>. The application will run an HTTP server listening on port <strong class="source-inline">3333</strong> to serve an embedded <span class="No-Break">HTML page.</span></p>
<p>The <strong class="source-inline">Dockerfile</strong> that we will use to build the Docker image looks <span class="No-Break">as follows:</span></p>
<pre class="console">
# 1. Compile the app.
FROM golang:1.18  as builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -o bin/embed
# 2. Create final environment for the compiled binary.
FROM alpine:latest
RUN apk --update upgrade &amp;&amp; apk --no-cache add curl ca-certificates &amp;&amp; rm -rf /var/cache/apk/*
RUN mkdir -p /app
# 3. Copy the binary from step 1 and set it as the default command.
COPY --from=builder /app/bin/embed /app
WORKDIR /app
CMD /app/embed</pre>
<p>Let’s step<a id="_idIndexMarker463"/> through the different parts of the command to understand what it is doing. The first step is to compile the application by using a pre-built Golang 1.18 Docker image. This image contains all the necessary tools to build a Go application. We specify <strong class="source-inline">/app</strong> as the working directory using the <strong class="source-inline">WORKDIR</strong> command, and in the last line we copy all the source files using the <strong class="source-inline">COPY</strong> command and compile the source code using the standard <strong class="source-inline">go build</strong> <span class="No-Break">command line.</span></p>
<pre class="console">
FROM golang:1.18  as builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -o bin/embed</pre>
<p>After<a id="_idIndexMarker464"/> successfully compiling the application, the next step is to prepare the runtime environment that will host the application. In this case, we are using a pre-built Docker image of the Alpine Linux operating system. Alpine is a Linux distribution that is small in terms of size, which makes it ideal when creating Docker images for applications to <span class="No-Break">run on.</span></p>
<p>The next thing we want to do is to make sure the operating system is up to date by using the - <strong class="source-inline">update upgrade</strong> command. This ensures that the operating system contains all the latest updates, including security updates. The last step is to create a new <strong class="source-inline">/app</strong> directory that will store the <span class="No-Break">application binary:</span></p>
<pre class="console">
FROM alpine:latest
RUN apk --update upgrade &amp;&amp; apk --no-cache add curl ca-certificates &amp;&amp; rm -rf /var/cache/apk/*
RUN mkdir -p /app</pre>
<p>The final step is to copy over the binary from the previous step, which we have labeled as <strong class="source-inline">builder</strong>, into the new <strong class="source-inline">/app</strong> directory. The <strong class="source-inline">CMD</strong> command specifies the command that will be run when the Docker image is executed as a container – in this case, we want to run our sample application <strong class="source-inline">embed</strong> specified by the <span class="No-Break">parameter</span><span class="No-Break"><em class="italic"> </em></span><span class="No-Break"><strong class="source-inline">/app/embed</strong></span><span class="No-Break">:</span></p>
<pre class="console">
COPY --from=builder /app/bin/embed /app
WORKDIR /app
CMD /app/embed</pre>
<p>Now we have gone through what the <strong class="source-inline">Dockerfile</strong> is doing, let’s create the Docker image. Use the following command to build <span class="No-Break">the image:</span></p>
<pre class="console">
docker build  --tag chapter13 .</pre>
<p>You will see an output that looks like the following, showing the different steps and processes Docker is doing to build <span class="No-Break">the image:</span></p>
<pre class="console">
Sending build context to Docker daemon   29.7kB
Step 1/10 : FROM golang:1.18  as builder
 ---&gt; 65b2f1fa535f
Step 2/10 : WORKDIR /app
 ---&gt; Using cache
 ---&gt; 7ab996f8148c
…
Step 5/10 : FROM alpine:latest
 ---&gt; 0ac33e5f5afa
…
Step 8/10 : COPY --from=builder /app/bin/embed /app
…
Step 10/10 : CMD /app/embed
 ---&gt; Using cache
 ---&gt; ade99a01b92e
Successfully built ade99a01b92e
Successfully tagged chapter13:latest</pre>
<p>Once you <a id="_idIndexMarker465"/>get the <strong class="source-inline">Successfully tagged</strong> message, the building process is complete, and the image is ready on your <span class="No-Break">local machine.</span></p>
<p>The new image will be labeled <strong class="source-inline">chapter13</strong> and will look as follows when we use the <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">images</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
REPOSITORY    TAG           IMAGE ID       CREATED             SIZE
…
chapter13     latest        ade99a01b92e   33 minutes ago      16.9MB
…
golang        1.18          65b2f1fa535f   14 hours ago        964MB
…
hello-world   latest        feb5d9fea6a5   7 months ago        13.3kB</pre>
<p>Run the newly <a id="_idIndexMarker466"/>created image using the <span class="No-Break">following command:</span></p>
<pre class="console">
docker  run -p 3333:3333 chapter13</pre>
<p>The <a id="_idIndexMarker467"/>command will run the image as a container, and using the <strong class="source-inline">-p</strong> port parameter, it exposes port <strong class="source-inline">3333</strong> inside the container to the same port <strong class="source-inline">3333</strong> on the host. Open your browser and type in <strong class="source-inline">http://localhost:3333</strong> and you will see the HTML login page, as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<img alt="Figure 13.2: Web application served from a Docker container" height="214" src="image/Figure_13.02_B18295.jpg" width="251"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: Web application served from a Doc<a id="_idTextAnchor274"/>ker container</p>
<p>In the next section, we’ll understand about <span class="No-Break">Docker Compose.</span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor275"/>Docker Compose</h1>
<p>Docker provides another tool called<a id="_idIndexMarker468"/> Docker Compose, allowing developers to run multiple containers simultaneously. Think about use cases where you are building a server that requires temporary memory storage to store cart information; this requires using an external application such as Redis, which provides an <span class="No-Break">in-memory database.</span></p>
<p>In this kind of scenario, our application depends on Redis to function properly, which means that we need to run Redis at the same time we run our application. There are many other different kinds of use cases where there will be a need to use Docker Compose. The Docker Compose documentation provides a complete step-by-step guide on how to install it on your local <span class="No-Break">machine: </span><a href="https://docs.docker.com/compose/install/"><span class="No-Break">https://docs.docker.com/compose/install/</span></a><span class="No-Break">.</span></p>
<p>Docker Compose is <a id="_idIndexMarker469"/>actually a file that outlines the different containers we want to use. Let’s try to run the sample Docker Compose file that is inside the <strong class="source-inline">chapter13/embed</strong> folder. Open the terminal and make sure you are inside the <strong class="source-inline">chapter13/embed</strong> folder, then execute the <span class="No-Break">following command:</span></p>
<pre class="console">
docker compose -f compose.yaml up</pre>
<p>You will get the <span class="No-Break">following output:</span></p>
<pre class="console">
[+] Running 7/7
   ⠿ cache Pulled 11.6s
   ⠿ 213ec9aee27d Already exists  0.0s
   ⠿ c99be1b28c7f Pull complete    1.4s
   ⠿ 8ff0bb7e55e3 Pull complete   1.8s
   ⠿ 477c33011f3e Pull complete   4.8s
   ⠿ 2bbc51a93257 Pull complete   4.8s
   ⠿ 2d27eae19281 Pull complete   4.9s
[+] Building 7.3s (15/15) FINISHED
 =&gt; [internal] load build definition from Dockerfile    0.0s
 =&gt; =&gt; transferring dockerfile: 491B                    0.0s
 =&gt; [internal] load .dockerignore                       0.0s
 =&gt; =&gt; transferring context: 2B                         0.0s
 =&gt; [internal] load metadata for docker.io/library/alpine:latest 0.0s
 =&gt; [internal] load metadata for docker.io/library/golang:1.18   0.0s
 =&gt; [builder 1/4] FROM docker.io/library/golang:1.18             0.3s
 =&gt; [stage-1 1/5] FROM docker.io/library/alpine:latest           0.1s
 =&gt; [internal] load build context                                0.2s
 =&gt; =&gt; transferring context: 18.81kB                             0.0s
 =&gt; [stage-1 2/5] RUN apk --update upgrade &amp;&amp; apk --no-cache add curl ca-certificates &amp;&amp; rm -rf /var/cache/apk/*   5.5s
 =&gt; [builder 2/4] WORKDIR /app  0.2s
 =&gt; [builder 3/4] COPY . .   0.1s
 =&gt; [builder 4/4] RUN CGO_ENABLED=0 GOOS=linux go build -a -o bin/embed 6.4s
 =&gt; [stage-1 3/5] RUN mkdir -p /app  1.4s
 =&gt; [stage-1 4/5] COPY --from=builder /app/bin/embed /app  0.1s
 =&gt; [stage-1 5/5] WORKDIR /app  0.0s
 =&gt; exporting to image  0.1s
 =&gt; =&gt; exporting layers  0.1s
 =&gt; =&gt; writing image sha256:84621b13c179c03eed57a23c66974659eae 4b50c97e3f8af13de99db1adf4c06  0.0s
 =&gt; =&gt; naming to docker.io/library/embed-server  0.0s
[+] Running 3/3
 ⠿ Network embed_default     Created 0.1s
 ⠿ Container embed-cache-1   Created 0.1s
 ⠿ Container embed-server-1  Created 0.1s
Attaching to embed-cache-1, embed-server-1
embed-server-1  | 2022/09/10 06:24:30 Server Version : 0.0.1
embed-cache-1   | 1:C 10 Sep 2022 06:24:30.898 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
embed-cache-1   | 1:C 10 Sep 2022 06:24:30.898 # Redis version=7.0.4, bits=64, commit=00000000, modified=0, pid=1, just started
...
embed-cache-1   | 1:M 10 Sep 2022 06:24:30.899 * Running mode=standalone, port=6379.
embed-cache-1   | 1:M 10 Sep 2022 06:24:30.899 # Server initialized
...
embed-cache-1   | 1:M 10 Sep 2022 06:24:30.899 * Loading RDB produced by version 6.2.7
embed-cache-1   | 1:M 10 Sep 2022 06:24:30.899 * RDB age 10 seconds
...
embed-cache-1   | 1:M 10 Sep 2022 06:24:30.899 * Ready to accept connections</pre>
<p>Once<a id="_idIndexMarker470"/> everything is running, you should be able to access the server by opening your browser and typing <strong class="source-inline">http://localhost:3333</strong> in the <span class="No-Break">address bar.</span></p>
<p>The Docker Compose file looks <span class="No-Break">as follows:</span></p>
<pre class="console">
version: '3'
services:
 server:
   build: .
   ports:
     - "3333:3333"
 cache:z
   image: redis:7.0.4-alpine
   restart: always
   ports:
     - '6379:6379'</pre>
<p>The file <a id="_idIndexMarker471"/>outlines two containers that need to be run – the server is pointing to our application server, and the <strong class="source-inline">build</strong> parameter uses the <strong class="source-inline">.</strong> dot notation. This tells Docker Compose that the source (Dockerfile) to build the image for this container is found in the local directory, while the cache service is a Redis server, and it will be pulled from the Docker remote registry, specifical<a id="_idTextAnchor276"/>ly <span class="No-Break">version 7.0.4.</span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor277"/>Summary</h1>
<p>In this chapter, we learned about what Docker is and how to use it. Building applications is one part of the puzzle, but packaging them to be deployed in a cloud environment requires developers to understand Docker and how to build Docker images for their applications. We looked at how Docker stores images on your local machine and also inspected the state of the <span class="No-Break">running container.</span></p>
<p>We learned that when containers are running, there is a lot of information generated that can help us to understand what’s going on with the container and also the parameters used to run our application. We also learned about the <strong class="source-inline">Dockerfile</strong> and used it to package our sample application into a container to run it as a single <span class="No-Break">Docker image.</span></p>
<p>In the next chapter, we will use the knowledge we gained in this chapter by deploying our images to a <span class="No-Break">cloud environment.</span></p>
</div>
</div></body></html>