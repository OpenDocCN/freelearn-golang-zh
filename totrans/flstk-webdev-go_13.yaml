- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dockerizing an Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about Docker and how to package applications
    as Docker images. Understanding how to package your application as a Docker image
    will allow you to deploy the application in any kind of environment and infrastructure
    without having to worry about setting up the infrastructure to build your application.
    Building a Docker image will allow you to run your application anywhere you like:
    build once and deploy anywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Docker image from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Docker image filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is an open source platform that is used for software development, making
    it easy to package and ship programs. Docker enables you to package your application
    and run it in different kinds of infrastructure such as cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at installing Docker on a local machine. Different
    operating systems have different steps for installing it. Refer to the Docker
    documentation for an in-depth installation guide relevant to your operating system,
    which can be found at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was written on a Linux machine, so most of the command-line applications
    that are outlined are only available for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: After taking the steps to install Docker on our development machine, the following
    are some of the things we do to ensure that everything is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following commands to check that the Docker engine is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output if the engine has been installed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output shows two different services running – `docker.service` and `containerd.service`.
    The `containerd.service` service takes care of launching the Docker image into
    a container and ensuring that all the local machine services are set up to allow
    the container to run while the `docker.service` service takes care of the management
    of the image and communication with the Docker command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know both services are running, let’s use the command-line tools
    to check the communication with the engine. Use the following command to communicate
    with the engine to list all the locally available images – note you may need to
    have root privileges to do this so prefixing with `sudo` might be required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we get the output as shown in *Figure 13**.1*, showing we have
    downloaded two images. In your case, if this is your first time installing Docker,
    it will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Docker images on a local machine](img/Figure_13.01_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Docker images on a local machine'
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully completed the Docker installation on the local machine.
    In the next section, we will go into more detail about using Docker and understanding
    Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to use Docker for day-to-day operations.
    Let’s understand the concepts that are talked about when using Docker – images
    and the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker image**: This image is a file that contains our application, including
    all the relevant operating system files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: The image file is read and executed by the Docker engine. Once
    it runs on the local machine it is called a container. You can interact with the
    container using the Docker command-line tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will look at using Docker to download and run a simple *Hello World* application
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open your terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will download the image file (if none exists locally) and execute
    it. You will then see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image has been downloaded and run as a container, it will print out
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have had a taste of how to run an image file as a container, we
    will explore Docker images more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker image files look like any other file on your local machine, except they
    are stored in a special format that can only be understood by Docker. Locally
    the image files are stored inside the `/var/lib/docker/image/overlay2` directory.
    To see what images are available, you can take a look at the `repositories.json`
    file, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explore the Docker directories that host the image files further. We
    can get the image information using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows some information about the `hello-world` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The image ID for `hello-world` is `feb5d9fea6a5`. Let''s try to find the image
    file inside `/var/lib/docker` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look inside that file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table outlines the meanings of some relevant fields from the
    preceding JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Cmd` | This is the command that will be executed when the image file is
    run as a container. For the `hello-world` example, it will execute the `hello`
    executable when the container is launched. |'
  prefs: []
  type: TYPE_TB
- en: '| `rootfs` | `rootfs` stands for *root filesystem*, which means it contains
    all the necessary operating system files that are required to start itself as
    a normal machine. |'
  prefs: []
  type: TYPE_TB
- en: 'The JSON information we saw previously can also be viewed using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get output that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the interesting pieces of information in the output is the `GraphDriver`
    field that points to the `/var/lib/docker/overlay2/c0d9b295437abcdeb9caeec51dcbde1b11b`
    **0aeb3dd9e469f357889defed757d9** directory containing the extracted Docker image.
    For hello-world, it will be the `hello` executable file, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking a look inside the `diff/` directory, we see the following executable
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a good understanding of how Docker images are stored locally,
    in the next section, we will look at using Docker to run the image locally as
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: Running images as containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at running Docker images as containers and examine
    the different information that we can see when a container is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by running a database Docker image and look at what information we can
    get about the state of the container. Open the terminal window and run the following
    command to run Redis locally. Redis is an open source memory-based data store
    used to store data. Since data is stored in memory, it is fast compared to storing
    on disk. The command will run Redis, listening on port `7777`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you change the `/home/user/Downloads/redis-7.0-rc3/data` directory
    to your own local directory, as Docker will use this to store the Redis data file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following message when the container is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use the Docker command-line tool to look at the running state of this
    container. In order to do that, we need to get the ID of the container by running
    the `docker ps` command; in our case, the output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Redis container ID is `e1f58f395d06`. Using this information, we will use
    `docker inspect` to look at the different properties of the running container.
    Use `docker inspect` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get output that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output shows a lot of information about the running state of the Redis container.
    The main things that we are interested in are the network and the mount. The `NetworkSettings`
    section shows the network configuration of the container, indicating the network
    mapping parameter of the host to the container – the container is using port `7777`,
    and the same port is exposed on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: The other interesting thing is the `Mounts` parameter, which points to the mapping
    of `/home/user/Downloads/redis-7.0-rc3/data` to the `/data` local host directory
    inside the container. The mount is like a redirection from the container directory
    to the local machine directory. Using the mount ensures that all data is saved
    to the local machine when the container shuts down.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen what a container is all about and how to look at the running state
    of the container. Now that we have a good understanding of images and containers,
    we will look at creating our own image in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building and packaging images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned about Docker images and how to look at the
    state of a running container; we also looked at how Docker images are stored locally.
    In this section, we will look at how to create our own Docker image by writing
    a `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at building the sample application inside the `chapter13/embed`
    folder. The sample application is the same one we discussed in [*Chapter 4*](B18295_04.xhtml#_idTextAnchor053)*,
    Serving and Embedding HTML Content*. The application will run an HTTP server listening
    on port `3333` to serve an embedded HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dockerfile` that we will use to build the Docker image looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let’s step through the different parts of the command to understand what it
    is doing. The first step is to compile the application by using a pre-built Golang
    1.18 Docker image. This image contains all the necessary tools to build a Go application.
    We specify `/app` as the working directory using the `WORKDIR` command, and in
    the last line we copy all the source files using the `COPY` command and compile
    the source code using the standard `go build` command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After successfully compiling the application, the next step is to prepare the
    runtime environment that will host the application. In this case, we are using
    a pre-built Docker image of the Alpine Linux operating system. Alpine is a Linux
    distribution that is small in terms of size, which makes it ideal when creating
    Docker images for applications to run on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we want to do is to make sure the operating system is up to
    date by using the - `update upgrade` command. This ensures that the operating
    system contains all the latest updates, including security updates. The last step
    is to create a new `/app` directory that will store the application binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to copy over the binary from the previous step, which we
    have labeled as `builder`, into the new `/app` directory. The `CMD` command specifies
    the command that will be run when the Docker image is executed as a container
    – in this case, we want to run our sample application `embed` specified by the
    parameter`/app/embed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have gone through what the `Dockerfile` is doing, let’s create the Docker
    image. Use the following command to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output that looks like the following, showing the different
    steps and processes Docker is doing to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Once you get the `Successfully tagged` message, the building process is complete,
    and the image is ready on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new image will be labeled `chapter13` and will look as follows when we
    use the `docker` `images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the newly created image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will run the image as a container, and using the `-p` port parameter,
    it exposes port `3333` inside the container to the same port `3333` on the host.
    Open your browser and type in `http://localhost:3333` and you will see the HTML
    login page, as shown in *Figure 13**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: Web application served from a Docker container](img/Figure_13.02_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Web application served from a Docker container'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll understand about Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker provides another tool called Docker Compose, allowing developers to run
    multiple containers simultaneously. Think about use cases where you are building
    a server that requires temporary memory storage to store cart information; this
    requires using an external application such as Redis, which provides an in-memory
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this kind of scenario, our application depends on Redis to function properly,
    which means that we need to run Redis at the same time we run our application.
    There are many other different kinds of use cases where there will be a need to
    use Docker Compose. The Docker Compose documentation provides a complete step-by-step
    guide on how to install it on your local machine: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Compose is actually a file that outlines the different containers we
    want to use. Let’s try to run the sample Docker Compose file that is inside the
    `chapter13/embed` folder. Open the terminal and make sure you are inside the `chapter13/embed`
    folder, then execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once everything is running, you should be able to access the server by opening
    your browser and typing `http://localhost:3333` in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Compose file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The file outlines two containers that need to be run – the server is pointing
    to our application server, and the `build` parameter uses the `.` dot notation.
    This tells Docker Compose that the source (Dockerfile) to build the image for
    this container is found in the local directory, while the cache service is a Redis
    server, and it will be pulled from the Docker remote registry, specifically version
    7.0.4.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about what Docker is and how to use it. Building
    applications is one part of the puzzle, but packaging them to be deployed in a
    cloud environment requires developers to understand Docker and how to build Docker
    images for their applications. We looked at how Docker stores images on your local
    machine and also inspected the state of the running container.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that when containers are running, there is a lot of information generated
    that can help us to understand what’s going on with the container and also the
    parameters used to run our application. We also learned about the `Dockerfile`
    and used it to package our sample application into a container to run it as a
    single Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the knowledge we gained in this chapter by
    deploying our images to a cloud environment.
  prefs: []
  type: TYPE_NORMAL
