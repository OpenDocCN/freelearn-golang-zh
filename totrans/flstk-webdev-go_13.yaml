- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Dockerizing an Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序 Docker 化
- en: 'In this chapter, we will learn about Docker and how to package applications
    as Docker images. Understanding how to package your application as a Docker image
    will allow you to deploy the application in any kind of environment and infrastructure
    without having to worry about setting up the infrastructure to build your application.
    Building a Docker image will allow you to run your application anywhere you like:
    build once and deploy anywhere.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Docker 以及如何将应用程序打包为 Docker 镜像。了解如何将您的应用程序打包为 Docker 镜像将允许您在任何类型的环境和基础设施中部署应用程序，而无需担心设置构建应用程序的基础设施。构建
    Docker 镜像将允许您在任何您喜欢的地方运行您的应用程序：构建一次，部署到任何地方。
- en: 'In this chapter, we will learn about the following key topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下关键主题：
- en: Building a Docker image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Running a Docker image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Docker 镜像
- en: Creating a Docker image from scratch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建 Docker 镜像
- en: Understanding the Docker image filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker 镜像文件系统
- en: Looking at Docker Compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 Docker Compose
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter13)中查看。
- en: Installing Docker
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Docker is an open source platform that is used for software development, making
    it easy to package and ship programs. Docker enables you to package your application
    and run it in different kinds of infrastructure such as cloud environments.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个开源平台，用于软件开发，它使得打包和分发程序变得容易。Docker 允许您打包您的应用程序并在不同类型的基础设施（如云环境）中运行。
- en: In this section, we will look at installing Docker on a local machine. Different
    operating systems have different steps for installing it. Refer to the Docker
    documentation for an in-depth installation guide relevant to your operating system,
    which can be found at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看如何在本地机器上安装 Docker。不同的操作系统安装 Docker 的步骤不同。请参考 Docker 文档以获取适用于您操作系统的深入安装指南，该指南可在[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)找到。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter was written on a Linux machine, so most of the command-line applications
    that are outlined are only available for Linux.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是在 Linux 机器上编写的，因此概述的大多数命令行应用程序仅适用于 Linux。
- en: After taking the steps to install Docker on our development machine, the following
    are some of the things we do to ensure that everything is working fine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的开发机器上安装 Docker 的步骤完成后，以下是一些确保一切正常工作的操作。
- en: 'Use the following commands to check that the Docker engine is running:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来检查 Docker 引擎是否正在运行：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will see the following output if the engine has been installed correctly:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引擎已正确安装，您将看到以下输出：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output shows two different services running – `docker.service` and `containerd.service`.
    The `containerd.service` service takes care of launching the Docker image into
    a container and ensuring that all the local machine services are set up to allow
    the container to run while the `docker.service` service takes care of the management
    of the image and communication with the Docker command-line tools.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了两个不同的服务正在运行 - `docker.service` 和 `containerd.service`。`containerd.service`
    服务负责将 Docker 镜像启动到容器中，并确保所有本地机器服务都已设置，以便容器可以在 `docker.service` 服务管理镜像和与 Docker
    命令行工具通信的同时运行。
- en: 'Now that we know both services are running, let’s use the command-line tools
    to check the communication with the engine. Use the following command to communicate
    with the engine to list all the locally available images – note you may need to
    have root privileges to do this so prefixing with `sudo` might be required:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道这两个服务都在运行，让我们使用命令行工具来检查与引擎的通信。使用以下命令与引擎通信以列出所有本地可用的镜像 - 注意您可能需要具有 root
    权限才能执行此操作，因此可能需要使用 `sudo` 前缀：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our case, we get the output as shown in *Figure 13**.1*, showing we have
    downloaded two images. In your case, if this is your first time installing Docker,
    it will be empty.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们得到如图 *图 13.1* 所示的输出，显示我们已下载了两个镜像。在您的情况下，如果您是第一次安装 Docker，它将是空的。
- en: '![Figure 13.1: Docker images on a local machine](img/Figure_13.01_B18295.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：本地机器上的 Docker 镜像](img/Figure_13.01_B18295.jpg)'
- en: 'Figure 13.1: Docker images on a local machine'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：本地机器上的Docker镜像
- en: We have successfully completed the Docker installation on the local machine.
    In the next section, we will go into more detail about using Docker and understanding
    Docker images.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本地机器上成功完成了Docker的安装。在下一节中，我们将更详细地介绍如何使用Docker以及理解Docker镜像。
- en: Using Docker
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker
- en: 'In this section, we will look at how to use Docker for day-to-day operations.
    Let’s understand the concepts that are talked about when using Docker – images
    and the container:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用Docker进行日常操作。让我们了解使用Docker时提到的概念——镜像和容器：
- en: '**Docker image**: This image is a file that contains our application, including
    all the relevant operating system files.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：此镜像是一个包含我们的应用程序的文件，包括所有相关的操作系统文件。'
- en: '**Container**: The image file is read and executed by the Docker engine. Once
    it runs on the local machine it is called a container. You can interact with the
    container using the Docker command-line tools.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：镜像文件被Docker引擎读取和执行。一旦它在本地机器上运行，它就被称为容器。您可以使用Docker命令行工具与容器交互。'
- en: 'We will look at using Docker to download and run a simple *Hello World* application
    using the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令查看如何使用Docker下载和运行一个简单的*Hello World*应用程序：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open your terminal and run the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的终端并运行以下命令：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command will download the image file (if none exists locally) and execute
    it. You will then see the following message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载镜像文件（如果本地不存在）并执行它。然后您将看到以下消息：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the image has been downloaded and run as a container, it will print out
    the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像被下载并作为容器运行，它将输出以下内容：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have had a taste of how to run an image file as a container, we
    will explore Docker images more in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试了如何将镜像文件作为容器运行，我们将在下一节中更深入地探索Docker镜像。
- en: Docker images
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker镜像
- en: 'Docker image files look like any other file on your local machine, except they
    are stored in a special format that can only be understood by Docker. Locally
    the image files are stored inside the `/var/lib/docker/image/overlay2` directory.
    To see what images are available, you can take a look at the `repositories.json`
    file, which looks as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像文件看起来就像您本地机器上的任何其他文件一样，但它们以Docker才能理解的特殊格式存储。在本地，镜像文件存储在`/var/lib/docker/image/overlay2`目录中。要查看可用的镜像，您可以查看`repositories.json`文件，其外观如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s explore the Docker directories that host the image files further. We
    can get the image information using the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探索托管镜像文件的Docker目录。我们可以使用以下命令获取镜像信息：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following output shows some information about the `hello-world` container:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了有关`hello-world`容器的某些信息：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The image ID for `hello-world` is `feb5d9fea6a5`. Let''s try to find the image
    file inside `/var/lib/docker` using the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello-world`的镜像ID是`feb5d9fea6a5`。让我们尝试使用以下命令在`/var/lib/docker`中找到镜像文件：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will get the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now look inside that file using the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用以下命令查看该文件内部：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following table outlines the meanings of some relevant fields from the
    preceding JSON output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下表概述了前一个JSON输出中一些相关字段的意义：
- en: '| **Field Name** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **字段名称** | **描述** |'
- en: '| `Cmd` | This is the command that will be executed when the image file is
    run as a container. For the `hello-world` example, it will execute the `hello`
    executable when the container is launched. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Cmd` | 这是在镜像文件作为容器运行时将要执行的命令。对于`hello-world`示例，当容器启动时，它将执行`hello`可执行文件。|'
- en: '| `rootfs` | `rootfs` stands for *root filesystem*, which means it contains
    all the necessary operating system files that are required to start itself as
    a normal machine. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `rootfs` | `rootfs`代表*根文件系统*，这意味着它包含所有必要的操作系统文件，这些文件是作为正常机器启动所必需的。|'
- en: 'The JSON information we saw previously can also be viewed using the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的JSON信息也可以使用以下命令查看：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will get output that looks as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到如下所示输出：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One of the interesting pieces of information in the output is the `GraphDriver`
    field that points to the `/var/lib/docker/overlay2/c0d9b295437abcdeb9caeec51dcbde1b11b`
    **0aeb3dd9e469f357889defed757d9** directory containing the extracted Docker image.
    For hello-world, it will be the `hello` executable file, as shown next:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中一个有趣的信息片段是`GraphDriver`字段，它指向包含提取的Docker镜像的`/var/lib/docker/overlay2/c0d9b295437abcdeb9caeec51dcbde1b11b`
    **0aeb3dd9e469f357889defed757d9** 目录。对于hello-world，它将是`hello`可执行文件，如下所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Taking a look inside the `diff/` directory, we see the following executable
    file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`diff/`目录，我们看到以下可执行文件：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have a good understanding of how Docker images are stored locally,
    in the next section, we will look at using Docker to run the image locally as
    a container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经很好地理解了Docker镜像是如何在本地存储的，在下一节中，我们将查看如何使用Docker在本地作为容器运行镜像。
- en: Running images as containers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将镜像作为容器运行
- en: In this section, we will look at running Docker images as containers and examine
    the different information that we can see when a container is running.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看如何将Docker镜像作为容器运行，并检查容器运行时我们可以看到的不同信息。
- en: 'Start by running a database Docker image and look at what information we can
    get about the state of the container. Open the terminal window and run the following
    command to run Redis locally. Redis is an open source memory-based data store
    used to store data. Since data is stored in memory, it is fast compared to storing
    on disk. The command will run Redis, listening on port `7777`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行一个数据库Docker镜像，查看我们可以从容器状态中获得哪些信息。打开终端窗口并运行以下命令以在本地运行Redis。Redis是一个开源的基于内存的数据存储，用于存储数据。由于数据存储在内存中，与存储在磁盘上相比，它速度更快。该命令将运行Redis，监听端口`7777`：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure you change the `/home/user/Downloads/redis-7.0-rc3/data` directory
    to your own local directory, as Docker will use this to store the Redis data file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`/home/user/Downloads/redis-7.0-rc3/data`目录更改为您自己的本地目录，因为Docker将使用此目录来存储Redis数据文件。
- en: 'You will see the following message when the container is up and running:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器运行时，你会看到以下信息：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s use the Docker command-line tool to look at the running state of this
    container. In order to do that, we need to get the ID of the container by running
    the `docker ps` command; in our case, the output looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Docker命令行工具来查看这个容器的运行状态。为了做到这一点，我们需要通过运行`docker ps`命令来获取容器的ID；在我们的情况下，输出如下：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Redis container ID is `e1f58f395d06`. Using this information, we will use
    `docker inspect` to look at the different properties of the running container.
    Use `docker inspect` as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Redis容器的ID是`e1f58f395d06`。使用此信息，我们将使用`docker inspect`来查看运行容器的不同属性。如下使用`docker
    inspect`：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will get output that looks like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下所示的信息输出：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output shows a lot of information about the running state of the Redis container.
    The main things that we are interested in are the network and the mount. The `NetworkSettings`
    section shows the network configuration of the container, indicating the network
    mapping parameter of the host to the container – the container is using port `7777`,
    and the same port is exposed on the local machine.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了关于Redis容器运行状态的大量信息。我们感兴趣的主要是网络和挂载。`NetworkSettings`部分显示了容器的网络配置，指示主机到容器的网络映射参数——容器正在使用端口`7777`，并且相同的端口在本地机器上暴露。
- en: The other interesting thing is the `Mounts` parameter, which points to the mapping
    of `/home/user/Downloads/redis-7.0-rc3/data` to the `/data` local host directory
    inside the container. The mount is like a redirection from the container directory
    to the local machine directory. Using the mount ensures that all data is saved
    to the local machine when the container shuts down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事情是`Mounts`参数，它指向`/home/user/Downloads/redis-7.0-rc3/data`到容器内部`/data`本地主机目录的映射。挂载就像是从容器目录到本地机器目录的重定向。使用挂载确保在容器关闭时所有数据都保存在本地机器上。
- en: We have seen what a container is all about and how to look at the running state
    of the container. Now that we have a good understanding of images and containers,
    we will look at creating our own image in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了容器是什么以及如何查看容器的运行状态。现在，我们已经对镜像和容器有了很好的理解，我们将在本节中查看如何创建我们自己的镜像。
- en: Building and packaging images
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和打包镜像
- en: In the previous section, we learned about Docker images and how to look at the
    state of a running container; we also looked at how Docker images are stored locally.
    In this section, we will look at how to create our own Docker image by writing
    a `Dockerfile`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了 Docker 镜像以及如何查看运行中容器的状态；我们还了解了 Docker 镜像是如何在本地存储的。在本节中，我们将探讨如何通过编写
    `Dockerfile` 来创建我们自己的 Docker 镜像。
- en: We will look at building the sample application inside the `chapter13/embed`
    folder. The sample application is the same one we discussed in [*Chapter 4*](B18295_04.xhtml#_idTextAnchor053)*,
    Serving and Embedding HTML Content*. The application will run an HTTP server listening
    on port `3333` to serve an embedded HTML page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 `chapter13/embed` 文件夹内的示例应用程序的构建。该示例应用程序与我们讨论过的[*第 4 章*](B18295_04.xhtml#_idTextAnchor053)*，即“服务与嵌入
    HTML 内容”中的相同。该应用程序将运行一个监听端口 `3333` 的 HTTP 服务器，以提供嵌入的 HTML 页面。
- en: 'The `Dockerfile` that we will use to build the Docker image looks as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下 `Dockerfile` 来构建 Docker 镜像：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let’s step through the different parts of the command to understand what it
    is doing. The first step is to compile the application by using a pre-built Golang
    1.18 Docker image. This image contains all the necessary tools to build a Go application.
    We specify `/app` as the working directory using the `WORKDIR` command, and in
    the last line we copy all the source files using the `COPY` command and compile
    the source code using the standard `go build` command line.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析命令的不同部分，以了解它在做什么。第一步是使用预构建的 Golang 1.18 Docker 镜像编译应用程序。这个镜像包含构建 Go 应用程序所需的所有工具。我们使用
    `WORKDIR` 命令指定 `/app` 作为工作目录，并在最后一行使用 `COPY` 命令复制所有源文件，并使用标准的 `go build` 命令行编译源代码。
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After successfully compiling the application, the next step is to prepare the
    runtime environment that will host the application. In this case, we are using
    a pre-built Docker image of the Alpine Linux operating system. Alpine is a Linux
    distribution that is small in terms of size, which makes it ideal when creating
    Docker images for applications to run on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功编译应用程序后，下一步是准备将托管应用程序的运行时环境。在这种情况下，我们使用预构建的 Alpine Linux 操作系统 Docker 镜像。Alpine
    是一个在尺寸上较小的 Linux 发行版，这使得它在创建用于在应用程序上运行的 Docker 镜像时非常理想。
- en: 'The next thing we want to do is to make sure the operating system is up to
    date by using the - `update upgrade` command. This ensures that the operating
    system contains all the latest updates, including security updates. The last step
    is to create a new `/app` directory that will store the application binary:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要做的是通过使用 `-update upgrade` 命令确保操作系统是最新的。这确保了操作系统包含所有最新的更新，包括安全更新。最后一步是创建一个新的
    `/app` 目录，用于存储应用程序的二进制文件：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final step is to copy over the binary from the previous step, which we
    have labeled as `builder`, into the new `/app` directory. The `CMD` command specifies
    the command that will be run when the Docker image is executed as a container
    – in this case, we want to run our sample application `embed` specified by the
    parameter`/app/embed`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将上一步创建的标记为 `builder` 的二进制文件复制到新的 `/app` 目录中。`CMD` 命令指定了当 Docker 镜像作为容器执行时要运行的命令——在这种情况下，我们想要运行由参数
    `/app/embed` 指定的示例应用程序 `embed`：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have gone through what the `Dockerfile` is doing, let’s create the Docker
    image. Use the following command to build the image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `Dockerfile` 所做的工作，让我们创建 Docker 镜像。使用以下命令构建镜像：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see an output that looks like the following, showing the different
    steps and processes Docker is doing to build the image:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下所示的输出，展示了 Docker 构建镜像时进行的不同步骤和过程：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once you get the `Successfully tagged` message, the building process is complete,
    and the image is ready on your local machine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你收到“成功标记”的消息，构建过程就完成了，镜像已准备好在你的本地机器上使用。
- en: 'The new image will be labeled `chapter13` and will look as follows when we
    use the `docker` `images` command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新镜像将被标记为 `chapter13`，当我们使用 `docker images` 命令时，它将看起来如下：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the newly created image using the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行新创建的镜像：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The command will run the image as a container, and using the `-p` port parameter,
    it exposes port `3333` inside the container to the same port `3333` on the host.
    Open your browser and type in `http://localhost:3333` and you will see the HTML
    login page, as shown in *Figure 13**.2*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将以容器形式运行镜像，并使用 `-p` 端口参数，将容器内的端口 `3333` 映射到主机上的相同端口 `3333`。打开你的浏览器，输入 `http://localhost:3333`，你将看到如图
    *图 13**.2* 所示的 HTML 登录页面：
- en: '![Figure 13.2: Web application served from a Docker container](img/Figure_13.02_B18295.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2：从 Docker 容器中提供的 Web 应用程序](img/Figure_13.02_B18295.jpg)'
- en: 'Figure 13.2: Web application served from a Docker container'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：从 Docker 容器中提供 Web 应用程序
- en: In the next section, we’ll understand about Docker Compose.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解 Docker Compose。
- en: Docker Compose
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Docker provides another tool called Docker Compose, allowing developers to run
    multiple containers simultaneously. Think about use cases where you are building
    a server that requires temporary memory storage to store cart information; this
    requires using an external application such as Redis, which provides an in-memory
    database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了另一个名为 Docker Compose 的工具，允许开发者同时运行多个容器。考虑一下这样的用例，你正在构建一个需要临时内存存储来存储购物车信息的服务器；这需要使用外部应用程序，如
    Redis，它提供了一个内存数据库。
- en: 'In this kind of scenario, our application depends on Redis to function properly,
    which means that we need to run Redis at the same time we run our application.
    There are many other different kinds of use cases where there will be a need to
    use Docker Compose. The Docker Compose documentation provides a complete step-by-step
    guide on how to install it on your local machine: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景下，我们的应用程序依赖于 Redis 正常运行，这意味着我们需要在运行应用程序的同时运行 Redis。还有许多其他不同类型的用例，其中将需要使用
    Docker Compose。Docker Compose 文档提供了如何在本地机器上安装它的完整分步指南：[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)。
- en: 'Docker Compose is actually a file that outlines the different containers we
    want to use. Let’s try to run the sample Docker Compose file that is inside the
    `chapter13/embed` folder. Open the terminal and make sure you are inside the `chapter13/embed`
    folder, then execute the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 实际上是一个文件，概述了我们想要使用的不同容器。让我们尝试运行位于 `chapter13/embed` 文件夹内的示例 Docker
    Compose 文件。打开终端并确保你位于 `chapter13/embed` 文件夹中，然后执行以下命令：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will get the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once everything is running, you should be able to access the server by opening
    your browser and typing `http://localhost:3333` in the address bar.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一切运行起来后，你应该能够通过打开浏览器并在地址栏中输入 `http://localhost:3333` 来访问服务器。
- en: 'The Docker Compose file looks as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 文件如下所示：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The file outlines two containers that need to be run – the server is pointing
    to our application server, and the `build` parameter uses the `.` dot notation.
    This tells Docker Compose that the source (Dockerfile) to build the image for
    this container is found in the local directory, while the cache service is a Redis
    server, and it will be pulled from the Docker remote registry, specifically version
    7.0.4.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件概述了需要运行的两个容器——服务器指向我们的应用程序服务器，而 `build` 参数使用的是 `.` 点表示法。这告诉 Docker Compose，构建此容器镜像的源（Dockerfile）位于本地目录中，而缓存服务是一个
    Redis 服务器，它将从 Docker 远程仓库中拉取，具体版本为 7.0.4。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about what Docker is and how to use it. Building
    applications is one part of the puzzle, but packaging them to be deployed in a
    cloud environment requires developers to understand Docker and how to build Docker
    images for their applications. We looked at how Docker stores images on your local
    machine and also inspected the state of the running container.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Docker 是什么以及如何使用它。构建应用程序是谜题的一部分，但要将它们打包以部署到云环境中，则需要开发者了解 Docker 以及如何为他们的应用程序构建
    Docker 镜像。我们探讨了 Docker 在本地机器上存储镜像的方式，并检查了运行容器的状态。
- en: We learned that when containers are running, there is a lot of information generated
    that can help us to understand what’s going on with the container and also the
    parameters used to run our application. We also learned about the `Dockerfile`
    and used it to package our sample application into a container to run it as a
    single Docker image.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，当容器运行时，会产生大量信息，这些信息可以帮助我们了解容器运行的情况以及运行应用程序所使用的参数。我们还学习了 `Dockerfile` 的相关知识，并使用它将我们的示例应用程序打包进容器中，以便作为一个单独的
    Docker 镜像运行。
- en: In the next chapter, we will use the knowledge we gained in this chapter by
    deploying our images to a cloud environment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过将我们的镜像部署到云环境中来应用本章所获得的知识。
