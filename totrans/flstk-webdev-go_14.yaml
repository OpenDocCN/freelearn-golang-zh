- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about cloud deployment, specifically using AWS
    as the cloud provider. We will look at some of the infrastructure services provided
    by AWS and how to use them. We will learn about using and writing code for creating
    the different AWS infrastructure services using an open source tool called Terraform.
    Understanding the cloud and how cloud deployment works has become a necessity
    for developers nowadays rather than an exception. Gaining a good understanding
    of the different aspects of cloud deployment will allow you to think outside the
    box about how your application should run in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completion of this chapter, we will have learned about the following key
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning basic AWS infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and using Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Terraform for local and cloud deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to AWS Elastic Container Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end goal of this chapter is to provide you with some knowledge about the
    cloud and how to perform certain basic operations for deploying applications to
    the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter14](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses AWS services, so you are expected to have an AWS account.
    AWS provides a Free Tier for new user registration; more information can be found
    at [https://aws.amazon.com/free](https://aws.amazon.com/free).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using any kind of AWS services will incur a cost. Please read and inform yourself
    before using the service. We highly recommend reading what is available on the
    Free Tier on the AWS website.
  prefs: []
  type: TYPE_NORMAL
- en: AWS refresher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS** stands for **Amazon Web Services** and belongs to Amazon, which provides
    the e-commerce platform [amazon.com.au](http://amazon.com.au). AWS provides services
    that allow organizations to run their applications in a complete infrastructure
    without owning any of the hardware required.'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS brand is a household name for developers and almost all developers have
    some basic direct/indirect exposure to using AWS tools or its services. In this
    section, we will look at some services provided by AWS as a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: The question that comes to our mind is, why bother using services such as AWS?
    *Figure 14**.1* summarizes the answer nicely. AWS provides services that are available
    across different continents of the world and ready to be used by organizations
    to fulfill their needs. Imagine that your organization has customers across different
    continents. How much easier would it be to run your application on different continents
    without having the burden of investing in hardware on each of those continents?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: Global AWS Regions](img/Figure_14.01_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Global AWS Regions'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the basic service provided by AWS called
    AWS EC2, which provides computing resources.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Elastic Compute Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Amazon **Elastic Compute Cloud** (**EC2**) is the basic computing resource
    for developers to run their applications on. You can think of EC2 as a virtual
    computer on Amazon infrastructure somewhere on the internet that runs your application.
    You can select from a number of computer configurations that you want to run your
    application on, from a small 512-MB memory to a gigantic 384-GB memory computer
    with different configurations of storage. *Figure 14**.2* shows the Instance Type
    Explorer that can be accessed using the following URL: [https://aws.amazon.com/ec2/instance-explorer/](https://aws.amazon.com/ec2/instance-explorer/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2: Instance Type Explorer](img/Figure_14.02_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Instance Type Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at another AWS resource related to computing
    that is super important for applications, and that is storage.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs: []
  type: TYPE_NORMAL
- en: Computing power is great for running applications, but applications require
    long-term storage to store data such as log files and databases. There are a number
    of different kinds of storage provided by AWS. For example, *Figure 14**.3* shows
    the **Elastic Block Store** (**EBS**), which is a block storage service. This
    block storage is like the normal storage that you have on your local computer
    and is offered as a hard drive or a **solid-state** **drive** (**SSD**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: EBS](img/Figure_14.03_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: EBS'
  prefs: []
  type: TYPE_NORMAL
- en: The amazing thing about having this kind of storage is its elastic nature –
    what this means is you can increase or decrease the size of storage anytime you
    need without the worry of adding new hardware. Imagine what would happen if you
    were running out of hard drive space on your local computer. You would need to
    buy a new hard drive and install and configure it, none of which is required when
    you use the AWS storage service. Attaching storage to the EC2 instance of your
    choice enables your application to run and store data in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at another AWS service that is as important as the one that we
    have just discussed: networking.'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Private Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that your application is running in its own virtual computer, complete with
    storage, the next question is how we configure a network in AWS so that users
    can access the application. This is called a **Virtual Private Cloud** (**VPC**).
    Think about a VPC as your own network setup, but without cables – everything is
    configured and run using software. *Figure 14**.4* shows the powerful capability
    of a VPC, enabling you to connect different networks configured in different Regions.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a Region as the physical location where AWS stores its hardware, and
    if you run your applications in different physical locations, you are able to
    connect them using a VPC.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: Virtual Private Networking](img/Figure_14.04_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Virtual Private Networking'
  prefs: []
  type: TYPE_NORMAL
- en: You have full control to configure the network of each Region your application
    is running on, how these Regions communicate with your own network, and how your
    application will be accessible via the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at another important service that a lot of
    applications require which is storing data in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Database storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter what kind of applications you are building, you will require a database
    to store data, and this requires a database server to be running. AWS provides
    different database services ranging from those that store small amounts of data
    to massively distributed databases across different continents. One of these services
    is called Amazon **Relational Database Service** (**RDS**), a managed service
    to set up, scale, and operate databases.
  prefs: []
  type: TYPE_NORMAL
- en: The databases that RDS can support are MySQL, PostgreSQL, MariaDB, Oracle, and
    SQL Server. *Figure 14**.5* outlines the features provided by RDS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: RDS](img/Figure_14.05_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: RDS'
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Container Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B18295_13.xhtml#_idTextAnchor261), *Dockerizing an Application*,
    we learned how to create Docker images to package our application so it can run
    as a container. Packaging applications as Docker images allows us to run our application
    in any kind of environment, from a local machine to the cloud. AWS provides a
    related service called **Elastic Container** **Service** (**ECS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'ECS helps us to deploy, manage, and scale out applications that have been built
    as containers. A key scaling feature of ECS is the ability to scale your application
    using the Application Auto Scaling capability. This feature allows developers
    to scale applications based on certain conditions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step scaling**: This means scaling an application based on the breach of
    an alarm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduled scaling**: This is scaling based on a predetermined time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS provides different ways to use its services, including a web user interface
    and the **command-line interface** (**CLI**). The main page of the web UI can
    be seen in *Figure 14**.6*. You will need to register for an AWS account first
    before using any of the AWS tools.
  prefs: []
  type: TYPE_NORMAL
- en: The UI is a very good place to start exploring the different services and go
    through some sample tutorials to get a better understanding of each service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: AWS web UI](img/Figure_14.06_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: AWS web UI'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other AWS tool that is used to interact with the services is the CLI, which
    needs to be installed locally ([https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.xhtml](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.xhtml)).
    The CLI makes it easier to interact with the AWS services than the web UI. If
    you have installed it locally, when you run `aws` from your terminal, you will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at how to use some of the features described
    here to deploy our application in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at another tool that makes it easier for us to
    work with AWS services: Terraform. In the previous section, we learned that AWS
    provides tools of its own, which is great for small tasks, but once you start
    combining the different services it becomes harder to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: What is Terraform?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform ([https://www.terraform.io/](https://www.terraform.io/)) is an open
    source tool that provides **infrastructure as code** (**IaC**). What this means
    is you write code to define what kind of service you want to use and how you want
    to use it, and this way, you can combine and link the different services together
    as a single piece. This makes it easy for you as a developer to run and destroy
    infrastructure as a unit instead of separate fragments.
  prefs: []
  type: TYPE_NORMAL
- en: The other benefit that Terraform provides is the ability to version control
    the infrastructure code like normal application code, where it goes through the
    normal review process, including the peer review process and also unit testing,
    before deploying the infrastructure to production. With this, your application
    and infrastructure will now go through the same development process, which is
    trackable.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Terraform installation process is straightforward: you can find a complete
    set of instructions for your operating system in the HashiCorp documentation at
    [https://www.terraform.io/downloads](https://www.terraform.io/downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when writing this book we are using an Ubuntu-based distro, so
    we download the AMD64 binary from [https://releases.hashicorp.com/terraform/1.3.0/terraform_1.3.0_linux_amd64](https://releases.hashicorp.com/terraform/1.3.0/terraform_1.3.0_linux_amd64)`.zip`
    and include the Terraform directory into our `PATH`, as in the following snippet.
    The directory added to the `PATH` variable environment is a temporary solution
    for the terminal that you are using. In order to store it, you need to put it
    as part of your shell script (for Linux, if you are using Bash, you can add this
    to your `.``bashrc` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether the installation was successful, open the terminal and execute
    `Terraform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For detailed information on how to install Terraform for your environment, see
    [https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed the Terraform installation, we will learn how to
    use some of the basic commands available in Terraform. The commands will enable
    you to jumpstart your journey into the world of cloud deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform basic commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn some basic Terraform commands that are often
    used when writing code. We will also examine concepts that are relevant to Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: The init command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every time we start writing Terraform code, the first command that we run is
    `terraform init`. This command prepares all the necessary dependencies required
    to run the code locally. The command performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloads all the necessary modules that are used in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializes plugins that are used in the code. For example, if the code is deployed
    on AWS it will download the AWS plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a file called a lock file that registers the different dependencies
    and versions that are used by the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To gain a better understanding of the previous steps, let’s run the command.
    Open the terminal and change to the `chapter14/simple` directory, and execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `init` process is complete, your directory will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `.terraform` directory contains the dependencies that are specified in the
    code. In this example, it uses the `kreuzwerker/docker` plugin, which is used
    to run Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.terraform.lock.hcl` file contains the version information of the dependencies,
    and it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The plan command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `plan` command is used to help us understand the execution plan that Terraform
    will be doing. This is a very important feature as it gives us visibility of what
    changes will be performed to our infrastructure. This will give us a better understanding
    of which parts of the infrastructure will be impacted by the code. Unlike tools
    such as Chef or Ansible, Terraform is interesting in that it will tend towards
    a target state and only make the changes necessary to reach it. For example, if
    you had a target of five EC2 instances but Terraform only knew of three, it would
    take the steps needed to reach that target of five.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal, change to the `chapter14/simple` directory, and execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that there will be `2` things added and `0` operations for
    changing or destroying, which tells us that this is the first time we are running
    the code or it’s still fresh.
  prefs: []
  type: TYPE_NORMAL
- en: The apply command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The normal process of running Terraform is that after `init`, we run `apply`
    (however, if we are not sure about the impact, we use the `plan` command as shown
    previously). Open the terminal, change to the `chapter14/simple` directory, and
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the output, the `nginx` container will be downloaded (if it does
    not exist as yet) and then run. Once the command is successfully run you can test
    it by opening your browser and accessing http://localhost:8080\. You will see
    something like *Figure 14**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7: nginx running in a container](img/Figure_14.07_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: nginx running in a container'
  prefs: []
  type: TYPE_NORMAL
- en: The destroy command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last command that we will look at is `destroy`. As the name implies, it
    is used to destroy the infrastructure that was created using the `apply` command.
    Use this command with caution if you are unsure about the impact of the code on
    your infrastructure. Use the `plan` command before running this to get better
    visibility of what will be removed from the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and run the following command from the `chapter14/simple`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the output, we can see that there are `2` infrastructures that are destroyed
    – one is the container removed from memory, and the other is the removal of the
    image from the local Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: The `–auto-approve` command is used to automatically approve the steps; normally,
    without using this, Terraform will stop execution and ask the user to enter `Yes`
    or `No` to continue at each step. This is a precautionary measure to ensure that
    the user does indeed want to destroy the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at writing Terraform code and how it uses
    providers. We will look at a few Terraform examples to get an understanding of
    how it works to spin up different AWS infrastructure services for deploying applications.
  prefs: []
  type: TYPE_NORMAL
- en: Coding in Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HashiCorp, the creator of Terraform, created **HashiCorp configuration language**
    (**HCL**), which is used in writing Terraform code. HCL is a functional programming
    language with features such as loops, if statements, variables, and logic flow
    that are normally found in programming languages. Complete in-depth HCL documentation
    can be found at [https://www.terraform.io/language/](https://www.terraform.io/language/).
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reason why Terraform is so widely used is the number of extensions that
    are available from the company and open source communities; these extensions are
    called providers. A provider is a piece of software that interacts with the different
    cloud providers and other resources in the cloud. We will look at Terraform code
    to understand more about providers. The following code snippets can be found inside
    the `chapter14/simple` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resource` block in the code can be used to declare infrastructure or an
    API. In this example, we are using Docker, specifically, `docker_image` and `docker_container`.
    When Terraform runs the code it detects the `required_providers` block, which
    is used to define a provider. A provider is an external module that the code will
    be using, and this will be automatically downloaded by Terraform from a central
    repository. In our example, the provider that we are using is the `kreuzwerker/docker`
    Docker provider. More information on this provider can be found at the following
    link: [https://registry.terraform.io/providers/kreuzwerker/docker/](https://registry.terraform.io/providers/kreuzwerker/docker/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal, make sure you are inside the `chapter14/simple` directory,
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Terraform downloads the provider and stores it inside the `chapter14/simple/.terraform`
    folder. Now, let’s run the sample code and see what we get, by running the following
    command in the same terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser and go to http://localhost:8000\. You will see something like
    *Figure 14**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform downloads the `nginx` Docker image automatically to your local machine
    and runs the `nginx` container using the port defined in the `ports` code block
    (port `8000`). To destroy the running container and delete the image locally from
    the Docker registry, all you have to do is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you compare the steps involved to do the same thing manually using the Docker
    command, it is more involved and error-prone; writing it in Terraform makes it
    much easier to run and remove containers with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore more examples to better understand how
    to use Terraform for deploying applications.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will look at different ways we can use Terraform,
    such as pulling images from GitHub and running them locally, or building and publishing
    Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure every time you run Terraform examples that create AWS resources to
    remember to destroy the resources using the `terraform` `destroy` command.
  prefs: []
  type: TYPE_NORMAL
- en: All resources created in AWS incur charges, and by destroying them, you will
    ensure there will be no surprise charges.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling from GitHub Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example code for this section can be found inside the `chapter14/github`
    folder. The following snippet is from `pullfromgithub.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The main objective of the code is to download the Docker image that we built
    in [*Chapter 12*](B18295_12.xhtml#_idTextAnchor241)*, Building Continuous Integration*.
    Once the Docker image is downloaded, it will be run locally. Open your terminal,
    make sure you are inside the `chapter14/github` directory, and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see output in your terminal that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser and go to http://localhost:3333\. You will see the login page
    of the sample app.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the same `docker` provider that we discussed in the previous section,
    and we use a new `docker_registry_image` command to specify the address to download
    the Docker image from, in this case from the `ghcr.io/nanikjava/golangci/chapter12:latest`
    GitHub package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other HCL feature we are using is the `data` block, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` block works similarly to `resource`, except it is only used for
    reading values and not creating or destroying resources or to get data that will
    be used internally as configuration to another resource. In our sample, it is
    used by the `docker_image` resource, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: AWS EC2 setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous examples, we looked at using the Docker provider to run Docker
    containers locally. In this example, we will look at creating AWS resources, specifically
    EC2 instances. An EC2 instance is basically a virtual machine that can be initialized
    with a certain configuration to run in the cloud to host your application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create resources in AWS, you will first need to already have an
    AWS account. If you don’t have an AWS account, you can create one at [https://aws.amazon.com/](https://aws.amazon.com/).
    Once you have your AWS account ready, log in to the AWS website, and in the main
    console (*Figure 14**.6*) web page, click on your name on the right side and it
    will display a drop-down menu, as shown in *Figure 14**.8*. Then click on **Security
    credentials**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8: Security credentials option](img/Figure_14.08_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Security credentials option'
  prefs: []
  type: TYPE_NORMAL
- en: Your browser will now show the **identity and access management** (**IAM**)
    page, as shown in *Figure 14**.9*. Select the **Access keys (access key ID and
    secret access key)** option. Since you haven’t created any key, it will be empty.
    Click on the **Create New Access Key** button and follow the instructions to create
    a new key.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9: Access keys section](img/Figure_14.09_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Access keys section'
  prefs: []
  type: TYPE_NORMAL
- en: Once you complete the steps you will get two keys – an Access Key ID and Secret
    Access Key. Keep these keys safe as they are used like a username and password
    combination you use to create resources in AWS infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have the keys required, you can now open a terminal and change
    into the `chapter14/simpleec2` directory, and run the example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following command to create the EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once completed you will see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows three resources were created – the AWS instance (EC2), an
    IP subnet, and a network VPC. Now, let’s take a look at the code (the complete
    code can be seen inside the `chapter14/simpleec2` directory). The code requires
    your AWS keys, storing them inside the `variable` block as `aws_access_key` and
    `aws_secret_key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The keys will be passed to the `aws` provider to enable the provider to communicate
    with the AWS service using our keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following part of the code creates the VPC and IP subnet, which will be
    used as a private network by EC2 instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last resource the code defines is the EC2 instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The EC2 instance type is `t2.nano`, which is the smallest virtual machine that
    can be configured. It is linked to the IP subnet defined earlier by assigning
    the subnet ID to the `subnet_id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to ECS with a load balancer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last example that we are going to look at is using AWS ECS. The source code
    can be found inside the `chapter14/lbecs` directory. The code will use ECS to
    deploy our [*Chapter 12*](B18295_12.xhtml#_idTextAnchor241) container hosted in
    GitHub Packages and made scalable by using a load balancer. *Figure 14**.9* shows
    the infrastructure configuration after running the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10: ECS with a load balancer](img/Figure_14.10_B18295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: ECS with a load balancer'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code uses the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An internet gateway**: As the name implies, this is a gateway that enables
    communication to be established between the AWS VPC private network and the internet.
    With the help of the gateway, we open our application to the world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A load balancer**: This service helps balance the incoming traffic across
    the different networks configured, ensuring that the application can take care
    of all incoming requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS provides the capability to scale the deployment process for containers.
    This means that, as developers, we don’t have to worry about how to scale the
    containers that are running our application, as this is all taken care of by ECS.
    More in-depth information can be found at [https://aws.amazon.com/ecs/](https://aws.amazon.com/ecs/).
    The application is run the same way as in the previous examples, using the `terraform
    init` and `terraform` `apply` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The ECS example takes a bit longer to execute compared to the other examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get output that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code to see how it uses ECS and configures the internet
    gateway, load balancer, and network. The following code shows the internet gateway
    declaration, which is simple enough as it requires to be attached to a VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Besides that, the gateway will also be attached to a routing table declared
    inside the `aws_default_route_table` block. This is necessary as this tells the
    gateway how to route the incoming and outgoing traffic through the internal private
    VPC network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our internal private network can communicate to the internet via a
    gateway, we need to have network rules in place to ensure our network is secure,
    and this is done in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `egress` block declares the rule for outgoing network traffic, allowing
    all protocols to pass through. The incoming network traffic rule is declared in
    the `ingress` block, and allows ports between `80`-`3333` and only over TCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a load balancer requires two different subnets to be declared. In our
    code example, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of code that we will look at is the ECS block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code contains three different code blocks that are explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aws_ecs_cluster`: This block configures the name of the ECS cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws_ecs_task_definition`: This block configures the ECS task, which specifies
    what kind of container it has to run, the virtual machine configuration that the
    container will be running on, the network mode, security group, and other options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws_ecs_service`: This block ties together the different services to describe
    the complete infrastructure that will be run, such as security, ECS task, network
    configuration, load balancers, public IP address, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once ECS has been spun up, it will print out in your console the load-balanced
    public address you can use to access the application. For example, when it was
    run, we got the following output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using the `load-balancer-375816308.us-east-1.elb.amazonaws.com` address in the
    browser will show the application login page. This address is dynamically generated
    by AWS, and you will get something different than what is shown in the previous
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored cloud solutions provided by AWS, and we briefly
    looked at the different services offered, such as EC2, VPC, storage, and others.
    We learned about the open source Terraform tools that make it easy to create,
    manage, and destroy cloud infrastructure in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to install and use Terraform locally, and how to write Terraform
    code to use Docker as a provider, allowing us to run containers locally. Terraform
    also allows us to download, run, and destroy containers locally with a single
    command.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored different Terraform examples for creating AWS infrastructure
    resources and looked at one of the advanced features of AWS ECS.
  prefs: []
  type: TYPE_NORMAL
- en: In this last chapter of the book, you have learned the different things that
    need to be done to deploy an application to the AWS cloud.
  prefs: []
  type: TYPE_NORMAL
