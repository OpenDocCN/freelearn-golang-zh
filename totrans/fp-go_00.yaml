- en: Preface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: Go is a multi-paradigm programming language. This means that both the object-oriented
    paradigm and the functional paradigm are entirely valid approaches to problem
    solving. In this book, we will explore the applications of functional programming
    techniques in Go. But rather than being purely focused on the functional aspect,
    we will embrace Go for what it is – multi-paradigm. This means that we highlight
    the difference between the functional and object-oriented ways of problem solving.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种多范式编程语言。这意味着面向对象范式和函数式范式都是完全有效的解决问题的方法。在这本书中，我们将探讨函数式编程技术在Go中的应用。但本书不会仅仅关注函数式方面，而是会拥抱Go的本质——多范式。这意味着我们将突出函数式和面向对象解决问题的不同方式。
- en: To write Go code that is more testable, readable, and reliable, we will look
    at functional-first approaches such as functions as first-class citizens, function
    purity, currying, and more. We will look not only at how to write functional code,
    but we will also explore the performance implications and limitations of Go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写更易于测试、阅读和可靠的Go代码，我们将探讨以函数式编程为首要方法的途径，如函数作为一等公民、函数纯净性、柯里化等。我们将不仅探讨如何编写函数式代码，还将探讨Go的性能影响和局限性。
- en: The goal of this book is to get the reader accustomed to functional programming
    as a valid paradigm that can improve your code, no matter whether you’re working
    on a greenfield project or a project already entrenched in the OO paradigm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是让读者习惯将函数式编程作为一种有效的范式，无论你是在开发一个全新的项目，还是在已经深入OO范式的项目中工作，都能通过它来提升你的代码质量。
- en: For readers unfamiliar with the newly introduced generics in Go, this book also
    serves as an example of what’s possible now that generics are part of the standard
    library. Finally, we will also look at libraries that can be leveraged to write
    functional code for both pre-generic and post-generic versions of Go.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉Go中新引入的泛型的读者，本书也提供了一个示例，展示了泛型成为标准库的一部分后，现在可以实现的可能性。最后，我们还将探讨可以用来为Go的泛型前和泛型后版本编写函数式代码的库。
- en: Who this book is for
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书面向的对象
- en: If you are a Go engineer with a background in traditionally object-oriented
    languages such as Java or C++ who wants to broaden your knowledge of functional
    programming, this book is for you. The book aims to teach you how concepts from
    functional programming can improve your existing Go code, as well as when to choose
    the functional approach. At each step, we highlight the trade-offs between the
    functional and object-oriented approaches to see how they compare.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一位有Java或C++等传统面向对象语言背景的Go工程师，希望扩展你对函数式编程的了解，这本书就是为你准备的。本书旨在教你如何将函数式编程的概念应用于现有的Go代码中，以及何时选择函数式方法。在每一步中，我们将突出函数式和面向对象方法之间的权衡，以了解它们是如何比较的。
- en: What this book covers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书涵盖的内容
- en: In [*Chapter 1*](B18771_01.xhtml#_idTextAnchor015), *Introducing Functional
    Programming*, we are going to take a bird’s eye view of the *what* and *why* behind
    functional programming. To start, we will take a brief look at the history and
    contemporary state of functional programming methodologies. Then we will take
    a look at how functional programming compares to the more traditional object-oriented
    programming.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18771_01.xhtml#_idTextAnchor015)《介绍函数式编程》中，我们将从宏观的角度了解函数式编程背后的*是什么*和*为什么*。首先，我们将简要回顾函数式编程方法的历史和当代状态。然后，我们将探讨函数式编程与传统面向对象编程的比较。
- en: In[*Chapter 2*](B18771_02.xhtml#_idTextAnchor028), *Treating Functions as First-Class
    Citizens*, we are going to cover exactly why functions are powerful in languages
    that treat them as **first-class citizens**. Go has functions as first-class citizens
    out of the box, meaning we get this functionality. We are going to see how this
    allows us to create function-centered constructs that improve the readability
    and testability of our code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18771_02.xhtml#_idTextAnchor028)《将函数视为一等公民》中，我们将详细探讨为什么在将函数视为**一等公民**的语言中，函数如此强大。Go语言天生就支持函数作为一等公民，这意味着我们能够获得这种功能。我们将看到这是如何使我们能够创建以函数为中心的结构，从而提高我们代码的可读性和可测试性。
- en: In[*Chapter 3*](B18771_03.xhtml#_idTextAnchor047), *Higher-Order Functions*,
    we are going to explore the concept of function composition through higher-order
    functions. There are a variety of new concepts that are introduced here, such
    as closures, partial application, and function currying. We will take a look at
    some practical examples and real-world use cases for these.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18771_03.xhtml#_idTextAnchor047)，*高阶函数*中，我们将通过高阶函数探索函数组合的概念。这里引入了许多新的概念，例如闭包、部分应用和函数柯里化。我们将探讨一些实际示例和实际用例。
- en: In[*Chapter 4*](B18771_04.xhtml#_idTextAnchor060), *Write Testable Code with
    Pure Functions*, we will take a look at what it means for a language, and a function,
    to be considered pure. We will take a look at some of the tradeoffs between function
    purity and impurity, and explore how pure functions help us write testable code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18771_04.xhtml#_idTextAnchor060)，*使用纯函数编写可测试的代码*中，我们将探讨一个语言和一个函数被认为是纯函数的含义。我们将探讨函数纯度与不纯度之间的权衡，并探讨纯函数如何帮助我们编写可测试的代码。
- en: In[*Chapter 5*](B18771_05.xhtml#_idTextAnchor085), *Immutability*, we cover
    what exactly it means to be immutable, and how the Go language can help preserve
    immutability at the struct level. To understand how this works, we will look at
    how Go handles pointers and references to objects, what the performance implications
    are, and how to decide between the pointer-reference trade-offs. We will also
    dive into the implications for garbage collection, unit testing, and pure functional
    programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18771_05.xhtml#_idTextAnchor085)，*不可变性*中，我们讨论了不可变性的确切含义，以及Go语言如何帮助在结构级别上保持不可变性。为了理解这是如何工作的，我们将看看Go如何处理对象的指针和引用，性能影响是什么，以及如何在指针-引用权衡之间做出决定。我们还将深入研究垃圾收集、单元测试和纯函数式编程的影响。
- en: In[*Chapter 6*](B18771_06.xhtml#_idTextAnchor101), *Three Common Categories
    of Functions*, we are going to look at some practical implementations of functions
    that leverage the concepts of functional programming covered up to now. We will
    build Filter functions, Map functions and Reducers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18771_06.xhtml#_idTextAnchor101)，*函数的三个常见类别*中，我们将探讨一些利用到目前为止所涵盖的函数式编程概念的函数的实际实现。我们将构建过滤器函数、映射函数和归约器。
- en: In[*Chapter 7*](B18771_07.xhtml#_idTextAnchor113), *Recursion*, we are going
    to talk about recursion. This is a topic that all programmers encounter sooner
    or later, as it’s not exclusive to the functional paradigm. Any language in which
    you can express function calls also allows you to express functions that are recursive
    in nature. But in functional languages, these take center stage. We will look
    at the implications for this in Go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18771_07.xhtml#_idTextAnchor113)，*递归*中，我们将讨论递归。这是一个所有程序员迟早都会遇到的话题，因为它并不仅限于函数式范式。任何允许你表达函数调用的语言也允许你表达本质上递归的函数。但在函数式语言中，这些函数占据了中心舞台。我们将探讨Go语言中这一点的含义。
- en: In[*Chapter 8*](B18771_08.xhtml#_idTextAnchor126), *Readable Function Composition
    with Fluent Programming,* we are going to look at different methods for chaining
    functions in functional programming. The end goal here is to write code that is
    easier to read and creates less visual clutter. We will look at three ways for
    achieving this. First, we will take a look at how we can use type aliases to attach
    methods to container types, allowing us to create chained functions with the familiar
    *dot notation*. Next, we will look at continuation-passing style programming and
    consider the trade-offs of each approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18771_08.xhtml#_idTextAnchor126)，*使用流畅编程进行可读性函数组合*中，我们将探讨在函数式编程中链式调用函数的不同方法。这里的最终目标是编写更易于阅读的代码，并减少视觉混乱。我们将探讨三种实现这一目标的方法。首先，我们将看看如何使用类型别名将方法附加到容器类型上，从而允许我们使用熟悉的*点符号*创建链式函数。接下来，我们将探讨传递风格编程，并考虑每种方法的权衡。
- en: In[*Chapter 9*](B18771_09.xhtml#_idTextAnchor138), *Functional Design Patterns*,
    we will move to a higher level of abstraction. Rather than talking about individual
    functions and operations, we will look at design patterns. While we will not extensively
    explain each design pattern, we will take a look at how the object-oriented pattern
    translates to the functional world.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18771_09.xhtml#_idTextAnchor138)，*功能设计模式*中，我们将提升到更高的抽象层次。我们不会谈论单个函数和操作，而是会探讨设计模式。虽然我们不会详细解释每个设计模式，但我们会看看面向对象模式如何转化为函数式世界。
- en: In[*Chapter 10*](B18771_10.xhtml#_idTextAnchor147), *Concurrency and Functional
    Programming*, we consider how concurrency is all around us, both in the real world
    as well as the virtual one. In this chapter we will start by looking at concurrency,
    parallelism, and distributed computation. Next, we will focus on how the concurrency
    mechanisms in Go can help us write functional code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18771_10.xhtml#_idTextAnchor147)*，并发和函数式编程*中，我们考虑了并发无处不在，无论是在现实世界还是在虚拟世界中。在这一章中，我们将首先探讨并发、并行和分布式计算。接下来，我们将关注Go中的并发机制如何帮助我们编写函数式代码。
- en: In[*Chapter 11*](B18771_11.xhtml#_idTextAnchor158)*, Functional Programming
    Libraries*, we will explore several libraries that can help us build programs
    in the functional paradigm. We will look both at pre-generic libraries and post-generic
    libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B18771_11.xhtml#_idTextAnchor158)*，函数式编程库*中，我们将探讨几个可以帮助我们在函数式范式下构建程序的库。我们将查看既有的非泛型库和泛型库。
- en: To get the most out of this book
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了充分利用这本书
- en: Prior to picking up this book, the reader should be familiar with Go and generics.
    The basic concepts of the programming language (control flow, structs, and imports),
    how to build and run applications, and how to import open source libraries from
    GitHub should also be understood by the reader.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在拿起这本书之前，读者应该熟悉Go和泛型。编程语言的基本概念（控制流、结构体和导入）、如何构建和运行应用程序以及如何从GitHub导入开源库也应该为读者所理解。
- en: '| **Software/hardware covered in** **the book** | **Operating** **system requirements**
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **本书涵盖的软件/硬件** | **操作系统要求** |'
- en: '| Go (pre- and post-generics) | Windows, macOS, or Linux |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Go（泛型和泛型之前） | Windows、macOS或Linux |'
- en: Having Go 1.18 or later installed is a prerequisite for the majority of this
    book. Certain chapters will also work on Go version’s prior to 1.18, this will
    be called out per chapter. Most of the code will also work in the Go playground
    at[https://go.dev/play/](https://go.dev/play/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Go 1.18或更高版本是本书大多数内容的先决条件。某些章节也将适用于1.18之前的Go版本，这将在每个章节中说明。大多数代码也将适用于Go playground[https://go.dev/play/](https://go.dev/play/)。
- en: '**If you are using the digital version of this book, we advise you to type
    the code yourself or access the code from the book’s GitHub repository (a link
    is available in the next section). Doing so will help you avoid any potential
    errors related to the copying and pasting** **of code.**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您正在使用本书的数字版，我们建议您自己输入代码或从本书的GitHub仓库（下一节中有一个链接）获取代码。这样做将有助于避免与代码复制和粘贴相关的任何潜在错误。**'
- en: '*Some chapters will have snippets in Haskell and Java for illustrative purposes
    of (pure) functional and object-oriented counterparts* *to Go.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些章节将包含Haskell和Java的代码片段，以说明Go的（纯）函数式和面向对象对应物的示例*。'
- en: Download the example code files
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载示例代码文件
- en: You can download the example code files for this book from GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go](https://github.com/PacktPublishing/Functional-Programming-in-Go).
    If there’s an update to the code, it will be updated in the GitHub repository.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载本书的示例代码文件：[https://github.com/PacktPublishing/Functional-Programming-in-Go](https://github.com/PacktPublishing/Functional-Programming-in-Go)。如果代码有更新，它将在GitHub仓库中更新。
- en: We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有其他来自我们丰富的图书和视频目录的代码包，可在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)找到。查看它们！
- en: Download the color images
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载彩色图像
- en: 'We also provide a PDF file that has color images of the screenshots and diagrams
    used in this book. You can download it here: [https://packt.link/5tPDg](https://packt.link/5tPDg).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一份包含本书中使用的截图和图表彩色图像的PDF文件。您可以从这里下载：[https://packt.link/5tPDg](https://packt.link/5tPDg)。
- en: Conventions used
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用的约定
- en: There are a number of text conventions used throughout this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用了多种文本约定。
- en: '`Code in text`: Indicates code words in text, database table names, folder
    names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter
    handles. Here is an example: “When calling the `rollDice` function, the output
    is not consistent. If it were consistently outputting the same number, it would
    be a pretty bad randomization function.”'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`文本中的代码`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟URL、用户输入和Twitter昵称。以下是一个示例：“在调用`rollDice`函数时，输出并不一致。如果它始终输出相同的数字，那将是一个非常糟糕的随机化函数。”'
- en: 'A block of code is set as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块设置如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Any command-line input or output is written as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 任何命令行输入或输出都应如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Bold**: Indicates a new term, an important word, or words that you see onscreen.
    For instance, words in menus or dialog boxes appear in **bold**. Here is an example:
    “In this main function, we are first defining a **deferred** function that runs
    at the end of main function, just before function exit.”'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**粗体**：表示新术语、重要单词或屏幕上看到的单词。例如，菜单或对话框中的单词以**粗体**显示。以下是一个示例：“在这个主函数中，我们首先定义了一个在主函数结束前、函数退出前运行的**延迟**函数。”'
- en: Tips or important notes
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士或重要注意事项
- en: Appear like this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样。
- en: Get in touch
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系我们
- en: Feedback from our readers is always welcome.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终欢迎读者的反馈。
- en: '`customercare@packtpub.com` and mention the book title in the subject of your
    message.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`customercare@packtpub.com`并在您的消息主题中提及书名。'
- en: '**Errata**: Although we have taken every care to ensure the accuracy of our
    content, mistakes do happen. If you have found a mistake in this book, we would
    be grateful if you would report this to us. Please visit [www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)
    and fill in the form.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**勘误表**：尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果您在此书中发现错误，我们将不胜感激，如果您能向我们报告，我们将不胜感激。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。'
- en: '`copyright@packt.com` with a link to the material.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyright@packt.com`，并提供材料链接。'
- en: '`authors.packtpub.com`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`authors.packtpub.com`。'
- en: Share your thoughts
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享您的想法
- en: Once you’ve read *Functional Programming in Golang*, we’d love to hear your
    thoughts! Please [click here to go straight to the Amazon review page](https://packt.link/r/9781803238012)
    for this book and share your feedback.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您阅读了《Golang中的函数式编程》，我们很乐意听到您的想法！请[点击此处直接进入此书的亚马逊评论页面](https://packt.link/r/9781803238012)并分享您的反馈。
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论对我们和科技社区非常重要，并将帮助我们确保我们提供高质量的内容。
- en: Download a free PDF copy of this book
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载此书的免费PDF副本
- en: Thanks for purchasing this book!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您购买此书！
- en: Do you like to read on the go but are unable to carry your print books everywhere?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您喜欢在路上阅读，但无法随身携带您的印刷书籍吗？
- en: Is your eBook purchase not compatible with the device of your choice?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电子书购买是否与您选择的设备不兼容？
- en: Don’t worry, now with every Packt book you get a DRM-free PDF version of that
    book at no cost.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，现在，随着每本Packt书籍，您都可以免费获得该书的DRM免费PDF版本。
- en: Read anywhere, any place, on any device. Search, copy, and paste code from your
    favorite technical books directly into your application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何地方、任何设备上阅读。直接从您最喜欢的技术书籍中搜索、复制和粘贴代码到您的应用程序中。
- en: The perks don’t stop there, you can get exclusive access to discounts, newsletters,
    and great free content in your inbox daily
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 优惠远不止于此，您还可以获得独家折扣、时事通讯和每日免费内容的每日电子邮件。
- en: 'Follow these simple steps to get the benefits:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤获取好处：
- en: Scan the QR code or visit the link below
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描下面的二维码或访问以下链接
- en: '![](img/B18771_QR_Free_PDF.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18771_QR_Free_PDF.jpg)'
- en: '[https://packt.link/free-ebook/9781801811163](https://packt.link/free-ebook/9781801811163)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/free-ebook/9781801811163](https://packt.link/free-ebook/9781801811163)'
- en: Submit your proof of purchase
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交您的购买证明
- en: That’s it! We’ll send your free PDF and other benefits to your email directly
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这些！我们将直接将您的免费PDF和其他优惠发送到您的邮箱。
- en: 'Part 1: Functional Programming Paradigm Essentials'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1部分：函数式编程范式基础
- en: In this part, we will take a look at what the functional programming paradigm
    entails. We’ll look at how it compares to the traditional object-oriented approach,
    and learn some language design differences between programming languages in each
    paradigm. We’ll also discuss what it means for Go to be a multi-paradigm language
    and see how this benefits our use case. Finally, we’ll look at some key ideas
    in functional programming, which we can leverage to write more readable, maintainable,
    and testable code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将探讨函数式编程范式包含的内容。我们将比较它与传统的面向对象方法，并学习每个范式编程语言之间的语言设计差异。我们还将讨论Go成为多范式语言的意义，并看看这对我们的用例有何好处。最后，我们将探讨函数式编程的一些关键思想，我们可以利用这些思想来编写更易读、可维护和可测试的代码。
- en: 'This part has the following chapters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 1*](B18771_01.xhtml#_idTextAnchor015), *Introducing Functional Programming*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第1章*](B18771_01.xhtml#_idTextAnchor015)，*介绍函数式编程*'
- en: '[*Chapter 2*](B18771_02.xhtml#_idTextAnchor028), *Treating Functions as First-Class
    Citizens*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第二章*](B18771_02.xhtml#_idTextAnchor028), *将函数视为一等公民*'
- en: '[*Chapter 3*](B18771_03.xhtml#_idTextAnchor047)*, Higher-Order Functions*'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第三章*](B18771_03.xhtml#_idTextAnchor047)*, 高阶函数*'
- en: '[*Chapter 4*](B18771_04.xhtml#_idTextAnchor060)*, Write Testable Code with
    Pure Functions*'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第四章*](B18771_04.xhtml#_idTextAnchor060)*, 使用纯函数编写可测试的代码*'
- en: '[*Chapter 5*](B18771_05.xhtml#_idTextAnchor085)*, Immutability*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18771_05.xhtml#_idTextAnchor085)*, 不可变性*'
