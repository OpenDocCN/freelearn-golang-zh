<html><head></head><body>
		<div id="_idContainer010">
			<h1 id="_idParaDest-29" class="chapter-number"><a id="_idTextAnchor028"/>2</h1>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Treating Functions as First-Class Citizens</h1>
			<p>As we established in the previous chapter, the core part of our functional programs will be functions. In this chapter, we are going to cover exactly why functions are powerful in languages that treat them as <strong class="bold">first-class citizens</strong>. Go has functions as first-class citizens out of the box, meaning we get this functionality by default. More and more languages are choosing this approach. In this chapter, we are going to see how this will allow us to create interesting constructs, which will improve the readability and test ability of <span class="No-Break">our code.</span></p>
			<p>Concretely, we are going to cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Benefits of <span class="No-Break">first-class functions</span></li>
				<li>Defining types <span class="No-Break">for functions</span></li>
				<li>Using functions <span class="No-Break">like objects</span></li>
				<li>Anonymous functions versus <span class="No-Break">named functions</span></li>
				<li>Storing functions in data types <span class="No-Break">or structs</span></li>
				<li>Creating a function dispatcher using all <span class="No-Break">the previous</span></li>
			</ul>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>All the examples for this chapter can be found at <a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2</a>. For this example, any Go version <span class="No-Break">will work</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Benefits of first-class functions</h1>
			<p>Before we <a id="_idIndexMarker038"/>talk about “first-class functions,” let’s first define what it means for anything to be called “first-class” in programming language design. When we talk about a “first-class citizen,” we mean an entity (object, primitive, or function) for which all the common language operations are available. These are operations such as assignment, passing it to a function, returning from a function, or storing it in another data type such as <span class="No-Break">a map.</span></p>
			<p>Looking at this list, we can see how all of those operations typically apply to the structs that we are defining in our language. Objects and primitives can be passed around between functions. They are often returned as the results of a function and we definitely assign them to variables. When we say that functions are first-class citizens, you can simply <a id="_idIndexMarker039"/>think of this as treating functions like objects. Their equivalence will help us create all future constructs in this book. They will lead to improved <em class="italic">testability</em>, such as by allowing us to mock functions of a struct, and improved <em class="italic">readability</em>, such as by removing large switch cases for a single <span class="No-Break">function dispatcher.</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Defining types for functions</h1>
			<p>Go is a statically typed language. Although, we don’t have to spell out the type for each assignment – the types <a id="_idIndexMarker040"/>are there under the hood. It is effectively the compiler taking care of this for us. When we work with functions in Go, they are also implicitly assigned a type. While defining a type for a function in the way a compiler does it is a difficult task, we can use the concept of function aliases to add type safety to our <span class="No-Break">code base.</span></p>
			<p>When working with functions throughout the rest of this book, we will often use <strong class="bold">type aliases</strong>. This <a id="_idIndexMarker041"/>will help the compiler provide more readable error messages, and also makes our code more readable in general. Type aliases are, however, not just useful in the context of functions. They are a great feature of Go that is not too often used. It’s also a feature that you won’t easily find in other mainstream languages. So let’s take a dive into what type <span class="No-Break">aliases are.</span></p>
			<p>In essence, a type alias does just what it says on the tin; it creates an alias for a type. It's similar to how in Unix systems you would create an alias for a command. It helps us create a new type that has all the same properties as the original type. One reason why we might want to do this is for readability, as we will see when creating aliases for functions. Another reason is to communicate our intent more clearly when we write code. For example, we could use our type system to define <strong class="source-inline">CountryID</strong> and <strong class="source-inline">CityID</strong> as an alias for <strong class="source-inline">String</strong>. Although both types are a string under the hood, they cannot be used interchangeably in code. Thus they communicate to the reader what the actual expected <span class="No-Break">value is.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Type aliases for primitives</h2>
			<p>A common <a id="_idIndexMarker042"/>pattern to see in object-oriented languages <a id="_idIndexMarker043"/>is that the OO languages turn into <strong class="bold">stringly-oriented</strong> programming. Part of this is due to the overhead of creating a full class for <a id="_idIndexMarker044"/>a type that is, in essence, just a string. Take this example, where we have a <strong class="source-inline">Person</strong> struct, and we want to set a phone number on <span class="No-Break">this struct:</span></p>
			<pre class="source-code">
type Person struct {
	name        string
	phonenumber string
}
func (p *Person) setPhoneNumber(s string) {
	p.phonenumber = s
}</pre>
			<p>In this example, which is heavily influenced by Java, we are creating a “setter-like” function that takes <strong class="source-inline">phonenumber</strong> as a string input and updates our object accordingly. If you are using an IDE that provides type hints for functions you are calling, it will just tell you that the <strong class="source-inline">setPhoneNumberfunction</strong> expects a string, which means any string is valid. Now, if we had a type alias, we could make that hint <span class="No-Break">more useful.</span></p>
			<p>So, let’s make some changes and use a type alias <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">phoneNumber</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type phoneNumber string
type Person struct {
	name        string
	phonenumber phoneNumber
}
func (p *Person) setPhoneNumber(s phoneNumber) {
	p.phonenumber = s
}</pre>
			<p>By making this change, our type is now communicating more clearly with what our intent is, and with none of the overhead of creating a new struct just to model a phone number. We can do this, as a phone number can be thought of as essentially <span class="No-Break">a string.</span></p>
			<p>Using this, because <a id="_idIndexMarker045"/>a type alias is equivalent <a id="_idIndexMarker046"/>to the underlying type, is as easy as using a <span class="No-Break">real string:</span></p>
			<pre class="source-code">
func main() {
	p := Person{
		name:        "John",
		phonenumber: "123",
	}
	fmt.Printf("%v\n", p)
}</pre>
			<p>Okay, great. So we have a name, which is just a string, and <strong class="source-inline">phonenumber</strong>, which is a <strong class="source-inline">phoneNumber</strong> type, which is equal to a string. So where does the benefit come from? Well, part of it is gained in communicating intent. Code is read by many more people than the original author, so we want to be as clear as possible in our code. The other part is in the error messages. Using type aliases, error messages will tell us explicitly what was expected rather than just saying a string was expected. Let’s create a function that can update both <strong class="source-inline">name</strong> and <strong class="source-inline">phonenumber</strong>, and let’s first use <strong class="source-inline">string</strong> <span class="No-Break">for both:</span></p>
			<pre class="source-code">
func (p *Person) update(name, phonenumber string) {
	p.name = name
	p.phonenumber = phonenumber
}</pre>
			<p>What happens when we try to compile our code? Well, we will get the <span class="No-Break">following error:</span></p>
			<pre class="source-code">
./prog.go:26:18: cannot use phonenumber (variable of type 
  string) as type phoneNumber in assignment</pre>
			<p>In this simple example, it doesn’t do much. But as your code base expands, this ensures that all developers are thinking about the type that should be passed into a function. This lowers the risk of errors by passing invalid data to a function. An additional benefit, depending on the IDE, is that your IDE will also show you the signature. If you had a large function that takes five different types of string, your IDE might just show you <em class="italic">function expects input (string, string, string, string, string)</em>, with no clear order in which arguments need to be passed. If each string is a distinct type, this might become <em class="italic">name, phonenumber, email, street, country</em>. Especially in a language such as Go, where single-letter variable names are often used, this can create <span class="No-Break">readability benefits.</span></p>
			<p>To make <a id="_idIndexMarker047"/>our code work, we just have to make a <a id="_idIndexMarker048"/>small change to the <span class="No-Break">function signature:</span></p>
			<pre class="source-code">
func (p *Person) update(name string, phonenumber phoneNumber) {
	p.name = name
	p.phonenumber = phonenumber
}</pre>
			<p>This is an easy fix and amounts to just a small change, but doing it consistently makes your code convey more meaning just with the type system. In the end, types are there to convey meaning to other readers as well as <span class="No-Break">the compiler.</span></p>
			<p>Let’s take a look at another benefit of type aliases. Let’s add an <strong class="source-inline">age</strong> field to our struct with its own <span class="No-Break">type alias:</span></p>
			<pre class="source-code">
type age uint
type Person struct {
	name        string
	age         age
	phonenumber phoneNumber
}</pre>
			<p>One thing that we cannot do with primitive types in Go such as <strong class="source-inline">uint</strong> is to attach functions to them. When we assign a type alias, however, that restriction is gone. Hence, now we can attach functions to the <strong class="source-inline">age</strong> type, which really is just attaching a function <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">uint</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func (a age) valid() bool {
	return a &lt; 120
}
func isValidPerson(p Person) bool {
	return p.age.valid() &amp;&amp; p.name != ""
}</pre>
			<p>In the preceding code, we are creating a <strong class="source-inline">valid</strong> function, which is bound to the <strong class="source-inline">age</strong> type. In other functions, we can now call the <strong class="source-inline">valid()</strong> function on this type with the familiar dot notation. This example is a bit trivial, but it’s something that would not work on a <span class="No-Break">primitive type.</span></p>
			<p>If we <a id="_idIndexMarker049"/>tried to attach a function to a primitive, we <a id="_idIndexMarker050"/>would not be able to compile <span class="No-Break">our program:</span></p>
			<pre class="source-code">
func (u uint) valid() bool {
	return u &lt; 120
}</pre>
			<p>This throws the <span class="No-Break">following error:</span></p>
			<pre class="source-code">
./prog.go:30:7: cannot define new methods on non-local type 
  uint
Go build failed.</pre>
			<p>This alone makes type aliases quite powerful. It also means you can now extend types that are not created by you in your code base. You might be working with an external library that exposes a struct, but you want to add your own functionality to it. One way of doing that is by creating a type alias and extending it with your own functionality. While diving into this example is too in-depth for what we’re exploring in this chapter, suffice it to say that type aliases are a <span class="No-Break">powerful construct.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Type aliases for functions</h2>
			<p>As a <a id="_idIndexMarker051"/>function is a <em class="italic">first-class citizen</em> in Go, we can <a id="_idIndexMarker052"/>work with them like we would with any other data type. Thus, just as we can create a type alias for a variable or a struct, we can also create a type alias for <span class="No-Break">a function.</span></p>
			<p>Why might we want to do this? The main benefit for the reader of our code will be the clarity and readability it creates. Look at the following piece of code for a <span class="No-Break"><strong class="source-inline">filter</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func filter(is []int, predicate func(int) bool) []int {
	out := []int{}
	for _, i := range is {
		if predicate(i) {
			out = append(out, i)
		}
	}
	return out
}</pre>
			<p>This function is a good example of using functions as first-class citizens. Here, the <strong class="source-inline">predicate</strong> function is a function that is passed to the <strong class="source-inline">filter</strong> function. It is passed around in the same way in which we would typically pass <span class="No-Break">around objects.</span></p>
			<p>If we want to clean up this function signature, we can introduce a type alias and rewrite the <span class="No-Break">filter function:</span></p>
			<pre class="source-code">
type predicate func(int) bool
func filter(is []int, p predicate) []int {
	out := []int{}
	for _, i := range is {
		if p(i) {
			out = append(out, i)
		}
	}
	return out
}</pre>
			<p>Here, you can see that the second argument now takes the <strong class="source-inline">predicate</strong> type. The compiler will translate this type to <strong class="source-inline">func(int) bool</strong>, but we can just write <strong class="source-inline">predicate</strong> throughout our <span class="No-Break">code base.</span></p>
			<p>Another benefit <a id="_idIndexMarker053"/>of introducing a type alias is that our error <a id="_idIndexMarker054"/>messages become more readable. Let’s imagine we pass a function to <strong class="source-inline">filter</strong> that does not adhere to the <strong class="source-inline">predicate</strong> <span class="No-Break">type declaration:</span></p>
			<pre class="source-code">
	filter(ints, func(i int, s string) bool { return i &gt; 2 })</pre>
			<p>Without a type alias, the error message reads <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
./prog.go:9:15: cannot use func(i int, s string) bool {…} 
(value of type func(i int, s string) bool) as type func(int) 
bool in argument to filter</pre>
			<p>That’s an error message that, while being quite explicit, is quite verbose to read. With the type alias, the message will tell us what type of function <span class="No-Break">we expected:</span></p>
			<pre class="source-code">
./prog.go:9:15: cannot use func(i int, s string) bool {…} 
(value of type func(i int, s string) bool) as type predicate in 
argument to filter</pre>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Using functions as objects</h1>
			<p>In the preceding section, we saw how to create type aliases to make our code more readable <a id="_idIndexMarker055"/>when dealing with functions. In this section, let’s take a brief look at how functions can be used in the same way as objects. This is the essence of what it means to <span class="No-Break">be </span><span class="No-Break"><em class="italic">first-class</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Passing functions to functions</h2>
			<p>We can <a id="_idIndexMarker056"/>pass functions to functions as in the preceding <span class="No-Break">filter function:</span></p>
			<pre class="source-code">
type predicate func(int) bool
func largerThanTwo(i int) bool {
	return i &gt; 2
}
func filter(is []int, p predicate) []int {
	out := []int{}
	for _, i := range is {
		if p(i) {
			out = append(out, i)
		}
	}
	return out
}
func main() {
	ints := []int{1, 2, 3}
	filter(ints, largerThanTwo)
}</pre>
			<p>In this example, we have created the <strong class="source-inline">largerThanTwo</strong> function, which adheres to the <strong class="source-inline">predicate</strong> type alias. Note that we don’t have to specify anywhere that this function adheres to our <strong class="source-inline">predicate</strong> type; the compiler will figure this out during compile time, just like it does for regular variables. Next, we have created a <strong class="source-inline">filter</strong> function, which expects both a slice of <strong class="source-inline">ints</strong> as well as a <strong class="source-inline">predicate</strong> function. In our <strong class="source-inline">main</strong> function, we create a slice of <strong class="source-inline">ints</strong> and call the <strong class="source-inline">filter</strong> function with the <strong class="source-inline">largerThanTwo</strong> function as the <span class="No-Break">second parameter.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>In-line function definitions</h2>
			<p>We don’t <a id="_idIndexMarker057"/>have to create functions such as <strong class="source-inline">largerThanTwo</strong> in the package scope. We can create functions inline, in the same way in which we can create <span class="No-Break">structs inline:</span></p>
			<pre class="source-code">
func main() {
	// functions in variables
	inlinePersonStruct := struct {
		name string
	}{
		name: "John",
	}
	ints := []int{1, 2, 3}
	inlineFunction := func(i int) bool { return i &gt; 2 }
	filter(ints, inlineFunction)
}</pre>
			<p>The <strong class="source-inline">inlinePersonStruct</strong> is shown in this code as an example of how the inline function compares to the inline struct definition. The code won’t actually compile with this struct present as it’s not used in the rest of our <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Anonymous functions</h2>
			<p>We can <a id="_idIndexMarker058"/>also create functions on the fly where they are needed. These are called <em class="italic">anonymous</em> functions as they don’t have a name assigned to them. Continuing with our <strong class="source-inline">filter</strong> function, the anonymous function version of a <strong class="source-inline">largerThanTwo</strong> predicate would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func main() {
	filter([]int{1, 2, 3}, func(i int) bool { return i &gt; 2 })
}</pre>
			<p>In the preceding example, we are both creating a slice of integers as well as the predicate <a id="_idIndexMarker059"/>function inline. Neither of them is named. The slice cannot be referenced anywhere else in that <strong class="source-inline">main</strong> function and neither can the function. While function definitions like these tend to make our code more verbose and can hinder readability, we will see applications of them in <a href="B18771_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> and <a href="B18771_04.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Returning functions from functions</h2>
			<p>A core concept of any programming language is returning a value from a function. As a function <a id="_idIndexMarker060"/>is treated just like a regular object, we can return a function from <span class="No-Break">a function.</span></p>
			<p>In the earlier examples, our predicate <strong class="source-inline">largerThanTwo</strong> function always checked whether or not an integer was larger than two. Now, let’s create a function that can generate such <span class="No-Break">predicate functions:</span></p>
			<pre class="source-code">
func createLargerThanPredicate(threshold int) predicate {
	return func(i int) bool {
		return i &gt; threshold
	}
}</pre>
			<p>In this example, we have created a <strong class="source-inline">createLargerThanPredicate</strong> function, which returns a <strong class="source-inline">predicate</strong>. Remember that the type <strong class="source-inline">predicate</strong> is just a type alias for a function that takes an integer as input and returns a bool as output. Next, we define the function that we are returning in the <span class="No-Break">function body.</span></p>
			<p>The function we are returning follows the type signature of <strong class="source-inline">predicate</strong>, and it returns true if <strong class="source-inline">i</strong> is larger than <strong class="source-inline">threshold</strong>. Notice that the <strong class="source-inline">i</strong> function is not passed to the <strong class="source-inline">createLargerThanPredicate</strong> function itself. We have defined that inline. When we call the <strong class="source-inline">createLargerThanPredicate</strong> function, we don’t get the outcome of the predicate function, but rather we get a new function that follows the <span class="No-Break">inner signature:</span></p>
			<pre class="source-code">
func main() {
	ints := []int{1, 2, 3}
	largerThanTwo := createLargerThanPredicate(2)
	filter(ints, largerThanTwo)
}</pre>
			<p>Here, in the <strong class="source-inline">main</strong> function, we first call the <strong class="source-inline">createLargerThanPredicate(2)</strong> function. This returns a new <strong class="source-inline">func(i int) bool</strong> function. The <strong class="source-inline">2</strong> here refers to the <strong class="source-inline">threshold</strong> parameter, not the <span class="No-Break"><strong class="source-inline">i</strong></span><span class="No-Break"> parameter.</span></p>
			<p>On the <a id="_idIndexMarker061"/>next line, we can once again call the <strong class="source-inline">filter</strong> function with the newly created <span class="No-Break"><strong class="source-inline">largerThanTwo</strong></span><span class="No-Break"> function.</span></p>
			<p>Returning functions from functions will be a core concept when we dive into more advanced topics such as <em class="italic">continuation-passing style</em> programming and function currying. For now, the main takeaway is that this allows us to create customizable functions on the fly. For example, we could create a series of “larger than” predicates each with its <span class="No-Break">own threshold:</span></p>
			<pre class="source-code">
 func main() {
	largerThanTwo := createLargerThanPredicate(2)
	largerThanFive := createLargerThanPredicate(5)
	largerThanHundred := createLargerThanPredicate(100)
}</pre>
			<p>Notice that this example won’t compile, as we’re not using the functions anywhere in the remainder of the <strong class="source-inline">main</strong> block. But this shows us how we can essentially “spawn” functions with one parameter fixed. Instead of creating these functions inside function blocks, we can move them up to the package-specific <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> block.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Functions in var</h2>
			<p>Continuing <a id="_idIndexMarker062"/>the preceding example, we can create a series of functions that can be used throughout <span class="No-Break">our package:</span></p>
			<pre class="source-code">
var (
	largerThanTwo     = createLargerThanPredicate(2)
	largerThanFive    = createLargerThanPredicate(5)
	largerThanHundred = createLargerThanPredicate(100)
)</pre>
			<p>These “function factories” allow us to create some customized functions throughout our code. One thing to note here is that this will work inside <strong class="source-inline">var</strong> blocks, but will not compile if we move these to a <span class="No-Break"><strong class="source-inline">const</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
const (
	largerThanTwo      = createLargerThanPredicate(2)
	largerThanFive     = createLargerThanPredicate(5)
	largerThanHundred  = createLargerThanPredicate(100)
)</pre>
			<p>This will generate the <span class="No-Break">following errors:</span></p>
			<pre class="source-code">
./prog.go:8:23: createLargerThanPredicate(2) (value of type 
predicate) is not constant
./prog.go:9:23: createLargerThanPredicate(5) (value of type 
predicate) is not constant
./prog.go:10:23: createLargerThanHundred(100) (value of type 
predicate) is not constant</pre>
			<p>Our functions are not considered “constants” from a <span class="No-Break">package perspective.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Functions inside data structures</h2>
			<p>So far, we <a id="_idIndexMarker063"/>have been creating a bunch of functions that were either defined at the top-level <strong class="source-inline">var</strong> block or inline inside a function. What if we want to store our function somewhere in the runtime memory of <span class="No-Break">our application?</span></p>
			<p>Well, just like we can store primitives and structs inside our runtime memory, we can store functions there <span class="No-Break">as well.</span></p>
			<p>Let’s start off by storing our <strong class="source-inline">largerThan</strong> predicates in an array. We’ll move the predicate <a id="_idIndexMarker064"/>declarations back to the <strong class="source-inline">var</strong> block and pass them to a <strong class="source-inline">filter</strong> function in our <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
var (
	largerThanTwo     = createLargerThanPredicate(2)
	largerThanFive    = createLargerThanPredicate(5)
	largerThanHundred = createLargerThanPredicate(100)
)
func main() {
	ints := []int{1, 2, 3, 6, 101}
	predicates := []predicate{largerThanTwo, largerThanFive, 
        largerThanHundred}
	for _, predicate := range predicates {
		fmt.Printf("%v\n", filter(ints, predicate))
	}
}</pre>
			<p>In the preceding example, we have created a “slice of predicates.” The type would be <strong class="source-inline">[]predicate</strong>, and as part of the declaration, we have also pushed the three predicates we created earlier to this slice. After this line, the slice contains a reference to the three functions: <strong class="source-inline">largerThanTwo</strong>, <strong class="source-inline">largerThanFive</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">largerThanHundred</strong></span><span class="No-Break">.</span></p>
			<p>Once we have created this slice, we can iterate over it just like any regular slice. When we write <strong class="source-inline">for _, predicate := range predicates</strong>, the value of <strong class="source-inline">predicate</strong> takes on the value of each function we stored in the slice, sequentially. Thus, when we print the output of our filter function for each subsequent iteration, we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[3 6 101]
[6 101]
[101]</pre>
			<p>In the <a id="_idIndexMarker065"/>first iteration, <strong class="source-inline">predicate</strong> refers to the <strong class="source-inline">largerThanTwofunction</strong>; in the second iteration, it becomes <strong class="source-inline">largerThanFive</strong>, and finally <span class="No-Break">becomes </span><span class="No-Break"><strong class="source-inline">largerThanHundred</strong></span><span class="No-Break">.</span></p>
			<p>Similarly, we can store functions inside <span class="No-Break">a map:</span></p>
			<pre class="source-code">
func main() {
	ints := []int{1, 2, 3, 6, 101}
	dispatcher := map[string]predicate{
		"2": largerThanTwo,
		"5": largerThanFive,
	}
	fmt.Printf("%v\n", filter(ints, dispatcher["2"]))
}</pre>
			<p>In this example, we create a map that stores predicates and associates the predicate function with a string as the key. We can then call the <strong class="source-inline">filter</strong> function and ask the map to return the function associated with the <strong class="source-inline">"2"</strong> key. This returns <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[3 6 101]</pre>
			<p>This pattern is quite powerful, which we’ll explore later in this chapter, in <span class="No-Break"><em class="italic">Example 1</em></span><span class="No-Break">.</span></p>
			<p>Before we dive into that example, let’s take a look at storing functions <span class="No-Break">inside structs.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Functions inside structs</h2>
			<p>By now, it should come as no surprise that wherever we can use a data type, a function can play <a id="_idIndexMarker066"/>that role. Let’s see how this plays out for structs. Let’s create a struct called <strong class="source-inline">ConstraintChecker</strong>, which checks whether or not a value is in between <span class="No-Break">two values.</span></p>
			<p>Let’s start off by defining our struct. The <strong class="source-inline">ConstraintChecker</strong> struct has two fields. Each field is a function of type <strong class="source-inline">predicate</strong>. The first function is <strong class="source-inline">largerThan</strong> and the second is <strong class="source-inline">smallerThan</strong>. These are the boundaries between which the input number <span class="No-Break">should lie:</span></p>
			<pre class="source-code">
type ConstraintChecker struct {
	largerThan  predicate
	smallerThan predicate
}</pre>
			<p>Next, we create a method for this struct. The <strong class="source-inline">check</strong> method takes an integer input and passes this on to the <strong class="source-inline">largerThan</strong> and <strong class="source-inline">smallerThan</strong> functions, respectively. As both predicate functions return a bool, we simply check that the input returns true for both <span class="No-Break">these functions:</span></p>
			<pre class="source-code">
func (c ConstraintChecker) check(input int) bool {
	return c.largerThan(input) &amp;&amp; c.smallerThan(input)
}</pre>
			<p>Now that we have our struct and our method created, let’s take a look at how we would use <span class="No-Break">this struct:</span></p>
			<pre class="source-code">
func main() {
	checker := ConstraintChecker{
		largerThan:  createLargerThanPredicate(2),
		smallerThan: func(i int) bool { return i &lt; 10 },
	}
	fmt.Printf("%v\n", checker.check(5))
}</pre>
			<p>In our main function, we first instantiate the functions. Note that we can create the <strong class="source-inline">ConstraintChecker</strong> struct both by providing an existing function, as we have done for <strong class="source-inline">largerThan</strong>, as well as by using an anonymous function as is the case for the <span class="No-Break"><strong class="source-inline">smallerThan</strong></span><span class="No-Break"> field.</span></p>
			<p>This shows <a id="_idIndexMarker067"/>how a struct can store functions, and how these functions can be treated just like any other field in the struct. In essence, we could treat each function that is <strong class="bold">bound</strong> to a struct as a function that is a <strong class="bold">field</strong> of the struct. There are advantages to passing functions as a field versus binding it, which we will explore in more detail later, in <em class="italic">Example 2</em> in <span class="No-Break">this chapter.</span></p>
			<p>The main difference is that a function that is bound is essentially constant – the implementation does not change. Whereas a function passed to a field is entirely flexible. The actual implementation is unknown to our struct. We’ll explore in more detail how this allows us to mock functions for testing in <span class="No-Break"><em class="italic">Example 2</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Example 1 – map dispatcher</h1>
			<p>One pattern <a id="_idIndexMarker068"/>that is enabled by these types of first-class functions is the “map dispatcher pattern.” This is a pattern where we use a map of “key <span class="No-Break">to function.”</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Creating a simple calculator</h2>
			<p>For this first example, let’s build a really simple calculator. This is just to demonstrate the idea <a id="_idIndexMarker069"/>of dispatching functions based on a certain input value. In this case, we are going to build a calculator that takes two integers as input, an operation, and returns the result of this operation to the user. For this first example, we are only supporting the addition, subtraction, multiplication, and <span class="No-Break">division operations.</span></p>
			<p>First, let’s define the basic functions that <span class="No-Break">are supported:</span></p>
			<pre class="source-code">
func add(a, b int) int {
	return a + b
}
func sub(a, b int) int {
	return a - b
}
func mult(a, b int) int {
	return a + b
}
func div(a, b int) int {
	if b == 0 {
		panic("divide by zero")
	}
	return a / b
}</pre>
			<p>So far, this is all pretty standard stuff. We have a few functions that our calculator supports. In most cases, the result is returned instantly, but for the division function, we’ll do a <a id="_idIndexMarker070"/>quick check to make sure we’re not dividing by zero and panic otherwise. In a real application, we’d avoid the <strong class="source-inline">panic</strong> operation as much as possible, but for this example, it doesn’t really have any impact. No users were harmed by having a panic in <span class="No-Break">this example!</span></p>
			<p>Next, let’s take a look at how we’d implement the <strong class="source-inline">calculate</strong> function, which takes two numbers and the desired operation. We’ll implement this first without considering functions as first-class citizens and use a <strong class="source-inline">switch</strong> statement instead to decide which operation <span class="No-Break">to dispatch:</span></p>
			<pre class="source-code">
func calculate(a, b int, operation string) int {
	switch operation {
	case "+":
		return add(a, b)
	case "-":
		return sub(a, b)
	case "*":
		return mult(a, b)
	case "/":
		return div(a, b)
	default:
		panic("operation not supported")
	}
}</pre>
			<p>Each branch of the <strong class="source-inline">switch</strong> statement performs the desired operation on our numbers and returns the result. If the options are exhausted and nothing matched the input, we panic. Each time we added a new function to our calculator, we would have to extend this function <a id="_idIndexMarker071"/>with another branch. Over time, this might not be the most readable option. So let’s look at an alternative using what we’ve learned so far in <span class="No-Break">this chapter.</span></p>
			<p>First, let’s introduce a type for these kinds <span class="No-Break">of functions:</span></p>
			<pre class="source-code">
type calculateFunc func(int, int) int</pre>
			<p>Next, let’s create a map where we can bind the string input of a user to a <span class="No-Break">calculator function:</span></p>
			<pre class="source-code">
var (
	operations = map[string]calculateFunc{
		"+": add,
		"-": sub,
		"*": mult,
		"/": div,
	}
)</pre>
			<p>This map is called <strong class="source-inline">operations</strong>. The key of the map is the input the user will provide, which is the operations we support in our calculator. We have bound each input to a specific <span class="No-Break">function call.</span></p>
			<p>Now, if we want to implement the actual <strong class="source-inline">calculate</strong> function, we just have to look up the key in our map and call the corresponding function. If the requested operation does not match <a id="_idIndexMarker072"/>a key in our map, we’ll panic. This is similar to the default branch in the <span class="No-Break">switch-based approach:</span></p>
			<pre class="source-code">
func calculateWithMap(a, b int, opString string) int {
	if operation, ok := operations[opString]; ok {
		return operation(a, b)
	}
	panic("operation not supported")
}</pre>
			<p>This way, we can replace <strong class="source-inline">Switch</strong> statements with a map dispatcher. Also remember also that a map lookup is typically done in constant time, so this implementation of a function dispatcher is fairly efficient. It does require us to use a bit more memory to bind keys to functions, but this is negligible. With this approach, adding a new operation is a matter of adding a new entry to our map rather than extending the <span class="No-Break"><strong class="source-inline">switch</strong></span><span class="No-Break"> statement.</span></p>
			<p>With the use of anonymous functions, we could also define the dispatched function inline. For example, this is how we would extend the map with <span class="No-Break">bitshift functions:</span></p>
			<pre class="source-code">
var (
	operations = map[string]calculateFunc{
		"+": add,
		"-": sub,
		"*": mult,
		"/": div,
		"&lt;&lt;": func(a, b int) int { return a &lt;&lt; b },
		"&gt;&gt;": func(a, b int) int { return a &gt;&gt; b },
	 }
)</pre>
			<p>In this way, we can <a id="_idIndexMarker073"/>create a map dispatcher for anonymous functions. This could become rather verbose to read though, so use your best judgment when <span class="No-Break">applying this.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Example 2 – mocking functions for testing</h1>
			<p>In the following example, we will take a look at mocking functions using what we have learned so <a id="_idIndexMarker074"/>far in this chapter. The application we will be building and testing is a simple to-do application. The to-do application simply allows a user to add text to a to-do, to overwrite <span class="No-Break">all content.</span></p>
			<p>We won’t be using an actual database, so we’ll imagine that this one exists and use the filesystem and program arguments instead. Our goal will be to create tests for this application where we can mock the database interactions. To achieve this, we will use functions as first-class citizens and type aliases for <span class="No-Break">code readability.</span></p>
			<p>The complete example can be found on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2/Examples/TestingExample"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2/Examples/TestingExample</span></a></p>
			<p>Let’s start by setting up our main structs. The two structs we will need are <strong class="source-inline">Todo</strong> and <strong class="source-inline">Db</strong>. The <strong class="source-inline">Todo</strong> struct represents the to-do item, which will contain a piece of text. The struct also contains a reference to a <span class="No-Break"><strong class="source-inline">Db</strong></span><span class="No-Break"> struct:</span></p>
			<pre class="source-code">
type Todo struct {
	Text string
	Db   *Db
}
func NewTodo() Todo {
	return Todo{
		Text: "",
		Db:   NewDB(),
	}
}</pre>
			<p>In this example, we also created a “constructor” function, to ensure that users get a correctly <span class="No-Break">initialized object.</span></p>
			<p>We will add two functions bound to this struct: <strong class="source-inline">Write</strong> and <strong class="source-inline">Append</strong>. The <strong class="source-inline">Write</strong> function will override the content of the <strong class="source-inline">Text</strong> field, while the <strong class="source-inline">Append</strong> function will add content <a id="_idIndexMarker075"/>to the existing field’s content. Let’s also assume that any call to these functions can only be done by authorized users. As such, we’ll first make a database call to figure out whether the user is authorized to perform <span class="No-Break">this action:</span></p>
			<pre class="source-code">
func (t *Todo) Write(s string){
	if t.Db.IsAuthorized() {
		t.Text = s
	} else {
		panic("user not authorized to write")
	}
}
func (t *Todo) Append(s string) {
	if t.Db.IsAuthorized() {
		t.Text += s
	} else {
		panic("user not authorized to append")
	}
}</pre>
			<p>With this in place, let’s take a look at the fake database. As we want to be able to mock our database’s functions in the tests that we will write later, we will leverage the concept of first-class functions. First, we’ll create a <strong class="source-inline">Db</strong> struct. As we are only pretending that we are connecting to a real database, we won’t bother with setting up the connection and having an actual database <span class="No-Break">running somewhere:</span></p>
			<pre class="source-code">
type authorizationFunc func() bool
type Db struct {
	AuthorizationFn authorizationFunc
}</pre>
			<p>This is the <a id="_idIndexMarker076"/>struct definition of <strong class="source-inline">Db</strong>. Remember that functions can be stored as fields in a struct. And that’s what’s happening here, our <strong class="source-inline">Db</strong> struct contains a single field called <strong class="source-inline">AuthorizationFn</strong>. This is a reference to a function of type <strong class="source-inline">authorizationFunc</strong>. Remember that this is just a type alias. The compiler will actually expect a function with the <strong class="source-inline">func() bool</strong> signature. Thus, we are expecting a function that takes no arguments as input and returns <span class="No-Break">a bool.</span></p>
			<p>Now, let’s create such an authorization function. As this example is self-contained, we’re not interested in the overhead of having an actual database in use. For this example, assume that a user is authorized if the program arguments contain the <strong class="source-inline">admin</strong> string as the first argument to <span class="No-Break">our program:</span></p>
			<pre class="source-code">
func argsAuthorization() bool {
	user := os.Args[1]
	// super secure authorization layer
	// in a real application, this would be a database call
	if user == "admin" {
		return true
	}
	return false
}</pre>
			<p>Notice that this function matches the function signature for the type <strong class="source-inline">authorizationFunc</strong>. As such, this can be stored inside the <strong class="source-inline">authorizationFn</strong> field of our <strong class="source-inline">Db</strong> struct. Next, let’s create a constructor type function for our <strong class="source-inline">Db</strong> so we can give users a correctly <span class="No-Break">initialized struct:</span></p>
			<pre class="source-code">
func NewDB() *Db {
	return &amp;Db{
		AuthorizationFn: argsAuthorization,
	}
}</pre>
			<p>Notice how <a id="_idIndexMarker077"/>we are passing the <strong class="source-inline">argsAuthorization</strong> function to the <strong class="source-inline">AuthorizationFn</strong> field. Whenever we are creating a database, we can thus change the implementation of <strong class="source-inline">AuthorizationFn</strong> to match our use case. We’ll leverage this for unit testing later, but you could also leverage this to provide different authorization implementations, thus improving the reusability of <span class="No-Break">our struct.</span></p>
			<p>A handy construct to introduce here is to also create a function bound to the <strong class="source-inline">Db</strong> object, which will call the inner <span class="No-Break">authorization function:</span></p>
			<pre class="source-code">
func (d *Db) IsAuthorized() bool {
	return d.AuthorizationFn()
}</pre>
			<p>This is a simple quality-of-life improvement. In this way, we could add code to <strong class="source-inline">IsAuthorized</strong>, which runs regardless of which implementation is chosen for the authorization function. We could add logs here for debugging, collecting metrics, handling potential exceptions, and so forth. In our case, we’ll keep it as a simple function call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">AuthorizationFn</strong></span><span class="No-Break">.</span></p>
			<p>With this in place, let’s now think about testing our code. Without mocking the <strong class="source-inline">IsAuthorized</strong> function, our tests would fail the <strong class="source-inline">Write</strong> and <strong class="source-inline">Append</strong> tests, as only authorized users can call those functions. Our test runs should not depend on the “outside world” to succeed. Unit tests should run in isolation without caring about real underlying systems (in this case, program arguments, but in a real scenario, the <span class="No-Break">actual database).</span></p>
			<p>So, how do we get around this? We will mock the <strong class="source-inline">authorizationFn</strong> implementation by creating a <strong class="source-inline">Db</strong> struct with our own <strong class="source-inline">AuthorizationFn</strong> in <span class="No-Break">its place:</span></p>
			<pre class="source-code">
func TestTodoWrite(t *testing.T) {
	todo := pkg.Todo{
		Db: &amp;pkg.Db{
			AuthorizationF: func() bool { return true },
		},
	}
	todo.Write("hello")
	if todo.Text != "hello" {
		t.Errorf("Expected 'hello' but got %v\n", todo.Text)
	}
	todo.Append(" world")
	if todo.Text != "hello world" {
		t.Errorf("Expected 'hello world' but got %v\n", 
          todo.Text)
	}
}</pre>
			<p>Notice how <a id="_idIndexMarker078"/>in the setup of this test, we are manually constructing a <strong class="source-inline">Todo</strong> struct rather than calling the constructor-type <strong class="source-inline">newTodo()</strong> function. We’re also manually constructing <strong class="source-inline">Db</strong>. This is to avoid the default implementation from running in our unit tests. Instead of using the existing function found in the code, we’re providing a custom authorization function. Our custom function simply returns true for every call to <strong class="source-inline">IsAuthorized</strong>. This is the desired behavior in our test case, as we want to test the functionality of the <strong class="source-inline">Todo</strong> struct rather than that of <strong class="source-inline">Db</strong>. Using this pattern, we can mock core parts of our implementation. We also get the additional benefit that our structs themselves have become more flexible, as implementations can now be swapped out even <span class="No-Break">at runtime.</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Summary</h1>
			<p>In this chapter, we have taken a look at what first-class functions are and what type of use cases they open up to us as Go developers. We have taken a look at the equivalence between functions and objects, such as how they can be instantiated, passed around as parameters, stored inside other data structures, and returned from <span class="No-Break">other functions.</span></p>
			<p>We have also learned how type aliases can be used to create more readable code and to provide clearer error messages. We’ve seen how these can be applied to both functions as well as regular data types for structs <span class="No-Break">and primitives.</span></p>
			<p>In the examples, we have seen how we can create a readable function dispatcher, as well as how we can leverage first-class functions to create mocks of functions. In the next chapter, we will use what we have learned in this chapter to build <span class="No-Break">higher-order functions.</span></p>
		</div>
	</body></html>