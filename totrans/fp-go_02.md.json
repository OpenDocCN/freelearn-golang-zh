["```go\ntype Person struct {\n\tname        string\n\tphonenumber string\n}\nfunc (p *Person) setPhoneNumber(s string) {\n\tp.phonenumber = s\n}\n```", "```go\ntype phoneNumber string\ntype Person struct {\n\tname        string\n\tphonenumber phoneNumber\n}\nfunc (p *Person) setPhoneNumber(s phoneNumber) {\n\tp.phonenumber = s\n}\n```", "```go\nfunc main() {\n\tp := Person{\n\t\tname:        \"John\",\n\t\tphonenumber: \"123\",\n\t}\n\tfmt.Printf(\"%v\\n\", p)\n}\n```", "```go\nfunc (p *Person) update(name, phonenumber string) {\n\tp.name = name\n\tp.phonenumber = phonenumber\n}\n```", "```go\n./prog.go:26:18: cannot use phonenumber (variable of type \n  string) as type phoneNumber in assignment\n```", "```go\nfunc (p *Person) update(name string, phonenumber phoneNumber) {\n\tp.name = name\n\tp.phonenumber = phonenumber\n}\n```", "```go\ntype age uint\ntype Person struct {\n\tname        string\n\tage         age\n\tphonenumber phoneNumber\n}\n```", "```go\nfunc (a age) valid() bool {\n\treturn a < 120\n}\nfunc isValidPerson(p Person) bool {\n\treturn p.age.valid() && p.name != \"\"\n}\n```", "```go\nfunc (u uint) valid() bool {\n\treturn u < 120\n}\n```", "```go\n./prog.go:30:7: cannot define new methods on non-local type \n  uint\nGo build failed.\n```", "```go\nfunc filter(is []int, predicate func(int) bool) []int {\n\tout := []int{}\n\tfor _, i := range is {\n\t\tif predicate(i) {\n\t\t\tout = append(out, i)\n\t\t}\n\t}\n\treturn out\n}\n```", "```go\ntype predicate func(int) bool\nfunc filter(is []int, p predicate) []int {\n\tout := []int{}\n\tfor _, i := range is {\n\t\tif p(i) {\n\t\t\tout = append(out, i)\n\t\t}\n\t}\n\treturn out\n}\n```", "```go\n\tfilter(ints, func(i int, s string) bool { return i > 2 })\n```", "```go\n./prog.go:9:15: cannot use func(i int, s string) bool {…} \n(value of type func(i int, s string) bool) as type func(int) \nbool in argument to filter\n```", "```go\n./prog.go:9:15: cannot use func(i int, s string) bool {…} \n(value of type func(i int, s string) bool) as type predicate in \nargument to filter\n```", "```go\ntype predicate func(int) bool\nfunc largerThanTwo(i int) bool {\n\treturn i > 2\n}\nfunc filter(is []int, p predicate) []int {\n\tout := []int{}\n\tfor _, i := range is {\n\t\tif p(i) {\n\t\t\tout = append(out, i)\n\t\t}\n\t}\n\treturn out\n}\nfunc main() {\n\tints := []int{1, 2, 3}\n\tfilter(ints, largerThanTwo)\n}\n```", "```go\nfunc main() {\n\t// functions in variables\n\tinlinePersonStruct := struct {\n\t\tname string\n\t}{\n\t\tname: \"John\",\n\t}\n\tints := []int{1, 2, 3}\n\tinlineFunction := func(i int) bool { return i > 2 }\n\tfilter(ints, inlineFunction)\n}\n```", "```go\nfunc main() {\n\tfilter([]int{1, 2, 3}, func(i int) bool { return i > 2 })\n}\n```", "```go\nfunc createLargerThanPredicate(threshold int) predicate {\n\treturn func(i int) bool {\n\t\treturn i > threshold\n\t}\n}\n```", "```go\nfunc main() {\n\tints := []int{1, 2, 3}\n\tlargerThanTwo := createLargerThanPredicate(2)\n\tfilter(ints, largerThanTwo)\n}\n```", "```go\n func main() {\n\tlargerThanTwo := createLargerThanPredicate(2)\n\tlargerThanFive := createLargerThanPredicate(5)\n\tlargerThanHundred := createLargerThanPredicate(100)\n}\n```", "```go\nvar (\n\tlargerThanTwo     = createLargerThanPredicate(2)\n\tlargerThanFive    = createLargerThanPredicate(5)\n\tlargerThanHundred = createLargerThanPredicate(100)\n)\n```", "```go\nconst (\n\tlargerThanTwo      = createLargerThanPredicate(2)\n\tlargerThanFive     = createLargerThanPredicate(5)\n\tlargerThanHundred  = createLargerThanPredicate(100)\n)\n```", "```go\n./prog.go:8:23: createLargerThanPredicate(2) (value of type \npredicate) is not constant\n./prog.go:9:23: createLargerThanPredicate(5) (value of type \npredicate) is not constant\n./prog.go:10:23: createLargerThanHundred(100) (value of type \npredicate) is not constant\n```", "```go\nvar (\n\tlargerThanTwo     = createLargerThanPredicate(2)\n\tlargerThanFive    = createLargerThanPredicate(5)\n\tlargerThanHundred = createLargerThanPredicate(100)\n)\nfunc main() {\n\tints := []int{1, 2, 3, 6, 101}\n\tpredicates := []predicate{largerThanTwo, largerThanFive, \n        largerThanHundred}\n\tfor _, predicate := range predicates {\n\t\tfmt.Printf(\"%v\\n\", filter(ints, predicate))\n\t}\n}\n```", "```go\n[3 6 101]\n[6 101]\n[101]\n```", "```go\nfunc main() {\n\tints := []int{1, 2, 3, 6, 101}\n\tdispatcher := map[string]predicate{\n\t\t\"2\": largerThanTwo,\n\t\t\"5\": largerThanFive,\n\t}\n\tfmt.Printf(\"%v\\n\", filter(ints, dispatcher[\"2\"]))\n}\n```", "```go\n[3 6 101]\n```", "```go\ntype ConstraintChecker struct {\n\tlargerThan  predicate\n\tsmallerThan predicate\n}\n```", "```go\nfunc (c ConstraintChecker) check(input int) bool {\n\treturn c.largerThan(input) && c.smallerThan(input)\n}\n```", "```go\nfunc main() {\n\tchecker := ConstraintChecker{\n\t\tlargerThan:  createLargerThanPredicate(2),\n\t\tsmallerThan: func(i int) bool { return i < 10 },\n\t}\n\tfmt.Printf(\"%v\\n\", checker.check(5))\n}\n```", "```go\nfunc add(a, b int) int {\n\treturn a + b\n}\nfunc sub(a, b int) int {\n\treturn a - b\n}\nfunc mult(a, b int) int {\n\treturn a + b\n}\nfunc div(a, b int) int {\n\tif b == 0 {\n\t\tpanic(\"divide by zero\")\n\t}\n\treturn a / b\n}\n```", "```go\nfunc calculate(a, b int, operation string) int {\n\tswitch operation {\n\tcase \"+\":\n\t\treturn add(a, b)\n\tcase \"-\":\n\t\treturn sub(a, b)\n\tcase \"*\":\n\t\treturn mult(a, b)\n\tcase \"/\":\n\t\treturn div(a, b)\n\tdefault:\n\t\tpanic(\"operation not supported\")\n\t}\n}\n```", "```go\ntype calculateFunc func(int, int) int\n```", "```go\nvar (\n\toperations = map[string]calculateFunc{\n\t\t\"+\": add,\n\t\t\"-\": sub,\n\t\t\"*\": mult,\n\t\t\"/\": div,\n\t}\n)\n```", "```go\nfunc calculateWithMap(a, b int, opString string) int {\n\tif operation, ok := operations[opString]; ok {\n\t\treturn operation(a, b)\n\t}\n\tpanic(\"operation not supported\")\n}\n```", "```go\nvar (\n\toperations = map[string]calculateFunc{\n\t\t\"+\": add,\n\t\t\"-\": sub,\n\t\t\"*\": mult,\n\t\t\"/\": div,\n\t\t\"<<\": func(a, b int) int { return a << b },\n\t\t\">>\": func(a, b int) int { return a >> b },\n\t }\n)\n```", "```go\ntype Todo struct {\n\tText string\n\tDb   *Db\n}\nfunc NewTodo() Todo {\n\treturn Todo{\n\t\tText: \"\",\n\t\tDb:   NewDB(),\n\t}\n}\n```", "```go\nfunc (t *Todo) Write(s string){\n\tif t.Db.IsAuthorized() {\n\t\tt.Text = s\n\t} else {\n\t\tpanic(\"user not authorized to write\")\n\t}\n}\nfunc (t *Todo) Append(s string) {\n\tif t.Db.IsAuthorized() {\n\t\tt.Text += s\n\t} else {\n\t\tpanic(\"user not authorized to append\")\n\t}\n}\n```", "```go\ntype authorizationFunc func() bool\ntype Db struct {\n\tAuthorizationFn authorizationFunc\n}\n```", "```go\nfunc argsAuthorization() bool {\n\tuser := os.Args[1]\n\t// super secure authorization layer\n\t// in a real application, this would be a database call\n\tif user == \"admin\" {\n\t\treturn true\n\t}\n\treturn false\n}\n```", "```go\nfunc NewDB() *Db {\n\treturn &Db{\n\t\tAuthorizationFn: argsAuthorization,\n\t}\n}\n```", "```go\nfunc (d *Db) IsAuthorized() bool {\n\treturn d.AuthorizationFn()\n}\n```", "```go\nfunc TestTodoWrite(t *testing.T) {\n\ttodo := pkg.Todo{\n\t\tDb: &pkg.Db{\n\t\t\tAuthorizationF: func() bool { return true },\n\t\t},\n\t}\n\ttodo.Write(\"hello\")\n\tif todo.Text != \"hello\" {\n\t\tt.Errorf(\"Expected 'hello' but got %v\\n\", todo.Text)\n\t}\n\ttodo.Append(\" world\")\n\tif todo.Text != \"hello world\" {\n\t\tt.Errorf(\"Expected 'hello world' but got %v\\n\", \n          todo.Text)\n\t}\n}\n```"]