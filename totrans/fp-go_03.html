<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-48" class="chapter-number"><a id="_idTextAnchor047"/>3</h1>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Higher-Order Functions</h1>
			<p>In this chapter, we are going to explore the concept of function composition through higher-order functions. There are a variety of new concepts that we are introducing here, such as closures, partial application, and function currying. We will take a look at some practical examples and real-world use cases <span class="No-Break">for these.</span></p>
			<p>First, we will cover the core concepts of composing functions from an abstract viewpoint, and then we will combine the concepts in a practical example. Everything that we will learn here leans heavily on the concepts introduced in <a href="B18771_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, where we learned what it means to treat functions as <span class="No-Break">first-class citizens.</span></p>
			<p>In this chapter, we will cover <span class="No-Break">the following:</span></p>
			<ul>
				<li>An introduction to <span class="No-Break">higher-order functions</span></li>
				<li><a id="_idTextAnchor049"/>Closures and <span class="No-Break">variable scoping</span></li>
				<li><span class="No-Break">Partial application</span></li>
				<li>Function currying, or how to reduce n-ary functions to <span class="No-Break">unary functions</span></li>
				<li><span class="No-Break">Examples:</span></li>
			</ul>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Technical requirements</h1>
			<p>All the examples for this chapter can be found at <a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3</a>. For this example, any Go version <span class="No-Break">will work.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>An introduction to higher-order functions</h1>
			<p>In essence, a higher-order function is any function that either takes a function as the input or returns <a id="_idIndexMarker079"/>a function as the output. Recall from the previous chapter that both of these things are made possible through the support for functions as “first-class citizens.” Although it’s perhaps uncommon to call them “higher-order functions,” many programming languages do support these functions out of the box. For example, in Java and Python, the <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">reduce</strong> functions are all examples of <span class="No-Break">higher-order functions.</span></p>
			<p>Let’s create a simple example in Go. We’ll have a function, <strong class="source-inline">A</strong>, that returns <strong class="source-inline">hello,</strong> and a function, <strong class="source-inline">B</strong>, that takes <strong class="source-inline">A</strong> as an input parameter. This is a higher-order function, as the <strong class="source-inline">A</strong> function is used as input <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func A() string {
     return "hello"
}
func B(a A) string {
     return A() + " world"
}</pre>
			<p>It is important to point out here that we’re not simply passing the result of <strong class="source-inline">A</strong> to <strong class="source-inline">B</strong> – we’re actually running the <strong class="source-inline">A</strong> function as part of the execution of <strong class="source-inline">B</strong>. So far, what I’ve shown here is not fundamentally different from anything that we saw in <a href="B18771_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. Indeed, first-class functions are often demonstrated by the implementation of <span class="No-Break">higher-order functions.</span></p>
			<p>When they become interesting is when you start using them for partially applied computation, or when you use them to build function currying, but before we dive into these, let’s look at the concept of <span class="No-Break">closure first.</span></p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Closures and variable scoping</h1>
			<p>Closures are <a id="_idIndexMarker080"/>closely related to how variable scoping works in a given programming language. To fully understand how they work and how they become useful, we will first do a quick refresher on how variable scoping works in Go. Next, we’ll remind ourselves of how anonymous functions work and what they are. Finally, we will take a look at what closures are in this context. This will set us up to properly understand <a id="_idIndexMarker081"/>partial application and function currying when we get to those techniques later in <span class="No-Break">the chapter.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Variable scoping in Go</h2>
			<p>Variable scoping in Go is <a id="_idIndexMarker082"/>done by what is called <strong class="bold">lexical scoping</strong>. This means <a id="_idIndexMarker083"/>that a variable is identified and usable within the context <a id="_idIndexMarker084"/>where it was created. In Go, “blocks” are used to delineate locations in code. For example, see <span class="No-Break">the following:</span></p>
			<pre class="source-code">
package main
import "fmt"
// location 1
func main() {
     // location 2
     b := true
     if b {
          // location 3
          fmt.Println(b)
     }
}</pre>
			<p>There are three locations of scope in <span class="No-Break">this code:</span></p>
			<ul>
				<li>The first one, <strong class="source-inline">location 1</strong>, is the package scope. Our main function sits at this level <span class="No-Break">of scoping.</span></li>
				<li>The next location is inside our <strong class="source-inline">main</strong> function. This is where we are defining the <span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break"> Boolean.</span></li>
				<li>The third location is inside the <strong class="source-inline">if</strong> statement. In Go, and many other languages, the block is defined by <span class="No-Break">curly braces.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">As a rule, variables that are defined at a “higher location” are available at a lower location, but variables defined at the lower location are not available in the surrounding higher location. In the preceding example, our code works as expected, as <strong class="source-inline">b</strong> is accessible from within <strong class="source-inline">location 3</strong>, even though it was defined in <span class="No-Break"><strong class="source-inline">location 2</strong></span><span class="No-Break">.</span></p>
			<p>So far, for the <a id="_idIndexMarker085"/>seasoned Go programmer, this should all pretty <a id="_idIndexMarker086"/>much be behaving as expected. Let’s take a look at a few other examples of scoping. Try to figure out the output of the code prior to <span class="No-Break">reading on:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Scoping example 1:</p>
			<pre class="source-code">
 func main() {
      {
           b := true
     }
     if b {
          fmt.Println("b is true")
     }
}</pre>
			<p>What would the output be here? The right answer is… <em class="italic">a compilation error</em>. In this example, we have defined <strong class="source-inline">b</strong> at a different scope than the scope of the <strong class="source-inline">if</strong> block. Thus, we don’t have access to <strong class="source-inline">b</strong> at this level <span class="No-Break">of scoping.</span></p>
			<p>Now, think about what the output would <span class="No-Break">be here:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Scoping example 2:</p>
			<pre class="source-code">
func main() {
     s := "hello"
     if true {
          s := "world"
          fmt.Println(s)
     }
     fmt.Println(s)
}</pre>
			<p>The right answer is <strong class="source-inline">world hello</strong>. This might be a bit surprising. You know that you can’t redeclare <a id="_idIndexMarker087"/>a variable in Go in a given scope, but, in this example, the scope inside our <strong class="source-inline">if</strong> statement is different from the scope of our <strong class="source-inline">main</strong> function. Thus, it is <a id="_idIndexMarker088"/>valid to declare a new <strong class="source-inline">s</strong> variable inside the <strong class="source-inline">if</strong> function. Do note that when using the <strong class="source-inline">s</strong> variable declared outside of our <strong class="source-inline">if</strong> statement, it has remained unchanged. This might be slightly surprising behavior. Let’s change our code slightly as we jump to the <span class="No-Break">third example.</span></p>
			<p>Let’s try to guess what the output might be of the following example: </p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Scoping example 3:</p>
			<pre class="source-code">
func main() {
     s := "hello"
     if true {
           s = "world"
           fmt.Println(s)
     }
     fmt.Println(s)
}</pre>
			<p>To point out the difference in this snippet, we have changed the first line in the <strong class="source-inline">if</strong> statement <span class="No-Break">from this:</span></p>
			<pre class="source-code">
S := world</pre>
			<p>Now, it is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
S = world</pre>
			<p>This seemingly small difference creates the following output: <strong class="source-inline">world world</strong>. To understand this, remember that when using the <strong class="source-inline">:=</strong> syntax, we are declaring a new variable. When we <a id="_idIndexMarker089"/>only write <strong class="source-inline">=</strong>, we are redeclaring an existing <a id="_idIndexMarker090"/>variable. In this example, we are just updating the content of the <span class="No-Break"><strong class="source-inline">s</strong></span><span class="No-Break"> variable.</span></p>
			<p>Now, let’s make one final change to <span class="No-Break">this example:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Scoping example 4:</p>
			<pre class="source-code">
func main() {
      s := "hello"
      s := "world"
      fmt.Println(s)
}</pre>
			<p>As you might have guessed, this code does not compile. While Go does allow us to declare variables with the same name, it only allows us to do so when they are not in the same block scope. A notable exception here is when a function returns multiple values. For example, in the following snippet, we can redeclare the error value as a return value for both <strong class="source-inline">func1</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">func2</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
      str1, err := func1()
      if err != nil {
           panic(err)
      }
      str2, err := func2()
      if err != nil {
           panic(err)
      }
      fmt.Printf("%v %v\n", str1, str2)
}
func func1() (string, error) {
      return "", errors.New("error 1")
}
func func2() (string, error) {
      return "", errors.New("error 2")
}</pre>
			<p>In the <a id="_idIndexMarker091"/>preceding snippet, the <strong class="source-inline">err</strong> value gets redeclared even though <a id="_idIndexMarker092"/>we are using the <strong class="source-inline">:=</strong> syntax. This is commonly encountered in Go as the error values bubble up from each function to an eventual parent method that handles <span class="No-Break">multiple errors.</span></p>
			<p>It is important to remember how scoping works and the significance of the curly braces to delineate blocks, as well as to remember the difference between introducing a new variable versus simply redeclaring an existing one. With this out of the way, we have enough background knowledge to jump into variable scoping when using functions <span class="No-Break">inside functions.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>Capturing variable context in functions (closures)</h2>
			<p>In the previous chapter, we saw that each time we encountered curly braces, a new variable scope <a id="_idIndexMarker093"/>was introduced. This happens when we declare a function, branch into an <strong class="source-inline">if</strong> statement, introduce a <strong class="source-inline">for</strong> loop, or simply place curly braces anywhere in a function, as in our first scoping example. We also saw in <a href="B18771_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> that we can create functions inside functions – and, as you might have guessed, this creates a new scope <span class="No-Break">yet again.</span></p>
			<p>For the remainder of this chapter, we will frequently use anonymous functions. Remember that an anonymous function is essentially a function declaration without an identifier attached to it. This is the general template that we <span class="No-Break">are using:</span></p>
			<pre class="source-code">
// location 1
func outerFunction() func() {
     // location 2
     fmt.Println("outer function")
     return func() {
           // location 3
           fmt.Println("inner function")
     }
}</pre>
			<p>In this example, I have denoted the three variable scoping locations as well. As you can see, <strong class="source-inline">location 3</strong>, which is part of the anonymous function, is scoped at a lower level than <strong class="source-inline">location 2</strong>. This is a critical reason why closures work. Defining a new function does not <a id="_idIndexMarker094"/>automatically create a top-level scope. When we define a function inside another function, this new function scopes variables at a lower level than where it <span class="No-Break">was introduced.</span></p>
			<p>Also, note that <strong class="source-inline">outerFunction</strong> is a higher-order function. Although we don’t take a function as input, we are returning a function as output. This is a valid characteristic of <span class="No-Break">higher-order functions.</span></p>
			<p>Now, let’s say specifically what we mean by a closure. A closure is <em class="italic">any inner function that uses a variable introduced in the outer function</em> to perform its work. Let’s make this more concrete by looking at <span class="No-Break">an example.</span></p>
			<p>In this example, we are going to create a function that creates a greeting function. Our outer function will be the function that determines the greeting message to show. The inner function will ask for a name as input and return the greeting combined with <span class="No-Break">the name:</span></p>
			<pre class="source-code">
func main() {
     greetingFunc := createGreeting()
     response := greetingFunc("Ana")
     fmt.Println(response)
}
func createGreeting() func(string) string {
     s := "Hello "
     return func(name string) string {
          return s + name
     }
}</pre>
			<p>In the preceding example, we are using a closure. The anonymous inner function references the outer variable, <strong class="source-inline">s</strong>, to create the greeting. The output of this code is <strong class="source-inline">Hello Ana</strong>. What is important here is that, although the <strong class="source-inline">s</strong> variable went out of scope once the <strong class="source-inline">createGreeting</strong> function ended, the variable content is actually captured inside the inner function. Thus, after we called <strong class="source-inline">greetingFunc</strong> in our <strong class="source-inline">main</strong> function, the capture <a id="_idIndexMarker095"/>was fixed as <strong class="source-inline">Hello</strong>. Capturing a variable inside an inner function is what is meant when we talk <span class="No-Break">about closures.</span></p>
			<p>We can make this function more flexible by accepting the greeting string as an input parameter to the <strong class="source-inline">createGreeting</strong> function so that we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
func createGreeting(greeting string) func(string) string {..}</pre>
			<p>This small change brings us to the start of the next topic: <span class="No-Break">partial applications.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/>Partial application</h1>
			<p>Now that we <a id="_idIndexMarker096"/>understand closures, we can start thinking about partial application. The name “partial application” quite explicitly tells us what is happening – it is a function that is partially applied. This is perhaps still a bit cryptic. A partially applied function is taking a function that takes <em class="italic">N</em> number of arguments and “fixing” a subset of these arguments. By fixing a subset of the arguments, they become set in stone, while the other input parameters <span class="No-Break">remain flexible.</span></p>
			<p>This is perhaps best shown with an example. Let’s extend the <strong class="source-inline">createGreeting</strong> function that we built in the previous section of <span class="No-Break">this chapter:</span></p>
			<pre class="source-code">
func createGreeting(greeting string) func(string) string {
     return func(name string) string {
          return greeting + name
     }
}</pre>
			<p>The change we have made here is to have the greeting passed as an input to the <strong class="source-inline">createGreeting</strong> function. Each time that we call <strong class="source-inline">createGreeting</strong>, we are effectively <a id="_idIndexMarker097"/>creating a new function, which expects <strong class="source-inline">name</strong> as input but has the <strong class="source-inline">greeting</strong> string fixed. Let’s create a few of those functions now and use them to print <span class="No-Break">the output:</span></p>
			<pre class="source-code">
func main() {
     firstGreeting := createGreeting("Well, hello there ")
     secondGreeting := createGreeting("Hola ")
     fmt.Println(firstGreeting("Remi"))
     fmt.Println(firstGreeting("Sean"))
     fmt.Println(secondGreeting("Ana"))
}</pre>
			<p>The output of running this function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Well, hello there Remi
Well, hello there Sean
Hola Ana</pre>
			<p>In this example, we fix the first parameter of the <strong class="source-inline">firstGreeting</strong> function as <strong class="source-inline">Well, hello there,</strong> while for the <strong class="source-inline">secondGreeting</strong> function, we have fixed the value as <strong class="source-inline">Hola</strong>. This is partial application – when we create the function to greet users with a name, part of this function has already been applied. In this case, the <strong class="source-inline">greeting</strong> variable was fixed, but you can fix any subset of the arguments of a function – it’s not limited to just <span class="No-Break">one variable.</span></p>
			<h3>Example: DogSpawner</h3>
			<p>In this example, we are going to tie everything that we have learned so far together. For this example, we are going to create <strong class="source-inline">DogSpawner</strong>. You can imagine that this could be used in the <a id="_idIndexMarker098"/>context of creating a game or another application for which you’d be maintaining information on dogs. As in our other examples, we are going to trim this down to the bare essentials and we won’t be making an actual game. What we are going to do in this example, however, is leverage what we’ve learned in previous chapters and tie it all together with clean <span class="No-Break">functional code.</span></p>
			<p>From a high-level point of view, our application should support dogs of multiple breeds. The breeds should be easily extensible. We also want to record the gender of the dog and give the dog a name. In our example, imagine that you’d want to spawn many dogs, so there would be a lot of repetition of types and genders. We’ll leverage partial application to prevent the repetitiveness of those function calls and improve the <span class="No-Break">code readability.</span></p>
			<p>First, we will start by defining the types that we’ll need for this program. Remember from the first chapter that we can use the <strong class="source-inline">type</strong> system to give you more information about what is happening in <span class="No-Break">the code:</span></p>
			<pre class="source-code">
type (
     Name          string
     Breed         int
     Gender        int
     NameToDogFunc func(Name) Dog
)</pre>
			<p>Notice that we can use a <strong class="source-inline">type</strong> block, similar to how we can use a <strong class="source-inline">var</strong> or <strong class="source-inline">const</strong> block. This prevents us from having to repeat the <strong class="source-inline">type Name string</strong> structure. In this <strong class="source-inline">type</strong> block, we have simply chosen <strong class="source-inline">Name</strong> to be a <strong class="source-inline">string</strong> object, <strong class="source-inline">Breed</strong> and <strong class="source-inline">Gender</strong> to be <strong class="source-inline">int</strong> objects, and <strong class="source-inline">NameToDogFunc</strong> is a function that takes in a given <strong class="source-inline">Name</strong> and returns a given <strong class="source-inline">Dog</strong> as a result. The reason we chose <strong class="source-inline">int</strong> objects for <strong class="source-inline">Breed</strong> and <strong class="source-inline">Gender</strong> is that we’ll construct those using Go’s equivalent of an <strong class="source-inline">Enum</strong> definition. We’ll go ahead and populate these enums with <span class="No-Break">some values:</span></p>
			<pre class="source-code">
// define possible breeds
const (
     Bulldog Breed = iota
     Havanese
     Cavalier
     Poodle
)
// define possible genders
const (
     Male Gender = iota
     Female
)</pre>
			<p>As you can tell from the preceding example, the default <strong class="source-inline">iota</strong> keyword works out of the box with the <a id="_idIndexMarker099"/>types that we have defined. Once again, this shows that our type aliases compile down to the underlying type, in this case, the <strong class="source-inline">int</strong> type for which <strong class="source-inline">iota</strong> is defined. You could merge the two <strong class="source-inline">const</strong> blocks in this example into a single block, but when dealing with enumerations, the code remains more readable when each block serves a <span class="No-Break">single purpose.</span></p>
			<p>With these constants and types in place, we can create a struct to represent <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">Dog</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Dog struct {
     Name   Name
     Breed  Breed
     Gender Gender
}</pre>
			<p>It’s a bit repetitive in this struct, as the names of our variables are identical to the type. For this example, we can keep it lightweight and don’t have to add any more information to our <strong class="source-inline">Dog</strong>. With this in place, we have everything we need to start implementing our partially applied functions, but before we get to that, let’s look at how we’d create <strong class="source-inline">Dog</strong> structs without partially <span class="No-Break">applied functions:</span></p>
			<pre class="source-code">
func createDogsWithoutPartialApplication() {
     bucky := Dog{
           Name:   "Bucky",
           Breed:  Havanese,
           Gender: Male,
     }
     rocky := Dog{
           Name:   "Rocky",
           Breed:  Havanese,
           Gender: Male,
     }
     tipsy := Dog{
           Name:   "Tipsy",
           Breed:  Poodle,
           Gender: Female,
     }
}</pre>
			<p>In the preceding example, we have created three dogs. The first two are both male Havanese dogs, so we had to repeat the <strong class="source-inline">Breed</strong> and <strong class="source-inline">Gender</strong> information there. The only thing <a id="_idIndexMarker100"/>that’s unique between those two would be the name. Now, let’s create a function that allows us to create <strong class="source-inline">DogSpawner</strong> of various gender and <span class="No-Break">breed combinations:</span></p>
			<pre class="source-code">
func DogSpawner(breed Breed, gender Gender) NameToDogFunc {
     return func(n Name) Dog {
           return Dog {
                 Breed:  breed,
                 Gender: gender,
                 Name:   n,
           }
     }
}</pre>
			<p>The preceding <strong class="source-inline">DogSpawner</strong> function is a function that takes <strong class="source-inline">Breed</strong> and <strong class="source-inline">Gender</strong> as input. It returns a new function, <strong class="source-inline">NameToDogFunc</strong>, which takes <strong class="source-inline">Name</strong> as input and returns a new <strong class="source-inline">Dog</strong> struct. This <strong class="source-inline">DogSpawner</strong> function thus allows us to create new functions <a id="_idIndexMarker101"/>where the dog’s breed and gender are already partially applied, but the name is still expected <span class="No-Break">as input.</span></p>
			<p>Using the <strong class="source-inline">DogSpawner</strong> function, we can create two new functions, <strong class="source-inline">maleHavaneseSpawner</strong> and <strong class="source-inline">femalePoodleSpawner</strong>. These functions will allow us to create male Havanese dogs and female poodles, by only providing a name for our dogs. Let’s go ahead and create two new functions in the package-scoped <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
var (
     maleHavaneseSpawner = DogSpawner(Havanese, Male)
     femalePoodleSpawner = DogSpawner(Poodle, Female)
)</pre>
			<p>After this definition, the <strong class="source-inline">maleHavaneseSpawner</strong> and <strong class="source-inline">femalePoodleSpawner</strong> functions are available anywhere in that package. You could also expose them as public functions that anyone using the package has access to. Let’s demonstrate in our <strong class="source-inline">main</strong> function how these functions could <span class="No-Break">be used:</span></p>
			<pre class="source-code">
func main() {
     bucky := maleHavaneseSpawner("bucky")
     rocky := maleHavaneseSpawner("rocky")
     tipsy := femalePoodleSpawner("tipsy")
     fmt.Printf("%v\n", bucky)
     fmt.Printf("%v\n", rocky)
     fmt.Printf("%v\n", tipsy)
}</pre>
			<p>In this <strong class="source-inline">main</strong> function, we can see how we can leverage the partially applied functions. We could <a id="_idIndexMarker102"/>have created a function to create dogs, such as <strong class="source-inline">newDog(n Name, b Breed, g Gender) Dog{}</strong>, but this would still have led to a lot of repetition in creating our dogs, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func main() {
     createDog("bucky", Havanese, Male)
     createDog("rocky", Havanese, Male)
     createDog("tipsy", Poodle, Female)
     createDog("keeno", Cavalier, Male)
}</pre>
			<p>While still decently readable with only three parameters, more parameters will significantly impair readability. We’ll show this in the last example of this chapter after we’ve discussed <span class="No-Break">function currying.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>Function currying, or how to reduce n-ary functions to unary functions</h1>
			<p>Function <a id="_idIndexMarker103"/>currying is often mistaken for <a id="_idIndexMarker104"/>partial application. As you will see, function currying and partial <a id="_idIndexMarker105"/>application are related but not identical concepts. When we talk about function currying, we are talking about transforming a function that takes a single argument to a sequence of functions where each function takes exactly one argument. In pseudocode, what we are doing is transforming a function such as the following into a sequence of <span class="No-Break">three functions:</span></p>
			<pre class="source-code">
func F(a,b,c): int {}</pre>
			<p>The first function, <strong class="source-inline">(Fa)</strong>, takes the <strong class="source-inline">a</strong> argument as input and returns a new function, <strong class="source-inline">(Fb)</strong>, as output. <strong class="source-inline">(Fb)</strong> takes <strong class="source-inline">b</strong> as input and returns an <strong class="source-inline">(Fc)</strong> function. <strong class="source-inline">(Fc)</strong>, the final function, takes <strong class="source-inline">c</strong> as input and returns an <strong class="source-inline">int</strong> object <span class="No-Break">as output:</span></p>
			<pre class="source-code">
func Fa(a): Fb(b)
func Fb(b): Fc(c)
func Fc(c): int</pre>
			<p>This is done by leveraging the concept of first-class citizens and higher-order functions once again. We’ll be able to achieve this transformation by returning a function from a function. The core feature that we’ll achieve from this is more composable functions. For our purposes, you can think of this as partial application applied to <span class="No-Break">single arguments.</span></p>
			<p>One thing <a id="_idIndexMarker106"/>to note here is that in other <a id="_idIndexMarker107"/>programming languages such as Haskell, function <a id="_idIndexMarker108"/>currying plays a much more important role than here in our Go examples. Haskell (which is named after Haskell Curry), transforms each function into a curried function. The compiler takes care of that, so you’re not generally aware of this as a user. The Go compiler does no such thing, but we can still manually create functions in such a way. Before we dive into larger end-to-end examples, let’s take a quick look at how we’d transform the previous pseudocode into functioning <span class="No-Break">Go code.</span></p>
			<p>Without currying, our function would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func threeSum(a, b, c int) int {
     return a + b + c
}</pre>
			<p>Now, with currying, the same example would translate <span class="No-Break">to this:</span></p>
			<pre class="source-code">
func threeSumCurried(a int) func(int) func(int) int {
     return func(b int) func(int) int {
          return func(c int) int {
               return a + b + c
          }
     }
}</pre>
			<p>When calling them in the <strong class="source-inline">main</strong> function, these return the same result. Notice the difference in syntax between the two calls in the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func main() {
     fmt.Println(threeSum(10, 20, 30))
     fmt.Println(threeSumCurried(10)(20)(30))
}</pre>
			<p>It should <a id="_idIndexMarker109"/>go without saying that the curried <a id="_idIndexMarker110"/>version of this function is way more complicated to read and <a id="_idIndexMarker111"/>comprehend than the uncurried function. This ties back to what I mentioned in the first chapter – you should leverage functional concepts where they make sense. For this simple example, it didn’t make sense but it does demonstrate the point of what we are trying to do. The real power of function currying only comes in handy when we also decide to combine it with partial application to create flexible functions. To show how this works, let’s dive into <span class="No-Break">an example.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Example: function currying</h2>
			<p>In this example, we are going to extend the functionality of the <strong class="source-inline">DogSpawner</strong> example that we’ve <a id="_idIndexMarker112"/>built to demonstrate partial application. If we look at the main <strong class="source-inline">DogSpawner</strong> code for that application, we can tell that we are almost using a <span class="No-Break">unary function:</span></p>
			<pre class="source-code">
func DogSpawner(breed Breed, gender Gender) NameToDogFunc {
     // implementation
}</pre>
			<p>That gets us close, but no dice. To be a properly curried function, <strong class="source-inline">DogSpawner</strong> can only take one parameter. In essence, we are going to create a sequence of three functions that take the successive arguments to create <strong class="source-inline">Dog</strong>, <strong class="source-inline">DogSpawner(Breed)(Gender)(Name)</strong>. If we implement this function in Go, we get the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
func DogSpawnerCurry(breed Breed) func(Gender) NameToDogFunc {
     return func(gender Gender) NameToDogFunc {
            return func(name Name) Dog {
                   return Dog{
                          Breed:  breed,
                          Gender: gender,
                       Name:   name,
               }
          }
     }
}</pre>
			<p>The way to <a id="_idIndexMarker113"/>read this is that <strong class="source-inline">DogSpawnerCurry</strong> is a function that takes <strong class="source-inline">breed</strong> as input. It returns a function that takes <strong class="source-inline">gender</strong> as input, which, in turn, returns a function that takes <strong class="source-inline">name</strong> as input and returns <strong class="source-inline">Dog</strong>. This is a bit complex to read, but you get the hang of it. This is also where type aliases come in handy. Without a type alias, this would be even more verbose, which would hinder reading and make it more error-prone <span class="No-Break">to write:</span></p>
			<pre class="source-code">
func DogSpawnerCurry(breed Breed) func(Gender) func(Name) Dog {
     return func(gender Gender) func(Name) Dog{
          return func(name Name) Dog {
               return Dog{
                    Breed:  breed,
                    Gender: gender,
                    Name:   name,
               }
          }
     }
}</pre>
			<p>Now that <a id="_idIndexMarker114"/>we have covered the three main themes of this chapter, let’s take a look at some further examples to demonstrate <span class="No-Break">these techniques.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Example: server constructor</h1>
			<p>In this first example, we are going to leverage what we’ve learned so far to create flexible constructors <a id="_idIndexMarker115"/>for data types. We will also see how we can create constructors with default values of <span class="No-Break">our choosing.</span></p>
			<p>In our setup, a <strong class="source-inline">Server</strong> struct is a simple struct that has a set number of maximum connections, a transport type, and a name. We won’t be building an actual web server, but rather, we are demonstrating the concepts with only a small amount of overhead. What we want to do in this example is to focus on the core ideas, which you can then apply anywhere you see fit. Our server only has three configurable parameters, but you can imagine that this benefit is more pronounced when there are more parameters <span class="No-Break">to configure.</span></p>
			<p>As always, we are going to start by defining the custom types of our application. To keep it lightweight, I’m defining two of them – <strong class="source-inline">TransportType</strong>, which is an <strong class="source-inline">int</strong> type to be used as an enumeration, and a type alias for <strong class="source-inline">func(options) options</strong>. Let’s also set some values <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">TransportType</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type (
     ServerOptions func(options) options
     TransportType int
)
const (
     UDP TransportType = iota
     TCP
)</pre>
			<p>Now that <a id="_idIndexMarker116"/>we have this, let’s get our structs in place – the two structs that we will be using as <strong class="source-inline">Server</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">options</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Server struct {
     options
}
type options struct {
     MaxConnection int
     TransportType TransportType
     Name          string
}</pre>
			<p>In the example here, we have embedded <strong class="source-inline">options</strong> without declaring a new name for the field. This is achieved in Go by simply writing the type of struct that you want to embed. When doing so, the <strong class="source-inline">Server</strong> struct will contain all the fields that the <strong class="source-inline">options</strong> struct has. It’s a way to model object composition <span class="No-Break">in Go.</span></p>
			<p>This might look a bit peculiar and warrants some further investigation. In a more typical setup, you might have the <strong class="source-inline">Server</strong> struct contain the variables that we have placed inside the <strong class="source-inline">options</strong> struct. The main reason for using the <strong class="source-inline">options</strong> struct and embedding it inside <strong class="source-inline">Server</strong> is to use this as a configuration for our server that we want users to provide. We don’t want users to provide data that is not contained in this struct, such as the <strong class="source-inline">isAlive</strong> flag. This clearly separates concerns, and it will allow us to build the next higher-order functions and partial application layers on top <span class="No-Break">of it.</span></p>
			<p>The next step is creating a way for us to configure the <strong class="source-inline">options</strong> struct through multiple function calls. For each variable inside the <strong class="source-inline">options</strong> struct, we are creating a higher-order function. These are functions that take in the parameter to be configured, and return a new <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">ServerOptions</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func MaxConnection(n int) ServerOptions {
     return func(o options) options {
     o.MaxConnection = n
          return o
     }
}
func ServerName(n string) ServerOptions {
     return func(o options) options {
          o.Name = n
          return o
     }
}
func Transport(t TransportType) ServerOptions {
        return func(o options) options {
                o.TransportType = t
                return o
        }
}</pre>
			<p>As you can <a id="_idIndexMarker117"/>see in the preceding three functions (<strong class="source-inline">MaxConnection</strong>, <strong class="source-inline">ServerName</strong>, and <strong class="source-inline">TransportType</strong>), we are using a closure to build this configuration. Each function takes in a struct of the <strong class="source-inline">options</strong> type, changes the corresponding variable, and returns the same <strong class="source-inline">options</strong> struct with the change applied. <em class="italic">Notice that these functions only change their corresponding variable, and everything else in the struct </em><span class="No-Break"><em class="italic">remains untouched.</em></span></p>
			<p>Now that we have this, we have everything in place to start constructing our server. For our constructor, we’ll write a function that takes a variadic argument list of <strong class="source-inline">ServerOptions</strong> as our input. Remember that these inputs are really other functions. Our constructor is a higher-order function that takes functions as input and returns a server as output. Thus, when we iterate over our <strong class="source-inline">ServerOptions</strong>, we get a series of functions that we can call. We’ll create a default struct of <strong class="source-inline">options</strong> to pass to <span class="No-Break">these functions:</span></p>
			<pre class="source-code">
func NewServer(os ...ServerOptions) Server {
     opts := options{}
     for _, option := range os {
          opts = option(opts)
     }
     return Server{
          options: opts,
          isAlive: true,
     }
}</pre>
			<p>In the code here, you can see how our <strong class="source-inline">Server</strong> is finally built based on the <strong class="source-inline">options</strong> struct. We’re <a id="_idIndexMarker118"/>also setting the <strong class="source-inline">isAlive</strong> flag to <strong class="source-inline">true</strong>, as this is not something the user <span class="No-Break">could input.</span></p>
			<p>Great, we have everything in place to start creating servers – so how do we go about that? Well, our constructor is a bit different from other constructors that you might have seen. Rather than taking variables such as primitives or structs as input, we are going to pass functions as input. Let’s demonstrate in the <strong class="source-inline">main</strong> function how we can call <span class="No-Break">this constructor:</span></p>
			<pre class="source-code">
func main() {
     server := NewServer(MaxConnection(10), ServerName("MyFirstServer"))
     fmt.Printf("%+v\n", server)
}</pre>
			<p>As you can tell, we call the <strong class="source-inline">MaxConnection(10)</strong> function inside the constructor. The output of this function is not simply a struct; the output is <strong class="source-inline">function(options) options</strong>. When running this code, we get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
{options:{MaxConnection:10 TransportType:0 Name:MyFirstServer} 
  isAlive:true}</pre>
			<p>Great – now, we have a quite flexible constructor. If you notice in the output, we get <strong class="source-inline">TransportType: 0</strong> as output, even though we did not configure this in our <strong class="source-inline">options</strong> struct. This is because Go uses a sane default zero value for its primitive types. One thing <a id="_idIndexMarker119"/>our current constructor setup allows us to do is to create default values that we set ourselves with only minor changes to our code. Let’s update the <strong class="source-inline">NewServer</strong> function to use <strong class="source-inline">TCP</strong> (<strong class="source-inline">TransportType: 1</strong>) as the <span class="No-Break">default value:</span></p>
			<pre class="source-code">
func NewServer(os ...ServerOptions) Server {
        opts := options{
                TransportType: TCP,
        }
        for _, option := range os {
                opts = option(opts)
        }
        return Server{
                options: opts,
                isAlive: true,
        }
}</pre>
			<p>In the example, the only change we made was to add <strong class="source-inline">TransportType: TCP</strong> to the initialization for our <strong class="source-inline">options</strong>. Now, if we run the same main code again, we get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
{options:{MaxConnection:10 TransportType:1 Name:MyFirstServer} 
  isAlive:true}</pre>
			<p>This is how easy it is to create our own default values when a user does not provide any. As this example shows, we can easily use functional programming concepts to build flexible functions <a id="_idIndexMarker120"/>such as constructors and achieve functionality that is not natively present in Go. In some languages, such as Python, you can set default values for a function when the user does not provide them. Now, we can do the same thing using the <strong class="source-inline">options</strong> struct for <span class="No-Break">our server.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Summary</h1>
			<p>In this chapter, we covered three things: closures, partial application, and currying. By using closures, we learned how we can share the context of variables between outer and inner functions. This allowed us to build flexible applications, such as the final “constructor” example. Next, we learned how to use a partially applied function to fix certain arguments to an n-ary function. This shows us how we can create default configurations for functions, such as how we created a <strong class="source-inline">HavaneseSpawner</strong> option in our example. Finally, we learned about function currying and how this relates to partial application. We showed how we can extend our partial application example by transforming each function into unary function calls. All three techniques have allowed us to create more composable and <span class="No-Break">reusable functions.</span></p>
			<p>Up until now, we have not been concerned with function purity and have played a bit fast and loose with the state of our system. In the next chapter, we are going to talk about what it means for functions to be pure, how we can encapsulate side effects, and what benefits this brings for writing <span class="No-Break">testable code.</span></p>
		</div>
	</body></html>