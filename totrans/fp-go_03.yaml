- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Higher-Order Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: In this chapter, we are going to explore the concept of function composition
    through higher-order functions. There are a variety of new concepts that we are
    introducing here, such as closures, partial application, and function currying.
    We will take a look at some practical examples and real-world use cases for these.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过高阶函数来探讨函数组合的概念。这里我们将介绍多种新的概念，例如闭包、偏应用和函数柯里化。我们将查看一些实际例子和这些概念的实际应用场景。
- en: First, we will cover the core concepts of composing functions from an abstract
    viewpoint, and then we will combine the concepts in a practical example. Everything
    that we will learn here leans heavily on the concepts introduced in [*Chapter
    2*](B18771_02.xhtml#_idTextAnchor028), where we learned what it means to treat
    functions as first-class citizens.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从抽象的角度介绍函数组合的核心概念，然后我们将结合实际例子来应用这些概念。在这里我们所学到的所有内容都高度依赖于在[*第二章*](B18771_02.xhtml#_idTextAnchor028)中介绍的概念，在那里我们学习了如何将函数视为一等公民。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: An introduction to higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数简介
- en: Closures and variable scoping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包和变量作用域
- en: Partial application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏应用
- en: Function currying, or how to reduce n-ary functions to unary functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数柯里化，或者如何将n元函数简化为一元函数
- en: 'Examples:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the examples for this chapter can be found at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3).
    For this example, any Go version will work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有示例都可以在[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3)找到。对于这个例子，任何版本的Go语言都可以使用。
- en: An introduction to higher-order functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数简介
- en: In essence, a higher-order function is any function that either takes a function
    as the input or returns a function as the output. Recall from the previous chapter
    that both of these things are made possible through the support for functions
    as “first-class citizens.” Although it’s perhaps uncommon to call them “higher-order
    functions,” many programming languages do support these functions out of the box.
    For example, in Java and Python, the `map`, `filter`, and `reduce` functions are
    all examples of higher-order functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，高阶函数是指那些要么接受函数作为输入，要么返回函数作为输出的函数。回想一下上一章，这两者都是通过支持函数作为“一等公民”而成为可能的。尽管将它们称为“高阶函数”可能并不常见，但许多编程语言都默认支持这些函数。例如，在Java和Python中，`map`、`filter`和`reduce`函数都是高阶函数的例子。
- en: 'Let’s create a simple example in Go. We’ll have a function, `A`, that returns
    `hello,` and a function, `B`, that takes `A` as an input parameter. This is a
    higher-order function, as the `A` function is used as input to `B`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Go语言中创建一个简单的例子。我们将有一个返回“hello,”的函数`A`，以及一个接受`A`作为输入参数的函数`B`。这是一个高阶函数，因为`A`函数被用作`B`函数的输入：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is important to point out here that we’re not simply passing the result of
    `A` to `B` – we’re actually running the `A` function as part of the execution
    of `B`. So far, what I’ve shown here is not fundamentally different from anything
    that we saw in [*Chapter 2*](B18771_02.xhtml#_idTextAnchor028). Indeed, first-class
    functions are often demonstrated by the implementation of higher-order functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要指出的是，我们并不是简单地将`A`函数的结果传递给`B`函数——我们实际上是在执行`B`函数的过程中运行`A`函数。到目前为止，我所展示的内容与我们之前在[*第二章*](B18771_02.xhtml#_idTextAnchor028)中看到的内容并没有本质的不同。实际上，一等函数通常是通过高阶函数的实现来展示的。
- en: When they become interesting is when you start using them for partially applied
    computation, or when you use them to build function currying, but before we dive
    into these, let’s look at the concept of closure first.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们变得有趣时，是你开始使用它们进行偏应用计算，或者使用它们来构建函数柯里化的时候，但在我们深入这些内容之前，让我们先看看闭包的概念。
- en: Closures and variable scoping
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包和变量作用域
- en: Closures are closely related to how variable scoping works in a given programming
    language. To fully understand how they work and how they become useful, we will
    first do a quick refresher on how variable scoping works in Go. Next, we’ll remind
    ourselves of how anonymous functions work and what they are. Finally, we will
    take a look at what closures are in this context. This will set us up to properly
    understand partial application and function currying when we get to those techniques
    later in the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包与特定编程语言中变量作用域的工作方式密切相关。为了完全理解它们是如何工作的以及它们如何变得有用，我们首先将快速回顾一下 Go 中变量作用域是如何工作的。接下来，我们将提醒自己匿名函数是如何工作的以及它们是什么。最后，我们将探讨在这个上下文中闭包是什么。这将为我们理解稍后章节中提到的部分应用和函数柯里化打下基础。
- en: Variable scoping in Go
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中的变量作用域
- en: 'Variable scoping in Go is done by what is called **lexical scoping**. This
    means that a variable is identified and usable within the context where it was
    created. In Go, “blocks” are used to delineate locations in code. For example,
    see the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的变量作用域是通过所谓的 **词法作用域** 来实现的。这意味着变量在其创建的上下文中被识别并可用。在 Go 中，“块”用于界定代码中的位置。例如，看以下代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are three locations of scope in this code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有三个作用域位置：
- en: The first one, `location 1`, is the package scope. Our main function sits at
    this level of scoping.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个位置，`location 1`，是包作用域。我们的主函数位于这个作用域级别。
- en: The next location is inside our `main` function. This is where we are defining
    the `b` Boolean.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个位置是在我们的 `main` 函数内部。这就是我们定义 `b` 布尔变量的地方。
- en: The third location is inside the `if` statement. In Go, and many other languages,
    the block is defined by curly braces.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个位置是在 `if` 语句内部。在 Go 以及许多其他语言中，块是由花括号定义的。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a rule, variables that are defined at a “higher location” are available at
    a lower location, but variables defined at the lower location are not available
    in the surrounding higher location. In the preceding example, our code works as
    expected, as `b` is accessible from within `location 3`, even though it was defined
    in `location 2`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在“更高位置”定义的变量在较低位置是可用的，但在较低位置定义的变量在周围较高位置是不可用的。在前面的例子中，我们的代码按预期工作，因为 `b`
    可以从 `location 3` 内部访问，尽管它是在 `location 2` 中定义的。
- en: 'So far, for the seasoned Go programmer, this should all pretty much be behaving
    as expected. Let’s take a look at a few other examples of scoping. Try to figure
    out the output of the code prior to reading on:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于经验丰富的 Go 程序员来说，这一切应该都表现得相当符合预期。让我们看看一些其他关于范围示例。在继续阅读之前，试着找出代码的输出：
- en: 'Scoping example 1:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 范围示例 1：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What would the output be here? The right answer is… *a compilation error*. In
    this example, we have defined `b` at a different scope than the scope of the `if`
    block. Thus, we don’t have access to `b` at this level of scoping.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出会是什么？正确答案是… *编译错误*。在这个例子中，我们定义 `b` 的作用域与 `if` 块的作用域不同。因此，在这个作用域级别我们没有访问
    `b` 的权限。
- en: 'Now, think about what the output would be here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想想这里的输出会是什么：
- en: 'Scoping example 2:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 范围示例 2：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The right answer is `world hello`. This might be a bit surprising. You know
    that you can’t redeclare a variable in Go in a given scope, but, in this example,
    the scope inside our `if` statement is different from the scope of our `main`
    function. Thus, it is valid to declare a new `s` variable inside the `if` function.
    Do note that when using the `s` variable declared outside of our `if` statement,
    it has remained unchanged. This might be slightly surprising behavior. Let’s change
    our code slightly as we jump to the third example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是 `world hello`。这可能会让人有些惊讶。你知道在 Go 中你不能在给定的作用域中重新声明一个变量，但在这个例子中，`if` 语句内部的范围与我们的
    `main` 函数的范围不同。因此，在 `if` 函数内部声明新的 `s` 变量是有效的。请注意，当我们使用在 `if` 语句外部声明的 `s` 变量时，它保持未变。这可能会有些令人惊讶的行为。让我们在跳到第三个例子之前稍微修改一下我们的代码。
- en: 'Let’s try to guess what the output might be of the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试猜测以下示例的输出可能是什么：
- en: 'Scoping example 3:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 范围示例 3：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To point out the difference in this snippet, we have changed the first line
    in the `if` statement from this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指出这个片段中的差异，我们将 `if` 语句中的第一行从以下内容更改：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, it is the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，情况如下：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This seemingly small difference creates the following output: `world world`.
    To understand this, remember that when using the `:=` syntax, we are declaring
    a new variable. When we only write `=`, we are redeclaring an existing variable.
    In this example, we are just updating the content of the `s` variable.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似微小的差异产生了以下输出：`world world`。要理解这一点，请记住，当我们使用`:=`语法时，我们是在声明一个新的变量。当我们只写`=`时，我们是在重新声明一个现有的变量。在这个例子中，我们只是在更新`s`变量的内容。
- en: 'Now, let’s make one final change to this example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对这个例子做一个最后的修改：
- en: 'Scoping example 4:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域示例 4：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you might have guessed, this code does not compile. While Go does allow
    us to declare variables with the same name, it only allows us to do so when they
    are not in the same block scope. A notable exception here is when a function returns
    multiple values. For example, in the following snippet, we can redeclare the error
    value as a return value for both `func1` and `func2`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜到的，这段代码无法编译。虽然Go允许我们声明具有相同名称的变量，但它只允许我们在它们不在同一块作用域内时这样做。这里的一个显著例外是当函数返回多个值时。例如，在下面的代码片段中，我们可以将错误值重新声明为`func1`和`func2`的返回值：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, the `err` value gets redeclared even though we are
    using the `:=` syntax. This is commonly encountered in Go as the error values
    bubble up from each function to an eventual parent method that handles multiple
    errors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，尽管我们使用了`:=`语法，但`err`值仍然被重新声明。这在Go语言中很常见，因为错误值会从每个函数向上冒泡，最终到达处理多个错误的事件处理方法。
- en: It is important to remember how scoping works and the significance of the curly
    braces to delineate blocks, as well as to remember the difference between introducing
    a new variable versus simply redeclaring an existing one. With this out of the
    way, we have enough background knowledge to jump into variable scoping when using
    functions inside functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 记住作用域的工作方式和花括号在界定块中的作用，以及记住引入新变量与简单重新声明现有变量之间的区别非常重要。这样，我们就有了足够的背景知识，可以深入探讨在函数内部使用函数时的变量作用域。
- en: Capturing variable context in functions (closures)
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数中捕获变量上下文（闭包）
- en: In the previous chapter, we saw that each time we encountered curly braces,
    a new variable scope was introduced. This happens when we declare a function,
    branch into an `if` statement, introduce a `for` loop, or simply place curly braces
    anywhere in a function, as in our first scoping example. We also saw in [*Chapter
    2*](B18771_02.xhtml#_idTextAnchor028) that we can create functions inside functions
    – and, as you might have guessed, this creates a new scope yet again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了每次遇到花括号时，都会引入一个新的变量作用域。这发生在我们声明一个函数、分支到`if`语句、引入`for`循环，或者在函数的任何地方放置花括号时，就像我们的第一个作用域示例一样。我们还看到在[*第二章*](B18771_02.xhtml#_idTextAnchor028)中，我们可以在函数内部创建函数——正如你可能猜到的，这又创建了一个新的作用域。
- en: 'For the remainder of this chapter, we will frequently use anonymous functions.
    Remember that an anonymous function is essentially a function declaration without
    an identifier attached to it. This is the general template that we are using:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将频繁使用匿名函数。请记住，匿名函数本质上是一个没有与标识符关联的函数声明。这是我们使用的通用模板：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, I have denoted the three variable scoping locations as well.
    As you can see, `location 3`, which is part of the anonymous function, is scoped
    at a lower level than `location 2`. This is a critical reason why closures work.
    Defining a new function does not automatically create a top-level scope. When
    we define a function inside another function, this new function scopes variables
    at a lower level than where it was introduced.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我还标记了三个变量作用域的位置。正如你所看到的，`位置 3`，它是匿名函数的一部分，其作用域比`位置 2`低。这是闭包能够工作的一个关键原因。定义一个新的函数并不会自动创建一个顶级作用域。当我们在一个函数内部定义另一个函数时，这个新函数的作用域比其引入的位置低。
- en: Also, note that `outerFunction` is a higher-order function. Although we don’t
    take a function as input, we are returning a function as output. This is a valid
    characteristic of higher-order functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`outerFunction`是一个高阶函数。尽管我们没有将函数作为输入，但我们返回一个函数作为输出。这是高阶函数的有效特征。
- en: Now, let’s say specifically what we mean by a closure. A closure is *any inner
    function that uses a variable introduced in the outer function* to perform its
    work. Let’s make this more concrete by looking at an example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们具体说明我们所说的闭包是什么。闭包是指**任何使用在外部函数中引入的变量来执行其工作的内部函数**。让我们通过一个例子来使这个概念更加具体。
- en: 'In this example, we are going to create a function that creates a greeting
    function. Our outer function will be the function that determines the greeting
    message to show. The inner function will ask for a name as input and return the
    greeting combined with the name:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个函数，该函数创建一个问候函数。我们的外部函数将是确定要显示的问候信息的函数。内部函数将要求输入一个名字，并返回与名字结合的问候语：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we are using a closure. The anonymous inner function
    references the outer variable, `s`, to create the greeting. The output of this
    code is `Hello Ana`. What is important here is that, although the `s` variable
    went out of scope once the `createGreeting` function ended, the variable content
    is actually captured inside the inner function. Thus, after we called `greetingFunc`
    in our `main` function, the capture was fixed as `Hello`. Capturing a variable
    inside an inner function is what is meant when we talk about closures.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了闭包。匿名内部函数引用外部变量`s`来创建问候。这段代码的输出是`Hello Ana`。这里重要的是，尽管`s`变量在`createGreeting`函数结束时已经超出作用域，但变量内容实际上被捕获在内部函数中。因此，在我们`main`函数中调用`greetingFunc`之后，捕获被固定为`Hello`。在内部函数中捕获变量就是我们所说的闭包的含义。
- en: 'We can make this function more flexible by accepting the greeting string as
    an input parameter to the `createGreeting` function so that we get the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将问候字符串作为`createGreeting`函数的输入参数来使这个函数更加灵活，从而得到以下结果：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This small change brings us to the start of the next topic: partial applications.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的改变带我们进入了下一个主题的开始：偏应用。
- en: Partial application
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏应用
- en: Now that we understand closures, we can start thinking about partial application.
    The name “partial application” quite explicitly tells us what is happening – it
    is a function that is partially applied. This is perhaps still a bit cryptic.
    A partially applied function is taking a function that takes *N* number of arguments
    and “fixing” a subset of these arguments. By fixing a subset of the arguments,
    they become set in stone, while the other input parameters remain flexible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了闭包，我们可以开始考虑偏应用。名称“偏应用”非常明确地告诉我们发生了什么——它是一个部分应用的函数。这也许仍然有点晦涩。一个部分应用的函数正在接受一个接受*N*个参数的函数，并“固定”这些参数的一个子集。通过固定参数的一个子集，它们就变得固定不变，而其他输入参数仍然保持灵活。
- en: 'This is perhaps best shown with an example. Let’s extend the `createGreeting`
    function that we built in the previous section of this chapter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好用一个例子来说明。让我们扩展我们在本章前一部分中构建的`createGreeting`函数：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The change we have made here is to have the greeting passed as an input to
    the `createGreeting` function. Each time that we call `createGreeting`, we are
    effectively creating a new function, which expects `name` as input but has the
    `greeting` string fixed. Let’s create a few of those functions now and use them
    to print the output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的改变是将问候语作为输入传递给`createGreeting`函数。每次我们调用`createGreeting`时，实际上我们都在创建一个新的函数，该函数期望`name`作为输入，但`greeting`字符串是固定的。现在让我们创建几个这样的函数并使用它们来打印输出：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of running this function is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此函数的输出如下：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we fix the first parameter of the `firstGreeting` function
    as `Well, hello there,` while for the `secondGreeting` function, we have fixed
    the value as `Hola`. This is partial application – when we create the function
    to greet users with a name, part of this function has already been applied. In
    this case, the `greeting` variable was fixed, but you can fix any subset of the
    arguments of a function – it’s not limited to just one variable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`firstGreeting`函数的第一个参数固定为`Well, hello there,`，而对于`secondGreeting`函数，我们将值固定为`Hola`。这是偏应用——当我们创建用于问候用户的函数时，这个函数的部分已经被应用。在这种情况下，`greeting`变量被固定，但你也可以固定函数参数的任何子集——这不仅仅局限于一个变量。
- en: 'Example: DogSpawner'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：DogSpawner
- en: In this example, we are going to tie everything that we have learned so far
    together. For this example, we are going to create `DogSpawner`. You can imagine
    that this could be used in the context of creating a game or another application
    for which you’d be maintaining information on dogs. As in our other examples,
    we are going to trim this down to the bare essentials and we won’t be making an
    actual game. What we are going to do in this example, however, is leverage what
    we’ve learned in previous chapters and tie it all together with clean functional
    code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将把到目前为止所学的一切结合起来。对于这个例子，我们将创建 `DogSpawner`。你可以想象这可以用于创建游戏或需要维护狗信息的其他应用程序的上下文中。就像我们之前的例子一样，我们将将其简化到最基本的部分，并且不会制作一个真正的游戏。然而，在这个例子中，我们将利用之前章节中学到的知识，并用干净的函数式代码将它们全部结合起来。
- en: From a high-level point of view, our application should support dogs of multiple
    breeds. The breeds should be easily extensible. We also want to record the gender
    of the dog and give the dog a name. In our example, imagine that you’d want to
    spawn many dogs, so there would be a lot of repetition of types and genders. We’ll
    leverage partial application to prevent the repetitiveness of those function calls
    and improve the code readability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个高层次的角度来看，我们的应用程序应该支持多种品种的狗。品种应该是易于扩展的。我们还希望记录狗的性别并给狗起一个名字。在我们的例子中，假设你想要生成许多狗，那么就会有大量的类型和性别的重复。我们将利用部分应用来防止这些函数调用的重复性，并提高代码的可读性。
- en: 'First, we will start by defining the types that we’ll need for this program.
    Remember from the first chapter that we can use the `type` system to give you
    more information about what is happening in the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义这个程序需要的类型。记得从第一章中，我们可以使用 `type` 系统来提供有关代码中发生情况的更多信息：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that we can use a `type` block, similar to how we can use a `var` or
    `const` block. This prevents us from having to repeat the `type Name string` structure.
    In this `type` block, we have simply chosen `Name` to be a `string` object, `Breed`
    and `Gender` to be `int` objects, and `NameToDogFunc` is a function that takes
    in a given `Name` and returns a given `Dog` as a result. The reason we chose `int`
    objects for `Breed` and `Gender` is that we’ll construct those using Go’s equivalent
    of an `Enum` definition. We’ll go ahead and populate these enums with some values:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用一个 `type` 块，类似于我们如何使用 `var` 或 `const` 块。这可以防止我们不得不重复 `type Name string`
    结构。在这个 `type` 块中，我们简单地将 `Name` 选择为 `string` 对象，`Breed` 和 `Gender` 选择为 `int` 对象，而
    `NameToDogFunc` 是一个接受给定的 `Name` 并返回一个给定的 `Dog` 结果的函数。我们选择 `int` 对象作为 `Breed` 和
    `Gender` 的原因是我们将使用 Go 的 `Enum` 定义等效物来构建它们。我们将继续填充这些枚举值：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can tell from the preceding example, the default `iota` keyword works
    out of the box with the types that we have defined. Once again, this shows that
    our type aliases compile down to the underlying type, in this case, the `int`
    type for which `iota` is defined. You could merge the two `const` blocks in this
    example into a single block, but when dealing with enumerations, the code remains
    more readable when each block serves a single purpose.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，默认的 `iota` 关键字与我们所定义的类型无缝配合。再次证明，我们的类型别名编译成底层类型，在这种情况下，是 `int` 类型，`iota`
    就定义在这个类型上。你可以在本例中将两个 `const` 块合并为一个块，但在处理枚举时，每个块只服务于单一目的时代码更易于阅读。
- en: 'With these constants and types in place, we can create a struct to represent
    our `Dog`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些常量和类型就绪后，我们可以创建一个结构体来表示我们的 `Dog`：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It’s a bit repetitive in this struct, as the names of our variables are identical
    to the type. For this example, we can keep it lightweight and don’t have to add
    any more information to our `Dog`. With this in place, we have everything we need
    to start implementing our partially applied functions, but before we get to that,
    let’s look at how we’d create `Dog` structs without partially applied functions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构体中有点重复，因为我们的变量名与类型相同。对于这个例子，我们可以保持它轻量级，不需要向我们的 `Dog` 添加更多信息。有了这个，我们就有了开始实现部分应用函数所需的一切，但在我们到达那里之前，让我们看看在没有部分应用函数的情况下如何创建
    `Dog` 结构体：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding example, we have created three dogs. The first two are both
    male Havanese dogs, so we had to repeat the `Breed` and `Gender` information there.
    The only thing that’s unique between those two would be the name. Now, let’s create
    a function that allows us to create `DogSpawner` of various gender and breed combinations:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了三只狗。前两只都是雄性巴厘犬，因此我们不得不在那里重复`品种`和`性别`信息。这两只狗之间唯一独特的东西就是名字。现在，让我们创建一个函数，允许我们创建具有各种性别和品种组合的`DogSpawner`：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding `DogSpawner` function is a function that takes `Breed` and `Gender`
    as input. It returns a new function, `NameToDogFunc`, which takes `Name` as input
    and returns a new `Dog` struct. This `DogSpawner` function thus allows us to create
    new functions where the dog’s breed and gender are already partially applied,
    but the name is still expected as input.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`DogSpawner`函数是一个接受`品种`和`性别`作为输入的函数。它返回一个新的函数`NameToDogFunc`，该函数接受`名字`作为输入并返回一个新的`Dog`结构体。因此，`DogSpawner`函数允许我们创建新的函数，其中狗的品种和性别已经部分应用，但名字仍然需要作为输入。
- en: 'Using the `DogSpawner` function, we can create two new functions, `maleHavaneseSpawner`
    and `femalePoodleSpawner`. These functions will allow us to create male Havanese
    dogs and female poodles, by only providing a name for our dogs. Let’s go ahead
    and create two new functions in the package-scoped `var` block:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DogSpawner`函数，我们可以创建两个新的函数，`maleHavaneseSpawner`和`femalePoodleSpawner`。这些函数将允许我们通过只提供狗的名字来创建雄性巴厘犬和雌性贵宾犬。让我们继续在包作用域的`var`块中创建两个新的函数：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After this definition, the `maleHavaneseSpawner` and `femalePoodleSpawner`
    functions are available anywhere in that package. You could also expose them as
    public functions that anyone using the package has access to. Let’s demonstrate
    in our `main` function how these functions could be used:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义之后，`maleHavaneseSpawner`和`femalePoodleSpawner`函数可以在该包的任何地方使用。你也可以将它们公开为任何使用该包的人都可以访问的公共函数。让我们在我们的`main`函数中演示这些函数如何被使用：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this `main` function, we can see how we can leverage the partially applied
    functions. We could have created a function to create dogs, such as `newDog(n
    Name, b Breed, g Gender) Dog{}`, but this would still have led to a lot of repetition
    in creating our dogs, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`main`函数中，我们可以看到如何利用部分应用函数。我们本可以创建一个创建狗的函数，例如`newDog(n Name, b Breed, g Gender)
    Dog{}`，但这仍然会导致在创建我们的狗时有很多重复，如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While still decently readable with only three parameters, more parameters will
    significantly impair readability. We’ll show this in the last example of this
    chapter after we’ve discussed function currying.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有三个参数时仍然相当易读，但更多的参数将显著降低可读性。我们将在讨论了函数柯里化之后，在本章的最后示例中展示这一点。
- en: Function currying, or how to reduce n-ary functions to unary functions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数柯里化，或如何将多元函数简化为一元函数
- en: 'Function currying is often mistaken for partial application. As you will see,
    function currying and partial application are related but not identical concepts.
    When we talk about function currying, we are talking about transforming a function
    that takes a single argument to a sequence of functions where each function takes
    exactly one argument. In pseudocode, what we are doing is transforming a function
    such as the following into a sequence of three functions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数柯里化常被误认为是部分应用。正如你将看到的，函数柯里化和部分应用是相关但不同的概念。当我们谈论函数柯里化时，我们是在谈论将接受单个参数的函数转换为一个序列的函数，其中每个函数恰好接受一个参数。在伪代码中，我们所做的是将如下函数转换为一个由三个函数组成的序列：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first function, `(Fa)`, takes the `a` argument as input and returns a new
    function, `(Fb)`, as output. `(Fb)` takes `b` as input and returns an `(Fc)` function.
    `(Fc)`, the final function, takes `c` as input and returns an `int` object as
    output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`(Fa)`接受`a`参数作为输入并返回一个新的函数`(Fb)`作为输出。`(Fb)`接受`b`作为输入并返回一个`(Fc)`函数。`(Fc)`是最终函数，它接受`c`作为输入并返回一个`int`对象作为输出：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is done by leveraging the concept of first-class citizens and higher-order
    functions once again. We’ll be able to achieve this transformation by returning
    a function from a function. The core feature that we’ll achieve from this is more
    composable functions. For our purposes, you can think of this as partial application
    applied to single arguments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过再次利用第一公民和高阶函数的概念来实现的。我们将能够通过从函数中返回一个函数来实现这种转换。我们将从这一核心特性中获得更可组合的函数。就我们的目的而言，你可以将这视为单参数的部分应用。
- en: One thing to note here is that in other programming languages such as Haskell,
    function currying plays a much more important role than here in our Go examples.
    Haskell (which is named after Haskell Curry), transforms each function into a
    curried function. The compiler takes care of that, so you’re not generally aware
    of this as a user. The Go compiler does no such thing, but we can still manually
    create functions in such a way. Before we dive into larger end-to-end examples,
    let’s take a quick look at how we’d transform the previous pseudocode into functioning
    Go code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的一点是，在其他编程语言如Haskell中，函数柯里化比在我们的Go示例中扮演着更重要的角色。Haskell（以Haskell Curry的名字命名），将每个函数转换为一个柯里化函数。编译器会处理这件事，所以作为用户你通常不会意识到这一点。Go编译器不做这样的事情，但我们仍然可以手动以这种方式创建函数。在我们深入更大的端到端示例之前，让我们快速看看如何将之前的伪代码转换为功能性的Go代码。
- en: 'Without currying, our function would look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 没有柯里化，我们的函数将看起来像这样：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, with currying, the same example would translate to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了柯里化，相同的例子将转化为这样：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When calling them in the `main` function, these return the same result. Notice
    the difference in syntax between the two calls in the `main` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`main`函数中调用它们时，这些返回相同的结果。注意`main`函数中两次调用之间的语法差异：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It should go without saying that the curried version of this function is way
    more complicated to read and comprehend than the uncurried function. This ties
    back to what I mentioned in the first chapter – you should leverage functional
    concepts where they make sense. For this simple example, it didn’t make sense
    but it does demonstrate the point of what we are trying to do. The real power
    of function currying only comes in handy when we also decide to combine it with
    partial application to create flexible functions. To show how this works, let’s
    dive into an example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这个函数的柯里化版本比非柯里化版本更难阅读和理解。这回到了我在第一章提到的事情——你应该在合理的地方利用函数式概念。对于这个简单的例子，这样做并不合理，但它确实展示了我们试图做到的事情。函数柯里化的真正力量只有在我们也决定将其与部分应用结合以创建灵活函数时才会派上用场。为了展示这是如何工作的，让我们深入一个例子。
- en: 'Example: function currying'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：柯里化函数
- en: 'In this example, we are going to extend the functionality of the `DogSpawner`
    example that we’ve built to demonstrate partial application. If we look at the
    main `DogSpawner` code for that application, we can tell that we are almost using
    a unary function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将扩展我们构建的`DogSpawner`示例的功能，以演示部分应用。如果我们查看该应用程序的`main`函数中的主要`DogSpawner`代码，我们可以看出我们几乎使用了一个一元函数：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That gets us close, but no dice. To be a properly curried function, `DogSpawner`
    can only take one parameter. In essence, we are going to create a sequence of
    three functions that take the successive arguments to create `Dog`, `DogSpawner(Breed)(Gender)(Name)`.
    If we implement this function in Go, we get the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们接近了，但还不够。为了成为一个正确的柯里化函数，`DogSpawner`只能接受一个参数。本质上，我们将创建一个由三个函数组成的序列，这些函数依次接受参数来创建`Dog`，`DogSpawner(Breed)(Gender)(Name)`。如果我们用Go实现这个函数，我们得到以下代码：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The way to read this is that `DogSpawnerCurry` is a function that takes `breed`
    as input. It returns a function that takes `gender` as input, which, in turn,
    returns a function that takes `name` as input and returns `Dog`. This is a bit
    complex to read, but you get the hang of it. This is also where type aliases come
    in handy. Without a type alias, this would be even more verbose, which would hinder
    reading and make it more error-prone to write:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 读取这个的方式是`DogSpawnerCurry`是一个接受`breed`作为输入的函数。它返回一个接受`gender`作为输入的函数，而这个函数反过来又返回一个接受`name`作为输入的函数，该函数返回`Dog`。这有点复杂，但你会习惯的。这也是类型别名派上用场的地方。如果没有类型别名，这将更加冗长，这会阻碍阅读并使编写时更容易出错：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have covered the three main themes of this chapter, let’s take a
    look at some further examples to demonstrate these techniques.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了本章的三个主要主题，让我们看看一些进一步的例子来展示这些技术。
- en: 'Example: server constructor'
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：服务器构造函数
- en: In this first example, we are going to leverage what we’ve learned so far to
    create flexible constructors for data types. We will also see how we can create
    constructors with default values of our choosing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们将利用到目前为止所学到的知识来创建数据类型的灵活构造函数。我们还将看到如何创建具有我们选择的默认值的构造函数。
- en: In our setup, a `Server` struct is a simple struct that has a set number of
    maximum connections, a transport type, and a name. We won’t be building an actual
    web server, but rather, we are demonstrating the concepts with only a small amount
    of overhead. What we want to do in this example is to focus on the core ideas,
    which you can then apply anywhere you see fit. Our server only has three configurable
    parameters, but you can imagine that this benefit is more pronounced when there
    are more parameters to configure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设置中，`Server` 结构体是一个简单的结构体，具有固定数量的最大连接数、传输类型和名称。我们不会构建实际的 Web 服务器，而是仅用少量开销来展示这些概念。我们在这个示例中想要关注的是核心思想，您可以在任何合适的地方应用这些思想。我们的服务器只有三个可配置的参数，但您可以想象，当有更多参数需要配置时，这种好处更为明显。
- en: 'As always, we are going to start by defining the custom types of our application.
    To keep it lightweight, I’m defining two of them – `TransportType`, which is an
    `int` type to be used as an enumeration, and a type alias for `func(options) options`.
    Let’s also set some values for `TransportType`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从定义应用程序的自定义类型开始。为了保持轻量级，我定义了两个——`TransportType`，它是一个用作枚举的 `int` 类型，以及
    `func(options) options` 的类型别名。让我们也为 `TransportType` 设置一些值：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have this, let’s get our structs in place – the two structs that
    we will be using as `Server` and `options`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，让我们将结构体放到位——我们将用作 `Server` 和 `options` 的两个结构体：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the example here, we have embedded `options` without declaring a new name
    for the field. This is achieved in Go by simply writing the type of struct that
    you want to embed. When doing so, the `Server` struct will contain all the fields
    that the `options` struct has. It’s a way to model object composition in Go.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们未为嵌入的字段声明新名称就嵌入了 `options`。在 Go 中，这可以通过简单地写出您想要嵌入的结构体的类型来实现。这样做时，`Server`
    结构体会包含 `options` 结构体具有的所有字段。这是在 Go 中建模对象组合的一种方式。
- en: This might look a bit peculiar and warrants some further investigation. In a
    more typical setup, you might have the `Server` struct contain the variables that
    we have placed inside the `options` struct. The main reason for using the `options`
    struct and embedding it inside `Server` is to use this as a configuration for
    our server that we want users to provide. We don’t want users to provide data
    that is not contained in this struct, such as the `isAlive` flag. This clearly
    separates concerns, and it will allow us to build the next higher-order functions
    and partial application layers on top of it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇特，需要进一步调查。在更典型的设置中，您可能会在 `Server` 结构体中包含我们放在 `options` 结构体内部的变量。使用
    `options` 结构体并将其嵌入 `Server` 的主要原因是为了将其用作我们希望用户提供的服务器配置。我们不希望用户提供不包含在此结构体中的数据，例如
    `isAlive` 标志。这清楚地分离了关注点，并允许我们在其之上构建更高阶的函数和部分应用层。
- en: 'The next step is creating a way for us to configure the `options` struct through
    multiple function calls. For each variable inside the `options` struct, we are
    creating a higher-order function. These are functions that take in the parameter
    to be configured, and return a new function, `ServerOptions`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们创建一种通过多次函数调用配置 `options` 结构体的方式。对于 `options` 结构体内部的每个变量，我们创建一个高阶函数。这些函数接收要配置的参数，并返回一个新的函数，`ServerOptions`：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see in the preceding three functions (`MaxConnection`, `ServerName`,
    and `TransportType`), we are using a closure to build this configuration. Each
    function takes in a struct of the `options` type, changes the corresponding variable,
    and returns the same `options` struct with the change applied. *Notice that these
    functions only change their corresponding variable, and everything else in the
    struct* *remains untouched.*
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前三个函数（`MaxConnection`、`ServerName` 和 `TransportType`）中看到的，我们正在使用闭包来构建这个配置。每个函数接收一个
    `options` 类型的结构体，更改相应的变量，并返回应用更改后的相同 `options` 结构体。*请注意，这些函数只更改它们对应的变量，结构体中的其他所有内容都保持不变*。
- en: 'Now that we have this, we have everything in place to start constructing our
    server. For our constructor, we’ll write a function that takes a variadic argument
    list of `ServerOptions` as our input. Remember that these inputs are really other
    functions. Our constructor is a higher-order function that takes functions as
    input and returns a server as output. Thus, when we iterate over our `ServerOptions`,
    we get a series of functions that we can call. We’ll create a default struct of
    `options` to pass to these functions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，我们就准备好了一切，可以开始构建我们的服务器。对于我们的构造器，我们将编写一个函数，它接受一个可变参数列表`ServerOptions`作为输入。请记住，这些输入实际上是其他函数。我们的构造器是一个高阶函数，它接受函数作为输入，并返回服务器作为输出。因此，当我们遍历我们的`ServerOptions`时，我们得到一系列可以调用的函数。我们将创建一个默认的`options`结构体，并将其传递给这些函数：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the code here, you can see how our `Server` is finally built based on the
    `options` struct. We’re also setting the `isAlive` flag to `true`, as this is
    not something the user could input.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的代码中，您可以看到我们的`Server`是如何基于`options`结构体最终构建的。我们还设置了`isAlive`标志为`true`，因为这不是用户可以输入的内容。
- en: 'Great, we have everything in place to start creating servers – so how do we
    go about that? Well, our constructor is a bit different from other constructors
    that you might have seen. Rather than taking variables such as primitives or structs
    as input, we are going to pass functions as input. Let’s demonstrate in the `main`
    function how we can call this constructor:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们已经准备好了一切，可以开始创建服务器了——那么我们该如何着手呢？嗯，我们的构造器与您可能见过的其他构造器略有不同。我们不是以原语或结构体等变量作为输入，而是将函数作为输入传递。让我们在`main`函数中演示如何调用这个构造器：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can tell, we call the `MaxConnection(10)` function inside the constructor.
    The output of this function is not simply a struct; the output is `function(options)
    options`. When running this code, we get the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，我们在构造器内部调用了`MaxConnection(10)`函数。这个函数的输出不仅仅是结构体；输出是`function(options) options`。当运行这段代码时，我们得到以下输出：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Great – now, we have a quite flexible constructor. If you notice in the output,
    we get `TransportType: 0` as output, even though we did not configure this in
    our `options` struct. This is because Go uses a sane default zero value for its
    primitive types. One thing our current constructor setup allows us to do is to
    create default values that we set ourselves with only minor changes to our code.
    Let’s update the `NewServer` function to use `TCP` (`TransportType: 1`) as the
    default value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '太好了——现在，我们有一个相当灵活的构造器。如果您注意输出，我们会得到`TransportType: 0`作为输出，即使我们没有在我们的`options`结构体中配置这个。这是因为Go为其原始类型使用了一个合理的默认零值。我们当前构造器设置允许我们做的事情之一是，通过仅对我们的代码进行少量修改，就可以创建我们自行设置的默认值。让我们更新`NewServer`函数，使用`TCP`（`TransportType:
    1`）作为默认值：'
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the example, the only change we made was to add `TransportType: TCP` to
    the initialization for our `options`. Now, if we run the same main code again,
    we get the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们唯一做的改变是在`options`的初始化中添加了`TransportType: TCP`。现在，如果我们再次运行相同的`main`代码，我们得到以下输出：'
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is how easy it is to create our own default values when a user does not
    provide any. As this example shows, we can easily use functional programming concepts
    to build flexible functions such as constructors and achieve functionality that
    is not natively present in Go. In some languages, such as Python, you can set
    default values for a function when the user does not provide them. Now, we can
    do the same thing using the `options` struct for our server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当用户没有提供任何内容时创建我们自己的默认值有多简单。正如这个例子所示，我们可以轻松地使用函数式编程的概念来构建灵活的函数，如构造器，并实现Go中本不存在的功能。在一些语言中，例如Python，当用户没有提供时，您可以为一个函数设置默认值。现在，我们可以使用我们的服务器`options`结构体来做同样的事情。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered three things: closures, partial application, and
    currying. By using closures, we learned how we can share the context of variables
    between outer and inner functions. This allowed us to build flexible applications,
    such as the final “constructor” example. Next, we learned how to use a partially
    applied function to fix certain arguments to an n-ary function. This shows us
    how we can create default configurations for functions, such as how we created
    a `HavaneseSpawner` option in our example. Finally, we learned about function
    currying and how this relates to partial application. We showed how we can extend
    our partial application example by transforming each function into unary function
    calls. All three techniques have allowed us to create more composable and reusable
    functions.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了三个主题：闭包、偏应用和柯里化。通过使用闭包，我们学习了如何在内外函数之间共享变量上下文。这使得我们能够构建灵活的应用程序，例如最后的“构造函数”示例。接下来，我们学习了如何使用偏应用函数将某些参数固定到多元函数中。这展示了我们如何为函数创建默认配置，例如在我们示例中创建的`HavaneseSpawner`选项。最后，我们了解了函数柯里化及其与偏应用的关系。我们展示了如何通过将每个函数转换为单参数函数调用来扩展我们的偏应用示例。这三种技术使我们能够创建更多可组合和可重用的函数。
- en: Up until now, we have not been concerned with function purity and have played
    a bit fast and loose with the state of our system. In the next chapter, we are
    going to talk about what it means for functions to be pure, how we can encapsulate
    side effects, and what benefits this brings for writing testable code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们并没有关注函数的纯度，对系统的状态处理得有些草率。在下一章中，我们将讨论函数纯度的含义，如何封装副作用，以及这对编写可测试代码带来的好处。
