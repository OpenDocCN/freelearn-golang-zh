<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-60" class="chapter-number"><a id="_idTextAnchor060"/>4</h1>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Writing Testable Code with Pure Functions</h1>
			<p>When you read about functional programming, quite often, what is meant is “pure” functional programming. As we touched on in the first chapter, this is not a strict requirement of functional programming or functional languages. If you decide to pick up a functional programming language, the chances are pretty high that you’ll pick up a language such as Haskell or Elm. If so, you would have chosen two purely functional languages and might have coupled your understanding of <em class="italic">pure functional</em> with <em class="italic">functional</em>. On the other hand, if you had picked up a language such as Lisp, Clojure, or Erlang, you would have picked a functional language that is impure yet <span class="No-Break">still functional.</span></p>
			<p>In this chapter, we will address the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What exactly <span class="No-Break">is purity?</span></li>
				<li>Why should <span class="No-Break">purity matter?</span></li>
				<li>How do we create <span class="No-Break">pure functions?</span></li>
				<li>Learning how unit testing is impacted by writing <span class="No-Break">pure functions</span></li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Technical requirements</h1>
			<p>For this chapter, any version of Go after Go 1.12 can be used. You can find the complete examples <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>What is purity?</h1>
			<p>When talking <a id="_idIndexMarker121"/>about a purely functional programming language, we are talking about a language in which each function adheres to <span class="No-Break">these properties:</span></p>
			<ul>
				<li>Does not generate any <span class="No-Break">side effects</span></li>
				<li>Returns the same output when providing the same <span class="No-Break">input (idempotence)</span></li>
			</ul>
			<p>This means that our functions are <span class="No-Break">completely deterministic.</span></p>
			<p>The best way forward might be to demonstrate what we are talking about by showing some examples. So, in this section, we’ll take a look at two functions, a pure one and another <a id="_idIndexMarker122"/>which is impure. Then, we’ll talk a bit more about the properties of such functions and their importance to the programs that we <span class="No-Break">are writing.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>Demonstrating pure versus impure function calls</h2>
			<p>A simple <a id="_idIndexMarker123"/>example of this would be an <a id="_idIndexMarker124"/>addition function. This is a function that takes two integers as input and returns the sum as <span class="No-Break">the output:</span></p>
			<pre class="source-code">
func add(a, b int) int {
	return a + b
}</pre>
			<p>When we call this function with the same inputs, we will get consistent output. Thus, no matter how many times I call the <strong class="source-inline">add(10,5)</strong> function, the code will always return the same output: 15. This is pretty much as simple as it gets when creating a pure function. We did not use any state outside of our function to determine the answer, nor did we update anything outside of <span class="No-Break">our function.</span></p>
			<p>Next, let’s look at an example of an impure function, whose output is <span class="No-Break">always random:</span></p>
			<pre class="source-code">
func rollDice() int {
	return rand.Intn(6)
}</pre>
			<p>When calling the <strong class="source-inline">rollDice</strong> function, the output is not consistent. If it were consistently outputting the same number, it would be a pretty bad randomization function. If we were to call the <strong class="source-inline">rollDice</strong> function five times, we’d get five <span class="No-Break">different outputs:</span></p>
			<pre class="source-code">
func main() {
	for i := 0; i &lt; 5; i++ {
		fmt.Printf("dice roll: %v\n", rollDice())
	}
}</pre>
			<p>This <a id="_idIndexMarker125"/>would <a id="_idIndexMarker126"/>result in the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
dice roll: 5
dice roll: 3
dice roll: 5
dice roll: 5
dice roll: 1</pre>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Referential transparency</h2>
			<p>One property that helps us think about pure functions is the property of <em class="italic">referential transparency</em>. Both in mathematics and computer science, a function is said to be referentially <a id="_idIndexMarker127"/>transparent if you can replace the function call with <a id="_idIndexMarker128"/>its output, without changing the result of the program. In mathematics, it’s easy to see why that is true. If we work out any formula, we can essentially substitute part of an equation for its result, without changing the result. For example, take the <span class="No-Break">following equation:</span></p>
			<pre class="source-code">
X = 1 + (2 * 2)</pre>
			<p>The result is 5. We could have gotten the same result had we replaced the multiplication with its result, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
X = (1 + 4)</pre>
			<p>This property is what we mean by referential transparency. All mathematical operations have this property, and many of us have leveraged this property when working out equations in our algebra, calculus, or other <span class="No-Break">mathematics classes.</span></p>
			<p>Let’s jump back to the realm of software engineering to explore this further. In a programming language, referential transparency means that a function call can be replaced with its result. If we apply this same test to our <strong class="source-inline">add</strong> function, which we wrote earlier, we can see how this is true. Let’s demonstrate this with a small piece <span class="No-Break">of code:</span></p>
			<pre class="source-code">
func main() {
	fmt.Printf("%v\n", add(10, add(10, 5)))
	fmt.Printf("%v\n", add(10, 15))
}
func add(a, b int) int {
	return a + b
}</pre>
			<p>In this example, we have replaced one of the <strong class="source-inline">add</strong> functions with its result. And sure enough, the output of our program remained identical and functionally correct. You might think <a id="_idIndexMarker129"/>this is obvious, but there are plenty of <a id="_idIndexMarker130"/>functions that we rely on for which this is not true. Let’s introduce another function that breaks this property. We’ll keep it simple and create a program that tells us the <span class="No-Break">current time:</span></p>
			<pre class="source-code">
func main() {
	fmt.Printf("%v\n", time.Now())
}</pre>
			<p>In this snippet, we are using the <strong class="source-inline">time.Now</strong> function. There’s not a single value that you can replace this function call with while guaranteeing your program is functionally equivalent and correct. If we were to hardcode the current time, it would be wrong by the time your program has compiled and when <span class="No-Break">it’s run.</span></p>
			<p>To expand on this, let’s take a look at a larger example than just the <strong class="source-inline">time.Now</strong> function. In the following piece of code, let’s imagine we are writing a function to select the starting player of a game. We’ll use a simple type alias from <strong class="source-inline">Player</strong> to <strong class="source-inline">string</strong> instead of making a complete struct. As this is a game, we want our starting player to be randomly selected on each run of <span class="No-Break">our program:</span></p>
			<pre class="source-code">
type Player string
const (
	PlayerOne Player = "Remi"
	PlayerTwo Player = "Yvonne"
)
func selectStartingPlayer() Player {
	randomized := rand.Intn(2)
	switch randomized {
	case 0:
		return PlayerOne
	case 1:
		return PlayerTwo
	}
	panic("No further player available")
}</pre>
			<p>In the <a id="_idIndexMarker131"/>preceding code, we are breaking the referential transparency <a id="_idIndexMarker132"/>requirement of our code since there is no way to replace this function call with a single value while maintaining an equivalent outcome of our program. The preceding code is also not testable. Think about this for a second – how would you write a unit test for this function? This would prove impossible to do in the code’s current state and would require some refactoring. We will show you how we could refactor this code and make it testable later in this chapter, but you can find it on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Idempotence</h2>
			<p>Another <a id="_idIndexMarker133"/>property of pure functions is that they are idempotent. This <a id="_idIndexMarker134"/>means that no matter how many times the function is executed, it will always return the same output, assuming that the input arguments have remained the same. In the preceding example, the <strong class="source-inline">add</strong> function is always returning the same sum of two numbers provided the same input. On the other hand, the <strong class="source-inline">time.Now</strong> function is not (nor would that have been the <span class="No-Break">desired behavior).</span></p>
			<p>You might be familiar with idempotence as it also shows up when you are implementing a <strong class="source-inline">REST</strong> service <a id="_idIndexMarker135"/>or dealing with HTTP calls in general. When implemented <a id="_idIndexMarker136"/>correctly, the <strong class="source-inline">GET, HEAD, PUT, and DELETE</strong> methods should be idempotent. A notable exception is the <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>Statelessness</h2>
			<p>A pure <a id="_idIndexMarker137"/>function should not depend on any state of the system. This means that neither the input nor the output should change the state. Web requests <a id="_idIndexMarker138"/>are often said to be stateless; each request can run independently of the other and still generate the same result. In Go terms, this also means that our function should not depend on things such as global variables, files on our filesystem, or general <span class="No-Break">I/O operations.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Side effects</h2>
			<p>The properties <a id="_idIndexMarker139"/>mentioned previously tie together in creating <a id="_idIndexMarker140"/>functions that are free of side effects. A side effect is any operation that your function does that changes the state of your system. In the next chapter, we’ll dive deeper into what it means for the state to be immutable at the <strong class="source-inline">struct</strong> level. In this chapter, we’ll consider the state to mean the system within which your program <span class="No-Break">is operating.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Why does purity improve our code?</h1>
			<p>So far, we have <a id="_idIndexMarker141"/>looked into some properties of purely functional code. We’ve also seen some examples of both pure and impure functions. Now, let’s look at what benefits we can expect from writing pure <span class="No-Break">functional code.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Increases the testability of our code</h2>
			<p>When <a id="_idIndexMarker142"/>writing pure functions, your functions will be easier to test. This is a consequence of them being both idempotent <span class="No-Break">and stateless:</span></p>
			<ul>
				<li><strong class="bold">Idempotent</strong>: Run functions any number of times and get the <span class="No-Break">same result</span></li>
				<li><strong class="bold">Stateless</strong>: Each function will run independently of the state of <span class="No-Break">the system</span></li>
			</ul>
			<p>For idempotence, it’s easy to see how this would be true. In our test suite, if functions were to return different outputs for the same inputs, it would be hard to write tests for that function. After all, if you can’t predict the output of a certain function, you can only guess what value you should be testing for. The benefit of it being stateless might not be immediately obvious. This comes down to our test suite not being able to run in the same environment as our production system. Thus, if we were relying on the state of the system in some way, we would have to guarantee that our test state replicates the production state at the moment in which the function is called. Let’s demonstrate this with <span class="No-Break">an example.</span></p>
			<p>Recall from <a id="_idIndexMarker143"/>earlier in this chapter, when we created a function to select a random player for a game? Let’s refactor this code into something more testable. There are two changes we need to make – first, we need to make the function deterministic. It sounds like this breaks the randomization, and it does, but we’ll show how we can work around that soon. The second change we will make is to remove any side effects. In our first example, we had a <strong class="source-inline">panic</strong> function in case the randomization function returned an integer above 1. We’ll replace that panic by returning a tuple from our function containing <strong class="source-inline">(Player, error)</strong>, following the common error handling idiom in Go. With these changes, our new function looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func PlayerSelectPure(i int) (Player, error) {
	switch i {
	case 0:
		return PlayerOne, nil
	case 1:
		return PlayerTwo, nil
	}
	return Player(""), fmt.Errorf("no player matching input:  	        %v", i)
}</pre>
			<p>With these changes in place, our function is now deterministic. For each input, we always generate the same output, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
PlayerSelectPure(0) = PlayerOne, nil
PlayerSelectPure(1) = PlayerTwo, nil
PlayerSelectPure(n &gt; 1) = Player{}, error</pre>
			<p>Notice how in the last case, whereby <strong class="source-inline">n</strong> is larger than one, we are not simply returning <strong class="source-inline">nil</strong> and an error. This bears some explanation. The gist of it is that we’ll try to avoid using pointers in our code as much as possible. And, in Go, if you’re not working with pointers, you cannot represent <strong class="source-inline">nil</strong>. Exactly why we avoid this and what the implications are will be explained in detail in the following chapter, <a href="B18771_05.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
			<p>Now that we <a id="_idIndexMarker144"/>have seen what the expected output is for each case, and that we agree on this function being pure, we can write a test case to confirm that the output matches what <span class="No-Break">we expect:</span></p>
			<pre class="source-code">
func TestPlayerSelectionPure(t *testing.T) {
	selectPlayerOne, err := PlayerSelectPure(0)
	if selectPlayerOne != PlayerOne || err != nil {
		t.Errorf("expected %v but got %v\n", PlayerOne,  	            selectPlayerOne)
	}
	selectPlayerTwo, err := PlayerSelectPure(1)
	if selectPlayerTwo != PlayerTwo || err != nil {
		t.Errorf("expected %v but got %v\n", PlayerOne,  	            selectPlayerTwo)
	}
	_, err = PlayerSelectPure(2)
	if err == nil {
		t.Error("Expected error but received nil")
	}
}</pre>
			<p>Everything that is happening in the preceding code is pretty straightforward. For each valid input (0 and 1), we confirm that the first or second player is returned, respectively. For an input higher than 1, we confirm that an error is thrown. Technically, you could extend this unit test to exhaustively test all possible integer inputs and confirm that an error is thrown for each of them. That might be a tad too exhaustive for this simple <span class="No-Break">function, though.</span></p>
			<p>With this, only one thing remains to be addressed: our code is no longer selecting a random player, but rather it is expecting an integer input and returning a deterministic value. You might <a id="_idIndexMarker145"/>notice that we have merely shifted the problem, as the random selection function still needs to be present somewhere. This is correct. If we were to look at how we would be using this code in an actual game, we might find code <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func main() {
	random := rand.Intn(2)
	player.PlayerSelectPure(random)
	// start the game
}</pre>
			<p>Here, we can see a recurring pattern as we aim to improve the purity of our code. The strategy will be to limit the places where side effects and non-determinism can occur. When you shift the way you think about structuring your code to preferring function purity and isolating the locations where you break it, you might end up with 90% of pure code and 10% impure code. Sure, you’re not 100% purely functional, but we’re programming in Go and we can forgive ourselves for the 10% impure code. As we’ve explored in quite some detail, purely functional programming is a subset of functional programming. Also, there’s no pure functional programming police that will hunt you down if you write an <span class="No-Break">impure function.</span></p>
			<p>Does this mean it’s impossible to be entirely pure? Well, not quite. After all, there are purely functional programming languages such as Haskell that can be used in real-world production <a id="_idIndexMarker146"/>environments. The way they deal with these impure functions is by using a form of encapsulation, known as <strong class="bold">monads</strong>. While it is possible to create monads in Go, it might cause more friction than necessary, hence why I advocate for embracing the idea of functional rather than pure functional code. For fun and to be extensive in our exploration of purely functional code, we will take a look at monads in the <span class="No-Break">next chapter.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Increases the confidence in our code</h2>
			<p>While this goes hand in hand with improved testability, the improved confidence in your code goes <a id="_idIndexMarker147"/>beyond that. When dealing with impure functions and states, your program is harder to comprehend. If you work in a sufficiently complex system that has impure functions, and state mutations such as through global variables, it becomes harder to reason about. Imagine you are working in such a complex system, and a user reports a bug. If the system is mutable, you’d need to get a full understanding of what the entire system looked like at the moment the bug appeared just to begin to debug it. This can lead to many painful and wasted hours of debugging. There’s a <a id="_idIndexMarker148"/>popular notion, called the <strong class="bold">Heisenbug</strong>, which is a consequence of this. In this case, if the function that caused the bug depended on the state of the system, you might need to repeat the exact steps the user did just to replicate <span class="No-Break">the bug.</span></p>
			<p>An additional benefit is that our code becomes easier to debug. When debugging a program, any sufficiently advanced debugger will also show the state of your system during debugging. It will tell you what values were held in memory by the various parts of your program. That’s a great tool and can help you find bugs and eliminate them. But what if your program just doesn’t depend on such a state? This would eliminate the need for a crux such as the <span class="No-Break">advanced debugger.</span></p>
			<p>You could look at a single function, and reason about what it’s doing without having to also keep in mind what the rest of the system would look like at the moment of execution. Humans are bad at keeping things in our “working memory;” we can juggle about 7 +- 2 things at any given moment. If we optimize and try to make our program understandable by most humans, we’d have to limit the state variables to just 5. This is ignoring the fact that our function probably has some variables as well. As such, we quickly exceed the upper bound of our human <span class="No-Break">memory limits.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Improved confidence in function names and signatures</h2>
			<p>Another <a id="_idIndexMarker149"/>great benefit of improving the readability and understandability of your code is that you can suddenly gain extra confidence in your functions. Imagine you are reading a code base, and you encounter the following piece <span class="No-Break">of code:</span></p>
			<pre class="source-code">
func main() {
	i := 1
	for i &lt; 10 {
		i = add1(i)
		fmt.Printf("%v,", i)
	}
}</pre>
			<p>What <a id="_idIndexMarker150"/>would the output be? You may naturally assume that <strong class="source-inline">add1</strong> is a pure function, and the output would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
1,2,3,4,5,6,7,8,9,10,</pre>
			<p>But, you would be wrong. The actual output is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
1, 2, 3, 4, 5, 6, panic: can not increment any more
goroutine 1 [running]:
main.add1(...)
	/tmp/sandbox1318301126/prog.go:17
main.main()
	/tmp/sandbox1318301126/prog.go:10 +0xa5
Program exited.</pre>
			<p>To understand why, let’s take a look at the <span class="No-Break"><strong class="source-inline">add1</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func add1(input int) int {
	if input != 0 &amp;&amp; input &gt; rand.Intn(input) {
		panic("can not increment any more")
	}
	return input + 1
}</pre>
			<p>In the preceding function, we can see that the <strong class="source-inline">add1</strong> function is impure. It is not deterministic, as the outcome of each run depends on a random number being generated. Plus, it also creates a side effect. Each time a function has a <strong class="source-inline">panic</strong> statement in it, that statement produces a side effect outside of the normal outcome of your function. This was a bit of a contrived example, but it shows that when working in an environment <a id="_idIndexMarker151"/>where functions can contain side effects and are not idempotent, you lose some trust in the function <span class="No-Break">signature itself.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Safer concurrency</h2>
			<p>One of the selling points of Go, and a feature that sets it apart from many mainstream languages, is how <a id="_idIndexMarker152"/>easily it handles concurrency. With Go, it is incredibly easy to spin up multiple threads and have them work in parallel. This happens through the <strong class="bold">channels</strong> and <strong class="bold">goroutines</strong> concepts. There is much to be said about how concurrency works in Go, enough to deserve its entire book. What we will focus on here briefly is the correctness aspect of concurrency. Is it true that spinning up goroutines and processing in parallel is much easier in Go compared to, say, Java? What is not true is that it’s easier to write correct <span class="No-Break">concurrent code.</span></p>
			<p>Let’s take a look at some concurrent code. In this example, we will create a slice of integers and append to it in the <strong class="source-inline">addToSlice</strong> function. In our <strong class="source-inline">main</strong> function, we will push an integer to <span class="No-Break">the slice:</span></p>
			<pre class="source-code">
var (
	integers = []int{}
)
func addToSlice(i int, wg *sync.WaitGroup) {
	integers = append(integers, i)
	wg.Done()
}
func main() {
	wg := sync.WaitGroup{}
	numbersToAdd := 10
	wg.Add(numbersToAdd)
	for i := 0; i &lt; numbersToAdd; i++ {
		go addToSlice(i, &amp;wg)
	}
	wg.Wait()
	fmt.Println(integers)
}</pre>
			<p>Think about <a id="_idIndexMarker153"/>this program for a second and try to guess what the output would be. The correct answer is that this program's output is non-deterministic. We are running multiple threads in which we append to our slice, and at the end, we call <strong class="source-inline">wg.Done()</strong>. When working with these waitgroups, we pass along several threads to wait for. This is done in <strong class="source-inline">wg.Add(numbersToAdd)</strong>. Each time <strong class="source-inline">wg.Done()</strong> is called, the number of threads to wait for decrements by one. As we are working on a shared slice of integers in this example, it is impossible to predict exactly what that slice looked like when it was performing the <strong class="source-inline">add</strong> operation in the final thread. This means that our output could be all numbers randomly ordered such as <strong class="source-inline">[9 0 1 2 3 4 5 6 7 8]</strong>, but it’s equally possible that the output would just be <strong class="source-inline">[4 9 0 1 2]</strong>. Having mutable data sources in concurrent functions is a recipe for disaster, and leads to some pretty <span class="No-Break">hard-to-trace bugs.</span></p>
			<p>So, as you can see from this small snippet, it was incredibly simple to spin up multiple threads, but not quite so simple to avoid bugs in our code. Pure functions can help with this. Remember that when a function is pure, the same input always generates the same output without causing any <span class="No-Break">side effects.</span></p>
			<p>In this example, our side effect was mutating the slice, which is not thread-safe in Go. The program won’t crash but the result will be random. If we push pure functional programming <a id="_idIndexMarker154"/>to the extreme, we will eliminate all such impure functions, and in doing so, we could run all our functions infinitely in parallel without causing <span class="No-Break">any trouble.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In practice, there are ways to avoid this from happening using a mutex. Some libraries take care of parallelism and thus abstract away some of <span class="No-Break">the complexity.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>When not to write pure functions</h1>
			<p>So far, we have seen what pure functions are and what kind of advantages pure functions <a id="_idIndexMarker155"/>can provide. But we should at least spend a bit of time thinking about occasions where we might want to sacrifice function purity. Now, if you ask this question to “purists,” the answer to this question is probably along the lines of: “Never, nunca, jamais.” This is fine, and some languages make it pretty easy to write functional code without ever having to sacrifice function purity. But, let’s take a look at a few examples where it makes sense to sacrifice some function purity. Now, before we dive into these examples, let me be the first to acknowledge that all of these supposed problems are circumventable. And yes, a language such as Haskell handles this <span class="No-Break">mostly gracefully.</span></p>
			<p>But we are not programming in Haskell; we are programming in Go. And while Go allows us to write purely functional code if we wish to do so, some things are just easier to implement by temporarily forgiving ourselves for our sin of writing <span class="No-Break">impure code.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Input/output operations</h2>
			<p>Think about the implications of totally eradicating side effects from your code. If we say that we <a id="_idIndexMarker156"/>are writing purely functional code and have eliminated all side effects, we have also eliminated part of what generates value for our users. Any time we are getting input from a user or displaying input to a user in some way, it is technically a side effect. Any time we are storing data in local storage, or uploading to a server somewhere, we are producing a side effect. Many applications will take some type of input, and many will also generate some kind <span class="No-Break">of output.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Non-determinism can be desired</h2>
			<p>Another <a id="_idIndexMarker157"/>reason why we might not want to create pure functions is when the non-deterministic nature fits within the domain of what we are building. If we are building a game of Monopoly, it is the desired effect to have a <strong class="source-inline">rollDice</strong> function return a non-deterministic result. The game of Monopoly example was no accident. Randomness is inherent in many of the games we see around us, and thus a domain where pure determinism is not the desired outcome of <span class="No-Break">each function.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>When we really have to panic!</h2>
			<p>When your program is in a state whereby it is impossible to continue operating normally, the <a id="_idIndexMarker158"/>typical way of handling that is by using a <strong class="source-inline">panic</strong>. While panics should be used sparingly, they are instances of the side effects that you are generating. Earlier in this chapter, we saw an example where a function would unpredictably panic during its execution. That example was artificial and a pretty bad use case for the <strong class="source-inline">panic</strong> function. But that does not mean that there are never any valid reasons to use <strong class="source-inline">panic</strong>. For example, if you are trying to reserve memory beyond the memory that is available on the system, that could be a cause for <strong class="source-inline">panic</strong>. In general, <strong class="source-inline">panic</strong> should be used to signal that the normal operation can’t proceed and there’s no way to gracefully continue running <span class="No-Break">the application.</span></p>
			<p>Two things are worth pointing out. The first one is that using the <strong class="source-inline">panic</strong> keyword should be the exception rather than the role. The second is that there is a common error handling paradigm in Go, namely returning a tuple containing a potential error value. Returning an error from a function is a distinct operation from using <strong class="source-inline">panic</strong> and serves a different <span class="No-Break">use case.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>How do we create pure functions?</h1>
			<p>So far in <a id="_idIndexMarker159"/>this chapter, we have taken a look at some properties of pure functions. We have also touched on some of the advantages we can gain by writing all our functions as pure functions. Now, let’s look at some things we can do to make it easier to write <span class="No-Break">pure functions.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Avoid global state</h2>
			<p>One of the ways we can facilitate writing pure functional code is by avoiding the global state in our programs. In Go, this comes down to avoiding the use of <strong class="source-inline">const</strong> and <strong class="source-inline">var</strong> blocks at <a id="_idIndexMarker160"/>the package level as much as possible. When you see these blocks, there’s a good chance that the program state is relied upon by some functions, thus generating either side effects or having non-deterministic program execution. While it’s not always possible to completely avoid such state variables, we should try to limit their use as much as possible. The way to prevent a function from relying on this state is by having the state pass to the function through a normal function argument. This is rather straightforward. The following is a small example, once using state from a <strong class="source-inline">var</strong> block and <span class="No-Break">once without:</span></p>
			<pre class="source-code">
var (
	name = "Remi"
)
func sayHello() string {
	return fmt.Sprintf("hello %s", name)
}
func main() {
	sayHello()
}</pre>
			<p>We could get the same functionality as the preceding block without the <strong class="source-inline">var</strong> block by simply passing the <strong class="source-inline">name</strong> parameter as input to <span class="No-Break">our function:</span></p>
			<pre class="source-code">
func sayHello(name string) string {
	return fmt.Sprintf("hello %s", name)
}
func main() {
	sayHello("Remi")
}</pre>
			<p>That’s <a id="_idIndexMarker161"/>the gist of it. Next, let’s look at a general way of dealing with code that contains <span class="No-Break">impure elements.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>Separate pure and impure functionality</h2>
			<p>As mentioned earlier, it’s hard to be completely pure. We should not aim to eradicate I/O operations, API calls, and so on as by eliminating these, we’d likely be throwing out most of <a id="_idIndexMarker162"/>what makes our programs valuable. The main exercise will be in trying to create as many small, pure functions as possible and composing these into a larger program. There will still be side effects, but we’ll limit <span class="No-Break">their occurrence.</span></p>
			<h3>Bubbling up errors</h3>
			<p>A somewhat common side effect is generated by errors. Our programs end up in a state where they <a id="_idIndexMarker163"/>do not continue gracefully and there’s no real way to circumvent this. One way to isolate the pure and impure aspects here is by using the Go error-handling idiom and essentially “bubbling up” errors to a common layer where they can be handled. We saw this earlier in our example of selecting random players. Since Go 1.13, there are additional built-in tools available for bubbling <span class="No-Break">up errors.</span></p>
			<h3>Each function does exactly one thing</h3>
			<p>This is good advice in general. Generally speaking, a function should only do one thing, which <a id="_idIndexMarker164"/>significantly reduces the odds of our function creating a side effect. You find this same principle in traditional object-oriented languages as well. The industry more or less agrees that this is the way, but it’s surprisingly easy to break this good intention. Take a look at the following code of a simple <span class="No-Break">addition function:</span></p>
			<pre class="source-code">
 func add(a, b int) int {
	sum := a + b
	fmt.Println(sum)
	return sum
}</pre>
			<p>This is not a pure function. The side effect of this snippet is that we are printing the <strong class="source-inline">sum</strong> value to the standard output. Sure enough, this is pretty harmless, but if our users rely on this functionality, how do we ensure this function works properly? In other words, how would you go about testing that this function prints the correct output to <span class="No-Break">the screen?</span></p>
			<p>A variant <a id="_idIndexMarker165"/>of this could be writing to the filesystem or a database call as part of a function where that should not be the case. Let’s take a look at a function for signing up new users to a service. We expect the input to be a username and a password, and there’s some logic defined on the <strong class="source-inline">User</strong> struct to ensure the password is compliant with <span class="No-Break">password rules:</span></p>
			<pre class="source-code">
func createUser(username, password string) {
	u := User{username, password}
	if u.validPassword() {
		userDb.save(u)
	} else {
		panic("invalid password")
	}
}</pre>
			<p>The issue with this function is that it tries to do two things. First, it creates a new user struct and confirms that the password is compliant. Next, it stores the <strong class="source-inline">User</strong> struct in a database, assuming that the password is valid; otherwise, it panics. We could have split this into multiple functions, one for validating the password, one for storing the user, and a third function for <span class="No-Break">orchestrating this:</span></p>
			<pre class="source-code">
func signup(username, password string) {
	user, err := createUser(username, password)
	if err != nil {
		saveUser(user)
	} else {
		Panic("Could not create account")
	}
}
func createUser(username, password string) (User, error) {
	u := User{username, password}
	if u.validPassword() {
		return u, nil
	}
	return User{}, Errors.new("invalid password")
}
func saveUser(u User) {
	userDb.save(u)
}</pre>
			<p>In the <a id="_idIndexMarker166"/>preceding example, we have separated the concerns, but we’re still left with two impure functions. However, the problems are now more contained tough within a single function. This code is not perfect yet, and there’s still room for improvement, as we will see in the next chapter. Before we go there, though, let’s take a look at a more <span class="No-Break">extensive example.</span></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Example 1 – hotdog shop</h1>
			<p>For our <a id="_idIndexMarker167"/>first example, we are going to take a look at some code that has been written in an impure way, and which is pretty much violating all good sense for writing pure functions. We’ll refactor this code as we go along to create more testable code, along with improving the readability and understandability of <span class="No-Break">the code.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Bad hotdog shop</h2>
			<p>First, let’s take a look at how not to create this hotdog shop system. We’ll start by defining a constant, a global variable that dictates the price of <span class="No-Break">our hotdog:</span></p>
			<pre class="source-code">
const (
	HOTDOG_PRICE = 4
)</pre>
			<p>Next, we’ll create some structs. We will need a struct to represent a hotdog, as well as a struct to <a id="_idIndexMarker168"/>hold our credit card information. To keep things simple, the hotdog does not hold any state variables at the moment, while the credit card only stores the credit that is available on the card. Credit in this example is an integer value. It’s not something that accurately represents a monetary value in real life, but it’s good enough for <span class="No-Break">this example:</span></p>
			<pre class="source-code">
type CreditCard struct {
	credit int
}
type Hotdog struct{}</pre>
			<p>With these defined, we can get to the first piece of functionality that we care about. We need a way to charge our credit card for a <span class="No-Break">certain value:</span></p>
			<pre class="source-code">
func (c *CreditCard) charge(amount int) {
	if amount &lt;= c.credit {
		c.credit -= amount
	} else {
		panic("no more credit")
	}
}</pre>
			<p>In the preceding <strong class="source-inline">charge</strong> method, we are charging the credit card for a certain amount by decreasing the credit available on the card. If there isn’t enough credit available to make the charge, we are using <strong class="source-inline">panic</strong> to halt the program. For now, the main issue with this function is the use of side effects. There are two of them. First, we are using <strong class="source-inline">panic</strong> if a certain branch is hit. The next side effect is that we are changing the state of <strong class="source-inline">CreditCard</strong>. Struct immutability is a topic we’ll cover in detail in the next chapter, so let’s close our eyes to this issue for now and continue writing the rest of our hotdog shop. The most important function for a user is to order a hotdog. So, let’s take a look at an implementation for <span class="No-Break">doing so:</span></p>
			<pre class="source-code">
func orderHotdog(c *CreditCard) Hotdog {
	c.charge(HOTDOG_PRICE)
	return Hotdog{}
}</pre>
			<p>The preceding code is, again, impure code. The credit card of the user is being charged by a price <a id="_idIndexMarker169"/>defined outside of the function, using the global state. This function is doing more than one thing – it is both creating a hotdog to return to the user as well as charging their <span class="No-Break">credit card.</span></p>
			<p>Think about how you would test this for a second. It is possible to test this – but not convenient. You need to test or mock the credit card to also ensure a hotdog is being returned from this function. Furthermore, you have to capture a potential panic, which is not happening in the <strong class="source-inline">orderHotdog</strong> function but rather a call deeper. In addition, because <strong class="source-inline">charge</strong> is also impure, a reader of <strong class="source-inline">orderHotdog</strong> has no idea that <strong class="source-inline">charge</strong> <em class="italic">might</em> panic unless they take a look at that specific function as well. As we learned earlier, pure functional code gives us more confidence when reading code. We trust that a function does what it says it will – nothing more, nothing less. With that in mind, let’s take a look at how we can refactor <span class="No-Break">this code.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>Better hotdog shop</h2>
			<p>In this <a id="_idIndexMarker170"/>version of the hotdog shop, we will try to address some of the issues we found in the previous example. The full code can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop</span></a><span class="No-Break">.</span></p>
			<p>Let’s start by defining <span class="No-Break">our types:</span></p>
			<pre class="source-code">
type CreditCard struct {
	credit int
}
type Hotdog struct {
	price int
}
type CreditError error
type PaymentFunc func(CreditCard, int) (CreditCard, 
  CreditError)</pre>
			<p>Here, we have defined all the types we need to represent data in this small application. Our <strong class="source-inline">CreditCard</strong> struct contains an integer amount of credit, and our <strong class="source-inline">hotdog</strong> costs an <a id="_idIndexMarker171"/>integer amount as well. We have defined a <strong class="bold">type alias</strong> for <strong class="source-inline">error</strong> called <strong class="source-inline">CreditError</strong>, as well as a type alias for a payment function. Let’s also set up some constructor-like functions for our <strong class="source-inline">CreditCard</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Hotdog</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func NewCreditCard(initialCredit int) CreditCard {
	return CreditCard{credit: initialCredit}
}
func NewHotdog() Hotdog {
	return Hotdog{price: 4}
}</pre>
			<p>These are pretty straightforward. We will add a global variable to represent an error whereby a user does not have enough credit to perform an operation on the <span class="No-Break">credit card:</span></p>
			<pre class="source-code">
var (
	NOT_ENOUGH_CREDIT CreditError = CreditError(errors.
      New("not enough credit"))
)</pre>
			<p>As you may recall, earlier, I advocated against using these types of package-level declarations. That’s still true and I’d advocate avoiding using them as much as possible. For error declarations, however, this is pretty much the accepted, idiomatic way of writing <span class="No-Break">Go code.</span></p>
			<p>We could avoid it here and instantiate the error in-line wherever it is applicable, but that will slightly hurt the testing code, which we’ll write later. In general, keep in mind that I advocate <em class="italic">functional programming</em> in Go, not <em class="italic">pure </em><span class="No-Break"><em class="italic">functional programming</em></span><span class="No-Break">.</span></p>
			<p>Either way, let’s write our first non-trivial function. We will rewrite the initial <strong class="source-inline">charge</strong> function <a id="_idIndexMarker172"/>in a pure way. The goal here is to eliminate the initial side effect that we had not by using <strong class="source-inline">panic</strong> but rather by returning a tuple containing a <span class="No-Break">potential error:</span></p>
			<pre class="source-code">
func Charge(c CreditCard, amount int) (CreditCard, CreditError) {
	if amount &lt;= c.credit {
		c.credit -= amount
		return c, nil
	}
	return c, NOT_ENOUGH_CREDIT
}</pre>
			<p>As you can tell in the preceding snippet, we are not only returning an error value, but we are also returning a value of the <strong class="source-inline">CreditCard</strong> type. This is not the same <strong class="source-inline">CreditCard</strong> that is passed to the function by a caller. As we are not using a pointer to <strong class="source-inline">CreditCard</strong>, when a function calls <strong class="source-inline">Charge</strong>, <strong class="bold">a copy</strong> of <strong class="source-inline">CreditCard</strong> will be used inside the <strong class="source-inline">Charge</strong> function. As we are working on a copy, the <strong class="source-inline">c.credit -= amount</strong> statement only impacts the copy and not the original <strong class="source-inline">CreditCard</strong>. This is a common pitfall for newer Go programmers. In the next chapter, we will dive into immutability in greater detail and discuss the trade-off between this approach and the pointer-based function calls. But suffice it to say that this current function is <span class="No-Break"><em class="italic">pure enough</em></span><span class="No-Break">.</span></p>
			<p>This <strong class="source-inline">Charge</strong> function is also easily testable. Let’s write a unit test to make sure the behavior is as we expect. First, we will define our test cases. The following structure is the setup for a <span class="No-Break"><em class="italic">table-driven test</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var (
	testChargeStruct = []struct {
		inputCard  CreditCard
		amount     int
		outputCard CreditCard
		err        CreditError
	}{
		{
			CreditCard{1000},
			500,
			CreditCard{500},
			nil,
		},
		{
			CreditCard{20},
			20,
			CreditCard{0},
			nil,
		},
		{
			CreditCard{150},
			1000,
			CreditCard{150},   // no money is withdrawn
			NOT_ENOUGH_CREDIT, 
               // payment fails with this error
		},
	}
)</pre>
			<p>In the preceding snippet, we are testing a few paths that our code can take. We can try to charge the credit card when we have more credit available than the cost, when we have the <a id="_idIndexMarker173"/>exact amount available, or when we don’t have enough credit available. With this table structure, adding more test cases is trivial. Now, let’s write the unit test itself, which will just run a test for each of the test cases <span class="No-Break">defined previously:</span></p>
			<pre class="source-code">
func TestCharge(t *testing.T) {
	for _, test := range testChargeStruct {
		t.Run("", func(t *testing.T) {
			output, err := Charge(test.inputCard, test. 	                     amount)
			if output != test.outputCard || !errors. 	 	                  Is(err, test.err) {
				t.Errorf("expected %v but got %v\n,  	                         error expected %v but got %v",
				test.outputCard, output, test.err, err)
			}
		})
	}
}</pre>
			<p>Et voilà! A complete unit test for the charge function. Something that would have been nigh impossible in the impure example. Now, let’s also refactor the <strong class="source-inline">OrderHotdog</strong> function that we had earlier. As with anything, there are multiple ways to tackle this problem. The solution that we are implementing here is using a higher-order function to delay computation to a later stage. This will move the side effect of actually charging the credit card up the <span class="No-Break">call chain:</span></p>
			<pre class="source-code">
func OrderHotdog(c CreditCard, pay PaymentFunc) (Hotdog, func() (CreditCard, error)) {
	hotdog := NewHotdog()
	chargeFunc := func() (CreditCard, error) {
		return pay(c, hotdog.price)
	}
	return hotdog, chargeFunc
}</pre>
			<p>Let’s <a id="_idIndexMarker174"/>unpack what’s happening here. First, there’s our function signature. The <strong class="source-inline">OrderHotdog</strong> function still accepts <strong class="source-inline">CreditCard</strong> as input, but also a <strong class="source-inline">PaymentFunc</strong>. Recall that we defined <strong class="source-inline">PaymentFunc</strong> as a function that takes a <strong class="source-inline">CreditCard</strong> and an <strong class="source-inline">int</strong>, and returns a <strong class="source-inline">CreditCard</strong> and a <strong class="source-inline">CreditError</strong>. The <strong class="source-inline">OrderHotdog</strong> function returns the <strong class="source-inline">Hotdog</strong> itself, as well as a function that will return a <strong class="source-inline">CreditCard</strong> and an <strong class="source-inline">error</strong>. This might be a bit confusing at first but will become clearer in the <span class="No-Break">function body.</span></p>
			<p>The first step is creating a new hotdog. After this, we must create a new function in-line. Recall that this is possible because Go supports functions as first-class citizens. Inside this function, we are calling <strong class="source-inline">pay</strong>, with the provided credit card, for the price of a hotdog. This is a <strong class="bold">closure</strong>, which we have explored in earlier chapters. Our <strong class="source-inline">OrderHotdog</strong> function then returns the hotdog and the newly created function. It’s important to note that <strong class="source-inline">chargeFunc</strong> is not executed when the <strong class="source-inline">OrderHotdog</strong> function is called. No side effect is occurring in this function; the side effect is deferred to a later stage. Once again, we are going to try to isolate our side effects as much as possible. Higher up the call chain is a better place for side effects as our code is typically read from higher to lower levels of abstraction. This avoids surprises somewhere hidden in the <span class="No-Break">implementation details.</span></p>
			<p>With this, we have recreated the functionality of the original hotdog shop. Before we take a look at testing <strong class="source-inline">OrderHotdog</strong>, we will first look at an example of how we would use this function. In the following <strong class="source-inline">main</strong> function, we are going to order a hotdog and subsequently call the <strong class="source-inline">pay</strong> function to charge our <span class="No-Break">credit card:</span></p>
			<pre class="source-code">
func main() {
	myCard := NewCreditCard(1000)
	hotdog, creditFunc := OrderHotdog(myCard, Charge)
	fmt.Printf("%+v\n", hotdog)
	newCard, err := creditFunc()
	if err != nil {
		panic("User has no credit")
	}
	myCard = newCard
	fmt.Printf("%+v\n", myCard)
}</pre>
			<p>There we go – a usable example of ordering a hotdog. Let’s look at how we are calling <strong class="source-inline">OrderHotdog</strong>. We are passing both the credit card, as well as the <strong class="source-inline">Charge</strong> function we wrote earlier. You can run this example in the GitHub example repository and play around with it. Let’s also confirm that this code is testable by writing a unit <span class="No-Break">test function.</span></p>
			<p>We don’t <a id="_idIndexMarker175"/>need a table-driven test for this. The <strong class="source-inline">OrderHotdog</strong> function needs to be tested to ensure that it does <span class="No-Break">the following:</span></p>
			<ul>
				<li>Creates a <span class="No-Break">new hotdog</span></li>
				<li>Creates a function that calls the <span class="No-Break">payment function</span></li>
				<li>Returns both the hotdog and <span class="No-Break">the function</span></li>
			</ul>
			<p>Our test function will confirm that a new hotdog has been created and that a payment function is called. As this is a unit test, we don’t care about the payment function itself. We will mock a payment function to ensure that it is called from the returned function. The actual <strong class="source-inline">charge</strong> function is tested separately, as we <span class="No-Break">saw earlier:</span></p>
			<pre class="source-code">
func TestOrderHotdog(t *testing.T) {
	testCC := CreditCard{1000}
	calledInnerFunction := false
	mockPayment := func(c CreditCard, input int) (CreditCard, 
      CreditError) {
		calledInnerFunction = true
		testCC.credit -= input
		return testCC, nil
	}
	hotdog, resultF := OrderHotdog(testCC, mockPayment)
	if hotdog != NewHotdog() {
		t.Errorf("expected %v but got %v\n", NewHotdog(), 
            hotdog)
	}
	_, err := resultF()
	if err != nil {
		t.Errorf("encountered %v but expected no error\n", 
            err)
	}
	if calledInnerFunction == false {
		t.Errorf("Inner function did not get called\n")
	}
}</pre>
			<p>In the <a id="_idIndexMarker176"/>preceding code, we are strictly testing that our function is creating the correct values for the hotdog and the closure. A correct closure function in this case implies that the function that is returned calls the payment function that is passed to it. Notice how we could mock away the original behavior and create a <strong class="source-inline">bool</strong> to ensure that the function is called. Once <a id="_idIndexMarker177"/>again, this is the power of having first-class functions <span class="No-Break">in Go.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Summary</h1>
			<p>In this chapter, we looked at pure functional programming. First, we looked at what exactly it means for a programming language to be pure and functional as opposed to impure and functional. Next, we took a more detailed look at how pure code can help improve testability by eliminating side effects. We also learned that pure code gives readers more confidence in the code that they are reading since functions are more predictable and won’t change the state of the system. We also discussed when we should not use pure functions, such as when dealing with functions that should generate random behavior for games or functions that deal <span class="No-Break">with I/O.</span></p>
			<p>Although we have only briefly touched on it, we have seen how immutability plays a core part in writing pure functions by not changing the values of structs. In the next chapter, we will take a deep dive into immutability, how it does (or doesn’t) impact performance, and how we can leverage this in combination with pure functions to write more <span class="No-Break">maintainable code.</span></p>
		</div>
	</body></html>