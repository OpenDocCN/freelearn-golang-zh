["```go\nfunc add(a, b int) int {\n\treturn a + b\n}\n```", "```go\nfunc rollDice() int {\n\treturn rand.Intn(6)\n}\n```", "```go\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Printf(\"dice roll: %v\\n\", rollDice())\n\t}\n}\n```", "```go\ndice roll: 5\ndice roll: 3\ndice roll: 5\ndice roll: 5\ndice roll: 1\n```", "```go\nX = 1 + (2 * 2)\n```", "```go\nX = (1 + 4)\n```", "```go\nfunc main() {\n\tfmt.Printf(\"%v\\n\", add(10, add(10, 5)))\n\tfmt.Printf(\"%v\\n\", add(10, 15))\n}\nfunc add(a, b int) int {\n\treturn a + b\n}\n```", "```go\nfunc main() {\n\tfmt.Printf(\"%v\\n\", time.Now())\n}\n```", "```go\ntype Player string\nconst (\n\tPlayerOne Player = \"Remi\"\n\tPlayerTwo Player = \"Yvonne\"\n)\nfunc selectStartingPlayer() Player {\n\trandomized := rand.Intn(2)\n\tswitch randomized {\n\tcase 0:\n\t\treturn PlayerOne\n\tcase 1:\n\t\treturn PlayerTwo\n\t}\n\tpanic(\"No further player available\")\n}\n```", "```go\nfunc PlayerSelectPure(i int) (Player, error) {\n\tswitch i {\n\tcase 0:\n\t\treturn PlayerOne, nil\n\tcase 1:\n\t\treturn PlayerTwo, nil\n\t}\n\treturn Player(\"\"), fmt.Errorf(\"no player matching input:  \t        %v\", i)\n}\n```", "```go\nPlayerSelectPure(0) = PlayerOne, nil\nPlayerSelectPure(1) = PlayerTwo, nil\nPlayerSelectPure(n > 1) = Player{}, error\n```", "```go\nfunc TestPlayerSelectionPure(t *testing.T) {\n\tselectPlayerOne, err := PlayerSelectPure(0)\n\tif selectPlayerOne != PlayerOne || err != nil {\n\t\tt.Errorf(\"expected %v but got %v\\n\", PlayerOne,  \t            selectPlayerOne)\n\t}\n\tselectPlayerTwo, err := PlayerSelectPure(1)\n\tif selectPlayerTwo != PlayerTwo || err != nil {\n\t\tt.Errorf(\"expected %v but got %v\\n\", PlayerOne,  \t            selectPlayerTwo)\n\t}\n\t_, err = PlayerSelectPure(2)\n\tif err == nil {\n\t\tt.Error(\"Expected error but received nil\")\n\t}\n}\n```", "```go\nfunc main() {\n\trandom := rand.Intn(2)\n\tplayer.PlayerSelectPure(random)\n\t// start the game\n}\n```", "```go\nfunc main() {\n\ti := 1\n\tfor i < 10 {\n\t\ti = add1(i)\n\t\tfmt.Printf(\"%v,\", i)\n\t}\n}\n```", "```go\n1,2,3,4,5,6,7,8,9,10,\n```", "```go\n1, 2, 3, 4, 5, 6, panic: can not increment any more\ngoroutine 1 [running]:\nmain.add1(...)\n\t/tmp/sandbox1318301126/prog.go:17\nmain.main()\n\t/tmp/sandbox1318301126/prog.go:10 +0xa5\nProgram exited.\n```", "```go\nfunc add1(input int) int {\n\tif input != 0 && input > rand.Intn(input) {\n\t\tpanic(\"can not increment any more\")\n\t}\n\treturn input + 1\n}\n```", "```go\nvar (\n\tintegers = []int{}\n)\nfunc addToSlice(i int, wg *sync.WaitGroup) {\n\tintegers = append(integers, i)\n\twg.Done()\n}\nfunc main() {\n\twg := sync.WaitGroup{}\n\tnumbersToAdd := 10\n\twg.Add(numbersToAdd)\n\tfor i := 0; i < numbersToAdd; i++ {\n\t\tgo addToSlice(i, &wg)\n\t}\n\twg.Wait()\n\tfmt.Println(integers)\n}\n```", "```go\nvar (\n\tname = \"Remi\"\n)\nfunc sayHello() string {\n\treturn fmt.Sprintf(\"hello %s\", name)\n}\nfunc main() {\n\tsayHello()\n}\n```", "```go\nfunc sayHello(name string) string {\n\treturn fmt.Sprintf(\"hello %s\", name)\n}\nfunc main() {\n\tsayHello(\"Remi\")\n}\n```", "```go\n func add(a, b int) int {\n\tsum := a + b\n\tfmt.Println(sum)\n\treturn sum\n}\n```", "```go\nfunc createUser(username, password string) {\n\tu := User{username, password}\n\tif u.validPassword() {\n\t\tuserDb.save(u)\n\t} else {\n\t\tpanic(\"invalid password\")\n\t}\n}\n```", "```go\nfunc signup(username, password string) {\n\tuser, err := createUser(username, password)\n\tif err != nil {\n\t\tsaveUser(user)\n\t} else {\n\t\tPanic(\"Could not create account\")\n\t}\n}\nfunc createUser(username, password string) (User, error) {\n\tu := User{username, password}\n\tif u.validPassword() {\n\t\treturn u, nil\n\t}\n\treturn User{}, Errors.new(\"invalid password\")\n}\nfunc saveUser(u User) {\n\tuserDb.save(u)\n}\n```", "```go\nconst (\n\tHOTDOG_PRICE = 4\n)\n```", "```go\ntype CreditCard struct {\n\tcredit int\n}\ntype Hotdog struct{}\n```", "```go\nfunc (c *CreditCard) charge(amount int) {\n\tif amount <= c.credit {\n\t\tc.credit -= amount\n\t} else {\n\t\tpanic(\"no more credit\")\n\t}\n}\n```", "```go\nfunc orderHotdog(c *CreditCard) Hotdog {\n\tc.charge(HOTDOG_PRICE)\n\treturn Hotdog{}\n}\n```", "```go\ntype CreditCard struct {\n\tcredit int\n}\ntype Hotdog struct {\n\tprice int\n}\ntype CreditError error\ntype PaymentFunc func(CreditCard, int) (CreditCard, \n  CreditError)\n```", "```go\nfunc NewCreditCard(initialCredit int) CreditCard {\n\treturn CreditCard{credit: initialCredit}\n}\nfunc NewHotdog() Hotdog {\n\treturn Hotdog{price: 4}\n}\n```", "```go\nvar (\n\tNOT_ENOUGH_CREDIT CreditError = CreditError(errors.\n      New(\"not enough credit\"))\n)\n```", "```go\nfunc Charge(c CreditCard, amount int) (CreditCard, CreditError) {\n\tif amount <= c.credit {\n\t\tc.credit -= amount\n\t\treturn c, nil\n\t}\n\treturn c, NOT_ENOUGH_CREDIT\n}\n```", "```go\nvar (\n\ttestChargeStruct = []struct {\n\t\tinputCard  CreditCard\n\t\tamount     int\n\t\toutputCard CreditCard\n\t\terr        CreditError\n\t}{\n\t\t{\n\t\t\tCreditCard{1000},\n\t\t\t500,\n\t\t\tCreditCard{500},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\tCreditCard{20},\n\t\t\t20,\n\t\t\tCreditCard{0},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\tCreditCard{150},\n\t\t\t1000,\n\t\t\tCreditCard{150},   // no money is withdrawn\n\t\t\tNOT_ENOUGH_CREDIT, \n               // payment fails with this error\n\t\t},\n\t}\n)\n```", "```go\nfunc TestCharge(t *testing.T) {\n\tfor _, test := range testChargeStruct {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\toutput, err := Charge(test.inputCard, test. \t                     amount)\n\t\t\tif output != test.outputCard || !errors. \t \t                  Is(err, test.err) {\n\t\t\t\tt.Errorf(\"expected %v but got %v\\n,  \t                         error expected %v but got %v\",\n\t\t\t\ttest.outputCard, output, test.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "```go\nfunc OrderHotdog(c CreditCard, pay PaymentFunc) (Hotdog, func() (CreditCard, error)) {\n\thotdog := NewHotdog()\n\tchargeFunc := func() (CreditCard, error) {\n\t\treturn pay(c, hotdog.price)\n\t}\n\treturn hotdog, chargeFunc\n}\n```", "```go\nfunc main() {\n\tmyCard := NewCreditCard(1000)\n\thotdog, creditFunc := OrderHotdog(myCard, Charge)\n\tfmt.Printf(\"%+v\\n\", hotdog)\n\tnewCard, err := creditFunc()\n\tif err != nil {\n\t\tpanic(\"User has no credit\")\n\t}\n\tmyCard = newCard\n\tfmt.Printf(\"%+v\\n\", myCard)\n}\n```", "```go\nfunc TestOrderHotdog(t *testing.T) {\n\ttestCC := CreditCard{1000}\n\tcalledInnerFunction := false\n\tmockPayment := func(c CreditCard, input int) (CreditCard, \n      CreditError) {\n\t\tcalledInnerFunction = true\n\t\ttestCC.credit -= input\n\t\treturn testCC, nil\n\t}\n\thotdog, resultF := OrderHotdog(testCC, mockPayment)\n\tif hotdog != NewHotdog() {\n\t\tt.Errorf(\"expected %v but got %v\\n\", NewHotdog(), \n            hotdog)\n\t}\n\t_, err := resultF()\n\tif err != nil {\n\t\tt.Errorf(\"encountered %v but expected no error\\n\", \n            err)\n\t}\n\tif calledInnerFunction == false {\n\t\tt.Errorf(\"Inner function did not get called\\n\")\n\t}\n}\n```"]