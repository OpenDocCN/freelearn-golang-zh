- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Testable Code with Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you read about functional programming, quite often, what is meant is “pure”
    functional programming. As we touched on in the first chapter, this is not a strict
    requirement of functional programming or functional languages. If you decide to
    pick up a functional programming language, the chances are pretty high that you’ll
    pick up a language such as Haskell or Elm. If so, you would have chosen two purely
    functional languages and might have coupled your understanding of *pure functional*
    with *functional*. On the other hand, if you had picked up a language such as
    Lisp, Clojure, or Erlang, you would have picked a functional language that is
    impure yet still functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will address the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is purity?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should purity matter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we create pure functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how unit testing is impacted by writing pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, any version of Go after Go 1.12 can be used. You can find
    the complete examples at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4).
  prefs: []
  type: TYPE_NORMAL
- en: What is purity?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When talking about a purely functional programming language, we are talking
    about a language in which each function adheres to these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Does not generate any side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the same output when providing the same input (idempotence)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that our functions are completely deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: The best way forward might be to demonstrate what we are talking about by showing
    some examples. So, in this section, we’ll take a look at two functions, a pure
    one and another which is impure. Then, we’ll talk a bit more about the properties
    of such functions and their importance to the programs that we are writing.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating pure versus impure function calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple example of this would be an addition function. This is a function
    that takes two integers as input and returns the sum as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call this function with the same inputs, we will get consistent output.
    Thus, no matter how many times I call the `add(10,5)` function, the code will
    always return the same output: 15\. This is pretty much as simple as it gets when
    creating a pure function. We did not use any state outside of our function to
    determine the answer, nor did we update anything outside of our function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at an example of an impure function, whose output is always
    random:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling the `rollDice` function, the output is not consistent. If it were
    consistently outputting the same number, it would be a pretty bad randomization
    function. If we were to call the `rollDice` function five times, we’d get five
    different outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This would result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Referential transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One property that helps us think about pure functions is the property of *referential
    transparency*. Both in mathematics and computer science, a function is said to
    be referentially transparent if you can replace the function call with its output,
    without changing the result of the program. In mathematics, it’s easy to see why
    that is true. If we work out any formula, we can essentially substitute part of
    an equation for its result, without changing the result. For example, take the
    following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is 5\. We could have gotten the same result had we replaced the
    multiplication with its result, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This property is what we mean by referential transparency. All mathematical
    operations have this property, and many of us have leveraged this property when
    working out equations in our algebra, calculus, or other mathematics classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s jump back to the realm of software engineering to explore this further.
    In a programming language, referential transparency means that a function call
    can be replaced with its result. If we apply this same test to our `add` function,
    which we wrote earlier, we can see how this is true. Let’s demonstrate this with
    a small piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have replaced one of the `add` functions with its result.
    And sure enough, the output of our program remained identical and functionally
    correct. You might think this is obvious, but there are plenty of functions that
    we rely on for which this is not true. Let’s introduce another function that breaks
    this property. We’ll keep it simple and create a program that tells us the current
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we are using the `time.Now` function. There’s not a single
    value that you can replace this function call with while guaranteeing your program
    is functionally equivalent and correct. If we were to hardcode the current time,
    it would be wrong by the time your program has compiled and when it’s run.
  prefs: []
  type: TYPE_NORMAL
- en: 'To expand on this, let’s take a look at a larger example than just the `time.Now`
    function. In the following piece of code, let’s imagine we are writing a function
    to select the starting player of a game. We’ll use a simple type alias from `Player`
    to `string` instead of making a complete struct. As this is a game, we want our
    starting player to be randomly selected on each run of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are breaking the referential transparency requirement
    of our code since there is no way to replace this function call with a single
    value while maintaining an equivalent outcome of our program. The preceding code
    is also not testable. Think about this for a second – how would you write a unit
    test for this function? This would prove impossible to do in the code’s current
    state and would require some refactoring. We will show you how we could refactor
    this code and make it testable later in this chapter, but you can find it on GitHub
    at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode).
  prefs: []
  type: TYPE_NORMAL
- en: Idempotence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another property of pure functions is that they are idempotent. This means that
    no matter how many times the function is executed, it will always return the same
    output, assuming that the input arguments have remained the same. In the preceding
    example, the `add` function is always returning the same sum of two numbers provided
    the same input. On the other hand, the `time.Now` function is not (nor would that
    have been the desired behavior).
  prefs: []
  type: TYPE_NORMAL
- en: You might be familiar with idempotence as it also shows up when you are implementing
    a `REST` service or dealing with HTTP calls in general. When implemented correctly,
    the `GET, HEAD, PUT, and DELETE` methods should be idempotent. A notable exception
    is the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pure function should not depend on any state of the system. This means that
    neither the input nor the output should change the state. Web requests are often
    said to be stateless; each request can run independently of the other and still
    generate the same result. In Go terms, this also means that our function should
    not depend on things such as global variables, files on our filesystem, or general
    I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The properties mentioned previously tie together in creating functions that
    are free of side effects. A side effect is any operation that your function does
    that changes the state of your system. In the next chapter, we’ll dive deeper
    into what it means for the state to be immutable at the `struct` level. In this
    chapter, we’ll consider the state to mean the system within which your program
    is operating.
  prefs: []
  type: TYPE_NORMAL
- en: Why does purity improve our code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked into some properties of purely functional code. We’ve
    also seen some examples of both pure and impure functions. Now, let’s look at
    what benefits we can expect from writing pure functional code.
  prefs: []
  type: TYPE_NORMAL
- en: Increases the testability of our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing pure functions, your functions will be easier to test. This is
    a consequence of them being both idempotent and stateless:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Idempotent**: Run functions any number of times and get the same result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: Each function will run independently of the state of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For idempotence, it’s easy to see how this would be true. In our test suite,
    if functions were to return different outputs for the same inputs, it would be
    hard to write tests for that function. After all, if you can’t predict the output
    of a certain function, you can only guess what value you should be testing for.
    The benefit of it being stateless might not be immediately obvious. This comes
    down to our test suite not being able to run in the same environment as our production
    system. Thus, if we were relying on the state of the system in some way, we would
    have to guarantee that our test state replicates the production state at the moment
    in which the function is called. Let’s demonstrate this with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from earlier in this chapter, when we created a function to select a
    random player for a game? Let’s refactor this code into something more testable.
    There are two changes we need to make – first, we need to make the function deterministic.
    It sounds like this breaks the randomization, and it does, but we’ll show how
    we can work around that soon. The second change we will make is to remove any
    side effects. In our first example, we had a `panic` function in case the randomization
    function returned an integer above 1\. We’ll replace that panic by returning a
    tuple from our function containing `(Player, error)`, following the common error
    handling idiom in Go. With these changes, our new function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes in place, our function is now deterministic. For each input,
    we always generate the same output, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how in the last case, whereby `n` is larger than one, we are not simply
    returning `nil` and an error. This bears some explanation. The gist of it is that
    we’ll try to avoid using pointers in our code as much as possible. And, in Go,
    if you’re not working with pointers, you cannot represent `nil`. Exactly why we
    avoid this and what the implications are will be explained in detail in the following
    chapter, [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen what the expected output is for each case, and that we
    agree on this function being pure, we can write a test case to confirm that the
    output matches what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Everything that is happening in the preceding code is pretty straightforward.
    For each valid input (0 and 1), we confirm that the first or second player is
    returned, respectively. For an input higher than 1, we confirm that an error is
    thrown. Technically, you could extend this unit test to exhaustively test all
    possible integer inputs and confirm that an error is thrown for each of them.
    That might be a tad too exhaustive for this simple function, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, only one thing remains to be addressed: our code is no longer selecting
    a random player, but rather it is expecting an integer input and returning a deterministic
    value. You might notice that we have merely shifted the problem, as the random
    selection function still needs to be present somewhere. This is correct. If we
    were to look at how we would be using this code in an actual game, we might find
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see a recurring pattern as we aim to improve the purity of our
    code. The strategy will be to limit the places where side effects and non-determinism
    can occur. When you shift the way you think about structuring your code to preferring
    function purity and isolating the locations where you break it, you might end
    up with 90% of pure code and 10% impure code. Sure, you’re not 100% purely functional,
    but we’re programming in Go and we can forgive ourselves for the 10% impure code.
    As we’ve explored in quite some detail, purely functional programming is a subset
    of functional programming. Also, there’s no pure functional programming police
    that will hunt you down if you write an impure function.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean it’s impossible to be entirely pure? Well, not quite. After all,
    there are purely functional programming languages such as Haskell that can be
    used in real-world production environments. The way they deal with these impure
    functions is by using a form of encapsulation, known as **monads**. While it is
    possible to create monads in Go, it might cause more friction than necessary,
    hence why I advocate for embracing the idea of functional rather than pure functional
    code. For fun and to be extensive in our exploration of purely functional code,
    we will take a look at monads in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Increases the confidence in our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this goes hand in hand with improved testability, the improved confidence
    in your code goes beyond that. When dealing with impure functions and states,
    your program is harder to comprehend. If you work in a sufficiently complex system
    that has impure functions, and state mutations such as through global variables,
    it becomes harder to reason about. Imagine you are working in such a complex system,
    and a user reports a bug. If the system is mutable, you’d need to get a full understanding
    of what the entire system looked like at the moment the bug appeared just to begin
    to debug it. This can lead to many painful and wasted hours of debugging. There’s
    a popular notion, called the **Heisenbug**, which is a consequence of this. In
    this case, if the function that caused the bug depended on the state of the system,
    you might need to repeat the exact steps the user did just to replicate the bug.
  prefs: []
  type: TYPE_NORMAL
- en: An additional benefit is that our code becomes easier to debug. When debugging
    a program, any sufficiently advanced debugger will also show the state of your
    system during debugging. It will tell you what values were held in memory by the
    various parts of your program. That’s a great tool and can help you find bugs
    and eliminate them. But what if your program just doesn’t depend on such a state?
    This would eliminate the need for a crux such as the advanced debugger.
  prefs: []
  type: TYPE_NORMAL
- en: You could look at a single function, and reason about what it’s doing without
    having to also keep in mind what the rest of the system would look like at the
    moment of execution. Humans are bad at keeping things in our “working memory;”
    we can juggle about 7 +- 2 things at any given moment. If we optimize and try
    to make our program understandable by most humans, we’d have to limit the state
    variables to just 5\. This is ignoring the fact that our function probably has
    some variables as well. As such, we quickly exceed the upper bound of our human
    memory limits.
  prefs: []
  type: TYPE_NORMAL
- en: Improved confidence in function names and signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another great benefit of improving the readability and understandability of
    your code is that you can suddenly gain extra confidence in your functions. Imagine
    you are reading a code base, and you encounter the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What would the output be? You may naturally assume that `add1` is a pure function,
    and the output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But, you would be wrong. The actual output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand why, let’s take a look at the `add1` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we can see that the `add1` function is impure. It
    is not deterministic, as the outcome of each run depends on a random number being
    generated. Plus, it also creates a side effect. Each time a function has a `panic`
    statement in it, that statement produces a side effect outside of the normal outcome
    of your function. This was a bit of a contrived example, but it shows that when
    working in an environment where functions can contain side effects and are not
    idempotent, you lose some trust in the function signature itself.
  prefs: []
  type: TYPE_NORMAL
- en: Safer concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the selling points of Go, and a feature that sets it apart from many
    mainstream languages, is how easily it handles concurrency. With Go, it is incredibly
    easy to spin up multiple threads and have them work in parallel. This happens
    through the **channels** and **goroutines** concepts. There is much to be said
    about how concurrency works in Go, enough to deserve its entire book. What we
    will focus on here briefly is the correctness aspect of concurrency. Is it true
    that spinning up goroutines and processing in parallel is much easier in Go compared
    to, say, Java? What is not true is that it’s easier to write correct concurrent
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at some concurrent code. In this example, we will create
    a slice of integers and append to it in the `addToSlice` function. In our `main`
    function, we will push an integer to the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Think about this program for a second and try to guess what the output would
    be. The correct answer is that this program's output is non-deterministic. We
    are running multiple threads in which we append to our slice, and at the end,
    we call `wg.Done()`. When working with these waitgroups, we pass along several
    threads to wait for. This is done in `wg.Add(numbersToAdd)`. Each time `wg.Done()`
    is called, the number of threads to wait for decrements by one. As we are working
    on a shared slice of integers in this example, it is impossible to predict exactly
    what that slice looked like when it was performing the `add` operation in the
    final thread. This means that our output could be all numbers randomly ordered
    such as `[9 0 1 2 3 4 5 6 7 8]`, but it’s equally possible that the output would
    just be `[4 9 0 1 2]`. Having mutable data sources in concurrent functions is
    a recipe for disaster, and leads to some pretty hard-to-trace bugs.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see from this small snippet, it was incredibly simple to spin
    up multiple threads, but not quite so simple to avoid bugs in our code. Pure functions
    can help with this. Remember that when a function is pure, the same input always
    generates the same output without causing any side effects.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, our side effect was mutating the slice, which is not thread-safe
    in Go. The program won’t crash but the result will be random. If we push pure
    functional programming to the extreme, we will eliminate all such impure functions,
    and in doing so, we could run all our functions infinitely in parallel without
    causing any trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In practice, there are ways to avoid this from happening using a mutex. Some
    libraries take care of parallelism and thus abstract away some of the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: When not to write pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen what pure functions are and what kind of advantages pure
    functions can provide. But we should at least spend a bit of time thinking about
    occasions where we might want to sacrifice function purity. Now, if you ask this
    question to “purists,” the answer to this question is probably along the lines
    of: “Never, nunca, jamais.” This is fine, and some languages make it pretty easy
    to write functional code without ever having to sacrifice function purity. But,
    let’s take a look at a few examples where it makes sense to sacrifice some function
    purity. Now, before we dive into these examples, let me be the first to acknowledge
    that all of these supposed problems are circumventable. And yes, a language such
    as Haskell handles this mostly gracefully.'
  prefs: []
  type: TYPE_NORMAL
- en: But we are not programming in Haskell; we are programming in Go. And while Go
    allows us to write purely functional code if we wish to do so, some things are
    just easier to implement by temporarily forgiving ourselves for our sin of writing
    impure code.
  prefs: []
  type: TYPE_NORMAL
- en: Input/output operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think about the implications of totally eradicating side effects from your code.
    If we say that we are writing purely functional code and have eliminated all side
    effects, we have also eliminated part of what generates value for our users. Any
    time we are getting input from a user or displaying input to a user in some way,
    it is technically a side effect. Any time we are storing data in local storage,
    or uploading to a server somewhere, we are producing a side effect. Many applications
    will take some type of input, and many will also generate some kind of output.
  prefs: []
  type: TYPE_NORMAL
- en: Non-determinism can be desired
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another reason why we might not want to create pure functions is when the non-deterministic
    nature fits within the domain of what we are building. If we are building a game
    of Monopoly, it is the desired effect to have a `rollDice` function return a non-deterministic
    result. The game of Monopoly example was no accident. Randomness is inherent in
    many of the games we see around us, and thus a domain where pure determinism is
    not the desired outcome of each function.
  prefs: []
  type: TYPE_NORMAL
- en: When we really have to panic!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your program is in a state whereby it is impossible to continue operating
    normally, the typical way of handling that is by using a `panic`. While panics
    should be used sparingly, they are instances of the side effects that you are
    generating. Earlier in this chapter, we saw an example where a function would
    unpredictably panic during its execution. That example was artificial and a pretty
    bad use case for the `panic` function. But that does not mean that there are never
    any valid reasons to use `panic`. For example, if you are trying to reserve memory
    beyond the memory that is available on the system, that could be a cause for `panic`.
    In general, `panic` should be used to signal that the normal operation can’t proceed
    and there’s no way to gracefully continue running the application.
  prefs: []
  type: TYPE_NORMAL
- en: Two things are worth pointing out. The first one is that using the `panic` keyword
    should be the exception rather than the role. The second is that there is a common
    error handling paradigm in Go, namely returning a tuple containing a potential
    error value. Returning an error from a function is a distinct operation from using
    `panic` and serves a different use case.
  prefs: []
  type: TYPE_NORMAL
- en: How do we create pure functions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have taken a look at some properties of pure functions.
    We have also touched on some of the advantages we can gain by writing all our
    functions as pure functions. Now, let’s look at some things we can do to make
    it easier to write pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid global state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the ways we can facilitate writing pure functional code is by avoiding
    the global state in our programs. In Go, this comes down to avoiding the use of
    `const` and `var` blocks at the package level as much as possible. When you see
    these blocks, there’s a good chance that the program state is relied upon by some
    functions, thus generating either side effects or having non-deterministic program
    execution. While it’s not always possible to completely avoid such state variables,
    we should try to limit their use as much as possible. The way to prevent a function
    from relying on this state is by having the state pass to the function through
    a normal function argument. This is rather straightforward. The following is a
    small example, once using state from a `var` block and once without:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We could get the same functionality as the preceding block without the `var`
    block by simply passing the `name` parameter as input to our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That’s the gist of it. Next, let’s look at a general way of dealing with code
    that contains impure elements.
  prefs: []
  type: TYPE_NORMAL
- en: Separate pure and impure functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, it’s hard to be completely pure. We should not aim to
    eradicate I/O operations, API calls, and so on as by eliminating these, we’d likely
    be throwing out most of what makes our programs valuable. The main exercise will
    be in trying to create as many small, pure functions as possible and composing
    these into a larger program. There will still be side effects, but we’ll limit
    their occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Bubbling up errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A somewhat common side effect is generated by errors. Our programs end up in
    a state where they do not continue gracefully and there’s no real way to circumvent
    this. One way to isolate the pure and impure aspects here is by using the Go error-handling
    idiom and essentially “bubbling up” errors to a common layer where they can be
    handled. We saw this earlier in our example of selecting random players. Since
    Go 1.13, there are additional built-in tools available for bubbling up errors.
  prefs: []
  type: TYPE_NORMAL
- en: Each function does exactly one thing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is good advice in general. Generally speaking, a function should only
    do one thing, which significantly reduces the odds of our function creating a
    side effect. You find this same principle in traditional object-oriented languages
    as well. The industry more or less agrees that this is the way, but it’s surprisingly
    easy to break this good intention. Take a look at the following code of a simple
    addition function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is not a pure function. The side effect of this snippet is that we are
    printing the `sum` value to the standard output. Sure enough, this is pretty harmless,
    but if our users rely on this functionality, how do we ensure this function works
    properly? In other words, how would you go about testing that this function prints
    the correct output to the screen?
  prefs: []
  type: TYPE_NORMAL
- en: 'A variant of this could be writing to the filesystem or a database call as
    part of a function where that should not be the case. Let’s take a look at a function
    for signing up new users to a service. We expect the input to be a username and
    a password, and there’s some logic defined on the `User` struct to ensure the
    password is compliant with password rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue with this function is that it tries to do two things. First, it creates
    a new user struct and confirms that the password is compliant. Next, it stores
    the `User` struct in a database, assuming that the password is valid; otherwise,
    it panics. We could have split this into multiple functions, one for validating
    the password, one for storing the user, and a third function for orchestrating
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have separated the concerns, but we’re still left
    with two impure functions. However, the problems are now more contained tough
    within a single function. This code is not perfect yet, and there’s still room
    for improvement, as we will see in the next chapter. Before we go there, though,
    let’s take a look at a more extensive example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – hotdog shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our first example, we are going to take a look at some code that has been
    written in an impure way, and which is pretty much violating all good sense for
    writing pure functions. We’ll refactor this code as we go along to create more
    testable code, along with improving the readability and understandability of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Bad hotdog shop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s take a look at how not to create this hotdog shop system. We’ll
    start by defining a constant, a global variable that dictates the price of our
    hotdog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll create some structs. We will need a struct to represent a hotdog,
    as well as a struct to hold our credit card information. To keep things simple,
    the hotdog does not hold any state variables at the moment, while the credit card
    only stores the credit that is available on the card. Credit in this example is
    an integer value. It’s not something that accurately represents a monetary value
    in real life, but it’s good enough for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With these defined, we can get to the first piece of functionality that we
    care about. We need a way to charge our credit card for a certain value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `charge` method, we are charging the credit card for a certain
    amount by decreasing the credit available on the card. If there isn’t enough credit
    available to make the charge, we are using `panic` to halt the program. For now,
    the main issue with this function is the use of side effects. There are two of
    them. First, we are using `panic` if a certain branch is hit. The next side effect
    is that we are changing the state of `CreditCard`. Struct immutability is a topic
    we’ll cover in detail in the next chapter, so let’s close our eyes to this issue
    for now and continue writing the rest of our hotdog shop. The most important function
    for a user is to order a hotdog. So, let’s take a look at an implementation for
    doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is, again, impure code. The credit card of the user is being
    charged by a price defined outside of the function, using the global state. This
    function is doing more than one thing – it is both creating a hotdog to return
    to the user as well as charging their credit card.
  prefs: []
  type: TYPE_NORMAL
- en: Think about how you would test this for a second. It is possible to test this
    – but not convenient. You need to test or mock the credit card to also ensure
    a hotdog is being returned from this function. Furthermore, you have to capture
    a potential panic, which is not happening in the `orderHotdog` function but rather
    a call deeper. In addition, because `charge` is also impure, a reader of `orderHotdog`
    has no idea that `charge` *might* panic unless they take a look at that specific
    function as well. As we learned earlier, pure functional code gives us more confidence
    when reading code. We trust that a function does what it says it will – nothing
    more, nothing less. With that in mind, let’s take a look at how we can refactor
    this code.
  prefs: []
  type: TYPE_NORMAL
- en: Better hotdog shop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this version of the hotdog shop, we will try to address some of the issues
    we found in the previous example. The full code can be found at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining our types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined all the types we need to represent data in this small
    application. Our `CreditCard` struct contains an integer amount of credit, and
    our `hotdog` costs an integer amount as well. We have defined a `error` called
    `CreditError`, as well as a type alias for a payment function. Let’s also set
    up some constructor-like functions for our `CreditCard` and `Hotdog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These are pretty straightforward. We will add a global variable to represent
    an error whereby a user does not have enough credit to perform an operation on
    the credit card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you may recall, earlier, I advocated against using these types of package-level
    declarations. That’s still true and I’d advocate avoiding using them as much as
    possible. For error declarations, however, this is pretty much the accepted, idiomatic
    way of writing Go code.
  prefs: []
  type: TYPE_NORMAL
- en: We could avoid it here and instantiate the error in-line wherever it is applicable,
    but that will slightly hurt the testing code, which we’ll write later. In general,
    keep in mind that I advocate *functional programming* in Go, not *pure* *functional
    programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, let’s write our first non-trivial function. We will rewrite the
    initial `charge` function in a pure way. The goal here is to eliminate the initial
    side effect that we had not by using `panic` but rather by returning a tuple containing
    a potential error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell in the preceding snippet, we are not only returning an error
    value, but we are also returning a value of the `CreditCard` type. This is not
    the same `CreditCard` that is passed to the function by a caller. As we are not
    using a pointer to `CreditCard`, when a function calls `Charge`, `CreditCard`
    will be used inside the `Charge` function. As we are working on a copy, the `c.credit
    -= amount` statement only impacts the copy and not the original `CreditCard`.
    This is a common pitfall for newer Go programmers. In the next chapter, we will
    dive into immutability in greater detail and discuss the trade-off between this
    approach and the pointer-based function calls. But suffice it to say that this
    current function is *pure enough*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Charge` function is also easily testable. Let’s write a unit test to
    make sure the behavior is as we expect. First, we will define our test cases.
    The following structure is the setup for a *table-driven test*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are testing a few paths that our code can take.
    We can try to charge the credit card when we have more credit available than the
    cost, when we have the exact amount available, or when we don’t have enough credit
    available. With this table structure, adding more test cases is trivial. Now,
    let’s write the unit test itself, which will just run a test for each of the test
    cases defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Et voilà! A complete unit test for the charge function. Something that would
    have been nigh impossible in the impure example. Now, let’s also refactor the
    `OrderHotdog` function that we had earlier. As with anything, there are multiple
    ways to tackle this problem. The solution that we are implementing here is using
    a higher-order function to delay computation to a later stage. This will move
    the side effect of actually charging the credit card up the call chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let’s unpack what’s happening here. First, there’s our function signature. The
    `OrderHotdog` function still accepts `CreditCard` as input, but also a `PaymentFunc`.
    Recall that we defined `PaymentFunc` as a function that takes a `CreditCard` and
    an `int`, and returns a `CreditCard` and a `CreditError`. The `OrderHotdog` function
    returns the `Hotdog` itself, as well as a function that will return a `CreditCard`
    and an `error`. This might be a bit confusing at first but will become clearer
    in the function body.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is creating a new hotdog. After this, we must create a new function
    in-line. Recall that this is possible because Go supports functions as first-class
    citizens. Inside this function, we are calling `pay`, with the provided credit
    card, for the price of a hotdog. This is a `OrderHotdog` function then returns
    the hotdog and the newly created function. It’s important to note that `chargeFunc`
    is not executed when the `OrderHotdog` function is called. No side effect is occurring
    in this function; the side effect is deferred to a later stage. Once again, we
    are going to try to isolate our side effects as much as possible. Higher up the
    call chain is a better place for side effects as our code is typically read from
    higher to lower levels of abstraction. This avoids surprises somewhere hidden
    in the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we have recreated the functionality of the original hotdog shop.
    Before we take a look at testing `OrderHotdog`, we will first look at an example
    of how we would use this function. In the following `main` function, we are going
    to order a hotdog and subsequently call the `pay` function to charge our credit
    card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There we go – a usable example of ordering a hotdog. Let’s look at how we are
    calling `OrderHotdog`. We are passing both the credit card, as well as the `Charge`
    function we wrote earlier. You can run this example in the GitHub example repository
    and play around with it. Let’s also confirm that this code is testable by writing
    a unit test function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t need a table-driven test for this. The `OrderHotdog` function needs
    to be tested to ensure that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new hotdog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a function that calls the payment function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns both the hotdog and the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our test function will confirm that a new hotdog has been created and that
    a payment function is called. As this is a unit test, we don’t care about the
    payment function itself. We will mock a payment function to ensure that it is
    called from the returned function. The actual `charge` function is tested separately,
    as we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are strictly testing that our function is creating
    the correct values for the hotdog and the closure. A correct closure function
    in this case implies that the function that is returned calls the payment function
    that is passed to it. Notice how we could mock away the original behavior and
    create a `bool` to ensure that the function is called. Once again, this is the
    power of having first-class functions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at pure functional programming. First, we looked
    at what exactly it means for a programming language to be pure and functional
    as opposed to impure and functional. Next, we took a more detailed look at how
    pure code can help improve testability by eliminating side effects. We also learned
    that pure code gives readers more confidence in the code that they are reading
    since functions are more predictable and won’t change the state of the system.
    We also discussed when we should not use pure functions, such as when dealing
    with functions that should generate random behavior for games or functions that
    deal with I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have only briefly touched on it, we have seen how immutability plays
    a core part in writing pure functions by not changing the values of structs. In
    the next chapter, we will take a deep dive into immutability, how it does (or
    doesn’t) impact performance, and how we can leverage this in combination with
    pure functions to write more maintainable code.
  prefs: []
  type: TYPE_NORMAL
