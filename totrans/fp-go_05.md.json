["```go\ntype Person struct {\n    name string\n    age  int\n}\nfunc main() {\n    p := Person{\n        name: \"Benny\",\n        age:  55,\n    }\n    setName(p, \"Bjorn\")\n    fmt.Println(p.name)\n}\nfunc setName(p Person, name string) {\n    p.name = name\n}\n```", "```go\nfunc main() {\n    p := Person{\n        name: \"Benny\",\n        age:  55,\n    }\n    setName(&p, \"Bjorn\")\n    fmt.Println(p.name)\n}\nfunc setName(p *Person, name string) {\n    p.name = name\n}\n```", "```go\nfunc main() {\n    p := Person{\n        name: \"Benny\",\n        age:  55,\n    }\n    p = setName(p, \"Bjorn\")\n    fmt.Println(p.name)\n}\nfunc setName(p Person, name string) Person {\n    p.name = name\n    return p\n}\n```", "```go\nfunc main() {\n    names := []string{\"Miranda\", \"Paula\"}\n    names = append(names, \"Yvonne\")\n    fmt.Printf(\"%v\\n\", names)\n}\n```", "```go\nfunc main() {\n    m := map[string]int{}\n    addValue(m, \"red\", 10)\n    fmt.Printf(\"%v\\n\", m)\n}\nfunc addValue(m map[string]int, colour string, value int) {\n    m[colour] = value\n}\n```", "```go\nfunc main() {\n    names := []string{\"Miranda\"}\n    addValue(names, \"Yvonne\")\n    fmt.Printf(\"%v\\n\", names)\n}\nfunc addValue(s []string, name string) {\n    s = append(s, name)\n}\n```", "```go\nfunc main() {\n    names := []string{\"Miranda\"}\n    addValue(&names, \"Yvonne\")\n    fmt.Printf(\"%v\\n\", names)\n}\nfunc addValue(s *[]string, name string) {\n    *s = append(*s, name)\n}\n```", "```go\nfunc immutableCreatePerson() Person {\n    p := Person{}\n    p = immutableSetName(p, \"Sean\")\n    p = immutableSetAge(p, 29)\n    return p\n}\nfunc immutableSetName(p Person, name string) Person {\n    p.name = name\n    return p\n}\nfunc immutableSetAge(p Person, age int) Person {\n    p.age = age\n    return p\n}\n```", "```go\nfunc mutableCreatePerson() *Person {\n    p := &Person{}\n    mutableSetName(p, \"Tom\")\n    mutableSetAge(p, 31)\n    return p\n}\nfunc mutableSetName(p *Person, name string) {\n    p.name = name\n}\nfunc mutableSetAge(p *Person, age int) {\n    p.age = age\n}\n```", "```go\nfunc mutableSetName(p *Person, name string)\n```", "```go\nfunc (p *Person) mutableSetName(name string)\n```", "```go\npackage pkg\nimport \"testing\"\nfunc BenchmarkImmutablePerson(b *testing.B) {\n    for n := 0; n < b.N; n++ {\n        immutableCreatePerson()\n    }\n}\nfunc BenchmarkMutablePerson(b *testing.B) {\n    for n := 0; n < b.N; n++ {\n        mutableCreatePerson()\n    }\n}\n```", "```go\ngo test -bench=.\n```", "```go\nBenchmarkImmutablePerson        0.3758 ns/op\nBenchmarkMutablePerson          0.3775 ns/op\n```", "```go\n//go:noinline\nfunc immutableCreatePerson() Person {\n    p := Person{}\n    p = immutableSetName(p, \"Sean\")\n    p = immutableSetAge(p, 29)\n    return p\n}\n```", "```go\ngo build -gcflags '-m -l'\n```", "```go\n# github.com/PacktPublishing/Chapter5/Benchmark/pkg\n./person.go:17:23: leaking param: p to result ~r0 level=0\n./person.go:17:33: leaking param: name to result ~r0\n  level=0\n./person.go:23:22: leaking param: p to result ~r0 level=0\n./person.go:37:21: p does not escape\n./person.go:37:32: leaking param: name\n./person.go:42:20: p does not escape\n./person.go:30:7: &Person{} escapes to heap\n```", "```go\nfunc fmap[A, B any](mapFunc func(A) B, sliceA []A) []B\n```", "```go\nfunc fmap[A, B any](mapFunc func(A) B, sliceA []A) []B {\n    sliceB := make([]B, len(sliceA))\n    for i, a := range sliceA {\n        sliceB[i] = mapFunc(a)\n    }\n    return sliceB\n}\n```", "```go\nimport (\n    \"fmt\"\n    \"strconv\"\n)\nfunc main() {\n    integers := []int{1, 2, 3}\n    strings := fmap(strconv.Itoa, integers)\n    fmt.Printf(\"%T transformed to %T - %v\\n\", integers,\n      strings, strings)\n}\n```", "```go\n[]int transformed to []string - [1 2 3]\n```", "```go\ntype Maybe[A any] interface {\n    Get() (A)\n    GetOrElse(def A) A\n}\n```", "```go\ntype JustMaybe[A any] struct {\n    value A\n}\nfunc (j JustMaybe[A]) Get() (A) {\n    return j.value\n}\nfunc (j JustMaybe[A]) GetOrElse(def A) A {\n    return j.value\n}\n```", "```go\ntype NothingMaybe[A any] struct{}\nfunc Nothing[A any]() Maybe[A] {\n    return NothingMaybe[A]{}\n}\nfunc (n NothingMaybe[A]) Get() (A) {\n    return *new(A)\n}\nfunc (n NothingMaybe[A]) GetOrElse(def A) A {\n    return def\n}\n```", "```go\n    return *new(A)\n```", "```go\nfunc Just[A any](a A) JustMaybe[A] {\n    return JustMaybe[A]{value: a}\n}\nfunc Nothing[A any]() Maybe[A] {\n    return NothingMaybe[A]{}\n}\n```", "```go\nfunc getFromMap(m map[string]int, key string) Maybe[int] {\n    if value, ok := m[key]; ok {\n        return Just[int](value)\n    } else {\n        return Nothing[int]()\n    }\n}\n```", "```go\nfunc fmap[A, B any](m Maybe[A], mapFunc func(A) B) Maybe[B]\n{\n    switch m.(type) {\n    case JustMaybe[A]:\n        j := m.(JustMaybe[A])\n        return JustMaybe[B]{\n            value: mapFunc(j.value),\n        }\n    case NothingMaybe[A]:\n        return NothingMaybe[B]{}\n    default:\n        panic(\"unknown type\")\n    }\n}\n```"]