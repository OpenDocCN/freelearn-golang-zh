<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-101" class="chapter-number"><a id="_idTextAnchor101"/>6</h1>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Three Common Categories of Functions</h1>
			<p>In the preceding chapters, we have looked at some of the core components of functional programming. We have discussed how to write functions that adhere to both functional programming and pure <span class="No-Break">functional programming.</span></p>
			<p>In this chapter, we are going to look at some practical implementations of functions that leverage these concepts. These are the categories and topics we <span class="No-Break">will cover:</span></p>
			<ul>
				<li>The first category we will look at is <span class="No-Break">predicate-based functions</span></li>
				<li>Then, we will take a look at data transformation functions, which maintain the structure of our data (more on <span class="No-Break">that later)</span></li>
				<li>Finally, we will take a look at functions, which transform the data and reduce the information into a <span class="No-Break">single value</span></li>
			</ul>
			<p>This is not meant to be an exhaustive list, but with these three categories, we can build a large portion of our <span class="No-Break">day-to-day applications.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Technical requirements</h1>
			<p>For this chapter, you can use any Go version at or above Go 1.18, as we will be using generics in some of the later examples. You can find all the code on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter6"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter6</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Predicate-based functions</h1>
			<p>The<a id="_idIndexMarker236"/> first type of functions<a id="_idIndexMarker237"/> that we will explore is predicate-based functions. A <strong class="bold">predicate</strong> is a statement that can be evaluated as either true or false. Typically, in a language without a higher-order function, this would be achieved by using <strong class="source-inline">if</strong> statements inside the body of a function. A common use case is to filter a set of data into a subset that matches a specific condition – for example, given a list of people, return all of those who are older than 18 <span class="No-Break">years old.</span></p>
			<p>To start, we can introduce a type alias for a function that defines the type signature of <span class="No-Break">a predicate:</span></p>
			<pre class="source-code">
type Predicate[A any] func(A) bool</pre>
			<p>This<a id="_idIndexMarker238"/> type alias tells us that the function takes an input with a type of <strong class="source-inline">A</strong>, which can represent <strong class="source-inline">the any</strong> type in our program, but needs to return a <strong class="source-inline">bool</strong> value. This type uses generics, which were introduced in Go 1.18. We can now use this type in every place at which a predicate is expected. The first function that works using predicates is the simple <span class="No-Break"><strong class="source-inline">Filter</strong></span><span class="No-Break"> function.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Implementing a Filter function</h2>
			<p>The <strong class="source-inline">Filter</strong> function<a id="_idIndexMarker239"/> is<a id="_idIndexMarker240"/> a staple<a id="_idIndexMarker241"/> within the functional programmer’s toolbox. Let’s imagine that we don’t have higher-order functions available, and we want to write a <strong class="source-inline">Filter</strong>-like function. For this, let’s assume that we have a slice of numbers, and we want to filter all the numbers that are larger than 10. We could write something such <span class="No-Break">as this:</span></p>
			<pre class="source-code">
func Filter(numbers []int) []int {
	out := []int{}
	for _, num := range numbers {
		if num &gt; 10 {
			out = append(out, num)
		}
	}
	return out
}</pre>
			<p>This works well enough, but it’s not flexible. In this case, this function will always just filter for numbers larger than 10. We could make it a bit more flexible by adjusting the threshold value using an input parameter for our function. With a trivial change, we get the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func Filter(numbers []int, threshold int) []int {
	out := []int{}
	for _, num := range numbers {
		if num &gt; threshold {
			out = append(out, num)
		}
	}
	return out
}</pre>
			<p>This <a id="_idIndexMarker242"/>gives us a more flexible <strong class="source-inline">Filter</strong> function. However, as <a id="_idIndexMarker243"/>we all know, requirements change often, and users need new functionalities on an existing system almost ad infinitum. The next requirement for our function is to optionally filter for either <em class="italic">larger than</em>, or, in some cases, <em class="italic">smaller than</em>. Thinking about this for some time, you might realize that this could be implemented as two functions (the function body is omitted in snippets, as it’s a <span class="No-Break">trivial change):</span></p>
			<pre class="source-code">
func FilterLargerThan(numbers []int, threshold int) []int {
..
}
func FilterSmallerThan(numbers []int, threshold int) []int {
..
}</pre>
			<p>Sure enough, this would work – but the work never stops. Next, you have to implement a function that can filter for numbers larger than a given value but smaller than another. Then, our users become really into odd numbers, so there needs to be a filter for finding all odd numbers as well. Later on, the user asks you to count the exact amount of times a certain value appears, so you also need a filter for a certain value <em class="italic">exactly</em> in your list of numbers. You get the point; we can create a bunch of functions that suit all these use cases, but that approach does not sound like the <span class="No-Break">best option.</span></p>
			<p>One of<a id="_idIndexMarker244"/> the benefits of having a language <a id="_idIndexMarker245"/>with support for higher-order functions is that we can reduce repetitive implementations and abstract our algorithm. All of the aforementioned use cases fit within a function often called <strong class="source-inline">Filter</strong> in functional programming languages. The implementation of the <strong class="source-inline">Filter</strong> function is rather straightforward. The basic operation it supports is to iterate over a container, such as a <em class="italic">slice</em>, and apply a predicate function to every data element contained within the container. If the predicate function returns <strong class="source-inline">true</strong>, we will append this data element to our output. If not, we simply discard elements that did <span class="No-Break">not match.</span></p>
			<p>As we want to follow the best practices for implementing these functions, these functions will be pure and immutable. The original slice will never be modified within our filter functions, and neither will the elements <span class="No-Break">contained therein:</span></p>
			<pre class="source-code">
func Filter[A any](input []A, pred Predicate[A]) []A {
	output := []A{}
	for _, element := range input {
		if pred(element) {
			output = append(output, element)
		}
	}
	return output
}</pre>
			<p>This <strong class="source-inline">Filter</strong> implementation is a pretty typical implementation that you will find in many functional (and multi-paradigm) programming languages. Using higher-order functions in this way, we can essentially make part of an algorithm configurable. In other words, we abstract our algorithm. With the <strong class="source-inline">Filter</strong> function, the actual predicate part of an <strong class="source-inline">if</strong> statement <span class="No-Break">is customizable.</span></p>
			<p>Notice that we have implemented this using <em class="italic">generics</em>. <strong class="source-inline">Filter</strong> does not care what data types it is working with. Anything that can be stored in a slice can be passed to the <strong class="source-inline">Filter</strong> function. Let’s look at how we would use this in practice by creating some of the functions we discussed earlier. We will start off by implementing <strong class="source-inline">LargerThan</strong> and <span class="No-Break"><strong class="source-inline">SmallerThan</strong></span><span class="No-Break"> filters:</span></p>
			<pre class="source-code">
func main() {
	input := []int{1, 1, 3, 5, 8, 13, 21, 34, 55}
	larger20 :=
          Filter(input, func(i int) bool { return i &gt; 20 })
	smaller20 :=
          Filter(input, func(i int) bool { return i &lt; 20 })
	fmt.Printf("%v\n%v\n", larger20, smaller20)
}</pre>
			<p>The<a id="_idIndexMarker246"/> functions that we are passing to <strong class="source-inline">Filter</strong> as input <a id="_idIndexMarker247"/>are a tad verbose, as at the time of writing, Go does not have syntactic sugar for creating anonymous functions. Notice how we did not have to duplicate the body of our <strong class="source-inline">Filter</strong> function for <span class="No-Break">this implementation.</span></p>
			<p>Implementing other filters, such as <em class="italic">larger than X but smaller than Y</em> or <em class="italic">filter even numbers</em>, are equally easy to implement. Remember that we only have to pass the <strong class="source-inline">if</strong> statement logic each time and the iteration of the list is taken care of by the <strong class="source-inline">Filter</strong> <span class="No-Break">function itself:</span></p>
			<pre class="source-code">
func main() {
	input := []int{1, 1, 3, 5, 8, 13, 21, 34, 55}
	larger10smaller20 := Filter(input, func(i int) bool {
		return i &gt; 10 &amp;&amp; i &lt; 20
	})
	evenNumbers := Filter(input, func(i int) bool {
		return i%2 == 0
	})
	fmt.Printf("%v\n%v\n", larger10smaller20, evenNumbers)
}</pre>
			<p>By implementing this with generics, our <strong class="source-inline">Filter</strong> function can work with any data type. Let’s see how<a id="_idIndexMarker248"/> this function would work with the <strong class="source-inline">Dog</strong> struct that we have used in <span class="No-Break">earlier chapters.</span></p>
			<p>Recall<a id="_idIndexMarker249"/> that our struct for <strong class="source-inline">Dog</strong> had three fields: <strong class="source-inline">Name</strong>, <strong class="source-inline">Breed</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Gender</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Dog struct {
	Name   Name
	Breed  Breed
	Gender Gender
}</pre>
			<p>This snippet omits the <strong class="source-inline">const</strong> declarations for <strong class="source-inline">Breed</strong> and <strong class="source-inline">Gender</strong>, as well as the type aliases. These are the same as those in <a href="B18771_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and the full implementation can be found on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3</span></a><span class="No-Break">.</span></p>
			<p>Because we have used generics in the implementation of our <strong class="source-inline">Filter</strong> function, this will work on any data type, including custom structs. As such, we can use the function as is without any changes. Let’s implement a filter for all dogs that are of the <span class="No-Break"><strong class="source-inline">Havanese</strong></span><span class="No-Break"> breed:</span></p>
			<pre class="source-code">
func main() {
	dogs := []Dog{
		Dog{"Bucky", Havanese, Male},
		Dog{"Tipsy", Poodle, Female},
	}
	result := Filter(dogs, func(d Dog) bool {
		return d.Breed == Havanese
	})
	fmt.Printf("%v\n", result)
}</pre>
			<p>That’s all there is to it. Next, let’s look at some other functions that <span class="No-Break">use predicates.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Any or all</h2>
			<p>It is common to have to make sure that either <em class="italic">some</em> elements or <em class="italic">all</em> elements match a certain condition. The use case for abstracting this into a higher-order function is the same as for the <strong class="source-inline">Filter</strong> function. If we do not abstract this, a separate <strong class="source-inline">All</strong> and <strong class="source-inline">Any</strong> function would have to be implemented for each use case. While these are not found as often in multi-paradigm languages or object-oriented languages, they are still found in purely functional languages and come <span class="No-Break">in handy.</span></p>
			<h3>Looking for a match</h3>
			<p>The first function <a id="_idIndexMarker250"/>to look <a id="_idIndexMarker251"/>at is the <strong class="source-inline">Any</strong> function. At times, you may be interested in knowing whether or not a certain value is present in a list without being interested in exactly how often it is present or actually using the values afterward. If this is the case, the <strong class="source-inline">Any</strong> function is exactly <a id="_idIndexMarker252"/>what you are <span class="No-Break">looking for.</span></p>
			<p>Without the <strong class="source-inline">Any</strong> function, the same result could be achieved somewhat ad hoc with the <strong class="source-inline">Filter</strong> function. You would probably end up writing something such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
func main() {
	input := []int{1, 1, 3, 5, 8, 13, 21, 34, 55}
	filtered := Filter(input, func(i int) bool { return i == 
        55 })
	contains55 := len(filtered) &gt; 0
	fmt.Printf("%v\n", contains55)
}</pre>
			<p>Do note that I am splitting this into multiple lines for clarity, but in less verbose languages such as Python and Haskell, this kind of filter would still be a good one-liner. In Go, I’d be a bit cautious about the line length in case you decide to <span class="No-Break">do so.</span></p>
			<p>This implementation has one major flaw. What if you have a really large list of 10 million elements? The <strong class="source-inline">Filter</strong> function will iterate through every element in the list. It is always<a id="_idIndexMarker253"/> running in linear time, <strong class="source-inline">O(n)</strong>. Our <strong class="source-inline">Any</strong> function can do better, although we’ll still be running in <strong class="source-inline">O(n)</strong> – worst-case time. In practice, it can be more <span class="No-Break">performant, however.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If we knew that we only needed to look for integers, there are better algorithms than our <strong class="source-inline">Any</strong> implementation here. However, we want to write it generically for any type of data, so those other algorithms would fail for data types such as strings or <span class="No-Break">custom structs.</span></p>
			<p>The easiest way to<a id="_idIndexMarker254"/> gain some performance, despite having a theoretical worst-case complexity of linear time, is by iterating through a slice until the first element matches our search. If the match is found, we return <strong class="source-inline">true</strong>. Otherwise, we return <strong class="source-inline">false</strong> at the end of <span class="No-Break">our function:</span></p>
			<pre class="source-code">
func Any[A any](input []A, pred Predicate[A]) bool {
	for _, element := range input {
		if pred(element) {
			return true
		}
	}
	return false
}</pre>
			<h3>Looking for all matches</h3>
			<p>The<a id="_idIndexMarker255"/> implementation for <strong class="source-inline">All</strong> matches is similar to the <strong class="source-inline">Any</strong> match, with the same benefit of abstracting the implementation of <strong class="source-inline">if</strong> statements. The <a id="_idIndexMarker256"/>implementation for <strong class="source-inline">All</strong> has a similar practical benefit as the <strong class="source-inline">Any</strong> implementation. As soon as an element does <strong class="bold">not</strong> match what we are looking for, we return <strong class="source-inline">false</strong>. Otherwise, we return <strong class="source-inline">true</strong> at the end of <span class="No-Break">our </span><span class="No-Break"><a id="_idIndexMarker257"/></span><span class="No-Break">function:</span></p>
			<pre class="source-code">
func All[A any](input []A, pred Predicate[A]) bool {
	for _, element := range input {
		if !pred(element) {
			return false
		}
	}
	return true
}</pre>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Implementing DropWhile and TakeWhile</h2>
			<p>The next two implementations are still predicate-based, but rather than returning a single <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> as output, these are used to manipulate the slice. In that sense, they are closer to the original <strong class="source-inline">Filter</strong> implementation, but the difference is that they truncate either the start of a list or the tail of <span class="No-Break">a list.</span></p>
			<h3>TakeWhile implementation</h3>
			<p><strong class="source-inline">TakeWhile</strong> is<a id="_idIndexMarker258"/> a <a id="_idIndexMarker259"/>function that will take elements from<a id="_idIndexMarker260"/> the input slice as long as a condition is met. As soon as the condition fails, the result containing the start of the list up until the failing predicate <span class="No-Break">is returned:</span></p>
			<pre class="source-code">
func TakeWhile[A any](input []A, pred Predicate[A]) []A {
	out := []A{}
	for _, element := range input {
		if pred(element) {
			out = append(out, element)
		} else {
			return out
		}
	}
	return out
}</pre>
			<p>In this <a id="_idIndexMarker261"/>function, this is exactly what is happening. As long as our predicate is met for each subsequent element, this element is stored in our output value. Once the predicate <a id="_idIndexMarker262"/>fails a single time, the output is returned. Let’s demonstrate this with a simple slice containing consecutive numbers. Our predicate will look for odd numbers. Hence, as long as the numbers are odd, they will be appended to the output slice, but as soon as we encounter an even number, what we have collected thus far will <span class="No-Break">be returned:</span></p>
			<pre class="source-code">
func main() {
	ints := []int{1, 1, 2, 3, 5, 8, 13}
	result := TakeWhile(ints, func(i int) bool {
		return i%2 != 0
	})
	fmt.Printf("%v\n", result)
}</pre>
			<p>In this example, the output is <strong class="source-inline">[1 1]</strong>. Notice how this is different from the plain <strong class="source-inline">Filter</strong> function – if this same predicate was given to the <strong class="source-inline">Filter</strong> function, our output would be <strong class="source-inline">[1 1 3 </strong><span class="No-Break"><strong class="source-inline">5 13]</strong></span><span class="No-Break">.</span></p>
			<p><span class="No-Break">Implementing DropWhile</span></p>
			<p>Implementing <strong class="source-inline">DropWhile</strong> is the <a id="_idIndexMarker263"/>counterpart to <strong class="source-inline">TakeWhile</strong>. This function will drop elements as long as a condition is met. Thus, elements <a id="_idIndexMarker264"/>are returned from the first failed predicate test until the end of <span class="No-Break">the list:</span></p>
			<pre class="source-code">
func DropWhile[A any](input []A, pred Predicate[A]) []A {
	out := []A{}
	drop := true
	for _, element := range input {
		if !pred(element) {
			drop = false
		}
		if !drop {
			out = append(out, element)
		}
	}
	return out
}</pre>
			<p>Let’s test<a id="_idIndexMarker265"/> this out against the same input data<a id="_idIndexMarker266"/> as our <span class="No-Break"><strong class="source-inline">TakeWhile</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func main() {
	ints := []int{1, 1, 2, 3, 5, 8, 13}
	result := DropWhile(ints, func(i int) bool {
		return i%2 != 0
	})
	fmt.Printf("%v\n", result)
}</pre>
			<p>The output of this function is <strong class="source-inline">[2 3 5 8 13]</strong>. The only elements that are dropped are therefore <strong class="source-inline">[1 1]</strong>. If you combine the output of <strong class="source-inline">TakeWhile</strong> and <strong class="source-inline">DropWhile</strong>, given the same predicate, you would recreate the <span class="No-Break">input slice.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Map/transformation functions</h1>
			<p>The next <a id="_idIndexMarker267"/>category of functions which we<a id="_idIndexMarker268"/> will look at is <strong class="source-inline">Map</strong> functions. These are functions that apply a transformation function to each element in a container, changing the element and possibly even the data type. This is one of the most powerful functions in a functional programmer’s toolbox, as this allows you to transform your data according to a <span class="No-Break">given rule.</span></p>
			<p>There are two main<a id="_idIndexMarker269"/> implementations that we will look at. The first implementation is the simple <strong class="source-inline">Map</strong> function, whereby an operation is performed on each element, but the data type remains the same before and after the transformation – for example, multiplying each element in a slice. This will change the content of the values, but not the type of the values. The other implementation of <strong class="source-inline">Map</strong> is one whereby the data types can change as well. This will be implemented as <strong class="source-inline">FMap</strong>, and this is what we introduced in the previous chapter when looking <span class="No-Break">into Monads.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Transformations while maintaining the data type</h2>
			<p>The<a id="_idIndexMarker270"/> first transformation function that we will look at is one whereby the data types remain the same. Whenever a programmer <a id="_idIndexMarker271"/>encounters this function, they can be assured that the data type after calling the function is the same as the data type that was passed to the function. In other words, if the function is called for a list of elements with a data type of <strong class="source-inline">Dog</strong>, the output of this function is still a list of <strong class="source-inline">Dog</strong> elements. What can be different though is the actual content of the fields within those structs (e.g., the name property can <span class="No-Break">be updated).</span></p>
			<p>Just like with the <strong class="source-inline">Filter</strong> implementation, these will be implemented in a purely functional way. Calling the <strong class="source-inline">Map</strong> function should <strong class="bold">never</strong> make changes in place to the objects that we provide as an input to <span class="No-Break">the function.</span></p>
			<p>Overall, implementing the <strong class="source-inline">Map</strong> function is straightforward. We will iterate over our slice of values and call a transformation function for each value. Essentially, what we are doing with the <strong class="source-inline">Map</strong> function is abstracting the actual transformation logic. The core algorithm is the iteration over our slice, not the concrete transformations. This means we are once again building a <span class="No-Break">higher-order function:</span></p>
			<pre class="source-code">
type MapFunc[A any] func(A) A
func Map[A any](input []A, m MapFunc[A]) []A {
	output := make([]A, len(input))
	for i, element := range input {
		output[i] = m(element)
	}
	return output
}</pre>
			<p>In this<a id="_idIndexMarker272"/> example, our generic type signature <a id="_idIndexMarker273"/>tells us that the data type is preserved when <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">MapFunc</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type MapFunc[A any] func(A) A</pre>
			<p>Given <strong class="source-inline">A</strong>, we will get <strong class="source-inline">A</strong> back. Notice that the type can be any type as per the generic contract. There are no type constraints necessary for our <strong class="source-inline">Map</strong> implementation. Let’s look at a demo of multiplying each element in our slice <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
	ints := []int{1, 1, 2, 3, 5, 8, 13}
	result := Map(ints, func(i int) int {
		return i * 2
	})
	fmt.Printf("%v\n", result)
}</pre>
			<p>This function can work with any data type as well. Let’s look at a demo in which we apply a transformation to the name of each dog in a list. If the gender of the dog is male, we’ll prefix the name with <strong class="source-inline">Mr.</strong>, and if the gender is female, we’ll prefix it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Mrs.</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func dogMapDemo() {
        dogs := []Dog{
                Dog{"Bucky", Havanese, Male},
                Dog{"Tipsy", Poodle, Female},
        }
        result := Map(dogs, func(d Dog) Dog {
                if d.Gender == Male {
                        d.Name = "Mr. " + d.Name
                } else {
                        d.Name = "Mrs. " + d.Name
                }
                return d
        })
        fmt.Printf("%v\n", result)
}</pre>
			<p>Running<a id="_idIndexMarker274"/> this code would result in the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
[{Mr. Bucky 1 0} {Mrs. Tipsy 3 1}]</pre>
			<p>It’s important<a id="_idIndexMarker275"/> to stress that these changes are made to copies of the data, and not to the original <span class="No-Break"><strong class="source-inline">Dog</strong></span><span class="No-Break"> objects.</span></p>
			<h3>Transforming from one to many</h3>
			<p>An <a id="_idIndexMarker276"/>adaptation of the <strong class="source-inline">Map</strong> function is<a id="_idIndexMarker277"/> the <strong class="source-inline">Flatmap</strong> function. This function will map a <strong class="bold">single</strong> item into <strong class="bold">multiple</strong> results. Those results will then be collapsed back down into a single list. Collapsing a two-dimensional<a id="_idIndexMarker278"/> list down into a one-dimensional list is referred to as flattening the list – <span class="No-Break">hence, </span><span class="No-Break"><strong class="source-inline">Flatmap</strong></span><span class="No-Break">.</span></p>
			<p>The<a id="_idIndexMarker279"/> implementation of the function we will use is not as efficient but works well enough for most purposes. For each element in our slice, we are going to call the transformation function, which will transform our single element into a slice of elements. Rather than storing this intermediately as a slice of slices, we will immediately collapse each slice and store the individual elements consecutively <a id="_idIndexMarker280"/><span class="No-Break">in memory:</span></p>
			<pre class="source-code">
func FlatMap[A any](input []A, m func(A) []A) []A {
	output := []A{}
	for _, element := range input {
		newElements := m(element)
		output = append(output, newElements…)
	}
	return output
}</pre>
			<p>Let’s demonstrate <a id="_idIndexMarker281"/>this by implementing an example. For each integer, <strong class="source-inline">N</strong>, in a slice, we are going to turn this into a slice of all integers from 0 up to <strong class="source-inline">N</strong>. Finally, we are going to return this result as a <span class="No-Break">consecutive slice:</span></p>
			<pre class="source-code">
func main() {
        ints := []int{1, 2, 3}
        result := FlatMap(ints, func(n int) []int {
                out := []int{}
                for i := 0; i &lt; n; i++ {
                        out = append(out, i)
                }
                return out
        })
        fmt.Printf("%v\n", result)
}</pre>
			<p>The output of running this code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[0 0 1 0 1 2]</pre>
			<p>This is what we have shown in the image. Every single element is turned into a slice, and the slices are then<a id="_idIndexMarker282"/> combined. For each element in our input slice, this is what the intermediate output would <span class="No-Break">look like:</span></p>
			<pre class="source-code">
0: [0]
1: [0 1]
2: [0 1 2]</pre>
			<p>This intermediate<a id="_idIndexMarker283"/> output then gets combined into a single slice. Next, let’s take a look at the final category of functions that play a crucial role in functional <span class="No-Break">programming languages.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Data reducing functions</h1>
			<p>The<a id="_idIndexMarker284"/> final group<a id="_idIndexMarker285"/> we are going to take a look at is <em class="italic">reducer</em> functions. These are functions that apply an operation to a container of elements and derive a single value from them. Combined with the functions we have seen earlier in this chapter, we can compose the majority of our applications. At least, as far as data manipulation goes. There are a few different names for functions such as this in functional programming. In Haskell, you’ll find functions named <strong class="source-inline">Fold</strong> or <strong class="source-inline">Fold</strong> + a suffix, such as <strong class="source-inline">Foldr</strong>, while in some languages they are called <strong class="source-inline">Reduce</strong>. We will use the <strong class="source-inline">Reduce</strong> terminology for the remainder of <span class="No-Break">this book.</span></p>
			<p>The first function we will look at is <a id="_idIndexMarker286"/>simply <strong class="source-inline">Reduce</strong>. This<a id="_idIndexMarker287"/> higher-order function abstracts operations to two data elements of the list. It then repeats this operation, accumulating the result, until a single answer is retrieved. Just as with the <strong class="source-inline">Filter</strong> and <strong class="source-inline">Map</strong> functions, these functions are pure, so the actual input data is <span class="No-Break">never changed.</span></p>
			<p>The abstracted function in this algorithm is a function that takes two values of an identical data type and returns a single value of that data. The result is achieved by performing some operation on them that the caller of the function <span class="No-Break">can provide:</span></p>
			<pre class="source-code">
type (
        reduceFunc[A any] func(a1, a2 A) A
)</pre>
			<p>This<a id="_idIndexMarker288"/> function will ultimately be called iteratively for <a id="_idIndexMarker289"/>each element in the slice, storing the intermediate results and feeding those back into <span class="No-Break">the function:</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This sounds like recursion but it is not recursive in the implementation in this chapter. We will look at a recursive approach in the <span class="No-Break">next chapter.</span></p>
			<pre class="source-code">
func Reduce[A any](input []A, reducer reduceFunc[A]) A {
	if len(input) == 0 {
		// return default zero
		return *new(A)
	}
	result := input[0]
	for _, element := range input[1:] {
		result = reducer(result, element)
	}
	return result
}</pre>
			<p>In this example, we are also handling our edge cases. If we get an empty slice, we return the <strong class="source-inline">default-nil</strong> value of whatever type was passed to our function. If there is only one item in the slice, no operation can be performed, and, instead, we just return that value (by not executing the loop and thus instantly returning the result based <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">input[0]</strong></span><span class="No-Break">).</span></p>
			<p>These higher-order<a id="_idIndexMarker290"/> function abstracts are how you can combine two elements into a single answer. One possible reducer would be <strong class="source-inline">sum reducer</strong>, which adds two numbers and returns the result. The following anonymous function is an example of <span class="No-Break">this function:</span></p>
			<pre class="source-code">
func(a1, a2 A) A { return a1 + a2 }</pre>
			<p>This is <a id="_idIndexMarker291"/>an anonymous function that we would pass to <strong class="source-inline">Reduce</strong> to perform a summation of all elements – but there’s one problem with this approach as it is written now. The <strong class="source-inline">Reduce</strong> function is generic and can take <strong class="bold">any</strong> type as input, but the <strong class="source-inline">+</strong> operator is not defined for every data type. To work around this, we can create a <strong class="source-inline">Sum</strong> function that calls the reducer internally but tightens the type signature to only allow numbers to be provided <span class="No-Break">as input.</span></p>
			<p>Remember that as there are multiple number data types in Go, we want to be able to use the <strong class="source-inline">Sum</strong> function for all of these. This can be achieved by creating a custom type constraint for our generic functions. We’ll also consider a <strong class="source-inline">type</strong> alias of <strong class="source-inline">Number</strong> as valid – this can be achieved by adding the <strong class="source-inline">~</strong> prefix to <span class="No-Break">each type:</span></p>
			<pre class="source-code">
type Number interface {
        ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uint |
                ~int8 | ~int16 | ~int32 | ~int64 | ~int |
                ~float32 | ~float64
}</pre>
			<p>Next, we can use this type as a type constraint in a generic function such as the <span class="No-Break"><strong class="source-inline">Sum</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func Sum[A Number](input []A) A {
	return Reduce(input, func(a1, a2 A) A { return a1 + a2 })
}</pre>
			<p>There we go – now, we can use this function to return a summation of a slice of numbers, whereby a number is any currently supported number-like data type in Go that we have defined in <span class="No-Break">our constraint:</span></p>
			<pre class="source-code">
func main{
        ints := []int{1, 2, 3, 4}
        result := Sum(ints)
        fmt.Printf("%v\n", result)
}</pre>
			<p>The output of <a id="_idIndexMarker292"/>this function is <strong class="source-inline">10</strong>. Effectively, our reducer<a id="_idIndexMarker293"/> has performed a sum of <strong class="source-inline">1 + 2 + 3 + 4</strong>. With the reducer in place, we can therefore abstract these operations to lists. Adding a similar function to perform the multiplication of each element is equally easy to write as the <span class="No-Break">summation function:</span></p>
			<pre class="source-code">
func Product[A Number](input []A) A {
        return Reduce(input, func(a1, a2 A) A { return a1 * a2 })
}</pre>
			<p>This implementation works the same way as the <span class="No-Break"><strong class="source-inline">Sum</strong></span><span class="No-Break"> function.</span></p>
			<p>In Haskell and other functional languages, there are a few different reducer implementations provided out of the box, each changing the core algorithm slightly. You will find <span class="No-Break">the following:</span></p>
			<ul>
				<li>Reducers that iterate from the start to the end of <span class="No-Break">a list</span></li>
				<li>Reducers that iterate from the end to the start of <span class="No-Break">a list</span></li>
				<li>Reducers that start with a default value instead of the first element of <span class="No-Break">a list</span></li>
				<li>Reducers that start with a default value and then iterate from the end to the start of <span class="No-Break">the list</span></li>
			</ul>
			<p>The reverse reducers (iterating from the end to the start of a list) are left as an exercise for the reader to explore independently, but the full code for them can be found on GitHub: <a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/pkg/reducers.go">https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/pkg/reducers.go</a>. However, we will take a look at the reducers that have a <span class="No-Break">starting value.</span></p>
			<p>Providing a different starting value would allow us to write a function such as <strong class="source-inline">multiple all numbers together, and then finally multiply by two</strong>. We could achieve this with some minor modifications <a id="_idIndexMarker294"/>to<a id="_idIndexMarker295"/> our <span class="No-Break"><strong class="source-inline">Reducer</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func ReduceWithStart[A any](input []A, startValue A, reducer reduceFunc[A]) A {
        if len(input) == 0 {
                return startValue
        }
        if len(input) == 1 {
                return reducer(startValue, input[0])
        }
        result := reducer(startValue, input[0])
        for _, element := range input[1:] {
                result = reducer(result, element)
        }
        return result
}</pre>
			<p>We’re handling similar edge cases as with the original <strong class="source-inline">Reduce</strong> function, but one key difference is that we always have a default value to return. We can either return it when the slice is empty or return the combination of the starting value with the first element in the slice when the slice contains exactly <span class="No-Break">one element.</span></p>
			<p>In the next example code, we are going to concatenate strings with a comma in between each word, but to show<a id="_idIndexMarker296"/> off our new <strong class="source-inline">ReduceWithStart</strong> function, we<a id="_idIndexMarker297"/> will provide a starting value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">first</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
        words := []string{"hello", "world", "universe"}
        result := ReduceWithStart(words, "first", func(s1, s2 
            string) string {
                return s1 + ", " + s2
        })
        fmt.Printf("%v\n", result)
}</pre>
			<p>If we run this code, we will get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
first, hello, world, universe</pre>
			<p>With these<a id="_idIndexMarker298"/> functions in place, let’s take a look at an example in which we combine the use of all three categories <span class="No-Break">of functions.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Example – working with airport data</h1>
			<p>In this example, we are going <a id="_idIndexMarker299"/>to tie together the functions <a id="_idIndexMarker300"/>from this chapter to analyze airport data. We need to do some work before we can play around with the functions that we have created. First, we need to get the data. On GitHub, you can find a <strong class="source-inline">.json</strong> extract <span class="No-Break">under </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/resources/airlines.json"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/resources/airlines.json</span></a><span class="No-Break">.</span></p>
			<p>The following snippet is the template for <span class="No-Break">the dataset:</span></p>
			<pre class="source-code">
  {
    "Airport": {
      "Code": string,
      "Name": string
    },
    "Statistics": {
      "Flights": {
        "Cancelled": number,
        "Delayed": number,
        "On Time": number,
        "Total": number
      },
      "Minutes Delayed": {
        "Carrier": number,
        "Late Aircraft": number,
        "Security": number,
        "Total": number,
        "Weather": number
      }
    }
  }</pre>
			<p>To work <a id="_idIndexMarker301"/>with this data, we will recreate the <strong class="source-inline">.json</strong> structure as structs in Go. We can use the built-in <strong class="source-inline">.json</strong> tags and deserializers to read this <a id="_idIndexMarker302"/>data in memory. Our Go struct to work with this data looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
type Entry struct {
	Airport struct {
		Code string `json:"Code"`
		Name string `json:"Name"`
	} `json:"Airport"`
	Statistics struct {
		Flights struct {
			Cancelled int `json:"Cancelled"`
			Delayed   int `json:"Delayed"`
			OnTime    int `json:"On Time"`
			Total     int `json:"Total"`
		} `json:"Flights"`
		MinutesDelayed struct {
			Carrier                int `json:"Carrier"`
			LateAircraft           int `json:"Late 
                                        Aircraft"`
			Security               int `json:"Security"`
			Weather                int `json:"Weather"`
		} `json:"Minutes Delayed"`
	} `json:"Statistics"`
}</pre>
			<p>This is a<a id="_idIndexMarker303"/> bit verbose, but it’s just a copy of what we could <a id="_idIndexMarker304"/>find in the first entry of the file. After this, we need to write some code to read this file into memory <span class="No-Break">as entries:</span></p>
			<pre class="source-code">
func getEntries() []Entry {
        bytes, err := ioutil.ReadFile("./resources/airlines.
            json")
        if err != nil {
                panic(err)
        }
        var entries []Entry
        err = json.Unmarshal(bytes, &amp;entries)
        if err != nil {
                panic(err)
        }
        return entries
}</pre>
			<p>As in previous chapters, we are using <strong class="source-inline">panic</strong> in this code. It is discouraged, but for demonstration purposes, this is fine. This code will read our resource file, parse it as <strong class="source-inline">json</strong> based on the struct we have created, and return it as <span class="No-Break">a slice.</span></p>
			<p>Now, to<a id="_idIndexMarker305"/> demo the functions that we have created, this is<a id="_idIndexMarker306"/> what our problem statement looks like: <strong class="bold">write a function that returns the total hours of delays for the Seattle airport (airport </strong><span class="No-Break"><strong class="bold">code: SEA)</strong></span><span class="No-Break">.</span></p>
			<p>Based on this problem statement, we can see that there are three actions <span class="No-Break">to take:</span></p>
			<ol>
				<li>Filter the data by the airport <span class="No-Break">code SEA.</span></li>
				<li>Transform the <strong class="source-inline">MinutesDelayed</strong> field <span class="No-Break">into hours.</span></li>
				<li>Sum all <span class="No-Break">the hours.</span></li>
			</ol>
			<p>The order of <em class="italic">steps 2 and 3</em> could be reversed, but this way, it follows the structure in which we have introduced those functions in <span class="No-Break">this chapter:</span></p>
			<pre class="source-code">
func main() {
	entries := getEntries()
	SEA := Filter(entries, func(e Entry) bool {
		return e.Airport.Code == "SEA"
	})
	WeatherDelayHours := FMap(SEA, func(e Entry) int {
		return e.Statistics.MinutesDelayed.Weather / 60
	})
	totalWeatherDelay := Sum(WeatherDelayHours)
	fmt.Printf("%v\n", totalWeatherDelay)
}</pre>
			<p>And there we go. We have implemented our use case using three of the functions that we have seen in this chapter. As you can tell, whenever we call a function, we store the result in a new slice. The original data is therefore never lost, and we could still use it for other parts of our function should we choose to <span class="No-Break">do so.</span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Summary</h1>
			<p>In this chapter, we saw three categories of functions that will help us functionally build our programs. First, we saw predicate-based functions, which can either filter our data into a subset meeting a requirement or tell us whether or not the data in our dataset entirely or partially matches a condition. Next, we saw how data can be changed functionally, ways of transforming data whereby our data type is guaranteed to remain the same, and functions in which we are also changing the <span class="No-Break">type itself.</span></p>
			<p>Finally, we looked at reducer functions, which take a list of elements and reduce them into a single value. We have demonstrated how these three types of functions can be combined in the airport <span class="No-Break">data example.</span></p>
			<p>In the next chapter, we will dive into recursion and see how this plays a role in functional programming, as well as what the performance implications are for writing recursive functions <span class="No-Break">in Go.</span></p>
		</div>
		<div>
			<div id="_idContainer018">
			</div>
		</div>
	</body></html>