["```go\nfunc recursive() {\n    recursive()\n}\n```", "```go\nFact(5) = 5 * 4 * 3 * 2 * 1\n```", "```go\nFact(5) = 5 * Fact(4) = 5 * 24 = 120\nFact(4) = 4 * Fact(3) = 4 * 6 = 24\nFact(3) = 3 * Fact(2) = 3 * 2 = 6\nFact(2) = 2 * Fact(1) = 2 * 1 = 2\nFact(1) = 1 * Fact(0) = 1 * 1\nFact(0) = 1\n```", "```go\nfunc main() {\n    fmt.Println(Fact(5))\n}\nfunc Fact(input int) int {\n    if input == 0 {\n        return 1\n    }\n    return input * Fact(input-1)\n}\n```", "```go\nfunc factorial(n int) int {\n    result := 1\n    for i := 1; i <= n; i++ {\n        result = result * i\n    }\n    return result\n}\n```", "```go\nreturn input * Fact(input-1)\n```", "```go\nfactorial :: Integral -> Integral\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n```", "```go\ntype node struct {\n        value int\n        left  *node\n        right *node\n}\n```", "```go\nvar (\n        ExampleTree = &node{\n                value: 1,\n                left: &node{\n                        value: 2,\n                        left: &node{\n                                value: 3,\n                        },\n                        right: &node{\n                                value: 4,\n                        },\n                },\n                right: &node{\n                        value: 5,\n                },\n        }\n)\n```", "```go\nfunc sumIterative(root *node) int {\n        queue := make(chan *node, 10)\n        queue <- root\n        var sum int\n        for {\n                select {\n                case node := <-queue:\n                        sum += node.value\n                        if node.left != nil {\n                                queue <- node.left\n                        }\n                        if node.right != nil {\n                                queue <- node.right\n                        }\n                default:\n                        return sum\n                }\n        }\n}\n```", "```go\nfunc sumRecursive(node *node) int {\n        if node == nil {\n                return 0\n        }\n        return node.value + sumRecursive(node.left) +\n            sumRecursive(node.right)\n}\n```", "```go\nvar maximum = 0\nfunc MaxGlobalVariable(node *node) {\n        if node == nil {\n                return\n        }\n        if node.value > maximum {\n                maximum = node.value\n        }\n        MaxGlobalVariable(node.left)\n        MaxGlobalVariable(node.right)\n}\nfunc main() {\n        maximum = int(math.MinInt)\n        MaxGlobalVariable(ExampleTree)\n        fmt.Println(maximum)\n}\n```", "```go\nfunc.maxInline(node *node,\n    maxValue int) int {\n        if node == nil {\n                return maxValue\n        }\n        if node.value > maxValue {\n                maxValue = node.value\n        }\n        maxLeft := maxInline(node.left, maxValue)\n        maxRight := maxInline(node.right, maxValue)\n        if maxLeft > maxRight {\n                return maxLeft\n        }\n        return maxRight\n}\n```", "```go\nfunc main() {\n        fmt.Println(maxInline(ExampleTree, 0))\n}\n```", "```go\nfunc main() {\n        fmt.Println(MaxInline(ExampleTree))\n}\nfunc MaxInline(root *node) int {\n        return maxInline(root, 0)\n}\nfunc maxInline(node *node, maxValue int) int {\n        if node == nil {\n                return maxValue\n        }\n        if node.value > maxValue {\n                maxValue = node.value\n        }\n        maxLeft := maxInline(node.left, maxValue)\n        maxRight := maxInline(node.right, maxValue)\n        if maxLeft > maxRight {\n                return maxLeft\n        }\n        return maxRight\n}\n```", "```go\nfunc Max(root *node) int {\n        currentMax := math.MinInt\n        var inner func(node *node)\n        inner = func(node *node) {\n                if node == nil {\n                        return\n                }\n                if node.value > currentMax {\n                        currentMax = node.value\n                }\n                inner(node.left)\n                inner(node.right)\n        }\n        inner(root)\n        return currentMax\n}\n```", "```go\nvar inner func(node *node)\ninner = func(node *node) {\n        if node == nil {\n                return\n        }\n        if node.value > currentMax {\n                currentMax = node.value\n        }\n        inner(node.left)\n        inner(node.right)\n}\n```", "```go\ninner := func(node *node) {\n   if node == nil {\n      return\n   }\n   if node.value > currentMax {\n      currentMax = node.value\n   }\n   inner(node.left)\n   inner(node.right)\n}\n```", "```go\ninner(root)\n```", "```go\npackage pkg\nfunc IterativeFact(n int) int {\n        result := 1\n        for i := 2; i <= n; i++ {\n                result *= i\n        }\n        return result\n}\nfunc RecursiveFact(n int) int {\n        if n == 0 {\n                return 1\n        }\n        return n * RecursiveFact(n-1)\n}\n```", "```go\npackage pkg\nimport \"testing\"\nfunc BenchmarkIterative100(b *testing.B) {\n        for n := 0; n < b.N; n++ {\n                IterativeFact(10)\n        }\n}\nfunc BenchmarkRecursive100(b *testing.B) {\n        for n := 0; n < b.N; n++ {\n                RecursiveFact(10)\n        }\n}\n```", "```go\nfunc main() {\n        infiniteCount(0)\n}\nfunc infiniteCount(i int) {\n        if i%1000 == 0 {\n                fmt.Println(i)\n        }\n        infiniteCount(i + 1)\n}\n```", "```go\n1861000\n1862000\n1863000\n1864000\nruntime: goroutine stack exceeds 262144000-byte limit\nruntime: sp=0xc008080380 stack=[0xc008080000, 0xc010080000]\nfatal error: stack overflow\nruntime stack:\nruntime.throw({0x496535?, 0x50e900?})\n        /usr/lib/golang/src/runtime/panic.go:992 +0x71\nruntime.newstack()\n        /usr/lib/golang/src/runtime/stack.go:1101 +0x5cc\nruntime.morestack()\n        /usr/lib/golang/src/runtime/asm_amd64.s:547 +0x8b\n```", "```go\nfunc main() {\n        debug.SetMaxStack(262144000 * 2)\n        infiniteCount(0)\n}\nfunc infiniteCount(i int) {\n        if i%1000 == 0 {\n                fmt.Println(i)\n        }\n        infiniteCount(i + 1)\n}\n```", "```go\n3724000\n3725000\n3726000\n3727000\n3728000\nruntime: goroutine stack exceeds 524288000-byte limit\nruntime: sp=0xc010080388 stack=[0xc010080000, 0xc020080000]\nfatal error: stack overflow\nruntime stack:\nruntime.throw({0x496535?, 0x50e900?})\n        /usr/lib/golang/src/runtime/panic.go:992 +0x71\nruntime.newstack()\n        /usr/lib/golang/src/runtime/stack.go:1101 +0x5cc\nruntime.morestack()\n        /usr/lib/golang/src/runtime/asm_amd64.s:547 +0x8b\n```", "```go\nfunc Fact(input int) int {\n    if input == 0 {\n        return 1\n    }\n    return input * Fact(input-1)\n}\n```", "```go\nfunc tailCallFactorial(n int) int {\n    var factorial func(counter, result int) int\n    factorial = func(counter, result int) int {\n        if counter == 0 {\n            return result\n        }\n        return factorial(counter-1, result*counter)\n    }\n    return factorial(n, 1)\n}\n```", "```go\nreturn factorial(counter-1, result*counter)\n```"]