- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to talk about recursion. This is a topic that
    all programmers encounter sooner or later, as it’s not exclusive to the functional
    paradigm. Any language in which you can express function calls allows you to express
    functions that are recursive in nature. For many, it is not a topic that is difficult
    to understand at first. In functional programming languages such as Haskell, recursion
    takes center stage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: As such, this chapter is dedicated to understanding exactly how recursion works,
    including what the performance implications are of doing so, and what the limits
    of recursion are in Go. We’ll also take a look at some handy constructs for dealing
    with recursion using functions as first-class citizens.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What recursion means
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use recursive functions?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When and how to use recursive functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging functions as first-class citizens to write recursive functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the limitations of recursive functions in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Tail-Recursion and compiler optimizations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we will learn in this chapter will set us up for success when talking about
    the Continuation-Passing style and fluent programming in later chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you should use any version of Go at or above 1.18\. All the
    code can be found on GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter7](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter7).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: What is recursion?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply put, a recursive function is a function that calls itself. In practice,
    this means that the following function is an example of a recursive function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, if the user would call the function “recursive,” all it would
    do would call itself ad infinitum. Effectively, this is an infinite loop and not
    the most useful function. To make recursive functions useful, we can extend our
    definition of a recursive function a bit further by setting up two rules:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A function must have a condition on which to call itself (recurse)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function must have a condition on which it returns *without* calling itself
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first condition just states that given a function, `X`, at some point in
    the function’s body, `X` will be called again. The second condition is that there
    exists a case for which the function, `X`, returns from the function without calling
    itself. This second condition is often called the *base case* of the recursive
    function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what this looks like, let’s implement a classical mathematical
    operation that lends itself well to recursion, namely the factorial function.
    The factorial function is defined as a function that, given an input, *N*, multiplies
    all the numbers of *N* down to 1; for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see why this is a recursive function, we can show that the result of calling
    `Fact(5)` is the result of calling 5 multiplied by the result of `Fact(4)`. Thus,
    if we write this out, we will get the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that in this example, the factorial of 0 is simply 1\. This is defined
    as our base case; when a value of 0 is passed to our function, we simply return
    the integer value 1\. However, in all other input cases, we are multiplying the
    input number with the output of calling the factorial function with `input-1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'If we turn this into Go code, we will get the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If this is the first time you’ve seen recursion in a while, it may take you
    a few minutes to wrap your head around what is happening here. One way to think
    about this is that each function call to `Fact` pushes a function onto our stack.
    When all functions are pushed to the stack, they are evaluated from top to bottom,
    and each lower level of the stack can use the result from what came above it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Recursive function calls and stack allocation](img/Figure_7.1_B18771.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Recursive function calls and stack allocation'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about recursion in this stack-based way will help us understand the
    examples and pitfalls of recursion later in this chapter. But before we get to
    that, let’s look at when you might want to opt for writing a recursive function
    instead of an iterative one and why functional languages typically favor recursion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Why do functional languages favor recursion?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we discuss when to use recursive functions in Go, let’s answer the question
    of why functional languages seem to prefer recursion rather than `for` loops.
    The best answer for this is that recursion is inherently purer than iterative
    solutions. Although each program that can be expressed recursively can also be
    expressed iteratively, iterative solutions need to maintain more state than recursive
    solutions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Our simple factorial example highlights this when we write an iterative implementation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this factorial implementation, we are mutating the “result” in each iteration
    of the `for` loop. It is a well-contained mutation as it does not escape the function
    itself, but it’s a mutating state, nonetheless. Meanwhile, our pure recursive
    example never mutates the state. Rather than mutating the state, it returns a
    **new** value by combining an input parameter with the output of a function call:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As a general rule, recursion allows us to create new functions with copied states,
    make changes to the copies, and return the result, all without mutating a value
    in the recursive call itself. This means that changes to the program state are
    contained within each stack frame.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Recursive state changes in Go
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In Go and other non-pure languages, it is possible to mutate the state in recursive
    function calls. In such languages, recursion does not guarantee the immutability
    of the state but it does make it easier to write immutable implementations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: When to use recursive functions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand when to use a recursive function, we have to talk about the main
    trade-offs between iterative and recursive functions. But before we get to that,
    let’s start by saying that anything that can be implemented iteratively can also
    be implemented recursively. As such, each function that has a `for` statement
    in Go can be replaced by an equivalent function that uses a recursive function
    call in place of the `for` loop.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解何时使用递归函数，我们必须讨论迭代函数和递归函数之间的主要权衡。但在我们到达那里之前，让我们首先说，任何可以用迭代实现的东西也可以用递归实现。因此，任何在Go中有`for`语句的函数都可以替换为使用递归函数调用的等效函数来代替`for`循环。
- en: However, we might not always want to do so. The two main disadvantages of recursive
    functions are that they typically have greater time and space requirements. Calling
    a function multiple times creates multiple stack frames. These stack frames use
    up part of the working memory of our programs. Typically, each frame will contain
    a copy of the data from the frame below it (in a recursive function), which means
    that in the earlier Factorial example, each function call uses a similar amount
    of memory as the function that came before it. However, all these stack frames,
    at some point, are alive at the same time. A recursive call stack does not pop
    the stack until the final recursive call is completed. Hence, in *Figure 7**.1*,
    we can see that all stacks are added on top of each other, and are then evaluated
    from top to bottom (**Last-In, First-Out**, or **LIFO**). Had we written the same
    function iteratively, we would only have had one function on the call stack.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不总是希望这样做。递归函数的两个主要缺点是它们通常需要更多的时间和空间。多次调用函数会创建多个栈帧。这些栈帧消耗了我们程序部分的工作内存。通常，每个栈帧都会包含从其下方栈帧（在递归函数中）复制的数据，这意味着在先前的阶乘示例中，每个函数调用使用的内存量与之前的函数相似。然而，所有这些栈帧在某个时刻都是活跃的。递归调用栈不会在最后的递归调用完成之前弹出栈。因此，在*图7.1*中，我们可以看到所有栈帧叠加在一起，然后从上到下进行评估（**后进先出**，或**LIFO**）。如果我们以迭代的方式编写相同的函数，我们只会有一个函数在调用栈上。
- en: The second limitation of recursive functions is that they are typically slower
    than their iterative counterparts. This is mostly because function calls are expensive
    operations as far as programming language features go. In light of what we have
    just learned about the call stack, this makes sense. Each function call has to
    copy over memory to a new location, perform the core algorithm, and then copy
    it all over again for the next recursive call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的第二个限制是它们通常比它们的迭代版本慢。这主要是因为从编程语言特性的角度来看，函数调用是昂贵的操作。鉴于我们刚刚学到的关于调用栈的知识，这很有道理。每个函数调用都必须将内存复制到新位置，执行核心算法，然后再次复制以供下一次递归调用使用。
- en: So, why would we want to still use recursive functions? Well, although these
    limitations are important, our main goal is to achieve code readability and maintainability.
    Recursion, once mastered, can make programs not only easier to write but also
    easier to understand. Problems that involve traversing over graphs or trees easily
    lend themselves to recursive functions (as these data structures are recursive
    data structures themselves). An overarching theme of this book is that we’ll trade
    off performance for the convenience of both you, the programmer, and later readers
    of the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么还想继续使用递归函数呢？好吧，尽管这些限制很重要，但我们的主要目标是实现代码的可读性和可维护性。一旦掌握递归，可以使程序不仅更容易编写，也更容易理解。涉及遍历图或树的问题很容易适合递归函数（因为这些数据结构本身就是递归数据结构）。本书的一个主要主题是我们将为了你，程序员，以及代码的后续读者方便而权衡性能。
- en: 'As a side note, in languages such as Haskell, writing recursive functions involves
    less syntax overhead than in Go – especially when combined with a concept known
    as *pattern matching*. Without diverging too much from the core content of this
    chapter, let’s quickly look at the factorial implementation in Haskell:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在Haskell等语言中，编写递归函数比在Go中涉及更少的语法开销——特别是当与称为*模式匹配*的概念结合使用时。在不偏离本章核心内容太多的情况下，让我们快速看一下Haskell中的阶乘实现：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding snippet is a full implementation of the Factorial function. Notice
    that it reads almost like a more mathematical description of the problem. This
    makes writing the recursive solution more appealing. In addition, Haskell also
    performs compiler-level optimizations for handling recursive functions. We’ll
    briefly look at one such optimization, Tail-Call optimization, later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over trees
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the preceding assumption that some code is easier to write recursively
    rather than functionally, let’s take a look at an example of iterating over a
    tree. Trees are recursive data structures, and as such should lend themselves
    to this implementation. For simplicity, let’s assume we have a tree that stores
    integers; the actual values don’t matter as much. We’ll construct a tree that
    looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Example of a (binary) tree](img/Figure_7.2_B18771.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Example of a (binary) tree'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The actual values of each node don’t matter, but let’s say we want to find the
    sum of all nodes. In plain English, what we have to do is get the value of each
    node. Then, for each node, we need to figure out if it has children. If so, we
    add the value of the child to our running sum. Next, for all of those children,
    we figure out if they have children, and if so, also add their values to our running
    sum. We do this until we have seen all the nodes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let’s create a data structure that represents our tree.
    The type declaration itself is straightforward: we have a node that contains a
    value, and each node has a pointer to a left and right child. These children are
    optionally present:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this struct set up, let’s also introduce an actual tree on which we can
    demonstrate our example functions later in this chapter. We can create this as
    a package-level object in a `var` block. We’ll model the tree shown in *Figure
    7**.2*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we write this as a recursive solution, let’s write this as an iterative
    solution using a normal `for` loop.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Iteratively solving tree problems using a for loop
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to introduce some additional data structures before we can make this
    work. The data structure that we will use here is a `Queue`. For each node that
    we visit, we will add the node’s value to our sum. For each child of the node,
    we will add the child to our `Queue`. We will keep doing this until our `Queue`
    is empty. As a starting value, we will add the root of our tree to our `Queue`
    to kickstart the entire process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'One important disclaimer is that, at the time of writing, Go does not ship
    with an easy-to-use, out-of-the-box queue implementation. However, Go does include
    buffered channels out of the box. We can use buffered channels to get queue-like
    behavior, which is what we will be doing to demonstrate this. The main properties
    to get queue-like behavior are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Being able to push an element to the queue
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to pop (remove) an element from the queue in LIFO style
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could use a slice to get this behavior, but even that requires some overhead
    for managing the slice and it’s not the most performant implementation. A real
    queue would offer constant-time addition and removal. For that matter, perhaps
    buffered channels are doing this in an optimized way under the hood, but further
    exploration of that is outside the scope of this book. One necessary assumption
    we have to make, however, is that we know the size of our queue beforehand.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real-world scenario, this is often not the case. You could pass a best-effort
    estimation for the queue size to the buffered channel, but this seems error-prone.
    For didactic purposes and not to distract from the essence of the algorithm, we
    will accept those assumptions for now. With this disclaimer out of the way, let’s
    learn how to implement a function to get the sum of all the nodes in a tree iteratively:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we are adding a bit of additional overhead since we are managing
    our queue behavior using buffered channels. However, the core algorithm is the
    same. You could imagine saving some lines of code by not having a `select` block
    when using a real queue implementation though.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let’s take a look at how we can solve this problem recursively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Recursively solving tree problems
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When thinking about this problem recursively, it becomes much clearer and easier
    to implement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember from our factorial example that we are adding calls to our stack frame
    until we encounter a base case for which we can return a value without calling
    the function itself. The base case for this implementation is an absent node (nil
    pointer). Such a node will return a value of 0 as there is no sum to be made.
    For each other node, we return the sum of its value, along with the sum of values
    for all children. Visualizing this like a stack, we are adding frames to our stack
    from bottom to top, but evaluating from top to bottom, aggregating the sum as
    we go along:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This recursive code is one way to solve this problem without too much overhead.
    It is a more readable version of the iterative solution, and our code is closer
    to our intention. How does the recursive solution relate to what we have learned
    about functional programming so far?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming languages, you want to tell the computer *what* to
    solve instead of *how* to solve it. When you are writing loops manually, you are
    firmly in the domain of the how rather than the what of a given problem. In addition,
    our recursive solution is not mutating state anywhere, which brings us closer
    to an ideal function in the world of functional programming.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Functional languages and loops
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: While recursion is preferred in functional languages, many do offer constructs
    for creating manual loops as well. That said, they often offer compiler optimizations
    for recursive functions, which makes them an even more attractive option to solve
    problems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Recursion and functions as first-class citizens
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have seen so far in this chapter can be applied to any language that
    has function calls, even in languages that stick more firmly to the object-oriented
    domain. In this section, we’ll learn how to leverage some of the concepts of functional
    and multi-paradigm languages that make recursion easier to write and manage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到目前为止所看到的内容可以应用于任何具有函数调用的语言，即使在更严格遵循面向对象领域的语言中也是如此。在本节中，我们将学习如何利用一些使递归编写和管理更简单的函数式和多范式语言的概念。
- en: One of the most useful features I’ve found is to combine recursion with closures.
    To give an example of when this comes in handy, imagine working recursively on
    a data structure and having to keep some state tracked. Rather than tracking the
    state at the package level, or complicating the recursive function to keep the
    state tracked in the recursing functions, *we can create an outer function that
    is not recursive and then use a recursive inner function*. Let’s demonstrate this
    with an example to clear up some potential confusion.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现最有用的功能之一是将递归与闭包结合。为了举例说明何时这很有用，想象一下在递归处理数据结构时需要跟踪一些状态。与其在包级别跟踪状态，或者使递归函数复杂化以在递归函数中跟踪状态，*我们可以创建一个非递归的外部函数，然后使用递归的内层函数*。让我们用一个例子来演示这一点，以消除一些潜在的混淆。
- en: 'Using the same tree as in the previous example, let’s write a function to find
    the maximum value of a node in the tree. To achieve this, we need a way to track
    what the maximum value is, which we’ve seen so far. One option to achieve this
    is by tracking the state in a global variable outside of our recursive function.
    This is messy but would work. For example, the following code traverses the tree
    and uses a global variable to track what the maximum encountered value is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与上一个例子相同的树，让我们编写一个函数来找到树中节点的最大值。为了实现这一点，我们需要一种跟踪最大值的方法，我们之前已经看到了。实现这一点的选项之一是在递归函数外部跟踪状态。这很混乱但会起作用。例如，以下代码遍历树并使用全局变量跟踪遇到的最大值如下：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is not the ideal solution. First of all, using global variables
    to track any state should be discouraged. It would cause major headaches when
    writing multithreaded code, and if you’d forget to reset the global variable before
    a run of the recursive function. The outcome would be unreliable, even for single-threaded
    runs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不是理想的解决方案。首先，使用全局变量跟踪任何状态应该受到谴责。在编写多线程代码时，这会导致巨大的麻烦，如果你在递归函数运行之前忘记重置全局变量，结果将不可靠，即使是单线程运行。
- en: 'Another much better approach is to track the current maximum value as part
    of each recursive call. This is achieved by extending the function signature so
    that it includes the integer value that we are tracking, as shown in the following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更好的方法是跟踪每次递归调用中的当前最大值。这是通过扩展函数签名来实现的，使其包括我们正在跟踪的整数值，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are tracking the maximum value in the `maxValue` variable, which is
    passed in each recursive call. Then, in each call, we are continuing the recursive
    call downwards with the maximum value between `node.value` and `maxValue`. We
    end the calls by comparing the left and right-hand sides of the tree and returning
    the max of both sides.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`maxValue`变量中跟踪最大值，该变量在每次递归调用中传递。然后，在每次调用中，我们使用`node.value`和`maxValue`之间的最大值继续递归调用向下。我们通过比较树的左右两侧并返回两侧的最大值来结束调用。
- en: 'This is probably the cleanest way of writing the recursive function itself
    if we ignore what the code of the caller looks like. If we want to call the `maxInline`
    function, our calling functions will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是忽略调用者代码外观的情况下编写递归函数本身最干净的方式。如果我们想调用`maxInline`函数，我们的调用函数将看起来像这样：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the function call to `maxInline`, we are effectively leaking an implementation
    detail to the caller. The caller has to pass the initial starting value to our
    recursive function. This is rather messy, and for more complex functions, we can’t
    necessarily expect the caller to know what the appropriate value is. Ideally,
    we don’t leak such state details to our callers. Traditional object-oriented languages
    solve this problem by exposing a public non-recursive function that calls a private
    recursive function with the state appended. Modeling this in Go, we get the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have created a public `MaxInline` function that does not expose the
    internal mechanism for `maxInline`. The caller only needs to provide the root
    node to the public function. This function will then call the private `maxInline`
    function with the appropriate starting state. This pattern is incredibly common
    in object-oriented languages, and if those languages don’t support first-class
    functions, this is the right way to go about it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: However, in Go, we can do better. The main issue with the preceding approach
    is that you are still cluttering the package-private space with a function anyone
    working in the package can use. This might be desired behavior, but not always.
    One way to work around this is by encapsulating the recursive function *within*
    the non-recursive function. In this way, we can track the state inside the non-recursive
    function, which is accessible to the recursive inner function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation does exactly that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s take a look at what is happening here. First, note that our `Max` function
    is not recursive itself. This allows us to perform some operations that we know
    will only happen once per call to `Max`. For example, this is a great place to
    log activity, add metrics for performance, or add some state, as we are doing
    here. In our case, we’re creating a variable called `currentMax`. This variable
    will keep track of what the maximum value is that we’ve encountered.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are creating a variable called `inner` of the `func(node *node)` type.
    This is an important step. We’re not creating the function in-line immediately;
    first, we need to set up the variable without an implementation attached to it.
    The reason why we are doing this is so that we can refer to the `inner` variable
    inside an anonymous function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to instantiate this `inner` function. If we tie that block
    together, we get this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This shows how we are calling `inner(node.left)` and `inner(node.right)` from
    within the `inner` function itself. This would not work if we did not define the
    function first without instantiating. In other words, the following code would
    not work:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s a seemingly small change, but it would break our function. After all, how
    could we refer to `inner` if the compiler hadn’t yet compiled the function that
    you are trying to create?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step of our code is to call the inner recursive function itself:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we have seen how using functions as first-class citizens can
    help us write recursive code. But there are performance implications of doing
    so. We’ll explore this in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Limits of recursive functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursive functions have a performance penalty. When creating a recursive function
    call, we are copying over the state from one function stack to the next. This
    involves copying a lot of data into our working memory, but additional computational
    overhead is required to make the function call itself happen. The main limitation
    of solving problems recursively, at least in Go, is that we will eventually run
    out of space to make the recursive call happen. The other limitation is that a
    recursive solution is often slower than an iterative one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the performance of recursive versus iterative solutions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at the implications for the space our programs are using during
    recursive function calls, let’s compare the performance of recursive and iterative
    solutions that fit within our working memory. To demonstrate this, we will use
    the same iterative and recursive solution to the factorial problem that we saw
    at the start of this chapter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test both functions, we can use the benchmarking features of Go, which we
    explored in earlier chapters. The benchmark setup for both the iterative and recursive
    approach is straightforward:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To benchmark the functions, we are going to generate the result of `Factorial(10)`.
    This is a pretty low number as it takes only 10 steps to derive the answer. Yet,
    the performance implications are clear. The average of multiple runs is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | ns/op |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| Iterative | 8.2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| Recursive | 24.8 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Performance of iterative versus recursive functions in ns/op'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, each iterative function needed about 1/4th the time to complete
    compared to the recursive function. The following graph shows the runtime of each
    function in ns/op for different inputs to the factorial function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Iterative (bottom) versus recursive (top) runtime in ns/op](img/Figure_7.3_B18771.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Iterative (bottom) versus recursive (top) runtime in ns/op'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The preceding graph shows that not only are recursive functions typically slower
    than their iterative counterparts, but they become slower in a more drastic way
    than the iterative solution. Keep these performance considerations in mind when
    opting to write recursive functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Note on benchmarking
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: These results were obtained using an Amazon Web Services EC2 instance (`t2.micro`)
    running Amazon Linux. The actual values of these results are machine-dependent.
    Running these benchmarks on a different machine will not necessarily give different
    results, but the general trend should remain the same. Running the benchmarks
    on the same `t2.micro` instance can still cause variations in the outcome.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Space limitation of recursive functions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from being slower in a typical scenario, recursive functions suffer from
    another drawback: each function called to a recursive function adds another frame
    to our stack. All the data from the current iteration is copied over and passed
    on to the new function. Recall from *Figure 7**.1* that these stacks are added
    on top of each other in a **LIFO** fashion. Once our stack cannot grow any further,
    the program will halt. The good news is that in Go, this limit is relatively large
    and might not pose immediate practical problems. On a modern 64-bit machine, this
    stack can hold up to 1 GB of data, while on 32-bit machines, the limit is 250
    MB.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the limits will eventually get hit. Let’s take a look at the following
    example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we were to run this function on a 32-bit machine, the tail end of the output
    would look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Hence, after about 1.8 million iterations, our program will crash. The actual
    limit depends on how large each stack frame is. For recursive functions that are
    more complex and manage more internal state, this limit will be lower. But what
    can we do to avoid hitting this limit? In Go, there is no way to completely avoid
    this limit when dealing with recursive functions. However, we can adjust the limit
    (although the 1 GB limit on a 64-bit machine should be plenty).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To alter the limit, we can use the `debug.SetMaxStack(bytes)` function. To
    demonstrate this, let’s alter the limits of a 32-bit machine to be twice the default
    size:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, the function can go on much longer before running out of stack space:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can tell, we could complete about 3.7 million iterations now before running
    into the limits of a 500 MB stack. While the 250 MB limit on a 32-bit machine
    is not extensive, for most practical applications, the 1-GB limit on a 64-bit
    machine should be sufficient.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion as a solution to stack limitations
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering these limitations of recursive functions, it might seem strange
    that functional languages prefer recursion over iteration. Often, these languages,
    such as Haskell, only have recursion to work with, and they mock iterative functions.
    In this section, we will briefly look at how languages such as Haskell make recursion
    work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that this is not possible in Go at the time
    of writing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The technique some functional languages use is called **tail-call optimization**.
    Even non-functional languages might offer this – JavaScript is a notable example.
    This is a compiler (or interpreter) optimization whereby a recursive function
    call is made without allocating a new stack frame. Recall that the main drawback
    of recursive functions is the fact that they can run out of stack space – hence,
    if we solve that problem, we can have infinite recursion.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The compiler does need some help from the programmer to make this work. We’ll
    demonstrate the examples with Go, but keep in mind that so far in Go, the compiler
    performs no optimization and as such we would still overflow the stack eventually.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting a recursive function into a tail-call recursive function
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key difference between a tail-call recursive function and a normal recursive
    function is that in the tail-call variant, each stack frame is independent of
    the others. To show this, let’s examine the factorial function again:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the last line of this function, we are returning `input * Fact(input – 1)`.
    This effectively ties the result of each call to the result of the subsequent
    call. To evaluate the multiplication, we’d first have to run the `Fact` function
    one level deeper. We could rewrite this function to avoid this and make each stack
    frame independent of the next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To do this, let’s leverage our functions as first-class citizens again. We’ll
    create an outer function called `tailCallFactorial` that is non-recursive, which,
    in turn, calls an inner function called `factorial`, which is recursive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'To write this function recursively and decouple each stack frame, we’ll make
    two changes. First, we’ll use a counter that counts down from `input` to 0\. This
    is equivalent to the `for i := n; i > 0; i—` `for` loop. Next, we’ll also keep
    aggregating the result of each multiplication. We will do this by performing multiplication
    on the input arguments of the next frame and passing on the multiplied values:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The key line of code that makes this function tail-call recursive is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this simple change, each stack frame can be evaluated separately. And some
    compilers detect that the current stack frame can be de-allocated as soon as the
    next frame is called. This is a high-level overview of what tail-call optimization
    is, but keep in mind that Go does not perform such compiler optimizations at the
    time of writing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw why recursion is a critical part of functional programming
    languages. We looked into how recursive functions make it easier to enforce function
    purity and immutability. Next, we saw how functions as first-class citizens can
    make it easier to manage the state of our recursive function calls. We did this
    by creating outer non-recursive functions that leverage an inner recursive function
    to perform the calculations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: After, we looked into the performance concerns of recursive and iterative solutions.
    Here, we saw that recursive solutions are often slower than their iterative counterparts
    and that eventually, recursive functions run out of memory to operate with, causing
    our programs to halt (even though this would take a very long time on a 64-bit
    machine).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at Tail-Call optimization and Tail-Call recursive functions.
    Tail-Call optimization is a practical compiler optimization that many languages,
    such as Haskell and JavaScript, support to work around the limitations of recursive
    functions. Crucially, we have seen that Go does not support Tail-Call optimization,
    even if we write Tail-Call recursive functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at declarative and fluent programming. We’ll
    leverage recursion to write programs in a continuation-passing style.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
