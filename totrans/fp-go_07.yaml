- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Recursion
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: In this chapter, we are going to talk about recursion. This is a topic that
    all programmers encounter sooner or later, as it’s not exclusive to the functional
    paradigm. Any language in which you can express function calls allows you to express
    functions that are recursive in nature. For many, it is not a topic that is difficult
    to understand at first. In functional programming languages such as Haskell, recursion
    takes center stage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论递归。这是一个所有程序员迟早都会遇到的话题，因为它并不局限于函数式范式。任何允许你表达函数调用的语言都允许你表达本质上递归的函数。对于许多人来说，这并不是一个一开始就难以理解的话题。在
    Haskell 等函数式编程语言中，递归占据着中心舞台。
- en: As such, this chapter is dedicated to understanding exactly how recursion works,
    including what the performance implications are of doing so, and what the limits
    of recursion are in Go. We’ll also take a look at some handy constructs for dealing
    with recursion using functions as first-class citizens.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章致力于理解递归的确切工作方式，包括这样做所带来的性能影响，以及 Go 中递归的限制。我们还将探讨一些使用函数作为一等公民处理递归的实用结构。
- en: 'In this chapter, we will cover these main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: What recursion means
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归的含义
- en: Why use recursive functions?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用递归函数？
- en: When and how to use recursive functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何使用递归函数
- en: Leveraging functions as first-class citizens to write recursive functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用函数作为一等公民来编写递归函数
- en: Understanding the limitations of recursive functions in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Go 中递归函数的限制
- en: Understanding Tail-Recursion and compiler optimizations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解尾递归和编译器优化
- en: What we will learn in this chapter will set us up for success when talking about
    the Continuation-Passing style and fluent programming in later chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习的内容将为我们在后续章节中讨论 Continuation-Passing style 和流畅编程打下成功的基础。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you should use any version of Go at or above 1.18\. All the
    code can be found on GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter7](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter7).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您应使用 Go 1.18 或更高版本的任何版本。所有代码都可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter7](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter7)。
- en: What is recursion?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是递归？
- en: 'Simply put, a recursive function is a function that calls itself. In practice,
    this means that the following function is an example of a recursive function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，递归函数是一个调用自身的函数。在实践中，这意味着以下函数是一个递归函数的例子：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, if the user would call the function “recursive,” all it would
    do would call itself ad infinitum. Effectively, this is an infinite loop and not
    the most useful function. To make recursive functions useful, we can extend our
    definition of a recursive function a bit further by setting up two rules:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果用户调用函数“recursive”，它只会无限期地调用自身。实际上，这是一个无限循环，并不是最有用的函数。为了使递归函数有用，我们可以通过设置两条规则来进一步扩展递归函数的定义：
- en: A function must have a condition on which to call itself (recurse)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须有一个条件，以便它可以调用自身（递归）
- en: A function must have a condition on which it returns *without* calling itself
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须有一个条件，它在不调用自身的情况下返回
- en: The first condition just states that given a function, `X`, at some point in
    the function’s body, `X` will be called again. The second condition is that there
    exists a case for which the function, `X`, returns from the function without calling
    itself. This second condition is often called the *base case* of the recursive
    function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件只是说明，在函数体中的某个点上，函数 `X` 将再次被调用。第二个条件是存在一种情况，函数 `X` 在不调用自身的情况下从函数中返回。这个第二个条件通常被称为递归函数的*基准情况*。
- en: 'To understand what this looks like, let’s implement a classical mathematical
    operation that lends itself well to recursion, namely the factorial function.
    The factorial function is defined as a function that, given an input, *N*, multiplies
    all the numbers of *N* down to 1; for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这看起来是什么样子，让我们实现一个经典的数学运算，这个运算非常适合递归，即阶乘函数。阶乘函数定义为给定一个输入 *N*，将 *N* 下的所有数字乘到
    1；例如：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see why this is a recursive function, we can show that the result of calling
    `Fact(5)` is the result of calling 5 multiplied by the result of `Fact(4)`. Thus,
    if we write this out, we will get the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么这是一个递归函数，我们可以展示调用 `Fact(5)` 的结果实际上是调用 5 乘以调用 `Fact(4)` 的结果。因此，如果我们这样写出来，我们会得到以下结果：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that in this example, the factorial of 0 is simply 1\. This is defined
    as our base case; when a value of 0 is passed to our function, we simply return
    the integer value 1\. However, in all other input cases, we are multiplying the
    input number with the output of calling the factorial function with `input-1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，0 的阶乘简单地等于 1。这被定义为我们的基本情况；当将 0 的值传递给我们的函数时，我们简单地返回整数值 1。然而，在所有其他输入情况下，我们正在将输入数字与调用阶乘函数
    `input-1` 的输出相乘。
- en: 'If we turn this into Go code, we will get the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这段代码转换为 Go 代码，我们会得到以下结果：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If this is the first time you’ve seen recursion in a while, it may take you
    a few minutes to wrap your head around what is happening here. One way to think
    about this is that each function call to `Fact` pushes a function onto our stack.
    When all functions are pushed to the stack, they are evaluated from top to bottom,
    and each lower level of the stack can use the result from what came above it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一段时间没有看到递归了，可能需要几分钟的时间来理解这里发生的事情。一种思考方式是，每次对 `Fact` 的函数调用都会将一个函数推入我们的栈中。当所有函数都推入栈中时，它们从上到下被评估，栈的每一层都可以使用来自上一层的结果：
- en: '![Figure 7.1: Recursive function calls and stack allocation](img/Figure_7.1_B18771.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：递归函数调用和栈分配](img/Figure_7.1_B18771.jpg)'
- en: 'Figure 7.1: Recursive function calls and stack allocation'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：递归函数调用和栈分配
- en: Thinking about recursion in this stack-based way will help us understand the
    examples and pitfalls of recursion later in this chapter. But before we get to
    that, let’s look at when you might want to opt for writing a recursive function
    instead of an iterative one and why functional languages typically favor recursion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式思考基于栈的递归将帮助我们理解本章后面递归的例子和陷阱。但在我们到达那里之前，让我们看看你为什么可能想要选择编写递归函数而不是迭代函数，以及为什么函数式语言通常更喜欢递归。
- en: Why do functional languages favor recursion?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么函数式语言更喜欢递归？
- en: Before we discuss when to use recursive functions in Go, let’s answer the question
    of why functional languages seem to prefer recursion rather than `for` loops.
    The best answer for this is that recursion is inherently purer than iterative
    solutions. Although each program that can be expressed recursively can also be
    expressed iteratively, iterative solutions need to maintain more state than recursive
    solutions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论在 Go 中何时使用递归函数之前，让我们回答一下为什么函数式语言似乎更喜欢递归而不是 `for` 循环。最好的答案是递归本质上比迭代解决方案更纯净。尽管每个可以用递归表示的程序也可以用迭代表示，但迭代解决方案需要维护比递归解决方案更多的状态。
- en: 'Our simple factorial example highlights this when we write an iterative implementation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的阶乘示例在编写迭代实现时突出了这一点：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this factorial implementation, we are mutating the “result” in each iteration
    of the `for` loop. It is a well-contained mutation as it does not escape the function
    itself, but it’s a mutating state, nonetheless. Meanwhile, our pure recursive
    example never mutates the state. Rather than mutating the state, it returns a
    **new** value by combining an input parameter with the output of a function call:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶乘实现中，我们在 `for` 循环的每次迭代中修改“结果”。这是一个封闭的修改，因为它没有逃离函数本身，但无论如何它是一个修改状态的操作。与此同时，我们的纯递归示例从不修改状态。它不是修改状态，而是通过将输入参数与函数调用的输出组合来返回一个新的值：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As a general rule, recursion allows us to create new functions with copied states,
    make changes to the copies, and return the result, all without mutating a value
    in the recursive call itself. This means that changes to the program state are
    contained within each stack frame.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般规则，递归允许我们创建具有复制状态的新函数，修改这些复制，并返回结果，所有这些都不需要在递归调用本身中修改任何值。这意味着程序状态的变化被包含在每个栈帧中。
- en: Recursive state changes in Go
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的递归状态变化
- en: In Go and other non-pure languages, it is possible to mutate the state in recursive
    function calls. In such languages, recursion does not guarantee the immutability
    of the state but it does make it easier to write immutable implementations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 和其他非纯语言中，在递归函数调用中修改状态是可能的。在这些语言中，递归并不保证状态的不可变性，但它确实使得编写不可变实现变得更加容易。
- en: When to use recursive functions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用递归函数
- en: To understand when to use a recursive function, we have to talk about the main
    trade-offs between iterative and recursive functions. But before we get to that,
    let’s start by saying that anything that can be implemented iteratively can also
    be implemented recursively. As such, each function that has a `for` statement
    in Go can be replaced by an equivalent function that uses a recursive function
    call in place of the `for` loop.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解何时使用递归函数，我们必须讨论迭代函数和递归函数之间的主要权衡。但在我们到达那里之前，让我们首先说，任何可以用迭代实现的东西也可以用递归实现。因此，任何在Go中有`for`语句的函数都可以替换为使用递归函数调用的等效函数来代替`for`循环。
- en: However, we might not always want to do so. The two main disadvantages of recursive
    functions are that they typically have greater time and space requirements. Calling
    a function multiple times creates multiple stack frames. These stack frames use
    up part of the working memory of our programs. Typically, each frame will contain
    a copy of the data from the frame below it (in a recursive function), which means
    that in the earlier Factorial example, each function call uses a similar amount
    of memory as the function that came before it. However, all these stack frames,
    at some point, are alive at the same time. A recursive call stack does not pop
    the stack until the final recursive call is completed. Hence, in *Figure 7**.1*,
    we can see that all stacks are added on top of each other, and are then evaluated
    from top to bottom (**Last-In, First-Out**, or **LIFO**). Had we written the same
    function iteratively, we would only have had one function on the call stack.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不总是希望这样做。递归函数的两个主要缺点是它们通常需要更多的时间和空间。多次调用函数会创建多个栈帧。这些栈帧消耗了我们程序部分的工作内存。通常，每个栈帧都会包含从其下方栈帧（在递归函数中）复制的数据，这意味着在先前的阶乘示例中，每个函数调用使用的内存量与之前的函数相似。然而，所有这些栈帧在某个时刻都是活跃的。递归调用栈不会在最后的递归调用完成之前弹出栈。因此，在*图7.1*中，我们可以看到所有栈帧叠加在一起，然后从上到下进行评估（**后进先出**，或**LIFO**）。如果我们以迭代的方式编写相同的函数，我们只会有一个函数在调用栈上。
- en: The second limitation of recursive functions is that they are typically slower
    than their iterative counterparts. This is mostly because function calls are expensive
    operations as far as programming language features go. In light of what we have
    just learned about the call stack, this makes sense. Each function call has to
    copy over memory to a new location, perform the core algorithm, and then copy
    it all over again for the next recursive call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的第二个限制是它们通常比它们的迭代版本慢。这主要是因为从编程语言特性的角度来看，函数调用是昂贵的操作。鉴于我们刚刚学到的关于调用栈的知识，这很有道理。每个函数调用都必须将内存复制到新位置，执行核心算法，然后再次复制以供下一次递归调用使用。
- en: So, why would we want to still use recursive functions? Well, although these
    limitations are important, our main goal is to achieve code readability and maintainability.
    Recursion, once mastered, can make programs not only easier to write but also
    easier to understand. Problems that involve traversing over graphs or trees easily
    lend themselves to recursive functions (as these data structures are recursive
    data structures themselves). An overarching theme of this book is that we’ll trade
    off performance for the convenience of both you, the programmer, and later readers
    of the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么还想继续使用递归函数呢？好吧，尽管这些限制很重要，但我们的主要目标是实现代码的可读性和可维护性。一旦掌握递归，可以使程序不仅更容易编写，也更容易理解。涉及遍历图或树的问题很容易适合递归函数（因为这些数据结构本身就是递归数据结构）。本书的一个主要主题是我们将为了你，程序员，以及代码的后续读者方便而权衡性能。
- en: 'As a side note, in languages such as Haskell, writing recursive functions involves
    less syntax overhead than in Go – especially when combined with a concept known
    as *pattern matching*. Without diverging too much from the core content of this
    chapter, let’s quickly look at the factorial implementation in Haskell:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在Haskell等语言中，编写递归函数比在Go中涉及更少的语法开销——特别是当与称为*模式匹配*的概念结合使用时。在不偏离本章核心内容太多的情况下，让我们快速看一下Haskell中的阶乘实现：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding snippet is a full implementation of the Factorial function. Notice
    that it reads almost like a more mathematical description of the problem. This
    makes writing the recursive solution more appealing. In addition, Haskell also
    performs compiler-level optimizations for handling recursive functions. We’ll
    briefly look at one such optimization, Tail-Call optimization, later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段是阶乘函数的完整实现。注意，它几乎就像是对问题的更数学化的描述。这使得编写递归解决方案更具吸引力。此外，Haskell 还会对递归函数进行编译器级别的优化。我们将在本章后面简要介绍一种这样的优化，即尾调用优化。
- en: Iterating over trees
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历树
- en: 'To demonstrate the preceding assumption that some code is easier to write recursively
    rather than functionally, let’s take a look at an example of iterating over a
    tree. Trees are recursive data structures, and as such should lend themselves
    to this implementation. For simplicity, let’s assume we have a tree that stores
    integers; the actual values don’t matter as much. We’ll construct a tree that
    looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示前面的假设，即某些代码以递归方式编写比以函数方式编写更容易，让我们看看遍历树的示例。树是递归数据结构，因此应该适合这种实现。为了简单起见，让我们假设我们有一个存储整数的树；实际值并不那么重要。我们将构建一个看起来像这样的树：
- en: '![Figure 7.2: Example of a (binary) tree](img/Figure_7.2_B18771.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：二叉树示例](img/Figure_7.2_B18771.jpg)'
- en: 'Figure 7.2: Example of a (binary) tree'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：二叉树示例
- en: The actual values of each node don’t matter, but let’s say we want to find the
    sum of all nodes. In plain English, what we have to do is get the value of each
    node. Then, for each node, we need to figure out if it has children. If so, we
    add the value of the child to our running sum. Next, for all of those children,
    we figure out if they have children, and if so, also add their values to our running
    sum. We do this until we have seen all the nodes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的实际值并不重要，但让我们假设我们想要找到所有节点的和。用简单的话说，我们必须获取每个节点的值。然后，对于每个节点，我们需要确定它是否有子节点。如果有，我们将子节点的值添加到我们的运行和中。接下来，对于所有这些子节点，我们需要确定它们是否有子节点，如果有，也将它们的值添加到我们的运行和中。我们这样做，直到我们看到了所有节点。
- en: 'To demonstrate this, let’s create a data structure that represents our tree.
    The type declaration itself is straightforward: we have a node that contains a
    value, and each node has a pointer to a left and right child. These children are
    optionally present:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们创建一个表示我们的树的数据结构。类型声明本身很简单：我们有一个包含值的节点，每个节点都有一个指向左子节点和右子节点的指针。这些子节点是可选的：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this struct set up, let’s also introduce an actual tree on which we can
    demonstrate our example functions later in this chapter. We can create this as
    a package-level object in a `var` block. We’ll model the tree shown in *Figure
    7**.2*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这个结构之后，让我们也介绍一个实际的树，我们可以在本章后面演示我们的示例函数。我们可以在 `var` 块中创建这个作为包级别的对象。我们将模拟
    *图 7.2* 中显示的树：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we write this as a recursive solution, let’s write this as an iterative
    solution using a normal `for` loop.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将它写成递归解决方案之前，让我们先使用普通的 `for` 循环将其写成迭代解决方案。
- en: Iteratively solving tree problems using a for loop
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `for` 循环迭代解决树问题
- en: We need to introduce some additional data structures before we can make this
    work. The data structure that we will use here is a `Queue`. For each node that
    we visit, we will add the node’s value to our sum. For each child of the node,
    we will add the child to our `Queue`. We will keep doing this until our `Queue`
    is empty. As a starting value, we will add the root of our tree to our `Queue`
    to kickstart the entire process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使这成为可能之前，我们需要引入一些额外的数据结构。我们将使用的数据结构是一个 `Queue`。对于每个我们访问的节点，我们将节点的值添加到我们的和中。对于节点的每个子节点，我们将子节点添加到我们的
    `Queue` 中。我们将继续这样做，直到我们的 `Queue` 为空。作为一个起始值，我们将树的根添加到我们的 `Queue` 中，以启动整个过程。
- en: 'One important disclaimer is that, at the time of writing, Go does not ship
    with an easy-to-use, out-of-the-box queue implementation. However, Go does include
    buffered channels out of the box. We can use buffered channels to get queue-like
    behavior, which is what we will be doing to demonstrate this. The main properties
    to get queue-like behavior are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的免责声明是，在撰写本文时，Go 并没有提供易于使用的、开箱即用的队列实现。然而，Go 确实包含开箱即用的缓冲通道。我们可以使用缓冲通道来获得类似队列的行为，这正是我们将要演示的。要获得类似队列的行为，以下是一些主要属性：
- en: Being able to push an element to the queue
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将一个元素推送到队列中
- en: Being able to pop (remove) an element from the queue in LIFO style
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够以 LIFO（后进先出）风格从队列中弹出（移除）一个元素
- en: You could use a slice to get this behavior, but even that requires some overhead
    for managing the slice and it’s not the most performant implementation. A real
    queue would offer constant-time addition and removal. For that matter, perhaps
    buffered channels are doing this in an optimized way under the hood, but further
    exploration of that is outside the scope of this book. One necessary assumption
    we have to make, however, is that we know the size of our queue beforehand.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用切片来获取这种行为，但这甚至需要一些管理切片的开销，并且这不是最高效的实现。一个真正的队列将提供常数时间的添加和删除。关于这一点，也许缓冲通道在底层以优化的方式执行此操作，但这超出了本书的范围。然而，我们必须做出的一个必要假设是，我们事先知道队列的大小。
- en: 'In a real-world scenario, this is often not the case. You could pass a best-effort
    estimation for the queue size to the buffered channel, but this seems error-prone.
    For didactic purposes and not to distract from the essence of the algorithm, we
    will accept those assumptions for now. With this disclaimer out of the way, let’s
    learn how to implement a function to get the sum of all the nodes in a tree iteratively:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，情况往往并非如此。你可以将队列大小的最佳努力估计传递给缓冲通道，但这似乎容易出错。为了教学目的，并且不分散对算法本质的注意力，我们暂时接受这些假设。在此声明之后，让我们学习如何迭代地实现一个获取树中所有节点之和的函数：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we are adding a bit of additional overhead since we are managing
    our queue behavior using buffered channels. However, the core algorithm is the
    same. You could imagine saving some lines of code by not having a `select` block
    when using a real queue implementation though.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们增加了一些额外的开销，因为我们正在使用缓冲通道管理我们的队列行为。然而，核心算法是相同的。你可以想象，在使用真正的队列实现时，如果没有`select`块，可以节省一些代码行。
- en: Next up, let’s take a look at how we can solve this problem recursively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何递归地解决这个问题。
- en: Recursively solving tree problems
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归解决树问题
- en: When thinking about this problem recursively, it becomes much clearer and easier
    to implement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归地思考这个问题时，它变得更加清晰和易于实现。
- en: 'Remember from our factorial example that we are adding calls to our stack frame
    until we encounter a base case for which we can return a value without calling
    the function itself. The base case for this implementation is an absent node (nil
    pointer). Such a node will return a value of 0 as there is no sum to be made.
    For each other node, we return the sum of its value, along with the sum of values
    for all children. Visualizing this like a stack, we are adding frames to our stack
    from bottom to top, but evaluating from top to bottom, aggregating the sum as
    we go along:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，从我们的阶乘示例中，我们是在遇到一个基本案例时向我们的栈帧添加调用，对于这个基本案例，我们可以返回一个值而不调用函数本身。这个实现的基本案例是一个缺失的节点（nil指针）。这样的节点将返回0，因为没有要做的和。对于其他每个节点，我们返回其值的和，以及所有子节点值的和。将此可视化为一个栈，我们是从底部到顶部向栈中添加帧，但是从顶部到底部进行评估，随着我们的进行，汇总总和：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This recursive code is one way to solve this problem without too much overhead.
    It is a more readable version of the iterative solution, and our code is closer
    to our intention. How does the recursive solution relate to what we have learned
    about functional programming so far?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段递归代码是解决此问题的一种方法，开销不大。它是迭代解决方案的更易读版本，我们的代码更接近我们的意图。递归解决方案如何与我们迄今为止学到的函数式编程相关？
- en: In functional programming languages, you want to tell the computer *what* to
    solve instead of *how* to solve it. When you are writing loops manually, you are
    firmly in the domain of the how rather than the what of a given problem. In addition,
    our recursive solution is not mutating state anywhere, which brings us closer
    to an ideal function in the world of functional programming.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程语言中，你想要告诉计算机“解决什么”问题，而不是“如何”解决问题。当你手动编写循环时，你坚定地处于给定问题的“如何”领域，而不是“解决什么”领域。此外，我们的递归解决方案在任何地方都没有修改状态，这使我们更接近函数式编程世界中的理想函数。
- en: Functional languages and loops
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言与循环
- en: While recursion is preferred in functional languages, many do offer constructs
    for creating manual loops as well. That said, they often offer compiler optimizations
    for recursive functions, which makes them an even more attractive option to solve
    problems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在函数式语言中更倾向于使用递归，但许多语言也提供了创建手动循环的结构。话虽如此，它们通常为递归函数提供编译器优化，这使得它们成为解决问题的更有吸引力的选择。
- en: Recursion and functions as first-class citizens
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归与函数作为一等公民
- en: What we have seen so far in this chapter can be applied to any language that
    has function calls, even in languages that stick more firmly to the object-oriented
    domain. In this section, we’ll learn how to leverage some of the concepts of functional
    and multi-paradigm languages that make recursion easier to write and manage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到目前为止所看到的内容可以应用于任何具有函数调用的语言，即使在更严格遵循面向对象领域的语言中也是如此。在本节中，我们将学习如何利用一些使递归编写和管理更简单的函数式和多范式语言的概念。
- en: One of the most useful features I’ve found is to combine recursion with closures.
    To give an example of when this comes in handy, imagine working recursively on
    a data structure and having to keep some state tracked. Rather than tracking the
    state at the package level, or complicating the recursive function to keep the
    state tracked in the recursing functions, *we can create an outer function that
    is not recursive and then use a recursive inner function*. Let’s demonstrate this
    with an example to clear up some potential confusion.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现最有用的功能之一是将递归与闭包结合。为了举例说明何时这很有用，想象一下在递归处理数据结构时需要跟踪一些状态。与其在包级别跟踪状态，或者使递归函数复杂化以在递归函数中跟踪状态，*我们可以创建一个非递归的外部函数，然后使用递归的内层函数*。让我们用一个例子来演示这一点，以消除一些潜在的混淆。
- en: 'Using the same tree as in the previous example, let’s write a function to find
    the maximum value of a node in the tree. To achieve this, we need a way to track
    what the maximum value is, which we’ve seen so far. One option to achieve this
    is by tracking the state in a global variable outside of our recursive function.
    This is messy but would work. For example, the following code traverses the tree
    and uses a global variable to track what the maximum encountered value is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与上一个例子相同的树，让我们编写一个函数来找到树中节点的最大值。为了实现这一点，我们需要一种跟踪最大值的方法，我们之前已经看到了。实现这一点的选项之一是在递归函数外部跟踪状态。这很混乱但会起作用。例如，以下代码遍历树并使用全局变量跟踪遇到的最大值如下：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is not the ideal solution. First of all, using global variables
    to track any state should be discouraged. It would cause major headaches when
    writing multithreaded code, and if you’d forget to reset the global variable before
    a run of the recursive function. The outcome would be unreliable, even for single-threaded
    runs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不是理想的解决方案。首先，使用全局变量跟踪任何状态应该受到谴责。在编写多线程代码时，这会导致巨大的麻烦，如果你在递归函数运行之前忘记重置全局变量，结果将不可靠，即使是单线程运行。
- en: 'Another much better approach is to track the current maximum value as part
    of each recursive call. This is achieved by extending the function signature so
    that it includes the integer value that we are tracking, as shown in the following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更好的方法是跟踪每次递归调用中的当前最大值。这是通过扩展函数签名来实现的，使其包括我们正在跟踪的整数值，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are tracking the maximum value in the `maxValue` variable, which is
    passed in each recursive call. Then, in each call, we are continuing the recursive
    call downwards with the maximum value between `node.value` and `maxValue`. We
    end the calls by comparing the left and right-hand sides of the tree and returning
    the max of both sides.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`maxValue`变量中跟踪最大值，该变量在每次递归调用中传递。然后，在每次调用中，我们使用`node.value`和`maxValue`之间的最大值继续递归调用向下。我们通过比较树的左右两侧并返回两侧的最大值来结束调用。
- en: 'This is probably the cleanest way of writing the recursive function itself
    if we ignore what the code of the caller looks like. If we want to call the `maxInline`
    function, our calling functions will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是忽略调用者代码外观的情况下编写递归函数本身最干净的方式。如果我们想调用`maxInline`函数，我们的调用函数将看起来像这样：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the function call to `maxInline`, we are effectively leaking an implementation
    detail to the caller. The caller has to pass the initial starting value to our
    recursive function. This is rather messy, and for more complex functions, we can’t
    necessarily expect the caller to know what the appropriate value is. Ideally,
    we don’t leak such state details to our callers. Traditional object-oriented languages
    solve this problem by exposing a public non-recursive function that calls a private
    recursive function with the state appended. Modeling this in Go, we get the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `maxInline` 函数调用中，我们实际上向调用者泄露了实现细节。调用者必须将初始起始值传递给我们的递归函数。这相当混乱，对于更复杂的函数，我们不一定期望调用者知道适当的值。理想情况下，我们不希望向调用者泄露这样的状态细节。传统的面向对象语言通过暴露一个公开的非递归函数来解决此问题，该函数调用一个带有状态附加的私有递归函数。在
    Go 中建模，我们得到以下代码：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have created a public `MaxInline` function that does not expose the
    internal mechanism for `maxInline`. The caller only needs to provide the root
    node to the public function. This function will then call the private `maxInline`
    function with the appropriate starting state. This pattern is incredibly common
    in object-oriented languages, and if those languages don’t support first-class
    functions, this is the right way to go about it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个公开的 `MaxInline` 函数，它不暴露 `maxInline` 的内部机制。调用者只需要将根节点提供给公开函数。然后，这个函数将使用适当的起始状态调用私有的
    `maxInline` 函数。这种模式在面向对象的语言中非常常见，如果这些语言不支持一等函数，这是正确的做法。
- en: However, in Go, we can do better. The main issue with the preceding approach
    is that you are still cluttering the package-private space with a function anyone
    working in the package can use. This might be desired behavior, but not always.
    One way to work around this is by encapsulating the recursive function *within*
    the non-recursive function. In this way, we can track the state inside the non-recursive
    function, which is accessible to the recursive inner function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Go 语言中，我们可以做得更好。前面方法的主要问题是，你仍然在包私有空间中添加了一个任何在包中工作的人都可以使用的函数。这可能是期望的行为，但并不总是如此。一种解决方法是将递归函数封装在非递归函数中。这样，我们可以在非递归函数内部跟踪状态，这个状态对递归内部函数是可访问的。
- en: 'The following implementation does exactly that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现正是如此：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s take a look at what is happening here. First, note that our `Max` function
    is not recursive itself. This allows us to perform some operations that we know
    will only happen once per call to `Max`. For example, this is a great place to
    log activity, add metrics for performance, or add some state, as we are doing
    here. In our case, we’re creating a variable called `currentMax`. This variable
    will keep track of what the maximum value is that we’ve encountered.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。首先，请注意，我们的 `Max` 函数本身不是递归的。这允许我们执行一些我们知道只会发生在 `Max` 调用一次的操作。例如，这是一个记录活动、添加性能指标或添加一些状态的绝佳位置，就像我们在这里所做的那样。在我们的例子中，我们创建了一个名为
    `currentMax` 的变量。这个变量将跟踪我们遇到的最大值。
- en: Next, we are creating a variable called `inner` of the `func(node *node)` type.
    This is an important step. We’re not creating the function in-line immediately;
    first, we need to set up the variable without an implementation attached to it.
    The reason why we are doing this is so that we can refer to the `inner` variable
    inside an anonymous function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个名为 `inner` 的变量，其类型为 `func(node *node)`。这是一个重要的步骤。我们不是立即内联创建函数；首先，我们需要设置这个变量而不附加实现。我们这样做的原因是，我们可以在匿名函数内部引用
    `inner` 变量。
- en: 'The next step is to instantiate this `inner` function. If we tie that block
    together, we get this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实例化这个 `inner` 函数。如果我们把这个块连接起来，我们得到这个：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This shows how we are calling `inner(node.left)` and `inner(node.right)` from
    within the `inner` function itself. This would not work if we did not define the
    function first without instantiating. In other words, the following code would
    not work:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们在 `inner` 函数内部如何调用 `inner(node.left)` 和 `inner(node.right)`。如果我们没有先定义函数而不实例化，这将不会工作。换句话说，以下代码将不会工作：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s a seemingly small change, but it would break our function. After all, how
    could we refer to `inner` if the compiler hadn’t yet compiled the function that
    you are trying to create?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这看似是一个小的改动，但它会破坏我们的函数。毕竟，如果没有编译器编译你试图创建的函数，我们怎么能引用 `inner` 呢？
- en: 'The last step of our code is to call the inner recursive function itself:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的最后一个步骤是调用内部的递归函数本身：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we have seen how using functions as first-class citizens can
    help us write recursive code. But there are performance implications of doing
    so. We’ll explore this in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了如何使用函数作为一等公民来帮助我们编写递归代码。但是，这样做也有性能影响。我们将在下一节中探讨这一点。
- en: Limits of recursive functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数的限制
- en: Recursive functions have a performance penalty. When creating a recursive function
    call, we are copying over the state from one function stack to the next. This
    involves copying a lot of data into our working memory, but additional computational
    overhead is required to make the function call itself happen. The main limitation
    of solving problems recursively, at least in Go, is that we will eventually run
    out of space to make the recursive call happen. The other limitation is that a
    recursive solution is often slower than an iterative one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数有性能惩罚。在创建递归函数调用时，我们正在从一个函数栈复制状态到下一个函数栈。这涉及到将大量数据复制到我们的工作内存中，但还需要额外的计算开销来使函数调用本身发生。至少在Go中，解决递归问题的主要限制是我们最终会耗尽空间来使递归调用发生。另一个限制是递归解决方案通常比迭代解决方案慢。
- en: Measuring the performance of recursive versus iterative solutions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量递归与迭代解决方案的性能
- en: 'Before we look at the implications for the space our programs are using during
    recursive function calls, let’s compare the performance of recursive and iterative
    solutions that fit within our working memory. To demonstrate this, we will use
    the same iterative and recursive solution to the factorial problem that we saw
    at the start of this chapter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看递归函数调用期间程序使用的空间影响之前，让我们比较适合我们工作内存的递归和迭代解决方案的性能。为了演示这一点，我们将使用本章开头看到的相同的迭代和递归解决方案来解决阶乘问题：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test both functions, we can use the benchmarking features of Go, which we
    explored in earlier chapters. The benchmark setup for both the iterative and recursive
    approach is straightforward:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这两个函数，我们可以使用Go的基准测试功能，这在之前的章节中已经探讨过。迭代和递归方法的基准测试设置都很简单：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To benchmark the functions, we are going to generate the result of `Factorial(10)`.
    This is a pretty low number as it takes only 10 steps to derive the answer. Yet,
    the performance implications are clear. The average of multiple runs is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基准测试这些函数，我们将生成`Factorial(10)`的结果。这是一个相当小的数字，因为它只需要10步就能得出答案。然而，性能影响是明显的。多次运行的平均值如下：
- en: '| Function | ns/op |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | ns/op |'
- en: '| Iterative | 8.2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | 8.2 |'
- en: '| Recursive | 24.8 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 递归 | 24.8 |'
- en: 'Table 7.1: Performance of iterative versus recursive functions in ns/op'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：迭代函数与递归函数在ns/op中的性能
- en: 'As we can see, each iterative function needed about 1/4th the time to complete
    compared to the recursive function. The following graph shows the runtime of each
    function in ns/op for different inputs to the factorial function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每个迭代函数完成所需的时间大约是递归函数的四分之一。以下图表显示了不同输入到阶乘函数的每个函数的运行时间（ns/op）：
- en: '![Figure 7.3: Iterative (bottom) versus recursive (top) runtime in ns/op](img/Figure_7.3_B18771.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：迭代（底部）与递归（顶部）在ns/op中的运行时间](img/Figure_7.3_B18771.jpg)'
- en: 'Figure 7.3: Iterative (bottom) versus recursive (top) runtime in ns/op'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：迭代（底部）与递归（顶部）在ns/op中的运行时间
- en: The preceding graph shows that not only are recursive functions typically slower
    than their iterative counterparts, but they become slower in a more drastic way
    than the iterative solution. Keep these performance considerations in mind when
    opting to write recursive functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示，递归函数通常比它们的迭代对应物慢，而且它们比迭代解决方案慢得更加明显。在决定编写递归函数时，请记住这些性能考虑因素。
- en: Note on benchmarking
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试注意事项
- en: These results were obtained using an Amazon Web Services EC2 instance (`t2.micro`)
    running Amazon Linux. The actual values of these results are machine-dependent.
    Running these benchmarks on a different machine will not necessarily give different
    results, but the general trend should remain the same. Running the benchmarks
    on the same `t2.micro` instance can still cause variations in the outcome.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果是在使用运行Amazon Linux的Amazon Web Services EC2实例（`t2.micro`）的情况下获得的。这些结果的实际值是机器相关的。在不同的机器上运行这些基准测试不一定会得到不同的结果，但总体趋势应该保持不变。在相同的`t2.micro`实例上运行基准测试仍然可能导致结果的变化。
- en: Space limitation of recursive functions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数的空间限制
- en: 'Apart from being slower in a typical scenario, recursive functions suffer from
    another drawback: each function called to a recursive function adds another frame
    to our stack. All the data from the current iteration is copied over and passed
    on to the new function. Recall from *Figure 7**.1* that these stacks are added
    on top of each other in a **LIFO** fashion. Once our stack cannot grow any further,
    the program will halt. The good news is that in Go, this limit is relatively large
    and might not pose immediate practical problems. On a modern 64-bit machine, this
    stack can hold up to 1 GB of data, while on 32-bit machines, the limit is 250
    MB.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在典型场景中速度较慢之外，递归函数还遭受另一个缺点：每个被递归函数调用的函数都会给我们的栈添加另一个帧。所有当前迭代的当前数据都会被复制并传递给新函数。回想一下
    *图 7**.1* 中，这些栈以**后进先出**的方式叠加。一旦我们的栈无法再增长，程序将停止。好消息是，在 Go 中，这个限制相对较大，可能不会立即引起实际问题的出现。在现代
    64 位机器上，这个栈可以容纳高达 1 GB 的数据，而在 32 位机器上，限制是 250 MB。
- en: 'In practice, the limits will eventually get hit. Let’s take a look at the following
    example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，限制最终会被触及。让我们看看以下例子：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we were to run this function on a 32-bit machine, the tail end of the output
    would look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 32 位机器上运行这个函数，输出的尾部将看起来像这样：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Hence, after about 1.8 million iterations, our program will crash. The actual
    limit depends on how large each stack frame is. For recursive functions that are
    more complex and manage more internal state, this limit will be lower. But what
    can we do to avoid hitting this limit? In Go, there is no way to completely avoid
    this limit when dealing with recursive functions. However, we can adjust the limit
    (although the 1 GB limit on a 64-bit machine should be plenty).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在大约 180 万次迭代后，我们的程序将崩溃。实际的限制取决于每个栈帧的大小。对于更复杂且管理更多内部状态的递归函数，这个限制会低一些。但我们可以做些什么来避免触及这个限制呢？在
    Go 中，处理递归函数时，没有完全避免这个限制的方法。然而，我们可以调整限制（尽管在 64 位机器上的 1 GB 限制应该足够了）。
- en: 'To alter the limit, we can use the `debug.SetMaxStack(bytes)` function. To
    demonstrate this, let’s alter the limits of a 32-bit machine to be twice the default
    size:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改限制，我们可以使用 `debug.SetMaxStack(bytes)` 函数。为了演示这一点，让我们将 32 位机器的限制更改为默认大小的两倍：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, the function can go on much longer before running out of stack space:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数可以在耗尽栈空间之前运行更长的时间：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can tell, we could complete about 3.7 million iterations now before running
    into the limits of a 500 MB stack. While the 250 MB limit on a 32-bit machine
    is not extensive, for most practical applications, the 1-GB limit on a 64-bit
    machine should be sufficient.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们现在可以在遇到 500 MB 栈的限制之前完成大约 370 万次迭代。虽然 32 位机器上的 250 MB 限制并不大，但对于大多数实际应用来说，64
    位机器上的 1-GB 限制应该是足够的。
- en: Tail recursion as a solution to stack limitations
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归作为解决栈限制的方案
- en: Considering these limitations of recursive functions, it might seem strange
    that functional languages prefer recursion over iteration. Often, these languages,
    such as Haskell, only have recursion to work with, and they mock iterative functions.
    In this section, we will briefly look at how languages such as Haskell make recursion
    work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到递归函数的这些限制，功能语言更倾向于递归而不是迭代，这似乎有些奇怪。通常，这些语言，如 Haskell，只有递归可用，并且它们嘲笑迭代函数。在本节中，我们将简要探讨
    Haskell 等语言是如何使递归工作的。
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The important thing to note here is that this is not possible in Go at the time
    of writing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要一点是，在编写 Go 语言时，这是不可能实现的。
- en: The technique some functional languages use is called **tail-call optimization**.
    Even non-functional languages might offer this – JavaScript is a notable example.
    This is a compiler (or interpreter) optimization whereby a recursive function
    call is made without allocating a new stack frame. Recall that the main drawback
    of recursive functions is the fact that they can run out of stack space – hence,
    if we solve that problem, we can have infinite recursion.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能语言使用的技巧被称为**尾调用优化**。即使是非功能语言也可能提供这种优化——JavaScript 是一个显著的例子。这是一种编译器（或解释器）优化，其中递归函数调用不会分配新的栈帧。回想一下，递归函数的主要缺点是它们可能会耗尽栈空间——因此，如果我们解决了这个问题，我们就可以实现无限递归。
- en: The compiler does need some help from the programmer to make this work. We’ll
    demonstrate the examples with Go, but keep in mind that so far in Go, the compiler
    performs no optimization and as such we would still overflow the stack eventually.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器确实需要程序员的帮助才能实现这一点。我们将使用Go语言来演示这些示例，但请注意，到目前为止，在Go语言中，编译器不执行任何优化，因此我们最终仍然会溢出栈。
- en: Rewriting a recursive function into a tail-call recursive function
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将递归函数重写为尾调用递归函数
- en: 'The key difference between a tail-call recursive function and a normal recursive
    function is that in the tail-call variant, each stack frame is independent of
    the others. To show this, let’s examine the factorial function again:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用递归函数和普通递归函数之间的关键区别在于，在尾调用变体中，每个栈帧都是相互独立的。为了展示这一点，让我们再次检查阶乘函数：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the last line of this function, we are returning `input * Fact(input – 1)`.
    This effectively ties the result of each call to the result of the subsequent
    call. To evaluate the multiplication, we’d first have to run the `Fact` function
    one level deeper. We could rewrite this function to avoid this and make each stack
    frame independent of the next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数的最后一行，我们返回`input * Fact(input – 1)`。这实际上将每个调用的结果与后续调用的结果绑定在一起。为了评估乘法，我们首先必须运行`Fact`函数一个层级更深。我们可以重写这个函数来避免这种情况，并使每个栈帧独立于下一个。
- en: To do this, let’s leverage our functions as first-class citizens again. We’ll
    create an outer function called `tailCallFactorial` that is non-recursive, which,
    in turn, calls an inner function called `factorial`, which is recursive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们再次利用我们的函数作为一等公民。我们将创建一个名为`tailCallFactorial`的外部函数，它不是递归的，它反过来调用一个名为`factorial`的内部函数，该函数是递归的。
- en: 'To write this function recursively and decouple each stack frame, we’ll make
    two changes. First, we’ll use a counter that counts down from `input` to 0\. This
    is equivalent to the `for i := n; i > 0; i—` `for` loop. Next, we’ll also keep
    aggregating the result of each multiplication. We will do this by performing multiplication
    on the input arguments of the next frame and passing on the multiplied values:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要递归地编写这个函数并解耦每个栈帧，我们将进行两个更改。首先，我们将使用一个计数器，从`input`递减到0。这相当于`for i := n; i >
    0; i—` `for`循环。接下来，我们还将继续累加每次乘法的结果。我们将通过在下一个帧的输入参数上执行乘法并传递乘积值来完成这项工作：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The key line of code that makes this function tail-call recursive is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个函数成为尾递归的关键代码行如下：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this simple change, each stack frame can be evaluated separately. And some
    compilers detect that the current stack frame can be de-allocated as soon as the
    next frame is called. This is a high-level overview of what tail-call optimization
    is, but keep in mind that Go does not perform such compiler optimizations at the
    time of writing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的更改，每个栈帧都可以单独评估。并且一些编译器检测到当前栈帧可以在下一个帧被调用时立即释放。这是对尾调用优化的高级概述，但请注意，在编写本文时，Go并不执行此类编译器优化。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw why recursion is a critical part of functional programming
    languages. We looked into how recursive functions make it easier to enforce function
    purity and immutability. Next, we saw how functions as first-class citizens can
    make it easier to manage the state of our recursive function calls. We did this
    by creating outer non-recursive functions that leverage an inner recursive function
    to perform the calculations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了递归为什么是函数式编程语言的一个关键部分。我们研究了递归函数如何使强制函数纯净性和不可变性变得更容易。接下来，我们看到了函数作为一等公民如何使管理我们的递归函数调用状态变得更容易。我们通过创建外部非递归函数来实现这一点，这些函数利用内部递归函数来执行计算。
- en: After, we looked into the performance concerns of recursive and iterative solutions.
    Here, we saw that recursive solutions are often slower than their iterative counterparts
    and that eventually, recursive functions run out of memory to operate with, causing
    our programs to halt (even though this would take a very long time on a 64-bit
    machine).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们探讨了递归和迭代解决方案的性能问题。在这里，我们注意到递归解决方案通常比它们的迭代版本要慢，并且最终，递归函数会耗尽内存来执行操作，导致我们的程序停止（即使这在64位机器上可能需要非常长的时间）。
- en: Finally, we looked at Tail-Call optimization and Tail-Call recursive functions.
    Tail-Call optimization is a practical compiler optimization that many languages,
    such as Haskell and JavaScript, support to work around the limitations of recursive
    functions. Crucially, we have seen that Go does not support Tail-Call optimization,
    even if we write Tail-Call recursive functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了尾调用优化和尾调用递归函数。尾调用优化是一种实用的编译器优化，许多语言，如 Haskell 和 JavaScript，都支持这种优化以克服递归函数的限制。关键的是，我们了解到
    Go 语言不支持尾调用优化，即使我们编写了尾调用递归函数。
- en: In the next chapter, we will look at declarative and fluent programming. We’ll
    leverage recursion to write programs in a continuation-passing style.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨声明式和流畅式编程。我们将利用递归以传递继续风格编写程序。
