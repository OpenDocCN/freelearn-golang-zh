<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-126" class="chapter-number"><a id="_idTextAnchor126"/>8</h1>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/>Readable Function Composition with Fluent Programming</h1>
			<p>In this chapter, we are going to look at different methods for chaining functions in functional programming. The end goal here is to write code that is easier to read and takes up less visual space. We will look at three ways to <span class="No-Break">achieve this:</span></p>
			<ul>
				<li>First, we will take a look at how we can use type aliases to attach methods to container types, allowing us to create chained functions with the familiar <span class="No-Break"><em class="italic">dot notation</em></span><span class="No-Break">.</span></li>
				<li>We’ll then discuss lazy versus eager <span class="No-Break">code evaluation.</span></li>
				<li>Next, we will take a look at <strong class="bold">continuation-passing style</strong> (<strong class="bold">CPS</strong>) programming. In CPS, we will use higher-order functions to create a control flow without <span class="No-Break">our functions.</span></li>
				<li>We’ll also discuss the trade-offs in <span class="No-Break">each approach.</span></li>
			</ul>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Technical requirements</h1>
			<p>For this chapter, the minimum requirement is Go 1.18, as we will be writing code using generics. All the code can be found on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8</span></a><span class="No-Break">.</span></p>
			<p>Some of the code in this chapter will build on top of functions created in both <a href="B18771_05.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> and <a href="B18771_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. Where necessary, I have copied over the relevant functions and types from those chapters into the <strong class="source-inline">Chapter8</strong> subfolder. For example, <strong class="source-inline">Chapter8/LazyEvaluation/pkg</strong> is a copy of <strong class="source-inline">Chapter5/Monads/pkg</strong> and <strong class="source-inline">Chapter6/pkg</strong>. This way, the examples in <strong class="source-inline">Chapter8</strong> can always be run without requiring the <span class="No-Break">other chapters.</span></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor129"/>Chaining functions through dot notation</h1>
			<p>Chaining functions <a id="_idIndexMarker358"/>through dot notation is not a unique concept to functional programming. In fact, many object-oriented patterns such as the builder pattern explicitly do this as well. Before we dive into how we can leverage Go’s type aliases to do this, let’s look at an example in a more object-oriented style of programming before we dive into <span class="No-Break">chaining functions.</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Chaining methods for object creation (builder pattern)</h2>
			<p>We will create a package-private <strong class="source-inline">person</strong> object and add some public functions to change the state<a id="_idIndexMarker359"/> of the person, although remember that in Go, this is not the best way of instantiating a new object. However, it is the method many traditional object-oriented languages <span class="No-Break">opt for:</span></p>
			<pre class="source-code">
type person struct {
        firstName string
        lastName  string
        age       int
}
func newPerson() *person {
        return &amp;person{}
}
func (p *person) SetFirstName(firstName string) {
        p.firstName = firstName
}
func (p *person) SetLastName(lastName string) {
        p.lastName = lastName
}
func (p *person) SetAge(age int) {
        p.age = age
}</pre>
			<p>In this example, we have a person struct and three setters – <strong class="source-inline">SetFirstName</strong>, <strong class="source-inline">SetLastName</strong>, and <strong class="source-inline">SetAge</strong>. All three are used to modify the state of our object. If we want to create a new object, we can <a id="_idIndexMarker360"/>do so with the following <span class="No-Break">function calls:</span></p>
			<pre class="source-code">
func main() {
        alice := newPerson()
        alice.SetFirstName("alice")
        alice.SetLastName("elvi")
        alice.SetAge(30)
        fmt.Println(alice)
}</pre>
			<p>Alternatively, a constructor can <span class="No-Break">be created:</span></p>
			<pre class="source-code">
func constructor(firstName, lastName string, age int)
    person {
        return person{firstName, lastName, age}
}</pre>
			<p>This approach would work fine as long as our objects contain few fields. If an object contains many fields, the constructor and setter approach becomes error-prone and, frankly, tedious to write and maintain. When some fields need default values, it becomes even harder to model in many traditional languages (although some, such as Python and TypeScript, deal with this scenario gracefully). A solution to this particular problem is the <strong class="bold">builder pattern</strong>, which allows<a id="_idIndexMarker361"/> you to chain function calls for a more readable object-creation experience. It also offers additional benefits, such as being able to define default values, but for the purpose of this chapter, we’ll just focus on chaining <span class="No-Break">method calls.</span></p>
			<p>To achieve this, we will create a new type, <strong class="source-inline">personBuilder</strong>, which has a function for each field that we want to set. However, rather than simply mutating the <strong class="source-inline">person</strong> object, we will return <strong class="source-inline">personBuilder</strong> with the changes applied. Recall from earlier chapters that this is a way to ensure our functions are pure. It also allows us to create these functions without having to use pointers, as our state will be immutable. The one additional function<a id="_idIndexMarker362"/> that we need is <strong class="source-inline">build()</strong>, which will return the fully <span class="No-Break">instantiated object:</span></p>
			<pre class="source-code">
type personBuilder struct {
        person
}
func (pb personBuilder) FirstName(firstName string)
  personBuilder {
        pb.person.firstName = firstName
        return pb
}
func (pb personBuilder) LastName(lastName string)
  personBuilder {
        pb.person.lastName = lastName
        return pb
}
func (pb personBuilder) Age(age int) personBuilder {
        pb.person.age = age
        return pb
}
func (pb personBuilder) Build() person {
        return pb.person
}</pre>
			<p>When we want to create a person using <strong class="source-inline">personBuilder</strong>, we can chain the functions using the familiar <span class="No-Break">dot notation:</span></p>
			<pre class="source-code">
func main() {
        bob := personBuilder{}.FirstName("bob").
          LastName("Vande").
          Age(88).
          Build()
        fmt.Println(bob)
}</pre>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/>Dot notation to chain functions on slices</h2>
			<p>With this brief reminder of how dot notation works and how it is used in object-oriented languages, let’s dive into how we can leverage the same concept for the functions that are encountered in<a id="_idIndexMarker363"/> functional programming languages. Recall from earlier chapters that we created functions such as <strong class="source-inline">filter</strong>, <strong class="source-inline">map</strong>, and <strong class="source-inline">sum</strong> (as an abstraction on top of <strong class="source-inline">reduce</strong>). When we wanted to run multiple functions in sequence, we had to do <a id="_idIndexMarker364"/>so in separate statements and keep track of values in between. For example, imagine we have a slice of numbers. We want to double each number, then keep only those larger than 10, and finally, return their sum. Using the functions of <a href="B18771_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we could write this <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func main() {
        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        doubled := Map(ints, func(i int) int { return i * 2 })
        larger10 := Filter(doubled, func(i int) bool {
          return i &gt;= 10 })
        sum := Sum(larger10)
        fmt.Println(sum)
}</pre>
			<p>Technically, we don’t need the intermediate steps. We can write it as a one-liner, but it becomes incomprehensible <span class="No-Break">rather quickly:</span></p>
			<pre class="source-code">
func oneliner() {
        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        sum := Sum(Filter(Map(ints, func(i int) int {
           return i * 2 }), func(i int) bool {
             return i &gt;= 10 }))
        fmt.Println(sum)
}</pre>
			<p>With some minor<a id="_idIndexMarker365"/> formatting changes, it becomes <a id="_idIndexMarker366"/>slightly more readable, but it’s still not great, although it has a bit of a Lisp-y feel <span class="No-Break">to it:</span></p>
			<pre class="source-code">
func oneliner() {
        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        sum := .Sum(
                .Filter(
                        .Map(ints,
                            func(i int) int {
                                return i * 2 }),
                      func(i int) bool { return i &gt;= 10 }))
        fmt.Println(sum)
}</pre>
			<p>If you spend some time reading functions such as the preceding example, you do get used to it. Common Lisp is a good example here; the parenthesis makes it hard to read initially, but over time, it becomes second nature. Yet, I’d argue most of your coworkers are not fluent Lisp programmers and likely don’t want to spend their time learning how to read such code. As object-oriented dot notation is the most common way of method chaining, we should opt for a solution that is closer to what the majority of people are used to. We can achieve this in Go using type aliases. Remember from <a href="B18771_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> that type aliases allow us to attach functions to custom types and that we can create a custom type to represent <span class="No-Break">a slice.</span></p>
			<p>The first step, then, is to<a id="_idIndexMarker367"/> create a type alias for our container type. This works for all types, but we’ll demonstrate it <span class="No-Break">with integers:</span></p>
			<pre class="source-code">
type ints []int</pre>
			<p>Next, we will attach custom<a id="_idIndexMarker368"/> methods to this type alias. For our example, we will use <strong class="source-inline">Map</strong>, <strong class="source-inline">Filter</strong>, and <strong class="source-inline">Sum</strong>, as in the previous example, but this would work for any function. For each of the functions, they will call our existing (generic) <strong class="source-inline">Map</strong>, <strong class="source-inline">Filter</strong>, and <strong class="source-inline">Sum</strong> methods. However, notably, the difference is that these functions are now attached to a concrete type. This is somewhat similar to creating a <em class="italic">façade</em> pattern for <span class="No-Break">function dispatching:</span></p>
			<pre class="source-code">
func (i ints) Map(f func(i int) int) ints {
        return .Map(i, f)
}
func (i ints) Filter(f func(i int) bool) ints {
        return Filter(i, f)
}
func (i ints) Sum() int {
        return .Sum(i)
}</pre>
			<p>As you can tell from the preceding snippet, there’s no real magic happening here, but this small change will allow us to chain our functions together in the familiar dot notation. For example, the following method is identical to the previous <span class="No-Break">non-chained examples:</span></p>
			<pre class="source-code">
func chaining() int {
        input := ints([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
        return input.Map(func(i int) int { return i * 2 }).
              Filter(func(i int) bool { return i &gt;= 10 }).
                Sum()
}</pre>
			<p>I’d wager that, for many people, this is the more readable version, especially compared to the more Lisp-style example. However, to an extent, this is just personal preference and what you are used to. That said, in the population of Go programmers, dot notation function chaining is the more common approach. The main downside of this approach is that new functions <a id="_idIndexMarker369"/>need to be created simply to allow dot<a id="_idIndexMarker370"/> notation chaining. The good news is that there are solutions available for this, but they will make your project setup a bit more complex. We can automate the generation of such functions for our types using the Go compiler pragma system. In <a href="B18771_11.xhtml#_idTextAnchor158"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, we will see some examples of libraries that can <span class="No-Break">do this.</span></p>
			<h3>Lazy evaluation of function calls</h3>
			<p>There is a trade-off that happens <a id="_idIndexMarker371"/>whenever we opt for the preceding dot notation style of declarative programming in Go. To understand why there is a potential negative performance impact when<a id="_idIndexMarker372"/> chaining functions in Go but not in a language such as Haskell, we need to understand the concept of function evaluation and, particularly, lazy evaluation. When a programming language is said to support <strong class="bold">lazy evaluation</strong> of a<a id="_idIndexMarker373"/> function call, what is meant is that the function is only executed at the moment when the result is needed, instead of ahead <span class="No-Break">of time.</span></p>
			<p>We can contrast <a id="_idIndexMarker374"/>this with <strong class="bold">eager evaluation</strong> (also called strict evaluation), where the entire result for each function is computed at the time of the function call. Eager evaluation is the execution strategy employed by most programming languages, so it is likely the one that you are most familiar with. <em class="italic">Go does not opt for lazy evaluation, but we can mimic it.</em> To understand what it means for a programming language to be lazy, let’s first talk about eager evaluation and the mental model associated with this. Think about the flow of execution for the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
func main() {
     x := 3
     y := 4
     z := x + y
     fmt.Println(z)
}</pre>
			<p>When reading this <a id="_idIndexMarker375"/>code, the flow of <a id="_idIndexMarker376"/>execution follows our way of reading pretty much. First, the top line is evaluated, and then the one below that, all the way to the final line in <span class="No-Break">the code.</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_8.1_B18771.jpg" alt="Figure 8.1: The flow of execution, from top to bottom"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: The flow of execution, from top to bottom</p>
			<p>This is a natural way to read code and follow what is happening. Let’s extend the example with some <span class="No-Break">function calls.</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_8.2_B18771.jpg" alt="Figure 8.2: The execution flow with function calls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: The execution flow with function calls</p>
			<p>In <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em>, we can see how<a id="_idIndexMarker377"/> the execution flow is modeled when a function call is present. First, <strong class="bold">x</strong> and <strong class="bold">y</strong> are initialized. Then, before the assignment to <strong class="bold">z</strong> can happen, the <strong class="bold">add</strong> function needs to be executed entirely (line three in the image). Finally, the flow of execution is handed back over to our <strong class="source-inline">main</strong> function, which ends up printing the result stored in <strong class="bold">z</strong>. This is pretty straightforward and likely how you have been thinking about<a id="_idIndexMarker378"/> execution flow all along. Let’s show one more example of eager evaluation, and then contrast it with lazy evaluation. For this example, we will use the <strong class="source-inline">Filter</strong> method that we created in <a href="B18771_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
    input := []int{1, 2, 3, 4, 5, 6}
    isEven := func(i int) bool {
        return i%2 == 0
    }
    numberPrinter(pkg.Filter(input, isEven))
}
func numberPrinter(input []int) {
    for _, in := range input {
        fmt.Println(in)
    }
}</pre>
			<p>With eager evaluation, what <a id="_idIndexMarker379"/>happens in the preceding snippet is that the call to <strong class="source-inline">Filter</strong> will be resolved before passing on the entire result to <strong class="source-inline">numberPrinter</strong>. Essentially, the most deeply nested function will be evaluated first, with the outermost function evaluated last (and using the result of the inner evaluation). Again, this is how most of us rationalize<a id="_idIndexMarker380"/> code. <em class="italic">Lazy evaluation, however, wants to only perform the computation once the result becomes required.</em> In the preceding example, the moment at which the “even number filter” becomes relevant is when we start iterating over the result in <strong class="source-inline">numberPrinter</strong>. Thus, the flow of execution looks like <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_8.3_B18771.jpg" alt="Figure 8.3: The lazy evaluation execution flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: The lazy evaluation execution flow</p>
			<p>In <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em>, we zoom in on what happens once the <strong class="source-inline">numberPrinter(pkg.Filter(input, isEven))</strong> line is reached. What happens during lazy evaluation is that we jump into the <strong class="source-inline">numberPrinter</strong> function. Because the filtered list of numbers is not yet relevant to enter that function, the call to <strong class="source-inline">pkg.Filter</strong> has not yet happened. However, our runtime makes note that this function will need to be called eventually. Next, we hit the first line of <strong class="source-inline">numberPrinter</strong>, which loops <a id="_idIndexMarker381"/>over our input. At this point, the result of the <strong class="source-inline">Filter</strong> function becomes relevant. Thus, we need to figure out which numbers are odd by calling <strong class="source-inline">pkg.Filter</strong>. Once the<a id="_idIndexMarker382"/> result has been computed, the execution continues at the <strong class="source-inline">[..] range input [..]</strong> line. Thus, execution was effectively deferred until it was needed. That is the critical point of lazy evaluation – no work (i.e., no processing power) is expended until we know that it will be <span class="No-Break">absolutely necessary.</span></p>
			<p>A language built around this strongly requires function purity, as having a shifting state of the system in conjunction with this lazy evaluation mode of execution would be a recipe for disaster, and would be a leading cause of headaches among functional programmers. Go does not automatically translate our code into functions called with lazy evaluation, but we can force it to do so ourselves by leveraging higher-order functions. Before discussing how eager versus lazy evaluation impacts the declarative code that we are writing, let’s build a simple program that forces lazy evaluation in the preceding scenario. Once again, we’ll create a list of numbers, filtered to only keep the even ones, and then pass them <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">numberPrinter</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
    input := []int{1, 2, 3, 4, 5, 6}
    isEven := func(i int) bool {
        return i%2 == 0
    }
    numberPrinter(func() []int {
       return Filter(input, isEven)
})
    }
func numberPrinter(lazyGet func() []int) {
    fmt.Println("At this line, we don't yet know what our
      input values will be")
    for _, in := range lazyGet() {
        fmt.Println(in)
    }
}</pre>
			<p>In the preceding modified example, our <strong class="source-inline">numberPrinter</strong> function no longer takes a slice of integers as input. <em class="italic">Instead, it takes a function that returns a slice of integers as the input.</em> This is a crucial difference, as now it allows us to call the <strong class="source-inline">numberPrinter</strong> function without knowing the numbers to print ahead of time. Once <strong class="source-inline">numberPrinter</strong> deems it necessary to know the numbers, it can call the <strong class="source-inline">lazyGet</strong> function, which will generate<a id="_idIndexMarker383"/> each number. When we want to use <strong class="source-inline">numberPrinter</strong>, we have to provide a way for<a id="_idIndexMarker384"/> the function to get to the real input. We have done this with an anonymous function, simply wrapping our call to <strong class="source-inline">Filter</strong> in a new function that passes the <span class="No-Break">output along:</span></p>
			<pre class="source-code">
    numberPrinter(func() []int {
       return pkg.Filter(input, isEven)
})</pre>
			<p>This way, we can model lazy evaluation in Go. I’d say the main difference between this approach and what is typically considered a “lazily evaluated language” is that in a “lazy language,” this type of laziness is handled by the programming language itself. In Go, while we get to lazily evaluate each intermediate result for a function, doing so would require a lot <span class="No-Break">of overhead.</span></p>
			<h3>Delaying and avoiding execution</h3>
			<p>The right way to think about lazy evaluation is not simply <a id="_idIndexMarker385"/>delayed execution but rather <em class="italic">delay and avoid</em> execution. When <a id="_idIndexMarker386"/>working with lists, this translates into only generating the subset of the list required to solve the problem. This behavior is easy to mock in Go if we don’t want to write declarative code and hand-write our loops, but it’s much harder if we want to write declarative code. As mentioned earlier in the book, our aim is for code to be as declarative as possible, as this increases the readability. The next example will highlight what is meant by <em class="italic">delay and </em><span class="No-Break"><em class="italic">avoid</em></span><span class="No-Break"> execution.</span></p>
			<p>Let’s say we want to find the first factorial result that is larger than 10 million, and we want to write this in a declarative way. To demonstrate this, we will also reuse what we learned in earlier chapters. We’ll use the <strong class="source-inline">Maybe</strong> type introduced in <a href="B18771_05.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, create a new function (<strong class="source-inline">head</strong>), attach<a id="_idIndexMarker387"/> this function to a slice type (<strong class="source-inline">ints</strong>), create a function to generate a pre-populated slice of integers (<strong class="source-inline">IntRange</strong>), and finally, tie this together into a <span class="No-Break">single solution.</span></p>
			<p>The complete example can be found on GitHub: <a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8/LazyEvaluation">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8/LazyEvaluation</a>. Let’s start by setting up the <span class="No-Break"><strong class="source-inline">head</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func Head[A any](input []A) Maybe[A] {
        if len(input) == 0 {
                return Nothing[A]()
        }
        return Just(input[0])
}</pre>
			<p>This function returns <strong class="source-inline">Maybe</strong>, which either contains the underlying head of the list, or returns <strong class="source-inline">Nothing</strong>. To <a id="_idIndexMarker388"/>attach this to a type to use in our dot notation chain, we’ll need to provide a <span class="No-Break">wrapper function:</span></p>
			<pre class="source-code">
func (i ints) Head() Maybe[int] {
        return Head(i)
}</pre>
			<p>Next, we need to generate a slice of numbers. The <strong class="source-inline">IntRange</strong> function will generate a range of numbers between a lower and upper bound. Remember that when writing declarative code, we want to concern ourselves with the <em class="italic">what</em> and not the <em class="italic">how</em>. As Go does not offer this out of the box, we’ll write the generator function once (the <em class="italic">how</em>) and then only reuse the generator later (<span class="No-Break">the </span><span class="No-Break"><em class="italic">what</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
func IntRange(start, end int) []int {
        out := []int{}
        for i := start; i &lt;= end; i++ {
                out = append(out, i)
        }
        return out
}</pre>
			<p>If we were to write enough of these types of generators, we would ideally never have to write a manual loop again. Now that we have written these functions, in combination with <strong class="source-inline">Filter</strong> from <a href="B18771_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> and <strong class="source-inline">Factorial</strong> from <a href="B18771_07.xhtml#_idTextAnchor113"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we can tie this together into our <a id="_idIndexMarker389"/>declarative<a id="_idIndexMarker390"/> solution. In our <strong class="source-inline">main</strong> function, we will first create an inner function that checks whether a number is larger than 10 million. Then, we’ll declaratively chain the steps to find the first factorial larger than 10 million by doing <span class="No-Break">the following:</span></p>
			<ol>
				<li>Generating a range from 0 <span class="No-Break">to 100.</span></li>
				<li>Mapping each number in the range to its <span class="No-Break">factorial result.</span></li>
				<li>Filtering the results for being larger than <span class="No-Break">10 million.</span></li>
				<li>Returning the first element of <span class="No-Break">this list:</span></li>
			</ol>
			<pre class="source-code">
func main() {
        largerThan10Mil := func(i int) bool {
                return i &gt; 10_000_000
        }
        res := ints(IntRange(0, 100)).
                Map(Factorial).
                Filter(largerThan10Mil).
                Head()
        fmt.Printf("%v\n", res)
}</pre>
			<p>If we run this code, we get the following result – <strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">39916800}</strong></span><span class="No-Break">.</span></p>
			<p>While this is easy to read and understand, there is a pretty big drawback hiding underneath the<a id="_idIndexMarker391"/> implementation, due to Go’s lack of lazy evaluation. What we have done in the first two steps is <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Generate all numbers from 0 <span class="No-Break">to 100.</span></li>
				<li>Get their <span class="No-Break">factorial result.</span></li>
			</ol>
			<p>However, the first factorial that exceeded <strong class="source-inline">10_000_000</strong> actually happened at value for <strong class="source-inline">n=11</strong>. This means that <a id="_idIndexMarker392"/>every subsequent number (12 to 100) was generated and added to the slice, and then had its factorial calculated for no reason. In a lazily evaluated language such as Haskell, the list would only have generated the values needed to find the result and then <span class="No-Break">short-circuited execution.</span></p>
			<p class="callout-heading">Short-circuiting in predicates</p>
			<p class="callout">There is a form of short-circuiting and lazy evaluation that happens in most mainstream programming languages, including Go, which is short-circuiting for predicates. In an <strong class="source-inline">if</strong> condition, if there are multiple conditions present such as <strong class="source-inline">if A() &amp;&amp; B()</strong>, the <strong class="source-inline">B</strong> function would not be executed if <strong class="source-inline">A</strong> already returned <strong class="source-inline">false</strong>. Similarly, for the <strong class="source-inline">if A() || B()</strong> statement, the <strong class="source-inline">B</strong> function would not be executed if <strong class="source-inline">A</strong> already returned <strong class="source-inline">true</strong>. This saves on useless computation. (If you are writing side effect-heavy code that would have relied on the result of running both predicates, this can be nasty to debug. Yet another reason to avoid <span class="No-Break">side effects.)</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor132"/>Infinite data structures and lazy evaluation</h2>
			<p>Another advantage <a id="_idIndexMarker393"/>of lazy evaluation is that you can model infinite data structures, such as a list with all numbers from 0 to infinity. The reason that we can work with infinite structures in a lazily evaluated language is that you only compute as much data as is needed for the entire chain of operation. Go does not support lazy evaluation, so in this brief segue into the world of infinite data structures, the examples will be written in Haskell and an imaginary <span class="No-Break">Go implementation.</span></p>
			<p>In Haskell, defining an infinite list is a <span class="No-Break">simple operation:</span></p>
			<pre class="source-code">
InfiniteInts :: [Int]
InfiniteInts = [1..]</pre>
			<p>So how do we work with them? Well, we need a terminating function. For lazy evaluation to work with infinite lists, we need to have a clear end state at which the list operation completes. For example, let’s create an infinite list, check each number to see whether it is a prime number, and stop once we have generated 1 million <span class="No-Break">prime numbers.</span></p>
			<p>First, let’s create the <strong class="source-inline">naturals</strong> function, which generates all numbers from 2 to infinity. The reason for doing so is that we don’t know exactly where to stop. Let’s also define what the sieve of Eratosthenes <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
naturals :: [Int]
naturals = [2..]
sieve :: [Int] -&gt; [Int]
sieve (p:xs) = p : sieve [x | x &lt;- xs, x `mod` p /= 0]</pre>
			<p>The sieve will remove (sieve out) all non-primes from the list for a given starting value. Next, let’s wrap these two together into a function that generates prime numbers by feeding the infinite list of numbers into the sieve, alongside a limit (<strong class="source-inline">n</strong>) for how many we want <span class="No-Break">to generate:</span></p>
			<pre class="source-code">
primes :: Int -&gt; [Int]
primes n = take n (sieve naturals)</pre>
			<p>Here, we have our terminator function. <strong class="source-inline">take n</strong> tells us that, from the infinite list of data, we only want to generate however many are needed to reach <strong class="source-inline">n</strong>. Let’s call this in a <strong class="source-inline">main</strong> function to generate the first 1 million <span class="No-Break">of them:</span></p>
			<pre class="source-code">
main :: IO ()
main = do
  let millionPrimes = primes 1000000
  putStrLn $ "Generated " ++ show (length millionPrimes)
    ++ " prime numbers"</pre>
			<p>The preceding code is all written in Haskell, but now let’s move back to the domain of the star of this book, Go. If we think about how we would achieve something similar in Go, the easiest way to <a id="_idIndexMarker394"/>do so is by using a <strong class="source-inline">for { }</strong> loop. And to be specific, I mean the <em class="italic">while</em> behavior of the loop. We loop until a condition is met without a postcondition to increment a value. Ignoring the prime check, we would probably write something akin to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
func main() {
    primes := []int{}
    for len(primes) != 1_000_000 {
        // sieve or other algorithm to get prime
    }
}</pre>
			<p>The preceding implementation would work, assuming we fill out the body of the <strong class="source-inline">for </strong>loop (which is a de facto infinite generator; if we never reach the count of 1 million, it will keep looping forever. In practice, it means your algorithm is wrong). However, in writing this code, we have given up the declarative style of programming. <em class="italic">We moved back into the domain of spelling out “how” the result should be reached, rather than focusing on “what” the result should be.</em> In an imaginary Go implementation, what we would want to write is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
func main() {
    millionPrimes :=
        IntRange(2
            Filter(func(i int) bool {
                return isPrime(i)
            }).
            Take(1_000_000)
}</pre>
			<p>The preceding code<a id="_idIndexMarker395"/> would be the equivalent (functional) implementation, although we are filtering instead of using a sieve for the sake of simplicity. This ends our segue into lazy evaluation and its benefits. Let’s now move on to another style of chaining <span class="No-Break">functions together.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>Continuation-passing style programming</h2>
			<p>The next programming style that we will look at is <strong class="bold">continuation-passing style</strong> (<strong class="bold">CPS</strong>). Unlike the familiar dot notation style of method chaining, CPS is only possible in languages that support functions as first-class citizens. The core idea is that the continuation – in other words, the next step of execution – is another function that is passed as an argument to our <a id="_idIndexMarker396"/>original function. This allows us to control the flow of our program using function passing, rather than by branching and explicit function calls. The main benefit is that this will help us read and understand complex chains of functions, and we can change them with minimal effort. Before we dive into the Go implementation of CPS programming, let’s take a brief detour and <span class="No-Break">explain continuations.</span></p>
			<h3>What are continuations?</h3>
			<p>A continuation is a somewhat abstract concept in the realm of programming languages. It is a function that represents the next computation of a program. It essentially captures the state of our program at the moment of execution (more specifically, the stack), and provides the next step of execution as a function that can <span class="No-Break">be called.</span></p>
			<p>Continuations are<a id="_idIndexMarker397"/> used to implement the control flow within a programming language. They can be thought of as a data structure that represents our current state of execution and the next state of execution that we will transition into. This abstract concept is how programming languages can implement the control flow structures that are more familiar to us from day-to-day programming, such as exception handling, <strong class="source-inline">for</strong> loops, <span class="No-Break">and goroutines.</span></p>
			<p>In some languages, such as Scheme, continuations are exposed to the programmer and can be leveraged to control the flow of execution of the program at a higher level of abstraction. This is equivalent to programming your own control structs but with the additional advantage that the continuation can be modified in place to take on different behavior. In Go, this is not easily achievable. One of the challenges in doing this in Go is that it is a statically typed language, making it harder to even begin to define a continuation as a <span class="No-Break">data structure.</span></p>
			<p>The closest example that touches on continuations in Go is perhaps the <strong class="source-inline">panic</strong> and <strong class="source-inline">recover</strong> pattern. Imagine the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    fmt.Println("Normal execution happening")
    panic("Execution flow is broken")
    fmt.Println("This line will not be executed")
}</pre>
			<p>In this <strong class="source-inline">main</strong> function, we are first <a id="_idIndexMarker398"/>defining a <strong class="bold">deferred</strong> function that runs at the end of the <strong class="source-inline">main</strong> function, just<a id="_idIndexMarker399"/> before function exits. <strong class="source-inline">defer</strong> specifies a continuation for a function and is a special case in Go, in that it gets executed prior to function exit, regardless of how we exit the function. Inside the deferred function, we will recover if <strong class="source-inline">panic</strong> was encountered anywhere during the execution of the <span class="No-Break">parent function.</span></p>
			<p>Outside of the deferred function, we are explicitly calling <strong class="source-inline">panic</strong> after the first <strong class="source-inline">print</strong> statement. This is, again, an example of a continuation. There are a few special things happening here that might not be immediately obvious. First, the call to <strong class="source-inline">panic</strong> is not a simple function call. <strong class="source-inline">panic</strong> is used to signal that our execution stack ended up in a corrupted state, and the normal flow of execution is no longer possible. It captures the entire state of the stack at the moment <strong class="source-inline">panic</strong> was called and halts our function. However, because we have added the <strong class="source-inline">defer</strong> function as a continuation to <strong class="source-inline">main</strong>, <strong class="source-inline">defer</strong> gets access to this saved stack from <strong class="source-inline">panic</strong>. This can then display the content of the stack at the moment that <strong class="source-inline">panic</strong> was called, help us recover from the invalid state, and continue program execution without halting. In other words, our <strong class="source-inline">panic</strong> continuation is capturing valuable information about the state of our program and is exposing this to another function later on during execution. However, do remember that the use of <strong class="source-inline">panic</strong> is discouraged <span class="No-Break">in Go.</span></p>
			<p>Diving in depth into<a id="_idIndexMarker400"/> continuations is beyond the scope of this book, but this small introduction should serve the purpose of showing that continuations, although not explicitly called such in Go, are still prevalent in the language itself. There is a form of explicit continuation that we can leverage though, and that is how we end up in the domain of <span class="No-Break">CPS programming.</span></p>
			<h3>Implementing CPS code in Go</h3>
			<p>To build an understanding of CPS, let’s first take a look at a simple example. Recall from the last chapter that we<a id="_idIndexMarker401"/> created a few ways to calculate the factorial of a number. In this example, let’s rewrite the recursive version to follow the CPS pattern. To enable<a id="_idIndexMarker402"/> CPS, we need to pass the continuation as an argument to our recursive function. The remainder of the logic for calculating the factorial remains <span class="No-Break">the same:</span></p>
			<pre class="source-code">
func factorial(n int, f func(int)) {
    if n == 1 {
        f(1) // base-case
    } else {
        factorial(n-1, func(y int) {
            f(n * y)
        })
    }
}</pre>
			<p>In this factorial example, we are using a higher-order function, <strong class="source-inline">f</strong>, to represent the continuation of our recursive function call. Whereas in the recursive function call, we simply multiply the current input of our function by the result of the function call, here we are using a closure to perform the multiplication one layer deeper. We are saying that to continue calculating the factorial, we need to multiply <strong class="source-inline">n</strong> by <strong class="source-inline">y</strong>. However, <strong class="source-inline">y</strong> is not yet defined in this <a id="_idIndexMarker403"/>stack frame; it will only be defined in the next <span class="No-Break">function call.</span></p>
			<p>To run this <a id="_idIndexMarker404"/>function, let’s create a main function that prints the result of <span class="No-Break">the multiplications:</span></p>
			<pre class="source-code">
func main() {
    factorial(5, func(i int) {
        fmt.Printf("result: %v", i)
    })
}</pre>
			<p>Note how, in this function, we are calling <strong class="source-inline">fmt.Printf</strong> inside the closure. This means that the print statement will get passed down our function call chain, and it will eventually be evaluated by our factorial function. This is one of the powers of CPS – it is making explicit what happens at lower steps of recursion, rather than this being hidden from the programmer. The topmost stack frame gets a function pushed to it, which is the <strong class="source-inline">print</strong> function, and each subsequent call stack gets a function pushed onto it, which is a “multiply our input with the input of the next <span class="No-Break">call” function.</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_8.4_B18771.jpg" alt="Figure 8.4: Call stack with variable functions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4: Call stack with variable functions</p>
			<p>If we take a look at <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em>, we can see how there are different functions being pushed to different levels of our call stack. The bottommost call stack has a function call to <strong class="source-inline">Println</strong>, while the ones immediately above it have a function call to a multiplication closure. The final stack frame simply has the constant <strong class="bold">1</strong> (to signify <strong class="source-inline">n * 1</strong>). By introducing CPS, we <a id="_idIndexMarker405"/>have effectively abstracted over the recursive function call and have added additional flexibility to how our program flows through the call stack. Whereas in a normal recursive function, each subsequent layer is mostly <a id="_idIndexMarker406"/>a copy of the previous layers (apart from the base case), with CPS, we can introduce a different behavior at each frame, depending on what we want <span class="No-Break">to do.</span></p>
			<p>One thing to point out when we are using this mental model of call frames is that they are never returned. In a CPS program, you are not using <strong class="source-inline">return</strong> statements; rather, you are passing the continuation (next step) as a higher-order function. This is why our <strong class="source-inline">print</strong> statement is passed down until the final iteration is reached. To be explicit about it, each call frame is added to the stack but evaluation rolls up from the bottom – that is, our <strong class="source-inline">print</strong> statement is pushed to the frame above it, which pushes it to the frame above it, and so on, all the way to <span class="No-Break">the top.</span></p>
			<p>The function result is rolled up along the way with it. This is in contrast with normal recursion, where our stack frames are added similarly but evaluated from top to bottom. It can take a second to wrap your head around this inversion of evaluation flow. The reason behind this is that in each stack frame, we are passing closures as <em class="italic">input</em> to the next function. <em class="italic">However, remember that passing around a function as input to another function does not evaluate that function yet.</em> Hence, we are delaying the execution (as with lazy evaluation) of each function along the stack frame until the final frame is reached. In this case, <strong class="source-inline">f(1)</strong> is the final stack frame. Once we have reached this frame, all our closure functions are effectively evaluated. (From the last closure to the first closure, they are evaluated in the final frame. Hence, the <strong class="source-inline">print</strong> statement from the bottom prints the<a id="_idIndexMarker407"/> result of the <span class="No-Break">final evaluation.)</span></p>
			<p>Now that we have seen this example work with recursion, let’s look at a slightly more complex example<a id="_idIndexMarker408"/> where we are not actually using recursion. This is to show that any type of control flow can actually be modeled <span class="No-Break">with CPS.</span></p>
			<h3>Simple mathematics operations with CPS</h3>
			<p>In the preceding example, we have seen the recursive factorial calculation using CPS. This might lead us to believe that CPS is just an alternative way of writing a recursive function. And while<a id="_idIndexMarker409"/> there are certain advantages to writing recursive functions with CPS, it is not strictly necessary for a function to be recursive. Take the following example. Let’s say we start with a slice of integers as input. We first want to filter out the even numbers from the input. If a number is even, we want to double it. Finally, we want to print out the resulting integer. If we want to write this in CPS, we need to consider each continuation (following action) as a function to be passed to the original function. This, without diving into the details, produces the following flow <span class="No-Break">of continuations:</span></p>
			<pre class="source-code">
Input []int -&gt; isEven(int) -&gt; double(int) -&gt; print(int)</pre>
			<p>This shows us that three continuation functions are needed, along with a fourth function in which we will create the slice of inputs and start the chain of operations. Written in Go, this would produce the <span class="No-Break">following result:</span></p>
			<pre class="source-code">
func main() {
    is := []int{1, 2, 3, 4, 5, 6}
    isEven(is, func(i int) {
        double(i, print)
    })
}
func isEven(input []int, cont func(int)) {
    for _, i := range input {
        if i%2 == 0 {
            cont(i)
        }
    }
}
func double(input int, cont func(int)) {
    cont(input * 2)
}
func print(i int) {
    fmt.Println(i)
}</pre>
			<p>Each of our functions, apart from <strong class="source-inline">print</strong>, performs an operation on our input and calls a continuation function. The<a id="_idIndexMarker410"/> continuation function will provide the next step in our algorithm. In the <strong class="source-inline">isEven</strong> function, the continuation is only called if a number matches the <strong class="source-inline">i%2==0</strong> condition, effectively making sure that the continuation only happens on numbers that are even. Now, when we read our <strong class="source-inline">main</strong> function, the entire chain of operations is <span class="No-Break">spelled out:</span></p>
			<pre class="source-code">
func main() {
    is := []int{1, 2, 3, 4, 5, 6}
    isEven(is, func(i int) {
        double(i, print)
    })
}</pre>
			<p>First, we create a slice of integers. Next, we call <strong class="source-inline">isEven</strong>; after that, we double, and finally, we print. Note that the odd thing here is that we are actually creating an anonymous function <a id="_idIndexMarker411"/>as input for the <strong class="source-inline">isEven</strong> continuation. In Go, we cannot simply write the function <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func main() {
    is := []int{1, 2, 3, 4, 5, 6}
    isEven(is,    double(i, print))
}</pre>
			<p>Well, we could if we changed the signature of <strong class="source-inline">isEven</strong> to take as <span class="No-Break">input arguments:</span></p>
			<pre class="source-code">
func isEven(input []int, cont func(int, func(int))) {</pre>
			<p>However, now our <strong class="source-inline">isEven</strong> function is tied to a function that explicitly takes a continuation as a request. What if we simply want to print the even numbers and perform no further operations <span class="No-Break">on them?</span></p>
			<p>This gets to the heart of why CPS is difficult to get right in Go. The type system is too strict to easily manage functions in the CPS style of programming. We will discuss the drawbacks of CPS in more detail, but first, let’s take a look at a scenario where CPS can actually be a <span class="No-Break">real advantage.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>CPS and goroutines</h2>
			<p>One of the areas where CPS can definitely help<a id="_idIndexMarker412"/> is managing concurrent code. Whenever you hear about a <em class="italic">callback</em> in languages such as JavaScript, what you are really doing is using a continuation and passing this to an asynchronous function. Once the asynchronous part has been completed, the continuation (callback) is automatically called with the result of the asynchronous part. Often, this is done in the form of web requests, whereby a web request is launched, the callback is called when the request has been completed, and the state of the callback is populated with the result of the request. This result is often a status code (e.g., <strong class="source-inline">200</strong>) and a payload (in the case of a <strong class="source-inline">GET</strong> request). This is such a common pattern nowadays that we ignore the underlying concepts, nor do we really need to understand them to use callbacks. However, let’s model our <em class="italic">double if even</em> function with callbacks and asynchronous Go code to provide an <span class="No-Break">explicit example:</span></p>
			<pre class="source-code">
func main() {
        callback := func(input int, b bool) {
                if b {
                        fmt.Printf("the number %v is
                            even\n", input)
                } else {
                        fmt.Printf("the number %v is
                            odd\n", input)
                }
        }
        for i := 0; i &lt; 10; i++ {
                go isEven(i, callback)
        }
        _ := &lt;-make(chan int)
}
func isEven(i int, callback func(int, bool)) {
        if i%2 == 0 {
                callback(i, true)
        } else {
                callback(i, false)
        }
}</pre>
			<p>The preceding code is a slightly altered version. We are going to asynchronously verify whether or not a number is even, and if it is, we will print <strong class="source-inline">the number x is even</strong>; otherwise, we will print <strong class="source-inline">the number x is odd</strong>. The key component that CPS aims to simplify here is the flow-control <a id="_idIndexMarker413"/>part of an asynchronous call. We will launch a call with the <strong class="source-inline">go</strong> keyword, and as the continuation is encoded as part of the function that we are calling, we don’t have to worry about waiting for the result of the function call asynchronously to then launch into the next function. The pattern of <em class="italic">launch call, wait for result, continue computation</em> is often modeled as async/await operations in languages that don’t support higher-order functions. As <a id="_idIndexMarker414"/>Go is a multi-paradigm language, we can leverage higher-order functions and, thus, CPS. This allows us to focus on the <em class="italic">async</em> part without having to worry about the <em class="italic">wait and continue</em> part. That said, Go actually has a solid concurrency paradigm with goroutines and channels, so the need for this CPS-style programming is <span class="No-Break">mostly alleviated.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/>When to use CPS?</h2>
			<p>For most use cases, CPS will likely make<a id="_idIndexMarker415"/> your program more complex than it’s worth. It’s not the easiest way of reading recursive functions, and even when you are used to it, it can trip you up. It is, however, used in certain spaces, such as compiler/interpreter design. Typically, if there is a complex control flow that you want to model, CPS can make this control explicit and, thus, easier to comprehend <span class="No-Break">and read.</span></p>
			<p>Apart from this, another use case is the use of callbacks in asynchronous programming. Although we don’t often call those CPS, or even continuations, they are definitely a form of CPS. Due to the use of goroutines and channels, the more familiar style of callbacks that we find in languages such as JavaScript is a bit less common but, nevertheless, a useful area where we can <span class="No-Break">use them.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor136"/>Summary</h1>
			<p>In this chapter, we have looked at two distinct ways of composing our functional code. The first way is by chaining methods in a familiar dot notation-style chaining. This is a way of connecting inputs and outputs of various functions without having an intermediate variable assignment in between. While most programmers are familiar with this style of programming, there is some overhead required when writing (pure) functional code with generics <span class="No-Break">in Go.</span></p>
			<p>Another trade-off that we discussed here is the eager versus lazy modes of function evaluation. While it is possible to mimic lazy evaluation in Go, the compiler and language don’t do any of the heavy lifting for us. This means that if we were to port code from a functional language such as Haskell, the performance characters would be <span class="No-Break">significantly different.</span></p>
			<p>Finally, we also looked at continuations and CPS programming. A continuation is an abstract representation of any “next step” in an algorithm, whether it is a function call, a loop, or a “goto” statement. CPS programming makes the nature of recursive operations explicit and allows us to abstract over how function chaining happens. While CPS is a powerful technique, the use cases in daily life are a bit limited, even though we are using a lot of CPS under the hood, such as when modeling <span class="No-Break">callback functions.</span></p>
			<p>In the next chapter, we will jump one layer of abstraction higher and look at program composition through functional <span class="No-Break">design patterns.</span></p>
		</div>
		<div>
			<div id="_idContainer028" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer029" class="Content">
			<h1 id="_idParaDest-137"><a id="_idTextAnchor137"/>Part 3: Design Patterns and Functional Programming Libraries</h1>
			<p>In this part, we will first move to a higher level of abstraction by looking at software architecture using functional programming techniques. Once again, we will compare how the object-oriented approach compares with the more functional approach. We’ll see how Go’s concurrency paradigm can be leveraged in a functional context. Finally, we will learn about libraries that help us in building <span class="No-Break">functional applications.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18771_09.xhtml#_idTextAnchor138"><em class="italic">Chapter 9</em></a><em class="italic">, Functional Design Patterns</em></li>
				<li><a href="B18771_10.xhtml#_idTextAnchor147"><em class="italic">Chapter 10</em></a><em class="italic">, Concurrency and Functional Programming</em></li>
				<li><a href="B18771_11.xhtml#_idTextAnchor158"><em class="italic">Chapter 11</em></a><em class="italic">, Functional Programming Libraries</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer030">
			</div>
		</div>
	</body></html>