["```go\ntype person struct {\n        firstName string\n        lastName  string\n        age       int\n}\nfunc newPerson() *person {\n        return &person{}\n}\nfunc (p *person) SetFirstName(firstName string) {\n        p.firstName = firstName\n}\nfunc (p *person) SetLastName(lastName string) {\n        p.lastName = lastName\n}\nfunc (p *person) SetAge(age int) {\n        p.age = age\n}\n```", "```go\nfunc main() {\n        alice := newPerson()\n        alice.SetFirstName(\"alice\")\n        alice.SetLastName(\"elvi\")\n        alice.SetAge(30)\n        fmt.Println(alice)\n}\n```", "```go\nfunc constructor(firstName, lastName string, age int)\n    person {\n        return person{firstName, lastName, age}\n}\n```", "```go\ntype personBuilder struct {\n        person\n}\nfunc (pb personBuilder) FirstName(firstName string)\n  personBuilder {\n        pb.person.firstName = firstName\n        return pb\n}\nfunc (pb personBuilder) LastName(lastName string)\n  personBuilder {\n        pb.person.lastName = lastName\n        return pb\n}\nfunc (pb personBuilder) Age(age int) personBuilder {\n        pb.person.age = age\n        return pb\n}\nfunc (pb personBuilder) Build() person {\n        return pb.person\n}\n```", "```go\nfunc main() {\n        bob := personBuilder{}.FirstName(\"bob\").\n          LastName(\"Vande\").\n          Age(88).\n          Build()\n        fmt.Println(bob)\n}\n```", "```go\nfunc main() {\n        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n        doubled := Map(ints, func(i int) int { return i * 2 })\n        larger10 := Filter(doubled, func(i int) bool {\n          return i >= 10 })\n        sum := Sum(larger10)\n        fmt.Println(sum)\n}\n```", "```go\nfunc oneliner() {\n        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n        sum := Sum(Filter(Map(ints, func(i int) int {\n           return i * 2 }), func(i int) bool {\n             return i >= 10 }))\n        fmt.Println(sum)\n}\n```", "```go\nfunc oneliner() {\n        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n        sum := .Sum(\n                .Filter(\n                        .Map(ints,\n                            func(i int) int {\n                                return i * 2 }),\n                      func(i int) bool { return i >= 10 }))\n        fmt.Println(sum)\n}\n```", "```go\ntype ints []int\n```", "```go\nfunc (i ints) Map(f func(i int) int) ints {\n        return .Map(i, f)\n}\nfunc (i ints) Filter(f func(i int) bool) ints {\n        return Filter(i, f)\n}\nfunc (i ints) Sum() int {\n        return .Sum(i)\n}\n```", "```go\nfunc chaining() int {\n        input := ints([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n        return input.Map(func(i int) int { return i * 2 }).\n              Filter(func(i int) bool { return i >= 10 }).\n                Sum()\n}\n```", "```go\nfunc main() {\n     x := 3\n     y := 4\n     z := x + y\n     fmt.Println(z)\n}\n```", "```go\nfunc main() {\n    input := []int{1, 2, 3, 4, 5, 6}\n    isEven := func(i int) bool {\n        return i%2 == 0\n    }\n    numberPrinter(pkg.Filter(input, isEven))\n}\nfunc numberPrinter(input []int) {\n    for _, in := range input {\n        fmt.Println(in)\n    }\n}\n```", "```go\nfunc main() {\n    input := []int{1, 2, 3, 4, 5, 6}\n    isEven := func(i int) bool {\n        return i%2 == 0\n    }\n    numberPrinter(func() []int {\n       return Filter(input, isEven)\n})\n    }\nfunc numberPrinter(lazyGet func() []int) {\n    fmt.Println(\"At this line, we don't yet know what our\n      input values will be\")\n    for _, in := range lazyGet() {\n        fmt.Println(in)\n    }\n}\n```", "```go\n    numberPrinter(func() []int {\n       return pkg.Filter(input, isEven)\n})\n```", "```go\nfunc Head[A any](input []A) Maybe[A] {\n        if len(input) == 0 {\n                return Nothing[A]()\n        }\n        return Just(input[0])\n}\n```", "```go\nfunc (i ints) Head() Maybe[int] {\n        return Head(i)\n}\n```", "```go\nfunc IntRange(start, end int) []int {\n        out := []int{}\n        for i := start; i <= end; i++ {\n                out = append(out, i)\n        }\n        return out\n}\n```", "```go\nfunc main() {\n        largerThan10Mil := func(i int) bool {\n                return i > 10_000_000\n        }\n        res := ints(IntRange(0, 100)).\n                Map(Factorial).\n                Filter(largerThan10Mil).\n                Head()\n        fmt.Printf(\"%v\\n\", res)\n}\n```", "```go\nInfiniteInts :: [Int]\nInfiniteInts = [1..]\n```", "```go\nnaturals :: [Int]\nnaturals = [2..]\nsieve :: [Int] -> [Int]\nsieve (p:xs) = p : sieve [x | x <- xs, x `mod` p /= 0]\n```", "```go\nprimes :: Int -> [Int]\nprimes n = take n (sieve naturals)\n```", "```go\nmain :: IO ()\nmain = do\n  let millionPrimes = primes 1000000\n  putStrLn $ \"Generated \" ++ show (length millionPrimes)\n    ++ \" prime numbers\"\n```", "```go\nfunc main() {\n    primes := []int{}\n    for len(primes) != 1_000_000 {\n        // sieve or other algorithm to get prime\n    }\n}\n```", "```go\nfunc main() {\n    millionPrimes :=\n        IntRange(2\n            Filter(func(i int) bool {\n                return isPrime(i)\n            }).\n            Take(1_000_000)\n}\n```", "```go\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Recovered from panic:\", r)\n        }\n    }()\n    fmt.Println(\"Normal execution happening\")\n    panic(\"Execution flow is broken\")\n    fmt.Println(\"This line will not be executed\")\n}\n```", "```go\nfunc factorial(n int, f func(int)) {\n    if n == 1 {\n        f(1) // base-case\n    } else {\n        factorial(n-1, func(y int) {\n            f(n * y)\n        })\n    }\n}\n```", "```go\nfunc main() {\n    factorial(5, func(i int) {\n        fmt.Printf(\"result: %v\", i)\n    })\n}\n```", "```go\nInput []int -> isEven(int) -> double(int) -> print(int)\n```", "```go\nfunc main() {\n    is := []int{1, 2, 3, 4, 5, 6}\n    isEven(is, func(i int) {\n        double(i, print)\n    })\n}\nfunc isEven(input []int, cont func(int)) {\n    for _, i := range input {\n        if i%2 == 0 {\n            cont(i)\n        }\n    }\n}\nfunc double(input int, cont func(int)) {\n    cont(input * 2)\n}\nfunc print(i int) {\n    fmt.Println(i)\n}\n```", "```go\nfunc main() {\n    is := []int{1, 2, 3, 4, 5, 6}\n    isEven(is, func(i int) {\n        double(i, print)\n    })\n}\n```", "```go\nfunc main() {\n    is := []int{1, 2, 3, 4, 5, 6}\n    isEven(is,    double(i, print))\n}\n```", "```go\nfunc isEven(input []int, cont func(int, func(int))) {\n```", "```go\nfunc main() {\n        callback := func(input int, b bool) {\n                if b {\n                        fmt.Printf(\"the number %v is\n                            even\\n\", input)\n                } else {\n                        fmt.Printf(\"the number %v is\n                            odd\\n\", input)\n                }\n        }\n        for i := 0; i < 10; i++ {\n                go isEven(i, callback)\n        }\n        _ := <-make(chan int)\n}\nfunc isEven(i int, callback func(int, bool)) {\n        if i%2 == 0 {\n                callback(i, true)\n        } else {\n                callback(i, false)\n        }\n}\n```"]