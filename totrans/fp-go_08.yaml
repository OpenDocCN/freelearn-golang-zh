- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Readable Function Composition with Fluent Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读的函数组合与流畅编程
- en: 'In this chapter, we are going to look at different methods for chaining functions
    in functional programming. The end goal here is to write code that is easier to
    read and takes up less visual space. We will look at three ways to achieve this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在函数式编程中链式调用函数的不同方法。我们的最终目标是编写易于阅读且占用较少视觉空间的代码。我们将探讨三种实现这一目标的方法：
- en: First, we will take a look at how we can use type aliases to attach methods
    to container types, allowing us to create chained functions with the familiar
    *dot notation*.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将探讨如何使用类型别名将方法附加到容器类型上，从而允许我们使用熟悉的*点符号*创建链式函数。
- en: We’ll then discuss lazy versus eager code evaluation.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们接下来将讨论懒加载与急加载代码评估。
- en: Next, we will take a look at **continuation-passing style** (**CPS**) programming.
    In CPS, we will use higher-order functions to create a control flow without our
    functions.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨**延续传递风格**（**CPS**）编程。在CPS中，我们将使用高阶函数来创建控制流，而无需我们的函数。
- en: We’ll also discuss the trade-offs in each approach.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将讨论每种方法的权衡。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, the minimum requirement is Go 1.18, as we will be writing
    code using generics. All the code can be found on GitHub: [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，最低要求是Go 1.18，因为我们将会使用泛型编写代码。所有代码都可以在GitHub上找到：[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8)。
- en: Some of the code in this chapter will build on top of functions created in both
    [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085) and [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101).
    Where necessary, I have copied over the relevant functions and types from those
    chapters into the `Chapter8` subfolder. For example, `Chapter8/LazyEvaluation/pkg`
    is a copy of `Chapter5/Monads/pkg` and `Chapter6/pkg`. This way, the examples
    in `Chapter8` can always be run without requiring the other chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些代码将建立在第5章和第6章中创建的函数之上。[*第5章*](B18771_05.xhtml#_idTextAnchor085) 和 [*第6章*](B18771_06.xhtml#_idTextAnchor101)。在必要时，我已经将那些章节中的相关函数和类型复制到了`Chapter8`子文件夹中。例如，`Chapter8/LazyEvaluation/pkg`是`Chapter5/Monads/pkg`和`Chapter6/pkg`的副本。这样，`Chapter8`中的示例始终可以在不要求其他章节的情况下运行。
- en: Chaining functions through dot notation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过点符号链式调用函数
- en: Chaining functions through dot notation is not a unique concept to functional
    programming. In fact, many object-oriented patterns such as the builder pattern
    explicitly do this as well. Before we dive into how we can leverage Go’s type
    aliases to do this, let’s look at an example in a more object-oriented style of
    programming before we dive into chaining functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点符号链式调用函数并不是函数式编程独有的概念。实际上，许多面向对象的设计模式，如建造者模式，也明确地这样做。在我们深入探讨如何利用Go的类型别名来实现这一点之前，让我们先看看一个更面向对象风格的编程示例，然后再深入链式调用函数。
- en: Chaining methods for object creation (builder pattern)
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象创建的链式方法（建造者模式）
- en: 'We will create a package-private `person` object and add some public functions
    to change the state of the person, although remember that in Go, this is not the
    best way of instantiating a new object. However, it is the method many traditional
    object-oriented languages opt for:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包私有`person`对象，并添加一些公共函数来改变人的状态，尽管记住在Go中，这不是实例化新对象的最佳方式。然而，这是许多传统面向对象语言选择的方法：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we have a person struct and three setters – `SetFirstName`,
    `SetLastName`, and `SetAge`. All three are used to modify the state of our object.
    If we want to create a new object, we can do so with the following function calls:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有一个`person`结构体和三个设置器 - `SetFirstName`、`SetLastName`和`SetAge`。所有这三个都用于修改我们的对象状态。如果我们想创建一个新的对象，我们可以使用以下函数调用：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, a constructor can be created:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以创建一个构造函数：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This approach would work fine as long as our objects contain few fields. If
    an object contains many fields, the constructor and setter approach becomes error-prone
    and, frankly, tedious to write and maintain. When some fields need default values,
    it becomes even harder to model in many traditional languages (although some,
    such as Python and TypeScript, deal with this scenario gracefully). A solution
    to this particular problem is the **builder pattern**, which allows you to chain
    function calls for a more readable object-creation experience. It also offers
    additional benefits, such as being able to define default values, but for the
    purpose of this chapter, we’ll just focus on chaining method calls.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的对象包含的字段不多，这种方法就可以很好地工作。如果一个对象包含很多字段，构造函数和设置器方法就会变得容易出错，而且坦白说，编写和维护起来都很繁琐。当一些字段需要默认值时，在许多传统语言中建模就变得更加困难（尽管一些语言，如Python和TypeScript，可以优雅地处理这种场景）。解决这个特定问题的方法是**构建器模式**，它允许你链式调用函数，以获得更易读的对象创建体验。它还提供了额外的优势，例如能够定义默认值，但为了本章的目的，我们只关注链式调用方法。
- en: 'To achieve this, we will create a new type, `personBuilder`, which has a function
    for each field that we want to set. However, rather than simply mutating the `person`
    object, we will return `personBuilder` with the changes applied. Recall from earlier
    chapters that this is a way to ensure our functions are pure. It also allows us
    to create these functions without having to use pointers, as our state will be
    immutable. The one additional function that we need is `build()`, which will return
    the fully instantiated object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建一个新的类型，`personBuilder`，它为每个我们想要设置的域都有一个函数。然而，我们不会简单地修改`person`对象，而是将应用了更改的`personBuilder`返回。回想一下前面的章节，这是一种确保我们的函数是纯函数的方法。这也允许我们创建这些函数，而无需使用指针，因为我们的状态将是不可变的。我们还需要一个额外的函数`build()`，它将返回一个完全实例化的对象：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we want to create a person using `personBuilder`, we can chain the functions
    using the familiar dot notation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用`personBuilder`创建一个人时，我们可以使用熟悉的点表示法链式调用函数：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Dot notation to chain functions on slices
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点表示法用于在切片上链式调用函数
- en: 'With this brief reminder of how dot notation works and how it is used in object-oriented
    languages, let’s dive into how we can leverage the same concept for the functions
    that are encountered in functional programming languages. Recall from earlier
    chapters that we created functions such as `filter`, `map`, and `sum` (as an abstraction
    on top of `reduce`). When we wanted to run multiple functions in sequence, we
    had to do so in separate statements and keep track of values in between. For example,
    imagine we have a slice of numbers. We want to double each number, then keep only
    those larger than 10, and finally, return their sum. Using the functions of [*Chapter
    6*](B18771_06.xhtml#_idTextAnchor101), we could write this as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要回顾了点表示法的工作原理以及它在面向对象语言中的应用之后，让我们深入探讨如何利用这个概念来处理在函数式编程语言中遇到的函数。回想一下前面的章节，我们创建了诸如`filter`、`map`和`sum`（作为`reduce`的抽象）之类的函数。当我们想要按顺序运行多个函数时，我们必须在单独的语句中这样做，并在其中跟踪值。例如，假设我们有一个数字切片。我们想要将每个数字翻倍，然后只保留大于10的数字，最后返回它们的总和。使用[*第6章*](B18771_06.xhtml#_idTextAnchor101)中的函数，我们可以这样写：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Technically, we don’t need the intermediate steps. We can write it as a one-liner,
    but it becomes incomprehensible rather quickly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们不需要中间步骤。我们可以将其写为一行，但这很快就会变得难以理解：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With some minor formatting changes, it becomes slightly more readable, but
    it’s still not great, although it has a bit of a Lisp-y feel to it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些微小的格式调整，它变得稍微容易阅读一些，但仍然不是很好，尽管它带有一点Lisp风格的气息：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you spend some time reading functions such as the preceding example, you
    do get used to it. Common Lisp is a good example here; the parenthesis makes it
    hard to read initially, but over time, it becomes second nature. Yet, I’d argue
    most of your coworkers are not fluent Lisp programmers and likely don’t want to
    spend their time learning how to read such code. As object-oriented dot notation
    is the most common way of method chaining, we should opt for a solution that is
    closer to what the majority of people are used to. We can achieve this in Go using
    type aliases. Remember from [*Chapter 2*](B18771_02.xhtml#_idTextAnchor028) that
    type aliases allow us to attach functions to custom types and that we can create
    a custom type to represent a slice.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花些时间阅读像前面例子那样的函数，你会逐渐习惯它。Lisp 是一个很好的例子；括号使得它一开始难以阅读，但随着时间的推移，它变得像第二本能一样自然。然而，我敢打赌，大多数你的同事并不是熟练的
    Lisp 程序员，并且可能不想花时间学习如何阅读这样的代码。由于面向对象的点表示法是方法链的最常见方式，我们应该选择一个更接近大多数人习惯的解决方案。我们可以在
    Go 中使用类型别名来实现这一点。记得从[*第 2 章*](B18771_02.xhtml#_idTextAnchor028)中，类型别名允许我们将函数附加到自定义类型，并且我们可以创建一个自定义类型来表示一个切片。
- en: 'The first step, then, is to create a type alias for our container type. This
    works for all types, but we’ll demonstrate it with integers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，然后，是为我们的容器类型创建一个类型别名。这对所有类型都适用，但我们将用整数来演示它：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will attach custom methods to this type alias. For our example, we
    will use `Map`, `Filter`, and `Sum`, as in the previous example, but this would
    work for any function. For each of the functions, they will call our existing
    (generic) `Map`, `Filter`, and `Sum` methods. However, notably, the difference
    is that these functions are now attached to a concrete type. This is somewhat
    similar to creating a *façade* pattern for function dispatching:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为此类型别名附加自定义方法。在我们的例子中，我们将使用 `Map`、`Filter` 和 `Sum`，就像前面的例子一样，但这适用于任何函数。对于每个函数，它们将调用我们现有的（通用的）`Map`、`Filter`
    和 `Sum` 方法。然而，值得注意的是，这些函数现在被附加到一个具体类型上。这在某种程度上类似于创建一个 *外观* 模式来进行函数分发：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can tell from the preceding snippet, there’s no real magic happening
    here, but this small change will allow us to chain our functions together in the
    familiar dot notation. For example, the following method is identical to the previous
    non-chained examples:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的片段中并没有真正发生什么魔法，但这个小小的变化将允许我们以熟悉的点表示法将我们的函数链接在一起。例如，以下方法与前面的非链式示例相同：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’d wager that, for many people, this is the more readable version, especially
    compared to the more Lisp-style example. However, to an extent, this is just personal
    preference and what you are used to. That said, in the population of Go programmers,
    dot notation function chaining is the more common approach. The main downside
    of this approach is that new functions need to be created simply to allow dot
    notation chaining. The good news is that there are solutions available for this,
    but they will make your project setup a bit more complex. We can automate the
    generation of such functions for our types using the Go compiler pragma system.
    In [*Chapter 11*](B18771_11.xhtml#_idTextAnchor158), we will see some examples
    of libraries that can do this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，对于许多人来说，这是更易读的版本，尤其是与更 Lisp 风格的例子相比。然而，在某种程度上，这仅仅是个人偏好和习惯。话虽如此，在 Go 程序员群体中，点表示法函数链是更常见的方法。这种方法的主要缺点是，需要创建新的函数来简单地允许点表示法链。好消息是，有可用的解决方案，但它们会使你的项目设置变得更加复杂。我们可以使用
    Go 编译器预处理器系统自动为我们生成这些函数。在[*第 11 章*](B18771_11.xhtml#_idTextAnchor158)中，我们将看到一些可以做到这一点的库的例子。
- en: Lazy evaluation of function calls
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数调用的惰性评估
- en: There is a trade-off that happens whenever we opt for the preceding dot notation
    style of declarative programming in Go. To understand why there is a potential
    negative performance impact when chaining functions in Go but not in a language
    such as Haskell, we need to understand the concept of function evaluation and,
    particularly, lazy evaluation. When a programming language is said to support
    **lazy evaluation** of a function call, what is meant is that the function is
    only executed at the moment when the result is needed, instead of ahead of time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们选择 Go 中的前面点表示法声明性编程风格时，都会发生权衡。为了理解为什么在 Go 中链式调用函数时可能会有潜在的性能影响，而在像 Haskell
    这样的语言中则没有，我们需要理解函数评估的概念，尤其是惰性评估。当一个编程语言声称支持函数调用的 **惰性评估** 时，这意味着函数只有在需要结果的时候才会执行，而不是提前执行。
- en: 'We can contrast this with **eager evaluation** (also called strict evaluation),
    where the entire result for each function is computed at the time of the function
    call. Eager evaluation is the execution strategy employed by most programming
    languages, so it is likely the one that you are most familiar with. *Go does not
    opt for lazy evaluation, but we can mimic it.* To understand what it means for
    a programming language to be lazy, let’s first talk about eager evaluation and
    the mental model associated with this. Think about the flow of execution for the
    following snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这与其他的**贪婪求值**（也称为严格求值）进行对比，在函数调用时，每个函数的整个结果都会被计算。贪婪求值是大多数编程语言采用的执行策略，因此你很可能最熟悉它。*Go语言没有选择惰性求值，但我们仍然可以模拟它。*
    要了解编程语言惰性求值的意义，我们首先来谈谈贪婪求值及其相关的思维模型。考虑以下代码片段的执行流程：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When reading this code, the flow of execution follows our way of reading pretty
    much. First, the top line is evaluated, and then the one below that, all the way
    to the final line in the code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读这段代码时，执行流程基本上遵循我们阅读的方式。首先评估最上面的一行，然后是下面的一行，一直到最后一行代码。
- en: '![Figure 8.1: The flow of execution, from top to bottom](img/Figure_8.1_B18771.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：从上到下的执行流程](img/Figure_8.1_B18771.jpg)'
- en: 'Figure 8.1: The flow of execution, from top to bottom'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：从上到下的执行流程
- en: This is a natural way to read code and follow what is happening. Let’s extend
    the example with some function calls.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种自然的方式来阅读代码并跟踪正在发生的事情。让我们通过一些函数调用来扩展这个例子。
- en: '![Figure 8.2: The execution flow with function calls](img/Figure_8.2_B18771.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：带有函数调用的执行流程](img/Figure_8.2_B18771.jpg)'
- en: 'Figure 8.2: The execution flow with function calls'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：带有函数调用的执行流程
- en: 'In *Figure 8**.2*, we can see how the execution flow is modeled when a function
    call is present. First, `main` function, which ends up printing the result stored
    in `Filter` method that we created in [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.2*中，我们可以看到当存在函数调用时，执行流程是如何建模的。首先，是`main`函数，它最终会打印出我们创建在[*第6章*](B18771_06.xhtml#_idTextAnchor101)中的`Filter`方法中存储的结果：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With eager evaluation, what happens in the preceding snippet is that the call
    to `Filter` will be resolved before passing on the entire result to `numberPrinter`.
    Essentially, the most deeply nested function will be evaluated first, with the
    outermost function evaluated last (and using the result of the inner evaluation).
    Again, this is how most of us rationalize code. *Lazy evaluation, however, wants
    to only perform the computation once the result becomes required.* In the preceding
    example, the moment at which the “even number filter” becomes relevant is when
    we start iterating over the result in `numberPrinter`. Thus, the flow of execution
    looks like *Figure 8**.3*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在贪婪求值中，前面的代码片段中发生的情况是，在将整个结果传递给`numberPrinter`之前，会先解析对`Filter`的调用。本质上，最深层嵌套的函数会首先被评估，最外层的函数最后被评估（并使用内部评估的结果）。再次强调，这是我们大多数人合理化代码的方式。*然而，惰性求值只想在结果变得需要时才执行计算。*
    在前面的例子中，“偶数过滤器”变得相关的那一刻，是我们开始在`numberPrinter`中迭代结果的时候。因此，执行流程看起来就像*图8.3*所示的那样。
- en: '![Figure 8.3: The lazy evaluation execution flow](img/Figure_8.3_B18771.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：惰性求值执行流程](img/Figure_8.3_B18771.jpg)'
- en: 'Figure 8.3: The lazy evaluation execution flow'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：惰性求值执行流程
- en: In *Figure 8**.3*, we zoom in on what happens once the `numberPrinter(pkg.Filter(input,
    isEven))` line is reached. What happens during lazy evaluation is that we jump
    into the `numberPrinter` function. Because the filtered list of numbers is not
    yet relevant to enter that function, the call to `pkg.Filter` has not yet happened.
    However, our runtime makes note that this function will need to be called eventually.
    Next, we hit the first line of `numberPrinter`, which loops over our input. At
    this point, the result of the `Filter` function becomes relevant. Thus, we need
    to figure out which numbers are odd by calling `pkg.Filter`. Once the result has
    been computed, the execution continues at the `[..] range input [..]` line. Thus,
    execution was effectively deferred until it was needed. That is the critical point
    of lazy evaluation – no work (i.e., no processing power) is expended until we
    know that it will be absolutely necessary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8**.3*中，我们聚焦于一旦到达`numberPrinter(pkg.Filter(input, isEven))`行时发生的情况。在惰性求值期间发生的事情是，我们跳入`numberPrinter`函数。因为过滤后的数字列表尚未与该函数相关，所以对`pkg.Filter`的调用尚未发生。然而，我们的运行时记录下这个函数最终需要被调用。接下来，我们到达`numberPrinter`的第一行，它遍历我们的输入。在这个时候，`Filter`函数的结果变得相关。因此，我们需要通过调用`pkg.Filter`来确定哪些数字是奇数。一旦计算出了结果，执行将继续在`[..]
    range input [..]`行。因此，执行实际上被延迟到需要的时候。这就是惰性求值的要点——直到我们知道它绝对必要之前，不会消耗任何工作（即不会消耗处理能力）。
- en: 'A language built around this strongly requires function purity, as having a
    shifting state of the system in conjunction with this lazy evaluation mode of
    execution would be a recipe for disaster, and would be a leading cause of headaches
    among functional programmers. Go does not automatically translate our code into
    functions called with lazy evaluation, but we can force it to do so ourselves
    by leveraging higher-order functions. Before discussing how eager versus lazy
    evaluation impacts the declarative code that we are writing, let’s build a simple
    program that forces lazy evaluation in the preceding scenario. Once again, we’ll
    create a list of numbers, filtered to only keep the even ones, and then pass them
    to `numberPrinter`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在这一点上的语言强烈需要函数的纯净性，因为如果系统状态发生变化与这种惰性求值执行模式相结合，那将是一场灾难，也将是函数程序员头疼的主要原因。Go不会自动将我们的代码翻译成使用惰性求值的函数，但我们可以通过利用高阶函数来强制它这样做。在讨论急切求值与惰性求值如何影响我们正在编写的声明式代码之前，让我们构建一个简单的程序，在前面场景中强制惰性求值。再一次，我们将创建一个数字列表，过滤出仅保留偶数的数字，然后将它们传递给`numberPrinter`：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding modified example, our `numberPrinter` function no longer takes
    a slice of integers as input. *Instead, it takes a function that returns a slice
    of integers as the input.* This is a crucial difference, as now it allows us to
    call the `numberPrinter` function without knowing the numbers to print ahead of
    time. Once `numberPrinter` deems it necessary to know the numbers, it can call
    the `lazyGet` function, which will generate each number. When we want to use `numberPrinter`,
    we have to provide a way for the function to get to the real input. We have done
    this with an anonymous function, simply wrapping our call to `Filter` in a new
    function that passes the output along:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的修改示例中，我们的`numberPrinter`函数不再接受一个整数切片作为输入。*相反，它接受一个返回整数切片的函数作为输入。* 这是一个关键的区别，因为它现在允许我们在不知道要打印的数字的情况下调用`numberPrinter`函数。一旦`numberPrinter`认为有必要知道这些数字，它就可以调用`lazyGet`函数，该函数将生成每个数字。当我们想要使用`numberPrinter`时，我们必须提供一种方法让函数能够获取真实输入。我们通过一个匿名函数做到了这一点，简单地将对`Filter`的调用封装在一个新函数中，该函数将输出传递下去：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This way, we can model lazy evaluation in Go. I’d say the main difference between
    this approach and what is typically considered a “lazily evaluated language” is
    that in a “lazy language,” this type of laziness is handled by the programming
    language itself. In Go, while we get to lazily evaluate each intermediate result
    for a function, doing so would require a lot of overhead.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以在Go中模拟惰性求值。我认为这种方法与通常被认为是“惰性求值语言”的方法的主要区别在于，在“惰性语言”中，这种惰性是由编程语言本身处理的。在Go中，虽然我们可以对函数的每个中间结果进行惰性求值，但这样做会需要大量的开销。
- en: Delaying and avoiding execution
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟和避免执行
- en: The right way to think about lazy evaluation is not simply delayed execution
    but rather *delay and avoid* execution. When working with lists, this translates
    into only generating the subset of the list required to solve the problem. This
    behavior is easy to mock in Go if we don’t want to write declarative code and
    hand-write our loops, but it’s much harder if we want to write declarative code.
    As mentioned earlier in the book, our aim is for code to be as declarative as
    possible, as this increases the readability. The next example will highlight what
    is meant by *delay and* *avoid* execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正确理解惰性评估的方式并非仅仅是延迟执行，而是*延迟和避免*执行。当与列表一起工作时，这转化为仅生成解决问题所需的列表子集。如果我们不想编写声明式代码并手动编写循环，那么在
    Go 中模拟这种行为很容易，但如果我们要编写声明式代码，那就困难得多。正如本书前面提到的，我们的目标是使代码尽可能声明式，因为这会增加可读性。下一个示例将突出*延迟和*
    *避免*执行的含义。
- en: Let’s say we want to find the first factorial result that is larger than 10
    million, and we want to write this in a declarative way. To demonstrate this,
    we will also reuse what we learned in earlier chapters. We’ll use the `Maybe`
    type introduced in [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085), create a new
    function (`head`), attach this function to a slice type (`ints`), create a function
    to generate a pre-populated slice of integers (`IntRange`), and finally, tie this
    together into a single solution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到第一个大于一千万的阶乘结果，并且我们想要以声明式的方式编写这个程序。为了演示这一点，我们还将重用前面章节中学到的知识。我们将使用在[*第5章*](B18771_05.xhtml#_idTextAnchor085)中引入的`Maybe`类型，创建一个新的函数（`head`），将这个函数附加到切片类型（`ints`）上，创建一个生成预填充整数切片的函数（`IntRange`），最后，将这些结合起来形成一个单一解决方案。
- en: 'The complete example can be found on GitHub: [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8/LazyEvaluation](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8/LazyEvaluation).
    Let’s start by setting up the `head` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可以在 GitHub 上找到：[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8/LazyEvaluation](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter8/LazyEvaluation)。让我们首先设置`head`函数：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function returns `Maybe`, which either contains the underlying head of
    the list, or returns `Nothing`. To attach this to a type to use in our dot notation
    chain, we’ll need to provide a wrapper function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回`Maybe`，它要么包含列表的底层头元素，要么返回`Nothing`。为了将其附加到类型以用于我们的点符号链，我们需要提供一个包装函数：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we need to generate a slice of numbers. The `IntRange` function will
    generate a range of numbers between a lower and upper bound. Remember that when
    writing declarative code, we want to concern ourselves with the *what* and not
    the *how*. As Go does not offer this out of the box, we’ll write the generator
    function once (the *how*) and then only reuse the generator later (the *what*):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要生成一个数字切片。`IntRange`函数将生成介于下限和上限之间的数字范围。记住，在编写声明式代码时，我们想要关注的是*什么*，而不是*如何*。由于
    Go 没有提供这种功能，我们将一次性编写生成器函数（*如何*），然后只在以后重用生成器（*什么*）：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we were to write enough of these types of generators, we would ideally never
    have to write a manual loop again. Now that we have written these functions, in
    combination with `Filter` from [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101)
    and `Factorial` from [*Chapter 7*](B18771_07.xhtml#_idTextAnchor113), we can tie
    this together into our declarative solution. In our `main` function, we will first
    create an inner function that checks whether a number is larger than 10 million.
    Then, we’ll declaratively chain the steps to find the first factorial larger than
    10 million by doing the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写足够多的这种类型的生成器，我们理想情况下将永远不需要再手动编写循环。现在我们已经编写了这些函数，结合[*第6章*](B18771_06.xhtml#_idTextAnchor101)中的`Filter`和[*第7章*](B18771_07.xhtml#_idTextAnchor113)中的`Factorial`，我们可以将这些结合起来形成一个声明式解决方案。在我们的`main`函数中，我们首先创建一个内部函数，该函数检查一个数字是否大于一千万。然后，我们将通过以下方式声明性地链接步骤，以找到第一个大于一千万的阶乘：
- en: Generating a range from 0 to 100.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0生成到100的范围。
- en: Mapping each number in the range to its factorial result.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将范围内的每个数字映射到其阶乘结果。
- en: Filtering the results for being larger than 10 million.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选出大于一千万的结果。
- en: 'Returning the first element of this list:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回此列表的第一个元素：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we run this code, we get the following result – `{``39916800}`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们得到以下结果 - `{``39916800}`。
- en: 'While this is easy to read and understand, there is a pretty big drawback hiding
    underneath the implementation, due to Go’s lack of lazy evaluation. What we have
    done in the first two steps is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很容易阅读和理解，但实现中隐藏着一个相当大的缺点，这是由于 Go 缺乏惰性评估。我们在前两个步骤中所做的是如下：
- en: Generate all numbers from 0 to 100.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成从 0 到 100 的所有数字。
- en: Get their factorial result.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取它们的阶乘结果。
- en: However, the first factorial that exceeded `10_000_000` actually happened at
    value for `n=11`. This means that every subsequent number (12 to 100) was generated
    and added to the slice, and then had its factorial calculated for no reason. In
    a lazily evaluated language such as Haskell, the list would only have generated
    the values needed to find the result and then short-circuited execution.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第一个超过 `10_000_000` 的阶乘实际上发生在 `n=11` 的值上。这意味着从 12 到 100 的每个后续数字都被生成并添加到切片中，然后没有理由地计算了它的阶乘。在像
    Haskell 这样的惰性评估语言中，列表只会生成找到结果所需的价值，然后短路执行。
- en: Short-circuiting in predicates
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词中的短路
- en: There is a form of short-circuiting and lazy evaluation that happens in most
    mainstream programming languages, including Go, which is short-circuiting for
    predicates. In an `if` condition, if there are multiple conditions present such
    as `if A() && B()`, the `B` function would not be executed if `A` already returned
    `false`. Similarly, for the `if A() || B()` statement, the `B` function would
    not be executed if `A` already returned `true`. This saves on useless computation.
    (If you are writing side effect-heavy code that would have relied on the result
    of running both predicates, this can be nasty to debug. Yet another reason to
    avoid side effects.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主流编程语言，包括 Go，都存在一种短路和惰性评估的形式，这是对谓词的短路。在 `if` 条件中，如果有多个条件，例如 `if A() && B()`，如果
    `A` 已经返回 `false`，则不会执行 `B` 函数。同样，对于 `if A() || B()` 语句，如果 `A` 已经返回 `true`，则不会执行
    `B` 函数。这样可以节省不必要的计算。（如果你正在编写依赖运行两个谓词结果的副作用代码，这可能会很难调试。又是避免副作用的一个原因。）
- en: Infinite data structures and lazy evaluation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限数据结构和惰性评估
- en: Another advantage of lazy evaluation is that you can model infinite data structures,
    such as a list with all numbers from 0 to infinity. The reason that we can work
    with infinite structures in a lazily evaluated language is that you only compute
    as much data as is needed for the entire chain of operation. Go does not support
    lazy evaluation, so in this brief segue into the world of infinite data structures,
    the examples will be written in Haskell and an imaginary Go implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估的另一个优点是可以对无限数据结构进行建模，例如包含从 0 到无穷大所有数字的列表。我们之所以能够在惰性评估语言中处理无限结构，是因为你只计算整个操作链所需的数据。Go
    不支持惰性评估，因此在这个关于无限数据结构世界的简短过渡中，示例将使用 Haskell 和一个假想的 Go 实现。
- en: 'In Haskell, defining an infinite list is a simple operation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，定义一个无限列表是一个简单的操作：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So how do we work with them? Well, we need a terminating function. For lazy
    evaluation to work with infinite lists, we need to have a clear end state at which
    the list operation completes. For example, let’s create an infinite list, check
    each number to see whether it is a prime number, and stop once we have generated
    1 million prime numbers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理它们呢？嗯，我们需要一个终止函数。为了使惰性评估与无限列表一起工作，我们需要有一个清晰的结束状态，使得列表操作完成。例如，让我们创建一个无限列表，检查每个数字是否是素数，一旦我们生成了
    100 万个素数就停止。
- en: 'First, let’s create the `naturals` function, which generates all numbers from
    2 to infinity. The reason for doing so is that we don’t know exactly where to
    stop. Let’s also define what the sieve of Eratosthenes looks like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建 `naturals` 函数，它生成从 2 到无穷大的所有数字。这样做的原因是我们不知道确切在哪里停止。让我们还定义一下欧几里得筛子看起来是什么样子：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The sieve will remove (sieve out) all non-primes from the list for a given
    starting value. Next, let’s wrap these two together into a function that generates
    prime numbers by feeding the infinite list of numbers into the sieve, alongside
    a limit (`n`) for how many we want to generate:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 筛子将移除（筛选出）给定起始值列表中的所有非素数。接下来，让我们将这些两个步骤组合成一个函数，通过将无限数字列表输入到筛子中，并指定我们想要生成的数量（`n`）来生成素数：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we have our terminator function. `take n` tells us that, from the infinite
    list of data, we only want to generate however many are needed to reach `n`. Let’s
    call this in a `main` function to generate the first 1 million of them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的终止函数。`take n`告诉我们，从无限的数据列表中，我们只想生成达到`n`所需的数量。让我们在`main`函数中调用它来生成前一百方个：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code is all written in Haskell, but now let’s move back to the
    domain of the star of this book, Go. If we think about how we would achieve something
    similar in Go, the easiest way to do so is by using a `for { }` loop. And to be
    specific, I mean the *while* behavior of the loop. We loop until a condition is
    met without a postcondition to increment a value. Ignoring the prime check, we
    would probably write something akin to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码全部是用Haskell编写的，但现在让我们回到这本书的主角Go的领域。如果我们考虑如何在Go中实现类似的功能，最简单的方法是使用`for {
    }`循环。具体来说，我的意思是循环的*while*行为。我们循环直到满足条件，没有后置条件来增加值。忽略素数检查，我们可能会编写类似以下的内容：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding implementation would work, assuming we fill out the body of the
    `for` loop (which is a de facto infinite generator; if we never reach the count
    of 1 million, it will keep looping forever. In practice, it means your algorithm
    is wrong). However, in writing this code, we have given up the declarative style
    of programming. *We moved back into the domain of spelling out “how” the result
    should be reached, rather than focusing on “what” the result should be.* In an
    imaginary Go implementation, what we would want to write is the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现方法是可行的，假设我们填充了`for`循环的主体（这实际上是一个事实上的无限生成器；如果我们从未达到一百万的计数，它将永远循环。在实践中，这意味着你的算法是错误的）。然而，在编写这段代码时，我们已经放弃了声明式编程风格。*我们回到了详细说明“如何”达到结果而不是关注“结果应该是什么”的领域。*在一个假想的Go实现中，我们想要编写的代码如下：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code would be the equivalent (functional) implementation, although
    we are filtering instead of using a sieve for the sake of simplicity. This ends
    our segue into lazy evaluation and its benefits. Let’s now move on to another
    style of chaining functions together.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将是等效的（函数式）实现，尽管我们为了简单起见，是在过滤而不是使用筛子。这结束了我们对惰性评估及其益处的过渡。现在让我们转向另一种将函数链接在一起的风格。
- en: Continuation-passing style programming
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延续传递风格编程
- en: The next programming style that we will look at is **continuation-passing style**
    (**CPS**). Unlike the familiar dot notation style of method chaining, CPS is only
    possible in languages that support functions as first-class citizens. The core
    idea is that the continuation – in other words, the next step of execution – is
    another function that is passed as an argument to our original function. This
    allows us to control the flow of our program using function passing, rather than
    by branching and explicit function calls. The main benefit is that this will help
    us read and understand complex chains of functions, and we can change them with
    minimal effort. Before we dive into the Go implementation of CPS programming,
    let’s take a brief detour and explain continuations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的下一个编程风格是**延续传递风格**（**CPS**）。与熟悉的方法链点号表示法不同，CPS只能在支持函数作为一等公民的语言中实现。核心思想是延续——换句话说，执行的下一步——是另一个作为参数传递给原始函数的函数。这允许我们通过函数传递来控制程序的流程，而不是通过分支和显式函数调用。主要好处是这将帮助我们阅读和理解复杂的函数链，并且我们可以以最小的努力来更改它们。在我们深入Go的CPS编程实现之前，让我们简要地偏离一下，并解释延续的概念。
- en: What are continuations?
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延续是什么？
- en: A continuation is a somewhat abstract concept in the realm of programming languages.
    It is a function that represents the next computation of a program. It essentially
    captures the state of our program at the moment of execution (more specifically,
    the stack), and provides the next step of execution as a function that can be
    called.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言的领域中，延续（continuation）是一个相对抽象的概念。它是一个表示程序下一次计算的函数。它本质上捕捉了程序在执行时刻的状态（更具体地说，是栈），并提供了一个可以调用的执行下一步的函数。
- en: Continuations are used to implement the control flow within a programming language.
    They can be thought of as a data structure that represents our current state of
    execution and the next state of execution that we will transition into. This abstract
    concept is how programming languages can implement the control flow structures
    that are more familiar to us from day-to-day programming, such as exception handling,
    `for` loops, and goroutines.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 延续被用来在编程语言中实现控制流程。它们可以被看作是一种数据结构，它代表了我们的当前执行状态以及我们将要过渡到的下一个执行状态。这个抽象概念是编程语言如何实现我们日常编程中更熟悉的控制流程结构，例如异常处理、`for`
    循环和 goroutines 的方式。
- en: In some languages, such as Scheme, continuations are exposed to the programmer
    and can be leveraged to control the flow of execution of the program at a higher
    level of abstraction. This is equivalent to programming your own control structs
    but with the additional advantage that the continuation can be modified in place
    to take on different behavior. In Go, this is not easily achievable. One of the
    challenges in doing this in Go is that it is a statically typed language, making
    it harder to even begin to define a continuation as a data structure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，例如 Scheme，延续（continuations）被暴露给程序员，并且可以用来在更高层次上抽象地控制程序执行的流程。这相当于编程自己的控制结构，但额外的优势在于延续可以在原地修改以采取不同的行为。在
    Go 语言中，这并不容易实现。在 Go 中实现这一点的挑战之一是它是一种静态类型语言，这使得定义延续作为数据结构变得更加困难。
- en: 'The closest example that touches on continuations in Go is perhaps the `panic`
    and `recover` pattern. Imagine the following function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接近 Go 中延续的例子可能是 `panic` 和 `recover` 模式。想象以下函数：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this `main` function, we are first defining a `main` function, just before
    function exits. `defer` specifies a continuation for a function and is a special
    case in Go, in that it gets executed prior to function exit, regardless of how
    we exit the function. Inside the deferred function, we will recover if `panic`
    was encountered anywhere during the execution of the parent function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `main` 函数中，我们首先定义了一个 `main` 函数，就在函数退出之前。`defer` 指定了一个函数的延续，在 Go 中是一个特殊情况，因为它在函数退出之前执行，无论我们如何退出函数。在延迟函数内部，如果父函数的执行过程中遇到了
    `panic`，我们将从中恢复。
- en: Outside of the deferred function, we are explicitly calling `panic` after the
    first `print` statement. This is, again, an example of a continuation. There are
    a few special things happening here that might not be immediately obvious. First,
    the call to `panic` is not a simple function call. `panic` is used to signal that
    our execution stack ended up in a corrupted state, and the normal flow of execution
    is no longer possible. It captures the entire state of the stack at the moment
    `panic` was called and halts our function. However, because we have added the
    `defer` function as a continuation to `main`, `defer` gets access to this saved
    stack from `panic`. This can then display the content of the stack at the moment
    that `panic` was called, help us recover from the invalid state, and continue
    program execution without halting. In other words, our `panic` continuation is
    capturing valuable information about the state of our program and is exposing
    this to another function later on during execution. However, do remember that
    the use of `panic` is discouraged in Go.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了延迟函数（deferred function）之外，我们在第一个 `print` 语句之后明确地调用了 `panic`。这同样是一个延续的例子。这里发生了一些可能不是立即明显的事情。首先，对
    `panic` 的调用不是一个简单的函数调用。`panic` 用于表示我们的执行栈最终处于损坏状态，正常的执行流程不再可能。它捕获了 `panic` 被调用时的整个栈状态，并停止了我们的函数。然而，因为我们已经将
    `defer` 函数作为延续添加到 `main` 中，`defer` 能够从 `panic` 中访问这个保存的栈。然后，它可以在 `panic` 被调用时的那一刻显示栈的内容，帮助我们恢复到无效状态，并继续程序执行而不会停止。换句话说，我们的
    `panic` 延续正在捕获有关程序状态的宝贵信息，并在执行过程中稍后将其暴露给另一个函数。然而，请记住，在 Go 中不建议使用 `panic`。
- en: Diving in depth into continuations is beyond the scope of this book, but this
    small introduction should serve the purpose of showing that continuations, although
    not explicitly called such in Go, are still prevalent in the language itself.
    There is a form of explicit continuation that we can leverage though, and that
    is how we end up in the domain of CPS programming.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨延续超出了本书的范围，但这个小引言应该足以说明，尽管在 Go 中没有明确地称为延续，但延续在语言本身中仍然很普遍。尽管如此，我们可以利用一种显式的延续形式，这就是我们最终进入
    CPS（Continuation-Passing Style）编程领域的原因。
- en: Implementing CPS code in Go
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Go 中实现 CPS 代码
- en: 'To build an understanding of CPS, let’s first take a look at a simple example.
    Recall from the last chapter that we created a few ways to calculate the factorial
    of a number. In this example, let’s rewrite the recursive version to follow the
    CPS pattern. To enable CPS, we need to pass the continuation as an argument to
    our recursive function. The remainder of the logic for calculating the factorial
    remains the same:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解CPS（Continuation Passing Style，延续传递风格），让我们先来看一个简单的例子。回想一下上一章，我们创建了几种计算数字阶乘的方法。在这个例子中，让我们重写递归版本以遵循CPS模式。为了启用CPS，我们需要将延续作为参数传递给我们的递归函数。计算阶乘的逻辑的其他部分保持不变：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this factorial example, we are using a higher-order function, `f`, to represent
    the continuation of our recursive function call. Whereas in the recursive function
    call, we simply multiply the current input of our function by the result of the
    function call, here we are using a closure to perform the multiplication one layer
    deeper. We are saying that to continue calculating the factorial, we need to multiply
    `n` by `y`. However, `y` is not yet defined in this stack frame; it will only
    be defined in the next function call.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶乘示例中，我们使用一个高阶函数 `f` 来表示我们递归函数调用的延续。而在递归函数调用中，我们只是简单地将函数的当前输入乘以函数调用的结果，这里我们使用闭包在更深的一层进行乘法操作。我们说的是，为了继续计算阶乘，我们需要将
    `n` 乘以 `y`。然而，`y` 在这个栈帧中尚未定义；它只会在下一个函数调用中定义。
- en: 'To run this function, let’s create a main function that prints the result of
    the multiplications:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个函数，让我们创建一个主函数来打印乘法的结果：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note how, in this function, we are calling `fmt.Printf` inside the closure.
    This means that the print statement will get passed down our function call chain,
    and it will eventually be evaluated by our factorial function. This is one of
    the powers of CPS – it is making explicit what happens at lower steps of recursion,
    rather than this being hidden from the programmer. The topmost stack frame gets
    a function pushed to it, which is the `print` function, and each subsequent call
    stack gets a function pushed onto it, which is a “multiply our input with the
    input of the next call” function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这个函数中，我们在闭包内部调用 `fmt.Printf`。这意味着打印语句将沿着我们的函数调用链传递下去，最终将由我们的阶乘函数进行评估。这是CPS的一个优点——它使递归的较低步骤发生的事情变得明确，而不是让程序员看不到。最顶层的栈帧被推入一个函数，即
    `print` 函数，而每个后续的调用栈都会推入一个函数，即“将我们的输入与下一个调用的输入相乘”的函数。
- en: '![Figure 8.4: Call stack with variable functions](img/Figure_8.4_B18771.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：带有可变函数的调用栈](img/Figure_8.4_B18771.jpg)'
- en: 'Figure 8.4: Call stack with variable functions'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：带有可变函数的调用栈
- en: If we take a look at *Figure 8**.4*, we can see how there are different functions
    being pushed to different levels of our call stack. The bottommost call stack
    has a function call to `Println`, while the ones immediately above it have a function
    call to a multiplication closure. The final stack frame simply has the constant
    `n * 1`). By introducing CPS, we have effectively abstracted over the recursive
    function call and have added additional flexibility to how our program flows through
    the call stack. Whereas in a normal recursive function, each subsequent layer
    is mostly a copy of the previous layers (apart from the base case), with CPS,
    we can introduce a different behavior at each frame, depending on what we want
    to do.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 *图8**.4*，我们可以看到不同的函数被推送到我们的调用栈的不同层级。最底层的调用栈有一个 `Println` 函数调用，而上面的那些有一个乘法闭包的函数调用。最后的栈帧简单地有一个常数
    `n * 1`)。通过引入CPS，我们有效地抽象了递归函数调用，并为我们程序通过调用栈的流程增加了额外的灵活性。而在正常的递归函数中，每一层后续层主要是前一层的一个副本（除了基本情况），而使用CPS，我们可以在每个帧中引入不同的行为，具体取决于我们想要做什么。
- en: One thing to point out when we are using this mental model of call frames is
    that they are never returned. In a CPS program, you are not using `return` statements;
    rather, you are passing the continuation (next step) as a higher-order function.
    This is why our `print` statement is passed down until the final iteration is
    reached. To be explicit about it, each call frame is added to the stack but evaluation
    rolls up from the bottom – that is, our `print` statement is pushed to the frame
    above it, which pushes it to the frame above it, and so on, all the way to the
    top.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用调用栈的这种心理模型时，有一点需要注意，它们永远不会被返回。在CPS程序中，我们不使用`return`语句；相反，我们通过传递一个高阶函数作为后续步骤（下一个动作）。这就是为什么我们的`print`语句会一直传递到最终迭代。为了明确这一点，每个调用栈帧都会被添加到栈中，但评估是从底部向上滚动的——也就是说，我们的`print`语句被推送到它上面的栈帧，然后推送到更高的栈帧，以此类推，直到顶部。
- en: The function result is rolled up along the way with it. This is in contrast
    with normal recursion, where our stack frames are added similarly but evaluated
    from top to bottom. It can take a second to wrap your head around this inversion
    of evaluation flow. The reason behind this is that in each stack frame, we are
    passing closures as *input* to the next function. *However, remember that passing
    around a function as input to another function does not evaluate that function
    yet.* Hence, we are delaying the execution (as with lazy evaluation) of each function
    along the stack frame until the final frame is reached. In this case, `f(1)` is
    the final stack frame. Once we have reached this frame, all our closure functions
    are effectively evaluated. (From the last closure to the first closure, they are
    evaluated in the final frame. Hence, the `print` statement from the bottom prints
    the result of the final evaluation.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的结果在执行过程中被逐步展开，这与常规递归不同，在常规递归中，我们的栈帧是以相同的方式添加的，但评估是从顶部到底部的。理解这种评估流程的倒置可能需要一点时间。背后的原因是，在每一个栈帧中，我们都是将闭包作为*输入*传递给下一个函数。*然而，请记住，将一个函数作为输入传递给另一个函数并不会立即评估该函数。*
    因此，我们在到达最终栈帧之前延迟了每个函数的执行（就像惰性求值一样）。在这种情况下，`f(1)`是最终的栈帧。一旦我们到达这个栈帧，所有的闭包函数都会被有效地评估。（从最后一个闭包到第一个闭包，它们在最终栈帧中被评估。因此，底部的`print`语句打印出最终评估的结果。）
- en: Now that we have seen this example work with recursion, let’s look at a slightly
    more complex example where we are not actually using recursion. This is to show
    that any type of control flow can actually be modeled with CPS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了这个递归示例的工作原理，让我们看看一个稍微复杂一点的例子，在这个例子中，我们实际上并没有使用递归。这是为了表明任何类型的控制流都可以用CPS来建模。
- en: Simple mathematics operations with CPS
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CPS进行简单的数学运算
- en: 'In the preceding example, we have seen the recursive factorial calculation
    using CPS. This might lead us to believe that CPS is just an alternative way of
    writing a recursive function. And while there are certain advantages to writing
    recursive functions with CPS, it is not strictly necessary for a function to be
    recursive. Take the following example. Let’s say we start with a slice of integers
    as input. We first want to filter out the even numbers from the input. If a number
    is even, we want to double it. Finally, we want to print out the resulting integer.
    If we want to write this in CPS, we need to consider each continuation (following
    action) as a function to be passed to the original function. This, without diving
    into the details, produces the following flow of continuations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了使用CPS进行的递归阶乘计算。这可能会让我们认为CPS只是编写递归函数的另一种方式。虽然使用CPS编写递归函数确实有一些优势，但函数不一定是递归的。以下是一个例子。假设我们从一个整数切片开始。我们首先想要过滤掉输入中的偶数。如果一个数字是偶数，我们想要将其翻倍。最后，我们想要打印出结果整数。如果我们想用CPS来编写这个程序，我们需要将每个后续动作（后续步骤）视为一个要传递给原始函数的函数。不深入细节的话，这会产生以下后续动作流：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This shows us that three continuation functions are needed, along with a fourth
    function in which we will create the slice of inputs and start the chain of operations.
    Written in Go, this would produce the following result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们需要三个后续函数，以及一个第四个函数，在这个函数中我们将创建输入的切片并开始操作链。用Go语言编写，这将产生以下结果：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each of our functions, apart from `print`, performs an operation on our input
    and calls a continuation function. The continuation function will provide the
    next step in our algorithm. In the `isEven` function, the continuation is only
    called if a number matches the `i%2==0` condition, effectively making sure that
    the continuation only happens on numbers that are even. Now, when we read our
    `main` function, the entire chain of operations is spelled out:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有函数，除了`print`，都会对我们的输入执行操作并调用一个延续函数。延续函数将提供我们算法的下一步。在`isEven`函数中，只有当数字匹配`i%2==0`条件时，才会调用延续，从而确保延续只发生在偶数上。现在，当我们阅读我们的`main`函数时，整个操作链都被明确地列出来了：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'First, we create a slice of integers. Next, we call `isEven`; after that, we
    double, and finally, we print. Note that the odd thing here is that we are actually
    creating an anonymous function as input for the `isEven` continuation. In Go,
    we cannot simply write the function like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个整数切片。接下来，我们调用`isEven`；然后，我们进行加倍，最后打印。注意，这里奇怪的是，我们实际上正在创建一个匿名函数作为`isEven`延续的输入。在Go中，我们不能简单地这样写函数：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Well, we could if we changed the signature of `isEven` to take as input arguments:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我们改变`isEven`的签名，使其接受以下输入参数：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, now our `isEven` function is tied to a function that explicitly takes
    a continuation as a request. What if we simply want to print the even numbers
    and perform no further operations on them?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们的`isEven`函数绑定到一个显式接受一个延续作为请求的函数。如果我们只想打印偶数而不对它们执行任何其他操作会怎样呢？
- en: This gets to the heart of why CPS is difficult to get right in Go. The type
    system is too strict to easily manage functions in the CPS style of programming.
    We will discuss the drawbacks of CPS in more detail, but first, let’s take a look
    at a scenario where CPS can actually be a real advantage.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这触及了为什么CPS在Go中难以正确实现的核心原因。类型系统过于严格，难以轻松管理CPS编程风格的函数。我们将更详细地讨论CPS的缺点，但首先，让我们看看CPS实际上可以带来真正优势的场景。
- en: CPS and goroutines
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPS和goroutines
- en: 'One of the areas where CPS can definitely help is managing concurrent code.
    Whenever you hear about a *callback* in languages such as JavaScript, what you
    are really doing is using a continuation and passing this to an asynchronous function.
    Once the asynchronous part has been completed, the continuation (callback) is
    automatically called with the result of the asynchronous part. Often, this is
    done in the form of web requests, whereby a web request is launched, the callback
    is called when the request has been completed, and the state of the callback is
    populated with the result of the request. This result is often a status code (e.g.,
    `200`) and a payload (in the case of a `GET` request). This is such a common pattern
    nowadays that we ignore the underlying concepts, nor do we really need to understand
    them to use callbacks. However, let’s model our *double if even* function with
    callbacks and asynchronous Go code to provide an explicit example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: CPS确实可以帮助的一个领域是管理并发代码。每当你在像JavaScript这样的语言中听到关于*回调*的时候，你实际上是在使用一个延续并将其传递给一个异步函数。一旦异步部分完成，延续（回调）会自动调用，并带有异步部分的结果。通常，这是通过Web请求完成的，其中启动一个Web请求，当请求完成时调用回调，回调的状态被填充为请求的结果。这个结果通常是一个状态码（例如，`200`）和一个有效负载（在`GET`请求的情况下）。这种模式现在如此常见，以至于我们忽略了其背后的概念，而且我们实际上也不需要真正理解它们就能使用回调。然而，让我们用回调和异步Go代码来模拟我们的*如果偶数则加倍*函数，以提供一个明确的例子：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code is a slightly altered version. We are going to asynchronously
    verify whether or not a number is even, and if it is, we will print `the number
    x is even`; otherwise, we will print `the number x is odd`. The key component
    that CPS aims to simplify here is the flow-control part of an asynchronous call.
    We will launch a call with the `go` keyword, and as the continuation is encoded
    as part of the function that we are calling, we don’t have to worry about waiting
    for the result of the function call asynchronously to then launch into the next
    function. The pattern of *launch call, wait for result, continue computation*
    is often modeled as async/await operations in languages that don’t support higher-order
    functions. As Go is a multi-paradigm language, we can leverage higher-order functions
    and, thus, CPS. This allows us to focus on the *async* part without having to
    worry about the *wait and continue* part. That said, Go actually has a solid concurrency
    paradigm with goroutines and channels, so the need for this CPS-style programming
    is mostly alleviated.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是一个略微修改的版本。我们将异步验证一个数字是否为偶数，如果是，我们将打印`the number x is even`；如果不是，我们将打印`the
    number x is odd`。CPS旨在简化的关键部分是异步调用的流程控制部分。我们将使用`go`关键字启动一个调用，因为延续被编码为我们调用的函数的一部分，所以我们不需要担心异步等待函数调用的结果然后启动下一个函数。在不支持高阶函数的语言中，*启动调用，等待结果，继续计算*的模式通常被建模为async/await操作。由于Go是一种多范式语言，我们可以利用高阶函数和CPS。这使我们能够专注于*异步*部分，而不必担心*等待和继续*部分。话虽如此，Go实际上有一个基于goroutines和channels的坚实的并发范式，所以这种CPS风格的编程需求大部分得到了缓解。
- en: When to use CPS?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用CPS？
- en: For most use cases, CPS will likely make your program more complex than it’s
    worth. It’s not the easiest way of reading recursive functions, and even when
    you are used to it, it can trip you up. It is, however, used in certain spaces,
    such as compiler/interpreter design. Typically, if there is a complex control
    flow that you want to model, CPS can make this control explicit and, thus, easier
    to comprehend and read.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用例来说，CPS可能会使你的程序比它应有的复杂。这不是阅读递归函数最容易的方式，即使你习惯了它，它也可能让你出错。然而，它在某些领域，如编译器/解释器设计中被使用。通常，如果你想要模拟复杂的控制流，CPS可以使这种控制更加明确，从而更容易理解和阅读。
- en: Apart from this, another use case is the use of callbacks in asynchronous programming.
    Although we don’t often call those CPS, or even continuations, they are definitely
    a form of CPS. Due to the use of goroutines and channels, the more familiar style
    of callbacks that we find in languages such as JavaScript is a bit less common
    but, nevertheless, a useful area where we can use them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，另一个用例是在异步编程中使用回调。虽然我们并不经常调用那些CPS（Continuation-Passing Style，即延续传递风格），甚至延续，但它们确实是一种CPS的形式。由于使用了goroutines和channels，我们在像JavaScript这样的语言中找到的更熟悉的回调风格稍微少一些，但无论如何，这是一个我们可以使用它们的有用领域。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at two distinct ways of composing our functional
    code. The first way is by chaining methods in a familiar dot notation-style chaining.
    This is a way of connecting inputs and outputs of various functions without having
    an intermediate variable assignment in between. While most programmers are familiar
    with this style of programming, there is some overhead required when writing (pure)
    functional code with generics in Go.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种不同的方式来组合我们的函数式代码。第一种方式是通过熟悉的点符号链式连接方法。这是一种连接各种函数的输入和输出的方式，而不需要在它们之间进行中间变量赋值。虽然大多数程序员熟悉这种编程风格，但在Go中使用泛型编写（纯）函数式代码时，需要一些开销。
- en: Another trade-off that we discussed here is the eager versus lazy modes of function
    evaluation. While it is possible to mimic lazy evaluation in Go, the compiler
    and language don’t do any of the heavy lifting for us. This means that if we were
    to port code from a functional language such as Haskell, the performance characters
    would be significantly different.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的另一个权衡是函数评估的急切模式与懒模式。虽然在Go中可以模拟懒评估，但编译器和语言并没有为我们做任何繁重的处理。这意味着如果我们从像Haskell这样的函数式语言移植代码，性能特征将会有显著的不同。
- en: Finally, we also looked at continuations and CPS programming. A continuation
    is an abstract representation of any “next step” in an algorithm, whether it is
    a function call, a loop, or a “goto” statement. CPS programming makes the nature
    of recursive operations explicit and allows us to abstract over how function chaining
    happens. While CPS is a powerful technique, the use cases in daily life are a
    bit limited, even though we are using a lot of CPS under the hood, such as when
    modeling callback functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还探讨了延续和CPS编程。延续是对算法中任何“下一步”的抽象表示，无论是函数调用、循环还是“goto”语句。CPS编程使递归操作的本质变得明确，并允许我们抽象地处理函数链的生成。虽然CPS是一种强大的技术，但在日常生活中的应用场景相对有限，尽管我们在底层大量使用了CPS，例如在建模回调函数时。
- en: In the next chapter, we will jump one layer of abstraction higher and look at
    program composition through functional design patterns.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将提升一个抽象层次，通过功能设计模式来观察程序组合。
- en: 'Part 3: Design Patterns and Functional Programming Libraries'
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：设计模式和函数式编程库
- en: In this part, we will first move to a higher level of abstraction by looking
    at software architecture using functional programming techniques. Once again,
    we will compare how the object-oriented approach compares with the more functional
    approach. We’ll see how Go’s concurrency paradigm can be leveraged in a functional
    context. Finally, we will learn about libraries that help us in building functional
    applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将通过使用函数式编程技术来观察软件架构，从而提升到一个更高的抽象层次。我们再次比较面向对象方法与更函数式方法的差异。我们将看到Go的并发范式如何在函数式环境中得到利用。最后，我们将了解有助于我们构建函数式应用的库。
- en: 'This part has the following chapters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B18771_09.xhtml#_idTextAnchor138)*, Functional Design Patterns*'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18771_09.xhtml#_idTextAnchor138)*，函数式设计模式*'
- en: '[*Chapter 10*](B18771_10.xhtml#_idTextAnchor147)*, Concurrency and Functional
    Programming*'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18771_10.xhtml#_idTextAnchor147)*，并发与函数式编程*'
- en: '[*Chapter 11*](B18771_11.xhtml#_idTextAnchor158)*, Functional Programming Libraries*'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18771_11.xhtml#_idTextAnchor158)*，函数式编程库*'
