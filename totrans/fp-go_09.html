<html><head></head><body>
		<div id="_idContainer033">
			<h1 id="_idParaDest-138" class="chapter-number"><a id="_idTextAnchor138"/>9</h1>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/>Functional Design Patterns</h1>
			<p>In this chapter, we will move to a higher level of abstraction. Rather than talking about individual functions and operations, let’s take a look at some design patterns. While we will not extensively explain each design pattern, we will take a look at how the object-oriented pattern translates to the <span class="No-Break">functional world.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Classical design patterns in a <span class="No-Break">functional paradigm:</span><ul><li>The <span class="No-Break">strategy pattern</span></li><li>The <span class="No-Break">decorator pattern</span></li><li>The <span class="No-Break">Hollywood principle</span></li></ul></li>
				<li>Functional <span class="No-Break">design patterns</span></li>
			</ul>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor140"/>Technical requirements</h1>
			<p>In this chapter, any version at or above Go 1.18 will work for all Go-related code. Some snippets are written in Java; those will work with any version of Java <span class="No-Break">above 1.5.</span></p>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor141"/>Classical design patterns in a functional paradigm</h1>
			<p>Anyone who <a id="_idIndexMarker416"/>has programmed in an object-oriented <a id="_idIndexMarker417"/>language will encounter design patterns at some point. Design patterns are a type of cookie-cutter solution to common engineering problems. One key point is that the solution they provide should be thought of as a starting point, a way to tackle a problem that has proven itself to be useful. Often, the solution is not readily usable out of the box and needs to be adapted to your concrete environment and situation. A given design pattern might provide 90% of a solution to a problem, and the remaining 10% is filled in with custom, <span class="No-Break">non-pattern code.</span></p>
			<p>This chapter does not aim to exhaustively cover design patterns. In fact, entire books have been written about design patterns, such as the well-known <em class="italic">Gang of Four</em> book, <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>. What this chapter does aim to do is to showcase how certain object-oriented design patterns translate to the functional paradigm, and how they are often simpler to express in this paradigm. For <a id="_idIndexMarker418"/>each design pattern, we will <a id="_idIndexMarker419"/>take a look at the object-oriented implementation, the general problem and benefit of the pattern, and finally, what the functional implementation looks like. We’ll start off with the strategy pattern and continue <a id="_idIndexMarker420"/>with the decorator pattern and the <strong class="bold">Inversion of Control</strong> (<span class="No-Break"><strong class="bold">IoC</strong></span><span class="No-Break">) principle.</span></p>
			<p>These are three patterns that are common to object-oriented code. The strategy pattern is a way to change the behavior of our program at runtime and decouple a class with a concrete implementation. The decorator pattern allows us to dynamically extend functions without breaking the open-closed principle, and the IoC principle is a staple of many object-oriented frameworks, whereby the order of control is delegated to the highest level in the <span class="No-Break">call tree.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor142"/>The strategy pattern</h2>
			<p>The first pattern that we will take a look at is the strategy pattern. The strategy pattern is a <a id="_idIndexMarker421"/>design pattern that allows us to dynamically change the algorithm <a id="_idIndexMarker422"/>of a method or function at runtime. By doing this, we can modify the behavior of our program throughout its runtime. In the example that we will work out, we will have an <strong class="source-inline">EncryptionService</strong>, which supports <span class="No-Break">various ciphers.</span></p>
			<p>We’ll keep it simple and work with substitution ciphers that change the letters in the output. We will <a id="_idIndexMarker423"/>implement three different <span class="No-Break">cipher mechanisms:</span></p>
			<ul>
				<li>The <span class="No-Break">Caesar cipher</span></li>
				<li>The <span class="No-Break">Atbash cipher</span></li>
				<li>A <span class="No-Break">custom cipher</span></li>
			</ul>
			<p>Each cipher needs to support the encryption and decryption of a given string <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Input = decipher(cipher(Input))</pre>
			<p>In other <a id="_idIndexMarker424"/>words, we should be able to reconstruct the input from a ciphered <a id="_idIndexMarker425"/>output. For our implementations, we will also limit ourselves to changing the letters of the alphabet a-z, and <span class="No-Break">ignore casing.</span></p>
			<p class="callout-heading">Ciphers and security</p>
			<p class="callout">It bears calling out that these ciphers should never be used for actual encryption. They are incredibly weak and offer no real protection against a malicious actor in this day and age. They are interesting to study for their historical context and are fun to implement while being easy <span class="No-Break">to understand.</span></p>
			<h3>Object-oriented strategy pattern</h3>
			<p>First, we will <a id="_idIndexMarker426"/>solve this problem in an object-oriented way. Remember that Go is a multi-paradigm <a id="_idIndexMarker427"/>language, so we can easily apply object-oriented design patterns in Go. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> shows the architecture for <span class="No-Break">this solution:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_9.1_B18771.jpg" alt="Figure 9.1: Strategy pattern for cipher implementation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: Strategy pattern for cipher implementation</p>
			<p>In the object-oriented implementation, we start with a <strong class="source-inline">CipherService</strong>. This is any class that wants to use a cipher. Rather than having a concrete implementation, <strong class="source-inline">CipherService</strong> instead contains a <strong class="source-inline">CipherStrategy</strong> through object composition. This <strong class="source-inline">CipherStrategy</strong> is an interface that specifies the <strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong> methods. Both <a id="_idIndexMarker428"/>methods take a string as input and <a id="_idIndexMarker429"/>return either a ciphered or deciphered string. In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em>, we have three concrete implementations for <span class="No-Break">the cipher:</span></p>
			<ul>
				<li><span class="No-Break">Caesar</span></li>
				<li><span class="No-Break">Atbash</span></li>
				<li>A <span class="No-Break">custom cipher</span></li>
			</ul>
			<p>Each of these is a class (struct) that implements the required methods (<strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong>). We can also include a useful state in these classes, as we will see in the upcoming code examples, whereby we maintain a <strong class="source-inline">Rotation</strong> variable as part of the Caesar cipher. Both the Caesar cipher and the Atbash cipher are so-called substitution ciphers. They exchange one letter of the alphabet with another letter. In the case of the Caesar cipher, the replacement letter is situated a certain amount of positions further in the alphabet. For the Atbash cipher, this is a simple substitution of each letter with the letter of the same position in the reverse <span class="No-Break">alphabet (z-a).</span></p>
			<h4>Caesar</h4>
			<p>Let’s start <a id="_idIndexMarker430"/>implementing this in Go. First, we’ll <a id="_idIndexMarker431"/>set up the <strong class="source-inline">CipherService</strong>, as well as a slice containing all letters of the alphabet that we’ll support. We will also need to figure out the index of a given rune in this slice of letters, which we will do by implementing an <span class="No-Break"><strong class="source-inline">indexOf</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
var (
    alphabet [26]rune = [26]rune{'a', 'b', 'c', 'd', 'e',
    'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}
)
func indexOf(r rune, rs [26]rune) (int, bool) {
    for i := 0; i &lt; len(rs); i++ {
        if r == rs[i] {
            return i, true
        }
    }
    return -1, false
}
type CipherService struct {
    Strategy CipherStrategy
}</pre>
			<p>To follow <a id="_idIndexMarker432"/>a more traditional object-oriented language pattern, we can attach a <strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong> method to <strong class="source-inline">CipherService</strong> as well. This will just delegate <a id="_idIndexMarker433"/>the call to the chosen <span class="No-Break">implementation (</span><span class="No-Break"><strong class="source-inline">Strategy</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
func (c CipherService) Cipher(input string) string {
        return c.Strategy.Cipher(input)
}
func (c CipherService) Decipher(input string) string {
        return c.Strategy.Decipher(input)
}</pre>
			<p>After this is set up, we will also define an interface, <strong class="source-inline">CipherStrategy</strong>, which will enforce any implementation to have the <strong class="source-inline">Cipher</strong> and <span class="No-Break"><strong class="source-inline">Decipher</strong></span><span class="No-Break"> methods:</span></p>
			<pre class="source-code">
type CipherStrategy interface {
    Cipher(string) string
    Decipher(string) string
}</pre>
			<p>With this in place, we can start implementing the strategies that we will support. For brevity, we will only implement the Caesar and Atbash cipher. Implementing a custom cipher, as in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em>, would be a trivial extension of this. To implement the Caesar cipher, we will first define a struct to represent <span class="No-Break">this strategy:</span></p>
			<pre class="source-code">
type CaesarCipher struct {
    Rotation int
}</pre>
			<p>The Caesar cipher <a id="_idIndexMarker434"/>is a cipher whereby a <a id="_idIndexMarker435"/>letter in the input is exchanged for a letter a certain number of positions further in the alphabet. The number of positions that we use is defined as the <em class="italic">rotation</em> of the cipher. For example, if we have the <strong class="source-inline">abc</strong> input and a rotation of <strong class="source-inline">1</strong>, each letter is replaced with the letter 1 position further in the alphabet, so the output would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">bcd</strong></span><span class="No-Break">.</span></p>
			<p>Similarly, if the rotation were <strong class="source-inline">2</strong>, the output would be <strong class="source-inline">cde</strong>, and so on. The following is an implementation of the Caesar <strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong> methods in Go. Understanding the implementation is not that important; the important part is to note how we select which implementation <strong class="source-inline">CipherService</strong> uses and even change it during the execution of <span class="No-Break">our program:</span></p>
			<pre class="source-code">
func (c CaesarCipher) Cipher(input string) string {
        output := ""
        for _, r := range input {
                if idx, ok := indexOf(r, alphabet); ok {
                        idx += c.Rotation
                        idx = idx % 26
                        output += string(alphabet[idx])
                } else {
                        output += string(r)
                }
        }
        return output
}
func (c CaesarCipher) Decipher(input string) string {
        output := ""
        for _, r := range input {
                if idx, ok := indexOf(r, alphabet); ok {
                        idx += (26 - c.Rotation)
                        idx = idx % 26
                        output += string(alphabet[idx])
                } else {
                        output += string(r)
                }
        }
        return output
}</pre>
			<p>Now that <a id="_idIndexMarker436"/>we have the Caesar cipher implemented, let’s also implement <a id="_idIndexMarker437"/>the <span class="No-Break">Atbash cipher.</span></p>
			<h4>Atbash</h4>
			<p>The Atbash cipher <a id="_idIndexMarker438"/>is a straightforward <a id="_idIndexMarker439"/>replacement of each letter with the letter at the same index but with the alphabet in reverse. So, <strong class="source-inline">a</strong> becomes <strong class="source-inline">z</strong>, <strong class="source-inline">b</strong> becomes <strong class="source-inline">y</strong>, and on until <strong class="source-inline">z</strong> becomes <strong class="source-inline">a</strong>. As a result, deciphering can be achieved by calling the cipher again, as we are effectively mirroring the alphabet (and mirroring twice returns the <span class="No-Break">original result).</span></p>
			<p>We don’t need any real state to manage with the <strong class="source-inline">AtbashCipher</strong> struct, unlike <strong class="source-inline">CaesarCipher</strong>, where we maintained the rotation as a class variable. However, we will still need <a id="_idIndexMarker440"/>to create the struct for our <a id="_idIndexMarker441"/>strategy pattern implementation to work correctly. It will just be an empty struct with functions attached <span class="No-Break">to it:</span></p>
			<pre class="source-code">
type AtbashCipher struct {}
func (a AtbashCipher) Cipher(input string) string {
        output := ""
        for _, r := range input {
                if idx, ok := indexOf(r, alphabet); ok {
                        idx = 25 - idx
                        output += string(alphabet[idx])
                } else {
                        output += string(r)
                }
        }
        return output
}
func (a AtbashCipher) Decipher(input string) string {
        return a.Cipher(input)
}</pre>
			<p>Again, the actual implementation of the code here is not that important. It is neat that we can decipher it by just calling <strong class="source-inline">Cipher</strong> again, and this will become even more interesting in the functional example. Either way, let’s look at how we can change the implementation during execution and switch between <strong class="source-inline">CaesarCipher</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AtbashCipher</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
        svc := CipherService{}
        svc.Strategy = CaesarCipher{Rotation: 10}
        fmt.Println(svc.Cipher("helloworld"))
        svc.Strategy = AtbashCipher{}
        fmt.Println(svc.Cipher("helloworld"))
}</pre>
			<p>This is the <a id="_idIndexMarker442"/>object-oriented implementation of the strategy pattern. We have <a id="_idIndexMarker443"/>created three classes (<strong class="source-inline">CipherService</strong>, <strong class="source-inline">CaesarCipher</strong>, and <strong class="source-inline">AtbashCipher</strong>) one interface (<strong class="source-inline">CipherStrategy</strong>), and two functions per struct (to cipher and decipher). Now, let’s take a look at a <span class="No-Break">functional implementation.</span></p>
			<h3>Functional implementation of the strategy pattern</h3>
			<p>We have already seen in previous chapters how we can dynamically change the implementation <a id="_idIndexMarker444"/>details of an algorithm by leveraging the fact that functions are first-class citizens, and we can pass them around like objects in a traditional object-oriented language. If we refactored our <strong class="source-inline">CipherService</strong>, all we would need to know is that this service needs a function to take a string and return a string twice (one for ciphering and one <span class="No-Break">for deciphering).</span></p>
			<p>To start off, let’s define the struct for this new service, as well as two types to define the <strong class="source-inline">Cipher</strong> and <span class="No-Break"><strong class="source-inline">Decipher</strong></span><span class="No-Break"> functions:</span></p>
			<pre class="source-code">
type (
        CipherFunc   func(string) string
        DecipherFunc func(string) string
)
type CipherService struct {
    CipherFn   CipherFunc
    DecipherFn DecipherFunc
}
func (c CipherService) Cipher(input string) string {
    return c.CipherFn(input)
}
func (c CipherService) Decipher(input string) string {
    return c.DecipherFn(input)
}</pre>
			<p>Now that we have <strong class="source-inline">CipherService</strong> in place, we need to define our Caesar and Atbash cipher-related functions. Unlike in the object-oriented example, we don’t need to define <a id="_idIndexMarker445"/>a new struct to do so. We can define our functions in the same package as our <strong class="source-inline">CipherService</strong> but we would not have to do so. In fact, any function of the correct type can be used as a <strong class="source-inline">Cipher</strong> or <span class="No-Break"><strong class="source-inline">Decipher</strong></span><span class="No-Break"> function.</span></p>
			<p>Let’s implement <strong class="source-inline">CaesarCipher</strong> first. The one thing we do have to be aware of is that we do not have a struct that can hold the state anymore. In our example, the <strong class="source-inline">CaesarCipher</strong> struct stored <strong class="source-inline">Rotation</strong> as a class variable. In the functional approach, the rotation needs to be part of the <strong class="source-inline">CaesarCipher</strong> function itself. It’s a minor but important change. Apart from this change, the implementation remains <span class="No-Break">the same:</span></p>
			<pre class="source-code">
func CaesarCipher(input string, rotation int) string {
    output := ""
    for _, r := range input {
        idx := indexOf(r, alphabet)
        idx += rotation
        idx = idx % 26
        output += string(alphabet[idx])
    }
    return output
}
func CaesarDecipher(input string, rotation int) string {
    output := ""
    for _, r := range input {
        idx := indexOf(r, alphabet)
        idx += (26 - rotation)
        idx = idx % 26
        output += string(alphabet[idx])
    }
    return output
}</pre>
			<p>Similarly, we can implement <strong class="source-inline">AtbashCipher</strong> as a function. One nice thing here is that due to <a id="_idIndexMarker446"/>the relationship between ciphering and deciphering with Atbash, we don’t have to actually write any implementation for the <strong class="source-inline">Decipher</strong> function. Rather, we can just equate the <strong class="source-inline">Decipher</strong> function to the <span class="No-Break"><strong class="source-inline">Cipher</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func AtbashCipher(input string) string {
    output := ""
    for _, r := range input {
        if idx, ok := indexOf(r, alphabet); ok {
            idx = 25 - idx
            output += string(alphabet[idx])
        } else {
            output += string(r)
        }
    }
    return output
}
var AtbashDecipher = AtbashCipher</pre>
			<p>The last line effectively defines a new function, <strong class="source-inline">AtbashDecipher</strong>, with the same implementation as <strong class="source-inline">AtbashCipher</strong>, once again leveraging the fact that our functions are simply data, which can be stored as variables <span class="No-Break">in Go.</span></p>
			<p>When <a id="_idIndexMarker447"/>using this functional implementation in Go, we have to provide a function of the <strong class="source-inline">func(string) string</strong> type to both the <strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong> implementation of our service. As a result of <strong class="source-inline">CaesarCipher</strong> requiring an extra variable to determine the rotation, we do need to create a closure for our <strong class="source-inline">CipherService</strong>. In our <strong class="source-inline">main</strong> method, we can dynamically update the cipher that we want to use to <strong class="source-inline">AtbashCipher</strong> without the need for a closure, as the Atbash cipher is a straightforward cipher that adheres to <span class="No-Break"><strong class="source-inline">func(string) string</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
    fpSvc := {
        CipherFn: func(input string) string {
            return (input, 10)
        },
        DecipherFn: func(input string) string {
            Return fp.CaesarDecipher(input, 10)
        },
    }
    fmt.Println(fpSvc.Cipher("helloworld"))
    fpSvc.CipherFn = AtbashCipher
    fpSvc.DecipherFn = AtbashDeciphe
    fmt.Println(fpSvc.Cipher("helloworld"))
    fmt.Println(fpSvc.Decipher(fpSvc.Cipher("hello")))
}</pre>
			<p>This example prints some ciphered and deciphered content using our functional implementation. Using this functional implementation, we could easily implement ad hoc <a id="_idIndexMarker448"/>ciphers without defining them as standalone functions. Both the <strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong> implementation accept anonymous functions to specify the implementation details. This is what we have done to make the Caesar cipher work by wrapping it in such an <span class="No-Break">anonymous function.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>The decorator pattern</h2>
			<p>Let’s modify <a id="_idIndexMarker449"/>our code to also adhere to the decorator pattern. The decorator <a id="_idIndexMarker450"/>pattern is a way to add functionality to our methods and classes without having to modify them. This means that the <em class="italic">open-closed</em> part of SOLID is respected. When programming in an object-oriented fashion, this is done through function composition (and often with inheritance in languages that support this). In Go, composition is the favored way of composing structs, so the decorator pattern feels natural for both a functional and object-oriented <span class="No-Break">style implementation.</span></p>
			<p class="callout-heading">SOLID principles for object-oriented design</p>
			<p class="callout">SOLID is a <a id="_idIndexMarker451"/>set of principles for designing robust object-oriented systems. It stands for <strong class="bold">Single-Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion</strong>. These principles are good to adhere to regardless of which paradigm you use, but their implementation differs. For example, functions should have a single responsibility, be closed to modification but open to extension, and functions should rely on abstract (higher-order) functions rather than <span class="No-Break">concrete implementations.</span></p>
			<h3>Object-oriented decorator pattern</h3>
			<p>First, let’s <a id="_idIndexMarker452"/>start off by implementing the decorator pattern in an object-oriented way. We’ll <a id="_idIndexMarker453"/>extend our strategy pattern example of the various ciphers. To keep things simple, let’s just say we want to log the input to each <strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong> function. To make our program more composable, we don’t want to add the <strong class="source-inline">log</strong> function by modifying the existing <strong class="source-inline">CaesarCipher</strong> and <strong class="source-inline">AtbashCipher</strong> structs. If we were to do so, we would also have to update the <strong class="source-inline">log</strong> functionality for each struct in case the logging requirements change. Instead, what we will do is implement a <strong class="source-inline">LogCipherDecorator</strong> struct. This struct adheres to the <strong class="source-inline">CipherStrategy</strong> interface by implementing a function for both <strong class="source-inline">Cipher</strong> and <strong class="source-inline">Decipher</strong>. These functions will first write to a log and then delegate each call to the underlying <strong class="source-inline">Cipher</strong> or <strong class="source-inline">Decipher</strong> implementation. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em> shows the class diagram for <span class="No-Break">this pattern.</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_9.2_B18771.jpg" alt="Figure 9.2: Class diagram for the decorator pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Class diagram for the decorator pattern</p>
			<p>Now, we <a id="_idIndexMarker454"/>can turn <a id="_idIndexMarker455"/>this into code; let’s look at the struct definition first. We have a new <strong class="source-inline">LogCipherDecorator</strong> struct, which uses <strong class="source-inline">CipherStrategy</strong> <span class="No-Break">through composition:</span></p>
			<pre class="source-code">
type CipherLogDecorator struct {
    CipherI CipherStrategy
}</pre>
			<p>Now, we will also implement the necessary functions to have this new struct adhere to <strong class="source-inline">CipherStrategy</strong> itself. In each function, first, we will log the input prior to dispatching the call to the <span class="No-Break">underlying </span><span class="No-Break"><strong class="source-inline">CipherStrategy</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func (c CipherLogDecorator) Cipher(input string) string {
    log.Printf("ciphering: %s\n", input)
    return c.CipherI.Cipher(input)
}
func (c CipherLogDecorator) Decipher(input string) string {
    log.Printf("deciphering: %s\n", input)
    return c.CipherI.Decipher(input)
}</pre>
			<p>That is <a id="_idIndexMarker456"/>essentially all that is required to implement the decorator pattern. It comes in handy <a id="_idIndexMarker457"/>in a variety of scenarios, but it’s encountered <a id="_idIndexMarker458"/>especially often when working with <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) code (Java UI libraries such as Swing tend to use <span class="No-Break">this extensively).</span></p>
			<p>In the <strong class="source-inline">main</strong> function, we can now use <strong class="source-inline">CipherLogDecorator</strong> anywhere that we expect <strong class="source-inline">CipherStrategy</strong>. We’ll have to instantiate the decorator with the underlying class to get the <span class="No-Break">additional functionality:</span></p>
			<pre class="source-code">
func main() {
    cld := {
        CipherI: oop.CaesarCipher{Rotation: 10},
    }
    svc := oop.CipherService{Strategy: cld}
    ciphered := svc.Cipher("helloworld")
    fmt.Println(ciphered)
}</pre>
			<p>In this snippet, we can see how <strong class="source-inline">CipherService</strong> accepts <strong class="source-inline">CipherLogDecorator</strong> just like any other <strong class="source-inline">CipherService</strong>. When we run this <strong class="source-inline">main</strong> function, the log statement appears before each print statement. Running that function, we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[ec2-user@ip-172-31-29-49 Chapter9]$ go run main.go
2023/01/14 15:50:05 ciphering: helloworld
rovvygybvn</pre>
			<p>Next, let’s functionally implement this and compare the <span class="No-Break">two approaches.</span></p>
			<h3>Functional decorator pattern implementation</h3>
			<p>Applying the decorator pattern to functional programming does not require anything that <a id="_idIndexMarker459"/>we haven’t seen before in this book. We have learned about function composition and used that in previous chapters. The decorator pattern for object-oriented code really is nothing more than function composition in the functional <span class="No-Break">programming paradigm.</span></p>
			<p>As such, creating a function for adding a log statement prior to each <strong class="source-inline">cipher</strong> or <strong class="source-inline">decipher</strong> call is a matter of creating a higher-order function that takes either a <strong class="source-inline">Cipher</strong> or <strong class="source-inline">Decipher</strong> function as input, and returns a new function, which first calls <strong class="source-inline">log</strong> and then delegates the remainder of the functionality to the underlying function. Let’s make this concrete by looking at the decorating functions for ciphering and deciphering, <strong class="source-inline">LogCipher</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">LogDecipher</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func LogCipher(cipher CipherFunc) CipherFunc {
    return func(input string) string {
        log.Printf("ciphering: %s\n", input)
        return cipher(input)
    }
}
func LogDecipher(decipher DecipherFunc) DecipherFunc {
    return func(input string) string {
        log.Printf("deciphering: %s\n", input)
        return decipher(input)
    }
}</pre>
			<p>In essence, that’s all that needs to happen to decorate functions with new functionality. <strong class="source-inline">LogCipher</strong> accepts any function that adheres to the <strong class="source-inline">CipherFunc</strong> type definition and returns a new function that also adheres to that type definition. The new function, created as an anonymous function returned from <strong class="source-inline">LogCipher</strong>, then calls <strong class="source-inline">log</strong> and subsequently our <strong class="source-inline">CipherFunc</strong> that was <span class="No-Break">passed initially.</span></p>
			<p>The main difference in the implementation strategy with the object-oriented and functional paradigms is just how we define adherence to the expected functionality. With <a id="_idIndexMarker460"/>an object-oriented approach, we use interfaces to define adherence, while with the functional approach, we use the type system to <span class="No-Break">define adherence.</span></p>
			<p>In our <strong class="source-inline">main</strong> function, we can create <strong class="source-inline">CipherService</strong> using the decorator functions rather than the <span class="No-Break">underlying ciphers:</span></p>
			<pre class="source-code">
func main() {
    caesarCipher := func(input string) string {
        return CaesarCipher(input, 10)
    }
    caesarDecipher := func(input string) string {
        return CaesarDecipher(input, 10)
    }
    fpSvc := {
        CipherFn:  LogCipher(caesarCipher),
        DecipherFn: LogDecipher(caesarDecipher),
    }
    fmt.Println(fpSvc.Cipher("hello"))
}</pre>
			<p>Notice that in this example, for readability, the decorator functions are split from the creation of <strong class="source-inline">CipherService</strong>, but this could have been done in line, as in the earlier strategy pattern implementation. If we created <strong class="source-inline">CipherService</strong> with <strong class="source-inline">AtbashCipher</strong> instead, it makes for a more <span class="No-Break">readable example:</span></p>
			<pre class="source-code">
func main() {
    fpSvc := fp.CipherService{
        CipherFn:   fp.LogCipher(caesarCipher),
        DecipherFn: fp.LogDecipher(caesarDecipher),
    }
    fmt.Println(fpSvc.Cipher("hello"))
}</pre>
			<p>As <a id="_idIndexMarker461"/>we can see from the examples, function composition is the key to decorating functions with additional functionality, which can then be shared across implementations. Another advantage of what we have done so far can be described as the <em class="italic">Hollywood principle</em>, also known as the <span class="No-Break"><em class="italic">IoC</em></span><span class="No-Break"> principle.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/>The Hollywood principle</h2>
			<p>The Hollywood principle of <em class="italic">don’t call us, we’ll call you</em> is also known as the IoC principle. IoC is <a id="_idIndexMarker462"/>an abstraction of the well-known <a id="_idIndexMarker463"/>Dependency Injection pattern. Dependency Injection is an important aspect of <a id="_idIndexMarker464"/>writing object-oriented applications and is useful for the functional paradigm <span class="No-Break">as well.</span></p>
			<p>Without going too in-depth into the object-oriented implementation, the key takeaway is that objects should defer concrete implementations of their dependencies to the highest level in the object/call hierarchy. We have done this implicitly in the previous examples for our cipher implementations by leveraging interfaces rather than concrete implementations. Notice that the object-oriented <strong class="source-inline">CipherService</strong> did not specify which cipher it would use and instead, we deferred that choice to the creator of <strong class="source-inline">CipherService</strong> by just asking for an implementation of the <span class="No-Break"><strong class="source-inline">CipherStrategy</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
type CipherStrategy interface {
    Cipher(string) string
    Decipher(string) string
}
type CipherService struct {
    Strategy CipherStrategy
}</pre>
			<p>Go lends itself quite naturally to this way of programming by not having explicit constructors for structs. In a language such as Java, where objects can be instantiated with default <a id="_idIndexMarker465"/>class-level objects through <a id="_idIndexMarker466"/>object composition, it is easier to ignore programming against an abstract implementation. For example, the following Java snippet would show an implementation of a <strong class="source-inline">CipherService</strong> that does not adhere to IoC but uses a specific type of cipher (the Caesar cipher, in <span class="No-Break">this case):</span></p>
			<pre class="source-code">
class CaesarCipher {
    int rotation;
    CaesarCipher(int rotation) {
        this.rotation = rotation;
    }
}
class CipherService {
    CaesarCipher cipher = new CaesarCipher();
    CipherService() {}
    public String cipher(String input) {
        String result = "";
        // implement cipher
        return result;
    }
}</pre>
			<p>Why do we highlight this Java code here? First, to show that Go’s struct paradigm lends itself naturally to IoC by way of struct instantiation without constructors. This means that structs do not have an inherent <span class="No-Break">class state.</span></p>
			<p>This brings us to the functional implementations of services. In Go, we have two ways of making <span class="No-Break">IoC happen:</span></p>
			<ul>
				<li>The first way is through the use of interfaces, as we have done in the <span class="No-Break">object-oriented examples</span></li>
				<li>The second way is to use type definitions and functions as first-class citizens to abstract over the behavior of <span class="No-Break">a struct</span></li>
			</ul>
			<p>To illustrate <a id="_idIndexMarker467"/>the difference, the following are the two definitions <a id="_idIndexMarker468"/>of the <strong class="source-inline">CipherService</strong> that we have used, and both apply IoC in alignment with <span class="No-Break">their paradigm.</span></p>
			<p>First, let’s show the <span class="No-Break">object-oriented way:</span></p>
			<pre class="source-code">
type CipherStrategy interface {
    Cipher(string) string
    Decipher(string) string
}
type CipherService struct {
    Strategy CipherStrategy
}</pre>
			<p>And now the <span class="No-Break">functional way:</span></p>
			<pre class="source-code">
type (
    CipherFunc   func(string) string
    DecipherFunc func(string) string
)
type CipherService struct {
    CipherFn   CipherFunc
    DecipherFn DecipherFunc
}</pre>
			<p>This was just a brief segue to point out what is happening in both instances. Let’s continue our discussion of <span class="No-Break">design patterns.</span></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/>Functional design patterns</h1>
			<p>In the preceding sections of this chapter, we have compared functional and object-oriented <a id="_idIndexMarker469"/>design patterns (strategy, decorator, and Dependency Injection/IoC). If we look at the main differences between the functional and object-oriented patterns, it becomes clear that our patterns are achieved through different combinations of functions. We are either using functions as first-class citizens to store them as variables within a struct, or we are using function composition, higher-order functions, anonymous functions, and closures to achieve what would traditionally have been achieved with interfaces and the inheritance <span class="No-Break">of classes.</span></p>
			<p>And this really should be the main takeaway when writing functional code. Everything is a function. Design patterns become patterns of function combinations. As such, there is no real counterpart to the traditional design patterns outlined by the <em class="italic">Gang of Four</em> for the object-oriented world. So, what does the functional paradigm offer in terms of design patterns? Well, if we go back to the definition of design patterns, we can see that a pattern is a reusable solution to a commonly encountered problem. It is a cookie-cutter approach that might solve 85% of your problem, while the remaining 15% remains to be solved beyond the pattern. Functional programming does offer these solutions, and we discussed many of them earlier in <span class="No-Break">this book.</span></p>
			<p>When you think of function currying to compose different functions together and reducing each function to a 1-ary function to then combine them into any n-ary function, these steps can be thought of as a functional design pattern. Similarly, using closures, monads, and callbacks through CPS all can be thought of as patterns that are applied to solve a common problem. What we don’t have in functional programming is the overhead of object taxonomy, which is what the design patterns in object-oriented code reflect. You could argue that the need for design patterns in traditional object-oriented languages is more of a solution to a limitation in the programming language itself rather than a real benefit to <span class="No-Break">the programmer.</span></p>
			<p>One of the ways traditional design patterns are avoided is through the use of function composition, but an equally critical component is leveraging the type system – a type system that can assign a concrete type to a function of a specified signature. Looking at object-oriented design patterns, whether the decorator pattern, factory pattern, or visitor pattern, they leverage interfaces extensively to abstract the implementation details. In Go, we can use the type system to abstract the implementation, as we have done in the <span class="No-Break">earlier examples.</span></p>
			<p>If we summed <a id="_idIndexMarker470"/>up how to solve a particular design problem in the functional paradigm, it would be rather boring, as the problem either does not exist <a id="_idIndexMarker471"/>or is solved through functions. Our solution would just look like <span class="No-Break"><em class="italic">Table 9.1</em></span><span class="No-Break">:</span></p>
			<table id="table001-3" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Design Pattern</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Solution</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Strategy pattern</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Functions (higher-order functions + <span class="No-Break">function types)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Decorator pattern</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Function <span class="No-Break">composition (closures)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Factory pattern</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No real need, as we don’t need objects, but we could create functions with a set of default values – so, this would be <span class="No-Break">function currying</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Visitor pattern</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Functions</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Singleton pattern</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No need, as we avoid objects and <span class="No-Break">mutable state</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Adapter</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Could be seen as <span class="No-Break">function mapping</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Façade</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Functions again</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1: Design patterns and their functional solution</p>
			<p>In Go, however, we are working with a multi-paradigm language, so we get to have the best of both worlds. We can leverage some design patterns when we are working with structs, but their implementation is simplified in many ways through the use of functional programming principles rather than object-oriented ones. Despite creating an interface to abstract the implementation of a struct’s functionality, we can use a function that adheres to a given type, as we have done <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">CipherService</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor146"/>Summary</h1>
			<p>In this chapter, we took a look at the design patterns common in object-oriented code, namely the strategy pattern, the decorator pattern, and the Hollywood principle (IoC). We saw that these can be implemented in Go without the need for extensive object taxonomy simply by leveraging functions as first-class citizens. We also discussed the need for design patterns in the functional paradigm and concluded that either the patterns are not needed or can be solved using functions. In terms of real functional code that is reusable for solving common problems, we pointed at concepts such as function currying and function composition. In the next chapter, we will take a look at how functional programming can be leveraged to implement <span class="No-Break">concurrent code.</span></p>
		</div>
		<div>
			<div id="_idContainer034" class="IMG---Figure">
			</div>
		</div>
	</body></html>