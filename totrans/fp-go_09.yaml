- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will move to a higher level of abstraction. Rather than
    talking about individual functions and operations, let’s take a look at some design
    patterns. While we will not extensively explain each design pattern, we will take
    a look at how the object-oriented pattern translates to the functional world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Classical design patterns in a functional paradigm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hollywood principle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, any version at or above Go 1.18 will work for all Go-related
    code. Some snippets are written in Java; those will work with any version of Java
    above 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9).
  prefs: []
  type: TYPE_NORMAL
- en: Classical design patterns in a functional paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone who has programmed in an object-oriented language will encounter design
    patterns at some point. Design patterns are a type of cookie-cutter solution to
    common engineering problems. One key point is that the solution they provide should
    be thought of as a starting point, a way to tackle a problem that has proven itself
    to be useful. Often, the solution is not readily usable out of the box and needs
    to be adapted to your concrete environment and situation. A given design pattern
    might provide 90% of a solution to a problem, and the remaining 10% is filled
    in with custom, non-pattern code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter does not aim to exhaustively cover design patterns. In fact, entire
    books have been written about design patterns, such as the well-known *Gang of
    Four* book, *Design Patterns: Elements of Reusable Object-Oriented Software*.
    What this chapter does aim to do is to showcase how certain object-oriented design
    patterns translate to the functional paradigm, and how they are often simpler
    to express in this paradigm. For each design pattern, we will take a look at the
    object-oriented implementation, the general problem and benefit of the pattern,
    and finally, what the functional implementation looks like. We’ll start off with
    the strategy pattern and continue with the decorator pattern and the **Inversion
    of Control** (**IoC**) principle.'
  prefs: []
  type: TYPE_NORMAL
- en: These are three patterns that are common to object-oriented code. The strategy
    pattern is a way to change the behavior of our program at runtime and decouple
    a class with a concrete implementation. The decorator pattern allows us to dynamically
    extend functions without breaking the open-closed principle, and the IoC principle
    is a staple of many object-oriented frameworks, whereby the order of control is
    delegated to the highest level in the call tree.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first pattern that we will take a look at is the strategy pattern. The strategy
    pattern is a design pattern that allows us to dynamically change the algorithm
    of a method or function at runtime. By doing this, we can modify the behavior
    of our program throughout its runtime. In the example that we will work out, we
    will have an `EncryptionService`, which supports various ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll keep it simple and work with substitution ciphers that change the letters
    in the output. We will implement three different cipher mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: The Caesar cipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Atbash cipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom cipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each cipher needs to support the encryption and decryption of a given string
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In other words, we should be able to reconstruct the input from a ciphered output.
    For our implementations, we will also limit ourselves to changing the letters
    of the alphabet a-z, and ignore casing.
  prefs: []
  type: TYPE_NORMAL
- en: Ciphers and security
  prefs: []
  type: TYPE_NORMAL
- en: It bears calling out that these ciphers should never be used for actual encryption.
    They are incredibly weak and offer no real protection against a malicious actor
    in this day and age. They are interesting to study for their historical context
    and are fun to implement while being easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented strategy pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will solve this problem in an object-oriented way. Remember that
    Go is a multi-paradigm language, so we can easily apply object-oriented design
    patterns in Go. *Figure 9**.1* shows the architecture for this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Strategy pattern for cipher implementation](img/Figure_9.1_B18771.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Strategy pattern for cipher implementation'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the object-oriented implementation, we start with a `CipherService`. This
    is any class that wants to use a cipher. Rather than having a concrete implementation,
    `CipherService` instead contains a `CipherStrategy` through object composition.
    This `CipherStrategy` is an interface that specifies the `Cipher` and `Decipher`
    methods. Both methods take a string as input and return either a ciphered or deciphered
    string. In *Figure 9**.1*, we have three concrete implementations for the cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: Caesar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atbash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom cipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these is a class (struct) that implements the required methods (`Cipher`
    and `Decipher`). We can also include a useful state in these classes, as we will
    see in the upcoming code examples, whereby we maintain a `Rotation` variable as
    part of the Caesar cipher. Both the Caesar cipher and the Atbash cipher are so-called
    substitution ciphers. They exchange one letter of the alphabet with another letter.
    In the case of the Caesar cipher, the replacement letter is situated a certain
    amount of positions further in the alphabet. For the Atbash cipher, this is a
    simple substitution of each letter with the letter of the same position in the
    reverse alphabet (z-a).
  prefs: []
  type: TYPE_NORMAL
- en: Caesar
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start implementing this in Go. First, we’ll set up the `CipherService`,
    as well as a slice containing all letters of the alphabet that we’ll support.
    We will also need to figure out the index of a given rune in this slice of letters,
    which we will do by implementing an `indexOf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To follow a more traditional object-oriented language pattern, we can attach
    a `Cipher` and `Decipher` method to `CipherService` as well. This will just delegate
    the call to the chosen implementation (`Strategy`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is set up, we will also define an interface, `CipherStrategy`, which
    will enforce any implementation to have the `Cipher` and `Decipher` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can start implementing the strategies that we will support.
    For brevity, we will only implement the Caesar and Atbash cipher. Implementing
    a custom cipher, as in *Figure 9**.1*, would be a trivial extension of this. To
    implement the Caesar cipher, we will first define a struct to represent this strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Caesar cipher is a cipher whereby a letter in the input is exchanged for
    a letter a certain number of positions further in the alphabet. The number of
    positions that we use is defined as the *rotation* of the cipher. For example,
    if we have the `abc` input and a rotation of `1`, each letter is replaced with
    the letter 1 position further in the alphabet, so the output would be `bcd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if the rotation were `2`, the output would be `cde`, and so on.
    The following is an implementation of the Caesar `Cipher` and `Decipher` methods
    in Go. Understanding the implementation is not that important; the important part
    is to note how we select which implementation `CipherService` uses and even change
    it during the execution of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the Caesar cipher implemented, let’s also implement the Atbash
    cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Atbash
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Atbash cipher is a straightforward replacement of each letter with the letter
    at the same index but with the alphabet in reverse. So, `a` becomes `z`, `b` becomes
    `y`, and on until `z` becomes `a`. As a result, deciphering can be achieved by
    calling the cipher again, as we are effectively mirroring the alphabet (and mirroring
    twice returns the original result).
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t need any real state to manage with the `AtbashCipher` struct, unlike
    `CaesarCipher`, where we maintained the rotation as a class variable. However,
    we will still need to create the struct for our strategy pattern implementation
    to work correctly. It will just be an empty struct with functions attached to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the actual implementation of the code here is not that important. It
    is neat that we can decipher it by just calling `Cipher` again, and this will
    become even more interesting in the functional example. Either way, let’s look
    at how we can change the implementation during execution and switch between `CaesarCipher`
    and `AtbashCipher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the object-oriented implementation of the strategy pattern. We have
    created three classes (`CipherService`, `CaesarCipher`, and `AtbashCipher`) one
    interface (`CipherStrategy`), and two functions per struct (to cipher and decipher).
    Now, let’s take a look at a functional implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Functional implementation of the strategy pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already seen in previous chapters how we can dynamically change the
    implementation details of an algorithm by leveraging the fact that functions are
    first-class citizens, and we can pass them around like objects in a traditional
    object-oriented language. If we refactored our `CipherService`, all we would need
    to know is that this service needs a function to take a string and return a string
    twice (one for ciphering and one for deciphering).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, let’s define the struct for this new service, as well as two
    types to define the `Cipher` and `Decipher` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have `CipherService` in place, we need to define our Caesar and
    Atbash cipher-related functions. Unlike in the object-oriented example, we don’t
    need to define a new struct to do so. We can define our functions in the same
    package as our `CipherService` but we would not have to do so. In fact, any function
    of the correct type can be used as a `Cipher` or `Decipher` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement `CaesarCipher` first. The one thing we do have to be aware
    of is that we do not have a struct that can hold the state anymore. In our example,
    the `CaesarCipher` struct stored `Rotation` as a class variable. In the functional
    approach, the rotation needs to be part of the `CaesarCipher` function itself.
    It’s a minor but important change. Apart from this change, the implementation
    remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can implement `AtbashCipher` as a function. One nice thing here
    is that due to the relationship between ciphering and deciphering with Atbash,
    we don’t have to actually write any implementation for the `Decipher` function.
    Rather, we can just equate the `Decipher` function to the `Cipher` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last line effectively defines a new function, `AtbashDecipher`, with the
    same implementation as `AtbashCipher`, once again leveraging the fact that our
    functions are simply data, which can be stored as variables in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using this functional implementation in Go, we have to provide a function
    of the `func(string) string` type to both the `Cipher` and `Decipher` implementation
    of our service. As a result of `CaesarCipher` requiring an extra variable to determine
    the rotation, we do need to create a closure for our `CipherService`. In our `main`
    method, we can dynamically update the cipher that we want to use to `AtbashCipher`
    without the need for a closure, as the Atbash cipher is a straightforward cipher
    that adheres to `func(string) string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example prints some ciphered and deciphered content using our functional
    implementation. Using this functional implementation, we could easily implement
    ad hoc ciphers without defining them as standalone functions. Both the `Cipher`
    and `Decipher` implementation accept anonymous functions to specify the implementation
    details. This is what we have done to make the Caesar cipher work by wrapping
    it in such an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s modify our code to also adhere to the decorator pattern. The decorator
    pattern is a way to add functionality to our methods and classes without having
    to modify them. This means that the *open-closed* part of SOLID is respected.
    When programming in an object-oriented fashion, this is done through function
    composition (and often with inheritance in languages that support this). In Go,
    composition is the favored way of composing structs, so the decorator pattern
    feels natural for both a functional and object-oriented style implementation.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles for object-oriented design
  prefs: []
  type: TYPE_NORMAL
- en: SOLID is a set of principles for designing robust object-oriented systems. It
    stands for **Single-Responsibility, Open-Closed, Liskov Substitution, Interface
    Segregation, and Dependency Inversion**. These principles are good to adhere to
    regardless of which paradigm you use, but their implementation differs. For example,
    functions should have a single responsibility, be closed to modification but open
    to extension, and functions should rely on abstract (higher-order) functions rather
    than concrete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented decorator pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s start off by implementing the decorator pattern in an object-oriented
    way. We’ll extend our strategy pattern example of the various ciphers. To keep
    things simple, let’s just say we want to log the input to each `Cipher` and `Decipher`
    function. To make our program more composable, we don’t want to add the `log`
    function by modifying the existing `CaesarCipher` and `AtbashCipher` structs.
    If we were to do so, we would also have to update the `log` functionality for
    each struct in case the logging requirements change. Instead, what we will do
    is implement a `LogCipherDecorator` struct. This struct adheres to the `CipherStrategy`
    interface by implementing a function for both `Cipher` and `Decipher`. These functions
    will first write to a log and then delegate each call to the underlying `Cipher`
    or `Decipher` implementation. *Figure 9**.2* shows the class diagram for this
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Class diagram for the decorator pattern](img/Figure_9.2_B18771.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Class diagram for the decorator pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can turn this into code; let’s look at the struct definition first.
    We have a new `LogCipherDecorator` struct, which uses `CipherStrategy` through
    composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will also implement the necessary functions to have this new struct
    adhere to `CipherStrategy` itself. In each function, first, we will log the input
    prior to dispatching the call to the underlying `CipherStrategy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That is essentially all that is required to implement the decorator pattern.
    It comes in handy in a variety of scenarios, but it’s encountered especially often
    when working with **User Interface** (**UI**) code (Java UI libraries such as
    Swing tend to use this extensively).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` function, we can now use `CipherLogDecorator` anywhere that we
    expect `CipherStrategy`. We’ll have to instantiate the decorator with the underlying
    class to get the additional functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we can see how `CipherService` accepts `CipherLogDecorator`
    just like any other `CipherService`. When we run this `main` function, the log
    statement appears before each print statement. Running that function, we get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s functionally implement this and compare the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Functional decorator pattern implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applying the decorator pattern to functional programming does not require anything
    that we haven’t seen before in this book. We have learned about function composition
    and used that in previous chapters. The decorator pattern for object-oriented
    code really is nothing more than function composition in the functional programming
    paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, creating a function for adding a log statement prior to each `cipher`
    or `decipher` call is a matter of creating a higher-order function that takes
    either a `Cipher` or `Decipher` function as input, and returns a new function,
    which first calls `log` and then delegates the remainder of the functionality
    to the underlying function. Let’s make this concrete by looking at the decorating
    functions for ciphering and deciphering, `LogCipher` and `LogDecipher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In essence, that’s all that needs to happen to decorate functions with new functionality.
    `LogCipher` accepts any function that adheres to the `CipherFunc` type definition
    and returns a new function that also adheres to that type definition. The new
    function, created as an anonymous function returned from `LogCipher`, then calls
    `log` and subsequently our `CipherFunc` that was passed initially.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference in the implementation strategy with the object-oriented
    and functional paradigms is just how we define adherence to the expected functionality.
    With an object-oriented approach, we use interfaces to define adherence, while
    with the functional approach, we use the type system to define adherence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main` function, we can create `CipherService` using the decorator functions
    rather than the underlying ciphers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in this example, for readability, the decorator functions are split
    from the creation of `CipherService`, but this could have been done in line, as
    in the earlier strategy pattern implementation. If we created `CipherService`
    with `AtbashCipher` instead, it makes for a more readable example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the examples, function composition is the key to decorating
    functions with additional functionality, which can then be shared across implementations.
    Another advantage of what we have done so far can be described as the *Hollywood
    principle*, also known as the *IoC* principle.
  prefs: []
  type: TYPE_NORMAL
- en: The Hollywood principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hollywood principle of *don’t call us, we’ll call you* is also known as
    the IoC principle. IoC is an abstraction of the well-known Dependency Injection
    pattern. Dependency Injection is an important aspect of writing object-oriented
    applications and is useful for the functional paradigm as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going too in-depth into the object-oriented implementation, the key
    takeaway is that objects should defer concrete implementations of their dependencies
    to the highest level in the object/call hierarchy. We have done this implicitly
    in the previous examples for our cipher implementations by leveraging interfaces
    rather than concrete implementations. Notice that the object-oriented `CipherService`
    did not specify which cipher it would use and instead, we deferred that choice
    to the creator of `CipherService` by just asking for an implementation of the
    `CipherStrategy` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Go lends itself quite naturally to this way of programming by not having explicit
    constructors for structs. In a language such as Java, where objects can be instantiated
    with default class-level objects through object composition, it is easier to ignore
    programming against an abstract implementation. For example, the following Java
    snippet would show an implementation of a `CipherService` that does not adhere
    to IoC but uses a specific type of cipher (the Caesar cipher, in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Why do we highlight this Java code here? First, to show that Go’s struct paradigm
    lends itself naturally to IoC by way of struct instantiation without constructors.
    This means that structs do not have an inherent class state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the functional implementations of services. In Go, we have
    two ways of making IoC happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The first way is through the use of interfaces, as we have done in the object-oriented
    examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way is to use type definitions and functions as first-class citizens
    to abstract over the behavior of a struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the difference, the following are the two definitions of the `CipherService`
    that we have used, and both apply IoC in alignment with their paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s show the object-oriented way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the functional way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This was just a brief segue to point out what is happening in both instances.
    Let’s continue our discussion of design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Functional design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections of this chapter, we have compared functional and object-oriented
    design patterns (strategy, decorator, and Dependency Injection/IoC). If we look
    at the main differences between the functional and object-oriented patterns, it
    becomes clear that our patterns are achieved through different combinations of
    functions. We are either using functions as first-class citizens to store them
    as variables within a struct, or we are using function composition, higher-order
    functions, anonymous functions, and closures to achieve what would traditionally
    have been achieved with interfaces and the inheritance of classes.
  prefs: []
  type: TYPE_NORMAL
- en: And this really should be the main takeaway when writing functional code. Everything
    is a function. Design patterns become patterns of function combinations. As such,
    there is no real counterpart to the traditional design patterns outlined by the
    *Gang of Four* for the object-oriented world. So, what does the functional paradigm
    offer in terms of design patterns? Well, if we go back to the definition of design
    patterns, we can see that a pattern is a reusable solution to a commonly encountered
    problem. It is a cookie-cutter approach that might solve 85% of your problem,
    while the remaining 15% remains to be solved beyond the pattern. Functional programming
    does offer these solutions, and we discussed many of them earlier in this book.
  prefs: []
  type: TYPE_NORMAL
- en: When you think of function currying to compose different functions together
    and reducing each function to a 1-ary function to then combine them into any n-ary
    function, these steps can be thought of as a functional design pattern. Similarly,
    using closures, monads, and callbacks through CPS all can be thought of as patterns
    that are applied to solve a common problem. What we don’t have in functional programming
    is the overhead of object taxonomy, which is what the design patterns in object-oriented
    code reflect. You could argue that the need for design patterns in traditional
    object-oriented languages is more of a solution to a limitation in the programming
    language itself rather than a real benefit to the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways traditional design patterns are avoided is through the use of
    function composition, but an equally critical component is leveraging the type
    system – a type system that can assign a concrete type to a function of a specified
    signature. Looking at object-oriented design patterns, whether the decorator pattern,
    factory pattern, or visitor pattern, they leverage interfaces extensively to abstract
    the implementation details. In Go, we can use the type system to abstract the
    implementation, as we have done in the earlier examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we summed up how to solve a particular design problem in the functional
    paradigm, it would be rather boring, as the problem either does not exist or is
    solved through functions. Our solution would just look like *Table 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Design Pattern** | **Solution** |'
  prefs: []
  type: TYPE_TB
- en: '| Strategy pattern | Functions (higher-order functions + function types) |'
  prefs: []
  type: TYPE_TB
- en: '| Decorator pattern | Function composition (closures) |'
  prefs: []
  type: TYPE_TB
- en: '| Factory pattern | No real need, as we don’t need objects, but we could create
    functions with a set of default values – so, this would be function currying |'
  prefs: []
  type: TYPE_TB
- en: '| Visitor pattern | Functions |'
  prefs: []
  type: TYPE_TB
- en: '| Singleton pattern | No need, as we avoid objects and mutable state |'
  prefs: []
  type: TYPE_TB
- en: '| Adapter | Could be seen as function mapping |'
  prefs: []
  type: TYPE_TB
- en: '| Façade | Functions again |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: Design patterns and their functional solution'
  prefs: []
  type: TYPE_NORMAL
- en: In Go, however, we are working with a multi-paradigm language, so we get to
    have the best of both worlds. We can leverage some design patterns when we are
    working with structs, but their implementation is simplified in many ways through
    the use of functional programming principles rather than object-oriented ones.
    Despite creating an interface to abstract the implementation of a struct’s functionality,
    we can use a function that adheres to a given type, as we have done with `CipherService`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at the design patterns common in object-oriented
    code, namely the strategy pattern, the decorator pattern, and the Hollywood principle
    (IoC). We saw that these can be implemented in Go without the need for extensive
    object taxonomy simply by leveraging functions as first-class citizens. We also
    discussed the need for design patterns in the functional paradigm and concluded
    that either the patterns are not needed or can be solved using functions. In terms
    of real functional code that is reusable for solving common problems, we pointed
    at concepts such as function currying and function composition. In the next chapter,
    we will take a look at how functional programming can be leveraged to implement
    concurrent code.
  prefs: []
  type: TYPE_NORMAL
