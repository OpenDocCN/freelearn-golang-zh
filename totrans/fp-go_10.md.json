["```go\nimport (\n        \"fmt\"\n        \"io/ioutil\"\n        \"net/http\"\n)\ntype ResponseFunc func(*http.Response)\nfunc getURL(url string, onSuccess, onFailure ResponseFunc)\n    {\n        resp, err := http.Get(url)\n        if err != nil {\n                panic(err)\n        }\n        if resp.StatusCode >= 200 && resp.StatusCode < 300 {\n                onSuccess(resp)\n        } else {\n                onFailure(resp)\n        }\n}\n```", "```go\n    func main() {\n            success := func(response *http.Response) {\n                    fmt.Println(\"success\")\n                    content, err := ioutil.ReadAll\n                        (response.Body)\n                    if err != nil {\n                            panic(err)\n                    }\n                    fmt.Printf(\"%v\\n\", string(content))\n            }\n            failure := func(response *http.Response) {\n                    fmt.Printf(\"something went wrong,\n                      received: %d\\n\", response\n                        .StatusCode)\n            }\n            go getURL(\"https://news.ycombinator.com\",\n              success, failure)\n            go getURL(\"https://news.ycombinator.com/\n              ThisPageDoesNotExist\", success, failure)\n            done := make(chan bool)\n            <-done // keep main alive\n    }\n    ```", "```go\ntype Predicate[A any] func(A) bool\nfunc Filter[A any](input []A, p Predicate[A], out chan []A)\n  {\n        output := []A{}\n        for _, element := range input {\n                if p(element) {\n                        output = append(output, element)\n                }\n        }\n        out <- output\n}\n```", "```go\nfunc ConcurrentFilter[A any](input []A, p Predicate[A],\n\tbatchSize int) []A {\n\toutput := []A{}\nout := make(chan []A)\n\tthreadCount := int(math.Ceil(float64(len(input)) /\n\t\tfloat64(batchSize)))\n\tfmt.Printf(\"goroutines: %d\\n\", threadCount)\n\tfor i := 0; i < threadCount; i++ {\n\t\tfmt.Println(\"spun up thread\")\n\t\tif ((i + 1) * batchSize) < len(input) {\n\t\t\tgo Filter(input[i*batchSize:(i+1)*batchSize],  \t                     p, out)\n\t\t} else {\n\t\t\tgo Filter(input[i*batchSize:], p, out)\n\t\t}\n\t}\n\tfor i := 0; i < threadCount; i++ {\n\t\tfiltered := <-out\n\t\tfmt.Printf(\"got data: %v\\n\", filtered)\n\t\toutput = append(output, filtered...)\n\t}\n\tclose(out)\n\treturn output\n}\n```", "```go\nfunc main() {\n        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n        output := ConcurrentFilter(ints, func(i int) bool {\n           return i%2 == 0 }, 3)\n        fmt.Printf(\"%v\\n\", output)\n}\n```", "```go\ngoroutines: 4\nspun up thread\nspun up thread\nspun up thread\nspun up thread\ngot data: [10]\ngot data: [2]\ngot data: [4 6]\ngot data: [8]\n[10 2 4 6 8]\n```", "```go\n[]int{1,2,3}\n[]int{4,5,6}\n[]int{7,8,9}\n[]int{10}\n```", "```go\ntype MapFunc[A any] func(A) A\nfunc Map[A any](input []A, m MapFunc[A], out chan []A) {\n        output := make([]A, len(input))\n        for i, element := range input {\n                output[i] = m(element)\n        }\n        out <- output\n}\n```", "```go\nfunc ConcurrentMap[A any](input []A, mapFn MapFunc[A],\n    batchSize int) []A {\n        output := make([]A, 0, len(input))\n        out := make(chan []A)\n        threadCount := int(math.Ceil(float64(len(input)) /\n            float64(batchSize)))\n        fmt.Printf(\"goroutines: %d\\n\", threadCount)\n        for i := 0; i < threadCount; i++ {\n                fmt.Println(\"spun up thread\")\n                if ((i + 1) * batchSize) < len(input) {\n                        go Map(input[i*batchSize:(i+1)\n                           *batchSize], mapFn, out)\n                } else {\n                        go Map(input[i*batchSize:],\n                            mapFn, out)\n                }\n        }\n        for i := 0; i < threadCount; i++ {\n                mapped := <-out\n                fmt.Printf(\"got data: %v\\n\", mapped)\n                output = append(output, mapped...)\n        }\n        close(output)\n        return output\n}\n```", "```go\nfunc main() {\n        ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n        output := ConcurrentFilter(ints, func(i int) bool {\n            return i%2 == 0 }, 3)\n        fmt.Printf(\"%v\\n\", output)\n        output = ConcurrentMap(output, func(i int) int {\n            return i * 2 }, 2)\n        fmt.Printf(\"%v\\n\", output)\n}\n```", "```go\ngoroutines: 4\nspun up thread\nspun up thread\nspun up thread\nspun up thread\ngot data: [10]\ngot data: [2]\ngot data: [4 6]\ngot data: [8]\n[10 2 4 6 8]\n{next statements are the output for the map function}\ngoroutines: 3\nspun up thread\nspun up thread\nspun up thread\ngot data: [16]\ngot data: [20 4]\ngot data: [8 12]\n[16 20 4 8 12]\n```", "```go\nfunc FMap[A, B any](input []A, m func(A) B, out chan []B) {\n        output := make([]B, len(input))\n        for i, element := range input {\n                output[i] = m(element)\n        }\n        out <- output\n}\nfunc ConcurrentFMap[A, B any](input []A, fMapFn ,\n    batchSize int) []B {\n        output := make([]B, 0, len(input)\n        out := make(chan []B)\n        threadCount := int(math.Ceil(float64(len(input)) /\n            float64(batchSize)))\n        fmt.Printf(\"goroutines: %d\\n\", threadCount)\n        for i := 0; i < threadCount; i++ {\n                fmt.Println(\"spun up thread\")\n                if ((i + 1) * batchSize) < len(input) {\n                        go FMap(input[i*batchSize:\n                           (i+1)*batchSize], fMapFn, out)\n                } else {\n                        go FMap(input[i*batchSize:],\n                            fMapFn, out)\n                }\n        }\n        for i := 0; i < threadCount; i++ {\n                mapped := <-out\n                fmt.Printf(\"got data: %v\\n\", mapped)\n                output = append(output, mapped...)\n        }\n        return output\n}\n```", "```go\nfunc ConcurrentRunner(input []Input, fn func(), batchSize\n  int) []Output {\n     // set up channels and batch logic\n     for batch in batches {\n         go Run(fn(batch))\n     }\n     // collect output and return\n}\n```", "```go\ncat main.go | grep \"func\" | wc -l | awk '{print \"lines: \"\n  $1}'\n```", "```go\nfunc FilterNode[A any](in <-chan A, predicate Predicate[A])\n  <-chan A {\n        out := make(chan A)\n        go func() {\n                for n := range in {\n                        if predicate(n) {\n.                                out <- n\n                        }\n                }\n                close(out)\n        }()\n        return out\n}\n```", "```go\nfunc MapNode[A any](in <-chan A, mapf MapFunc[A]) <-chan A\n  {\n        out := make(chan A)\n        go func() {\n                for n := range in {\n                        out <- mapf(n)\n                }\n                close(out)\n        }()\n        return out\n}\n```", "```go\nfunc Generator[A any](input ...A) <-chan A {\n        out := make(chan A)\n        go func() {\n                for _, element := range input {\n                        out <- element\n                }\n                close(out)\n        }()\n        return out\n}\n```", "```go\nfunc Cat(filepath string) <-chan string {\n        out := make(chan string)\n        f, err := ioutil.ReadFile(filepath)\n        if err != nil {\n                panic(err)\n        }\n        go func() {\n                lines := strings.Split(string(f), \"\\n\")\n                for _, line := range lines {\n                        out <- line\n                }\n                close(out)\n        }()\n        return out\n}\n```", "```go\nfunc Collector[A any](in <-chan A) []A {\n        output := []A{}\n        for n := range in {\n                output = append(output, n)\n        }\n        return output\n}\n```", "```go\nfunc main(){\n        generated := Generator(1, 2, 3, 4)\n        filtered := FilterNode(generated, func(i int) bool\n            { return i%2 == 0 })\n        mapped := MapNode(filtered, func(i int) int {\n            return i * 2 })\n        collected := Collector(mapped)\n        fmt.Printf(\"%v\\n\", collected)\n}\n```", "```go\n[4 8]\n```", "```go\n        out := pkg.ChainPipes(generated,\n                pkg.CurriedFilterNode(func(i int) bool { return i%2 == 0 }),\n                pkg.CurriedMapNode(func(i int) int { return\n                    i * i }))\n```", "```go\ntype (\n        Node[A any]          func(<-chan A) <-chan A\n        GeneratorNode[A any] func() <-chan A\n        CollectorNode[A any] func(<-chan A) []A\n)\n```", "```go\nfunc ChainPipes[A any](in <-chan A, nodes ...Node[A]) []A {\n        for _, node := range nodes {\n                in = node(in)\n        }\n        return Collector(in)\n}\n```", "```go\nfunc FilterNode[A any](in <-chan A, predicate Predicate[A])\n  <-chan A\nfunc MapNode[A any](in <-chan A, mapf MapFunc[A]) <-chan A\n```", "```go\nfunc CurriedFilterNode[A any](p Predicate[A]) Node[A] {\n        return func(in <-chan A) <-chan A {\n                out := make(chan A)\n                go func() {\n                        for n := range in {\n                                if p(n) {\n                                        out <- n\n                                }\n                        }\n                        close(out)\n                }()\n                return out\n        }\n}\nfunc CurriedMapNode[A any](mapFn MapFunc[A]) Node[A] {\n        return func(in <-chan A) <-chan A {\n                out := make(chan A)\n                go func() {\n                        for n := range in {\n                                out <- mapFn(n)\n                        }\n                        close(out)\n                }()\n                return out\n        }\n}\n```", "```go\npkg.CurriedFilterNode(func(i int) bool { return i%2 == 0 }}\n```", "```go\n        for _, node := range nodes {\n                in = node(in)\n        }\n```", "```go\nfunc ChainPipes[A any](gn GeneratorNode[A], nodes\n  ...Node[A]) []A {\n        in := gn()\n        for _, node := range nodes {\n                in = node(in)\n        }\n        return Collector(in)\n}\n```", "```go\nfunc CurriedCat(filepath string) func() <-chan string {\n        return func() <-chan string {\n                out := make(chan string)\n                f, err := ioutil.ReadFile(filepath)\n                if err != nil {\n                        panic(err)\n                }\n                go func() {\n                        lines := strings.Split(string(f),\n                            \"\\n\")\n                        for _, line := range lines {\n                                out <- line\n                        }\n                        close(out)\n                }()\n                return out\n        }\n}\n```", "```go\nfunc main() {\n        out := ChainPipes[string](CurriedCat(\"./main.go\"),\n                CurriedFilterNode(func(s string) bool {\n                    return strings.Contains(s, \"func\") }),\n                CurriedMapNode(func(i string) string {\n                    return \"line contains func: \" + i }))\n        fmt.Printf(\"%v\\n\", out2)\n}\n```"]