- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Concurrency and Functional Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与函数式编程
- en: Concurrency is all around us, both in the real world as well as the virtual
    one. Humans can easily multitask (although we might not do a good job at either
    task). It’s entirely possible to drink a cup of coffee while you are reading this
    chapter or to run while listening to a podcast. For machines, concurrency is a
    complex undertaking, although a lot of that complexity can be hidden away by the
    programming language we choose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 并发无处不在，无论是在现实世界还是在虚拟世界中。人类可以轻松地多任务处理（尽管我们可能两个任务都做不好）。在你阅读本章的同时喝一杯咖啡或者边听播客边跑步是完全可能的。对于机器来说，并发是一个复杂的任务，尽管我们可以通过选择编程语言来隐藏很多这种复杂性。
- en: Go was built to be a language with all the necessary tools a modern-day software
    engineer needs. As we are now in a world where CPU power is abundant for most
    intents and purposes, it’s only natural that concurrency was a main concern when
    developing the language, rather than having to bolt it on later. In this chapter,
    we are going to take a look at how functional programming can help with concurrency
    and, conversely, how concurrency can help with functional programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言被设计成一种包含现代软件工程师所需所有工具的语言。鉴于我们现在生活在一个CPU能力在大多数情况下都很充足的世界，当开发这门语言时，并发自然成为了一个主要关注点，而不是后来不得不添加上去。在本章中，我们将探讨函数式编程如何帮助处理并发，以及反过来，并发如何帮助函数式编程。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why functional programming helps us write concurrent code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么函数式编程有助于我们编写并发代码
- en: How to create concurrent functions (Filter, Map, and so on)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建并发函数（过滤、映射等）
- en: How to chain functions together concurrently using the pipeline pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用管道模式并发地链接函数
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you can use any version of Go at or above version 1.18\. All
    the code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter10](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你可以使用Go语言1.18或更高版本。本章的所有代码都可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter10](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter10)。
- en: Functional programming and concurrency
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程与并发
- en: We have already hinted at it throughout this book, but the ideas behind functional
    programming can help us write concurrent code. Typically, thinking about concurrency
    is a bit of a headache, even when a language has modern tools to support it, such
    as goroutines and channels. Before we dive too deep into this material, let’s
    first take a small detour as a refresher on what exactly we mean when we talk
    about concurrent code, and how it compares to parallelism and distributed computing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在整本书中暗示了这一点，但函数式编程背后的思想可以帮助我们编写并发代码。通常，即使有goroutines和channels等现代工具支持，思考并发也会让人头疼。在我们深入探讨这个材料之前，让我们先稍微偏离一下，作为一个复习，来明确当我们谈论并发代码时我们到底指的是什么，以及它与并行和分布式计算有何不同。
- en: Concurrency, parallelism, and distributed computing
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发、并行和分布式计算
- en: The terms *concurrency*, *parallelism*, and *distributed computing* are, at
    times, used interchangeably. And while they are related, they are not exactly
    the same thing. Let’s just point out what we mean by concurrency first. **Concurrency**
    is what happens when our program can execute multiple tasks at the same time.
    For example, when we are playing a video game, typically a thread is playing audio,
    another one is processing input from the player, and another one is taking care
    of the internal game logic, updating the game state and performing the main game
    loop.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，“并发”、“并行”和“分布式计算”这些术语会被互换使用。虽然它们是相关的，但它们并不完全相同。让我们首先指出我们所说的“并发”是什么意思。**并发**是指我们的程序可以同时执行多个任务的情况。例如，当我们玩游戏时，通常有一个线程播放音频，另一个处理玩家的输入，还有一个处理游戏内部逻辑，更新游戏状态并执行主游戏循环。
- en: Video games have been around for a long time, and a game such as *DOOM* works
    in this way. It’s also safe to say that people were not playing this on a computer
    with multiple cores available back in 1995\. In other words, it’s possible for
    a single core to manage the execution of these distinct tasks and give the appearance
    of executing them at the same time. Exactly how this is done is beyond the scope
    of this book, but as a takeaway, just remember that the concurrency that we will
    mainly focus on is concurrency as defined previously – not the simultaneous execution
    of code, but the concurrent execution of code. One thing to note, though, is that
    concurrency can happen across multiple cores, or pipelines, as well. However,
    to keep things simple, we can imagine concurrency using a single core.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 电子游戏已经存在很长时间了，像 *DOOM* 这样的游戏就是以这种方式运行的。也可以说，在1995年，人们并没有在拥有多个核心的电脑上玩这样的游戏。换句话说，单个核心可以管理这些不同任务的执行，并给人一种同时执行这些任务的外观。确切地说，这是如何做到的，超出了本书的范围，但作为总结，只需记住，我们将主要关注的并发性，是之前定义的并发性——不是代码的同时执行，而是代码的并发执行。不过，有一点需要注意，并发可以发生在多个核心或流水线上。然而，为了简化问题，我们可以想象使用单个核心的并发。
- en: This brings us to the second term, **parallelism**. When we talk about a program
    executing in parallel, this means that multiple cores are performing a task simultaneously.
    You can not have parallelism without a physical means to run two tasks at the
    same time. The native Go mechanisms of channels and goroutines are focused on
    concurrency and not parallelism. This is an important distinction between the
    two. However, Go still lends itself to building out parallel algorithms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了第二个术语，**并行性**。当我们谈论一个程序并行执行时，这意味着多个核心正在同时执行一个任务。没有物理手段同时运行两个任务，就无法实现并行性。Go的本地机制，如通道和goroutines，专注于并发而不是并行。这是两者之间的重要区别。然而，Go仍然适合构建并行算法。
- en: 'To get an idea of what this looks like, there are a few packages available
    for Go that offer parallel solutions, such as the ExaScience Pargo package: [https://github.com/ExaScience/pargo](https://github.com/ExaScience/pargo).
    At the time of writing, this package is written in a pre-generics fashion, so
    do bear that in mind when looking through the code. In *Figure 10**.1*, the difference
    between concurrency and parallelism is highlighted by how the tasks get executed.
    Notably, the two tasks in the concurrent model are broken into multiple chunks,
    and each gets assigned CPU time in an alternating fashion.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这看起来是什么样子，有几个Go包提供了并行解决方案，例如ExaScience的Pargo包：[https://github.com/ExaScience/pargo](https://github.com/ExaScience/pargo)。在撰写本文时，这个包是以预泛型的方式编写的，所以在查看代码时请记住这一点。在
    *图10*.1中，通过任务执行方式突出了并发和并行之间的区别。值得注意的是，在并发模型中，两个任务被分割成多个部分，并且每个部分交替分配CPU时间。
- en: '![Figure 10.1: Concurrent (above) versus parallel (below) execution](img/Figure_10.1_B18771.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：并发（上方）与并行（下方）执行对比](img/Figure_10.1_B18771.jpg)'
- en: 'Figure 10.1: Concurrent (above) versus parallel (below) execution'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：并发（上方）与并行（下方）执行对比
- en: Finally, we have **distributed computing**. While concurrency is part of distributed
    computing, it is not the only requirement for this. Distributed computation does
    imply spreading out computational tasks over multiple machines, in which sense
    it is concurrent, but there’s more overhead than with typically concurrent or
    parallel applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 **分布式计算**。虽然并发是分布式计算的一部分，但这并不是唯一的要求。分布式计算确实意味着将计算任务分散到多台机器上，从这个意义上讲，它是并发的，但与通常的并发或并行应用程序相比，它有更多的开销。
- en: 'In distributed systems, you need to have mechanisms for fault tolerance (what
    if one node in the network becomes unavailable?) and mechanisms for dealing with
    the network (unreliable or insecure networks). So, while people might talk about
    distributed computation as an example of concurrency, concurrency only gives you
    the bare minimum required. The physical infrastructure and myriad of difficulties
    in making a distributed system work are beyond the scope of this book. One thing
    to take away is that Go is a language that can be used to write distributed systems.
    In fact, the use of goroutines and channels might help you build out the underlying
    infrastructure needed for distributed systems, but you’ll need more than the basic
    functionality of the language. If you want to learn more about distributed computing
    with Go, the book *Distributed Computing with Go* is a good place to start: [https://www.packtpub.com/product/distributed-computing-with-go/9781787125384?_ga=2.217817046.1391922680.1675144438-1944326834.1674539572](https://www.packtpub.com/product/distributed-computing-with-go/9781787125384?_ga=2.217817046.1391922680.1675144438-1944326834.1674539572).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，你需要有容错机制（如果网络中的一个节点变得不可用怎么办？）以及处理网络的机制（不可靠或不安全的网络）。因此，尽管人们可能会将分布式计算作为并发的例子来讨论，但并发只提供了所需的最基本功能。物理基础设施以及使分布式系统正常工作的无数困难超出了本书的范围。有一点需要记住的是，Go是一种可以用来编写分布式系统的语言。事实上，goroutines和channels的使用可能有助于构建分布式系统所需的基础设施，但你将需要比语言的基本功能更多。如果你想学习更多关于使用Go进行分布式计算的知识，那么《使用Go进行分布式计算》这本书是一个很好的起点：[https://www.packtpub.com/product/distributed-computing-with-go/9781787125384?_ga=2.217817046.1391922680.1675144438-1944326834.1674539572](https://www.packtpub.com/product/distributed-computing-with-go/9781787125384?_ga=2.217817046.1391922680.1675144438-1944326834.1674539572)。
- en: 'In this chapter, we will focus on concurrency only, and we won’t zoom in on
    parallelism or distributed computing. However, why do we want our code to be concurrent?
    There are a few clear advantages that this can bring:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只关注并发，而不会深入探讨并行化或分布式计算。然而，为什么我们想让我们的代码并发执行呢？这可以带来一些明显的优势：
- en: '**Higher responsiveness**: A program does not need to wait for a single long-running
    task to complete before starting another one'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的响应性**：一个程序不需要等待单个长时间运行的任务完成后再开始另一个任务'
- en: '**Higher performance**: If we can chunk out a heavy workload and perform this
    over multiple threads (and Go might schedule these across multiple cores to get
    a form of parallelism as well), this will reduce the time it takes to complete
    the operation'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的性能**：如果我们能够将繁重的工作量分成几块，并在多个线程上执行（Go可能会将这些线程调度到多个核心以获得并行性），这将减少完成操作所需的时间'
- en: Functional programming and concurrency
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程与并发
- en: 'I’ve made the claim before in this book that functional programming makes it
    easier to write concurrent code, but this claim needs to be tailored a little
    bit further. When talking about how functional programming makes concurrency easier,
    we are talking about the stricter subset of functional programming called “pure”
    functional programming. Pure functional programming gives us a few key features
    that make reasoning about concurrent execution easier and our code less error-prone.
    These are the main features responsible for this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中之前已经提出过，函数式编程使得编写并发代码更容易，但这个说法需要进一步细化。当我们谈论函数式编程如何使并发更容易时，我们是在谈论函数式编程的更严格子集，即“纯”函数式编程。纯函数式编程为我们提供了一些关键特性，使得推理并发执行更容易，并且我们的代码更不容易出错。这些是负责这一点的最主要特性：
- en: Immutable variables and state
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变变量和状态
- en: Pure functions (no side effects)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数（无副作用）
- en: Referential transparency
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Lazy evaluation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Composability
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可组合性
- en: For the rest of this chapter, when talking about functional programming, the
    assumption can be made that we’re talking strictly about pure functional programming.
    Let’s focus on each of these features and explain why they make for safer concurrent
    code, or make our code at least easier to reason about. The result is that when
    our code is easier to understand, it should help us reduce the number of bugs
    in it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，当我们谈论函数式编程时，可以假设我们严格指的是纯函数式编程。让我们分别关注这些特性，并解释为什么它们使得编写安全的并发代码更容易，或者至少使得我们的代码更容易推理。结果是，当我们的代码更容易理解时，它应该有助于我们减少其中的错误数量。
- en: Immutable variables and state
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变变量和状态
- en: When working in an object-oriented model, objects typically hold an internal
    state. If this state is allowed to mutate, then the state that two threads are
    working on might diverge. By not allowing the state to change, even if operating
    on the same data sources (or, rather, copies of the same data), our functions
    can execute independently of each other without ever messing with the shared memory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当在面向对象模型中工作时，对象通常持有内部状态。如果允许这种状态发生改变，那么两个线程正在处理的状态可能会发生分歧。通过不允许状态改变，即使操作相同的数据源（或者更确切地说，相同数据的副本），我们的函数可以独立执行，而不会干扰共享内存。
- en: In Go, if we do want to use structs, there are some pitfalls, which we discussed
    in earlier chapters. By avoiding the use of pointers, we can avoid the main causes
    of mutation in structs. When writing pure functional code, each individual component
    of our code needs to be immutable. When each component is immutable, we can more
    safely execute functions concurrently.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，如果我们想使用结构体，有一些陷阱，我们已经在前面的章节中讨论过了。通过避免使用指针，我们可以避免结构体中突变的主要原因。在编写纯函数式代码时，我们代码的每个单独组件都需要是不可变的。当每个组件都是不可变的时候，我们可以更安全地并发执行函数。
- en: Another issue we avoid by having immutable variables and states is that of resource
    contention. If we have a single true resource (a singleton in an object-oriented
    model), then this resource might be locked by thread A, causing thread B to wait
    until the resource is freed up before it can be used. Typically, this is implemented
    through a resource-locking mechanism (thread A locks the resource , *X*, performs
    operations while other threads wait for resource *X*, and then finally removes
    the lock when it is done operating). In a purely functional world, we would not
    need such singleton operations, partly due to our immutable state and partly due
    to the other benefits, such as pure functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不可变变量和状态，我们还可以避免资源竞争的问题。如果我们有一个真正的单一资源（面向对象模型中的单例），那么这个资源可能会被线程A锁定，导致线程B在资源被释放之前必须等待才能使用。通常，这是通过资源锁定机制实现的（线程A锁定资源
    *X*，在其它线程等待资源 *X* 的同时执行操作，然后完成操作后最终移除锁）。在纯函数式世界中，我们不需要这样的单例操作，部分原因是我们的不可变状态，部分原因是其他好处，比如纯函数。
- en: Pure functions
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯函数
- en: As we saw in [*Chapter 4*](B18771_04.xhtml#_idTextAnchor060), a function is
    considered pure when it does not produce any side effects and does not interact
    with the outside world. In this book, we implemented many functions that are common
    to functional programming. All of these were written in the pure functional style
    (although remember that pure functional is a subset of functional programming
    and not strictly required). The benefits here relate to the immutable state but
    extend beyond it as well. If our functions do not depend on the program state,
    then anything modifying the state of our program cannot disrupt our function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](B18771_04.xhtml#_idTextAnchor060)中看到的，一个函数被认为是没有产生任何副作用并且不与外界交互时是纯函数。在这本书中，我们实现了许多函数，这些函数是函数式编程中常见的。所有这些都是在纯函数式风格下编写的（尽管请记住，纯函数式是函数式编程的一个子集，并不是严格必需的）。这里的优势与不可变状态相关，但也超出了它。如果我们的函数不依赖于程序状态，那么任何修改我们程序状态的操作都不能干扰我们的函数。
- en: Beyond this, it also eliminates another class of problems. If our functions
    were allowed to mutate state, or our system, the order of operations would matter.
    For example, imagine that we were to write a concurrent function that appends
    content to a file. Writing to a file is a clear case of a side effect, but in
    a concurrent application, the content of our file would now depend on the order
    in which our threads are executed. This breaks the determinism of our application
    and, furthermore, would likely lead to a file that is not exactly what we desired.
    In an object-oriented model, this is again resolved through locking. In a purely
    functional language, the “impure” functions would be handled by monads. Go is
    not purely functional, but later in this chapter, we will look at the pipeline
    pattern through which we can model the data flow and control the side effects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还消除了另一类问题。如果我们的函数被允许改变状态或系统，操作顺序就会变得重要。例如，想象一下，如果我们编写一个并发函数来向文件追加内容。向文件写入是一个明显的副作用案例，但在并发应用程序中，我们的文件内容现在将取决于我们的线程执行的顺序。这破坏了应用程序的确定性，并且还可能导致一个与我们期望不完全一致的文件。在面向对象模型中，这同样通过锁定来解决。在纯函数式语言中，“不纯”的函数将由monads处理。Go语言不是纯函数式语言，但在这章的后面，我们将通过管道模式来查看如何建模数据流和控制副作用。
- en: Referential transparency
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用透明性
- en: '**Referential transparency** means that we can replace a function call with
    its result, without changing the result of our computation. We covered this in
    more detail in [*Chapter 2*](B18771_02.xhtml#_idTextAnchor028), but for concurrency,
    the important aspect is that if all our calls are referentially transparent, it
    does not matter when exactly a call is resolved (ahead of time or just in time).
    This means that when we chunk our code out into concurrent functions, it is safe
    to resolve certain function calls ahead of time in a concurrent fashion.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用透明性**意味着我们可以用函数的结果替换函数调用，而不会改变我们计算的结果。我们在[*第二章*](B18771_02.xhtml#_idTextAnchor028)中更详细地介绍了这一点，但对于并发，重要的方面是如果所有我们的调用都是引用透明的，那么调用解决的确切时间（提前或即时）并不重要。这意味着当我们把代码分成并发函数时，在并发方式中提前解决某些函数调用是安全的。'
- en: Lazy evaluation
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 惰性评估
- en: '`GET` request to a URL. We will use two callbacks, which will be lazily evaluated.
    The first callback will be resolved only if the `GET` request completed successfully,
    while the second callback will be resolved if the `GET` request failed. Note that
    here we mean the `GET` request itself did work, but we received a response code
    that is not in the `200` range:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对URL的`GET`请求。我们将使用两个回调，这些回调将被惰性评估。第一个回调只有在`GET`请求成功完成时才会解决，而第二个回调将在`GET`请求失败时解决。请注意，这里我们指的是`GET`请求本身确实工作，但我们收到了不在`200`范围内的响应代码：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we can see that `getURL` requires a string representing
    a URL to resolve, as well as two functions. Both functions have the same `ResponseFunc`
    type, which is a function with the `func(*http.Response)` signature.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到`getURL`需要一个表示要解析的URL的字符串，以及两个函数。这两个函数都有相同的`ResponseFunc`类型，它是一个具有`func(*http.Response)`签名的函数。
- en: 'Next, we can write a `main` function in which we call `getURL` and provide
    two callbacks:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以编写一个`main`函数，在其中调用`getURL`并提供两个回调：
- en: The first callback, `onSuccess`, will be executed if our `GET` request returns
    a status code in the `200` range; this function will simply print out the content
    of the response body.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次回调，`onSuccess`，将在我们的`GET`请求返回`200`范围内的状态码时执行；这个函数将简单地打印出响应体的内容。
- en: 'The second callback, `onFailure`, will simply print an error message along
    with the corresponding status code that our response received. We’ll call `getURL`
    twice, once with a valid URL and once with an invalid URL. However, instead of
    running this code synchronously, we will make the calls to `getURL` on separate
    goroutines by prefixing each call with `go`. This means we don’t know which call
    will complete first, but as we are using lazy functions (a type of continuation-passing
    style programming), we don’t have to orchestrate the control flow of our program.
    The correct callback will execute when its time comes. The callback, which is
    not necessary, will never be evaluated, so we avoid potentially expensive computation
    when it is not necessary:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次回调，`onFailure`，将简单地打印出错误消息以及我们收到的相应状态码。我们将调用`getURL`两次，一次是有效的URL，一次是无效的URL。然而，我们不会同步运行此代码，而是通过在每个调用前加上`go`前缀，在单独的goroutines上调用`getURL`。这意味着我们不知道哪个调用会先完成，但因为我们使用的是惰性函数（一种传递继续风格的编程），所以我们不需要编排我们程序的流程控制。正确回调将在其时间到来时执行。不必要的回调将永远不会被评估，因此我们避免了在不必要的情况下进行可能昂贵的计算：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, our `GET` requests complete asynchronously and then
    call the corresponding callback, as defined in the `getURL` function. One interesting
    bit of code is near the end of our main snippet. We have created a `bool` channel,
    and then we are reading from this channel without ever writing to it. This essentially
    keeps our application alive. If we didn’t have these two statements, our `main`
    function would likely exit and thus terminate our program, before our goroutines
    completed their computation. In a real-world application, you could also keep
    waiting for the threads to resolve using `waitgroup`. If you are stuck after running
    this from a terminal, press *Ctrl* + *C* to kill the process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们的`GET`请求异步完成，然后调用在`getURL`函数中定义的相应回调。在主代码片段的末尾有一个有趣的代码片段。我们创建了一个`bool`通道，然后我们从未向其中写入过。这实际上使我们的应用程序保持活跃。如果我们没有这两条语句，我们的`main`函数可能会退出，从而在goroutines完成计算之前终止我们的程序。在实际应用中，您也可以使用`waitgroup`等待线程解决。如果您在终端运行此代码后卡住了，请按*Ctrl*
    + *C*来终止进程。
- en: Lazy evaluation will show up again later in this chapter when we take a look
    at implementing functional pipes. However, we’ll be looking at it more through
    a direct lens of concurrent applications, rather than the callback mechanisms
    that we saw here.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值将在本章后面当我们查看实现函数管道时再次出现。然而，我们将更多地从并发应用程序的直接视角来探讨它，而不是我们在这里看到的回调机制。
- en: Threads versus goroutines
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 线程与goroutine
- en: While the terms *thread* and *goroutine* are often used interchangeably, they
    are distinct things. Goroutines are a construct in Go, built to leverage executing
    tasks concurrently. They are managed by the Go runtime, are lightweight and fast
    to start and execute, and have a built-in communication medium (channels). Threads,
    on the other hand, are implemented at the hardware level and are managed by the
    operating system. They are slower to spin up, have no communication medium built
    in, and are hardware-dependent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*线程*和*goroutine*这两个术语经常被互换使用，但它们是不同的事物。Goroutines是Go语言中的一个结构，旨在利用并发执行任务。它们由Go运行时管理，轻量级且启动和执行速度快，并且内置了通信介质（通道）。另一方面，线程在硬件级别实现，由操作系统管理。它们启动较慢，没有内置的通信介质，并且依赖于硬件。
- en: Composability
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可组合性
- en: Functions are composable in a myriad of ways. This allows us to define the building
    blocks of our application and then chain them together to solve our concrete problem.
    As each block is independent of one another, we can build concurrency layers in
    between them. This will be the focus in the last part of this chapter when we
    will create functional pipes that can run concurrently. However, before we get
    there, let’s take a look at making our functions internally concurrent.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过无数种方式组合。这使我们能够定义应用程序的构建块，然后将它们链接起来以解决具体问题。由于每个块都是相互独立的，我们可以在它们之间构建并发层。这将是本章最后部分的重点，届时我们将创建可以并发运行的函数管道。然而，在我们到达那里之前，让我们先看看如何使我们的函数内部并发。
- en: Creating concurrent functions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并发函数
- en: 'Broadly speaking, there are two types of concurrency that we will be looking
    at in this chapter. We can call them **intra-concurrency** and **extra-concurrency**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，在本章中我们将探讨两种类型的并发。我们可以称它们为**内部并发**和**外部并发**：
- en: '*Intra-concurrency* is about creating functions that are implemented concurrently
    internal to each function. For example, in [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101),
    we saw various functions such as `Filter`, `Map`, and `FMap` that lend themselves
    to a concurrent implementation. That will be the focus of this section. Notably,
    they can be used in conjunction with each other so that we achieve concurrency
    at multiple steps in our algorithm, and we can even decide on the level of concurrency
    required for each step individually.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内部并发*是关于创建在函数内部并发实现的函数。例如，在[*第6章*](B18771_06.xhtml#_idTextAnchor101)中，我们看到了各种函数，如`Filter`、`Map`和`FMap`，它们适合并发实现。这将是本节的重点。值得注意的是，它们可以相互结合使用，这样我们就可以在算法的多个步骤中实现并发，甚至可以单独决定每个步骤所需的并发级别。'
- en: '*Extra-concurrency* is about chaining together functions using Go''s built-in
    concurrency features: channels and goroutines. This is explored later in the chapter.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部并发*是关于使用Go内置的并发特性（通道和goroutine）链接函数。这将在本章后面进行探讨。'
- en: Why are many of the fundamental building blocks of functional programming good
    candidates for concurrency? Well, first and foremost, it is because a purely functional
    implementation lends itself to a concurrent implementation without too many headaches.
    As we saw in the preceding chapter, concepts such as an immutable state and the
    elimination of side effects make it easy to take our functions and concurrently
    rewrite them. There should not be interference from other functions, no outside
    state to deal with, and no I/O to contend with. However, just because we *can*
    does not mean that we *should*. In this chapter, I will make the assumption that
    a concurrent implementation is going to be the right choice for the problems that
    we are solving. In the real world, concurrency is not a zero-cost implementation.
    There is real overhead associated with writing a concurrent application, as the
    threaded execution needs to be managed by our system (or, in Go’s case, our runtime).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么许多函数式编程的基本构建块是并发实现的良好候选者？首先，这是因为纯函数式实现本身非常适合并发实现，而不会带来太多麻烦。正如我们在上一章中看到的，不可变状态和副作用消除的概念使得我们可以轻松地将函数并发重写。不应该有其他函数的干扰，没有外部状态需要处理，也没有I/O需要竞争。然而，仅仅因为我们“可以”并不意味着我们“应该”。在本章中，我将假设并发实现将是解决我们问题的正确选择。在现实世界中，并发并不是零成本实现。编写并发应用程序确实会有一些实际的开销，因为线程执行需要由我们的系统（或者，在Go的情况下，是我们的运行时）来管理。
- en: Although in Go we are not responsible for managing the goroutines ourselves,
    under the hood of the Go runtime, context switching is not a zero-cost implementation.
    This means that just adding concurrent calls does not guarantee a performance
    improvement and can, in fact, harm performance. Ultimately, as with anything done
    for performance, the key to understanding the benefit that can be achieved is
    obtained through profiling your application. Profiling itself is beyond the scope
    of this section; the only comment to make on it is that Go has built-in benchmarking
    tools, which we saw in earlier chapters. These can also be used to determine the
    cost benefit of concurrent versus sequential functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Go语言中我们不需要自己管理goroutines，但在Go运行时的底层，上下文切换并不是零成本实现。这意味着仅仅添加并发调用并不能保证性能提升，实际上可能会损害性能。最终，就像任何为了性能而做的事情一样，理解可以获得的收益的关键在于通过分析你的应用程序来获得。分析本身超出了本节的范围；对此唯一要说的就是，Go语言内置了基准测试工具，我们已经在前面的章节中看到了这些工具。这些工具也可以用来确定并发函数与顺序函数的成本效益。
- en: Concurrent filter implementation
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发过滤器实现
- en: 'As we started with sequential filter implementation in earlier chapters and
    have become more familiar with it throughout the book, let’s start with this function
    and turn it into a concurrent implementation. Keep in mind that our initial function
    was a pure function, and as such, refactoring it into a concurrent one can be
    done without causing too much of a headache. There are a few steps to making this
    concurrent:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前面的章节中从顺序过滤器实现开始，并在整本书中对其越来越熟悉，让我们从这个函数开始，将其转换为并发实现。请注意，我们的初始函数是一个纯函数，因此将其重构为并发函数不会引起太多麻烦。使这个函数并发化有几个步骤：
- en: Split the input into batches.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入数据分割成批次。
- en: Start a process to filter each batch.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个进程来过滤每个批次。
- en: Aggregate the result of each batch.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合每个批次的处理结果。
- en: Return the aggregated output.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回聚合后的输出。
- en: 'To achieve this, we do need to refactor the initial `Filter` implementation.
    We will leverage some of Go’s built-in concurrency features to implement this,
    and the first thing we’ll want to leverage are channels and goroutines. In our
    initial `Filter` function, we iterated over each element, appended it to an output
    slice if it matched the predicate, and finally, we returned the output slice.
    In this version, rather than returning an output slice, we’ll write the result
    onto a channel:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们确实需要重构初始的`Filter`实现。我们将利用Go的一些内置并发特性来实现这一点，我们首先想要利用的是通道和goroutines。在我们的初始`Filter`函数中，我们遍历每个元素，如果它匹配谓词，则将其追加到输出切片中，最后返回输出切片。在这个版本中，我们不会返回输出切片，而是将结果写入通道：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Writing to a channel allows us to call this function in a traditional concurrent
    fashion within Go. However, before we get there, we’ll have to establish a wrapper
    function around `Filter`, which we will call `ConcurrentFilter`. This function
    does a few things, including allowing us to configure the batch size. Playing
    around with the batch sizes can help us tweak the performance to get it where
    we want it (if there are too few batches, there’s little benefit to running concurrently;
    too many, and the overhead caused by managing goroutines similarly reduces our
    benefit). Apart from batching our input, we’ll also need to call the `Filter`
    function prepended with the `go` keyword so that it spins up a new goroutine.
    Finally, this function will read the results for each of the goroutines that we
    started and aggregate this result in to a single output slice:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据写入通道允许我们在Go中以传统的并发方式调用这个函数。然而，在我们到达那里之前，我们将在`Filter`周围建立一个包装函数，我们将称之为`ConcurrentFilter`。这个函数做了一些事情，包括允许我们配置批次大小。玩弄批次大小可以帮助我们调整性能，使其达到我们想要的状态（如果批次太少，并发运行的好处很小；太多，管理goroutines带来的开销同样会减少我们的好处）。除了批处理我们的输入之外，我们还需要调用前面带有`go`关键字的`Filter`函数，以便启动一个新的goroutine。最后，这个函数将读取我们启动的每个goroutine的结果，并将这些结果汇总到一个单一的输出切片中：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code snippet, we keep the print statements so we can see what
    execution looks like when running this. Let’s create a simple `main` function
    that will filter a slice of integers in this fashion and look at the corresponding
    output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们保留了打印语句，这样我们就可以看到运行这个函数时的执行情况。让我们创建一个简单的`main`函数，它将以这种方式过滤整数切片，并查看相应的输出：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running this function gives us the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个函数会给我们以下输出：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this output, we can see that `4` goroutines had to be spun up to process
    our input with a batch size of `3`. This has sharded our input data into the following
    segments:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，我们可以看到需要启动`4`个goroutine来处理我们的输入，批次大小为`3`。这已经将我们的输入数据分片成以下段：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we can see in which order the threads completed and returned their output.
    As you can tell from the output, we get the output back in random order. This
    is visible both in the `got data` output as well as in the final aggregated result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到线程完成并返回输出的顺序。正如你可以从输出中看到的，我们以随机顺序得到输出。这在`got data`输出以及最终的汇总结果中都是可见的。
- en: Tip
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An important callout here is that by sharding our data and running our functions
    concurrently, we no longer have a predictable sequence order in the output list.
    If we want to restore the ordering of our data, we should implement a `Sort` function
    after concurrently calling our functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的一个重要提示是，通过分片我们的数据和并发运行我们的函数，我们不再在输出列表中有一个可预测的顺序。如果我们想恢复我们数据的顺序，我们应该在并发调用我们的函数之后实现一个`Sort`函数。
- en: This `Filter` implementation is a good template to start from when we want to
    make our functions run concurrently. Let’s take a look at a concurrent implementation
    for both the `Map` and `FMap` functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使我们的函数并发运行时，这个`Filter`实现是一个很好的起点模板。让我们看看`Map`和`FMap`函数的并发实现。
- en: Concurrent Map and FMap implementation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发Map和FMap实现
- en: 'Implementing the `Map` and `FMap` functions concurrently requires the same
    steps as for the concurrent `Filter` implementation, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并发`Map`和`FMap`函数需要与并发`Filter`实现相同的步骤，如下所示：
- en: Split the input into batches.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入分割成批次。
- en: Start a process to filter each batch.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个进程来过滤每个批次。
- en: Aggregate the result of each batch.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇总每个批次的结果。
- en: Return the aggregated output.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回汇总的输出。
- en: As such, we won’t go over each step in detail for these implementations. The
    explanation behind each step and how we implement it is pretty much identical
    to the `Filter` implementation. We are showing these here for completeness and
    to showcase the general pattern of refactoring these functions to operate concurrently.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会详细说明这些实现的每个步骤。每个步骤背后的解释以及我们如何实现它基本上与`Filter`实现相同。我们在这里展示这些是为了完整性，并展示将这些函数重构为并发操作的一般模式。
- en: Concurrent Map
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发Map
- en: 'To implement our `Map` function concurrently, we first refactor the `Map` function
    that we created in [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101). Here, again,
    we are removing the explicit return, and we’ll use channels to communicate the
    output of mapping each element:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要并发实现我们的 `Map` 函数，我们首先重构了在 [*第 6 章*](B18771_06.xhtml#_idTextAnchor101) 中创建的
    `Map` 函数。在这里，我们再次移除了显式的返回，并将使用通道来传递映射每个元素的输出：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will implement the `ConcurrentMap` function, batching the output as
    we did with the `ConcurrentFilter` implementation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `ConcurrentMap` 函数，像我们在 `ConcurrentFilter` 实现中做的那样，批量处理输出：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that both the `ConcurrentFilter` and `ConcurrentMap` implementations require
    `batchSize` to be passed as input to the function. This means that we can process
    each step with a different number of goroutines, and tweak each function individually:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ConcurrentFilter` 和 `ConcurrentMap` 的实现都需要将 `batchSize` 作为输入传递给函数。这意味着我们可以用不同数量的
    goroutines 处理每个步骤，并单独调整每个函数：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we are using a batch size of `3` for filtering but only a
    batch size of `2` for mapping. The output of this `main` function looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `3` 作为过滤的批量大小，但只使用 `2` 作为映射的批量大小。这个 `main` 函数的输出如下所示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Concurrent FMap implementation
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发 FMap 实现
- en: 'This implementation is pretty similar to the `Map` implementation. The main
    difference is that our channel has changed type. Rather than having the entire
    function signature operate on the same `A` type, we’ll now have a mix of `A` and
    `B`. This is a minor change and does not affect the implementation details beyond
    having to create the right type for the channels:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现与 `Map` 实现非常相似。主要区别在于我们的通道类型已经改变。而不是让整个函数签名都操作相同的 `A` 类型，我们现在将有一个 `A` 和
    `B` 的混合。这是一个小的变化，不会影响实现细节，除了需要为通道创建正确的类型：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I hope that this serves as an illustration of how easy it is to create concurrent
    implementations for functions that are written in the purely functional style.
    There is one limitation posed by Go that makes this a bit more verbose than it
    would be in other languages. As Go is a strictly typed language (which is a good
    thing in general), our function signatures need to match exactly when using higher-order
    functions. Otherwise, we could template out the recursive part of our function
    and call a higher-order function for the actual implementation on each node. In
    pseudo-code, we would get something like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这能说明，对于以纯函数风格编写的函数，创建并发实现是多么容易。Go 语言的一个限制使得这比其他语言要冗长一些。由于 Go 是一种严格类型化的语言（这在一般情况下是好事），当使用高阶函数时，我们的函数签名需要完全匹配。否则，我们可以模板化函数的递归部分，并在每个节点上调用高阶函数进行实际实现。在伪代码中，我们可能会得到以下内容：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Either way, we saw that leveraging concurrency in our functions is relatively
    headache-free and can be achieved with only a bit of refactoring. Let’s move on
    to the final topic of this chapter, which is using concurrency mechanisms to chain
    functions together.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都看到，在我们的函数中利用并发相对无头痛，只需稍作重构即可实现。让我们继续本章的最后一个主题，即使用并发机制将函数链接在一起。
- en: The pipeline pattern
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道模式
- en: 'In the previous sections, we concerned ourselves with organizing concurrency
    inside the functions themselves. However, we have chained them together pretty
    much as we would normally, by calling them in sequential order in the main function.
    In this section, we are going to look at the pipeline pattern, which will allow
    us to leverage goroutines and channels to chain function calls together. First,
    let’s discuss what a pipeline is exactly. In 1964, Doug McIlroy wrote the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们关注的是在函数内部组织并发。然而，我们基本上是按照常规顺序在主函数中调用它们来将它们链接在一起。在本节中，我们将探讨管道模式，这将允许我们利用
    goroutines 和通道将函数调用链接在一起。首先，让我们讨论一下管道究竟是什么。在 1964 年，道格·麦克伊罗伊写了以下内容：
- en: We should have some ways of coupling programs like garden hose – screw in another
    segment when it becomes necessary to massage data in another way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该有一些方法来耦合程序，就像花园的水管一样——当需要以另一种方式处理数据时，可以拧上另一个段。
- en: 'This quote neatly expresses the Unix philosophy of composing programs. Many
    of us are familiar with the concept of Unix pipes, denoted by the `|` symbol.
    By using pipes, we can chain Unix programs together. The output of one program
    becomes the input of the next. For example, we can use `cat` to read a file, and
    we can use `wc` to get the word count of that file. To join this together, we
    would write `cat file.txt | wc`. In Unix’s modular program approach, the idea
    is that programs each serve a single purpose but can be joined together to create
    complex programs. This philosophy can be ported over to the functional programming
    paradigm. We want to chain simple functions together, where each function only
    has a single purpose, to create a complex program. Take the following example;
    each function serves a single purpose, and we chain them together using the pipe
    (`|`) character:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话巧妙地表达了Unix编程哲学中的程序组合思想。我们很多人对Unix管道的概念都很熟悉，管道用`|`符号表示。通过使用管道，我们可以将Unix程序连接起来。一个程序输出成为下一个程序的输入。例如，我们可以使用`cat`来读取文件，使用`wc`来获取该文件的单词数。要将它们组合在一起，我们会写`cat
    file.txt | wc`。在Unix的模块化程序方法中，其理念是每个程序只服务于单一目的，但可以组合起来创建复杂的程序。这种哲学可以移植到函数式编程范式。我们希望将简单的函数连接起来，每个函数只具有单一目的，以创建复杂的程序。以下是一个例子；每个函数只服务于单一目的，我们通过管道（`|`）字符将它们连接起来：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we first read the `main.go` file using `cat`. We send the content
    of that file to `grep`, which searches that content for the `func` keyword. Then,
    we send each line that matches this search to the `wc` program and count the lines
    in the output (the `-l` flag counts newlines). And finally, we send this to `awk`
    and print the result. What follows is a similar way of chaining Go functions together,
    rather than Unix commands.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用`cat`读取`main.go`文件。我们将该文件的内容发送到`grep`，在内容中搜索`func`关键字。然后，我们将匹配此搜索的每一行发送到`wc`程序，并计算输出中的行数（`-l`标志计算换行符）。最后，我们将这些发送到`awk`并打印结果。以下是以类似方式链式调用Go函数的方法，而不是Unix命令。
- en: Chaining functions with channels
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通道链式调用函数
- en: Go ships with all the tools necessary to create such building programs, namely
    channels. Channels are a way to send messages (data) from one function to another;
    thus, we can use channels as an alternative to the Unix pipes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言自带了创建此类构建程序的必要工具，即通道。通道是向另一个函数发送消息（数据）的方式；因此，我们可以将通道作为Unix管道的替代品。
- en: 'The first step in creating our pipeline starts by changing how our functions
    get their input and output. For the rest of this chapter, we will mainly be focusing
    on two functions, `Filter` and `Map`, but this can be extended to any other functions.
    The core idea is to use channels for input and output data communication. First,
    let’s take a look at the `Filter` function and how this needs to be changed to
    follow our channels-in/channels-out approach. We’ll name our new function `FilterNode`.
    We’ll get back to this naming convention later, but each function can be thought
    of as a node in our chain of functions. Instead of accepting a slice as input,
    we’ll have a channel as input, from which we can read incoming data. We’ll still
    have `predicate` as expected, and finally, we’ll return a channel rather than
    a slice of data as well:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的管道的第一步是改变我们的函数获取输入和输出的方式。在本章的剩余部分，我们将主要关注两个函数，`Filter`和`Map`，但这可以扩展到任何其他函数。核心思想是使用通道进行输入和输出数据通信。首先，让我们看看`Filter`函数以及如何将其修改为遵循我们的通道输入/输出方法。我们将我们的新函数命名为`FilterNode`。我们将在稍后回到这个命名约定，但每个函数都可以被视为我们函数链中的一个节点。我们不再接受切片作为输入，而将有一个通道作为输入，我们可以从中读取传入的数据。我们仍然会有`predicate`，最后，我们将返回一个通道而不是数据切片：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding function, the main algorithm for filtering elements remains
    unchanged. We’ll test each value against a predicate; if the predicate returns
    `true`, we’ll keep the value (by sending it to the output channel); otherwise,
    we'll discard it. Pay attention to the use of the `go` keyword here. This function,
    although it gets executed immediately, is launched on its own goroutine. The function
    immediately returns the `out` channel, although the evaluation on the goroutine
    has not necessarily finished the computation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，过滤元素的算法保持不变。我们将测试每个值是否满足谓词；如果谓词返回`true`，我们将保留该值（通过将其发送到输出通道）；否则，我们将丢弃它。请注意这里`go`关键字的使用。这个函数虽然立即执行，但它是在自己的goroutine上启动的。函数立即返回`out`通道，尽管goroutine上的评估不一定已经完成计算。
- en: 'The next function that we will refactor similarly is the `Map` function. It’s
    an analogous change to the `Filter` function. We’ll use a channel to receive input
    for the function, a channel to return the output, and run the actual mapping logic
    inside a goroutine, which we start before returning the channel from our function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要重构的下一个函数是`Map`函数。它与`Filter`函数类似。我们将使用一个通道接收函数的输入，一个通道返回输出，并在返回通道之前在goroutine中运行实际的映射逻辑：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So far, so good – we’ve refactored two of our functions to fit in with this
    new design. Next, let’s tackle the question of receiving input to these functions.
    From the function signature, we can tell that we need to receive data on a channel
    of type `A`. Thus, any function that can provide this can be used as the input
    for our function. We’ll call these types of functions *generators*. The first
    generator that we will create takes a variadic input of type `A` and pushes each
    of these values onto a channel:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利——我们已经重构了两个函数以适应这种新的设计。接下来，让我们解决接收这些函数输入的问题。从函数签名中，我们可以看出我们需要在类型为`A`的通道上接收数据。因此，任何可以提供这种数据的函数都可以用作我们函数的输入。我们将这些类型的函数称为*生成器*。我们将创建的第一个生成器接受类型为`A`的可变数量输入，并将每个这些值推送到通道中：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can tell, the main logic still resembles that of the previous `Filter`
    and `Map` implementations. The main difference is that we’re no longer receiving
    values over a channel but, rather, through some other input data structure (in
    this case, variadic input parameters). This could also be a function that reads
    a file and places each line on the channel. It’s similar to how `cat` worked in
    our earlier Unix example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主要逻辑仍然类似于之前的`Filter`和`Map`实现。主要区别在于我们不再通过通道接收值，而是通过其他输入数据结构（在这种情况下，可变数量输入参数）接收值。这也可能是一个读取文件并将每一行放置在通道上的函数。这与我们早期Unix示例中的`cat`操作类似：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The key point is that our function places values on a channel and returns this
    channel. How it gets to those values doesn’t matter too much for building our
    pipeline. Before we can test this implementation end to end, we still have one
    hurdle to cross. Each node in this setup writes data to a channel, but to collect
    the output at the end, we’ll want to store it in a more common data structure.
    Slices are the perfect structure for this, at least in our examples. We can call
    this last type of function a *collector*. A collector takes a channel as input
    and returns a slice of the elements as output. Essentially, it’s performing the
    reverse operation of the *generator*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于我们的函数将值放置在通道上并返回这个通道。如何获取这些值对于我们构建流水线来说并不那么重要。在我们能够从头到尾测试这个实现之前，我们仍然有一个障碍需要克服。在这个设置中，每个节点都将数据写入一个通道，但为了在最后收集输出，我们希望将其存储在一个更常见的数据结构中。切片是我们例子中的完美结构。我们可以将这种最后类型的函数称为*收集器*。收集器接收一个通道作为输入，并返回一个元素切片作为输出。本质上，它是在执行*生成器*的相反操作：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this in place, we can tie all of them together into a single pipeline.
    To demonstrate this, in our `main` function, we will push some numbers to a channel
    using `Generator`. We’ll then filter these numbers to only retain the even ones
    using `FilterNode`. These numbers then get squared using `MapNode`, and finally,
    we collect the output in a slice using the `Collector` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以将它们全部整合成一个单一的流水线。为了演示这一点，在我们的`main`函数中，我们将使用`Generator`将一些数字推送到一个通道中。然后，我们使用`FilterNode`对这些数字进行过滤，只保留偶数。这些数字随后通过`MapNode`进行平方，最后，我们使用`Collector`函数在一个切片中收集输出：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of running this is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的输出如下：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding is a good first step toward chaining our functions together. However,
    we can make it cleaner. We can build a `ChainPipes` function that will tie together
    the various functions and take care of managing the channels for us.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤是串联我们的函数的一个很好的第一步。然而，我们可以让它更简洁。我们可以构建一个`ChainPipes`函数，它将连接各种函数并为我们管理通道。
- en: Improved function chaining
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进的函数链式调用
- en: 'The initial approach of chaining the functions together was a workable solution,
    but it required some overhead, as we had to manage passing around the right channels
    to each subsequent function. What we want to achieve is for the engineers using
    our setup only needing to concern themselves with the functions to call, and which
    order to call them in. We don’t want them to be concerned about how the channels
    operate underneath; we can consider that an implementation detail. What we will
    work toward in this section will allow us to compose the functions like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数链式连接起来的初始方法是一个可行的解决方案，但它需要一些开销，因为我们必须管理传递正确的通道给每个后续函数。我们想要实现的是，使用我们设置的工程师只需要关注要调用的函数以及它们的调用顺序。我们不希望他们关心通道在底层是如何操作的；我们可以将其视为实现细节。在本节中，我们将努力实现以下内容：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This snippet gives us a bit of a teaser of what’s to come. In order to chain
    functions like this, we will need to take advantage of function currying. Let’s
    get there step by step. What we want to achieve is function composition by passing
    in functions to `ChainPipes`, as we saw in the preceding snippet. Go has a strict
    type system, so to make this function work nicely, we want to define a custom
    type for such functions, which will allow us to use it in the function signature
    and get the compiler to type-check for us.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段给我们一些关于接下来要发生什么的暗示。为了像这样链式连接函数，我们需要利用函数柯里化。让我们一步一步地实现它。我们想要实现的是通过将函数传递给`ChainPipes`来执行函数组合，就像我们在前面的代码片段中看到的那样。Go有一个严格的类型系统，因此为了使这个函数正常工作，我们想要为这样的函数定义一个自定义类型，这将允许我们在函数签名中使用它，并让编译器为我们进行类型检查。
- en: 'The first thing we will do is define our own types for the main functions representing
    an operation on our data. We’ll call these `Nodes`. There are three distinct types
    of nodes that we can define, based on the previous discussion – nodes that generate
    a channel, nodes that take a channel and return a new channel, and finally, nodes
    that take a channel and return a concrete data structure such as a slice:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是定义代表我们对数据进行操作的主要函数的自定义类型。我们将称之为`Nodes`。根据之前的讨论，我们可以定义三种不同的节点类型——生成通道的节点、接收通道并返回新通道的节点，以及最终接收通道并返回具体数据结构（如切片）的节点：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These type definitions make up the bread and butter of the function types that
    can be used to chain together our applications. With this in place, we can define
    the `ChainPipes` function as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型定义构成了我们可以用来链式连接应用程序的功能类型的精华。有了这个，我们可以定义`ChainPipes`函数如下：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding snippet creates a `ChainPipes` function that takes a channel as
    input and a series of nodes. Finally, it will call the default collector and return
    the data in a slice of type `[]A`. Do note that one limitation is that we are
    assuming that each node has a compatible type (`A`) throughout the chain.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段创建了一个`ChainPipes`函数，它接受一个通道作为输入和一系列节点。最后，它将调用默认的收集器，并以类型`[]A`的切片返回数据。请注意，一个限制是我们假设在链中的每个节点都具有兼容的类型（`A`）。
- en: 'To make the type system work, each node needs to have the same function signature.
    In our initial setup, that was difficult, as we already had two distinct function
    signatures for `Filter` and `Map`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使类型系统正常工作，每个节点都需要有相同的函数签名。在我们的初始设置中，这很困难，因为我们已经有了两个不同的函数签名用于`Filter`和`Map`：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'More functions would mean more distinct function signatures. Therefore, what
    is needed is refactoring these functions so that they adhere to the same type
    signature. We have already learned how to do that through function currying. We
    need to create two new functions that each `Node`. Each function will have the
    original functionality of `Filter` and `Map` baked in but returns a new function
    that takes a channel as the input (hence the function is partially applied):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的函数意味着更多的不同函数签名。因此，我们需要重构这些函数，使它们遵循相同的类型签名。我们已经通过函数柯里化学习了如何做到这一点。我们需要为每个`Node`创建两个新函数。每个函数都将包含`Filter`和`Map`的原始功能，但返回一个接受通道作为输入的新函数（因此函数是部分应用的）：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can tell in the preceding example that the core logic of each function has
    remained the same. However, rather than being instantly applied when the function
    is called, a new function is returned that expects to receive a channel as input
    and returns a channel as output. Inside this anonymous function, we have coded
    the `Filter` and `Map` logic respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的例子中看出，每个函数的核心逻辑保持不变。然而，而不是在函数被调用时立即应用，返回一个新的函数，该函数期望接收一个通道作为输入，并返回一个通道作为输出。在这个匿名函数内部，我们分别编写了`Filter`和`Map`逻辑。
- en: 'As the return type is `Node`, that means that when we call the `CurriedFilterNode`
    function, we are not receiving a result, but we are receiving another function
    that needs to be called at a later stage to actually compute the filtered list
    of values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回类型是`Node`，这意味着当我们调用`CurriedFilterNode`函数时，我们并没有收到一个结果，而是收到另一个需要在稍后阶段调用的函数，以实际计算过滤后的值列表：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is the crucial part of making our pipeline builder work. If we look at
    `ChainPipes` again, the main loop is calling the nodes (functions) that were supplied
    to it with the channel as input and reassigning the output to the same channel
    that was used as input:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使我们的管道构建器正常工作的关键部分。如果我们再次查看`ChainPipes`，主循环是调用提供给它的节点（函数），以通道作为输入，并将输出重新分配到用作输入的相同通道：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could go one step further and also abstract away the generator from the
    `ChainPipes` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，将生成器从`ChainPipes`函数中抽象出来：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this change in place, it does imply that when calling the function, we
    need another curried function to supply the generator. This can be done in-line,
    but for clarity, the following example is a separate function existing at the
    package level. In this case, we will use the `Cat` function that we introduced
    earlier and return the curried version:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这一变化意味着在调用函数时，我们需要另一个柯里化函数来提供生成器。这可以在行内完成，但为了清晰起见，以下示例是一个存在于包级别的独立函数。在这种情况下，我们将使用我们之前引入的`Cat`函数，并返回其柯里化版本：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once again, this curried version of the function operates in the same way as
    the non-curried version. However, through currying, we can make it adhere to the
    type signature indicated by the `ChainPipes` function. We can now pass both the
    generator as well as the nodes to this function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个柯里化版本的函数与未柯里化的版本以相同的方式运行。然而，通过柯里化，我们可以使其符合`ChainPipes`函数指示的类型签名。现在我们可以将生成器和节点都传递给这个函数：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that in the preceding example, we did have to give a type hint to `ChainPipes`
    to indicate the resulting type of the `CurriedCat` function. What we saw in the
    preceding section is that by using channels, the Go type system, higher-order
    functions, and more specifically, function currying, we can build programs by
    chaining together functions in the right way. Using this method of function composition,
    it’s also easier to refactor our application. If we want to apply a map before
    filtering, we just need to change the order in which the node is passed to `ChainPipes`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的例子中，我们确实需要给`ChainPipes`提供一个类型提示，以指示`CurriedCat`函数的结果类型。在前一节中我们看到，通过使用通道、Go类型系统、高阶函数，特别是函数柯里化，我们可以通过正确链接函数来构建程序。使用这种函数组合方法，重构我们的应用程序也更容易。如果我们想在过滤之前应用映射，我们只需更改传递给`ChainPipes`的节点的顺序即可。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a look at how Go’s concurrency model can be used when
    writing code in the functional paradigm. We started the chapter with a brief discussion
    on the difference between concurrency, parallelism, and distributed computing
    to delineate exactly what concurrency is.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在函数式编程范式编写代码时如何使用Go的并发模型。我们以对并发、并行和分布式计算之间差异的简要讨论开始本章，以明确并发是什么。
- en: Once we established that concurrency is the ability to do multiple tasks at
    once (although not necessarily simultaneously), we looked at how we can refactor
    the functions from [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101) into a concurrent
    implementation, leveraging channels and goroutines. We concluded this chapter
    by looking at pipelines, a way to create programs by composing functions together
    and orchestrating the flow of data with the use of channels. We also looked at
    how we can create a higher-order function to compose functions (`ChainPipes`)
    and have observed how, through the use of function currying, we can create functions
    that adhere to our type system without giving up type safety.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确立了并发是同时执行多个任务的能力（尽管不一定必须是同时进行），我们就研究了如何将[第6章](B18771_06.xhtml#_idTextAnchor101)中的函数重构为并发实现，利用通道和goroutines。我们通过查看管道来结束这一章，管道是一种通过组合函数来创建程序并使用通道来协调数据流的方法。我们还探讨了如何创建一个高阶函数来组合函数（`ChainPipes`），并观察到通过使用函数柯里化，我们可以创建符合我们的类型系统而不牺牲类型安全的函数。
- en: In the next and final chapter, we will take a look at programming libraries
    that we can leverage to create Go programs, following some of the functional programming
    principles that we explored in this book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将探讨一些编程库，这些库可以帮助我们创建Go程序，同时遵循我们在本书中探讨的一些函数式编程原则。
