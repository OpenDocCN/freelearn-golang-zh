<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-158" class="chapter-number"><a id="_idTextAnchor158"/>11</h1>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor159"/>Functional Programming Libraries</h1>
			<p>In the previous chapters of this book, we looked at how we can leverage functional programming techniques in Go. In doing so, we have looked over how functions can be created, such as Filter, Map, Reduce, and so on. We also looked at data structures such as the monad and its application with the Maybe data type, which could represent a value that’s either present or absent without having to rely <span class="No-Break">on nil.</span></p>
			<p>As mentioned previously, these are common tools in a functional programmer’s toolbox. As such, there are open source libraries that have this functionality built in. As generics are a recent addition in Go (about 1 year ago at the time of writing), not all libraries currently leverage generics to implement these concepts. For that reason, this chapter will cover both libraries that work in all versions of Go, as well as libraries that will exclusively work in versions that <span class="No-Break">support Generics.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Pre-generics libraries for creating common <span class="No-Break">FP functions</span></li>
				<li>Post-generics libraries for creating common <span class="No-Break">FP functions</span></li>
			</ul>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor160"/>Technical requirements</h1>
			<p>For this chapter, any version of Go will suffice for implementing the pre-generics library code. Once we move to the post-generics libraries, a version of 1.18 or higher will be needed to support the code. All the code can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
			<p>There are a few things to call out before we dive deeper into this topic that relate somewhat to the <span class="No-Break">technical requirements.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor161"/>Is the library alive – and do the examples still match it?</h2>
			<p>When writing a book <a id="_idIndexMarker543"/>about a specific programming language, it is hard to write it in an evergreen fashion. But programming libraries are perhaps even harder to keep evergreen than any other content. There are two reasons for this, which are important <span class="No-Break">to acknowledge:</span></p>
			<ul>
				<li>The implementations can change, and versioning is not <span class="No-Break">always respected.</span></li>
				<li>The library may become unsupported in <span class="No-Break">the future.</span></li>
			</ul>
			<p>The first problem, <em class="italic">changing implementations</em>, should be somewhat mitigated by the fact that only popular libraries will be explored in this chapter, whereby popularity is judged by engagement on GitHub as well as stars on GitHub. It’s an imperfect measure, but it’s better than not having anything to <span class="No-Break">go by.</span></p>
			<p>I hope that these libraries respect versioning and that they limit breaking changes as much as possible. Still, I can’t guarantee that these libraries won’t change and that the functions will work as-is when you are reading this chapter. In the code example, I will highlight which version of the library is being shown so that the results can at least be recreated by fetching the correct version of the library, even if that is not the latest version. This brings us to the second, <span class="No-Break"><em class="italic">related</em></span><span class="No-Break"> problem.</span></p>
			<p>The library may become unsupported. If you are working with an older version of the library to recreate the examples in this chapter because the latest version introduced some breaking changes, then <a id="_idIndexMarker544"/>clearly there’s a risk that you’ll run into some known issues, and you might not get support as you’re using an older version. But, even if the examples shown here work correctly with the latest version of the library, the library can still be stale. If everything works as intended and the library is considered feature complete, that’s not immediately a <span class="No-Break">red flag.</span></p>
			<p>However, it does mean that finding these libraries can be hard. The best way to determine this is by looking for any activity on the GitHub (or GitLab) page. For example, is the most recent commit only a few days or weeks ago, or is it years in the past? Are the contributors actively responding to tickets or do they all go unanswered? Are they engaging with their community over Discord or IRC? These are all examples that can hint at how well maintained a <span class="No-Break">library is.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor162"/>Legal requirements</h2>
			<p>I’ll keep this part brief, as I <a id="_idIndexMarker545"/>am not a lawyer. But anyone dealing with open source code should be aware that not all open source code <span class="No-Break">is permissive.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before working with a library, especially in a commercial context, be sure to review the software license and confirm that your use case is legally allowed and under which conditions. (For example, some licenses will allow the use of the code with attribution. Others will only allow for non-commercial use cases and <span class="No-Break">so on.)</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor163"/>Pre-generics libraries for creating common FP functions</h1>
			<p>With or without generics, it is common to operate on collection-style data structures in any programming language. Storing a series of values, whether it is a list of numbers representing scores <a id="_idIndexMarker546"/>on a test or a collection <a id="_idIndexMarker547"/>of structs such as all employees working in a hospital, is common enough that you’ll run into these data structures sooner rather than later. The operations that are performed on these can also fall into a few categories, especially once we abstract them into higher-order functions. You either have to modify the data elements in some way (for example, multiplying all the values by two) or modify the container in some way (for example, removing all the odd numbers). As we have seen, rather than implementing a function such as <strong class="source-inline">removeOdds</strong> or <strong class="source-inline">multiplyNumbers</strong>, what we’d like to write is just a function that can filter any element based on a predicate or change an element based on a transformation (these are the Filter and Map <span class="No-Break">functions, respectively).</span></p>
			<p>Before generics were introduced, there was no clear and best way to handle this. The reasoning for not abstracting these use cases, at the time, was that writing functions specific to your data structure would deliver the best results in terms of performance. So, you’d give up a bit of developer comfort but would get a more performant application in return. In hindsight, many of the operations on collections have an identical implementation, which means there’s no real performance difference. It’s only a natural consequence that people came up with ways of building abstractions for <span class="No-Break">repeating implementations.</span></p>
			<p>Broadly speaking, there are two ways this problem could be tackled before the introduction of generics – either by programming against the empty interface (<strong class="source-inline">interface{}</strong>), an interface that any data type implicitly adheres to in Go, or through code generation. The former, programming against <strong class="source-inline">interface{}</strong>, has too many disadvantages in terms of typesafety and runtimesafety to advocate strongly for it. But the latter, code generation, is <a id="_idIndexMarker548"/>still interesting to look at, if only because code generation could still be useful in a post-generics world <a id="_idIndexMarker549"/>albeit for different <span class="No-Break">use cases.</span></p>
			<p class="callout-heading">Libraries versus custom implementations</p>
			<p class="callout">In this book, we have seen ways to create our own set of functions that follow the functional <a id="_idIndexMarker550"/>programming paradigm. Libraries might <a id="_idIndexMarker551"/>offer a more efficient implementation and can prevent you from reinventing the wheel. However, if you want to keep your dependency graph lightweight, it is much easier to do so by providing a few implementations yourself now that Go has: generics. In a pre-generics version of Go, this was much harder and I’d favor the library-based approach. Neither the empty interface-based approach nor the code generation approach is easy to implement without errors <span class="No-Break">and headaches.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor164"/>Code generation libraries for pre-generics Go</h2>
			<p>Code generation, as the name implies, is a technique for generating Go code that can then be used like <a id="_idIndexMarker552"/>regular Go code in our <a id="_idIndexMarker553"/>application. The Go toolchain has all the necessary tools to do <a id="_idIndexMarker554"/>this out of the box. In Go, it is possible to add comments to your code that the compiler will interpret as commands. Such comments make it possible <a id="_idIndexMarker555"/>to trigger a special operation during the compile time of your program. These comments are called <strong class="bold">pragma</strong>. For example, you can add a comment to a function that will tell the compiler to avoid in-lining this function (the compiler can ignore it, so it’s more a suggestion than <span class="No-Break">a command):</span></p>
			<pre class="source-code">
//go:noinline
func someFunc() {}</pre>
			<p>The idea behind the code generation library, which we will explore shortly, is that using these special comments can trigger the generation of functions for a specific type, which implements the common functional programming operations such as filtering, mapping, reducing, and so on. The first library that we will explore, Pie, works in exactly <span class="No-Break">this way.</span></p>
			<h3>A slice of Pie</h3>
			<p>The library that we <a id="_idIndexMarker556"/>will explore is <strong class="bold">Pie</strong>, written by Elliot Chance and available on GitHub here: <a href="https://github.com/elliotchance/pie/tree/master/v1">https://github.com/elliotchance/pie/tree/master/v1</a>. This library is available in <span class="No-Break">two versions:</span></p>
			<ul>
				<li>Version 1 focuses on <a id="_idIndexMarker557"/>Go at or <span class="No-Break">below 1.17</span></li>
				<li>Version 2 is the newer version for working with generics and needs Go 1.18 or above <span class="No-Break">to work</span></li>
			</ul>
			<p>In version 1, there are two ways of using this library. You can either use the functions directly to operate on common data types (<strong class="source-inline">[]string</strong>, <strong class="source-inline">[]float64</strong>, or <strong class="source-inline">[]int</strong>), or you can use this library to generate functions for your own data type. First, we’ll explore the built-in structures and then move on to generating functions for <span class="No-Break">custom types.</span></p>
			<h4>Using the built-in functions of Pie</h4>
			<p>Pie supports built-in functions for three <span class="No-Break">data types:</span></p>
			<ul>
				<li><strong class="source-inline">[]</strong><span class="No-Break"><strong class="source-inline">string</strong></span></li>
				<li><strong class="source-inline">[]</strong><span class="No-Break"><strong class="source-inline">float64</strong></span></li>
				<li><strong class="source-inline">[]</strong><span class="No-Break"><strong class="source-inline">int</strong></span></li>
			</ul>
			<p>These are quite <a id="_idIndexMarker558"/>common, so it makes sense that these are supported by default. In the examples throughout this book, we have shown how we can filter a slice of integers to retain only the even numbers. Then, we squared them by using the Map function. Doing this in Pie is easy and follows the same idea as the code that we implemented in <a href="B18771_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> and beyond. As we are doing this through the use of a library, let’s first take a look at the content of the <strong class="source-inline">go.mod</strong> file to highlight which version of Pie we <span class="No-Break">are using:</span></p>
			<pre class="source-code">
go 1.17
require github.com/elliotchance/pie v1.39.0</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">This is showing <strong class="source-inline">go 1.17</strong> as we are explicitly looking at libraries that can be used before generics <span class="No-Break">were introduced.</span></p>
			<p>Now that we have imported the library (after running <strong class="source-inline">go get</strong>), we can use it in our application. Let’s build the Filter and Map example, as <span class="No-Break">explained earlier:</span></p>
			<pre class="source-code">
package main
import (
        "fmt"
        "github.com/elliotchance/pie/pie"
)
func main() {
        out := pie.Ints{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.
                Filter(func(i int) bool {
                        return i%2 == 0
                }).
                Map(func(i int) int { return i * i })
        fmt.Printf("result: %v\n", out)
}</pre>
			<p>Running this code will output <strong class="source-inline">result: [4 16 36 64 100]</strong>, as expected. Pie allows us to build <a id="_idIndexMarker559"/>and chain functions together, similar to what we have seen in this book so far. Out of the box, this only works for slices of strings, ints, and float64s. Each of these requires a custom implementation in the library. By attaching the function to a concrete type, it can support multiple Filter and Map functions defined for distinct data types. This is also something that we have looked at doing ourselves, and as pointed out, this is a time-consuming and <span class="No-Break">repetitive undertaking.</span></p>
			<p>What Pie does is remove some of this repetitive work by using code generation to generate the implementation for each data type. The details of how code generation works in this library are beyond the scope of this book, but I’d encourage checking out the library <a id="_idIndexMarker560"/>itself on GitHub and diving into the code to get a better appreciation for how this was built as it is genuinely <span class="No-Break">quite interesting.</span></p>
			<p>Pie ships with a lot of functions. To get an up-to-date listing with a description of each, take a look at the wiki <span class="No-Break">at </span><a href="https://github.com/elliotchance/pie/tree/master/v1"><span class="No-Break">https://github.com/elliotchance/pie/tree/master/v1</span></a><span class="No-Break">.</span></p>
			<h4>Pie for custom data types</h4>
			<p>If we want to <a id="_idIndexMarker561"/>use Pie for our own data type, we need to generate the code to <span class="No-Break">do this:</span></p>
			<ol>
				<li>First, let’s set up a struct that we can use in all the following examples. We’ll create a struct to represent a dog, and also a type alias for a slice of the <strong class="source-inline">[]</strong><span class="No-Break"><strong class="source-inline">Dog</strong></span><span class="No-Break"> type:</span><pre class="source-code">
//go:generate pie Dogs.*
type Dogs []Dog
type Dog struct {
    Name string
    Age  int
}</pre></li>
				<li>With this set up, we can run the <strong class="source-inline">go generate</strong> command and generate all of Pie’s functions for our custom data type. This created a new file, <strong class="source-inline">dogs_pie.go</strong>, in the same directory as our type definitions. By looking through the generated file, we can see which functions were generated. For example, the <strong class="source-inline">Reverse</strong> function was generated specifically for the <strong class="source-inline">Dog</strong> data type. This is copied <span class="No-Break">verbatim here:</span><pre class="source-code">
// Reverse returns a new copy of the slice with the
  elements ordered in reverse.
// This is useful when combined with Sort to get a
  descending sort order:
//
//   ss.Sort().Reverse()
//
func (ss Dogs) Reverse() Dogs {
 // Avoid the allocation. If there is one element or
    less it is already
 // reversed.
 if len(ss) &lt; 2 {
           return ss
 }
 sorted := make([]Dog, len(ss))
 for i := 0; i &lt; len(ss); i++ {
    sorted[i] = ss[len(ss)-i-1]
 }
 return sorted
}</pre></li>
				<li>We can also find <a id="_idIndexMarker562"/>the Filter and Map functions defined for the <strong class="source-inline">Dog</strong> data type. Again, these have been copied verbatim but with the <span class="No-Break">comments omitted:</span><pre class="source-code">
func (ss Dogs) Filter(condition func(Dog) bool) (ss2
    Dogs) {
 for _, s := range ss {
    if condition(s) {
 ss2 = append(ss2, s)
      }
 }
 return
}
func (ss Dogs) Map(fn func(Dog) Dog) (ss2 Dogs) {
 if ss == nil {
    return nil
 }
 ss2 = make([]Dog, len(ss))
 for i, s := range ss {
    ss2[i] = fn(s)
 }
 return
}</pre></li>
			</ol>
			<p>What this approach should highlight is that if you have many distinct types for which you are generating <a id="_idIndexMarker563"/>these functions, you are polluting your code base quite a bit with similar but not quite identical code. The executables that you are building will be larger as a result of this, and while it’s not often something that you have to think about anymore, if you are targeting a platform with limited memory availability, this might be <span class="No-Break">a showstopper.</span></p>
			<p>That said, let’s take a look at how we can use the generated functions with another example in the <strong class="source-inline">main</strong> function. First, we’ll create some dogs, each with a name and an age. Then, we will filter the dogs for those that are older than 10. These results will then get sorted based on age, and this will be printed as <span class="No-Break">the result:</span></p>
			<pre class="source-code">
func main() {
        MyDogs := []pkg.Dog{
                pkg.Dog{
                        "Bucky",
                        1,
                },
                pkg.Dog{
                        "Keeno",
                        15,
                },
                pkg.Dog{
                        "Tala",
                        16,
                },
                pkg.Dog{
                        "Amigo",
                        7,
                },
        }
        results := pkg.Dogs(MyDogs).
                Filter(func(d pkg.Dog) bool {
                        return d.Age &gt; 10
                }).SortUsing(func(a, b pkg.Dog) bool {
                return a.Age &lt; b.Age
        })
        fmt.Printf("results: %v\n", results)
}</pre>
			<p>Given <a id="_idIndexMarker564"/>this input, we get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
results: [{Keeno 15} {Tala 16}]</pre>
			<p>There are more functions to explore in Pie for a pre-generics version of Go. But let’s shift our focus now <a id="_idIndexMarker565"/>to contemporary Go code and look at libraries that we can leverage since <span class="No-Break">Go 1.18.</span></p>
			<p class="callout-heading">go generate and go environment</p>
			<p class="callout">To run <strong class="source-inline">go generate</strong> with Pie or any other executable that you download through <strong class="source-inline">go get</strong>, you need to ensure that <a id="_idIndexMarker566"/>your environment setup has been configured correctly to discover such executables. In a *nix-based system, this means that <strong class="source-inline">go/bin</strong> needs to be added to the <strong class="source-inline">$PATH</strong> variable. On Windows, you need to add <strong class="source-inline">go/bin</strong> to the environment variables. In the worst case, you can either download the GitHub source code or look for the directory where go dependencies are downloaded and build them yourself through <strong class="source-inline">go install</strong> and then move the executable to an environment location that is registered for <span class="No-Break">your system.</span></p>
			<p class="callout-heading">Pie and Hasgo</p>
			<p class="callout">For the sake of being <a id="_idIndexMarker567"/>transparent, there is another library out there that follows a similar approach to Pie but tailors the functions to a Haskell-like implementation. This library is called <strong class="bold">Hasgo</strong> (<a href="https://github.com/DylanMeeus/hasgo">https://github.com/DylanMeeus/hasgo</a>), of which I am the author. While both libraries <a id="_idIndexMarker568"/>work similarly, Pie offers more functions out of the box and fully supports Go 1.18. But if you have written Haskell before, Hasgo might feel more familiar in terms of function naming <span class="No-Break">and documentation.</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor165"/>Post-generics functional programming libraries</h1>
			<p>Functional programming libraries have seen a rise in popularity since the advent of generics in Go. No <a id="_idIndexMarker569"/>longer is it necessary to mess with the empty interface or to rely on code generation to build out the staples that make up functional programming languages. We’ll explore a few libraries in this section and see how their implementation compares. In doing so, we will stick with examples that are more or less identical but might show off some different functions from the ones we have seen so far in <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor166"/>Pie with generics</h2>
			<p>The first library that we will look at is Pie. In the previous section, we indicated that there are two <a id="_idIndexMarker570"/>versions of Pie available today: v1, which is tailored to Go before the introduction of generics, and v2, which offers the same functionality in terms of functions but leverages generics to do so. v2 is actively maintained, so I expect that over time v1 and v2 will no longer offer feature parity. That said, the Go community is pretty good at adopting the latest Go version wherever possible, so I don’t expect this to be a blocker <span class="No-Break">for anyone.</span></p>
			<p>Before we dive into the code, this is a snippet of the <strong class="source-inline">go.mod</strong> file, just to highlight which version of Pie we <span class="No-Break">are using:</span></p>
			<pre class="source-code">
go 1.18
require github.com/elliotchance/pie/v2 v2.3.0</pre>
			<p>The <strong class="source-inline">go 1.18</strong> statement indicates that we can use generics, as generics were introduced in this version. Any version above 1.18 will work for the examples that we are about <span class="No-Break">to see.</span></p>
			<p>As with the pre-generics example, we will work with the <strong class="source-inline">Dog</strong> struct and a slice of the <strong class="source-inline">[]Dog</strong> type. Unlike the previous non-generics example, we don’t need to add the compiler pragma to generate any code, nor do we need the type alias for <strong class="source-inline">[]Dog</strong> (although using this can still be good practice in a <span class="No-Break">real application):</span></p>
			<pre class="source-code">
type Dog struct {
        Name string
        Age  int
}</pre>
			<p>In the <strong class="source-inline">main</strong> function, we will create a slice of dogs. Then, we will once again filter for the dogs that are older than 10. We will then map their name to uppercase and finally return the result sorted <span class="No-Break">by age:</span></p>
			<pre class="source-code">
import<strong class="source-inline"> </strong>"github.com/elliotchance/pie/v2"
func main() {
        MyDogs := []Dog{
                Dog{
                        "Bucky",
                        1,
                },
                Dog{
                        "Keeno",
                        15,
                },
                Dog{
                        "Tala",
                        16,
                },
                Dog{
                        "Amigo",
                        7,
                },
        }
        result := pie.Of(MyDogs).
                Filter(func(d Dog) bool {
                        return d.Age &gt; 10
                }).Map(func(d Dog) Dog {
                d.Name = strings.ToUpper(d.Name)
                return d
        }).
                SortUsing(func(a, b Dog) bool {
                        return a.Age &lt; b.Age
                })
        fmt.Printf("out: %v\n", result)
}</pre>
			<p>As you can tell, the code is pretty similar to the pre-generics version. However, no code generation was used to achieve this. Also, note that <strong class="source-inline">pie.Of()</strong> figured out what type of data we are operating on. In the pre-generics version, this is part of the reason why we had to create a type alias for <strong class="source-inline">[]Dog</strong> – so that the code generator could then use Filter, Map, Reduce, or some other method for the correct slice type and attach it for dot notation-style function chaining. With generics, we no longer need to do so. In general, Pie is a good library to explore if you want to introduce generics to a team, as the familiar dot notation-style chaining of function calls looks natural to developers who are used to an object-oriented approach. As mentioned previously, it has an extensive set of functions that can be used out of the box. Next, let’s look at a library for functional programming that is based <span class="No-Break">on </span><span class="No-Break"><strong class="bold">Lodash</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor167"/>Lodash, for Go</h2>
			<p><strong class="bold">lo</strong> (<a href="https://github.com/samber/lo">https://github.com/samber/lo</a>) is a library that, similar to Pie, adds easy-to-use functions to Go and is <a id="_idIndexMarker571"/>quite popular at the <a id="_idIndexMarker572"/>moment. It is inspired by the insanely popular Lodash library for JavaScript (<a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a>), which currently has over 55,000 stars on GitHub and is <span class="No-Break">widely used.</span></p>
			<p>Currently, lo supports 38 functions that operate on slices, 16 of which operate on the Map data type, and a bunch of convenience functions for searching, tuples, channels, and (set) intersection-style operations. It’s not practical to outline all the functions here, but if you have a problem that requires operating on these common container data types, it’s a good idea to check whether this library suits your needs before reinventing the wheel. What we will do in this section is take a look at a similar example to the one we used <span class="No-Break">for Pie.</span></p>
			<h3>An example implementation with lo</h3>
			<p>As we are importing a new library, the following snippet shows the library and version that we <a id="_idIndexMarker573"/>will use for <span class="No-Break">these examples:</span></p>
			<pre class="source-code">
go 1.18
require (
        github.com/samber/lo v1.37.0
)</pre>
			<p>To demonstrate this library, we’ll once again use a <strong class="source-inline">main</strong> function and a slice of dogs. In this case, we’ll want to do the following. First, we’ll deduplicate the slice so that each element in the slice is unique. Then, we will transform the names of all dogs into uppercase variants. This is the result that we <span class="No-Break">will print:</span></p>
			<pre class="source-code">
func main() {
        result :=
                lo.Map(lo.Uniq(MyDogs), func(d Dog, i int)
                    Dog {
                        d.Name = strings.ToUpper(d.Name)
                        return d
                })
        fmt.Printf("%v\n", result)
}</pre>
			<p>In this small example, you can see how the use of the library is more reminiscent of a style chosen by (pure) functional programming languages rather than the dot notation style common to object-oriented code. We are chaining function calls by passing them as the input parameters of the higher-order function. Note that these are not lazily evaluated. In the preceding example, first, the <strong class="source-inline">Uniq</strong> function runs, which removes the duplicate entries from our input slice. Then, the <strong class="source-inline">Map</strong> function runs and applies the transformation. Remember that we are mutating the <strong class="bold">copy</strong> of the <strong class="source-inline">Dog</strong> struct by calling <strong class="source-inline">d.Name = ...</strong>, but this does not mutate the original data element. We explored this in more detail in previous chapters of <span class="No-Break">this book.</span></p>
			<p>There is one additional feature that bears calling out. <strong class="source-inline">lo</strong> contains a subset of the library supported for concurrent function calls. There is a package in <strong class="source-inline">lo</strong> under <strong class="source-inline">lo/parallel</strong> that supports the parallel evaluation of function calls. Let’s rewrite our example but have the <strong class="source-inline">Map</strong> function work concurrently. (<strong class="bold">Also, note that this package is called parallel but is talking about </strong><span class="No-Break"><strong class="bold">concurrent code</strong></span><span class="No-Break">).</span></p>
			<p>First, here’s the import statement and <span class="No-Break">import alias:</span></p>
			<pre class="source-code">
        lop "github.com/samber/lo/parallel"</pre>
			<p>Next, here’s the <a id="_idIndexMarker574"/>code to run the <strong class="source-inline">Map</strong> function concurrently, with the <strong class="source-inline">Uniq</strong> function still <span class="No-Break">running sequentially:</span></p>
			<pre class="source-code">
        result :=
                lop.Map(lo.Uniq(MyDogs), func(d Dog, i int)
                    Dog {
                        d.Name = strings.ToUpper(d.Name)
                        return d
                })
        fmt.Printf("%v\n", result)</pre>
			<p>This took almost no refactoring from our side but leveraged goroutines for concurrency. <span class="No-Break">Pretty neat!</span></p>
			<p>To close this chapter, let’s look at a library by the same author of <strong class="source-inline">lo</strong> that contains monad-like data structures such as the <strong class="source-inline">Maybe</strong> data type, which we explored in <a href="B18771_05.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>Mo, for go</h2>
			<p>Mo is a library that adds <a id="_idIndexMarker575"/>support for monad-like <a id="_idIndexMarker576"/>data structures in Go and is relatively popular. It fully supports Go 1.18+, and thus is built around generics. You can find the package itself <span class="No-Break">here: </span><a href="https://github.com/samber/mo"><span class="No-Break">https://github.com/samber/mo</span></a><span class="No-Break">.</span></p>
			<p>It’s worth taking the time to explore this library and read the documentation, especially as this could have changed by the time you read this book. In essence, it works in the same way as the <strong class="source-inline">Maybe</strong> implementation in <a href="B18771_05.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> although, in this library, that type is called <strong class="source-inline">Option</strong>. We can create a data type that optionally contains a value, but can also represent the absence of a value. This data type then supports functions to transform the data or get the data in a nil-safe way. For example, let’s create an option that contains <span class="No-Break">a dog:</span></p>
			<pre class="source-code">
func main() {
        maybe := mo.Some(Dog{"Bucky", 1})
        getOrElse := maybe.OrElse(Dog{})
        fmt.Println(getOrElse)
}</pre>
			<p>This prints <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{Bucky 1}</pre>
			<p>Now, if we were to use this to represent a <strong class="source-inline">nil</strong> value, we could still access it in a type-safe way. The <strong class="source-inline">OrElse</strong> function will ensure that a backup is used as a result of the function call, which <a id="_idIndexMarker577"/>is the default value provided <a id="_idIndexMarker578"/>by the caller. For example, let’s say we add the following code to our <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
        maybe2 := mo.None[Dog]()
        getOrElse2 := maybe2.OrElse(Dog{"Default", -1})
        fmt.Println(getOrElse2)</pre>
			<p>The output would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{Default -1}</pre>
			<p>This library supports other types as well, such as <strong class="source-inline">Future</strong> and <strong class="source-inline">Task</strong>. But one particularly useful one is the <strong class="source-inline">Result</strong> type, which is more or less like the <strong class="source-inline">Maybe</strong> type but is meant to work in cases where a value can optionally contain an error. We’ll demonstrate this in the following snippet. First, we will call the <strong class="source-inline">Ok()</strong> function, which creates the <strong class="source-inline">Result</strong> type with a valid <strong class="source-inline">Dog</strong> object. In the second case, we will create the <strong class="source-inline">Result</strong> type with an error instead of a <strong class="source-inline">Dog</strong> object. In both cases, we will try to get and print the result, as well as the <span class="No-Break">error message:</span></p>
			<pre class="source-code">
        ok := mo.Ok(MyDogs[0])
        result1 := ok.OrElse(Dog{})
        err1 := ok.Error()
        fmt.Println(result1, err1)
        err := errors.New("dog not found")
        ok2 := mo.Err[Dog](err)
        result2 := ok2.OrElse(Dog{"Default", -1})
        err2 := ok2.Error()
        fmt.Println(result2, err2)</pre>
			<p>If we run this function, we will get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
{Bucky 1} &lt;nil&gt;
{Default -1} dog not found</pre>
			<p>This shows us that based <a id="_idIndexMarker579"/>on the content <a id="_idIndexMarker580"/>of the <strong class="source-inline">error</strong> value for <strong class="source-inline">Result</strong>, the behavior of the type is different. In the first instance, where we don’t have an error, we get back the correct dog and the error is empty. In the second instance, we get back the default value that we provided as part of the <strong class="source-inline">OrElse</strong> statement, as well as the underlying <span class="No-Break">error message.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor169"/>Summary</h1>
			<p>In this chapter, we looked at libraries that implement concepts of the functional programming paradigm. We started by looking at Pie, a library that can help users in building code in the functional paradigm whether working with a code base that uses Go before or after the introduction of generics in Go 1.18. Specifically for the pre-generics version, we looked at the approach of code generation for custom types to get generics-like behavior. Pie allowed us to showcase the ease with which we can create functions such as Map and Filter since the introduction <span class="No-Break">of generics.</span></p>
			<p>Then, looked at the Lodash-inspired Go library, <strong class="source-inline">lo</strong>. This library supports common functions that operate on container data types such as slices and maps, but unlike Pie, it follows a nested approach to function chaining rather than the dot notation syntax. <strong class="source-inline">lo</strong> does offer concurrent implementations for certain functions, so if performance is a concern and concurrency seems like the right solution, checking out this library is a <span class="No-Break">good idea.</span></p>
			<p>Finally, we looked at the <strong class="source-inline">mo</strong> library, which adds monad-like data structures to Go. Specifically, we looked at the <strong class="source-inline">Option</strong> data structure, which is comparable to the <strong class="source-inline">Maybe</strong> data structure that we created in <a href="B18771_05.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. <strong class="source-inline">mo</strong> also offers a <strong class="source-inline">Result</strong> type, which is built for error handling and allows us to program more safely when dealing with potential <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> values.</span></p>
		</div>
		<div>
			<div id="_idContainer039" class="IMG---Figure">
			</div>
		</div>
	</body></html>