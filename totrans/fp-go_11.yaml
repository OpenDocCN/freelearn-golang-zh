- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Functional Programming Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程库
- en: In the previous chapters of this book, we looked at how we can leverage functional
    programming techniques in Go. In doing so, we have looked over how functions can
    be created, such as Filter, Map, Reduce, and so on. We also looked at data structures
    such as the monad and its application with the Maybe data type, which could represent
    a value that’s either present or absent without having to rely on nil.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们探讨了如何在Go中使用函数式编程技术。在这个过程中，我们查看了几种函数的创建方式，例如Filter、Map、Reduce等。我们还探讨了数据结构，如单子及其与Maybe数据类型的结合应用，它可以表示一个存在或不存在但不依赖于nil的值。
- en: As mentioned previously, these are common tools in a functional programmer’s
    toolbox. As such, there are open source libraries that have this functionality
    built in. As generics are a recent addition in Go (about 1 year ago at the time
    of writing), not all libraries currently leverage generics to implement these
    concepts. For that reason, this chapter will cover both libraries that work in
    all versions of Go, as well as libraries that will exclusively work in versions
    that support Generics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些是函数式程序员工具箱中的常用工具。因此，有一些开源库内置了这些功能。由于泛型是Go中最近添加的特性（在撰写本文时大约1年前），并非所有库都利用泛型来实现这些概念。因此，本章将涵盖适用于所有Go版本的库，以及仅适用于支持泛型的版本的库。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Pre-generics libraries for creating common FP functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建常见FP函数的预泛型库
- en: Post-generics libraries for creating common FP functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建常见FP函数的后泛型库
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, any version of Go will suffice for implementing the pre-generics
    library code. Once we move to the post-generics libraries, a version of 1.18 or
    higher will be needed to support the code. All the code can be found on GitHub
    at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，任何版本的Go都足以实现预泛型库代码。一旦我们转向后泛型库，就需要1.18或更高版本来支持代码。所有代码都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11)。
- en: There are a few things to call out before we dive deeper into this topic that
    relate somewhat to the technical requirements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨这个主题之前，有一些与技术要求相关的事项需要指出。
- en: Is the library alive – and do the examples still match it?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这个库是否仍然活跃——示例是否仍然与之匹配？
- en: 'When writing a book about a specific programming language, it is hard to write
    it in an evergreen fashion. But programming libraries are perhaps even harder
    to keep evergreen than any other content. There are two reasons for this, which
    are important to acknowledge:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当撰写一本关于特定编程语言的书籍时，很难以永恒的方式撰写它。但编程库可能比其他任何内容都更难保持永恒。这里有两大原因，这是需要承认的：
- en: The implementations can change, and versioning is not always respected.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可能会更改，并且版本控制并不总是得到尊重。
- en: The library may become unsupported in the future.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库未来可能会失去支持。
- en: The first problem, *changing implementations*, should be somewhat mitigated
    by the fact that only popular libraries will be explored in this chapter, whereby
    popularity is judged by engagement on GitHub as well as stars on GitHub. It’s
    an imperfect measure, but it’s better than not having anything to go by.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题，*更改实现*，应该会通过本章只探讨流行库这一事实得到一定程度的缓解，其中流行度是通过GitHub上的参与度和GitHub上的星标来评判的。这是一个不完美的衡量标准，但总比没有任何依据要好。
- en: I hope that these libraries respect versioning and that they limit breaking
    changes as much as possible. Still, I can’t guarantee that these libraries won’t
    change and that the functions will work as-is when you are reading this chapter.
    In the code example, I will highlight which version of the library is being shown
    so that the results can at least be recreated by fetching the correct version
    of the library, even if that is not the latest version. This brings us to the
    second, *related* problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些库尊重版本控制，并且尽可能地限制破坏性更改。尽管如此，我无法保证这些库不会更改，也无法保证你在阅读这一章时函数将按原样工作。在代码示例中，我将突出显示正在展示的库版本，以便至少可以通过获取库的正确版本来重现结果，即使这不是最新版本。这引出了第二个，*相关*问题。
- en: The library may become unsupported. If you are working with an older version
    of the library to recreate the examples in this chapter because the latest version
    introduced some breaking changes, then clearly there’s a risk that you’ll run
    into some known issues, and you might not get support as you’re using an older
    version. But, even if the examples shown here work correctly with the latest version
    of the library, the library can still be stale. If everything works as intended
    and the library is considered feature complete, that’s not immediately a red flag.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该库可能会变得不再受支持。如果您正在使用库的较旧版本来重现本章中的示例，因为最新版本引入了一些破坏性更改，那么您会遇到一些已知问题的风险，并且您可能不会得到支持，因为您正在使用较旧版本。但是，即使这里显示的示例与库的最新版本正确工作，该库仍然可能过时。如果一切按预期工作，并且库被认为是功能完整的，这并不立即是一个红旗。
- en: However, it does mean that finding these libraries can be hard. The best way
    to determine this is by looking for any activity on the GitHub (or GitLab) page.
    For example, is the most recent commit only a few days or weeks ago, or is it
    years in the past? Are the contributors actively responding to tickets or do they
    all go unanswered? Are they engaging with their community over Discord or IRC?
    These are all examples that can hint at how well maintained a library is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着找到这些库可能会有困难。确定这一点最好的方法是通过查看GitHub（或GitLab）页面上的任何活动。例如，最近的提交是在几天或几周前，还是几年前？贡献者是否积极回应问题，或者他们是否都未得到回复？他们是否在Discord或IRC上与社区互动？这些都是可以暗示库维护得如何的例子。
- en: Legal requirements
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 法律要求
- en: I’ll keep this part brief, as I am not a lawyer. But anyone dealing with open
    source code should be aware that not all open source code is permissive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我会简要介绍这部分内容，因为我不是律师。但是，任何处理开源代码的人都应该意识到，并非所有开源代码都是许可的。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before working with a library, especially in a commercial context, be sure to
    review the software license and confirm that your use case is legally allowed
    and under which conditions. (For example, some licenses will allow the use of
    the code with attribution. Others will only allow for non-commercial use cases
    and so on.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在与库合作之前，尤其是在商业环境中，务必审查软件许可，并确认您的用例在法律上是允许的，以及哪些条件下允许。（例如，某些许可允许带有归属的使用代码。其他许可可能仅允许非商业用途，等等。）
- en: Pre-generics libraries for creating common FP functions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于创建常见函数的前泛型库
- en: With or without generics, it is common to operate on collection-style data structures
    in any programming language. Storing a series of values, whether it is a list
    of numbers representing scores on a test or a collection of structs such as all
    employees working in a hospital, is common enough that you’ll run into these data
    structures sooner rather than later. The operations that are performed on these
    can also fall into a few categories, especially once we abstract them into higher-order
    functions. You either have to modify the data elements in some way (for example,
    multiplying all the values by two) or modify the container in some way (for example,
    removing all the odd numbers). As we have seen, rather than implementing a function
    such as `removeOdds` or `multiplyNumbers`, what we’d like to write is just a function
    that can filter any element based on a predicate or change an element based on
    a transformation (these are the Filter and Map functions, respectively).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否有泛型，在任何编程语言中操作集合式数据结构是很常见的。存储一系列值，无论是代表测试分数的数字列表，还是医院中所有员工的集合结构，都是如此常见，以至于您迟早会遇到这些数据结构。对这些数据结构执行的操作也可以归入几个类别，尤其是当我们将它们抽象为高阶函数时。您可能必须以某种方式修改数据元素（例如，将所有值乘以二）或以某种方式修改容器（例如，删除所有奇数）。正如我们所见，我们不想实现一个像`removeOdds`或`multiplyNumbers`这样的函数，我们想写的是一个可以根据谓词过滤任何元素或根据转换修改元素的函数（这些分别是过滤和映射函数）。
- en: Before generics were introduced, there was no clear and best way to handle this.
    The reasoning for not abstracting these use cases, at the time, was that writing
    functions specific to your data structure would deliver the best results in terms
    of performance. So, you’d give up a bit of developer comfort but would get a more
    performant application in return. In hindsight, many of the operations on collections
    have an identical implementation, which means there’s no real performance difference.
    It’s only a natural consequence that people came up with ways of building abstractions
    for repeating implementations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛型引入之前，没有明确且最佳的方式来处理这个问题。当时不抽象这些用例的理由是，针对你的数据结构编写特定函数会在性能方面提供最佳结果。所以，你会放弃一些开发者舒适度，但会得到一个性能更好的应用程序。事后看来，集合上的许多操作具有相同的实现，这意味着实际上没有真正的性能差异。人们想出构建重复实现抽象的方法，这只是一个自然的结果。
- en: Broadly speaking, there are two ways this problem could be tackled before the
    introduction of generics – either by programming against the empty interface (`interface{}`),
    an interface that any data type implicitly adheres to in Go, or through code generation.
    The former, programming against `interface{}`, has too many disadvantages in terms
    of typesafety and runtimesafety to advocate strongly for it. But the latter, code
    generation, is still interesting to look at, if only because code generation could
    still be useful in a post-generics world albeit for different use cases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 广义而言，在泛型引入之前，有两条途径可以解决这个问题——要么通过针对空接口（`interface{}`）编程，这是一个任何数据类型在Go中隐式遵守的接口，要么通过代码生成。前者，针对`interface{}`的编程，在类型安全和运行时安全方面有太多的缺点，因此不太可能强烈推荐。但后者，代码生成，仍然值得一看，仅仅是因为代码生成在泛型世界之后仍然可能有用，尽管适用于不同的用例。
- en: Libraries versus custom implementations
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 库与自定义实现
- en: 'In this book, we have seen ways to create our own set of functions that follow
    the functional programming paradigm. Libraries might offer a more efficient implementation
    and can prevent you from reinventing the wheel. However, if you want to keep your
    dependency graph lightweight, it is much easier to do so by providing a few implementations
    yourself now that Go has: generics. In a pre-generics version of Go, this was
    much harder and I’d favor the library-based approach. Neither the empty interface-based
    approach nor the code generation approach is easy to implement without errors
    and headaches.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们看到了创建遵循函数式编程范式的自定义函数集的方法。库可能提供更高效的实现，并可以防止你重新发明轮子。然而，如果你想保持你的依赖图轻量级，现在Go有了泛型，自己提供一些实现会更容易。在泛型引入之前的Go版本中，这样做要困难得多，我更倾向于基于库的方法。无论是基于空接口的方法还是代码生成的方法，在没有错误和头痛的情况下实现都不是很容易。
- en: Code generation libraries for pre-generics Go
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型之前的Go代码生成库
- en: 'Code generation, as the name implies, is a technique for generating Go code
    that can then be used like regular Go code in our application. The Go toolchain
    has all the necessary tools to do this out of the box. In Go, it is possible to
    add comments to your code that the compiler will interpret as commands. Such comments
    make it possible to trigger a special operation during the compile time of your
    program. These comments are called **pragma**. For example, you can add a comment
    to a function that will tell the compiler to avoid in-lining this function (the
    compiler can ignore it, so it’s more a suggestion than a command):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，代码生成是一种生成Go代码的技术，然后我们可以像使用常规Go代码一样在我们的应用程序中使用它。Go工具链提供了所有必要的工具来实现这一点。在Go中，你可以给你的代码添加注释，编译器会将其解释为命令。这些注释使得在程序编译时触发特殊操作成为可能。这些注释被称为**指令**。例如，你可以在一个函数上添加注释，告诉编译器避免内联这个函数（编译器可以忽略它，所以这更像是一个建议而不是命令）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The idea behind the code generation library, which we will explore shortly,
    is that using these special comments can trigger the generation of functions for
    a specific type, which implements the common functional programming operations
    such as filtering, mapping, reducing, and so on. The first library that we will
    explore, Pie, works in exactly this way.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成库背后的想法，我们将在稍后探讨，是使用这些特殊的注释可以触发为特定类型生成函数，这些函数实现了常见的函数式编程操作，如过滤、映射、归约等。我们将要探讨的第一个库，Pie，正是以这种方式工作的。
- en: A slice of Pie
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pie的切片
- en: 'The library that we will explore is **Pie**, written by Elliot Chance and available
    on GitHub here: [https://github.com/elliotchance/pie/tree/master/v1](https://github.com/elliotchance/pie/tree/master/v1).
    This library is available in two versions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的库是由 Elliot Chance 编写的 **Pie**，可在 GitHub 上找到：[https://github.com/elliotchance/pie/tree/master/v1](https://github.com/elliotchance/pie/tree/master/v1)。此库有两个版本：
- en: Version 1 focuses on Go at or below 1.17
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 1 专注于 Go 1.17 或更低版本
- en: Version 2 is the newer version for working with generics and needs Go 1.18 or
    above to work
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 2 是用于处理泛型的较新版本，需要 Go 1.18 或更高版本才能运行
- en: In version 1, there are two ways of using this library. You can either use the
    functions directly to operate on common data types (`[]string`, `[]float64`, or
    `[]int`), or you can use this library to generate functions for your own data
    type. First, we’ll explore the built-in structures and then move on to generating
    functions for custom types.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 1 中，有两种使用此库的方法。您可以直接使用函数来操作常见数据类型（`[]string`、`[]float64` 或 `[]int`），或者您可以使用此库为您自己的数据类型生成函数。首先，我们将探索内置结构，然后转向为自定义类型生成函数。
- en: Using the built-in functions of Pie
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Pie 的内置函数
- en: 'Pie supports built-in functions for three data types:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Pie 支持三种数据类型的内置函数：
- en: '`[]``string`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]string`'
- en: '`[]``float64`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]float64`'
- en: '`[]``int`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]int`'
- en: 'These are quite common, so it makes sense that these are supported by default.
    In the examples throughout this book, we have shown how we can filter a slice
    of integers to retain only the even numbers. Then, we squared them by using the
    Map function. Doing this in Pie is easy and follows the same idea as the code
    that we implemented in [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101) and beyond.
    As we are doing this through the use of a library, let’s first take a look at
    the content of the `go.mod` file to highlight which version of Pie we are using:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相当常见，因此默认支持这些功能是有意义的。在本书的各个示例中，我们已经展示了如何过滤整数切片以保留仅偶数。然后，我们使用 Map 函数对它们进行平方。在
    Pie 中这样做很容易，并且遵循与我们之前在 [*第 6 章*](B18771_06.xhtml#_idTextAnchor101) 和之后实现的代码相同的思路。由于我们是通过使用库来完成这项工作的，让我们首先查看
    `go.mod` 文件的内容，以突出显示我们正在使用 Pie 的哪个版本：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is showing `go 1.17` as we are explicitly looking at libraries that can
    be used before generics were introduced.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示的是 `go 1.17`，因为我们明确地正在查看在泛型引入之前可以使用的库。
- en: 'Now that we have imported the library (after running `go get`), we can use
    it in our application. Let’s build the Filter and Map example, as explained earlier:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了库（在运行 `go get` 之后），我们可以在我们的应用程序中使用它。让我们构建前面解释过的 Filter 和 Map 示例：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running this code will output `result: [4 16 36 64 100]`, as expected. Pie
    allows us to build and chain functions together, similar to what we have seen
    in this book so far. Out of the box, this only works for slices of strings, ints,
    and float64s. Each of these requires a custom implementation in the library. By
    attaching the function to a concrete type, it can support multiple Filter and
    Map functions defined for distinct data types. This is also something that we
    have looked at doing ourselves, and as pointed out, this is a time-consuming and
    repetitive undertaking.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '运行此代码将输出 `result: [4 16 36 64 100]`，正如预期的那样。Pie 允许我们构建和链式调用函数，类似于我们在本书中迄今为止所看到的。开箱即用，这仅适用于字符串切片、整数和
    float64。每种类型都需要在库中进行自定义实现。通过将函数附加到具体类型，它可以支持为不同数据类型定义的多个 Filter 和 Map 函数。这也是我们自己考虑过要做的事情，正如所指出的，这是一项耗时且重复的工作。'
- en: What Pie does is remove some of this repetitive work by using code generation
    to generate the implementation for each data type. The details of how code generation
    works in this library are beyond the scope of this book, but I’d encourage checking
    out the library itself on GitHub and diving into the code to get a better appreciation
    for how this was built as it is genuinely quite interesting.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Pie 通过使用代码生成来生成每种数据类型的实现，从而减少了这部分重复工作。在这个库中代码生成是如何工作的细节超出了本书的范围，但我鼓励您在 GitHub
    上查看这个库本身，并深入研究代码，以更好地理解它是如何构建的，因为这确实非常有趣。
- en: Pie ships with a lot of functions. To get an up-to-date listing with a description
    of each, take a look at the wiki at [https://github.com/elliotchance/pie/tree/master/v1](https://github.com/elliotchance/pie/tree/master/v1).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Pie 随带了许多函数。要获取每个函数的最新列表及其描述，请查看 [https://github.com/elliotchance/pie/tree/master/v1](https://github.com/elliotchance/pie/tree/master/v1)
    上的 wiki。
- en: Pie for custom data types
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pie 用于自定义数据类型
- en: 'If we want to use Pie for our own data type, we need to generate the code to
    do this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为我们的自定义数据类型使用Pie，我们需要生成执行此操作的代码：
- en: 'First, let’s set up a struct that we can use in all the following examples.
    We’ll create a struct to represent a dog, and also a type alias for a slice of
    the `[]``Dog` type:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个结构体，我们可以在所有以下示例中使用它。我们将创建一个表示狗的结构体，并为`[]Dog`类型创建一个类型别名：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this set up, we can run the `go generate` command and generate all of
    Pie’s functions for our custom data type. This created a new file, `dogs_pie.go`,
    in the same directory as our type definitions. By looking through the generated
    file, we can see which functions were generated. For example, the `Reverse` function
    was generated specifically for the `Dog` data type. This is copied verbatim here:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置好之后，我们可以运行`go generate`命令，为我们的自定义数据类型生成Pie的所有函数。这在我们类型定义所在的目录中创建了一个新的文件`dogs_pie.go`。通过查看生成的文件，我们可以看到哪些函数被生成。例如，`Reverse`函数是专门为`Dog`数据类型生成的。这里逐字复制如下：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also find the Filter and Map functions defined for the `Dog` data type.
    Again, these have been copied verbatim but with the comments omitted:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以找到为`Dog`数据类型定义的Filter和Map函数。同样，这些函数是逐字复制的，但注释已被省略：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What this approach should highlight is that if you have many distinct types
    for which you are generating these functions, you are polluting your code base
    quite a bit with similar but not quite identical code. The executables that you
    are building will be larger as a result of this, and while it’s not often something
    that you have to think about anymore, if you are targeting a platform with limited
    memory availability, this might be a showstopper.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应该强调的是，如果您为许多不同的类型生成这些函数，您将在代码库中添加大量相似但不完全相同的代码。由于这个原因，您构建的可执行文件将更大，尽管这不再是您经常需要考虑的事情，但如果您针对的是内存可用性有限的平台，这可能会成为障碍。
- en: 'That said, let’s take a look at how we can use the generated functions with
    another example in the `main` function. First, we’ll create some dogs, each with
    a name and an age. Then, we will filter the dogs for those that are older than
    10\. These results will then get sorted based on age, and this will be printed
    as the result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们看看如何在`main`函数中的另一个示例中利用生成的函数。首先，我们将创建一些狗，每只狗都有一个名字和年龄。然后，我们将过滤出年龄大于10岁的狗。这些结果将根据年龄排序，并将作为结果打印出来：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given this input, we get the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个输入，我们得到以下输出：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are more functions to explore in Pie for a pre-generics version of Go.
    But let’s shift our focus now to contemporary Go code and look at libraries that
    we can leverage since Go 1.18.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pie中，对于Go的预泛型版本，还有更多功能可以探索。但现在让我们将焦点转移到当代Go代码上，看看自Go 1.18以来我们可以利用的库。
- en: go generate and go environment
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: go generate和go环境
- en: To run `go generate` with Pie or any other executable that you download through
    `go get`, you need to ensure that your environment setup has been configured correctly
    to discover such executables. In a *nix-based system, this means that `go/bin`
    needs to be added to the `$PATH` variable. On Windows, you need to add `go/bin`
    to the environment variables. In the worst case, you can either download the GitHub
    source code or look for the directory where go dependencies are downloaded and
    build them yourself through `go install` and then move the executable to an environment
    location that is registered for your system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Pie或通过`go get`下载的任何其他可执行文件运行`go generate`，您需要确保您的环境设置已正确配置，以便发现此类可执行文件。在基于*nix的系统上，这意味着需要将`go/bin`添加到`$PATH`变量中。在Windows上，您需要将`go/bin`添加到环境变量中。在最坏的情况下，您可以下载GitHub源代码或查找下载go依赖项的目录，并通过`go
    install`自行构建它们，然后将可执行文件移动到已为您系统注册的环境位置。
- en: Pie and Hasgo
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图和Hasgo
- en: For the sake of being transparent, there is another library out there that follows
    a similar approach to Pie but tailors the functions to a Haskell-like implementation.
    This library is called **Hasgo** ([https://github.com/DylanMeeus/hasgo](https://github.com/DylanMeeus/hasgo)),
    of which I am the author. While both libraries work similarly, Pie offers more
    functions out of the box and fully supports Go 1.18\. But if you have written
    Haskell before, Hasgo might feel more familiar in terms of function naming and
    documentation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持透明度，还有一个库遵循与 Pie 类似的方法，但将函数定制为类似 Haskell 的实现。这个库叫做 **Hasgo** ([https://github.com/DylanMeeus/hasgo](https://github.com/DylanMeeus/hasgo))，我是它的作者。虽然这两个库的工作方式相似，但
    Pie 提供了更多的内置函数，并且完全支持 Go 1.18。但是，如果你之前编写过 Haskell，Hasgo 在函数命名和文档方面可能感觉更熟悉。
- en: Post-generics functional programming libraries
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型之后的函数式编程库
- en: Functional programming libraries have seen a rise in popularity since the advent
    of generics in Go. No longer is it necessary to mess with the empty interface
    or to rely on code generation to build out the staples that make up functional
    programming languages. We’ll explore a few libraries in this section and see how
    their implementation compares. In doing so, we will stick with examples that are
    more or less identical but might show off some different functions from the ones
    we have seen so far in this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Go 中引入泛型以来，函数式编程库的受欢迎程度有所上升。不再需要与空接口纠缠，也不必依赖代码生成来构建构成函数式编程语言的基础。在本节中，我们将探索几个库，并比较它们的实现方式。在这样做的时候，我们将坚持使用大致相同但可能展示一些与本书中迄今为止所见不同的函数的示例。
- en: Pie with generics
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有泛型的 Pie
- en: 'The first library that we will look at is Pie. In the previous section, we
    indicated that there are two versions of Pie available today: v1, which is tailored
    to Go before the introduction of generics, and v2, which offers the same functionality
    in terms of functions but leverages generics to do so. v2 is actively maintained,
    so I expect that over time v1 and v2 will no longer offer feature parity. That
    said, the Go community is pretty good at adopting the latest Go version wherever
    possible, so I don’t expect this to be a blocker for anyone.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个库是 Pie。在上一节中，我们指出目前有两个版本的 Pie 可用：v1，它针对泛型引入之前的 Go 进行了定制；v2，它提供了相同的功能，但利用泛型来实现。v2
    正在积极维护，因此我预计随着时间的推移，v1 和 v2 将不再提供功能对等。尽管如此，Go 社区在尽可能的地方都很好地采用了最新的 Go 版本，所以我不认为这会成为任何人的障碍。
- en: 'Before we dive into the code, this is a snippet of the `go.mod` file, just
    to highlight which version of Pie we are using:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，这是 `go.mod` 文件的片段，只是为了突出我们正在使用 Pie 的哪个版本：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `go 1.18` statement indicates that we can use generics, as generics were
    introduced in this version. Any version above 1.18 will work for the examples
    that we are about to see.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`go 1.18` 语句表示我们可以使用泛型，因为泛型是在这个版本中引入的。任何高于 1.18 的版本都将适用于我们即将看到的示例。'
- en: 'As with the pre-generics example, we will work with the `Dog` struct and a
    slice of the `[]Dog` type. Unlike the previous non-generics example, we don’t
    need to add the compiler pragma to generate any code, nor do we need the type
    alias for `[]Dog` (although using this can still be good practice in a real application):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与泛型之前的示例一样，我们将使用 `Dog` 结构体和 `[]Dog` 类型的切片。与之前的非泛型示例不同，我们不需要添加编译器指令来生成任何代码，也不需要为
    `[]Dog` 添加类型别名（尽管在实际应用中使用它仍然是一种好的实践）：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `main` function, we will create a slice of dogs. Then, we will once
    again filter for the dogs that are older than 10\. We will then map their name
    to uppercase and finally return the result sorted by age:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们将创建一个狗的切片。然后，我们将再次筛选出年龄大于 10 岁的狗。然后，我们将它们的名称映射为大写，最后按年龄返回排序后的结果：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can tell, the code is pretty similar to the pre-generics version. However,
    no code generation was used to achieve this. Also, note that `pie.Of()` figured
    out what type of data we are operating on. In the pre-generics version, this is
    part of the reason why we had to create a type alias for `[]Dog` – so that the
    code generator could then use Filter, Map, Reduce, or some other method for the
    correct slice type and attach it for dot notation-style function chaining. With
    generics, we no longer need to do so. In general, Pie is a good library to explore
    if you want to introduce generics to a team, as the familiar dot notation-style
    chaining of function calls looks natural to developers who are used to an object-oriented
    approach. As mentioned previously, it has an extensive set of functions that can
    be used out of the box. Next, let’s look at a library for functional programming
    that is based on **Lodash**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码与预泛型版本非常相似。然而，没有使用代码生成来实现这一点。此外，请注意 `pie.Of()` 确定了我们正在操作的数据类型。在预泛型版本中，这是我们必须为
    `[]Dog` 创建类型别名的原因之一——这样代码生成器就可以使用 Filter、Map、Reduce 或其他方法为正确的切片类型附加它，并用于点符号风格的函数链式调用。有了泛型，我们就不再需要这样做。一般来说，如果你想在团队中引入泛型，Pie
    是一个很好的库去探索，因为熟悉点符号风格的函数调用链对于习惯了面向对象方法的开发者来说看起来很自然。如前所述，它有一套广泛的函数可以直接使用。接下来，让我们看看一个基于
    **Lodash** 的函数式编程库。
- en: Lodash, for Go
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lodash，适用于 Go
- en: '**lo** ([https://github.com/samber/lo](https://github.com/samber/lo)) is a
    library that, similar to Pie, adds easy-to-use functions to Go and is quite popular
    at the moment. It is inspired by the insanely popular Lodash library for JavaScript
    ([https://github.com/lodash/lodash](https://github.com/lodash/lodash)), which
    currently has over 55,000 stars on GitHub and is widely used.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**lo** ([https://github.com/samber/lo](https://github.com/samber/lo)) 是一个库，类似于
    Pie，它为 Go 添加了易于使用的功能，并且目前非常受欢迎。它受到了 JavaScript 中极其流行的 Lodash 库 ([https://github.com/lodash/lodash](https://github.com/lodash/lodash))
    的启发，该库目前在 GitHub 上有超过 55,000 个星标，并且被广泛使用。'
- en: Currently, lo supports 38 functions that operate on slices, 16 of which operate
    on the Map data type, and a bunch of convenience functions for searching, tuples,
    channels, and (set) intersection-style operations. It’s not practical to outline
    all the functions here, but if you have a problem that requires operating on these
    common container data types, it’s a good idea to check whether this library suits
    your needs before reinventing the wheel. What we will do in this section is take
    a look at a similar example to the one we used for Pie.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，lo 支持 38 个在切片上操作的功能，其中 16 个操作在 Map 数据类型上，还有许多方便的搜索、元组、通道和（集合）交集样式操作的功能。在这里概述所有这些功能并不实际，但如果你的问题需要操作这些常见的容器数据类型，那么在重新发明轮子之前检查这个库是否满足你的需求是个好主意。在本节中，我们将查看一个与用于
    Pie 的示例类似的例子。
- en: An example implementation with lo
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 lo 的一个示例实现
- en: 'As we are importing a new library, the following snippet shows the library
    and version that we will use for these examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在导入一个新的库，以下代码片段显示了我们将用于这些示例的库及其版本：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To demonstrate this library, we’ll once again use a `main` function and a slice
    of dogs. In this case, we’ll want to do the following. First, we’ll deduplicate
    the slice so that each element in the slice is unique. Then, we will transform
    the names of all dogs into uppercase variants. This is the result that we will
    print:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个库，我们还将使用一个 `main` 函数和狗的切片。在这种情况下，我们想要做以下事情。首先，我们将去除切片中的重复项，以确保切片中的每个元素都是唯一的。然后，我们将所有狗的名字转换为大写形式。这是我们将会打印的结果：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this small example, you can see how the use of the library is more reminiscent
    of a style chosen by (pure) functional programming languages rather than the dot
    notation style common to object-oriented code. We are chaining function calls
    by passing them as the input parameters of the higher-order function. Note that
    these are not lazily evaluated. In the preceding example, first, the `Uniq` function
    runs, which removes the duplicate entries from our input slice. Then, the `Map`
    function runs and applies the transformation. Remember that we are mutating the
    `Dog` struct by calling `d.Name = ...`, but this does not mutate the original
    data element. We explored this in more detail in previous chapters of this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小型示例中，您可以看到库的使用更像是（纯）函数式编程语言选择的一种风格，而不是面向对象代码中常见的点符号风格。我们通过将它们作为高阶函数的输入参数来链式调用函数调用。请注意，这些不是惰性求值的。在前面的示例中，首先运行
    `Uniq` 函数，它从我们的输入切片中删除重复条目。然后运行 `Map` 函数并应用转换。记住，我们通过调用 `d.Name = ...` 来修改 `Dog`
    结构体，但这不会修改原始数据元素。我们在这本书的前几章中对此进行了更详细的探讨。
- en: There is one additional feature that bears calling out. `lo` contains a subset
    of the library supported for concurrent function calls. There is a package in
    `lo` under `lo/parallel` that supports the parallel evaluation of function calls.
    Let’s rewrite our example but have the `Map` function work concurrently. (**Also,
    note that this package is called parallel but is talking about** **concurrent
    code**).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个额外的功能值得指出。`lo` 包含了支持并发函数调用的库的子集。在 `lo` 的 `lo/parallel` 目录下有一个包，支持函数调用的并行评估。让我们重写我们的示例，但让
    `Map` 函数以并发方式工作。（**此外，请注意，这个包被称为 parallel，但讨论的是** **并发代码**）。
- en: 'First, here’s the import statement and import alias:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是导入语句和导入别名：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, here’s the code to run the `Map` function concurrently, with the `Uniq`
    function still running sequentially:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是运行 `Map` 函数的并发代码，而 `Uniq` 函数仍然按顺序运行：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This took almost no refactoring from our side but leveraged goroutines for concurrency.
    Pretty neat!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎不需要我们进行重构，但利用了 goroutines 来实现并发。相当不错！
- en: To close this chapter, let’s look at a library by the same author of `lo` that
    contains monad-like data structures such as the `Maybe` data type, which we explored
    in [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，让我们看看由 `lo` 的同一作者编写的一个库，该库包含类似于 monad 的数据结构，例如我们曾在 [*第五章*](B18771_05.xhtml#_idTextAnchor085)
    中探讨的 `Maybe` 数据类型。
- en: Mo, for go
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mo，为 go
- en: 'Mo is a library that adds support for monad-like data structures in Go and
    is relatively popular. It fully supports Go 1.18+, and thus is built around generics.
    You can find the package itself here: [https://github.com/samber/mo](https://github.com/samber/mo).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Mo 是一个在 Go 中添加对类似 monad 数据结构支持的库，并且相对流行。它完全支持 Go 1.18+，因此是围绕泛型构建的。您可以在以下位置找到该包本身：[https://github.com/samber/mo](https://github.com/samber/mo)。
- en: 'It’s worth taking the time to explore this library and read the documentation,
    especially as this could have changed by the time you read this book. In essence,
    it works in the same way as the `Maybe` implementation in [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085)
    although, in this library, that type is called `Option`. We can create a data
    type that optionally contains a value, but can also represent the absence of a
    value. This data type then supports functions to transform the data or get the
    data in a nil-safe way. For example, let’s create an option that contains a dog:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花时间探索这个库并阅读文档，特别是当您阅读这本书时，这可能已经发生了变化。本质上，它的工作方式与 [*第五章*](B18771_05.xhtml#_idTextAnchor085)
    中的 `Maybe` 实现相同，尽管在这个库中，该类型被称为 `Option`。我们可以创建一个可选包含值的类型，但也可以表示值的缺失。然后，这个数据类型支持转换数据或以
    nil 安全的方式获取数据的函数。例如，让我们创建一个包含狗的选项：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This prints the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, if we were to use this to represent a `nil` value, we could still access
    it in a type-safe way. The `OrElse` function will ensure that a backup is used
    as a result of the function call, which is the default value provided by the caller.
    For example, let’s say we add the following code to our `main` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用这个来表示 `nil` 值，我们仍然可以以类型安全的方式访问它。`OrElse` 函数将确保使用备份作为函数调用的结果，这是调用者提供的默认值。例如，让我们在我们的
    `main` 函数中添加以下代码：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output would look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This library supports other types as well, such as `Future` and `Task`. But
    one particularly useful one is the `Result` type, which is more or less like the
    `Maybe` type but is meant to work in cases where a value can optionally contain
    an error. We’ll demonstrate this in the following snippet. First, we will call
    the `Ok()` function, which creates the `Result` type with a valid `Dog` object.
    In the second case, we will create the `Result` type with an error instead of
    a `Dog` object. In both cases, we will try to get and print the result, as well
    as the error message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库还支持其他类型，例如`Future`和`Task`。但其中一个特别有用的类型是`Result`类型，它或多或少类似于`Maybe`类型，但旨在处理值可以可选地包含错误的情况。我们将在下面的代码片段中演示这一点。首先，我们将调用`Ok()`函数，它使用有效的`Dog`对象创建`Result`类型。在第二种情况下，我们将使用错误而不是`Dog`对象来创建`Result`类型。在这两种情况下，我们将尝试获取并打印结果以及错误信息：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we run this function, we will get the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个函数，我们将得到以下输出：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This shows us that based on the content of the `error` value for `Result`, the
    behavior of the type is different. In the first instance, where we don’t have
    an error, we get back the correct dog and the error is empty. In the second instance,
    we get back the default value that we provided as part of the `OrElse` statement,
    as well as the underlying error message.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明根据`Result`的`error`值的内容，类型的行为是不同的。在第一种情况下，我们没有错误，我们得到正确的狗，错误为空。在第二种情况下，我们得到作为`OrElse`语句一部分提供的默认值，以及底层错误信息。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at libraries that implement concepts of the functional
    programming paradigm. We started by looking at Pie, a library that can help users
    in building code in the functional paradigm whether working with a code base that
    uses Go before or after the introduction of generics in Go 1.18\. Specifically
    for the pre-generics version, we looked at the approach of code generation for
    custom types to get generics-like behavior. Pie allowed us to showcase the ease
    with which we can create functions such as Map and Filter since the introduction
    of generics.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了实现函数式编程范式概念的库。我们首先了解了Pie库，这个库可以帮助用户在Go 1.18引入泛型之前或之后使用Go构建函数式编程的代码。特别是对于泛型之前的版本，我们研究了为自定义类型生成代码以获得类似泛型行为的方法。Pie库使我们能够展示自从引入泛型以来，我们能够多么容易地创建如Map和Filter之类的函数。
- en: Then, looked at the Lodash-inspired Go library, `lo`. This library supports
    common functions that operate on container data types such as slices and maps,
    but unlike Pie, it follows a nested approach to function chaining rather than
    the dot notation syntax. `lo` does offer concurrent implementations for certain
    functions, so if performance is a concern and concurrency seems like the right
    solution, checking out this library is a good idea.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了受Lodash启发的Go库`lo`。这个库支持在切片和映射等容器数据类型上操作的一些常见函数，但与Pie不同，它采用嵌套方法进行函数链式调用，而不是点符号语法。`lo`库为某些函数提供了并发实现，所以如果性能是一个关注点，并且并发似乎是正确的解决方案，那么检查这个库是个好主意。
- en: Finally, we looked at the `mo` library, which adds monad-like data structures
    to Go. Specifically, we looked at the `Option` data structure, which is comparable
    to the `Maybe` data structure that we created in [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085).
    `mo` also offers a `Result` type, which is built for error handling and allows
    us to program more safely when dealing with potential `error` values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了添加到Go中的类似monad的数据结构库`mo`。具体来说，我们探讨了`Option`数据结构，它与我们在[*第五章*](B18771_05.xhtml#_idTextAnchor085)中创建的`Maybe`数据结构类似。`mo`还提供了一个`Result`类型，它是为错误处理而构建的，并允许我们在处理潜在的`error`值时编写更安全的代码。
