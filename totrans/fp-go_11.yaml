- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Programming Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters of this book, we looked at how we can leverage functional
    programming techniques in Go. In doing so, we have looked over how functions can
    be created, such as Filter, Map, Reduce, and so on. We also looked at data structures
    such as the monad and its application with the Maybe data type, which could represent
    a value that’s either present or absent without having to rely on nil.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, these are common tools in a functional programmer’s
    toolbox. As such, there are open source libraries that have this functionality
    built in. As generics are a recent addition in Go (about 1 year ago at the time
    of writing), not all libraries currently leverage generics to implement these
    concepts. For that reason, this chapter will cover both libraries that work in
    all versions of Go, as well as libraries that will exclusively work in versions
    that support Generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-generics libraries for creating common FP functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-generics libraries for creating common FP functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, any version of Go will suffice for implementing the pre-generics
    library code. Once we move to the post-generics libraries, a version of 1.18 or
    higher will be needed to support the code. All the code can be found on GitHub
    at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things to call out before we dive deeper into this topic that
    relate somewhat to the technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Is the library alive – and do the examples still match it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing a book about a specific programming language, it is hard to write
    it in an evergreen fashion. But programming libraries are perhaps even harder
    to keep evergreen than any other content. There are two reasons for this, which
    are important to acknowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: The implementations can change, and versioning is not always respected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library may become unsupported in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first problem, *changing implementations*, should be somewhat mitigated
    by the fact that only popular libraries will be explored in this chapter, whereby
    popularity is judged by engagement on GitHub as well as stars on GitHub. It’s
    an imperfect measure, but it’s better than not having anything to go by.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that these libraries respect versioning and that they limit breaking
    changes as much as possible. Still, I can’t guarantee that these libraries won’t
    change and that the functions will work as-is when you are reading this chapter.
    In the code example, I will highlight which version of the library is being shown
    so that the results can at least be recreated by fetching the correct version
    of the library, even if that is not the latest version. This brings us to the
    second, *related* problem.
  prefs: []
  type: TYPE_NORMAL
- en: The library may become unsupported. If you are working with an older version
    of the library to recreate the examples in this chapter because the latest version
    introduced some breaking changes, then clearly there’s a risk that you’ll run
    into some known issues, and you might not get support as you’re using an older
    version. But, even if the examples shown here work correctly with the latest version
    of the library, the library can still be stale. If everything works as intended
    and the library is considered feature complete, that’s not immediately a red flag.
  prefs: []
  type: TYPE_NORMAL
- en: However, it does mean that finding these libraries can be hard. The best way
    to determine this is by looking for any activity on the GitHub (or GitLab) page.
    For example, is the most recent commit only a few days or weeks ago, or is it
    years in the past? Are the contributors actively responding to tickets or do they
    all go unanswered? Are they engaging with their community over Discord or IRC?
    These are all examples that can hint at how well maintained a library is.
  prefs: []
  type: TYPE_NORMAL
- en: Legal requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ll keep this part brief, as I am not a lawyer. But anyone dealing with open
    source code should be aware that not all open source code is permissive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before working with a library, especially in a commercial context, be sure to
    review the software license and confirm that your use case is legally allowed
    and under which conditions. (For example, some licenses will allow the use of
    the code with attribution. Others will only allow for non-commercial use cases
    and so on.)
  prefs: []
  type: TYPE_NORMAL
- en: Pre-generics libraries for creating common FP functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With or without generics, it is common to operate on collection-style data structures
    in any programming language. Storing a series of values, whether it is a list
    of numbers representing scores on a test or a collection of structs such as all
    employees working in a hospital, is common enough that you’ll run into these data
    structures sooner rather than later. The operations that are performed on these
    can also fall into a few categories, especially once we abstract them into higher-order
    functions. You either have to modify the data elements in some way (for example,
    multiplying all the values by two) or modify the container in some way (for example,
    removing all the odd numbers). As we have seen, rather than implementing a function
    such as `removeOdds` or `multiplyNumbers`, what we’d like to write is just a function
    that can filter any element based on a predicate or change an element based on
    a transformation (these are the Filter and Map functions, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: Before generics were introduced, there was no clear and best way to handle this.
    The reasoning for not abstracting these use cases, at the time, was that writing
    functions specific to your data structure would deliver the best results in terms
    of performance. So, you’d give up a bit of developer comfort but would get a more
    performant application in return. In hindsight, many of the operations on collections
    have an identical implementation, which means there’s no real performance difference.
    It’s only a natural consequence that people came up with ways of building abstractions
    for repeating implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Broadly speaking, there are two ways this problem could be tackled before the
    introduction of generics – either by programming against the empty interface (`interface{}`),
    an interface that any data type implicitly adheres to in Go, or through code generation.
    The former, programming against `interface{}`, has too many disadvantages in terms
    of typesafety and runtimesafety to advocate strongly for it. But the latter, code
    generation, is still interesting to look at, if only because code generation could
    still be useful in a post-generics world albeit for different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries versus custom implementations
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we have seen ways to create our own set of functions that follow
    the functional programming paradigm. Libraries might offer a more efficient implementation
    and can prevent you from reinventing the wheel. However, if you want to keep your
    dependency graph lightweight, it is much easier to do so by providing a few implementations
    yourself now that Go has: generics. In a pre-generics version of Go, this was
    much harder and I’d favor the library-based approach. Neither the empty interface-based
    approach nor the code generation approach is easy to implement without errors
    and headaches.'
  prefs: []
  type: TYPE_NORMAL
- en: Code generation libraries for pre-generics Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code generation, as the name implies, is a technique for generating Go code
    that can then be used like regular Go code in our application. The Go toolchain
    has all the necessary tools to do this out of the box. In Go, it is possible to
    add comments to your code that the compiler will interpret as commands. Such comments
    make it possible to trigger a special operation during the compile time of your
    program. These comments are called **pragma**. For example, you can add a comment
    to a function that will tell the compiler to avoid in-lining this function (the
    compiler can ignore it, so it’s more a suggestion than a command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The idea behind the code generation library, which we will explore shortly,
    is that using these special comments can trigger the generation of functions for
    a specific type, which implements the common functional programming operations
    such as filtering, mapping, reducing, and so on. The first library that we will
    explore, Pie, works in exactly this way.
  prefs: []
  type: TYPE_NORMAL
- en: A slice of Pie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The library that we will explore is **Pie**, written by Elliot Chance and available
    on GitHub here: [https://github.com/elliotchance/pie/tree/master/v1](https://github.com/elliotchance/pie/tree/master/v1).
    This library is available in two versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Version 1 focuses on Go at or below 1.17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 2 is the newer version for working with generics and needs Go 1.18 or
    above to work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In version 1, there are two ways of using this library. You can either use the
    functions directly to operate on common data types (`[]string`, `[]float64`, or
    `[]int`), or you can use this library to generate functions for your own data
    type. First, we’ll explore the built-in structures and then move on to generating
    functions for custom types.
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in functions of Pie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pie supports built-in functions for three data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[]``string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]``float64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]``int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are quite common, so it makes sense that these are supported by default.
    In the examples throughout this book, we have shown how we can filter a slice
    of integers to retain only the even numbers. Then, we squared them by using the
    Map function. Doing this in Pie is easy and follows the same idea as the code
    that we implemented in [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101) and beyond.
    As we are doing this through the use of a library, let’s first take a look at
    the content of the `go.mod` file to highlight which version of Pie we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is showing `go 1.17` as we are explicitly looking at libraries that can
    be used before generics were introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have imported the library (after running `go get`), we can use
    it in our application. Let’s build the Filter and Map example, as explained earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will output `result: [4 16 36 64 100]`, as expected. Pie
    allows us to build and chain functions together, similar to what we have seen
    in this book so far. Out of the box, this only works for slices of strings, ints,
    and float64s. Each of these requires a custom implementation in the library. By
    attaching the function to a concrete type, it can support multiple Filter and
    Map functions defined for distinct data types. This is also something that we
    have looked at doing ourselves, and as pointed out, this is a time-consuming and
    repetitive undertaking.'
  prefs: []
  type: TYPE_NORMAL
- en: What Pie does is remove some of this repetitive work by using code generation
    to generate the implementation for each data type. The details of how code generation
    works in this library are beyond the scope of this book, but I’d encourage checking
    out the library itself on GitHub and diving into the code to get a better appreciation
    for how this was built as it is genuinely quite interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Pie ships with a lot of functions. To get an up-to-date listing with a description
    of each, take a look at the wiki at [https://github.com/elliotchance/pie/tree/master/v1](https://github.com/elliotchance/pie/tree/master/v1).
  prefs: []
  type: TYPE_NORMAL
- en: Pie for custom data types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we want to use Pie for our own data type, we need to generate the code to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s set up a struct that we can use in all the following examples.
    We’ll create a struct to represent a dog, and also a type alias for a slice of
    the `[]``Dog` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this set up, we can run the `go generate` command and generate all of
    Pie’s functions for our custom data type. This created a new file, `dogs_pie.go`,
    in the same directory as our type definitions. By looking through the generated
    file, we can see which functions were generated. For example, the `Reverse` function
    was generated specifically for the `Dog` data type. This is copied verbatim here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also find the Filter and Map functions defined for the `Dog` data type.
    Again, these have been copied verbatim but with the comments omitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What this approach should highlight is that if you have many distinct types
    for which you are generating these functions, you are polluting your code base
    quite a bit with similar but not quite identical code. The executables that you
    are building will be larger as a result of this, and while it’s not often something
    that you have to think about anymore, if you are targeting a platform with limited
    memory availability, this might be a showstopper.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s take a look at how we can use the generated functions with
    another example in the `main` function. First, we’ll create some dogs, each with
    a name and an age. Then, we will filter the dogs for those that are older than
    10\. These results will then get sorted based on age, and this will be printed
    as the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this input, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are more functions to explore in Pie for a pre-generics version of Go.
    But let’s shift our focus now to contemporary Go code and look at libraries that
    we can leverage since Go 1.18.
  prefs: []
  type: TYPE_NORMAL
- en: go generate and go environment
  prefs: []
  type: TYPE_NORMAL
- en: To run `go generate` with Pie or any other executable that you download through
    `go get`, you need to ensure that your environment setup has been configured correctly
    to discover such executables. In a *nix-based system, this means that `go/bin`
    needs to be added to the `$PATH` variable. On Windows, you need to add `go/bin`
    to the environment variables. In the worst case, you can either download the GitHub
    source code or look for the directory where go dependencies are downloaded and
    build them yourself through `go install` and then move the executable to an environment
    location that is registered for your system.
  prefs: []
  type: TYPE_NORMAL
- en: Pie and Hasgo
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of being transparent, there is another library out there that follows
    a similar approach to Pie but tailors the functions to a Haskell-like implementation.
    This library is called **Hasgo** ([https://github.com/DylanMeeus/hasgo](https://github.com/DylanMeeus/hasgo)),
    of which I am the author. While both libraries work similarly, Pie offers more
    functions out of the box and fully supports Go 1.18\. But if you have written
    Haskell before, Hasgo might feel more familiar in terms of function naming and
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Post-generics functional programming libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming libraries have seen a rise in popularity since the advent
    of generics in Go. No longer is it necessary to mess with the empty interface
    or to rely on code generation to build out the staples that make up functional
    programming languages. We’ll explore a few libraries in this section and see how
    their implementation compares. In doing so, we will stick with examples that are
    more or less identical but might show off some different functions from the ones
    we have seen so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Pie with generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first library that we will look at is Pie. In the previous section, we
    indicated that there are two versions of Pie available today: v1, which is tailored
    to Go before the introduction of generics, and v2, which offers the same functionality
    in terms of functions but leverages generics to do so. v2 is actively maintained,
    so I expect that over time v1 and v2 will no longer offer feature parity. That
    said, the Go community is pretty good at adopting the latest Go version wherever
    possible, so I don’t expect this to be a blocker for anyone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the code, this is a snippet of the `go.mod` file, just
    to highlight which version of Pie we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `go 1.18` statement indicates that we can use generics, as generics were
    introduced in this version. Any version above 1.18 will work for the examples
    that we are about to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the pre-generics example, we will work with the `Dog` struct and a
    slice of the `[]Dog` type. Unlike the previous non-generics example, we don’t
    need to add the compiler pragma to generate any code, nor do we need the type
    alias for `[]Dog` (although using this can still be good practice in a real application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we will create a slice of dogs. Then, we will once
    again filter for the dogs that are older than 10\. We will then map their name
    to uppercase and finally return the result sorted by age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell, the code is pretty similar to the pre-generics version. However,
    no code generation was used to achieve this. Also, note that `pie.Of()` figured
    out what type of data we are operating on. In the pre-generics version, this is
    part of the reason why we had to create a type alias for `[]Dog` – so that the
    code generator could then use Filter, Map, Reduce, or some other method for the
    correct slice type and attach it for dot notation-style function chaining. With
    generics, we no longer need to do so. In general, Pie is a good library to explore
    if you want to introduce generics to a team, as the familiar dot notation-style
    chaining of function calls looks natural to developers who are used to an object-oriented
    approach. As mentioned previously, it has an extensive set of functions that can
    be used out of the box. Next, let’s look at a library for functional programming
    that is based on **Lodash**.
  prefs: []
  type: TYPE_NORMAL
- en: Lodash, for Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**lo** ([https://github.com/samber/lo](https://github.com/samber/lo)) is a
    library that, similar to Pie, adds easy-to-use functions to Go and is quite popular
    at the moment. It is inspired by the insanely popular Lodash library for JavaScript
    ([https://github.com/lodash/lodash](https://github.com/lodash/lodash)), which
    currently has over 55,000 stars on GitHub and is widely used.'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, lo supports 38 functions that operate on slices, 16 of which operate
    on the Map data type, and a bunch of convenience functions for searching, tuples,
    channels, and (set) intersection-style operations. It’s not practical to outline
    all the functions here, but if you have a problem that requires operating on these
    common container data types, it’s a good idea to check whether this library suits
    your needs before reinventing the wheel. What we will do in this section is take
    a look at a similar example to the one we used for Pie.
  prefs: []
  type: TYPE_NORMAL
- en: An example implementation with lo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are importing a new library, the following snippet shows the library
    and version that we will use for these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate this library, we’ll once again use a `main` function and a slice
    of dogs. In this case, we’ll want to do the following. First, we’ll deduplicate
    the slice so that each element in the slice is unique. Then, we will transform
    the names of all dogs into uppercase variants. This is the result that we will
    print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this small example, you can see how the use of the library is more reminiscent
    of a style chosen by (pure) functional programming languages rather than the dot
    notation style common to object-oriented code. We are chaining function calls
    by passing them as the input parameters of the higher-order function. Note that
    these are not lazily evaluated. In the preceding example, first, the `Uniq` function
    runs, which removes the duplicate entries from our input slice. Then, the `Map`
    function runs and applies the transformation. Remember that we are mutating the
    `Dog` struct by calling `d.Name = ...`, but this does not mutate the original
    data element. We explored this in more detail in previous chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: There is one additional feature that bears calling out. `lo` contains a subset
    of the library supported for concurrent function calls. There is a package in
    `lo` under `lo/parallel` that supports the parallel evaluation of function calls.
    Let’s rewrite our example but have the `Map` function work concurrently. (**Also,
    note that this package is called parallel but is talking about** **concurrent
    code**).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s the import statement and import alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, here’s the code to run the `Map` function concurrently, with the `Uniq`
    function still running sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This took almost no refactoring from our side but leveraged goroutines for concurrency.
    Pretty neat!
  prefs: []
  type: TYPE_NORMAL
- en: To close this chapter, let’s look at a library by the same author of `lo` that
    contains monad-like data structures such as the `Maybe` data type, which we explored
    in [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085).
  prefs: []
  type: TYPE_NORMAL
- en: Mo, for go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mo is a library that adds support for monad-like data structures in Go and
    is relatively popular. It fully supports Go 1.18+, and thus is built around generics.
    You can find the package itself here: [https://github.com/samber/mo](https://github.com/samber/mo).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth taking the time to explore this library and read the documentation,
    especially as this could have changed by the time you read this book. In essence,
    it works in the same way as the `Maybe` implementation in [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085)
    although, in this library, that type is called `Option`. We can create a data
    type that optionally contains a value, but can also represent the absence of a
    value. This data type then supports functions to transform the data or get the
    data in a nil-safe way. For example, let’s create an option that contains a dog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to use this to represent a `nil` value, we could still access
    it in a type-safe way. The `OrElse` function will ensure that a backup is used
    as a result of the function call, which is the default value provided by the caller.
    For example, let’s say we add the following code to our `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This library supports other types as well, such as `Future` and `Task`. But
    one particularly useful one is the `Result` type, which is more or less like the
    `Maybe` type but is meant to work in cases where a value can optionally contain
    an error. We’ll demonstrate this in the following snippet. First, we will call
    the `Ok()` function, which creates the `Result` type with a valid `Dog` object.
    In the second case, we will create the `Result` type with an error instead of
    a `Dog` object. In both cases, we will try to get and print the result, as well
    as the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this function, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that based on the content of the `error` value for `Result`, the
    behavior of the type is different. In the first instance, where we don’t have
    an error, we get back the correct dog and the error is empty. In the second instance,
    we get back the default value that we provided as part of the `OrElse` statement,
    as well as the underlying error message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at libraries that implement concepts of the functional
    programming paradigm. We started by looking at Pie, a library that can help users
    in building code in the functional paradigm whether working with a code base that
    uses Go before or after the introduction of generics in Go 1.18\. Specifically
    for the pre-generics version, we looked at the approach of code generation for
    custom types to get generics-like behavior. Pie allowed us to showcase the ease
    with which we can create functions such as Map and Filter since the introduction
    of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Then, looked at the Lodash-inspired Go library, `lo`. This library supports
    common functions that operate on container data types such as slices and maps,
    but unlike Pie, it follows a nested approach to function chaining rather than
    the dot notation syntax. `lo` does offer concurrent implementations for certain
    functions, so if performance is a concern and concurrency seems like the right
    solution, checking out this library is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the `mo` library, which adds monad-like data structures
    to Go. Specifically, we looked at the `Option` data structure, which is comparable
    to the `Maybe` data structure that we created in [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085).
    `mo` also offers a `Result` type, which is built for error handling and allows
    us to program more safely when dealing with potential `error` values.
  prefs: []
  type: TYPE_NORMAL
