<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">I/O and File Systems</h1>
                </header>
            
            <article>
                
<p>In this chapter, the following recipes will be covered:</p>
<ul>
<li>Using the common I/O interfaces</li>
<li>Using the bytes and strings packages</li>
<li>Working with directories and files</li>
<li>Working with the CSV format</li>
<li>Working with temporary files</li>
<li>Working with text/template and HTML/templates</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Go provides excellent support for both basic and complex I/O. The recipes in this chapter will explore common Go interfaces to deal with I/O and show how to make use of them. The Go standard library frequently uses these interfaces, and these interfaces will be used by recipes throughout the book.</p>
<p>You'll learn how to work with data in memory and in the form of streams. You'll see examples of working with files and directories and of working with the CSV format. The temporary files recipe discusses a mechanism to work with files without the overhead of dealing with name collision and more. Lastly, we'll explore Go standard templates for both plain text and HTML.</p>
<p>These recipes should lay the foundation for the use of interfaces to represent and modify data and should help you think about data in an abstract and flexible way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the common I/O interfaces</h1>
                </header>
            
            <article>
                
<p>Go provides a number of I/O interfaces used throughout the standard library. It is a best practice to make use of these interfaces wherever possible rather than passing structs or other types directly. Two powerful interfaces we explore in this recipe are the <kbd>io.Reader</kbd> and <kbd>io.Writer</kbd> interfaces. These interfaces are used throughout the standard library and understanding how to use them will make you a better Go developer.</p>
<p>The <kbd>Reader</kbd> and <kbd>Writer</kbd> interfaces look like this:</p>
<pre>
type Reader interface {<br/>        Read(p []byte) (n int, err error)<br/>}<br/><br/>type Writer interface {<br/>        Write(p []byte) (n int, err error)<br/>}
</pre>
<p>Go also makes it easy to combine interfaces. For example, take a look at the following code:</p>
<pre>
type Seeker interface {<br/>        Seek(offset int64, whence int) (int64, error)<br/>}<br/><br/>type ReadSeeker interface {<br/>        Reader<br/>        Seeker<br/>}
</pre>
<p>The recipe will also explore an <kbd>io</kbd> function called <kbd>Pipe()</kbd>:</p>
<pre>
func Pipe() (*PipeReader, *PipeWriter)
</pre>
<p>The remainder of this book will make use of these interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system at <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> and configure your <kbd>GOPATH</kbd> <span><span>environment variable.</span></span></li>
</ol>
<ol start="2">
<li>Open a terminal/console application, navigate to your <kbd>GOPATH/src</kbd> directory, and create a project directory such as <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="3">
<li>Optionally, install the latest tested version of the code using the following command:</li>
</ol>
<pre>
<strong>      go get github.com/agtorre/go-cookbook/</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create a new directory called <kbd>chapter1/interfaces</kbd>.</li>
<li>Navigate to that directory.</li>
</ol>
<p>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter1/interfaces">https://github.com/agtorre/go-cookbook/tree/master/chapter1/interfaces</a>, or use this as an exercise to write some of your own code.</p>
<ol>
<li>Create a file called <kbd>interfaces.go</kbd> with the following contents:</li>
</ol>
<pre>
        package interfaces<br/><br/>        import (<br/>                "fmt"<br/>                "io"<br/>                "os"<br/>        )<br/><br/>        // Copy copies data from in to out first directly,<br/>        // then using a buffer. It also writes to stdout<br/>        func Copy(in io.ReadSeeker, out io.Writer) error {<br/>                // we write to out, but also Stdout<br/>                w := io.MultiWriter(out, os.Stdout)<br/>        <br/>                // a standard copy, this can be dangerous if there's a <br/>                // lot of data in in<br/>                if _, err := io.Copy(w, in); err != nil {<br/>                    return err<br/>                }<br/>        <br/>                in.Seek(0, 0)<br/><br/>                // buffered write using 64 byte chunks<br/>                buf := make([]byte, 64)<br/>                if _, err := io.CopyBuffer(w, in, buf); err != nil {<br/>                    return err<br/>                }<br/><br/>                // lets print a new line<br/>                fmt.Println()<br/>        <br/>                return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>pipes.go</kbd> with the following contents:</li>
</ol>
<pre>
        package interfaces<br/><br/>        import (<br/>                "io"<br/>                "os"<br/>        )<br/>        <br/>        // PipeExample helps give some more examples of using io  <br/>        //interfaces<br/>        func PipeExample() error {<br/>                // the pipe reader and pipe writer implement<br/>                // io.Reader and io.Writer<br/>                r, w := io.Pipe()<br/><br/>                // this needs to be run in a separate go routine<br/>                // as it will block waiting for the reader<br/>                // close at the end for cleanup<br/>                go func() {<br/>                    // for now we'll write something basic,<br/>                    // this could also be used to encode json<br/>                    // base64 encode, etc.<br/>                    w.Write([]byte("testn"))<br/>                    w.Close()<br/>                }()<br/>        <br/>                if _, err := io.Copy(os.Stdout, r); err != nil {<br/>                    return err<br/>                }<br/>                return nil<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
</ol>
<p>Â </p>
<ol start="8">
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the interfaces imported to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>             "bytes"<br/>             "fmt"<br/>        <br/>             "github.com/agtorre/go-cookbook/chapter1/interfaces"<br/>        )<br/>        <br/>        func main() {<br/>                in := bytes.NewReader([]byte("example"))<br/>                out := &amp;bytes.Buffer{}<br/>                fmt.Print("stdout on Copy = ")<br/>                if err := interfaces.Copy(in, out); err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                fmt.Println("out bytes buffer =", out.String())<br/>        <br/>                fmt.Print("stdout on PipeExample = ")<br/>                if err := interfaces.PipeExample(); err != nil {<br/>                        panic(err)<br/>                }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run these:</li>
</ol>
<pre>
<strong>      go build <br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 90px"><span>You should see the following output:</span></p>
<pre>
<strong>        $ go run main.go</strong><br/><strong>        stdout on Copy = exampleexample</strong><br/><strong>        out bytes buffer = exampleexample</strong><br/><strong>        stdout on PipeExample = test</strong>
</pre>
<ol start="11">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Copy()</kbd> function copies between interfaces and treats them like streams. Thinking of data as streams has a lot of practical uses, especially when working with network traffic or filesystems. The <kbd>Copy()</kbd> function also creates a multi-writer that combines two writer streams and writes to them twice using <kbd>ReadSeeker</kbd>. If a <kbd>Reader</kbd> interface were used instead rather than seeing <kbd>exampleexample</kbd>, you would only see <kbd>example</kbd> despite copying to the <kbd>MultiWriter</kbd> interface twice. There's also an example of a buffered write that you might use if your stream is not fit into the memory.</p>
<p>The <kbd>PipeReader</kbd> and <kbd>PipeWriter</kbd> structs implement <kbd>io.Reader</kbd> and <kbd>io.Writer</kbd> interfaces. They're connected, creating an in-memory pipe. The primary purpose of a pipe is to read from a stream while simultaneously writing from the same stream to a different source. In essence, it combines the two streams into a pipe.</p>
<p>Go interfaces are a clean abstraction to wrap data that performs common operations. This is made apparent when doing I/O operations, and so the <kbd>io</kbd> package is a great resource for learning about interface composition. The <kbd>pipe</kbd> package is often underused but provides great flexibility with thread-safety when linking input and output streams.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the bytes and strings packages</h1>
                </header>
            
            <article>
                
<p>The <kbd>bytes</kbd> and <kbd>string</kbd> packages have a number of useful helpers to work with and convert between strings and byte types. They allow the creation of buffers that work with a number of common I/O interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Refer to the <em>Getting ready</em> section's steps in the <em>Using the common I/O interfaces</em> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create a new directory called <kbd>chapter1/bytestrings</kbd>.</li>
<li>Navigate to this directory.</li>
</ol>
<p>Â </p>
<ol start="3">
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter1/bytesstrings">https://github.com/agtorre/go-cookbook/tree/master/chapter1/bytesstrings</a>, or use this as an exercise to write some of your own code!</li>
<li><span>Create a file called</span> <kbd>buffer.go</kbd> <span>with the following contents:</span></li>
</ol>
<pre>
        package bytestrings<br/>        <br/>        import (<br/>                "bytes"<br/>                "io"<br/>                "io/ioutil"<br/>        )<br/>        <br/>        // Buffer demonstrates some tricks for initializing bytes    <br/>        //Buffers<br/>        // These buffers implement an io.Reader interface<br/>        func Buffer(rawString string) *bytes.Buffer {<br/>        <br/>                // we'll start with a string encoded into raw bytes<br/>                rawBytes := []byte(rawString)<br/>        <br/>                // there are a number of ways to create a buffer from <br/>                // the raw bytes or from the original string<br/>                var b = new(bytes.Buffer)<br/>                b.Write(rawBytes)<br/>        <br/>                // alternatively<br/>                b = bytes.NewBuffer(rawBytes)<br/>        <br/>                // and avoiding the intial byte array altogether<br/>                b = bytes.NewBufferString(rawString)<br/>        <br/>                return b<br/>        }<br/>        <br/>        // ToString is an example of taking an io.Reader and consuming <br/>        // it all, then returning a string<br/>        func toString(r io.Reader) (string, error) {<br/>                b, err := ioutil.ReadAll(r)<br/>                if err != nil {<br/>                    return "", err<br/>                }<br/>                return string(b), nil<br/>        }
</pre>
<ol start="5">
<li><span>Cr</span>eate a file calle<span>d</span> <kbd>bytes.go</kbd> <span>with the following contents:</span></li>
</ol>
<pre>
        package bytestrings<br/>        <br/>        import (<br/>                "bufio"<br/>                "bytes"<br/>                "fmt"<br/>        )<br/>        <br/>        // WorkWithBuffer will make use of the buffer created by the<br/>        // Buffer function<br/>        func WorkWithBuffer() error {<br/>                rawString := "it's easy to encode unicode into a byte <br/>                              array"<br/><br/>                b := Buffer(rawString)<br/><br/>                // we can quickly convert a buffer back into byes with<br/>                // b.Bytes() or a string with b.String()<br/>                fmt.Println(b.String())<br/>        <br/>                // because this is an io Reader we can make use of  <br/>                // generic io reader functions such as<br/>                s, err := toString(b)<br/>                if err != nil {<br/>                    return err<br/>                }<br/>                fmt.Println(s)<br/><br/>                // we can also take our bytes and create a bytes reader<br/>                // these readers implement io.Reader, io.ReaderAt, <br/>                // io.WriterTo, io.Seeker, io.ByteScanner, and <br/>                // io.RuneScanner interfaces<br/>                reader := bytes.NewReader([]byte(rawString))<br/>        <br/>                // we can also plug it into a scanner that allows <br/>                // buffered reading and tokenzation<br/>                scanner := bufio.NewScanner(reader)<br/>                scanner.Split(bufio.ScanWords)<br/>        <br/>                // iterate over all of the scan events<br/>                for scanner.Scan() {<br/>                    fmt.Print(scanner.Text())<br/>                }<br/>        <br/>                return nil<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>string.go</kbd> with the following contents:</li>
</ol>
<pre>
        package bytestrings<br/>        <br/>        import (<br/>                "fmt"<br/>                "io"<br/>                "os"<br/>                "strings"<br/>        )<br/>        <br/>        // SearchString shows a number of methods<br/>        // for searching a string<br/>        func SearchString() {<br/>                s := "this is a test"<br/>        <br/>                // returns true because s contains<br/>                // the word this<br/>                fmt.Println(strings.Contains(s, "this"))<br/>        <br/>                // returns true because s contains the letter a<br/>                // would also match if it contained b or c<br/>                fmt.Println(strings.ContainsAny(s, "abc"))<br/>        <br/>                // returns true because s starts with this<br/>                fmt.Println(strings.HasPrefix(s, "this"))<br/>        <br/>                // returns true because s ends with this<br/>                fmt.Println(strings.HasSuffix(s, "test"))<br/>                }<br/>        <br/>        // ModifyString modifies a string in a number of ways<br/>        func ModifyString() {<br/>                s := "simple string"<br/>        <br/>                // prints [simple string]<br/>                fmt.Println(strings.Split(s, " "))<br/>        <br/>                // prints "Simple String"<br/>                fmt.Println(strings.Title(s))<br/>        <br/>                // prints "simple string"; all trailing and<br/>                // leading white space is removed<br/>                s = " simple string "<br/>                fmt.Println(strings.TrimSpace(s))<br/>        }<br/>        <br/>        // StringReader demonstrates how to create<br/>        // an io.Reader interface quickly with a string<br/>        func StringReader() {<br/>                s := "simple stringn"<br/>                r := strings.NewReader(s)<br/>        <br/>                // prints s on Stdout<br/>                io.Copy(os.Stdout, r)<br/>        }
</pre>
<ol start="7">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the interfaces imported to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/>        <br/>        import "github.com/agtorre/go-cookbook/chapter1/bytestrings"<br/>        <br/>        func main() {<br/>                err := bytestrings.WorkWithBuffer()<br/>                if err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                // each of these print to stdout<br/>                bytestrings.SearchString()<br/>                bytestrings.ModifyString()<br/>                bytestrings.StringReader() <br/>        }
</pre>
<ol start="10">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run these:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 90px">You should see the following output:</p>
<pre>
<strong>        $ go run main.go</strong><br/><strong>        it's easy to encode unicode into a byte array ??</strong><br/><strong>        it's easy to encode unicode into a byte array ??</strong><br/><strong>        it'seasytoencodeunicodeintoabytearray??true</strong><br/><strong>        true</strong><br/><strong>        true</strong><br/><strong>        true</strong><br/><strong>        [simple string]</strong><br/><strong>        Simple String</strong><br/><strong>        simple string</strong><br/><strong>        simple string</strong>
</pre>
<ol start="12">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The bytes library provides a number of convenience functions when working with data. A buffer, for example, is far more flexible than an array of bytes when working with stream processing libraries or methods. Once you've created a buffer, it can be used to satisfy an <kbd>io.Reader</kbd> interface so you can take advantage of <kbd>ioutil</kbd> functions to manipulate the data. For steaming applications, you'd probably want to use a buffer and a scanner. The <kbd>bufio</kbd> package comes in handy for these cases. Sometimes, using an array or slice is more appropriate for smaller datasets or when you have a lot of memory on your machine.</p>
<p>Go provides a lot of flexibility in converting between interfaces with these basic types--it's relatively simple to convert between strings and bytes. When working with strings, the <kbd>strings</kbd> package provides a number of convenience functions to work with, search, and manipulate strings. In some cases, a good regular expression may be appropriate, but most of the time, the <kbd>strings</kbd> and <kbd>strconv</kbd> packages are sufficient. The <kbd>strings</kbd> package allows you to make a string look like a title, split it into an array, or trim whitespace. It also provides a <kbd>Reader</kbd> interface of its own that can be used instead of the <kbd>bytes</kbd> package reader type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with directories and files</h1>
                </header>
            
            <article>
                
<p>Working with directories and files can be difficult when you switch between platforms (Windows and Linux, for example). Go provides cross-platform support to work with files and directories in the <kbd>os</kbd> and <kbd>ioutils</kbd> packages. We've already seen examples of <kbd>ioutils</kbd>, but now we'll explore how to use them in another way!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the</span> <em>Using the common I/O interfaces</em> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create a new directory called <kbd>chapter1/filedirs</kbd>.</li>
<li>Navigate to this directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter1/filedirs">https://github.com/agtorre/go-cookbook/tree/master/chapter1/filedirs</a>, or use this as an exercise to write some of your own code!</li>
<li><span>Create a</span> file called <kbd>dirs.go</kbd> with <span>the following contents:</span></li>
</ol>
<pre>
        package filedirs<br/>        <br/>        import (<br/>                "errors"<br/>                "io"<br/>                "os"<br/>        )<br/>        <br/>        // Operate manipulates files and directories<br/>        func Operate() error {<br/>                // this 0777 is similar to what you'd see with chown<br/>                // on a command line this will create a director <br/>                // /tmp/example, you may also use an absolute path <br/>                // instead of a relative one<br/>                if err := os.Mkdir("example_dir", os.FileMode(0755)); <br/>                err !=  nil {<br/>                        return err<br/>                }<br/><br/>                // go to the /tmp directory<br/>                if err := os.Chdir("example_dir"); err != nil {<br/>                        return err<br/>                }<br/><br/>                // f is a generic file object<br/>                // it also implements multiple interfaces<br/>                // and can be used as a reader or writer<br/>                // if the correct bits are set when opening<br/>                f, err := os.Create("test.txt")<br/>                if err != nil {<br/>                        return err<br/>                }<br/><br/>                // we write a known-length value to the file and <br/>                // validate that it wrote correctly<br/>                value := []byte("hellon")<br/>                count, err := f.Write(value)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>                if count != len(value) {<br/>                        return errors.New("incorrect length returned <br/>                        from write")<br/>                }<br/><br/>                if err := f.Close(); err != nil {<br/>                        return err<br/>                }<br/><br/>                // read the file<br/>                f, err = os.Open("test.txt")<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                io.Copy(os.Stdout, f)<br/>        <br/>                if err := f.Close(); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                // go to the /tmp directory<br/>                if err := os.Chdir(".."); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                // cleanup, os.RemoveAll can be dangerous if you<br/>                // point at the wrong directory, use user input,<br/>                // and especially if you run as root<br/>                if err := os.RemoveAll("example_dir"); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                return nil<br/>        }
</pre>
<ol start="5">
<li><span>Cre</span>ate a file c<span>alled <kbd>bytes.go</kbd></span> <span>with the following contents:</span></li>
</ol>
<pre>
        package filedirs<br/>        <br/>        import (<br/>                "bytes"<br/>                "io"<br/>                "os"<br/>                "strings"<br/>        )<br/>        <br/>        // Capitalizer opens a file, reads the contents,<br/>        // then writes those contents to a second file<br/>                func Capitalizer(f1 *os.File, f2 *os.File) error {<br/>                if _, err := f1.Seek(0, 0); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                var tmp = new(bytes.Buffer)<br/>        <br/>                if _, err := io.Copy(tmp, f1); err != nil {<br/>                        return err<br/>                }<br/><br/>                s := strings.ToUpper(tmp.String())<br/>        <br/>                if _, err := io.Copy(f2, strings.NewReader(s)); err != <br/>                nil {<br/>                        return err<br/>                }<br/>                return nil<br/>        }<br/>        <br/>        // CapitalizerExample creates two files, writes to one<br/>        //then calls Capitalizer() on both<br/>        func CapitalizerExample() error {<br/>                f1, err := os.Create("file1.txt")<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                if _, err := f1.Write([]byte(`this file contains a <br/>                number of words and new lines`)); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                f2, err := os.Create("file2.txt")<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                if err := Capitalizer(f1, f2); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                if err := os.Remove("file1.txt"); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                if err := os.Remove("file2.txt"); err != nil {<br/>                        return err<br/>                }<br/>        <br/>                return nil<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the <kbd>filedirs</kbd> package import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/>        <br/>        import "github.com/agtorre/go-cookbook/chapter1/filedirs"<br/>        <br/>        func main() {<br/>                if err := filedirs.Operate(); err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                if err := filedirs.CapitalizerExample(); err != nil {<br/>                        panic(err)<br/>                }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run these:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 90px"><span>Y</span>ou should s<span>ee the following output:</span></p>
<pre>
<strong>        $ go run main.go </strong><br/><strong>        hello</strong>
</pre>
<ol start="11">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If you're familiar with files in Unix, the Go <kbd>os</kbd> library should feel very familiar. You can do basically all common operations--stat a file to collect attributes, collect a file with different permissions, and create and modify directories and files. We performed a number of manipulations to directories and files and then cleaned up after ourselves.</p>
<p>Working with file objects is very similar to in-memory streams. Files also provide a number of convenience functions directly, such as <kbd>Chown</kbd>, <kbd>Stat</kbd>, and <kbd>Truncate</kbd>. The easiest way to get comfortable with files is to make use of them. In all the previous recipes, we have to be careful to clean up after our programs.</p>
<p>Working with files is a very common operation when building backend applications. Files can be used for configuration, secret keys, as temporary storage, and more. Go wraps OS system calls using the <kbd>os</kbd> package and allows the same functions to operate regardless of whether you're using Windows or Unix.</p>
<p>Once your file is opened and stored in a <kbd>File</kbd> struct, it can easily be passed into a number of interfaces discussed earlier. All the earlier examples of working with buffers and in-memory data streams can be replaced directly with file objects. This may be useful for things such as writing all logs to <kbd>stderr</kbd> and the file at the same time with a single write call.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with the CSV format</h1>
                </header>
            
            <article>
                
<p>CSV is a common format to manipulate data. It's common, for example, to import or export a CSV file into Excel. The Go <kbd>CSV</kbd> package operates on data interfaces, and as a result, it's easy to write data to a buffer, stdout, a file, or to a socket. The examples in this section will show some common ways to get data into and out of the CSV format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the</span> <em>Using the common I/O interfaces</em> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create a new directory called <kbd>chapter1/csvformat</kbd>.</li>
<li>Navigate to this directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter1/csvformat">https://github.com/agtorre/go-cookbook/tree/master/chapter1/csvformat</a>, or use this as an exercise to write some of your own code!</li>
</ol>
<p>Â </p>
<ol start="4">
<li><span>Create a file called</span> <kbd>read_csv.go</kbd> <span>with the following contents:</span></li>
</ol>
<pre>
        package csvformat<br/>        <br/>        import (<br/>                "bytes"<br/>                "encoding/csv"<br/>                "fmt"<br/>                "io"<br/>                "strconv"<br/>        )<br/>        <br/>        // Movie will hold our parsed CSV<br/>        type Movie struct {<br/>                Title string<br/>                Director string<br/>                Year int<br/>        }<br/>        <br/>        // ReadCSV gives shows some examples of processing CSV<br/>        // that is passed in as an io.Reader<br/>        func ReadCSV(b io.Reader) ([]Movie, error) {<br/>        <br/>                r := csv.NewReader(b)<br/>        <br/>                // These are some optional configuration options<br/>                r.Comma = ';'<br/>                r.Comment = '-'<br/>        <br/>                var movies []Movie<br/>        <br/>                // grab and ignore the header for now<br/>                // we may also wanna use this for a dictionary key or<br/>                // some other form of lookup<br/>                _, err := r.Read()<br/>                if err != nil &amp;&amp; err != io.EOF {<br/>                        return nil, err<br/>                }<br/>        <br/>                // loop until it's all processed<br/>                for {<br/>                        record, err := r.Read()<br/>                        if err == io.EOF {<br/>                                break<br/>                        } else if err != nil {<br/>                                return nil, err<br/>                        }<br/>        <br/>                        year, err := strconv.ParseInt(record[2], 10, <br/>                        64)<br/>                        if err != nil {<br/>                                return nil, err<br/>                        }<br/><br/>                        m := Movie{record[0], record[1], int(year)}<br/>                        movies = append(movies, m)<br/>                }<br/>                return movies, nil<br/>        }<br/><br/>        // AddMoviesFromText uses the CSV parser with a string<br/>        func AddMoviesFromText() error {<br/>                // this is an example of us taking a string, converting<br/>                // it into a buffer, and reading it <br/>                // with the csv package<br/>                in := `<br/>                - first our headers<br/>                movie title;director;year released<br/>        <br/>                - then some data<br/>                Guardians of the Galaxy Vol. 2;James Gunn;2017<br/>                Star Wars: Episode VIII;Rian Johnson;2017<br/>                `<br/>        <br/>                b := bytes.NewBufferString(in)<br/>                m, err := ReadCSV(b)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>                fmt.Printf("%#vn", m)<br/>                return nil<br/>        }
</pre>
<ol start="5">
<li><span>Cr</span>eate a fi<span>le called <kbd>write_csv.go</kbd></span> <span>with the following contents:</span></li>
</ol>
<pre>
        package csvformat<br/>        <br/>        import (<br/>                "bytes"<br/>                "encoding/csv"<br/>                "io"<br/>                "os"<br/>        )<br/>        <br/>        // A Book has an Author and Title<br/>        type Book struct {<br/>                Author string<br/>                Title string<br/>        }<br/>        <br/>        // Books is a named type for an array of books<br/>        type Books []Book<br/>        <br/>        // ToCSV takes a set of Books and writes to an io.Writer<br/>        // it returns any errors<br/>        func (books *Books) ToCSV(w io.Writer) error {<br/>                n := csv.NewWriter(w)<br/>                err := n.Write([]string{"Author", "Title"})<br/>                if err != nil {<br/>                        return err<br/>                }<br/>                for _, book := range *books {<br/>                        err := n.Write([]string{book.Author, <br/>                        book.Title})<br/>                        if err != nil {<br/>                                return err<br/>                        }<br/>                }<br/>        <br/>                n.Flush()<br/>                return n.Error()<br/>        }<br/><br/>        // WriteCSVOutput initializes a set of books<br/>        // and writes the to os.Stdout<br/>        func WriteCSVOutput() error {<br/>                b := Books{<br/>                        Book{<br/>                                Author: "F Scott Fitzgerald",<br/>                                Title: "The Great Gatsby",<br/>                        },<br/>                        Book{<br/>                                Author: "J D Salinger",<br/>                                Title: "The Catcher in the Rye",<br/>                        },<br/>                }<br/>        <br/>                return b.ToCSV(os.Stdout)<br/>        }<br/><br/>        // WriteCSVBuffer returns a buffer csv for<br/>        // a set of books<br/>        func WriteCSVBuffer() (*bytes.Buffer, error) {<br/>                b := Books{<br/>                        Book{<br/>                                Author: "F Scott Fitzgerald",<br/>                                Title: "The Great Gatsby",<br/>                        },<br/>                        Book{<br/>                                Author: "J D Salinger",<br/>                                Title: "The Catcher in the Rye",<br/>                        },<br/>                }<br/>        <br/>                w := &amp;bytes.Buffer{}<br/>                err := b.ToCSV(w)<br/>                return w, err<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd>.</li>
</ol>
<p>Â </p>
<ol start="7">
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the <kbd>csvformat</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/>        <br/>        import (<br/>                "fmt"<br/>        <br/>                "github.com/agtorre/go-cookbook/chapter1/csvformat"<br/>        )<br/>        <br/>        func main() {<br/>                if err := csvformat.AddMoviesFromText(); err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                if err := csvformat.WriteCSVOutput(); err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                buffer, err := csvformat.WriteCSVBuffer()<br/>                if err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                fmt.Println("Buffer = ", buffer.String())<br/>        }
</pre>
<ol start="9">
<li>Run go <kbd>run main.go</kbd>.</li>
<li>You may also run these:</li>
</ol>
<pre>
<strong>      go build</strong><br/><strong>      ./example</strong>
</pre>
<p style="padding-left: 90px"><span>Y</span>ou shoul<span>d see the following output:</span></p>
<pre>
<strong>        $ go run main.go </strong><br/><strong>        []csvformat.Movie{csvformat.Movie{Title:"Guardians of the <br/>        Galaxy Vol. 2", Director:"James Gunn", Year:2017},         <br/>        csvformat.Movie{Title:"Star Wars: Episode VIII", Director:"Rian <br/>        Johnson", Year:2017}}</strong><br/><strong>        Author,Title</strong><br/><strong>        F Scott Fitzgerald,The Great Gatsby</strong><br/><strong>        J D Salinger,The Catcher in the Rye</strong><br/><strong>        Buffer = Author,Title</strong><br/><strong>        F Scott Fitzgerald,The Great Gatsby</strong><br/><strong>        J D Salinger,The Catcher in the Rye</strong>
</pre>
<ol start="11">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In order to explore reading a CSV format, we first represent our data as a struct. It's very useful in Go to format data as a struct, as it makes things such as marshaling and encoding relatively simple. Our read example uses movies as our data type. The function takes an <kbd>io.Reader</kbd> interface that holds our CSV data as an input. This could be a file or a buffer. We then use that data to create and populate a <kbd>Movie</kbd> struct, including converting the year into an integer. We also add options to the CSV parser to use <kbd>;</kbd> as the separator and <kbd>-</kbd> as a comment line.</p>
<p>Next, we explore the same idea, but in reverse. Novels are represented with a title and an author. We initialize an array of novels and then write specific novels in the CSV format to an <kbd>io.Writer</kbd> interface. Once again, this can be a file, stdout, or a buffer.</p>
<p>The <kbd>CSV</kbd> package is an excellent example of why you'd want to think of data flows in Go as implementing common interfaces. It's easy to change the source and destination of our data with small one-line tweaks, and we can easily manipulate CSV data without using an excessive amount of memory or time. For example, it would be possible to read from a stream of data one record at a time and write to a separate stream in a modified format one record at a time. Doing this would not incur significant memory or processor usage.</p>
<p>Later, when we explore data pipelines and worker pools, you'll see how these ideas can be combined and how to handle these streams in parallel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with temporary files</h1>
                </header>
            
            <article>
                
<p>We've created and made use of files for a number of examples so far. We've also had to manually deal with cleanup, name collision, and more. Temporary files and directories are a quicker, simpler way to handle these cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the</span> <em>Using the common I/O interfaces</em> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create a new directory called <kbd>chapter1/tempfiles</kbd>.</li>
<li>Navigate to this directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter1/tempfiles">https://github.com/agtorre/go-cookbook/tree/master/chapter1/tempfiles</a>, or use this as an exercise to write some of your own code!</li>
<li><span>Create a file called</span> <kbd>temp_files.go</kbd> <span>with the following contents:</span></li>
</ol>
<pre>
        package tempfiles<br/>        <br/>        import (<br/>                "fmt"<br/>                "io/ioutil"<br/>                "os"<br/>        )<br/>        <br/>        // WorkWithTemp will give some basic patterns for working<br/>        // with temporary files and directories<br/>        func WorkWithTemp() error {<br/>                // If you need a temporary place to store files with <br/>                // the same name ie. template1-10.html a temp directory <br/>                //  is a good way to approach it, the first argument <br/>                // being blank means it will use create the directory                <br/>                // in the location returned by <br/>                // os.TempDir()<br/>                t, err := ioutil.TempDir("", "tmp")<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                // This will delete everything inside the temp file <br/>                // when this function exits if you want to do this <br/>                //  later, be sure to return the directory name to the <br/>                // calling function<br/>                defer os.RemoveAll(t)<br/>        <br/>                // the directory must exist to create the tempfile<br/>                // created. t is an *os.File object.<br/>                tf, err := ioutil.TempFile(t, "tmp")<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                fmt.Println(tf.Name())<br/>        <br/>                // normally we'd delete the temporary file here, but <br/>                // because we're placing it in a temp directory, it <br/>                // gets cleaned up by the earlier defer<br/><br/>                return nil<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the tempfiles imported to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/>        <br/>        import "github.com/agtorre/go-cookbook/chapter1/tempfiles"<br/>        <br/>        func main() {<br/>                if err := tempfiles.WorkWithTemp(); err != nil {<br/>                        panic(err)<br/>                }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run these:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>     ./example</strong>
</pre>
<p style="padding-left: 90px"><span>You should see (with a different path) the following output:</span></p>
<pre>
<strong>        $ go run main.go </strong><br/><strong>        /var/folders/kd/ygq5l_0d1xq1lzk_c7htft900000gn/T<br/>        /tmp764135258/tmp588787953</strong>
</pre>
<ol start="11">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Creating temporary files and directories can be done using the <kbd>ioutil</kbd> package. Although you must still delete the files yourself, <kbd>RemoveAll</kbd> is the convention, and it will do that for you with only one extra line of code.</p>
<p>When writing tests, the use of temporary files is highly recommended. It's also useful for things such as build artifacts and more. The Go <kbd>ioutil</kbd> package will try and honor the OS preferences by default, but it allows you to fall back to other directories if required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with text/template and HTML/templates</h1>
                </header>
            
            <article>
                
<p>Go provides rich support for templates. It is simple to nest templates, import functions, represent variables, iterate over data, and so on. If you need something more sophisticated than a CSV writer, templates may be a great solution.</p>
<p>Another application for templates is for websites. When we want to render server-side data to the client, templates fit the bill nicely. At first, Go templates can appear confusing. This chapter will explore working with templates, collecting templates inside of a directory, and working with HTML templates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the</span> <em>Using the common I/O interfaces</em> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create a new directory called <kbd>chapter1/templates</kbd>.</li>
<li>Navigate to this directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter1/templates">https://github.com/agtorre/go-cookbook/tree/master/chapter1/templates</a>, or use this as an exercise to write some of your own!</li>
<li>Create a file called <kbd>templates.go</kbd> w<span>ith the following contents:</span></li>
</ol>
<pre>
        package templates<br/>        <br/>        import (<br/>                "os"<br/>                "strings"<br/>                "text/template"<br/>        )<br/>        <br/>        const sampleTemplate = `<br/>                This template demonstrates printing a {{ .Variable | <br/>                printf "%#v" }}.<br/>         <br/>                {{if .Condition}}<br/>                If condition is set, we'll print this<br/>                {{else}}<br/>                Otherwise, we'll print this instead<br/>                {{end}}<br/>        <br/>                Next we'll iterate over an array of strings:<br/>                {{range $index, $item := .Items}}<br/>                {{$index}}: {{$item}}<br/>                {{end}}<br/><br/>                We can also easily import other functions like <br/>                strings.Split<br/>                then immediately used the array created as a result:<br/>                {{ range $index, $item := split .Words ","}}<br/>                {{$index}}: {{$item}}<br/>                {{end}}<br/>        <br/>                Blocks are a way to embed templates into one another<br/>                {{ block "block_example" .}}<br/>                No Block defined!<br/>                {{end}}<br/>        <br/>        <br/>                {{/*<br/>                This is a way<br/>                to insert a multi-line comment<br/>                */}}<br/>`<br/>        <br/>        const secondTemplate = `<br/>                {{ define "block_example" }}<br/>                {{.OtherVariable}}<br/>                {{end}}<br/>`        <br/>        <br/>        // RunTemplate initializes a template and demonstrates a <br/>        // variety of template helper functions<br/>        func RunTemplate() error {<br/>                data := struct {<br/>                        Condition bool<br/>                        Variable string<br/>                        Items []string<br/>                        Words string<br/>                        OtherVariable string<br/>                }{<br/>                        Condition: true,<br/>                        Variable: "variable",<br/>                        Items: []string{"item1", "item2", "item3"},<br/>                        Words: <br/>                        "another_item1,another_item2,another_item3",<br/>                        OtherVariable: "I'm defined in a second <br/>                        template!",<br/>                }<br/>        <br/>                funcmap := template.FuncMap{<br/>                        "split": strings.Split,<br/>                }<br/>        <br/>                // these can also be chained<br/>                t := template.New("example")<br/>                t = t.Funcs(funcmap)<br/>        <br/>                // We could use Must instead to panic on error<br/>                // template.Must(t.Parse(sampleTemplate))<br/>                t, err := t.Parse(sampleTemplate)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                // to demonstrate blocks we'll create another template<br/>                // by cloning the first template, then parsing a second<br/>                t2, err := t.Clone()<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                t2, err = t2.Parse(secondTemplate)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                // write the template to stdout and populate it<br/>                // with data<br/>                err = t2.Execute(os.Stdout, &amp;data)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>template_files.go</kbd> with the following contents:</li>
</ol>
<pre>
        package templates<br/>        <br/>        import (<br/>                "io/ioutil"<br/>                "os"<br/>                "path/filepath"<br/>                "text/template"<br/>        )<br/>        <br/>        //CreateTemplate will create a template file that contains data<br/>        func CreateTemplate(path string, data string) error {<br/>                return ioutil.WriteFile(path, []byte(data), <br/>                os.FileMode(0755))<br/>        }<br/><br/>        // InitTemplates sets up templates from a directory<br/>        func InitTemplates() error {<br/>                tempdir, err := ioutil.TempDir("", "temp")<br/>                if err != nil {<br/>                        return err<br/>                }<br/>                defer os.RemoveAll(tempdir)<br/>        <br/>                err = CreateTemplate(filepath.Join(tempdir, "t1.tmpl"), <br/>                `Template 1! {{ .Var1 }}<br/>                {{ block "template2" .}} {{end}}<br/>                {{ block "template3" .}} {{end}}<br/>                `)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                err = CreateTemplate(filepath.Join(tempdir, "t2.tmpl"), <br/>                `{{ define "template2"}}Template 2! {{ .Var2 }}{{end}}<br/>                `)<br/>                if err != nil {<br/>                        return err<br/>                }<br/><br/>                err = CreateTemplate(filepath.Join(tempdir, "t3.tmpl"), <br/>                `{{ define "template3"}}Template 3! {{ .Var3 }}{{end}}<br/>                `)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                pattern := filepath.Join(tempdir, "*.tmpl")<br/><br/>                // Parse glob will combine all the files that match <br/>                // glob and combine them into a single template<br/>                tmpl, err := template.ParseGlob(pattern)<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                // Execute can also work with a map instead<br/>                // of a struct<br/>                tmpl.Execute(os.Stdout, map[string]string{<br/>                        "Var1": "Var1!!",<br/>                        "Var2": "Var2!!",<br/>                        "Var3": "Var3!!",<br/>                 })<br/><br/>                 return nil<br/>        }
</pre>
<ol start="6">
<li><span>C</span>reate <span>a file calle</span>d <kbd>html_templates.go</kbd> wit<span>h the following content:</span></li>
</ol>
<pre>
        package templates<br/>        <br/>        import (<br/>                "fmt"<br/>                "html/template"<br/>                "os"<br/>        )<br/>        <br/>        // HTMLDifferences highlights some of the differences<br/>        // between html/template and text/template<br/>        func HTMLDifferences() error {<br/>                t := template.New("html")<br/>                t, err := t.Parse("&lt;h1&gt;Hello! {{.Name}}&lt;/h1&gt;n")<br/>                if err != nil {<br/>                        return err<br/>         }<br/>        <br/>                // html/template auto-escapes unsafe operations like <br/>                // javascript injection this is contextually aware and <br/>                // will behave differently<br/>                // depending on where a variable is rendered<br/>                err = t.Execute(os.Stdout, map[string]string{"Name": "                 &lt;script&gt;alert('Can you see me?')&lt;/script&gt;"})<br/>                if err != nil {<br/>                        return err<br/>                }<br/>        <br/>                // you can also manually call the escapers<br/>                fmt.Println(template.JSEscaper(`example         <br/>                &lt;example@example.com&gt;`))<br/>                fmt.Println(template.HTMLEscaper(`example <br/>                &lt;example@example.com&gt;`))<br/>                fmt.Println(template.URLQueryEscaper(`example <br/>                &lt;example@example.com&gt;`))<br/>        <br/>                return nil<br/>        }
</pre>
<ol start="7">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the tempfiles imported to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/>        <br/>        import "github.com/agtorre/go-cookbook/chapter1/templates"<br/>        <br/>        func main() {<br/>                if err := templates.RunTemplate(); err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                if err := templates.InitTemplates(); err != nil {<br/>                        panic(err)<br/>                }<br/>        <br/>                if err := templates.HTMLDifferences(); err != nil {<br/>                        panic(err)<br/>                }<br/>        }
</pre>
<ol start="10">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run these:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 90px"><span>You should see (with a different path) the following output:</span></p>
<pre>
<strong>        $ go run main.go </strong><br/><br/><strong>         This template demonstrates printing a "variable".</strong><br/><br/><br/><strong>         If condition is set, we'll print this</strong><br/><br/><br/><strong>         Next we'll iterate over an array of strings:</strong><br/><br/><strong>         0: item1</strong><br/><br/><strong>         1: item2</strong><br/><br/><strong>         2: item3</strong><br/><br/><br/><strong>         We can also easily import other functions like strings.Split</strong><br/><strong>         then immediately used the array created as a result:</strong><br/><br/><strong>         0: another_item1</strong><br/><br/><strong>         1: another_item2</strong><br/><br/><strong>         2: another_item3</strong><br/><br/><br/><strong>         Blocks are a way to embed templates into one another</strong><br/><br/><strong>         I'm defined in a second template!</strong><br/><br/><br/><br/><br/><br/><strong>         Template 1! Var1!!</strong><br/><strong>         Template 2! Var2!!</strong><br/><strong>         Template 3! Var3!!</strong><br/><strong>         &lt;h1&gt;Hello! &amp;lt;script&amp;gt;alert('Can you see <br/>         me?')&amp;lt;/script&amp;gt;&lt;/h1&gt;</strong><br/><strong>        example x3Cexample@example.comx3E</strong><br/><strong>        example &amp;lt;example@example.com&amp;gt;</strong><br/><strong>        example+%3Cexample%40example.com%3E</strong>
</pre>
<ol start="12">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>
<p>Â </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Go has two template packages--<kbd>text/template</kbd> and <kbd>html/template</kbd>. These share functionality and a variety of functions. In general, use <kbd>html/template</kbd> to render websites and text/html for everything else. Templates are plain text, but variables and functions can be used inside of curly brace blocks.</p>
<p>The template packages also provide convenience methods to work with files. The example creates a number of templates in a temporary directory and then reads them all with a single line of code.</p>
<p>The <kbd>html/template</kbd> package is a wrapper around the <kbd>text/template</kbd> package. All of the template examples work with the <kbd>html/template</kbd> package directly, using no modification and only changing the import statement. HTML templates provide the added benefit of context-aware safety. This prevents things such as JavaScript injection.</p>
<p>The template packages provide what you'd expect out of a modern template library. It's easy to combine templates, add application logic, and ensure safety when emitting results to HTML and JavaScript.</p>


            </article>

            
        </section>
    </body></html>