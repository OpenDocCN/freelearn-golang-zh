- en: I/O and File Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the common I/O interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the bytes and strings packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with directories and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the CSV format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with temporary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with text/template and HTML/templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides excellent support for both basic and complex I/O. The recipes in
    this chapter will explore common Go interfaces to deal with I/O and show how to
    make use of them. The Go standard library frequently uses these interfaces, and
    these interfaces will be used by recipes throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn how to work with data in memory and in the form of streams. You'll
    see examples of working with files and directories and of working with the CSV
    format. The temporary files recipe discusses a mechanism to work with files without
    the overhead of dealing with name collision and more. Lastly, we'll explore Go
    standard templates for both plain text and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: These recipes should lay the foundation for the use of interfaces to represent
    and modify data and should help you think about data in an abstract and flexible
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Using the common I/O interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides a number of I/O interfaces used throughout the standard library.
    It is a best practice to make use of these interfaces wherever possible rather
    than passing structs or other types directly. Two powerful interfaces we explore
    in this recipe are the `io.Reader` and `io.Writer` interfaces. These interfaces
    are used throughout the standard library and understanding how to use them will
    make you a better Go developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Reader` and `Writer` interfaces look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Go also makes it easy to combine interfaces. For example, take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The recipe will also explore an `io` function called `Pipe()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The remainder of this book will make use of these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go on your operating system at [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal/console application, navigate to your `GOPATH/src` directory,
    and create a project directory such as `$GOPATH/src/github.com/yourusername/customrepo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All code will be run and modified from this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, install the latest tested version of the code using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter1/interfaces`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to that directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter1/interfaces](https://github.com/agtorre/go-cookbook/tree/master/chapter1/interfaces),
    or use this as an exercise to write some of your own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `interfaces.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `pipes.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the interfaces imported to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Copy()` function copies between interfaces and treats them like streams.
    Thinking of data as streams has a lot of practical uses, especially when working
    with network traffic or filesystems. The `Copy()` function also creates a multi-writer
    that combines two writer streams and writes to them twice using `ReadSeeker`.
    If a `Reader` interface were used instead rather than seeing `exampleexample`,
    you would only see `example` despite copying to the `MultiWriter` interface twice.
    There's also an example of a buffered write that you might use if your stream
    is not fit into the memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `PipeReader` and `PipeWriter` structs implement `io.Reader` and `io.Writer`
    interfaces. They're connected, creating an in-memory pipe. The primary purpose
    of a pipe is to read from a stream while simultaneously writing from the same
    stream to a different source. In essence, it combines the two streams into a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Go interfaces are a clean abstraction to wrap data that performs common operations.
    This is made apparent when doing I/O operations, and so the `io` package is a
    great resource for learning about interface composition. The `pipe` package is
    often underused but provides great flexibility with thread-safety when linking
    input and output streams.
  prefs: []
  type: TYPE_NORMAL
- en: Using the bytes and strings packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bytes` and `string` packages have a number of useful helpers to work with
    and convert between strings and byte types. They allow the creation of buffers
    that work with a number of common I/O interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using the common I/O interfaces*
    recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter1/bytestrings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter1/bytesstrings](https://github.com/agtorre/go-cookbook/tree/master/chapter1/bytesstrings),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `buffer.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `bytes.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `string.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the interfaces imported to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bytes library provides a number of convenience functions when working with
    data. A buffer, for example, is far more flexible than an array of bytes when
    working with stream processing libraries or methods. Once you've created a buffer,
    it can be used to satisfy an `io.Reader` interface so you can take advantage of
    `ioutil` functions to manipulate the data. For steaming applications, you'd probably
    want to use a buffer and a scanner. The `bufio` package comes in handy for these
    cases. Sometimes, using an array or slice is more appropriate for smaller datasets
    or when you have a lot of memory on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides a lot of flexibility in converting between interfaces with these
    basic types--it's relatively simple to convert between strings and bytes. When
    working with strings, the `strings` package provides a number of convenience functions
    to work with, search, and manipulate strings. In some cases, a good regular expression
    may be appropriate, but most of the time, the `strings` and `strconv` packages
    are sufficient. The `strings` package allows you to make a string look like a
    title, split it into an array, or trim whitespace. It also provides a `Reader`
    interface of its own that can be used instead of the `bytes` package reader type.
  prefs: []
  type: TYPE_NORMAL
- en: Working with directories and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with directories and files can be difficult when you switch between
    platforms (Windows and Linux, for example). Go provides cross-platform support
    to work with files and directories in the `os` and `ioutils` packages. We've already
    seen examples of `ioutils`, but now we'll explore how to use them in another way!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using the common I/O interfaces*
    recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter1/filedirs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter1/filedirs](https://github.com/agtorre/go-cookbook/tree/master/chapter1/filedirs),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dirs.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `bytes.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the `filedirs` package import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're familiar with files in Unix, the Go `os` library should feel very
    familiar. You can do basically all common operations--stat a file to collect attributes,
    collect a file with different permissions, and create and modify directories and
    files. We performed a number of manipulations to directories and files and then
    cleaned up after ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Working with file objects is very similar to in-memory streams. Files also provide
    a number of convenience functions directly, such as `Chown`, `Stat`, and `Truncate`.
    The easiest way to get comfortable with files is to make use of them. In all the
    previous recipes, we have to be careful to clean up after our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files is a very common operation when building backend applications.
    Files can be used for configuration, secret keys, as temporary storage, and more.
    Go wraps OS system calls using the `os` package and allows the same functions
    to operate regardless of whether you're using Windows or Unix.
  prefs: []
  type: TYPE_NORMAL
- en: Once your file is opened and stored in a `File` struct, it can easily be passed
    into a number of interfaces discussed earlier. All the earlier examples of working
    with buffers and in-memory data streams can be replaced directly with file objects.
    This may be useful for things such as writing all logs to `stderr` and the file
    at the same time with a single write call.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the CSV format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSV is a common format to manipulate data. It's common, for example, to import
    or export a CSV file into Excel. The Go `CSV` package operates on data interfaces,
    and as a result, it's easy to write data to a buffer, stdout, a file, or to a
    socket. The examples in this section will show some common ways to get data into
    and out of the CSV format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using the common I/O interfaces*
    recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter1/csvformat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter1/csvformat](https://github.com/agtorre/go-cookbook/tree/master/chapter1/csvformat),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `read_csv.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `write_csv.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the `csvformat` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run go `run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to explore reading a CSV format, we first represent our data as a struct.
    It's very useful in Go to format data as a struct, as it makes things such as
    marshaling and encoding relatively simple. Our read example uses movies as our
    data type. The function takes an `io.Reader` interface that holds our CSV data
    as an input. This could be a file or a buffer. We then use that data to create
    and populate a `Movie` struct, including converting the year into an integer.
    We also add options to the CSV parser to use `;` as the separator and `-` as a
    comment line.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explore the same idea, but in reverse. Novels are represented with
    a title and an author. We initialize an array of novels and then write specific
    novels in the CSV format to an `io.Writer` interface. Once again, this can be
    a file, stdout, or a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The `CSV` package is an excellent example of why you'd want to think of data
    flows in Go as implementing common interfaces. It's easy to change the source
    and destination of our data with small one-line tweaks, and we can easily manipulate
    CSV data without using an excessive amount of memory or time. For example, it
    would be possible to read from a stream of data one record at a time and write
    to a separate stream in a modified format one record at a time. Doing this would
    not incur significant memory or processor usage.
  prefs: []
  type: TYPE_NORMAL
- en: Later, when we explore data pipelines and worker pools, you'll see how these
    ideas can be combined and how to handle these streams in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Working with temporary files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've created and made use of files for a number of examples so far. We've also
    had to manually deal with cleanup, name collision, and more. Temporary files and
    directories are a quicker, simpler way to handle these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using the common I/O interfaces*
    recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter1/tempfiles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter1/tempfiles](https://github.com/agtorre/go-cookbook/tree/master/chapter1/tempfiles),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `temp_files.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the tempfiles imported to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see (with a different path) the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating temporary files and directories can be done using the `ioutil` package.
    Although you must still delete the files yourself, `RemoveAll` is the convention,
    and it will do that for you with only one extra line of code.
  prefs: []
  type: TYPE_NORMAL
- en: When writing tests, the use of temporary files is highly recommended. It's also
    useful for things such as build artifacts and more. The Go `ioutil` package will
    try and honor the OS preferences by default, but it allows you to fall back to
    other directories if required.
  prefs: []
  type: TYPE_NORMAL
- en: Working with text/template and HTML/templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides rich support for templates. It is simple to nest templates, import
    functions, represent variables, iterate over data, and so on. If you need something
    more sophisticated than a CSV writer, templates may be a great solution.
  prefs: []
  type: TYPE_NORMAL
- en: Another application for templates is for websites. When we want to render server-side
    data to the client, templates fit the bill nicely. At first, Go templates can
    appear confusing. This chapter will explore working with templates, collecting
    templates inside of a directory, and working with HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using the common I/O interfaces*
    recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter1/templates`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter1/templates](https://github.com/agtorre/go-cookbook/tree/master/chapter1/templates),
    or use this as an exercise to write some of your own!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `templates.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `template_files.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `html_templates.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the tempfiles imported to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see (with a different path) the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has two template packages--`text/template` and `html/template`. These share
    functionality and a variety of functions. In general, use `html/template` to render
    websites and text/html for everything else. Templates are plain text, but variables
    and functions can be used inside of curly brace blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The template packages also provide convenience methods to work with files. The
    example creates a number of templates in a temporary directory and then reads
    them all with a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: The `html/template` package is a wrapper around the `text/template` package.
    All of the template examples work with the `html/template` package directly, using
    no modification and only changing the import statement. HTML templates provide
    the added benefit of context-aware safety. This prevents things such as JavaScript
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: The template packages provide what you'd expect out of a modern template library.
    It's easy to combine templates, add application logic, and ensure safety when
    emitting results to HTML and JavaScript.
  prefs: []
  type: TYPE_NORMAL
