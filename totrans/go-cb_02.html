<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Command-Line Tools</h1>
                </header>
            
            <article>
                
<p>In this chapter, the following recipes will be covered:</p>
<ul>
<li>Using command-line flags</li>
<li>Using command-line arguments</li>
<li>Reading and setting environment variables</li>
<li>Configuration using TOML, YAML, and JSON</li>
<li>Working with Unix pipes</li>
<li>Catching and handling signals</li>
<li>An ANSI coloring application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Command-line applications are among the easiest ways to handle user input and output. This chapter will focus on command-line-based interactions, such as command-line arguments, configuration, and environment variables. It'll conclude with a library for coloring text output in Unix and Bash for Windows.</p>
<p>With the recipes in this chapter, you should be equipped to handle expected and unexpected user input. The signal recipe is an example of cases where users may send unexpected signals to your application, and the pipes recipe is a good alternative to taking user inputs compared to flags or command-line arguments.</p>
<p>The ANSI color recipe will hopefully provide some examples of cleaning up output to users. For example, in logging, being able to color text based on its purpose can sometimes make large blocks of text significantly more clear.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using command-line flags</h1>
                </header>
            
            <article>
                
<p>The <kbd>flag</kbd> package makes it simple to add command-line flag arguments to a Go application. It has a few shortcomings--you tend to duplicate a lot of code in order to add shorthand versions of flags, and they're ordered alphabetically from the help prompt. There are a number of third-party libraries that attempt to address these shortcomings, but this chapter will focus on the standard library version and not on those libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>, and configure your <kbd>GOPATH</kbd> environment variable:</li>
<li>Open a terminal/console application, and navigate to your <kbd>GOPATH/src</kbd> and create a project directory, for example, <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="3">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter2/flags</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter2/flags">https://github.com/agtorre/go-cookbook/tree/master/chapter2/flags</a>, or use this as an exercise to write some of your own code!</li>
</ol>
<p>Â </p>
<ol start="3">
<li>Create a file called <kbd>flags.go</kbd> with the following contents:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>             "flag"<br/>             "fmt"<br/>        )<br/><br/>        // Config will be the holder for our flags<br/>        type Config struct {<br/>             subject string<br/>             isAwesome bool<br/>             howAwesome int<br/>             countTheWays CountTheWays<br/>        }<br/><br/>        // Setup initializes a config from flags that<br/>        // are passed in<br/>        func (c *Config) Setup() {<br/>            // you can set a flag directly like so:<br/>            // var someVar = flag.String("flag_name", "default_val",           <br/>            // "description")<br/>            // but in practice putting it in a struct is generally <br/>            // better longhand<br/>            flag.StringVar(&amp;c.subject, "subject", "", "subject is a           <br/>            string, it defaults to empty")<br/>            // shorthand<br/>            flag.StringVar(&amp;c.subject, "s", "", "subject is a string, <br/>            it defaults to empty (shorthand)")<br/><br/>           flag.BoolVar(&amp;c.isAwesome, "isawesome", false, "is it <br/>           awesome or what?")<br/>           flag.IntVar(&amp;c.howAwesome, "howawesome", 10, "how awesome <br/>           out of 10?")<br/><br/>           // custom variable type<br/>           flag.Var(&amp;c.countTheWays, "c", "comma separated list of <br/>           integers")<br/>        }<br/><br/>        // GetMessage uses all of the internal<br/>        // config vars and returns a sentence<br/>        func (c *Config) GetMessage() string {<br/>            msg := c.subject<br/>            if c.isAwesome {<br/>                msg += " is awesome"<br/>            } else {<br/>                msg += " is NOT awesome"<br/>            }<br/><br/>            msg = fmt.Sprintf("%s with a certainty of %d out of 10. Let <br/>            me count the ways %s", msg, c.howAwesome, <br/>            c.countTheWays.String())<br/>            return msg<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>custom.go</kbd> with the following contents:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "strconv"<br/>            "strings"<br/>        )<br/><br/>        // CountTheWays is a custom type that<br/>        // we'll read a flag into<br/>        type CountTheWays []int<br/><br/>        func (c *CountTheWays) String() string {<br/>            result := ""<br/>            for _, v := range *c {<br/>                if len(result) &gt; 0 {<br/>                    result += " ... "<br/>                }<br/>                result += fmt.Sprint(v)<br/>            }<br/>            return result<br/>        }<br/><br/>        // Set will be used by the flag package<br/>        func (c *CountTheWays) Set(value string) error {<br/>            values := strings.Split(value, ",")<br/><br/>            for _, v := range values {<br/>                i, err := strconv.Atoi(v)<br/>                if err != nil {<br/>                    return err<br/>                }<br/>                *c = append(*c, i)<br/>            }<br/><br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>main.go</kbd> with the following contents:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "flag"<br/>            "fmt"<br/>        )<br/><br/>        func main() {<br/>            // initialize our setup<br/>            c := Config{}<br/>            c.Setup()<br/><br/>            // generally call this from main<br/>            flag.Parse()<br/><br/>            fmt.Println(c.GetMessage())<br/>        }
</pre>
<ol start="6">
<li>Run the following commands on the command line:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./flags -h</strong>
</pre>
<ol start="7">
<li>Try these and some other arguments, and you should see the following output:</li>
</ol>
<pre>
<strong>      $ go build </strong><br/><strong>      $ ./flags -h </strong><br/><strong>      Usage of ./flags:</strong><br/><strong>       -c value</strong><br/><strong>       comma separated list of integers</strong><br/><strong>       -howawesome int</strong><br/><strong>       how awesome out of 10? (default 10)</strong><br/><strong>       -isawesome</strong><br/><strong>       is it awesome or what? (default false)</strong><br/><strong>       -s string</strong><br/><strong>       subject is a string, it defaults to empty (shorthand)</strong><br/><strong>       -subject string</strong><br/><strong>       subject is a string, it defaults to empty</strong><br/><strong>      $ ./flags -s Go -isawesome -howawesome 10 -c 1,2,3 </strong><br/><strong>      Go is awesome with a certainty of 10 out of 10. Let me count <br/>      the ways 1 ... 2 ... 3</strong>
</pre>
<ol start="8">
<li><span>If you copied or wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe attempts to demonstrate most of the common usages of the <kbd>flag</kbd> package. It shows custom variable types, a variety of built-in variables, shorthand flags, and writing all flags to a common struct. This is the first recipe to require a main function, as the main usage of flag (<kbd>flag.Parse()</kbd>) should be called from main. As a result, the normal example directory is omitted.</p>
<p>The example usage of this application shows that you get <kbd>-h</kbd> automatically to get a list of flags that are included. Some other things to note are Boolean flags that are invoked without arguments, and the flag order doesn't matter.</p>
<p>The <kbd>flag</kbd> package is a quick way to structure input for command-line applications and provide a flexible means of specifying upfront user input for things such as setting up log levels or verbosity of an application. In the command-line arguments recipe, we'll explore flag sets and switch between them using arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using command-line arguments</h1>
                </header>
            
            <article>
                
<p>The flags from the previous recipe are a type of command-line argument. This chapter will expand on other uses for these arguments by constructing a command that supports nested subcommands. This will demonstrate Flagsets and also use positional arguments passed into your application.</p>
<p>Like the previous recipe, this one requires a main function to run. There are a number of third-party packages to deal with complex nested arguments and flags, but we'll investigate how to do that using only the standard library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the <em>Using command-line flags</em></span> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create a new directory called <kbd>chapter2/cmdargs</kbd> and navigate to that directory.</li>
</ol>
<p>Â </p>
<ol start="2">
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter2/cmdargs">https://github.com/agtorre/go-cookbook/tree/master/chapter2/cmdargs</a>, or use this as an exercise to write some of your own code!</li>
<li>Create a file called <kbd>cmdargs.go</kbd> with the following contents:</li>
</ol>
<pre>
        package main<br/>        import (<br/>            "flag"<br/>            "fmt"<br/>            "os"<br/>        )<br/>        const version = "1.0.0"<br/>        const usage = `Usage:<br/>        %s [command]<br/>        Commands:<br/>            Greet<br/>            Version<br/>        `<br/>        const greetUsage = `Usage:<br/>        %s greet name [flag]<br/>        Positional Arguments:<br/>            name<br/>                the name to greet<br/>        Flags:<br/>        `<br/>        // MenuConf holds all the levels<br/>        // for a nested cmd line argument<br/>        type MenuConf struct {<br/>            Goodbye bool<br/>        }<br/>        // SetupMenu initializes the base flags<br/>        func (m *MenuConf) SetupMenu() *flag.FlagSet {<br/>            menu := flag.NewFlagSet("menu", flag.ExitOnError)<br/>            menu.Usage = func() {<br/>                fmt.Printf(usage, os.Args[0])<br/>                menu.PrintDefaults()<br/>            }<br/>            return menu<br/>        }<br/>        // GetSubMenu return a flag set for a submenu<br/>        func (m *MenuConf) GetSubMenu() *flag.FlagSet {<br/>            submenu := flag.NewFlagSet("submenu", flag.ExitOnError)<br/>            submenu.BoolVar(&amp;m.Goodbye, "goodbye", false, "Say goodbye <br/>            instead of hello")<br/>            submenu.Usage = func() {<br/>                fmt.Printf(greetUsage, os.Args[0])<br/>                submenu.PrintDefaults()<br/>            }<br/>            return submenu<br/>        }<br/>        // Greet will be invoked by the greet command<br/>        func (m *MenuConf) Greet(name string) {<br/>            if m.Goodbye {<br/>                fmt.Println("Goodbye " + name + "!")<br/>            } else {<br/>                fmt.Println("Hello " + name + "!")<br/>            }<br/>        }<br/>        // Version prints the current version that is<br/>        // stored as a const<br/>        func (m *MenuConf) Version() {<br/>            fmt.Println("Version: " + version)<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>main.go</kbd> with the following contents:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "os"<br/>            "strings"<br/>        )<br/><br/>        func main() {<br/>            c := MenuConf{}<br/>            menu := c.SetupMenu()<br/>            menu.Parse(os.Args[1:])<br/><br/>         // we use arguments to switch between commands<br/>         // flags are also an argument<br/>         if len(os.Args) &gt; 1 {<br/>             // we don't care about case<br/>             switch strings.ToLower(os.Args[1]) {<br/>             case "version":<br/>                 c.Version()<br/>             case "greet":<br/>                 f := c.GetSubMenu()<br/>                 if len(os.Args) &lt; 3 {<br/>                     f.Usage()<br/>                     return<br/>                 }<br/>                 if len(os.Args) &gt; 3 {<br/>                 if.Parse(os.Args[3:])<br/>                 }<br/>                 c.Greet(os.Args[2])<br/>             default:<br/>                 fmt.Println("Invalid command")<br/>                 menu.Usage()<br/>                 return<br/>             }<br/>          } else {<br/>             menu.Usage()<br/>             return<br/>          }<br/>        }
</pre>
<ol start="5">
<li>Run <kbd>go build</kbd>.</li>
<li>Run the following commands and try a few other combinations of arguments:</li>
</ol>
<pre>
<strong>      $./cmdargs -h </strong><br/><strong>      Usage:</strong><br/><br/><strong>      ./cmdargs [command]</strong><br/><br/><strong>      Commands:</strong><br/><strong>       Greet</strong><br/><strong>       Version</strong><br/><br/><strong>      $./cmdargs version</strong><br/><strong>      Version: 1.0.0</strong><br/><br/><strong>      $./cmdargs greet</strong><br/><strong>      Usage:</strong><br/><br/><strong>      ./cmdargs greet name [flag]</strong><br/><br/><strong>      Positional Arguments:</strong><br/><strong>       name</strong><br/><strong>       the name to greet</strong><br/><br/><strong>      Flags:</strong><br/><strong>       -goodbye</strong><br/><strong>       Say goodbye instead of hello</strong><br/><br/><strong>      $./cmdargs greet reader</strong><br/><strong>      Hello reader!</strong><br/><br/><strong>      $./cmdargs greet reader -goodbye</strong><br/><strong>      Goodbye reader!</strong>
</pre>
<ol start="7">
<li><span>If you copied or wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Flagsets can be used to set up independent lists of expected arguments, usage strings, and more. The developer is required to do validation on a number of arguments, parsing in the right subset of arguments to commands and defining usage strings. This can be error-prone and requires a lot of iteration to get it completely right.</p>
<p>The <kbd>flag</kbd> package makes parsing arguments much easier and includes convenience methods to get the number of flags, arguments, and more. This recipe demonstrates basic ways to construct a complex command-line application using arguments including a package-level config, required positional arguments, multi-level command usage, and how to split these things into multiple files or packages if required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading and setting environment variables</h1>
                </header>
            
            <article>
                
<p>Environment variables are another way to pass state into an application beyond reading data in from a file or passing it explicitly over the command line. This recipe will explore some very basic getting and setting of environment variables and then work with the highly useful third-party library <a href="https://github.com/kelseyhightower/envconfig">https://github.com/kelseyhightower/envconfig</a>.</p>
<p>We'll build an application that can read a config via JSON or through environment variables. The next recipe will further explore alternative formats, including TOML and YAML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li><span>Refer to the <em>Getting ready</em> section's steps in the <em>Using command-line flags</em></span> recipe.</li>
<li>Run the <kbd>go get github.com/kelseyhightower/envconfig/</kbd> command.</li>
<li>Run the <kbd>go get github.com/pkg/errors/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li><span>From your</span> terminal/console a<span>pplication, create a new directory called <kbd>chapter2/envvar</kbd> and</span> navigate to that directory.</li>
</ol>
<p>Â </p>
<ol start="2">
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter2/envvar">https://github.com/agtorre/go-cookbook/tree/master/chapter2/envvar</a>, or use this as an exercise to write some of your own code!</li>
<li>Create a file called <kbd>config.go</kbd> with the following contents:</li>
</ol>
<pre>
        package envvar<br/><br/>        import (<br/>            "encoding/json"<br/>            "os"<br/><br/>            "github.com/kelseyhightower/envconfig"<br/>            "github.com/pkg/errors"<br/>        )<br/><br/>        // LoadConfig will load files optionally from the json file <br/>        // stored at path, then will override those values based on the <br/>        // envconfig struct tags. The envPrefix is how we prefix our <br/>        // environment variables.<br/>        func LoadConfig(path, envPrefix string, config interface{}) <br/>        error {<br/>            if path != "" {<br/>               err := LoadFile(path, config)<br/>               if err != nil {<br/>                   return errors.Wrap(err, "error loading config from <br/>                   file")<br/>               }<br/>            }<br/>            err := envconfig.Process(envPrefix, config)<br/>            return errors.Wrap(err, "error loading config from env")<br/>        }<br/><br/>        // LoadFile unmarshalls a json file into a config struct<br/>        func LoadFile(path string, config interface{}) error {<br/>            configFile, err := os.Open(path)<br/>            if err != nil {<br/>                return errors.Wrap(err, "failed to read config file")<br/>         }<br/>         defer configFile.Close()<br/><br/>         decoder := json.NewDecoder(configFile)<br/>         if err = decoder.Decode(config); err != nil {<br/>             return errors.Wrap(err, "failed to decode config file")<br/>         }<br/>         return nil<br/>        }
</pre>
<ol start="4">
<li>Create a new directory named <kbd>example</kbd>.</li>
</ol>
<p>Â </p>
<ol start="5">
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file, <kbd>main.go</kbd>, with the following contents and ensure that you modify the <kbd>envvar</kbd> import to use the path you set up in step 1:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "bytes"<br/>            "fmt"<br/>            "io/ioutil"<br/>            "os"<br/> <br/>            "github.com/agtorre/go-cookbook/chapter2/envvar"<br/>        )<br/><br/>        // Config will hold the config we<br/>        // capture from a json file and env vars<br/>        type Config struct {<br/>            Version string `json:"version" required:"true"`<br/>            IsSafe bool `json:"is_safe" default:"true"`<br/>            Secret string `json:"secret"`<br/>        }<br/><br/>        func main() {<br/>            var err error<br/><br/>            // create a temporary file to hold<br/>            // an example json file<br/>            tf, err := ioutil.TempFile("", "tmp")<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            defer tf.Close()<br/>            defer os.Remove(tf.Name())<br/><br/>            // create a json file to hold<br/>            // our secrets<br/>            secrets := `{<br/>                "secret": "so so secret"<br/>            }`<br/><br/>            if _, err =   <br/>            tf.Write(bytes.NewBufferString(secrets).Bytes()); <br/>            err != nil {<br/>                panic(err)<br/>            }<br/><br/>            // We can easily set environment variables<br/>            // as needed<br/>            if err = os.Setenv("EXAMPLE_VERSION", "1.0.0"); err != nil <br/>            {<br/>                panic(err)<br/>            }<br/>            if err = os.Setenv("EXAMPLE_ISSAFE", "false"); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            c := Config{}<br/>            if err = envvar.LoadConfig(tf.Name(), "EXAMPLE", &amp;c);<br/>            err != nil {<br/>                panic(err)<br/>            }<br/><br/>            fmt.Println("secrets file contains =", secrets)<br/><br/>            // We can also read them<br/>            fmt.Println("EXAMPLE_VERSION =", <br/>            os.Getenv("EXAMPLE_VERSION"))<br/>            fmt.Println("EXAMPLE_ISSAFE =", <br/>            os.Getenv("EXAMPLE_ISSAFE"))<br/><br/>            // The final config is a mix of json and environment<br/>            // variables<br/>            fmt.Printf("Final Config: %#v\n", c)<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run these commands:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<ol start="9">
<li>You should see the following output:</li>
</ol>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      secrets file contains = {</strong><br/><strong>       "secret": "so so secret"</strong><br/><strong>       }</strong><br/><strong>      EXAMPLE_VERSION = 1.0.0</strong><br/><strong>      EXAMPLE_ISSAFE = false</strong><br/><strong>      Final Config: main.Config{Version:"1.0.0", IsSafe:false, <br/>      Secret:"so so secret"}</strong>
</pre>
<p>Â </p>
<ol start="10">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>, and ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Reading and writing environment variables is pretty simple with the <kbd>os</kbd> package. The <kbd>envconfig</kbd> third-party library this recipe uses is a clever way to capture environment variables and specify certain requirements using struct tags.</p>
<p>The <kbd>LoadConfig</kbd> function is a flexible way to pull in configuration information from a variety of sources without a lot of overhead or too many extra dependencies. It would be simple to convert the primary config into another format aside from JSON or just always use environment variables as well.</p>
<p>Also, note the use of errors. We wrap errors throughout the code in this recipe so that we can annotate errors without losing the original error information. There will be more details on this in <a href="e501e4de-b31e-447a-8109-6eee1a7f3a57.xhtml" target="_blank">Chapter 4</a>, <em>Error Handling in Go</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration using TOML, YAML, and JSON</h1>
                </header>
            
            <article>
                
<p>There are many configuration formats that Go, with the use of third-party libraries, has support for. Three of the most popular data formats are TOML, YAML, and JSON. Go can support JSON out of the box, and the others have clues on how to marshal/unmarshal or encode/decode data for these formats. The formats have many benefits beyond configuration, but this chapter will largely focus on converting a Go struct in the form of a configuration struct. This recipe will explore basic input and output using these formats.</p>
<p>These formats also provide an interface by which Go and applications written in other languages can share the same configuration. There are also a number of tools that deal with these formats and simplify working with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li><span>Refer to the <em>Getting ready</em> section's steps in the <em>Using command-line flags</em></span> recipe<em>.</em></li>
<li>Run the <kbd>go get github.com/BurntSushi/toml</kbd> command.</li>
<li><span>Run the</span> <kbd>go get github.com/go-yaml/yaml</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li><span>From your</span> terminal/console application, create a new directory called <kbd>chapter2/confformat</kbd> and navigate to that directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter2/confformat">https://github.com/agtorre/go-cookbook/tree/master/chapter2/confformat</a>, or use this as an exercise to write some of your own code!</li>
<li>Create a file called <kbd>toml.go</kbd> with the following contents:</li>
</ol>
<pre>
        package confformat<br/><br/>        import (<br/>            "bytes"<br/><br/>            "github.com/BurntSushi/toml"<br/>        )<br/><br/>        // TOMLData is our common data struct<br/>        // with TOML struct tags<br/>        type TOMLData struct {<br/>            Name string `toml:"name"`<br/>            Age int `toml:"age"`<br/>        }<br/><br/>        // ToTOML dumps the TOMLData struct to<br/>        // a TOML format bytes.Buffer<br/>        func (t *TOMLData) ToTOML() (*bytes.Buffer, error) {<br/>            b := &amp;bytes.Buffer{}<br/>            encoder := toml.NewEncoder(b)<br/>        <br/>            if err := encoder.Encode(t); err != nil {<br/>                return nil, err<br/>            }<br/>            return b, nil<br/>        }<br/><br/>        // Decode will decode into TOMLData<br/>        func (t *TOMLData) Decode(data []byte) (toml.MetaData, error) {<br/>            return toml.Decode(string(data), t)<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>yaml.go</kbd> with the following contents:</li>
</ol>
<pre>
        package confformat<br/><br/>        import (<br/>            "bytes"<br/><br/>            "github.com/go-yaml/yaml"<br/>        )<br/><br/>        // YAMLData is our common data struct<br/>        // with YAML struct tags<br/>        type YAMLData struct {<br/>            Name string `yaml:"name"`<br/>            Age int `yaml:"age"`<br/>        }<br/><br/>        // ToYAML dumps the YAMLData struct to<br/>        // a YAML format bytes.Buffer<br/>        func (t *YAMLData) ToYAML() (*bytes.Buffer, error) {<br/>            d, err := yaml.Marshal(t)<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/><br/>            b := bytes.NewBuffer(d)<br/><br/>            return b, nil<br/>        }<br/><br/>        // Decode will decode into TOMLData<br/>        func (t *YAMLData) Decode(data []byte) error {<br/>            return yaml.Unmarshal(data, t)<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>json.go</kbd> with the following contents:</li>
</ol>
<pre>
        package confformat<br/><br/>        import (<br/>            "bytes"<br/>            "encoding/json"<br/>            "fmt"<br/>        )<br/><br/>        // JSONData is our common data struct<br/>        // with JSON struct tags<br/>        type JSONData struct {<br/>            Name string `json:"name"`<br/>            Age int `json:"age"`<br/>        }<br/><br/>        // ToJSON dumps the JSONData struct to<br/>        // a JSON format bytes.Buffer<br/>        func (t *JSONData) ToJSON() (*bytes.Buffer, error) {<br/>            d, err := json.Marshal(t)<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/><br/>            b := bytes.NewBuffer(d)<br/><br/>            return b, nil<br/>        }<br/><br/>        // Decode will decode into JSONData<br/>        func (t *JSONData) Decode(data []byte) error {<br/>            return json.Unmarshal(data, t)<br/>        }<br/><br/>        // OtherJSONExamples shows ways to use types<br/>        // beyond structs and other useful functions<br/>        func OtherJSONExamples() error {<br/>            res := make(map[string]string)<br/>            err := json.Unmarshal([]byte(`{"key": "value"}`), &amp;res)<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("We can unmarshal into a map instead of a <br/>            struct:", res)<br/><br/>            b := bytes.NewReader([]byte(`{"key2": "value2"}`))<br/>            decoder := json.NewDecoder(b)<br/><br/>            if err := decoder.Decode(&amp;res); err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("we can also use decoders/encoders to work with <br/>            streams:", res)<br/><br/>            return nil<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>marshal.go</kbd> with the following contents:</li>
</ol>
<pre>
        package confformat<br/><br/>        import "fmt"<br/><br/>        // MarshalAll takes some data stored in structs<br/>        // and converts them to the various data formats<br/>        func MarshalAll() error {<br/>            t := TOMLData{<br/>                Name: "Name1",<br/>                Age: 20,<br/>            }<br/><br/>            j := JSONData{<br/>                Name: "Name2",<br/>                Age: 30,<br/>            }<br/><br/>            y := YAMLData{<br/>                Name: "Name3",<br/>                Age: 40,<br/>            }<br/><br/>            tomlRes, err := t.ToTOML()<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("TOML Marshal =", tomlRes.String())<br/><br/>            jsonRes, err := j.ToJSON()<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("JSON Marshal=", jsonRes.String())<br/><br/>            yamlRes, err := y.ToYAML()<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("YAML Marshal =", yamlRes.String())<br/>                return nil<br/>        }
</pre>
<ol start="7">
<li>Create a file called <kbd>unmarshal.go</kbd> with the following contents:</li>
</ol>
<pre>
        package confformat<br/><br/>        import "fmt"<br/><br/>        const (<br/>            exampleTOML = `name="Example1"<br/>        age=99<br/>            `<br/><br/>            exampleJSON = `{"name":"Example2","age":98}`<br/><br/>            exampleYAML = `name: Example3<br/>        age: 97 <br/>            `<br/>        )<br/><br/>        // UnmarshalAll takes data in various formats<br/>        // and converts them into structs<br/>        func UnmarshalAll() error {<br/>            t := TOMLData{}<br/>            j := JSONData{}<br/>            y := YAMLData{}<br/><br/>            if _, err := t.Decode([]byte(exampleTOML)); err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("TOML Unmarshal =", t)<br/><br/>            if err := j.Decode([]byte(exampleJSON)); err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("JSON Unmarshal =", j)<br/><br/>            if err := y.Decode([]byte(exampleYAML)); err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("Yaml Unmarshal =", y)<br/>                return nil<br/>            }
</pre>
<ol start="8">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the <kbd>confformat</kbd> import to use the path you set up in step 1:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter2/confformat"<br/><br/>        func main() {<br/>            if err := confformat.MarshalAll(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            if err := confformat.UnmarshalAll(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            if err := confformat.OtherJSONExamples(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="11">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run these commands:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<ol start="13">
<li><span>Yo</span>u sho<span>uld see the following:</span></li>
</ol>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      TOML Marshal = name = "Name1"</strong><br/><strong>      age = 20</strong><br/><br/><strong>      JSON Marshal= {"name":"Name2","age":30}</strong><br/><strong>      YAML Marshal = name: Name3</strong><br/><strong>      age: 40</strong><br/><br/><strong>      TOML Unmarshal = {Example1 99}</strong><br/><strong>      JSON Unmarshal = {Example2 98}</strong><br/><strong>      Yaml Unmarshal = {Example3 97}</strong><br/><strong>      We can unmarshal into a map instead of a struct: map[key:value]</strong><br/><strong>      we can also use decoders/encoders to work with streams: <br/>      map[key:value key2:value2]</strong>
</pre>
<ol start="14">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe gave examples of using a TOML, YAML, and JSON parser to both write raw data to a go struct and read data out of it and into the corresponding format. Like with the recipes in <a href="134503a3-8076-4d84-bb47-64f5880d6596.xhtml" target="_blank">Chapter 1</a>, <em>I/O and File Systems</em>, we see how common it is to quickly switch between <kbd>[]byte</kbd>, <kbd>string</kbd>, <kbd>bytes.Buffer</kbd>, and other I/O interfaces.</p>
<p>The <kbd>encoding/json</kbd> package is the most comprehensive in providing encoding, marshaling, and other methods to work with the JSON format. We abstracted these away with our <kbd>ToFormat</kbd> functions, and it would be very simple to attach multiple methods such as this to use a single struct that can quickly be converted to or from any of these types.</p>
<p>This section also used and touched upon struct tags and their use. The previous chapter also made use of these, and they're a common way in Go to give hints to packages and libraries about how to treat data contained within a struct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Unix pipes</h1>
                </header>
            
            <article>
                
<p>Unix pipes are useful when passing the output of one program to the input of another. For example, take a look at this:</p>
<pre>
<strong>$ echo "test case" | wc -l</strong><br/><strong>   1</strong>
</pre>
<p>In a Go application, the left-hand side of the pipe can be read in using <kbd>os.Stdin</kbd> and acts like a file descriptor. To demonstrate this, this recipe will take an input on the left-hand side of a pipe and return a list of words and their number of occurrences. These words will be tokenized on white space.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the <em>Using command-line flags</em></span> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li><span>From yo</span>ur terminal/console application, create a new directory called <kbd>chapter2/pipes</kbd> and navigate to that directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter2/pipes">https://github.com/agtorre/go-cookbook/tree/master/chapter2/pipes</a>, or use this as an exercise to write some of your own code!</li>
</ol>
<p>Â </p>
<ol start="3">
<li>Create a file called <kbd>pipes.go</kbd> with the following contents:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "bufio"<br/>            "fmt"<br/>            "io"<br/>            "os"<br/>        )<br/><br/>        // WordCount takes a file and returns a map<br/>        // with each word as a key and it's number of<br/>        // appearances as a value<br/>        func WordCount(f io.Reader) map[string]int {<br/>            result := make(map[string]int)<br/><br/>            // make a scanner to work on the file<br/>            // io.Reader interface<br/>            scanner := bufio.NewScanner(f)<br/>            scanner.Split(bufio.ScanWords)<br/><br/>            for scanner.Scan() {<br/>                result[scanner.Text()]++<br/>            }<br/><br/>            if err := scanner.Err(); err != nil {<br/>                fmt.Fprintln(os.Stderr, "reading input:", err)<br/>            }<br/><br/>            return result<br/>        }<br/><br/>        func main() {<br/>            fmt.Printf("string: number_of_occurrences\n\n")<br/>            for key, value := range WordCount(os.Stdin) {<br/>                fmt.Printf("%s: %d\n", key, value)<br/>            }<br/>        }
</pre>
<ol start="4">
<li>Run <kbd>echo "some string" | go run pipes.go</kbd>.</li>
<li>You may also run these:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      echo "some string" | ./pipes</strong>
</pre>
<p style="padding-left: 90px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ echo "test case" | go run pipes.go</strong><br/><strong>      string: number_of_occurrences</strong><br/><br/><strong>      test: 1</strong><br/><strong>      case: 1</strong><br/><br/><strong>      $ echo "test case test" | go run pipes.go</strong><br/><strong>      string: number_of_occurrences</strong><br/><br/><strong>      test: 2</strong><br/><strong>      case: 1</strong>
</pre>
<ol start="6">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Working with pipes in go is pretty simple, especially if you're familiar with working with files. For example, you could use the pipe recipe from <a href="134503a3-8076-4d84-bb47-64f5880d6596.xhtml" target="_blank">Chapter 1</a>, <em>I/O and File Systems</em>, to create a <strong>tee</strong> application (<a href="https://en.wikipedia.org/wiki/Tee_(command)">https://en.wikipedia.org/wiki/Tee_(command)</a>) where everything piped in is immediately written to stdout and to a file.</p>
<p>This recipe uses a scanner to tokenize the <kbd>io.Reader</kbd> interface of the <kbd>os.Stdin</kbd> file object. You can see how you must check for errors after completing all of the reads.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catching and handling signals</h1>
                </header>
            
            <article>
                
<p>Signals are a useful way for the user or the OS to kill your running application. Sometimes, it makes sense to handle these signals in a more graceful way than the default behavior. Go provides a mechanism to catch and handle signals. In this recipe, we'll explore the handling of signals through the use of a signal handling the Go routine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the <em>Using command-line flags</em></span> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li><span>From yo</span>ur terminal/console application, create a new directory called <kbd>chapter2/signals</kbd>, and navigate to that directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter2/signals">https://github.com/agtorre/go-cookbook/tree/master/chapter2/signals</a>, or use this as an exercise to write some of your own code!</li>
<li>Create a file called <kbd>signals.go</kbd> with the following contents:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "os"<br/>            "os/signal"<br/>            "syscall"<br/>        )<br/><br/>        // CatchSig sets up a listener for<br/>        // SIGINT interrupts<br/>        func CatchSig(ch chan os.Signal, done chan bool) {<br/>            // block on waiting for a signal<br/>            sig := &lt;-ch<br/>            // print it when it's received<br/>            fmt.Println("nsig received:", sig)<br/><br/>            // we can set up handlers for all types of<br/>            // sigs here<br/>            switch sig {<br/>            case syscall.SIGINT:<br/>                fmt.Println("handling a SIGINT now!")<br/>            case syscall.SIGTERM:<br/>                fmt.Println("handling a SIGTERM in an entirely <br/>                different way!")<br/>            default:<br/>                fmt.Println("unexpected signal received")<br/>            }<br/><br/>            // terminate<br/>            done &lt;- true<br/>        }<br/><br/>        func main() {<br/>            // initialize our channels<br/>            signals := make(chan os.Signal)<br/>            done := make(chan bool)<br/><br/>            // hook them up to the signals lib<br/>            signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)<br/><br/>            // if a signal is caught by this go routine<br/>            // it will write to done<br/>            go CatchSig(signals, done)<br/><br/>            fmt.Println("Press ctrl-c to terminate...")<br/>            // the program blogs until someone writes to done<br/>            &lt;-done<br/>            fmt.Println("Done!")<br/><br/>        }
</pre>
<ol start="4">
<li>Run these commands:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./signals</strong>
</pre>
<ol start="5">
<li>Try running and pressing <em>Ctrl</em> + <em>C</em>, and you should see this:</li>
</ol>
<pre>
<strong>      $./signals</strong><br/><strong>      Press ctrl-c to terminate...</strong><br/><strong>      ^C</strong><br/><strong>      sig received: interrupt</strong><br/><strong>      handling a SIGINT now!</strong><br/><strong>      Done!</strong>
</pre>
<ol start="6">
<li>Try running it again and from a separate terminal, determine the PID, and kill the application:</li>
</ol>
<pre>
<strong>      $./signals</strong><br/><strong>      Press ctrl-c to terminate...</strong><br/><br/><strong>      # in a separate terminal</strong><br/><strong>      $ ps -ef | grep signals</strong><br/><strong>       501 30777 26360 0 5:00PM ttys000 0:00.00 ./signals</strong><br/><br/><strong>      $ kill -SIGTERM 30777</strong><br/><br/><strong>      # in the original terminal</strong><br/><br/><strong>      sig received: terminated</strong><br/><strong>      handling a SIGTERM in an entirely different way!</strong><br/><strong>      Done!</strong>
</pre>
<ol start="7">
<li><span>If you copied or wrote your own tests, go up one directory and r</span>un <kbd>go test</kbd>. Ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe makes use of channels, which are covered more extensively in <a href="6d6aeb0c-68d5-4444-9aa1-a014759a7aab.xhtml" target="_blank">Chapter 9</a>, <em>Parallelism and Concurrency</em>. This is because signals. The <kbd>Notify</kbd> function requires a channel to send signal notifications to. The <kbd>kill</kbd> command is a good way to test passing signals to the applications. We register the types of signal we care about with the signal. The <kbd>Notify</kbd> function. Then, we set up a function in a Go routine to handle any activity on the channel we passed to that function. Once we receive the signal, we can handle it however we want. We can terminate the application, respond with a message, and have different behavior for different signals.</p>
<p>We also use a <kbd>done</kbd> channel to block the application from terminating until a signal is received. Otherwise, the program would terminate immediately. This is unnecessary for long-running applications such as web applications. It can be very useful to create appropriate signal handling routines to do cleanup, especially in applications with large amounts of Go routines that are holding a significant amount of state. A practical example of a graceful shutdown might be to allow current handlers to complete their HTTP requests without terminating them midway.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An ANSI coloring application</h1>
                </header>
            
            <article>
                
<p>Coloring an ANSI terminal application is handled by a variety of code before and after a section of text you want colored. This chapter will explore a basic coloring mechanism to color text red or plain. For a complete application, take a look at <a href="https://github.com/agtorre/gocolorize">https://github.com/agtorre/gocolorize</a>, which supports many more colors and text types and also implements the <kbd>fmt.Formatter</kbd> interface for ease of printing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section's steps in the <em>Using command-line flags</em></span> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li><span>From you</span>r terminal/console application, create and navigate to the <kbd>chapter2/ansicolor</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter2/ansicolor">https://github.com/agtorre/go-cookbook/tree/master/chapter2/ansicolor</a>, or use this as an exercise to write some of your own code!</li>
<li>Create a file called <kbd>color.go</kbd> with the following contents:</li>
</ol>
<pre>
        package ansicolor<br/><br/>        import "fmt"<br/><br/>        //Color of text<br/>        type Color int<br/><br/>        const (<br/>            // ColorNone is default<br/>            ColorNone = iota<br/>            // Red colored text<br/>            Red<br/>            // Green colored text<br/>            Green<br/>            // Yellow colored text<br/>            Yellow<br/>            // Blue colored text<br/>            Blue<br/>            // Magenta colored text<br/>            Magenta<br/>            // Cyan colored text<br/>            Cyan<br/>            // White colored text<br/>            White<br/>            // Black colored text<br/>            Black Color = -1<br/>        )<br/><br/>        // ColorText holds a string and its color<br/>        type ColorText struct {<br/>            TextColor Color<br/>            Text      string<br/>        }<br/><br/>        func (r *ColorText) String() string {<br/>            if r.TextColor == ColorNone {<br/>                return r.Text<br/>            }<br/><br/>            value := 30<br/>            if r.TextColor != Black {<br/>                value += int(r.TextColor)<br/>            }<br/>            return fmt.Sprintf("33[0;%dm%s33[0m", value, r.Text)<br/>        }
</pre>
<ol start="4">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following contents and ensure that you modify the <kbd>ansicolor</kbd> import to use the path you set up in step 1:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter2/ansicolor"<br/>        )<br/><br/>        func main() {<br/>            r := ansicolor.ColorText{<br/>                TextColor: ansicolor.Red,<br/>                Text:      "I'm red!",<br/>            }<br/><br/>            fmt.Println(r.String())<br/><br/>            r.TextColor = ansicolor.Green<br/>            r.Text = "Now I'm green!"<br/><br/>            fmt.Println(r.String())<br/><br/>            r.TextColor = ansicolor.ColorNone<br/>            r.Text = "Back to normal..."<br/><br/>            fmt.Println(r.String())<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
</ol>
<p>Â </p>
<ol start="8">
<li>You may also run these commands:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<ol start="9">
<li><span>You</span> should see <span>the following output with the text colored if your terminal supports the ANSI coloring format:</span></li>
</ol>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      I'm red!</strong><br/><strong>      Now I'm green!</strong><br/><strong>      Back to normal...</strong>
</pre>
<ol start="10">
<li><span>If you copied or wrote your own tests, go up one directory and ru</span>n <kbd>go test</kbd>. Ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This application makes use of a struct to maintain the state of the colored text. In this case, it stores the color of the text and the value of the text. The final string is rendered when you call the <kbd>String()</kbd> method, which will return either the colored text or plain text depending on the values stored in the struct. By default, the text will be plain.</p>


            </article>

            
        </section>
    </body></html>