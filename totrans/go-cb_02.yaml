- en: Command-Line Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using command-line flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and setting environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration using TOML, YAML, and JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unix pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching and handling signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ANSI coloring application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-line applications are among the easiest ways to handle user input and
    output. This chapter will focus on command-line-based interactions, such as command-line
    arguments, configuration, and environment variables. It'll conclude with a library
    for coloring text output in Unix and Bash for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: With the recipes in this chapter, you should be equipped to handle expected
    and unexpected user input. The signal recipe is an example of cases where users
    may send unexpected signals to your application, and the pipes recipe is a good
    alternative to taking user inputs compared to flags or command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The ANSI color recipe will hopefully provide some examples of cleaning up output
    to users. For example, in logging, being able to color text based on its purpose
    can sometimes make large blocks of text significantly more clear.
  prefs: []
  type: TYPE_NORMAL
- en: Using command-line flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `flag` package makes it simple to add command-line flag arguments to a Go
    application. It has a few shortcomings--you tend to duplicate a lot of code in
    order to add shorthand versions of flags, and they're ordered alphabetically from
    the help prompt. There are a number of third-party libraries that attempt to address
    these shortcomings, but this chapter will focus on the standard library version
    and not on those libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install),
    and configure your `GOPATH` environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal/console application, and navigate to your `GOPATH/src` and create
    a project directory, for example, `$GOPATH/src/github.com/yourusername/customrepo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All code will be run and modified from this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter2/flags`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter2/flags](https://github.com/agtorre/go-cookbook/tree/master/chapter2/flags),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `flags.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `custom.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `main.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Try these and some other arguments, and you should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe attempts to demonstrate most of the common usages of the `flag`
    package. It shows custom variable types, a variety of built-in variables, shorthand
    flags, and writing all flags to a common struct. This is the first recipe to require
    a main function, as the main usage of flag (`flag.Parse()`) should be called from
    main. As a result, the normal example directory is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: The example usage of this application shows that you get `-h` automatically
    to get a list of flags that are included. Some other things to note are Boolean
    flags that are invoked without arguments, and the flag order doesn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: The `flag` package is a quick way to structure input for command-line applications
    and provide a flexible means of specifying upfront user input for things such
    as setting up log levels or verbosity of an application. In the command-line arguments
    recipe, we'll explore flag sets and switch between them using arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flags from the previous recipe are a type of command-line argument. This
    chapter will expand on other uses for these arguments by constructing a command
    that supports nested subcommands. This will demonstrate Flagsets and also use
    positional arguments passed into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Like the previous recipe, this one requires a main function to run. There are
    a number of third-party packages to deal with complex nested arguments and flags,
    but we'll investigate how to do that using only the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using command-line flags*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter2/cmdargs`
    and navigate to that directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter2/cmdargs](https://github.com/agtorre/go-cookbook/tree/master/chapter2/cmdargs),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `cmdargs.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `main.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run `go build`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following commands and try a few other combinations of arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flagsets can be used to set up independent lists of expected arguments, usage
    strings, and more. The developer is required to do validation on a number of arguments,
    parsing in the right subset of arguments to commands and defining usage strings.
    This can be error-prone and requires a lot of iteration to get it completely right.
  prefs: []
  type: TYPE_NORMAL
- en: The `flag` package makes parsing arguments much easier and includes convenience
    methods to get the number of flags, arguments, and more. This recipe demonstrates
    basic ways to construct a complex command-line application using arguments including
    a package-level config, required positional arguments, multi-level command usage,
    and how to split these things into multiple files or packages if required.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and setting environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environment variables are another way to pass state into an application beyond
    reading data in from a file or passing it explicitly over the command line. This
    recipe will explore some very basic getting and setting of environment variables
    and then work with the highly useful third-party library [https://github.com/kelseyhightower/envconfig](https://github.com/kelseyhightower/envconfig).
  prefs: []
  type: TYPE_NORMAL
- en: We'll build an application that can read a config via JSON or through environment
    variables. The next recipe will further explore alternative formats, including
    TOML and YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using command-line flags*
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/kelseyhightower/envconfig/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/pkg/errors/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter2/envvar`
    and navigate to that directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter2/envvar](https://github.com/agtorre/go-cookbook/tree/master/chapter2/envvar),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `config.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file, `main.go`, with the following contents and ensure that you modify
    the `envvar` import to use the path you set up in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`,
    and ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading and writing environment variables is pretty simple with the `os` package.
    The `envconfig` third-party library this recipe uses is a clever way to capture
    environment variables and specify certain requirements using struct tags.
  prefs: []
  type: TYPE_NORMAL
- en: The `LoadConfig` function is a flexible way to pull in configuration information
    from a variety of sources without a lot of overhead or too many extra dependencies.
    It would be simple to convert the primary config into another format aside from
    JSON or just always use environment variables as well.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note the use of errors. We wrap errors throughout the code in this recipe
    so that we can annotate errors without losing the original error information.
    There will be more details on this in [Chapter 4](e501e4de-b31e-447a-8109-6eee1a7f3a57.xhtml),
    *Error Handling in Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration using TOML, YAML, and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many configuration formats that Go, with the use of third-party libraries,
    has support for. Three of the most popular data formats are TOML, YAML, and JSON.
    Go can support JSON out of the box, and the others have clues on how to marshal/unmarshal
    or encode/decode data for these formats. The formats have many benefits beyond
    configuration, but this chapter will largely focus on converting a Go struct in
    the form of a configuration struct. This recipe will explore basic input and output
    using these formats.
  prefs: []
  type: TYPE_NORMAL
- en: These formats also provide an interface by which Go and applications written
    in other languages can share the same configuration. There are also a number of
    tools that deal with these formats and simplify working with them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using command-line flags*
    recipe*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/BurntSushi/toml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/go-yaml/yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter2/confformat`
    and navigate to that directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter2/confformat](https://github.com/agtorre/go-cookbook/tree/master/chapter2/confformat),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `toml.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `yaml.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `json.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `marshal.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `unmarshal.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the `confformat` import to use the path you set up in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe gave examples of using a TOML, YAML, and JSON parser to both write
    raw data to a go struct and read data out of it and into the corresponding format.
    Like with the recipes in [Chapter 1](134503a3-8076-4d84-bb47-64f5880d6596.xhtml),
    *I/O and File Systems*, we see how common it is to quickly switch between `[]byte`,
    `string`, `bytes.Buffer`, and other I/O interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `encoding/json` package is the most comprehensive in providing encoding,
    marshaling, and other methods to work with the JSON format. We abstracted these
    away with our `ToFormat` functions, and it would be very simple to attach multiple
    methods such as this to use a single struct that can quickly be converted to or
    from any of these types.
  prefs: []
  type: TYPE_NORMAL
- en: This section also used and touched upon struct tags and their use. The previous
    chapter also made use of these, and they're a common way in Go to give hints to
    packages and libraries about how to treat data contained within a struct.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unix pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unix pipes are useful when passing the output of one program to the input of
    another. For example, take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In a Go application, the left-hand side of the pipe can be read in using `os.Stdin`
    and acts like a file descriptor. To demonstrate this, this recipe will take an
    input on the left-hand side of a pipe and return a list of words and their number
    of occurrences. These words will be tokenized on white space.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using command-line flags*
    recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter2/pipes`
    and navigate to that directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter2/pipes](https://github.com/agtorre/go-cookbook/tree/master/chapter2/pipes),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `pipes.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run `echo "some string" | go run pipes.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with pipes in go is pretty simple, especially if you're familiar with
    working with files. For example, you could use the pipe recipe from [Chapter 1](134503a3-8076-4d84-bb47-64f5880d6596.xhtml),
    *I/O and File Systems*, to create a **tee** application ([https://en.wikipedia.org/wiki/Tee_(command)](https://en.wikipedia.org/wiki/Tee_(command)))
    where everything piped in is immediately written to stdout and to a file.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe uses a scanner to tokenize the `io.Reader` interface of the `os.Stdin`
    file object. You can see how you must check for errors after completing all of
    the reads.
  prefs: []
  type: TYPE_NORMAL
- en: Catching and handling signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals are a useful way for the user or the OS to kill your running application.
    Sometimes, it makes sense to handle these signals in a more graceful way than
    the default behavior. Go provides a mechanism to catch and handle signals. In
    this recipe, we'll explore the handling of signals through the use of a signal
    handling the Go routine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using command-line flags*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create a new directory called `chapter2/signals`,
    and navigate to that directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter2/signals](https://github.com/agtorre/go-cookbook/tree/master/chapter2/signals),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `signals.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running and pressing *Ctrl* + *C*, and you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running it again and from a separate terminal, determine the PID, and kill
    the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe makes use of channels, which are covered more extensively in [Chapter
    9](6d6aeb0c-68d5-4444-9aa1-a014759a7aab.xhtml), *Parallelism and Concurrency*.
    This is because signals. The `Notify` function requires a channel to send signal
    notifications to. The `kill` command is a good way to test passing signals to
    the applications. We register the types of signal we care about with the signal.
    The `Notify` function. Then, we set up a function in a Go routine to handle any
    activity on the channel we passed to that function. Once we receive the signal,
    we can handle it however we want. We can terminate the application, respond with
    a message, and have different behavior for different signals.
  prefs: []
  type: TYPE_NORMAL
- en: We also use a `done` channel to block the application from terminating until
    a signal is received. Otherwise, the program would terminate immediately. This
    is unnecessary for long-running applications such as web applications. It can
    be very useful to create appropriate signal handling routines to do cleanup, especially
    in applications with large amounts of Go routines that are holding a significant
    amount of state. A practical example of a graceful shutdown might be to allow
    current handlers to complete their HTTP requests without terminating them midway.
  prefs: []
  type: TYPE_NORMAL
- en: An ANSI coloring application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coloring an ANSI terminal application is handled by a variety of code before
    and after a section of text you want colored. This chapter will explore a basic
    coloring mechanism to color text red or plain. For a complete application, take
    a look at [https://github.com/agtorre/gocolorize](https://github.com/agtorre/gocolorize),
    which supports many more colors and text types and also implements the `fmt.Formatter`
    interface for ease of printing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section's steps in the *Using command-line flags*
    recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter2/ansicolor`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter2/ansicolor](https://github.com/agtorre/go-cookbook/tree/master/chapter2/ansicolor),
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `color.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following contents and ensure that you modify
    the `ansicolor` import to use the path you set up in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output with the text colored if your terminal
    supports the ANSI coloring format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application makes use of a struct to maintain the state of the colored
    text. In this case, it stores the color of the text and the value of the text.
    The final string is rendered when you call the `String()` method, which will return
    either the colored text or plain text depending on the values stored in the struct.
    By default, the text will be plain.
  prefs: []
  type: TYPE_NORMAL
