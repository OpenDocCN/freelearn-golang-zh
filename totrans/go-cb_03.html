<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Data Conversion and Composition</h1>
                </header>
            
            <article>
                
<p>In this chapter, the following recipes will be covered:</p>
<ul>
<li>Converting data types and interface casting</li>
<li>Working with numeric data types using math and math/big</li>
<li>Currency conversions and float64 considerations</li>
<li>Using pointers and SQL NullTypes for encoding and decoding</li>
<li>Encoding and decoding Go data</li>
<li>Struct tags and basic reflection in Go</li>
<li>Implementing collections via closures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Reasoning about Go's typing system is a critical step to all levels of Go development. This chapter will show examples of converting between data types, working with very big numbers, working with currency, types of encoding and decoding, including base64 and gob, and creating custom collections using closures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting data types and interface casting</h1>
                </header>
            
            <article>
                
<p>Go is typically very flexible in conversion between data. A type may inherit another type as follows:</p>
<pre>
type A int
</pre>
<p>Then, we can always cast back to the type we inherited as follows:</p>
<pre>
var a A = 1<br/>fmt.Println(int(a))
</pre>
<p>There are also convenience functions for converting between numbers with casting, between strings and other types using <kbd>fmt.Sprint</kbd> and with <kbd>strconv</kbd>, and between interfaces and types using reflection. This recipe will explore some of these basic conversions that will be used throughout the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application, and navigate to your <kbd>GOPATH/src</kbd> and create a project directory such as <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All the code will be run and modified from this directory.</p>
<ol start="3">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter3/dataconv</kbd> directory.</li>
</ol>
<p>Â </p>
<ol start="2">
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter3/dataconv">https://github.com/agtorre/go-cookbook/tree/master/chapter3/dataconv</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>dataconv.go</kbd> with the following contents:</li>
</ol>
<pre>
        package dataconv<br/><br/>        import "fmt"<br/><br/>        // ShowConv demonstrates some type conversion<br/>        func ShowConv() {<br/>            // int<br/>            var a = 24<br/><br/>            // float 64<br/>            var b = 2.0<br/><br/>            // convert the int to a float64 for this calculation<br/>            c := float64(a) * b<br/>            fmt.Println(c)<br/>  <br/>            // fmt.Sprintf is a good way to convert to strings<br/>            precision := fmt.Sprintf("%.2f", b)<br/><br/>            // print the value and the type<br/>            fmt.Printf("%s - %T\n", precision, precision)<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>strconv.go</kbd> with the following contents:</li>
</ol>
<pre>
        package dataconv<br/><br/>        import (<br/>            "fmt"<br/>            "strconv"<br/>        )<br/><br/>        // Strconv demonstrates some strconv<br/>        // functions<br/>        func Strconv() error {<br/>            //strconv is a good way to convert to and from strings<br/>            s := "1234"<br/>            // we can specify the base (10) and precision<br/>            // 64 bit<br/>            res, err := strconv.ParseInt(s, 10, 64)<br/>            if err != nil {<br/>                return err<br/>          }<br/><br/>          fmt.Println(res)<br/><br/>          // lets try hex<br/>          res, err = strconv.ParseInt("FF", 16, 64)<br/>          if err != nil {<br/>              return err<br/>          }<br/><br/>          fmt.Println(res)<br/><br/>          // we can do other useful things like:<br/>          val, err := strconv.ParseBool("true")<br/>          if err != nil {<br/>              return err<br/>          }<br/><br/>          fmt.Println(val)<br/><br/>          return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>interfaces.go</kbd> with the following contents:</li>
</ol>
<pre>
        package dataconv<br/><br/>        import "fmt"<br/><br/>        // CheckType will print based on the<br/>        // interface type<br/>        func CheckType(s interface{}) {<br/>            switch s.(type) {<br/>            case string:<br/>                fmt.Println("It's a string!")<br/>            case int:<br/>                fmt.Println("It's an int!")<br/>            default:<br/>                fmt.Println("not sure what it is...")<br/>            }<br/>        }<br/><br/>        // Interfaces demonstrates casting<br/>        // from anonymous interfaces to types<br/>        func Interfaces() {<br/>            CheckType("test")<br/>            CheckType(1)<br/>            CheckType(false)<br/><br/>            var i interface{}<br/>            i = "test"<br/><br/>            // manually check an interface<br/>            if val, ok := i.(string); ok {<br/>                fmt.Println("val is", val)<br/>            }<br/><br/>            // this one should fail<br/>            if _, ok := i.(int); !ok {<br/>                fmt.Println("uh oh! glad we handled this")<br/>            }<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file <kbd>main.go</kbd> with the following contents. Be sure to modify the <kbd>dataconv</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter3/dataconv"<br/><br/>        func main() {<br/>            dataconv.ShowConv()<br/>            if err := dataconv.Strconv(); err != nil {<br/>                panic(err)<br/>            }<br/>            dataconv.Interfaces()<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go<br/>      48</strong><br/><strong>      2.00 - string</strong><br/><strong>      1234</strong><br/><strong>      255</strong><br/><strong>      true</strong><br/><strong>      It's a string!</strong><br/><strong>      It's an int!</strong><br/><strong>      not sure what it is...</strong><br/><strong>      val is test</strong><br/><strong>      uh oh! glad we handled this</strong>
</pre>
<ol start="11">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe demonstrates casting between types by wrapping them in a new type, using the <kbd>strconv</kbd> package, and by using interface reflection. These methods allow Go developer to quickly convert between various abstract Go types. will both reveal errors during compilation, but reflection can be more tricky. If you reflect incorrectly to an unsupported type, you'll cause a panic. Switching on type is a way to generalize and is also demonstrated in this recipe.</p>
<p>Conversion becomes important for packages such as <kbd>math</kbd>, which operate on float64 exclusively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with numeric data types using math and math/big</h1>
                </header>
            
            <article>
                
<p>The <kbd>math</kbd> and <kbd>math/big</kbd> packages focus on exposing more complex mathematical operations to the Go language, such as <kbd>Pow</kbd>, <kbd>Sqrt</kbd>, and <kbd>Cos</kbd>. The <kbd>math</kbd> package itself operates predominately on float64 unless a function says otherwise. The <kbd>math/big</kbd> package is for numbers that are too large to represent in a 64-bit value. This recipe will show some basic usage of the <kbd>math</kbd> package and demonstrate <kbd>math/big</kbd> for fibonacci.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>Converting data types and interface casting</em></span> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter3/math</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter3/math">https://github.com/agtorre/go-cookbook/tree/master/chapter3/math</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>math.go</kbd> with the following contents:</li>
</ol>
<pre>
        package math<br/><br/>        import (<br/>         "fmt"<br/>         "math"<br/>        )<br/><br/>        // Examples demonstrates some of the functions<br/>        // in the math package<br/>        func Examples() {<br/>            //sqrt Examples<br/>            i := 25<br/><br/>            // i is an int, so convert<br/>            result := math.Sqrt(float64(i))<br/><br/>            // sqrt of 25 == 5<br/>            fmt.Println(result)<br/><br/>            // ceil rounds up<br/>            result = math.Ceil(9.5)<br/>            fmt.Println(result)<br/><br/>            // floor rounds down<br/>            result = math.Floor(9.5)<br/>            fmt.Println(result)<br/> <br/>            // math also stores some consts:<br/>            fmt.Println("Pi:", math.Pi, "E:", math.E)<br/>        }
</pre>
<p>Â </p>
<ol start="4">
<li>Create a file called <kbd>fib.go</kbd> with the following contents:</li>
</ol>
<pre>
        package math<br/><br/>        import "math/big"<br/><br/>        // global to memoize fib<br/>        var memoize map[int]*big.Int<br/><br/>        func init() {<br/>            // initialize the map<br/>            memoize = make(map[int]*big.Int)<br/>        }<br/><br/>        // Fib prints the nth digit of the fibonacci sequence<br/>        // it will return 1 for anything &lt; 0 as well...<br/>        // it's calculated recursively and use big.Int since<br/>        // int64 will quickly overflow<br/>        func Fib(n int) *big.Int {<br/>            if n &lt; 0 {<br/>                return nil<br/>            }<br/><br/>            // base case<br/>            if n &lt; 2 {<br/>                memoize[n] = big.NewInt(1)<br/>            }<br/><br/>            // check if we stored it before<br/>            // if so return with no calculation<br/>            if val, ok := memoize[n]; ok {<br/>                return val<br/>            }<br/><br/>            // initialize map then add previous 2 fib values<br/>            memoize[n] = big.NewInt(0)<br/>            memoize[n].Add(memoize[n], Fib(n-1))<br/>            memoize[n].Add(memoize[n], Fib(n-2))<br/><br/>            // return result<br/>            return memoize[n]<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
</ol>
<p>Â </p>
<ol start="7">
<li>Create a file <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>math</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter3/math"<br/>        )<br/><br/>        func main() {<br/>            math.Examples()<br/><br/>            for i := 0; i &lt; 10; i++ {<br/>                fmt.Printf("%v ", math.Fib(i))<br/>            }<br/>            fmt.Println()<br/>        }
</pre>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      5</strong><br/><strong>      10</strong><br/><strong>      9</strong><br/><strong>      Pi: 3.141592653589793 E: 2.718281828459045</strong><br/><strong>      1 1 2 3 5 8 13 21 34 55</strong>
</pre>
<ol start="10">
<li><span>If you</span> copie<span>d or wrote your own tests, go up one directory</span> and run <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>math</kbd> package makes it possible to do complex mathematical operations in Go. This recipe should be used in conjunction with this package for doing complex floating point operations and converting between types as needed. It's worth noting that even with float64, there may still be rounding errors for certain floating point numbers, and the following recipe demonstrates some techniques for dealing with this.</p>
<p>The <kbd>math/big</kbd> section showcases a recursive Fibonacci sequence. If you modify <kbd>main.go</kbd> to loop well beyond 10, you'll quickly overflow int64 if it was used instead of <kbd>big.Int</kbd>. This package also has helper methods to convert between the big types to other types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Currency conversions and float64 considerations</h1>
                </header>
            
            <article>
                
<p>Working with currency is always a tricky process. It can be tempting to represent money as a float64, but this can result in some pretty tricky (and wrong) rounding errors when doing calculations. For this reason, it's preferable to think of money in terms of cents and store it as an Int64.</p>
<p>When collecting user input from forms, the command line, or other sources, money is usually represented in dollar form. For this reason, it's best to treat it as a string and convert that string directly to pennies without floating point conversions. This recipe will present ways to convert a string representation of currency into an int64 (pennies) and back again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>Converting data types and interface casting</em></span> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter3/currency</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter3/currency">https://github.com/agtorre/go-cookbook/tree/master/chapter3/currency</a> or use this as an exercise to write some of your own.</li>
<li>Create a file called <kbd>dollars.go</kbd> with the following contents:</li>
</ol>
<pre>
        package currency<br/><br/>        import (<br/>            "errors"<br/>            "strconv"<br/>            "strings"<br/>        )<br/><br/>        // ConvertStringDollarsToPennies takes a dollar amount<br/>        // as a string, i.e. 1.00, 55.12 etc and converts it<br/>        // into an int64<br/>        func ConvertStringDollarsToPennies(amount string) (int64, <br/>        error) {<br/>            // check if amount can convert to a valid float<br/>            _, err := strconv.ParseFloat(amount, 64)<br/>            if err != nil {<br/>                return 0, err<br/>            }<br/><br/>            // split the value on "."<br/>            groups := strings.Split(amount, ".")<br/><br/>            // if there is no . result will still be<br/>            // captured here<br/>            result := groups[0]<br/><br/>            // base string<br/>            r := ""<br/><br/>            // handle the data after the "."<br/>            if len(groups) == 2 {<br/>                if len(groups[1]) != 2 {<br/>                    return 0, errors.New("invalid cents")<br/>                }<br/>                r = groups[1]<br/>                if len(r) &gt; 2 {<br/>                    r = r[:2]<br/>                }<br/>            }<br/><br/>            // pad with 0, this will be<br/>            // 2 0's if there was no .<br/>            for len(r) &lt; 2 {<br/>                r += "0"<br/>            }<br/><br/>            result += r<br/><br/>            // convert it to an int<br/>            return strconv.ParseInt(result, 10, 64)<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>pennies.go</kbd> with the following contents:</li>
</ol>
<pre>
        package currency<br/><br/>        import (<br/>            "strconv"<br/>        )<br/><br/>        // ConvertPenniesToDollarString takes a penny amount as <br/>        // an int64 and returns a dollar string representation<br/>        func ConvertPenniesToDollarString(amount int64) string {<br/>            // parse the pennies as a base 10 int<br/>            result := strconv.FormatInt(amount, 10)<br/><br/>            // check if negative, will set it back later<br/>            negative := false<br/>            if result[0] == '-' {<br/>                result = result[1:]<br/>                negative = true<br/>            }<br/><br/>            // left pad with 0 if we're passed in value &lt; 100<br/>            for len(result) &lt; 3 {<br/>                result = "0" + result<br/>            }<br/>            length := len(result)<br/><br/>            // add in the decimal<br/>            result = result[0:length-2] + "." + result[length-2:]<br/><br/>            // from the negative we stored earlier!<br/>            if negative {<br/>                result = "-" + result<br/>            }<br/><br/>            return result<br/>        }
</pre>
<p>Â </p>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>currency</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter3/currency"<br/>        )<br/><br/>        func main() {<br/>            // start with our user input<br/>            // of fifteen dollars and 93 cents<br/>            userInput := "15.93"<br/><br/>            pennies, err := <br/>            currency.ConvertStringDollarsToPennies(userInput)<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/><br/>            fmt.Printf("User input converted to %d pennies\n", pennies)<br/><br/>            // adding 15 cents<br/>            pennies += 15<br/><br/>            dollars := currency.ConvertPenniesToDollarString(pennies)<br/><br/>            fmt.Printf("Added 15 cents, new values is %s dollars\n", <br/>            dollars)<br/>        }
</pre>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      User input converted to 1593 pennies</strong><br/><strong>      Added 15 cents, new values is 16.08 dollars</strong>
</pre>
<ol start="10">
<li><span>If y</span>ou copied o<span>r wrote your own tests, go up one directory and r</span>un <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe makes use of the <kbd>strconv</kbd> and <kbd>strings</kbd> packages to convert currency between dollars in string format and pennies in int64. It does this without even converting to a float64 other than as validation.</p>
<p>The <kbd>strconv.ParseInt</kbd> and <kbd>strconv.FormatInt</kbd> functions are very useful for converting to and from int64 and strings. We also made use of the fact that Go strings can easily be appended and sliced as needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using pointers and SQL NullTypes for encoding and decoding</h1>
                </header>
            
            <article>
                
<p>When you encode or decode into an object in Go, types that are not explicitly set will be set to their default values. Strings will default to empty string "", and integers will default to <kbd>0</kbd> as an example. Normally, this is fine, unless <kbd>0</kbd> means something for your API or service that is consuming the user input or returning it.</p>
<p>In addition, if you use struct tags such as <kbd>json omitempty</kbd>, 0 values will be ignored even if they're valid. <span>Another example of this is <kbd>Null</kbd> that returns from SQL</span>. What value best represents <kbd>Null</kbd> for an <kbd>Int</kbd>? This recipe will explore some of the ways Go developers deal with this issue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>Converting data types and interface casting</em></span> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter3/nulls</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter3/nulls">https://github.com/agtorre/go-cookbook/tree/master/chapter3/nulls</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>base.go</kbd> with the following contents:</li>
</ol>
<pre>
        package nulls<br/><br/>        import (<br/>            "encoding/json"<br/>            "fmt"<br/>        )<br/><br/>        // json that has name but not age<br/>        const (<br/>            jsonBlob = `{"name": "Aaron"}`<br/>            fulljsonBlob = `{"name":"Aaron", "age":0}`<br/>        )<br/><br/>        // Example is a basic struct with age<br/>        // and name fields<br/>        type Example struct {<br/>            Age int `json:"age,omitempty"`<br/>            Name string `json:"name"`<br/>        }<br/><br/>        // BaseEncoding shows encoding and<br/>        // decoding with normal types<br/>        func BaseEncoding() error {<br/>            e := Example{}<br/><br/>            // note that no age = 0 age<br/>            if err := json.Unmarshal([]byte(jsonBlob), &amp;e); err != nil <br/>            {<br/>                return err<br/>            }<br/>            fmt.Printf("Regular Unmarshal, no age: %+v\n", e)<br/>        <br/>            value, err := json.Marshal(&amp;e)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("Regular Marshal, with no age:", string(value))<br/><br/>            if err := json.Unmarshal([]byte(fulljsonBlob), &amp;e);<br/>            err != nil {<br/>                return err<br/>            }<br/>            fmt.Printf("Regular Unmarshal, with age = 0: %+v\n", e)<br/><br/>            value, err = json.Marshal(&amp;e)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("Regular Marshal, with age = 0:", <br/>            string(value))<br/><br/>            return nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>pointer.go</kbd> with the following contents:</li>
</ol>
<pre>
        package nulls<br/><br/>        import (<br/>            "encoding/json"<br/>            "fmt"<br/>        )<br/><br/>        // ExamplePointer is the same, but<br/>        // uses a *Int<br/>        type ExamplePointer struct {<br/>            Age *int `json:"age,omitempty"`<br/>            Name string `json:"name"`<br/>        }<br/><br/>        // PointerEncoding shows methods for<br/>        // dealing with nil/omitted values<br/>        func PointerEncoding() error {<br/><br/>            // note that no age = nil age<br/>            e := ExamplePointer{}<br/>            if err := json.Unmarshal([]byte(jsonBlob), &amp;e); err != nil <br/>            {<br/>                return err<br/>            }<br/>            fmt.Printf("Pointer Unmarshal, no age: %+v\n", e)<br/><br/>            value, err := json.Marshal(&amp;e)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("Pointer Marshal, with no age:", string(value))<br/><br/>            if err := json.Unmarshal([]byte(fulljsonBlob), &amp;e);<br/>            err != nil {<br/>                return err<br/>            }<br/>            fmt.Printf("Pointer Unmarshal, with age = 0: %+v\n", e)<br/><br/>            value, err = json.Marshal(&amp;e)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("Pointer Marshal, with age = 0:",<br/>            string(value))<br/><br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>nullencoding.go</kbd> with the following contents:</li>
</ol>
<pre>
        package nulls<br/><br/>        import (<br/>            "database/sql"<br/>            "encoding/json"<br/>            "fmt"<br/>        )<br/><br/>        type nullInt64 sql.NullInt64<br/><br/>        // ExampleNullInt is the same, but<br/>        // uses a sql.NullInt64<br/>        type ExampleNullInt struct {<br/>            Age *nullInt64 `json:"age,omitempty"`<br/>            Name string `json:"name"`<br/>        }<br/><br/>        func (v *nullInt64) MarshalJSON() ([]byte, error) {<br/>            if v.Valid {<br/>                return json.Marshal(v.Int64)<br/>            }<br/>            return json.Marshal(nil)<br/>        }<br/><br/>        func (v *nullInt64) UnmarshalJSON(b []byte) error {<br/>            v.Valid = false<br/>            if b != nil {<br/>                v.Valid = true<br/>                return json.Unmarshal(b, &amp;v.Int64)<br/>            }<br/>            return nil<br/>        }<br/><br/>        // NullEncoding shows an alternative method<br/>        // for dealing with nil/omitted values<br/>        func NullEncoding() error {<br/>            e := ExampleNullInt{}<br/><br/>            // note that no means an invalid value<br/>            if err := json.Unmarshal([]byte(jsonBlob), &amp;e); err != nil <br/>            {<br/>                return err<br/>            }<br/>            fmt.Printf("nullInt64 Unmarshal, no age: %+v\n", e)<br/><br/>            value, err := json.Marshal(&amp;e)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("nullInt64 Marshal, with no age:",<br/>            string(value))<br/><br/>            if err := json.Unmarshal([]byte(fulljsonBlob), &amp;e);<br/>            err != nil {<br/>                return err<br/>            }<br/>            fmt.Printf("nullInt64 Unmarshal, with age = 0: %+v\n", e)<br/><br/>            value, err = json.Marshal(&amp;e)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("nullInt64 Marshal, with age = 0:",<br/>            string(value))<br/><br/>            return nil<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>nulls</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter3/nulls"<br/>        )<br/><br/>        func main() {<br/>            if err := nulls.BaseEncoding(); err != nil {<br/>                panic(err)<br/>            }<br/>            fmt.Println()<br/><br/>            if err := nulls.PointerEncoding(); err != nil {<br/>                panic(err)<br/>            }<br/>            fmt.Println()<br/><br/>            if err := nulls.NullEncoding(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Regular Unmarshal, no age: {Age:0 Name:Aaron}</strong><br/><strong>      Regular Marshal, with no age: {"name":"Aaron"}</strong><br/><strong>      Regular Unmarshal, with age = 0: {Age:0 Name:Aaron}</strong><br/><strong>      Regular Marshal, with age = 0: {"name":"Aaron"}</strong><br/><br/><strong>      Pointer Unmarshal, no age: {Age:&lt;nil&gt; Name:Aaron}</strong><br/><strong>      Pointer Marshal, with no age: {"name":"Aaron"}</strong><br/><strong>      Pointer Unmarshal, with age = 0: {Age:0xc42000a610 Name:Aaron}</strong><br/><strong>      Pointer Marshal, with age = 0: {"age":0,"name":"Aaron"}</strong><br/><br/><strong>      nullInt64 Unmarshal, no age: {Age:&lt;nil&gt; Name:Aaron}</strong><br/><strong>      nullInt64 Marshal, with no age: {"name":"Aaron"}</strong><br/><strong>      nullInt64 Unmarshal, with age = 0: {Age:0xc42000a750 <br/>      Name:Aaron}</strong><br/><strong>      nullInt64 Marshal, with age = 0: {"age":0,"name":"Aaron"}</strong>
</pre>
<ol start="11">
<li><span>If you c</span>opied or w<span>rote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Switching from a value to a pointer is a quick way to express null values when marshaling and unmarshaling. It can be a bit unclear on setting these values as you can't assign them directly to a pointer <kbd>-- *a := 1</kbd>, but otherwise it's a flexible way of dealing with it.</p>
<p>This recipe also demonstrated an alternative method using the <kbd>sql.NullInt64</kbd> type. This is normally used with SQL and valid is set if anything other than <kbd>Null</kbd> is returned, otherwise it sets <kbd>Null</kbd>. We added a <kbd>MarshalJSON</kbd> and <kbd>UnmarshallJSON</kbd> method to allow this type to interact with the <kbd>JSON</kbd> package and we chose to use a pointer so that <kbd>omitempty</kbd> would continue to work as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encoding and decoding Go data</h1>
                </header>
            
            <article>
                
<p>Go features a number of alternative encoding types aside from JSON, TOML, and YAML. These are largely meant for transporting data between Go processes with things such as wire protocols and RPC or in cases where some character formats are restricted.</p>
<p>This recipe will explore encoding and decoding gob format and base64. The later chapters will explore protocols such as GRPC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>Converting Data Types and Interface Casting</em></span> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to a the <kbd>chapter3/encoding</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter3/encoding">https://github.com/agtorre/go-cookbook/tree/master/chapter3/encoding</a> or use this as an exercise to write some of your own.</li>
<li>Create a file called <kbd>gob.go</kbd> with the following contents:</li>
</ol>
<pre>
        package encoding<br/><br/>        import (<br/>            "bytes"<br/>            "encoding/gob"<br/>            "fmt"<br/>        )<br/><br/>        // pos stores the x, y position<br/>        // for Object<br/>        type pos struct {<br/>            X      int<br/>            Y      int<br/>            Object string<br/>        }<br/><br/>        // GobExample demonstrates using<br/>        // the gob package<br/>        func GobExample() error {<br/>            buffer := bytes.Buffer{}<br/><br/>            p := pos{<br/>                X:      10,<br/>                Y:      15,<br/>                Object: "wrench",<br/>            }<br/><br/>            // note that if p was an interface<br/>            // we'd have to call gob.Register first<br/><br/>            e := gob.NewEncoder(&amp;buffer)<br/>            if err := e.Encode(&amp;p); err != nil {<br/>                return err<br/>            }<br/><br/>            // note this is a binary format so it wont print well<br/>            fmt.Println("Gob Encoded valued length: ", <br/>            len(buffer.Bytes()))<br/><br/>            p2 := pos{}<br/>            d := gob.NewDecoder(&amp;buffer)<br/>            if err := d.Decode(&amp;p2); err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("Gob Decode value: ", p2)<br/>        <br/>            return nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>base64.go</kbd> with the following contents:</li>
</ol>
<pre>
        package encoding<br/><br/>        import (<br/>            "bytes"<br/>            "encoding/base64"<br/>            "fmt"<br/>            "io/ioutil"<br/>        )<br/><br/>        // Base64Example demonstrates using<br/>        // the base64 package<br/>        func Base64Example() error {<br/>            // base64 is useful for cases where<br/>            // you can't support binary formats<br/>            // it operates on bytes/strings<br/><br/>            // using helper functions and URL encoding<br/>            value := base64.URLEncoding.EncodeToString([]byte("encoding <br/>            some data!"))<br/>            fmt.Println("With EncodeToString and URLEncoding: ", value)<br/><br/>            // decode the first value<br/>            decoded, err := base64.URLEncoding.DecodeString(value)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("With DecodeToString and URLEncoding: ", <br/>            string(decoded))<br/><br/>            return nil<br/>        }<br/><br/>        // Base64ExampleEncoder shows similar examples<br/>        // with encoders/decoders<br/>        func Base64ExampleEncoder() error {<br/>            // using encoder/ decoder<br/>            buffer := bytes.Buffer{}<br/><br/>            // encode into the buffer<br/>            encoder := base64.NewEncoder(base64.StdEncoding, &amp;buffer)<br/> <br/>            // be sure to close<br/>            if err := encoder.Close(); err != nil {<br/>                return err<br/>            }<br/>            if _, err := encoder.Write([]byte("encoding some other <br/>            data")); err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("Using encoder and StdEncoding: ", <br/>            buffer.String())<br/><br/>            decoder := base64.NewDecoder(base64.StdEncoding, &amp;buffer)<br/>            results, err := ioutil.ReadAll(decoder)<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Println("Using decoder and StdEncoding: ", <br/>            string(results))<br/><br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>encoding</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "github.com/agtorre/go-cookbook/chapter3/encoding"<br/>        )<br/><br/>        func main() {<br/>            if err := encoding.Base64Example(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            if err := encoding.Base64ExampleEncoder(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            if err := encoding.GobExample(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      With EncodeToString and URLEncoding: <br/>      ZW5jb2Rpbmcgc29tZSBkYXRhIQ==</strong><br/><strong>      With DecodeToString and URLEncoding: encoding some data!</strong><br/><strong>      Using encoder and StdEncoding: ZW5jb2Rpbmcgc29tZSBvdGhlciBkYXRh</strong><br/><strong>      Using decoder and StdEncoding: encoding some other data</strong><br/><strong>      Gob Encoded valued length: 57</strong><br/><strong>      Gob Decode value: {10 15 wrench}</strong>
</pre>
<ol start="10">
<li><span>If you</span> copied or wrote <span>your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Gob encoding is a streaming format built with Go data types in mind. It is most efficient when sending and encoding many consecutive items. For a single item, other encoding formats such as JSON are potentially more efficient and portable. Despite this, gob encoding makes it simple to marshal large complex structs and reconstruct them in a separate process. Although it wasn't shown here, gob can also operate on custom types or unexported types with custom <kbd>MarshalBinary</kbd> and <kbd>UnmarshalBinary</kbd> methods.</p>
<p>Base64 encoding is useful for communicating via URLs in <kbd>GET</kbd> requests or for generating a string representation encoding of binary data. Most languages can support this format and unmarshal the data on the other end. As a result, it's common to encode things such as JSON payloads in cases where the JSON format is not supported.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Struct tags and basic reflection in Go</h1>
                </header>
            
            <article>
                
<p>Reflection is a complicated topic that can't really be covered in a single recipe. However, a practical application of reflection is dealing with struct tags. At their core, struct tags are just key-value strings. You lookup the key, then deal with the value. As you can imagine, for something like JSON marshal and unmarshal, there's a lot of complexity for dealing with these values.</p>
<p>The <kbd>reflect</kbd> package is designed for interrogating and understanding interface objects. It has helper methods to look at kind of structs, values, struct tags, and more. If you need something beyond the basic interface conversion like at the beginning of this chapter, this is the package you should look at.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>Converting Data Types and Interface Casting</em></span> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter3/tags</kbd> directory .</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter3/tags">https://github.com/agtorre/go-cookbook/tree/master/chapter3/tags</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>serialize.go</kbd> with the following contents:</li>
</ol>
<pre>
        package tags<br/><br/>        import "reflect"<br/><br/>        // SerializeStructStrings converts a struct<br/>        // to our custom serialization format<br/>        // it honors serialize struct tags for string types<br/>        func SerializeStructStrings(s interface{}) (string, error) {<br/>            result := ""<br/><br/>            // reflect the interface into<br/>            // a type<br/>            r := reflect.TypeOf(s)<br/>            value := reflect.ValueOf(s)<br/>        <br/>            // if a pointer to a struct is passed<br/>            // in, handle it appropriately<br/>            if r.Kind() == reflect.Ptr {<br/>                r = r.Elem()<br/>                value = value.Elem()<br/>            }<br/><br/>            // loop over all of the fields<br/>            for i := 0; i &lt; r.NumField(); i++ {<br/>                field := r.Field(i)<br/>                // struct tag found<br/>                key := field.Name<br/>                if serialize, ok := field.Tag.Lookup("serialize"); ok {<br/>                    // ignore "-" otherwise that whole value<br/>                    // becomes the serialize 'key'<br/>                    if serialize == "-" {<br/>                        continue<br/>                    }<br/>                    key = serialize<br/>                }<br/><br/>                switch value.Field(i).Kind() {<br/>                // this recipe only supports strings!<br/>                case reflect.String:<br/>                    result += key + ":" + value.Field(i).String() + ";"<br/>                    // by default skip it<br/>                default:<br/>                    continue<br/>               }<br/>            }<br/>            return result, nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>deserialize.go</kbd> with the following contents:</li>
</ol>
<pre>
        package tags<br/><br/>        import (<br/>            "errors"<br/>            "reflect"<br/>            "strings"<br/>        )<br/><br/>        // DeSerializeStructStrings converts a serialized<br/>        // string using our custom serialization format<br/>        // to a struct<br/>        func DeSerializeStructStrings(s string, res interface{}) error          <br/>        {<br/>            r := reflect.TypeOf(res)<br/><br/>            // we're setting using a pointer so<br/>            // it must always be a pointer passed<br/>            // in<br/>            if r.Kind() != reflect.Ptr {<br/>                return errors.New("res must be a pointer")<br/>            }<br/><br/>            // dereference the pointer<br/>            r = r.Elem()<br/>            value := reflect.ValueOf(res).Elem()<br/><br/>            // split our serialization string into<br/>            // a map<br/>            vals := strings.Split(s, ";")<br/>            valMap := make(map[string]string)<br/>            for _, v := range vals {<br/>                keyval := strings.Split(v, ":")<br/>                if len(keyval) != 2 {<br/>                    continue<br/>                }<br/>                valMap[keyval[0]] = keyval[1]<br/>            }<br/><br/>            // iterate over fields<br/>            for i := 0; i &lt; r.NumField(); i++ {<br/>                field := r.Field(i)<br/><br/>               // check if in the serialize set<br/>               if serialize, ok := field.Tag.Lookup("serialize"); ok {<br/>                   // ignore "-" otherwise that whole value<br/>                   // becomes the serialize 'key'<br/>                   if serialize == "-" {<br/>                       continue<br/>                   }<br/>                   // is it in the map<br/>                   if val, ok := valMap[serialize]; ok {<br/>                       value.Field(i).SetString(val)<br/>                   }<br/>               } else if val, ok := valMap[field.Name]; ok {<br/>                   // is our field name in the map instead?<br/>                   value.Field(i).SetString(val)<br/>               }<br/>            }<br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>tags.go</kbd> with the following contents:</li>
</ol>
<pre>
        package tags<br/><br/>        import "fmt"<br/><br/>        // Person is a struct that stores a persons<br/>        // name, city, state, and a misc attribute<br/>        type Person struct {<br/>            Name string `serialize:"name"`<br/>            City string `serialize:"city"`<br/>            State string<br/>             Misc string `serialize:"-"`<br/>             Year int `serialize:"year"`<br/>        }<br/><br/>        // EmptyStruct demonstrates serialize<br/>        // and deserialize for an Empty struct<br/>        // with tags<br/>        func EmptyStruct() error {<br/>            p := Person{}<br/><br/>            res, err := SerializeStructStrings(&amp;p)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Printf("Empty struct: %#v\n", p)<br/>            fmt.Println("Serialize Results:", res)<br/><br/>            newP := Person{}<br/>            if err := DeSerializeStructStrings(res, &amp;newP); err != nil <br/>            {<br/>                return err<br/>            }<br/>            fmt.Printf("Deserialize results: %#v\n", newP)<br/>                return nil<br/>            }<br/><br/>           // FullStruct demonstrates serialize<br/>           // and deserialize for an Full struct<br/>           // with tags<br/>           func FullStruct() error {<br/>               p := Person{<br/>                   Name: "Aaron",<br/>                   City: "Seattle",<br/>                   State: "WA",<br/>                   Misc: "some fact",<br/>                   Year: 2017,<br/>               }<br/>               res, err := SerializeStructStrings(&amp;p)<br/>               if err != nil {<br/>                   return err<br/>               }<br/>               fmt.Printf("Full struct: %#v\n", p)<br/>               fmt.Println("Serialize Results:", res)<br/><br/>               newP := Person{}<br/>               if err := DeSerializeStructStrings(res, &amp;newP);<br/>               err != nil {<br/>                   return err<br/>               }<br/>               fmt.Printf("Deserialize results: %#v\n", newP)<br/>               return nil<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>tags</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter3/tags"<br/>        )<br/><br/>        func main() {<br/><br/>            if err := tags.EmptyStruct(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            fmt.Println()<br/><br/>            if err := tags.FullStruct(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Empty struct: tags.Person{Name:"", City:"", State:"", Misc:"", <br/>      Year:0}</strong><br/><strong>      Serialize Results: name:;city:;State:;</strong><br/><strong>      Deserialize results: tags.Person{Name:"", City:"", State:"", <br/>      Misc:"", Year:0}</strong><br/><br/><strong>      Full struct: tags.Person{Name:"Aaron", City:"Seattle", <br/>      State:"WA", Misc:"some fact", Year:2017}</strong><br/><strong>      Serialize Results: name:Aaron;city:Seattle;State:WA;</strong><br/><strong>      Deserialize results: tags.Person{Name:"Aaron", City:"Seattle",        State:"WA", Misc:"", Year:0}</strong>
</pre>
<ol start="11">
<li><span>If you c</span>opied or w<span>rote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe makes a string serialization format that takes a struct, and serializes all the string fields into a parseable format. This recipe doesn't deal with certain edge cases; in particular, strings must not contain <kbd>:</kbd> or <kbd>;</kbd> characters. Here is a summary of its behavior:</p>
<ol>
<li>If a field is a string, it will be serialized/deserialized.</li>
<li>If a field is not a string, it will be ignored.</li>
<li>If the struct tag of the field contains the serialize"key", then key will be the returned serialized/deserialized environment.</li>
<li>Duplicates are not handled.</li>
<li>If a struct tag is not specified, the field name is used instead.</li>
<li>If serialize <kbd>-</kbd> is specified, the field is ignored even if it's a string.</li>
</ol>
<p>Some other things to note are that reflection does not work entirely with non-exported values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing collections via closures</h1>
                </header>
            
            <article>
                
<p>If you've been working with functional or dynamic programming languages, you may feel that <kbd>for</kbd> loops and <kbd>if</kbd> statements produce verbose code. Functional constructs such as <kbd>map</kbd> and <kbd>filter</kbd> for processing lists can be useful and make code appear more readable. However, in Go, these types are not in the standard library and can be difficult to generalize without generics or very complex reflection and use of empty interfaces. This recipe will provide you with some basic examples of implementing collections using Go closures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>Converting Data Types and Interface Casting</em></span> recipe<em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter3/collections</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter3/collections">https://github.com/agtorre/go-cookbook/tree/master/chapter3/collections</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>collections.go</kbd> with the following contents:</li>
</ol>
<pre>
        package collections<br/><br/>        // WorkWith is the struct we'll<br/>        // be implementing collections for<br/>        type WorkWith struct {<br/>            Data    string<br/>            Version int<br/>        }<br/><br/>        // Filter is a functional filter. It takes a list of<br/>        // WorkWith and a WorkWith Function that returns a bool<br/>        // for each "true" element we return it to the resultant<br/>        // list<br/>        func Filter(ws []WorkWith, f func(w WorkWith) bool) []WorkWith <br/>        {<br/>            // depending on results, smalles size for result<br/>            // is len == 0<br/>            result := make([]WorkWith, 0)<br/>            for _, w := range ws {<br/>                if f(w) {<br/>                    result = append(result, w)<br/>                }<br/>            }<br/>            return result<br/>        }<br/><br/>        // Map is a functional map. It takes a list of<br/>        // WorkWith and a WorkWith Function that takes a WorkWith<br/>        // and returns a modified WorkWith. The end result is<br/>        // a list of modified WorkWiths<br/>        func Map(ws []WorkWith, f func(w WorkWith) WorkWith) []WorkWith <br/>        {<br/>            // the result should always be the same<br/>            // length<br/>            result := make([]WorkWith, len(ws))<br/><br/>            for pos, w := range ws {<br/>                newW := f(w)<br/>                result[pos] = newW<br/>            }<br/>            return result<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>functions.go</kbd> with the following contents:</li>
</ol>
<pre>
        package collections<br/><br/>        import "strings"<br/><br/>        // LowerCaseData does a ToLower to the<br/>        // Data string of a WorkWith<br/>        func LowerCaseData(w WorkWith) WorkWith {<br/>            w.Data = strings.ToLower(w.Data)<br/>            return w<br/>        }<br/><br/>        // IncrementVersion increments a WorkWiths<br/>        // Version<br/>        func IncrementVersion(w WorkWith) WorkWith {<br/>            w.Version++<br/>            return w<br/>        }<br/><br/>        // OldVersion returns a closures<br/>        // that validates the version is greater than<br/>        // the specified amount<br/>        func OldVersion(v int) func(w WorkWith) bool {<br/>            return func(w WorkWith) bool {<br/>                return w.Version &gt;= v<br/>            }<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd>.</li>
<li>Navigate to <kbd>example</kbd>.</li>
</ol>
<p>Â </p>
<ol start="7">
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>collections</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter3/collections"<br/>        )<br/><br/>        func main() {<br/>            ws := []collections.WorkWith{<br/>                collections.WorkWith{"Example", 1},<br/>                collections.WorkWith{"Example 2", 2},<br/>            }<br/><br/>            fmt.Printf("Initial list: %#v\n", ws)<br/><br/>            // first lower case the list<br/>            ws = collections.Map(ws, collections.LowerCaseData)<br/>            fmt.Printf("After LowerCaseData Map: %#v\n", ws)<br/><br/>            // next increment all versions<br/>            ws = collections.Map(ws, collections.IncrementVersion)<br/>            fmt.Printf("After IncrementVersion Map: %#v\n", ws)<br/><br/>            // lastly remove all versions older than 3<br/>            ws = collections.Filter(ws, collections.OldVersion(3))<br/>            fmt.Printf("After OldVersion Filter: %#v\n", ws)<br/>        }
</pre>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Initial list:         <br/>      []collections.WorkWith{collections.WorkWith{Data:"Example", <br/>      Version:1}, collections.WorkWith{Data:"Example 2", Version:2}}</strong><br/><strong>      After LowerCaseData Map:         <br/>      []collections.WorkWith{collections.WorkWith{Data:"example", <br/>      Version:1}, collections.WorkWith{Data:"example 2", Version:2}}</strong><br/><strong>      After IncrementVersion Map: <br/>      []collections.WorkWith{collections.WorkWith{Data:"example", <br/>      Version:2}, collections.WorkWith{Data:"example 2", Version:3}}</strong><br/><strong>      After OldVersion Filter: <br/>      []collections.WorkWith{collections.WorkWith{Data:"example 2",        Version:3}}</strong>
</pre>
<ol start="10">
<li><span>If y</span>ou copied or <span>wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Closures in Go are very powerful. Although our collections functions are not generic, they're relatively small and easily applied with a variety of functions to our <kbd>WorkWith</kbd> struct. You may notice from looking at this that we're not returning errors anywhere. The idea of these functions are that they're pure. There are no side effects to the original list, except that we choose to write over it after each call.</p>
<p>If you need to apply layers of modification to a list or struct of lists, this pattern can save you a lot of confusion and makes testing very straightforward. It is also possible to chain maps and filters together for a very expressive coding style.</p>


            </article>

            
        </section>
    </body></html>