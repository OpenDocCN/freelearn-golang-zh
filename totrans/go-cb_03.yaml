- en: Data Conversion and Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting data types and interface casting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numeric data types using math and math/big
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currency conversions and float64 considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pointers and SQL NullTypes for encoding and decoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding and decoding Go data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct tags and basic reflection in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing collections via closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reasoning about Go's typing system is a critical step to all levels of Go development.
    This chapter will show examples of converting between data types, working with
    very big numbers, working with currency, types of encoding and decoding, including
    base64 and gob, and creating custom collections using closures.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data types and interface casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go is typically very flexible in conversion between data. A type may inherit
    another type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can always cast back to the type we inherited as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are also convenience functions for converting between numbers with casting,
    between strings and other types using `fmt.Sprint` and with `strconv`, and between
    interfaces and types using reflection. This recipe will explore some of these
    basic conversions that will be used throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal/console application, and navigate to your `GOPATH/src` and create
    a project directory such as `$GOPATH/src/github.com/yourusername/customrepo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the code will be run and modified from this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter3/dataconv`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter3/dataconv](https://github.com/agtorre/go-cookbook/tree/master/chapter3/dataconv)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dataconv.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `strconv.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `interfaces.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file `main.go` with the following contents. Be sure to modify the
    `dataconv` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates casting between types by wrapping them in a new type,
    using the `strconv` package, and by using interface reflection. These methods
    allow Go developer to quickly convert between various abstract Go types. will
    both reveal errors during compilation, but reflection can be more tricky. If you
    reflect incorrectly to an unsupported type, you'll cause a panic. Switching on
    type is a way to generalize and is also demonstrated in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion becomes important for packages such as `math`, which operate on float64
    exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: Working with numeric data types using math and math/big
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `math` and `math/big` packages focus on exposing more complex mathematical
    operations to the Go language, such as `Pow`, `Sqrt`, and `Cos`. The `math` package
    itself operates predominately on float64 unless a function says otherwise. The
    `math/big` package is for numbers that are too large to represent in a 64-bit
    value. This recipe will show some basic usage of the `math` package and demonstrate
    `math/big` for fibonacci.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the steps given in the *Getting ready* section of the *Converting data
    types and interface casting* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter3/math`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter3/math](https://github.com/agtorre/go-cookbook/tree/master/chapter3/math)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `math.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `fib.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file `main.go` with the following contents; be sure to modify the
    `math` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `math` package makes it possible to do complex mathematical operations in
    Go. This recipe should be used in conjunction with this package for doing complex
    floating point operations and converting between types as needed. It's worth noting
    that even with float64, there may still be rounding errors for certain floating
    point numbers, and the following recipe demonstrates some techniques for dealing
    with this.
  prefs: []
  type: TYPE_NORMAL
- en: The `math/big` section showcases a recursive Fibonacci sequence. If you modify
    `main.go` to loop well beyond 10, you'll quickly overflow int64 if it was used
    instead of `big.Int`. This package also has helper methods to convert between
    the big types to other types.
  prefs: []
  type: TYPE_NORMAL
- en: Currency conversions and float64 considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with currency is always a tricky process. It can be tempting to represent
    money as a float64, but this can result in some pretty tricky (and wrong) rounding
    errors when doing calculations. For this reason, it's preferable to think of money
    in terms of cents and store it as an Int64.
  prefs: []
  type: TYPE_NORMAL
- en: When collecting user input from forms, the command line, or other sources, money
    is usually represented in dollar form. For this reason, it's best to treat it
    as a string and convert that string directly to pennies without floating point
    conversions. This recipe will present ways to convert a string representation
    of currency into an int64 (pennies) and back again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the steps given in the *Getting ready* section of the *Converting data
    types and interface casting* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter3/currency`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter3/currency](https://github.com/agtorre/go-cookbook/tree/master/chapter3/currency)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dollars.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `pennies.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `main.go` with the following contents; be sure to modify
    the `currency` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe makes use of the `strconv` and `strings` packages to convert currency
    between dollars in string format and pennies in int64\. It does this without even
    converting to a float64 other than as validation.
  prefs: []
  type: TYPE_NORMAL
- en: The `strconv.ParseInt` and `strconv.FormatInt` functions are very useful for
    converting to and from int64 and strings. We also made use of the fact that Go
    strings can easily be appended and sliced as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers and SQL NullTypes for encoding and decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you encode or decode into an object in Go, types that are not explicitly
    set will be set to their default values. Strings will default to empty string
    "", and integers will default to `0` as an example. Normally, this is fine, unless
    `0` means something for your API or service that is consuming the user input or
    returning it.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if you use struct tags such as `json omitempty`, 0 values will
    be ignored even if they're valid. Another example of this is `Null` that returns
    from SQL. What value best represents `Null` for an `Int`? This recipe will explore
    some of the ways Go developers deal with this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the steps given in the *Getting ready* section of the *Converting data
    types and interface casting* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter3/nulls`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter3/nulls](https://github.com/agtorre/go-cookbook/tree/master/chapter3/nulls)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `base.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `pointer.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `nullencoding.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `main.go` with the following contents; be sure to modify
    the `nulls` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switching from a value to a pointer is a quick way to express null values when
    marshaling and unmarshaling. It can be a bit unclear on setting these values as
    you can't assign them directly to a pointer `-- *a := 1`, but otherwise it's a
    flexible way of dealing with it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also demonstrated an alternative method using the `sql.NullInt64`
    type. This is normally used with SQL and valid is set if anything other than `Null`
    is returned, otherwise it sets `Null`. We added a `MarshalJSON` and `UnmarshallJSON`
    method to allow this type to interact with the `JSON` package and we chose to
    use a pointer so that `omitempty` would continue to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and decoding Go data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go features a number of alternative encoding types aside from JSON, TOML, and
    YAML. These are largely meant for transporting data between Go processes with
    things such as wire protocols and RPC or in cases where some character formats
    are restricted.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explore encoding and decoding gob format and base64\. The later
    chapters will explore protocols such as GRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the steps given in the *Getting ready* section of the *Converting Data
    Types and Interface Casting* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to a the `chapter3/encoding`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter3/encoding](https://github.com/agtorre/go-cookbook/tree/master/chapter3/encoding)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `gob.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `base64.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `main.go` with the following contents; be sure to modify
    the `encoding` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gob encoding is a streaming format built with Go data types in mind. It is most
    efficient when sending and encoding many consecutive items. For a single item,
    other encoding formats such as JSON are potentially more efficient and portable.
    Despite this, gob encoding makes it simple to marshal large complex structs and
    reconstruct them in a separate process. Although it wasn't shown here, gob can
    also operate on custom types or unexported types with custom `MarshalBinary` and
    `UnmarshalBinary` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Base64 encoding is useful for communicating via URLs in `GET` requests or for
    generating a string representation encoding of binary data. Most languages can
    support this format and unmarshal the data on the other end. As a result, it's
    common to encode things such as JSON payloads in cases where the JSON format is
    not supported.
  prefs: []
  type: TYPE_NORMAL
- en: Struct tags and basic reflection in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection is a complicated topic that can't really be covered in a single recipe.
    However, a practical application of reflection is dealing with struct tags. At
    their core, struct tags are just key-value strings. You lookup the key, then deal
    with the value. As you can imagine, for something like JSON marshal and unmarshal,
    there's a lot of complexity for dealing with these values.
  prefs: []
  type: TYPE_NORMAL
- en: The `reflect` package is designed for interrogating and understanding interface
    objects. It has helper methods to look at kind of structs, values, struct tags,
    and more. If you need something beyond the basic interface conversion like at
    the beginning of this chapter, this is the package you should look at.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the steps given in the *Getting ready* section of the *Converting Data
    Types and Interface Casting* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter3/tags`
    directory .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter3/tags](https://github.com/agtorre/go-cookbook/tree/master/chapter3/tags)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `serialize.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `deserialize.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `tags.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `main.go` with the following contents; be sure to modify
    the `tags` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe makes a string serialization format that takes a struct, and serializes
    all the string fields into a parseable format. This recipe doesn''t deal with
    certain edge cases; in particular, strings must not contain `:` or `;` characters.
    Here is a summary of its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: If a field is a string, it will be serialized/deserialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a field is not a string, it will be ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the struct tag of the field contains the serialize"key", then key will be
    the returned serialized/deserialized environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicates are not handled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a struct tag is not specified, the field name is used instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If serialize `-` is specified, the field is ignored even if it's a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some other things to note are that reflection does not work entirely with non-exported
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing collections via closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been working with functional or dynamic programming languages, you
    may feel that `for` loops and `if` statements produce verbose code. Functional
    constructs such as `map` and `filter` for processing lists can be useful and make
    code appear more readable. However, in Go, these types are not in the standard
    library and can be difficult to generalize without generics or very complex reflection
    and use of empty interfaces. This recipe will provide you with some basic examples
    of implementing collections using Go closures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the steps given in the *Getting ready* section of the *Converting Data
    Types and Interface Casting* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter3/collections`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter3/collections](https://github.com/agtorre/go-cookbook/tree/master/chapter3/collections)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `collections.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `functions.go` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `main.go` with the following contents; be sure to modify
    the `collections` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures in Go are very powerful. Although our collections functions are not
    generic, they're relatively small and easily applied with a variety of functions
    to our `WorkWith` struct. You may notice from looking at this that we're not returning
    errors anywhere. The idea of these functions are that they're pure. There are
    no side effects to the original list, except that we choose to write over it after
    each call.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to apply layers of modification to a list or struct of lists, this
    pattern can save you a lot of confusion and makes testing very straightforward.
    It is also possible to chain maps and filters together for a very expressive coding
    style.
  prefs: []
  type: TYPE_NORMAL
