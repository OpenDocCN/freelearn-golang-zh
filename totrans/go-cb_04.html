<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Error Handling in Go</h1>
                </header>
            
            <article>
                
<p>In this chapter, the following recipes will be covered:</p>
<ul>
<li>Handling errors and the Error interface</li>
<li>Using the pkg/errors package and wrapping errors</li>
<li>Using the log package and <span>understanding when to log errors</span></li>
<li>Structured logging with the apex and logrus packages</li>
<li>Logging with the context package</li>
<li>Using package-level global variables</li>
<li>Catching panics for long running processes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Error handling is important for even the most basic Go program. Errors in Go implement the <kbd>Error</kbd> interface and must be dealt with at every layer of the code. <span>Go errors</span> do not work like exceptions, and unhandled errors can cause enormous problems. You should strive to handle and consider errors whenever they occur.</p>
<p>This chapter also covers logging since it's common to log whenever an actual error occurs. We'll also investigate wrapping errors so that a given error has the appropriate amount of context for the calling function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling errors and the Error interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>Error</kbd> interface is a pretty small and simple interface:</p>
<pre>
type Error interface{<br/>  Error() string<br/>}
</pre>
<p>This interface is elegant because it's simple to make anything to satisfy it. Unfortunately, this also creates confusion for packages that need to take certain actions depending on the error received.</p>
<p>There are a number of ways to create errors in Go, this recipe will explore the creation of basic errors, errors that have assigned values or types, and of a custom error using a struct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>, and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application.</li>
<li>Navigate to your <kbd>GOPATH/src</kbd> and create a project directory, for example, <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="4">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter4/basicerrors</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter4/basicerrors">https://github.com/agtorre/go-cookbook/tree/master/chapter4/basicerrors</a> or use this as an exercise to write some of your own code.</li>
</ol>
<p> </p>
<ol start="3">
<li>Create a file called <kbd>basicerrors.go</kbd> with the following content:</li>
</ol>
<pre>
        package basicerrors<br/><br/>        import (<br/>            "errors"<br/>            "fmt"<br/>        )<br/><br/>        // ErrorTyped is a way to make a package level<br/>        // error to check against. I.e. if err == TypedError<br/>        var ErrorTyped = errors.New("this is a typed error")<br/><br/>        //BasicErrors demonstrates some ways to create errors<br/>        func BasicErrors() {<br/>            err := errors.New("this is a quick and easy way to create <br/>            an error")<br/>            fmt.Println("errors.New: ", err)<br/><br/>            err = fmt.Errorf("an error occurred: %s", "something")<br/>            fmt.Println("fmt.Errorf: ", err)<br/><br/>            err = ErrorTyped<br/>            fmt.Println("typed error: ", err)<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>custom.go</kbd> with the following content:</li>
</ol>
<pre>
        package basicerrors<br/><br/>        import (<br/>            "errors"<br/>            "fmt"<br/>        )<br/><br/>        // ErrorValue is a way to make a package level<br/>        // error to check against. I.e. if err == ErrorValue<br/>        var ErrorValue = errors.New("this is a typed error")<br/><br/>        // TypedError is a way to make an error type<br/>        // you can do err.(type) == ErrorValue<br/>        type TypedError struct{ <br/>            error<br/>        }<br/><br/>        //BasicErrors demonstrates some ways to create errors<br/>        func BasicErrors() {<br/>            err := errors.New("this is a quick and easy way to create <br/>            an error")<br/>            fmt.Println("errors.New: ", err)<br/><br/>            err = fmt.Errorf("an error occurred: %s", "something")<br/>            fmt.Println("fmt.Errorf: ", err)<br/><br/>            err = ErrorValue<br/>            fmt.Println("value error: ", err)<br/>  <br/>            err = TypedError{errors.New("typed error")}<br/>            fmt.Println("typed error: ", err)<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>basicerrors</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter4/basicerrors"<br/>        )<br/><br/>        func main() {<br/>            basicerrors.BasicErrors()<br/><br/>            err := basicerrors.SomeFunc()<br/>            fmt.Println("custom error: ", err)<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should now see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      errors.New: this is a quick and easy way to create an error</strong><br/><strong>      fmt.Errorf: an error occurred: something</strong><br/><strong>      typed error: this is a typed error</strong><br/><strong>      custom error: there was an error; this was the result</strong>
</pre>
<ol start="9">
<li><span>If you co</span>pied or w<span>rote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Whether you use <kbd>errors.New</kbd>, <kbd>fmt.Errorf</kbd>, or a custom error, the most important thing is that you should never leave errors unhandled in your code. These different methods of defining errors give a lot of flexibility. You can, for example, put extra functions in your struct to further interrogate an error and cast the interface to your error type in the calling function to get some added functionality.</p>
<p>The interface itself is very simple and the only requirement is that you return a valid string. Connecting this to a struct may be useful for some high-level applications that have consistent error handling throughout but want to work nicely with other applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the pkg/errors package and wrapping errors</h1>
                </header>
            
            <article>
                
<p>The <kbd>errors</kbd> package located at <kbd>github.com/pkg/errors</kbd> is a drop in replacement for the standard Go <kbd>errors</kbd> package. In addition, it provides some very useful functionality for wrapping and handling errors. The typed and declared errors in the preceding recipe are a good example--they can be useful to add additional information to an error, but wrapping it in the standard way will change its type and break type assertion:</p>
<pre>
// this wont work if you wrapped it <br/>// in a standard way. i.e.<br/>// fmt.Errorf("custom error: %s", err.Error())<br/>if err == Package.ErrorNamed{<br/>  //handle this error in a specific way<br/>}
</pre>
<p>This recipe will demonstrate how to use the <kbd>pkg/errors</kbd> package to add annotation to errors throughout your code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Refer to the <em>Getting ready</em> section of the <span><em>Handling errors and the Error interface</em></span> recipe in this chapter.</li>
<li>Run the <kbd>go get github.com/pkg/errors/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter4/errwrap</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter4/errwrap">https://github.com/agtorre/go-cookbook/tree/master/chapter4/errwrap</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>errwrap.go</kbd> with the following content:</li>
</ol>
<pre>
        package errwrap<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/pkg/errors"<br/>        )<br/>        <br/>        // WrappedError demonstrates error wrapping and<br/>        // annotating an error<br/>        func WrappedError(e error) error {<br/>            return errors.Wrap(e, "An error occurred in WrappedError")<br/>        }<br/><br/>        // ErrorTyped is a error we can check against<br/>        type ErrorTyped struct{<br/>            error<br/>        }<br/><br/>        // Wrap shows what happens when we wrap an error<br/>        func Wrap() {<br/>            e := errors.New("standard error")<br/><br/>            fmt.Println("Regular Error - ", WrappedError(e))<br/><br/>            fmt.Println("Typed Error - ", <br/>            WrappedError(ErrorTyped{errors.New("typed error")}))<br/><br/>            fmt.Println("Nil -", WrappedError(nil))<br/><br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>unwrap.go</kbd> with the following content:</li>
</ol>
<pre>
        package errwrap<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/pkg/errors"<br/>        )<br/><br/>        // Unwrap will unwrap an error and do<br/>        // type assertion to it<br/>        func Unwrap() {<br/><br/>            err := error(ErrorTyped{errors.New("an error occurred")})<br/>            err = errors.Wrap(err, "wrapped")<br/>        <br/>            fmt.Println("wrapped error: ", err)<br/><br/>            // we can handle many error types<br/>            switch errors.Cause(err).(type) {<br/>            case ErrorTyped:<br/>                fmt.Println("a typed error occurred: ", err)<br/>            default:<br/>                fmt.Println("an unknown error occurred")<br/>            }<br/>        }<br/><br/>        // StackTrace will print all the stack for<br/>        // the error<br/>        func StackTrace() {<br/>            err := error(ErrorTyped{errors.New("an error occurred")})<br/>            err = errors.Wrap(err, "wrapped")<br/><br/>            fmt.Printf("%+v\n", err)<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>errwrap</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter4/errwrap"<br/>        )<br/><br/>        func main() {<br/>            errwrap.Wrap()<br/>            fmt.Println()<br/>            errwrap.Unwrap()<br/>            fmt.Println()<br/>            errwrap.StackTrace()<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should now see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Regular Error - An error occurred in WrappedError: standard <br/>      error</strong><br/><strong>      Typed Error - An error occurred in WrappedError: typed error</strong><br/><strong>      Nil - &lt;nil&gt;</strong><br/><br/><strong>      wrapped error: wrapped: an error occurred</strong><br/><strong>      a typed error occurred: wrapped: an error occurred</strong><br/><br/><strong>      an error occurred</strong><br/><strong>      github.com/agtorre/go-cookbook/chapter4/errwrap.StackTrace</strong><br/><strong>      /Users/lothamer/go/src/github.com/agtorre/go-<br/>      cookbook/chapter4/errwrap/unwrap.go:30</strong><br/><strong>      main.main</strong><br/><strong>      /tmp/go/src/github.com/agtorre/go-<br/>      cookbook/chapter4/errwrap/example/main.go:14</strong>
</pre>
<ol start="9">
<li><span>If y</span>ou copied or wrote your own test<span>s, go up one directory and ru</span>n <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>pkg/errors</kbd> package is a very useful tool. It makes sense to wrap basically every returned error using this package to provide extra context in logging and error debugging. It's flexible enough to print the entire stack traces when an error occurs or to just add a prefix to your errors when printing them. It can also clean up code since a wrapped nil returns a <kbd>nil</kbd> value. For example:</p>
<pre>
func RetError() error{<br/> err := ThisReturnsAnError()<br/> return errors.Wrap(err, "This only does something if err != nil")<br/>}
</pre>
<p>In some cases, this can save you from having to check if an error is <kbd>nil</kbd> first before simply returning it. This recipe demonstrated how to use the package to wrap and unwrap errors, as well as basic stack trace functionality. The documentation for the package also provides some other useful examples such as printing partial stacks. Dave Cheney, the author of this library, has also written a number of helpful blogs and given talks on the subject, go to <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a> to know more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the log package and understanding when to log errors</h1>
                </header>
            
            <article>
                
<p>Logging should typically occur when an error is the final result. In other words, it's useful to log when something exceptional or unexpected occurs. It might also be appropriate, if you use a log that provides log levels, to sprinkle debug or info statements at key parts of your code to quickly debug issues during development. Too much logging will make it difficult to find anything useful, but not enough logging can result in broken systems with no insight into the root cause. This recipe will <span>demonstrate the use of the default Go <kbd>log</kbd> package and some useful options and showcase when a log should probably occur</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Refer to the <em>Getting ready</em> section of the <em>Handling errors and the Error interface</em> recipe in this chapter.</li>
<li>Run the <kbd>go get github.com/pkg/errors/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter4/log</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter4/log">https://github.com/agtorre/go-cookbook/tree/master/chapter4/log</a> or use this as an exercise to write some of your own code.</li>
</ol>
<p> </p>
<ol start="3">
<li>Create a file called <kbd>log.go</kbd> with the following content:</li>
</ol>
<pre>
        package log<br/><br/>        import (<br/>            "bytes"<br/>            "fmt"<br/>            "log"<br/>        )<br/><br/>        // Log uses the setup logger<br/>        func Log() {<br/>            // we'll configure the logger to write<br/>            // to a bytes.Buffer<br/>            buf := bytes.Buffer{}<br/><br/>            // second argument is the prefix last argument is about <br/>            // options you combine them with a logical or.<br/>            logger := log.New(&amp;buf, "logger: ",<br/>            log.Lshortfile|log.Ldate)<br/><br/>            logger.Println("test")<br/><br/>            logger.SetPrefix("new logger: ")<br/><br/>            logger.Printf("you can also add args(%v) and use Fataln to <br/>            log and crash", true)<br/><br/>            fmt.Println(buf.String())<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>error.go</kbd> with the following content:</li>
</ol>
<pre>
        package log<br/><br/>        import "github.com/pkg/errors"<br/>        import "log"<br/><br/>        // OriginalError returns the error original error<br/>        func OriginalError() error {<br/>            return errors.New("error occurred")<br/>        }<br/><br/>        // PassThroughError calls OriginalError and<br/>        // forwards the error along after wrapping.<br/>        func PassThroughError() error {<br/>            err := OriginalError()<br/>            // no need to check error<br/>            // since this works with nil<br/>            return errors.Wrap(err, "in passthrougherror")<br/>        }<br/><br/>        // FinalDestination deals with the error<br/>        // and doesn't forward it<br/>        func FinalDestination() {<br/>            err := PassThroughError()<br/>            if err != nil {<br/>                // we log because an unexpected error occurred!<br/>               log.Printf("an error occurred: %s\n", err.Error())<br/>               return<br/>            }<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>log</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter4/log"<br/>        )<br/><br/>        func main() {<br/>            fmt.Println("basic logging and modification of logger:")<br/>            log.Log()<br/>            fmt.Println("logging 'handled' errors:")<br/>            log.FinalDestination()<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You shou</span>ld see the following output:</p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      basic logging and modification of logger:</strong><br/><strong>      logger: 2017/02/05 log.go:19: test</strong><br/><strong>      new logger: 2017/02/05 log.go:23: you can also add args(true) <br/>      and use Fataln to log and crash</strong><br/><br/><strong>      logging 'handled' errors:</strong><br/><strong>      2017/02/05 18:36:11 an error occurred: in passthrougherror: <br/>      error occurred</strong>
</pre>
<ol start="9">
<li><span>If you</span> copied <span>or wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You can either initialize a logger and pass it around using <kbd>log.NewLogger()</kbd>, or use the <kbd>log</kbd> package level logger to log messages. The log file in this recipe does the former and error does the latter. It also shows when logging might make sense after an error has reached its final destination, otherwise it's likely that you'll log multiple times for one event.</p>
<p>There are a few issues with this approach. For one, you may have additional context in one of the intermediate functions, such as variables you'd like to log. Next, logging a bunch of variables can get messy and is confusing and difficult to read. The next recipe explores structured logging that provides flexibility in logging variables, and a later recipe will explore implementing a global package-level logger as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structured logging with the apex and logrus packages</h1>
                </header>
            
            <article>
                
<p>The primary reason to log information is to examine the state of the system when events occur or occurred in the past. <span>B</span>asic log messages are tricky to comb over when you have a large number of microservices that are logging.</p>
<p>There's a variety of third-party packages for combing over logs if you can get the logs into a data format they understand. These packages provide indexing functionality, searchability, and more. The <kbd>sirupsen/logrus</kbd> and <kbd>apex/log</kbd> packages provide a way to do structured logging where you can log a number of fields that can be reformatted to fit these third-party log readers. For example, it's simple to emit logs in the JSON format to be parsed by a variety of services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Refer to the <em>Getting ready</em> section of the <em>Handling errors and the Error interface</em> recipe.</li>
<li>Run the <kbd>go get github.com/sirupsen/logrus</kbd> command.</li>
<li>Run the <kbd>go get github.com/apex/log</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter4/structured</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter4/structured">https://github.com/agtorre/go-cookbook/tree/master/chapter4/structured</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>logrus.go</kbd> with the following content:</li>
</ol>
<pre>
        package structured<br/><br/>        import "github.com/sirupsen/logrus"<br/><br/>        // Hook will implement the logrus<br/>        // hook interface<br/>        type Hook struct {<br/>            id string<br/>        }<br/><br/>        // Fire will trigger whenever you log<br/>        func (hook *Hook) Fire(entry *logrus.Entry) error {<br/>            entry.Data["id"] = hook.id<br/>            return nil<br/>        }<br/><br/>        // Levels is what levels this hook will fire on<br/>        func (hook *Hook) Levels() []logrus.Level {<br/>            return logrus.AllLevels<br/>        }<br/><br/>        // Logrus demonstrates some basic logrus functionality<br/>        func Logrus() {<br/>            // we're emitting in json format<br/>            logrus.SetFormatter(&amp;logrus.TextFormatter{})<br/>            logrus.SetLevel(logrus.InfoLevel)<br/>            logrus.AddHook(&amp;Hook{"123"})<br/><br/>            fields := logrus.Fields{}<br/>            fields["success"] = true<br/>            fields["complex_struct"] = struct {<br/>                Event string<br/>                When string<br/>            }{"Something happened", "Just now"}<br/><br/>            x := logrus.WithFields(fields)<br/>            x.Warn("warning!")<br/>            x.Error("error!")<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>apex.go</kbd> with the following content:</li>
</ol>
<pre>
        package structured<br/><br/>        import (<br/>            "errors"<br/>            "os"<br/><br/>            "github.com/apex/log"<br/>            "github.com/apex/log/handlers/text"<br/>        )<br/><br/>        // ThrowError throws an error that we'll trace<br/>        func ThrowError() error {<br/>            err := errors.New("a crazy failure")<br/>            log.WithField("id", "123").Trace("ThrowError").Stop(&amp;err)<br/>            return err<br/>        }<br/><br/>        // CustomHandler splits to two streams<br/>        type CustomHandler struct {<br/>            id string<br/>            handler log.Handler<br/>        }<br/><br/>        // HandleLog adds a hook and does the emitting<br/>        func (h *CustomHandler) HandleLog(e *log.Entry) error {<br/>            e.WithField("id", h.id)<br/>            return h.handler.HandleLog(e)<br/>        }<br/><br/>        // Apex has a number of useful tricks<br/>        func Apex() {<br/>            log.SetHandler(&amp;CustomHandler{"123", text.New(os.Stdout)})<br/>            err := ThrowError()<br/><br/>            //With error convenience function<br/>            log.WithError(err).Error("an error occurred")<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>structured</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter4/structured"<br/>        )<br/><br/>        func main() {<br/>            fmt.Println("Logrus:")<br/>            structured.Logrus()<br/><br/>            fmt.Println()<br/>            fmt.Println("Apex:")<br/>            structured.Apex()<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You s</span>hould now see the following output:</p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Logrus:</strong><br/><strong>      WARN[0000] warning! complex_struct={Something happened Just now} <br/>      id=123 success=true</strong><br/><strong>      ERRO[0000] error! complex_struct={Something happened Just now} <br/>      id=123 success=true</strong><br/><br/><strong>      Apex:</strong><br/><strong>      INFO[0000] ThrowError id=123</strong><br/><strong>      ERROR[0000] ThrowError duration=133ns error=a crazy failure </strong><br/><strong>      id=123</strong><br/>      <strong>ERROR[0000] an error occurred error=a crazy failure</strong>
</pre>
<ol start="9">
<li><span>If yo</span>u copi<span>ed or wrote your own tests, go up one directory and ru</span>n <kbd>go test</kbd>. Ensure all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>sirupsen/logrus</kbd> and <kbd>apex/log</kbd> packages are both excellent structured loggers. Both provide hooks for either emitting to multiple events or to add extra fields to a log entry. It would be relatively simple, for example, to use the <kbd>logrus</kbd> hook or the <kbd>apex</kbd> custom handler to add line numbers to all of your logs as well as service names. Another use for a hook might include <kbd>traceID</kbd> to trace a request across different services.</p>
<p>While <kbd>logrus</kbd> splits the hook and the formatter, <kbd>apex</kbd> combines them. In addition, <kbd>apex</kbd> adds some convenience functions such as <kbd>WithError</kbd> to add an <kbd>error</kbd> field as well as tracing, both of which are demonstrated in the recipe. It's also relatively simple to adapt hooks from <kbd>logrus</kbd> into the <kbd>apex</kbd> handlers. For both solutions, it would be a simple change to convert to JSON formatting instead of ANSI colored text.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging with the context package</h1>
                </header>
            
            <article>
                
<p>This recipe will demonstrate a way to pass log fields between various functions. The Go <kbd>pkg/context</kbd> package is an excellent way to pass additional variables and cancelation between functions. This recipe will explore using this functionality to distribute variables between functions for logging purposes.</p>
<p>This style can be adapted to <kbd>logrus</kbd> or <kbd>apex</kbd> from the previous recipe. We'll use <kbd>apex</kbd> for this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li><span>Refer to the</span> <em>Getting ready</em> <span>section of the</span> <em>Handling errors and the Error interface</em> <span>recipe.</span></li>
<li>Run the <kbd>go get github.com/apex/log</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application create and navigate to the <kbd>chapter4/context</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter4/context">https://github.com/agtorre/go-cookbook/tree/master/chapter4/context</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>log.go</kbd> with the following content:</li>
</ol>
<pre>
        package context<br/><br/>        import (<br/>            "context"<br/><br/>            "github.com/apex/log"<br/>        )<br/><br/>        type key int<br/><br/>        // logFields is a key we use<br/>        // for our context logging<br/>        const logFields key = 0<br/>        <br/>        func getFields(ctx context.Context) *log.Fields {<br/>            fields, ok := ctx.Value(logFields).(*log.Fields)<br/>            if !ok {<br/>                f := make(log.Fields)<br/>                fields = &amp;f<br/>            }<br/>            return fields<br/>        }<br/><br/>        // FromContext takes an entry and a context<br/>        // then returns an entry populated from the context object<br/>        func FromContext(ctx context.Context, l log.Interface) <br/>        (context.Context, *log.Entry) {<br/>            fields := getFields(ctx)<br/>            e := l.WithFields(fields)<br/>            ctx = context.WithValue(ctx, logFields, fields)<br/>            return ctx, e<br/>        }<br/><br/>        // WithField adds a log field to the context<br/>        func WithField(ctx context.Context, key string, value <br/>           interface{}) context.Context {<br/>               return WithFields(ctx, log.Fields{key: value})<br/>        }<br/><br/>        // WithFields adds many log fields to the context<br/>        func WithFields(ctx context.Context, fields log.Fielder) <br/>        context.Context {<br/>            f := getFields(ctx)<br/>            for key, val := range fields.Fields() {<br/>                (*f)[key] = val<br/>            }<br/>            ctx = context.WithValue(ctx, logFields, f)<br/>            return ctx<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>collect.go</kbd> with the following content:</li>
</ol>
<pre>
        package context<br/><br/>        import (<br/>            "context"<br/>            "os"<br/><br/>            "github.com/apex/log"<br/>            "github.com/apex/log/handlers/text"<br/>        )<br/><br/>        // Initialize calls 3 functions to set up, then<br/>        // logs before terminating<br/>        func Initialize() {<br/>            // set basic log up<br/>            log.SetHandler(text.New(os.Stdout))<br/>            // initialize our context<br/>            ctx := context.Background()<br/>            // create a logger and link it to<br/>            // the context<br/>            ctx, e := FromContext(ctx, log.Log)<br/><br/>            // set a field<br/>            ctx = WithField(ctx, "id", "123")<br/>            e.Info("starting")<br/>            gatherName(ctx)<br/>            e.Info("after gatherName")<br/>            gatherLocation(ctx)<br/>            e.Info("after gatherLocation")<br/>           }<br/><br/>           func gatherName(ctx context.Context) {<br/>               ctx = WithField(ctx, "name", "Go Cookbook")<br/>           }<br/><br/>           func gatherLocation(ctx context.Context) {<br/>               ctx = WithFields(ctx, log.Fields{"city": "Seattle", <br/>               "state": "WA"})<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>context</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter4/context"<br/><br/>        func main() {<br/>            context.Initialize()<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>       INFO[0000] starting id=123</strong><br/><strong>       INFO[0000] after gatherName id=123 name=Go Cookbook</strong><br/><strong>       INFO[0000] after gatherLocation city=Seattle id=123 name=Go <br/>       Cookbook state=WA</strong>
</pre>
<ol start="9">
<li><span>If y</span>ou copied or wrote your o<span>wn tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>context</kbd> package now appears in a variety of packages, including the databases and HTTP packages. This recipe will allow you to attach log fields to a context and use them for logging purposes. The idea is that separate methods can attach more fields onto a context as it is passed around, then the final call-site can perform logging and aggregate variables.</p>
<p>This recipe mimics the <kbd>WithField</kbd> and <kbd>WithFields</kbd> methods found in the logging packages in the previous recipe. These modify a single value stored in the context and also provide the other benefits of using a context: cancellation, timeouts, and thread safety.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using package-level global variables</h1>
                </header>
            
            <article>
                
<p>The <kbd>apex</kbd> and <kbd>logrus</kbd> packages in the earlier examples both used a package-level global variable. Sometimes, it's useful to structure your libraries to support both structs with a variety of methods and top-level functions so that you can use them directly without passing them around.</p>
<p>This recipe also demonstrates using <kbd>sync.Once</kbd> to ensure that the global logger will only be initialized once. It can also be bypassed by the <kbd>Set</kbd> method. The recipe only exports <kbd>WithField</kbd> and <kbd>Debug</kbd>, but one can imagine exporting every method attached to a <kbd>log</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li><span>Refer to the</span> <em>Getting ready</em> <span>section of the</span> <em>Handling errors and the Error interface</em> <span>recipe.</span></li>
<li>Run the <kbd>go get github.com/sirupsen/logrus</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the<br/>
<kbd>chapter4/global</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter4/global">https://github.com/agtorre/go-cookbook/tree/master/chapter4/global</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>global.go</kbd> with the following content:</li>
</ol>
<pre>
        package global<br/><br/>        import (<br/>            "errors"<br/>            "os"<br/>            "sync"<br/><br/>            "github.com/sirupsen/logrus"<br/>        )<br/><br/>        // we make our global package level<br/>        // variable lower case<br/>        var (<br/>            log *logrus.Logger<br/>            initLog sync.Once<br/>        )<br/><br/>        // Init sets up the logger intially<br/>        // if run multiple times, it returns<br/>        // an error<br/>        func Init() error {<br/>            err := errors.New("already initialized")<br/>            initLog.Do(func() {<br/>                err = nil<br/>                log = logrus.New()<br/>                log.Formatter = &amp;logrus.JSONFormatter{}<br/>                log.Out = os.Stdout<br/>                log.Level = logrus.DebugLevel<br/>            })<br/>            return err<br/>        }<br/><br/>        // SetLog sets the log<br/>        func SetLog(l *logrus.Logger) {<br/>            log = l<br/>        }<br/><br/>        // WithField exports the logs withfield connected<br/>        // to our global log<br/>        func WithField(key string, value interface{}) *logrus.Entry {<br/>            return log.WithField(key, value)<br/>        }<br/><br/>        // Debug exports the logs Debug connected<br/>        // to our global log<br/>        func Debug(args ...interface{}) {<br/>            log.Debug(args...)<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>log.go</kbd> with the following content:</li>
</ol>
<pre>
        package global<br/><br/>        // UseLog demonstrates using our global<br/>        // log<br/>        func UseLog() error {<br/>            if err := Init(); err != nil {<br/>               return err<br/>         }<br/><br/>         // if we were in another package these would be<br/>         // global.WithField and<br/>         // global.Debug<br/>         WithField("key", "value").Debug("hello")<br/>         Debug("test")<br/><br/>         return nil<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>global</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter4/global"<br/><br/>        func main() {<br/>            if err := global.UseLog(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You s</span>hould see the following output:</p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      {"key":"value","level":"debug","msg":"hello","time":"2017-02-<br/>      12T19:22:50-08:00"}</strong><br/><strong>      {"level":"debug","msg":"test","time":"2017-02-12T19:22:50-<br/>      08:00"}</strong>
</pre>
<ol start="9">
<li><span>If yo</span>u copied or wrote your own tests, <span>go up one directory and</span> run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A common pattern for these global package-level objects is to keep the global unexported and expose only the functionality desired via methods. Typically, you could also include a method to return a copy of the global logger for packages that want a logger object.</p>
<p>The <kbd>sync.Once</kbd> type is a newly introduced structure. This structure, in conjunction with the <kbd>Do</kbd> method, will only execute in the code once. We use this in our initialization code, and the <kbd>Init</kbd> function will throw an error if <kbd>Init</kbd> is called more than once.</p>
<p>Although this example uses a log, you can also imagine cases where this might be useful with a database connection, data streams, and a number of other use cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catching panics for long running processes</h1>
                </header>
            
            <article>
                
<p>When implementing long running processes, it's possible that certain code paths will result in a panic. This is usually common for things uninitialized maps and pointers, as well as division by zero problems in the case of poorly validated user input.</p>
<p>Having a program crash completely in these cases is frequently much worse than the panic itself, and so it can be helpful to catch and handle panics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the</span> <em>Getting ready</em> <span>section of the</span> <em>Handling errors and the Error interface</em> <span>recipe in this chapter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter4/panic</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter4/panic">https://github.com/agtorre/go-cookbook/tree/master/chapter4/panic</a> or use this as an exercise to write some of your own code.</li>
</ol>
<p> </p>
<ol start="3">
<li>Create a file called <kbd>panic.go</kbd> with the following content:</li>
</ol>
<pre>
        package panic<br/><br/>        import (<br/>            "fmt"<br/>            "strconv"<br/>        )<br/><br/>        // Panic panics with a divide by zero<br/>        func Panic() {<br/>            zero, err := strconv.ParseInt("0", 10, 64)<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>        <br/>            a := 1 / zero<br/>            fmt.Println("we'll never get here", a)<br/>        }<br/><br/>        // Catcher calls Panic<br/>        func Catcher() {<br/>            defer func() {<br/>                if r := recover(); r != nil {<br/>                    fmt.Println("panic occurred:", r)<br/>                }<br/>            }()<br/>            Panic()<br/>        }
</pre>
<ol start="4">
<li>Create a new directory named <kbd>example</kbd> and navigate to <kbd>example</kbd>.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>panic</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter4/panic"<br/>        )<br/><br/>        func main() {<br/>            fmt.Println("before panic")<br/>            panic.Catcher()<br/>            fmt.Println("after panic")<br/>        }
</pre>
<p> </p>
<ol start="6">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      before panic</strong><br/><strong>      panic occurred: runtime error: integer divide by zero</strong><br/><strong>      after panic</strong>
</pre>
<ol start="8">
<li><span>If</span> you copied or <span>wrote your own tests, go up one directory and r</span>un <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe is a very basic example of how to catch panics. You can imagine with more complex middleware how you can defer a recover and catch it after running many nested functions. Within the recover, you can do basically anything you want, although emitting a log is common.</p>
<p>In most web applications, it's common to catch panics and emit an <kbd>http.InternalServerError</kbd> message when a panic occurs.</p>


            </article>

            
        </section>
    </body></html>