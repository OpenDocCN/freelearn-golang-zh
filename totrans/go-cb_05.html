<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">All about Databases and Storage</h1>
                </header>
            
            <article>
                
<p>In this chapter, the following recipes will be covered:</p>
<ul>
<li>The database/sql package with MySQL</li>
<li>Executing a database transaction interface</li>
<li>Connection pooling, rate limiting, and timeouts for SQL</li>
<li>Working with Redis</li>
<li>Using NoSQL with MongoDB and mgo</li>
<li>Creating storage interfaces for data portability</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Go applications frequently need to make use of long-term storage. This is usually in the form of relational and non-relational databases, as well as key-value stores and more. When working with these storage applications, it helps to wrap your operations in an interface. The recipes in this chapter will examine various storage interfaces, considering parallel access with things such as connection pools, and look at general tips for integrating a new library, which is often the case when using a new storage technology.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The database/sql package with MySQL</h1>
                </header>
            
            <article>
                
<p>Relational databases are some of the most well understood and common database options. MySQL and Postgres are two of the most popular open source relational databases. This recipe will demonstrate the <kbd>database/sql</kbd> package, a package that provides hooks for a number of relational databases and automatically handles connection pooling, connection duration, and gives access to a number of basic database operations.</p>
<p>The future versions of this package will include support for context and timeouts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>, and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application, navigate to your <kbd>GOPATH/src</kbd> and create a project directory such as<br/>
<kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="3">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
<li>Run the <kbd>go get github.com/go-sql-driver/mysql</kbd> command.</li>
<li>Install and configure MySQL using <a href="https://dev.mysql.com/doc/mysql-getting-started/en/">https://dev.mysql.com/doc/mysql-getting-started/en/</a>.</li>
<li>Run the <kbd>export MYSQLUSERNAME=&lt;your mysql username&gt;</kbd> command.</li>
<li>Run the <kbd>export MYSQLPASSWORD=&lt;your mysql password&gt;</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to a the directory <kbd>chapter5/database</kbd>.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter5/database">https://github.com/agtorre/go-cookbook/tree/master/chapter5/database</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>config.go</kbd> with the following contents:</li>
</ol>
<pre>
        package database<br/><br/>        import (<br/>            "database/sql"<br/>            "fmt"<br/>            "os"<br/>            "time"<br/><br/>            _ "github.com/go-sql-driver/mysql" //we import supported <br/>            libraries for database/sql<br/>        )<br/><br/>        // Example hold the results of our queries<br/>        type Example struct {<br/>            Name string<br/>            Created *time.Time<br/>        }<br/><br/>        // Setup configures and returns our database<br/>        // connection poold<br/>        func Setup() (*sql.DB, error) {<br/>            db, err := sql.Open("mysql", <br/>            fmt.Sprintf("%s:%s@/gocookbook? <br/>            parseTime=true", os.Getenv("MYSQLUSERNAME"), <br/>            os.Getenv("MYSQLPASSWORD")))<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/>            return db, nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>create.go</kbd> with the following contents:</li>
</ol>
<pre>
        package database<br/><br/>        import (<br/>            "database/sql"<br/><br/>            _ "github.com/go-sql-driver/mysql" //we import supported <br/>            libraries for database/sql<br/>        )<br/><br/>        // Create makes a table called example<br/>        // and populates it<br/>        func Create(db *sql.DB) error {<br/>            // create the database<br/>            if _, err := db.Exec("CREATE TABLE example (name <br/>            VARCHAR(20), created DATETIME)"); err != nil {<br/>                return err<br/>            }<br/><br/>            if _, err := db.Exec(`INSERT INTO example (name, created) <br/>            values ("Aaron", NOW())`); err != nil {<br/>                return err<br/>            }<br/><br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>query.go</kbd> with the following contents:</li>
</ol>
<pre>
        package database<br/><br/>        import (<br/>            "database/sql"<br/>            "fmt"<br/><br/>            _ "github.com/go-sql-driver/mysql" //we import supported <br/>            libraries for database/sql<br/>        )<br/><br/>        // Query grabs a new connection<br/>        // creates tables, and later drops them<br/>        // and issues some queries<br/>        func Query(db *sql.DB) error {<br/>            name := "Aaron"<br/>            rows, err := db.Query("SELECT name, created FROM example <br/>            where name=?", name)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            defer rows.Close()<br/>            for rows.Next() {<br/>                var e Example<br/>                if err := rows.Scan(&amp;e.Name, &amp;e.Created); err != nil {<br/>                    return err<br/>                }<br/>                fmt.Printf("Results:\n\tName: %s\n\tCreated: %v\n", <br/>                e.Name, e.Created)<br/>            }<br/>            return rows.Err()<br/>        }
</pre>
<p> </p>
<ol start="6">
<li>Create a file called <kbd>exec.go</kbd> with the following contents:</li>
</ol>
<pre>
        package dbinterface<br/><br/>        // Exec replaces the Exec from the previous<br/>        // recipe<br/>        func Exec(db DB) error {<br/><br/>            // uncaught error on cleanup, but we always<br/>            // want to cleanup<br/>            defer db.Exec("DROP TABLE example")<br/><br/>            if err := Create(db); err != nil {<br/>                return err<br/>            }<br/><br/>            if err := Query(db); err != nil {<br/>                return err<br/>            }<br/>            return nil<br/>        }
</pre>
<ol start="7">
<li>Create and navigate to the <kbd>example</kbd> directory.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>database</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "github.com/agtorre/go-cookbook/chapter5/database"<br/>            _ "github.com/go-sql-driver/mysql" //we import supported <br/>            libraries for database/sql<br/>        )<br/><br/>        func main() {<br/>            db, err := database.Setup()<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/><br/>            if err := database.Exec(db); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<p> </p>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Results:</strong><br/><strong>       Name: Aaron</strong><br/><strong>       Created: 2017-02-16 19:02:36 +0000 UTC</strong>
</pre>
<ol start="11">
<li><span>If yo</span>u copied <span>or wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>_ "github.com/go-sql-driver/mysql"</kbd> line of the code is how you connect various database connectors to the <kbd>database/sql</kbd> package. The commands would be similar if you were to connect to Postgres, SQLite, or any others that implement the <kbd>database/sql</kbd> interfaces.</p>
<p>Once connected, the package sets up a connection pool that is covered in the <em>Connection pooling, rate limiting, and timeouts for SQL</em> recipe, and you can either directly execute SQL on the connection or create transaction objects that can do everything a connection can do with the <kbd>commit</kbd> and <kbd>rollback</kbd> commands.</p>
<p>The <kbd>mysql</kbd> package provides some convenience support for Go time objects when talking to the database. This recipe also retrieves the username and password from the <kbd>MYSQLUSERNAME</kbd> and <kbd>MYSQLPASSWORD</kbd> environment variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing a database transaction interface</h1>
                </header>
            
            <article>
                
<p>When working with connections to services such as database, it can be difficult to write tests. This is because it's difficult in Go to mock or duck-type things at runtime. Although I recommend using a storage interface when working with databases, it's still useful to mock a database transaction interface inside of this interface. The <em>Creating storage interfaces for data portability</em> recipe will cover storage interfaces; this one will focus on an interface to wrap database connections and transaction objects.</p>
<p>To show the use of such an interface, we'll rewrite the create and query files from the previous recipe to use our interface. The final output will be the same, but the create and query operations will all be performed in a transaction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>The database/sql package with MySQL</em></span> recipe.</li>
<li>Run the <kbd>go get https://github.com/agtorre/go-cookbook/tree/master/chapter5/database</kbd> command or write your own using the <em>The database/sql package with MySQL</em> recipe.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol start="1">
<li>From your terminal/console application, create and navigate to the <kbd>chapter5/dbinterface</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter5/dbinterface">https://github.com/agtorre/go-cookbook/tree/master/chapter5/dbinterface</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>transaction.go</kbd> with the following contents:</li>
</ol>
<pre>
        package database<br/><br/>        import _ "github.com/go-sql-driver/mysql" //we import supported<br/>        libraries for database/sql<br/>        // Exec grabs a new connection<br/>        // creates tables, and later drops them<br/>        // and issues some queries<br/>        func Exec() error {<br/>            db, err := Setup()<br/>            if err != nil {<br/>                return err<br/>            }<br/>            // uncaught error on cleanup, but we always<br/>            // want to cleanup<br/>            defer db.Exec("DROP TABLE example")<br/><br/>            if err := Create(db); err != nil {<br/>                return err<br/>            }<br/><br/>            if err := Query(db); err != nil {<br/>                return err<br/>            }<br/>            return nil<br/><br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>create.go</kbd> with the following contents:</li>
</ol>
<pre>
        package dbinterface<br/><br/>        import _ "github.com/go-sql-driver/mysql" //we import supported<br/>        libraries for database/sql<br/><br/>        // Create makes a table called example<br/>        // and populates it<br/>        func Create(db DB) error {<br/>            // create the database<br/>            if _, err := db.Exec("CREATE TABLE example (name             <br/>            VARCHAR(20), created DATETIME)"); err != nil {<br/>                return err<br/>            }<br/><br/>            if _, err := db.Exec(`INSERT INTO example (name, created) <br/>            values ("Aaron", NOW())`); err != nil {<br/>                return err<br/>            }<br/><br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>query.go</kbd> with the following contents:</li>
</ol>
<pre>
        package dbinterface<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter5/database"<br/>        )<br/><br/>        // Query grabs a new connection<br/>        // creates tables, and later drops them<br/>        // and issues some queries<br/>        func Query(db DB) error {<br/>            name := "Aaron"<br/>            rows, err := db.Query("SELECT name, created FROM example <br/>            where name=?", name)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            defer rows.Close()<br/>            for rows.Next() {<br/>                var e database.Example<br/>                if err := rows.Scan(&amp;e.Name, &amp;e.Created); err != nil {<br/>                    return err<br/>                }<br/>                fmt.Printf("Results:\n\tName: %s\n\tCreated: %v\n", <br/>                e.Name, e.Created)<br/>            }<br/>            return rows.Err()<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>exec.go</kbd> with the following contents:</li>
</ol>
<pre>
        package dbinterface<br/><br/>        // Exec replaces the Exec from the previous<br/>        // recipe<br/>        func Exec(db DB) error {<br/><br/>            // uncaught error on cleanup, but we always<br/>            // want to cleanup<br/>            defer db.Exec("DROP TABLE example")<br/><br/>            if err := Create(db); err != nil {<br/>                return err<br/>            }<br/><br/>            if err := Query(db); err != nil {<br/>                return err<br/>            }<br/>            return nil<br/>        }
</pre>
<ol start="7">
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>dbinterface</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "github.com/agtorre/go-cookbook/chapter5/database"<br/>            "github.com/agtorre/go-cookbook/chapter5/dbinterface"<br/>            _ "github.com/go-sql-driver/mysql" //we import supported <br/>            libraries for database/sql<br/>        )<br/><br/>        func main() {<br/>            db, err := database.Setup()<br/>            if err != nil {<br/>                panic(err)<br/>         }<br/><br/>         tx, err := db.Begin()<br/>         if err != nil {<br/>             panic(err)<br/>         }<br/>         // this wont do anything if commit is successful<br/>         defer tx.Rollback()<br/><br/>         if err := dbinterface.Exec(db); err != nil {<br/>             panic(err)<br/>         }<br/>         if err := tx.Commit(); err != nil {<br/>             panic(err)<br/>         }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Results:</strong><br/><strong>       Name: Aaron</strong><br/><strong>       Created: 2017-02-16 20:00:00 +0000 UTC</strong>
</pre>
<ol start="11">
<li><span>If y</span>ou copied o<span>r wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe works in a very similar way to the previous one, but demonstrates both using transactions and makes generic database functions that work with both <kbd>sql.DB</kbd> connections and <kbd>sql.Transaction</kbd> objects. It's also simple to mock these interfaces, as you'll see in <a href="ab72719b-7fbf-4127-a091-b4ca5cf59775.xhtml" target="_blank">Chapter 8</a>, <em>Testing</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connection pooling, rate limiting, and timeouts for SQL</h1>
                </header>
            
            <article>
                
<p>Although the <kbd>database/sql</kbd> package provides support for connection pooling, rate limiting, and timeouts, it's often important to tweak the defaults to better accommodate your database configuration. This can become important when you have horizontal scaling on microservices and don't want to hold too many active connections to the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>The database/sql package with MySQL</em></span> recipe.</li>
<li>Run the <kbd>go get https://github.com/agtorre/go-cookbook/tree/master/chapter5/database</kbd> command or write your own using the <em>The database/sql package with MySQL</em> recipe.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter5/pools</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter5/pools">https://github.com/agtorre/go-cookbook/tree/master/chapter5/pools</a> or use this as an exercise to write some of your own code.</li>
</ol>
<p> </p>
<ol start="3">
<li>Create a file called <kbd>pools.go</kbd> with the following contents:</li>
</ol>
<pre>
        package pools<br/><br/>        import (<br/>            "database/sql"<br/>            "fmt"<br/>            "os"<br/><br/>            _ "github.com/go-sql-driver/mysql" //we import supported <br/>            libraries for database/sql<br/>        )<br/><br/>        // Setup configures the db along with pools<br/>        // number of connections and more<br/>        func Setup() (*sql.DB, error) {<br/>            db, err := sql.Open("mysql", <br/>            fmt.Sprintf("%s:%s@/gocookbook? <br/>            parseTime=true", os.Getenv("MYSQLUSERNAME"),         <br/>            os.Getenv("MYSQLPASSWORD")))<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/><br/>            // there will only ever be 24 open connections<br/>            db.SetMaxOpenConns(24)<br/><br/>            // MaxIdleConns can never be less than max open <br/>            // SetMaxOpenConns otherwise it'll default to that value<br/>            db.SetMaxIdleConns(24)<br/><br/>            return db, nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>timeout.go</kbd> with the following contents:</li>
</ol>
<pre>
        package pools<br/><br/>        import (<br/>            "context"<br/>            "time"<br/>        )<br/><br/>        // ExecWithTimeout will timeout trying<br/>        // to get the current time<br/>        func ExecWithTimeout() error {<br/>            db, err := Setup()<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            ctx := context.Background()<br/><br/>            // we want to timeout immediately<br/>            ctx, can := context.WithDeadline(ctx, time.Now())<br/><br/>            // call cancel after we complete<br/>            defer can()<br/><br/>            // our transaction is context aware<br/>            _, err = db.BeginTx(ctx, nil)<br/>            return err<br/>        }
</pre>
<ol start="5">
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>pools</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter5/pools"<br/><br/>        func main() {<br/>            if err := pools.ExecWithTimeout(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      panic: context deadline exceeded</strong><br/><br/><strong>      goroutine 1 [running]:</strong><br/><strong>      main.main()</strong><br/><strong>      /go/src/github.com/agtorre/go-  <br/>      cookbook/chapter5/pools/example/main.go:7 +0x4e</strong><br/><strong>      exit status 2</strong>
</pre>
<ol start="9">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Being able to control the depth of our connection pool is very useful. This will allow us not to overload a database, but it's important to consider what it will mean in the context of timeouts. If you enforce both a set number of connections and strict context-based timeouts, as we did in this recipe, there will be cases where you'll have requests frequently timing out on an overloaded application trying to establish too many connections.</p>
<p>This is because connections will timeout waiting for a connection to become available. The newly added context functionality for <kbd>database/sql</kbd> makes it much simpler to have a shared timeout for the entire request, including the steps involved with performing the query.</p>
<p>With this and the other recipes, it makes sense to use a global <kbd>config</kbd> object to pass into the <kbd>Setup()</kbd> function, although this recipe just uses environment variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Redis</h1>
                </header>
            
            <article>
                
<p>Sometimes you want persistent storage or additional functionality provided by third-party libraries and services. This recipe will explore Redis as a form of non-relational data storage and showcase how a language such as Go can interact with these services.</p>
<p>Since Redis supports key-value storage with a simple interface, it's an excellent candidate for session storage or temporary data that has a duration. The ability to specify timeout on data stored in Redis is extremely valuable. This recipe will explore basic Redis usage from configuration, to querying, to using custom sorting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>, and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application.</li>
</ol>
<p> </p>
<ol start="3">
<li>Navigate to your <kbd>GOPATH/src</kbd> and create a project directory such as <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="4">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
<li>Run the <kbd>go get gopkg.in/redis.v5</kbd> command.</li>
<li>Install and configure Redis using <a href="https://redis.io/topics/quickstart">https://redis.io/topics/quickstart</a>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter5/redis</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter5/redis">https://github.com/agtorre/go-cookbook/tree/master/chapter5/redis</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>config.go</kbd> with the following contents:</li>
</ol>
<pre>
        package redis<br/><br/>        import (<br/>            "os"<br/><br/>            redis "gopkg.in/redis.v5"<br/>        )<br/><br/>        // Setup initializes a redis client<br/>        func Setup() (*redis.Client, error) {<br/>            client := redis.NewClient(&amp;redis.Options{<br/>                Addr: "localhost:6379",<br/>                Password: os.Getenv("REDISPASSWORD"),<br/>                DB: 0, // use default DB<br/>         })<br/><br/>         _, err := client.Ping().Result()<br/>         return client, err<br/>        }
</pre>
<p> </p>
<ol start="4">
<li>Create a file called <kbd>exec.go</kbd> with the following contents:</li>
</ol>
<pre>
        package redis<br/><br/>        import (<br/>            "fmt"<br/>            "time"<br/><br/>            redis "gopkg.in/redis.v5"<br/>        )<br/><br/>        // Exec performs some redis operations<br/>        func Exec() error {<br/>            conn, err := Setup()<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            c1 := "value"<br/>            // value is an interface, we can store whatever<br/>            // the last argument is the redis expiration<br/>            conn.Set("key", c1, 5*time.Second)<br/><br/>            var result string<br/>            if err := conn.Get("key").Scan(&amp;result); err != nil {<br/>                switch err {<br/>                // this means the key<br/>                // was not found<br/>                case redis.Nil:<br/>                    return nil<br/>                default:<br/>                    return err<br/>                }<br/>            }<br/><br/>            fmt.Println("result =", result)<br/><br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>sort.go</kbd> with the following contents:</li>
</ol>
<pre>
        package redis<br/><br/>        import (<br/>            "fmt"<br/><br/>            redis "gopkg.in/redis.v5"<br/>        )<br/><br/>        // Sort performs a sort redis operations<br/>        func Sort() error {<br/>            conn, err := Setup()<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            if err := conn.LPush("list", 1).Err(); err != nil {<br/>                return err<br/>            }<br/>            if err := conn.LPush("list", 3).Err(); err != nil {<br/>                return err<br/>            }<br/>            if err := conn.LPush("list", 2).Err(); err != nil {<br/>                return err<br/>            }<br/><br/>            res, err := conn.Sort("list", redis.Sort{Order: <br/>            "ASC"}).Result()<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println(res)<br/>            conn.Del("list")<br/>            return nil<br/>        }
</pre>
<ol start="6">
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>redis</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter5/redis"<br/><br/>        func main() {<br/>            if err := redis.Exec(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            if err := redis.Sort(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<p> </p>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You sho</span>uld see th<span>e following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      result = value</strong><br/><strong>      [1 2 3]</strong>
</pre>
<ol start="10">
<li><span>If you copied</span> or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Working with Redis in Go is very similar to working with MySQL, although there's not a standard library, a lot of the same conventions are followed with functions such as <kbd>Scan()</kbd> to read data from Redis into Go types. It can be challenging to pick the best library to use in cases like this and I suggest surveying what's available periodically, as things can rapidly change.</p>
<p>This recipe uses a <kbd>redis</kbd> package to do basic setting and getting, doing a more complex sort function, and basic configuration. Like <kbd>database/sql</kbd>, you can set additional configuration in the form of write timeouts, poolsize, and more. Redis itself also provides a lot of additional functionality, including Redis cluster support, Zscore and counter objects, distributed locks, and more.</p>
<p>As in the preceding recipe, I recommend using a <kbd>config</kbd> object, which stores your Redis settings and configuration details for ease of setup and security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using NoSQL with MongoDB and mgo</h1>
                </header>
            
            <article>
                
<p>You might first think that Go is better suited to relational databases due to Go structs and because Go is a typed language. When working with something like the <kbd>mgo</kbd> package, Go can nearly arbitrarily store and retrieve struct objects. If you version your objects, your schema can adapt and it can provide a very flexible development environment.</p>
<p>Some libraries do a better job of hiding or elevating these abstractions. The <kbd>mgo</kbd> package is an excellent example of a library that does an excellent job of the former. This recipe will create a connection in a similar way to Redis and MySQL, but will store and retrieve an object without even defining a concrete schema.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>, and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application.</li>
<li>Navigate to your <kbd>GOPATH/src</kbd> and create a project directory such as <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="4">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
<li>Run the <kbd>go get gopkg.in/mgo.v2</kbd> command.</li>
<li>To run the code, you'll need a working database connection to a MongoDB instance that this book will not cover.</li>
<li>The basic setup is <a href="https://docs.mongodb.com/getting-started/shell/">https://docs.mongodb.com/getting-started/shell/</a>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter5/mongodb</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter5/mongodb">https://github.com/agtorre/go-cookbook/tree/master/chapter5/mongodb</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>config.go</kbd> with the following contents:</li>
</ol>
<pre>
        package mongodb<br/><br/>        import mgo "gopkg.in/mgo.v2"<br/><br/>        // Setup initializes a redis client<br/>        func Setup() (*mgo.Session, error) {<br/>            session, err := mgo.Dial("localhost")<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/>            return session, nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>exec.go</kbd> with the following contents:</li>
</ol>
<pre>
        package mongodb<br/><br/>        import (<br/>            "fmt"<br/><br/>            "gopkg.in/mgo.v2/bson"<br/>        )<br/><br/>        // State is our data model<br/>        type State struct {<br/>            Name string `bson:"name"`<br/>            Population int `bson:"pop"`<br/>        }<br/><br/>        // Exec creates then queries an Example<br/>        func Exec() error {<br/>            db, err := Setup()<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            conn := db.DB("gocookbook").C("example")<br/><br/>            // we can inserts many rows at once<br/>            if err := conn.Insert(&amp;State{"Washington", 7062000}, <br/>            &amp;State{"Oregon", 3970000}); err != nil {<br/>                return err<br/>            }<br/><br/>            var s State<br/>            if err := conn.Find(bson.M{"name": "Washington"}).One(&amp;s); <br/>            err!= nil {<br/>                return err<br/>            }<br/><br/>            if err := conn.DropCollection(); err != nil {<br/>                return err<br/>            }<br/><br/>            fmt.Printf("State: %#vn", s)<br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>mongodb</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter5/mongodb"<br/><br/>        func main() {<br/>            if err := mongodb.Exec(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should</span> see th<span>e following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      State: mongodb.State{Name:"Washington", Population:7062000}</strong>
</pre>
<ol start="9">
<li><span>If you</span> copied or wr<span>ote your own tests, go up one directory and ru</span>n <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>mgo</kbd> package also provides connection pooling, and many ways to tweak and configure your connections to the <kbd>mongodb</kbd> database. The examples of this recipe are fairly basic, but they illustrate how easy it is to reason about and query a document-based database. The package implements a BSON data type, and marshaling to and from it is very similar to working with JSON.</p>
<p>Consistency guarantees and best practice for <kbd>mongodb</kbd> are outside the scope of this book--but it's a pleasure to work with it in the Go language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating storage interfaces for data portability</h1>
                </header>
            
            <article>
                
<p>When working with external storage interfaces, it can be helpful to abstract your operations behind an interface. This is for ease of mocking, portability in case you change storage backends, and isolation of concerns. The downside to this approach may come if you need to perform multiple operations inside of a transaction. In that case, it makes sense to make composite operations, or to allow it to be passed in via a context object or additional function arguments.</p>
<p>This recipe will implement a very simple interface to working with items in MongoDB. These items will have a name and price and we'll use an interface to persist and retrieve these objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the steps given in the <em>Getting ready</em> section of the <em>Using NoSQL with MongoDB and mgo</em></span> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter5/mongodb</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter5/mongodb">https://github.com/agtorre/go-cookbook/tree/master/chapter5/mongodb</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>storage.go</kbd> with the following contents:</li>
</ol>
<pre>
        package storage<br/><br/>        import "context"<br/><br/>        // Item represents an item at<br/>        // a shop<br/>        type Item struct {<br/>            Name  string<br/>            Price int64<br/>        }<br/><br/>        // Storage is our storage interface<br/>        // We'll implement it with Mongo<br/>        // storage<br/>        type Storage interface {<br/>            GetByName(context.Context, string) (*Item, error)<br/>            Put(context.Context, *Item) error<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>mongoconfig.go</kbd> with the following contents:</li>
</ol>
<pre>
        package storage<br/><br/>        import mgo "gopkg.in/mgo.v2"<br/><br/>        // MongoStorage implements our storage interface<br/>        type MongoStorage struct {<br/>            *mgo.Session<br/>            DB string<br/>            Collection string<br/>        }<br/><br/>        // NewMongoStorage initializes a MongoStorage<br/>        func NewMongoStorage(connection, db, collection string) <br/>        (*MongoStorage, error) {<br/>            session, err := mgo.Dial("localhost")<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/>            ms := MongoStorage{<br/>                Session: session,<br/>                DB: db,<br/>                Collection: collection,<br/>            }<br/>            return &amp;ms, nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>mongointerface.go</kbd> with the following contents:</li>
</ol>
<pre>
        package storage<br/><br/>        import (<br/>            "context"<br/><br/>            "gopkg.in/mgo.v2/bson"<br/>        )<br/><br/>        // GetByName queries mongodb for an item with<br/>        // the correct name<br/>        func (m *MongoStorage) GetByName(ctx context.Context, name <br/>        string) (*Item, error) {<br/>            c := m.Session.DB(m.DB).C(m.Collection)<br/>            var i Item<br/>            if err := c.Find(bson.M{"name": name}).One(&amp;i); err != nil <br/>            {<br/>                return nil, err<br/>            }<br/><br/>            return &amp;i, nil<br/>        }<br/><br/>        // Put adds an item to our mongo instance<br/>        func (m *MongoStorage) Put(ctx context.Context, i *Item) error <br/>        {<br/>            c := m.Session.DB(m.DB).C(m.Collection)<br/>            return c.Insert(i)<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>exec.go</kbd> with the following contents:</li>
</ol>
<pre>
        package storage<br/><br/>        import (<br/>            "context"<br/>            "fmt"<br/>        )<br/><br/>        // Exec initializes storage, then performs operations<br/>        // using the storage interface<br/>        func Exec() error {<br/>            m, err := NewMongoStorage("localhost", "gocookbook", <br/>            "items")<br/>            if err != nil {<br/>                return err<br/>            }<br/>            if err := PerformOperations(m); err != nil {<br/>                return err<br/>            }<br/><br/>            if err := <br/>            m.Session.DB(m.DB).C(m.Collection).DropCollection(); <br/>            err != nil {<br/>                return err<br/>            }<br/><br/>            return nil<br/>        }<br/><br/>        // PerformOperations creates a candle item<br/>        // then gets it<br/>        func PerformOperations(s Storage) error {<br/>            ctx := context.Background()<br/>            i := Item{Name: "candles", Price: 100}<br/>            if err := s.Put(ctx, &amp;i); err != nil {<br/>                return err<br/>            }<br/><br/>            candles, err := s.GetByName(ctx, "candles")<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Printf("Result: %#vn", candles)<br/>                return nil<br/>        }
</pre>
<ol start="7">
<li>Navigate to <kbd>example</kbd>.</li>
<li>Create a file called <kbd>main.go</kbd> with the following contents; be sure to modify the <kbd>storage</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter5/storage"<br/><br/>        func main() {<br/>            if err := storage.Exec(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You could also run this:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Result: &amp;storage.Item{Name:"candles", Price:100}</strong>
</pre>
<ol start="11">
<li><span>If you co</span>pied or wr<span>ote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The most important function for demonstrating this recipe is <kbd>PerformOperation</kbd>. This function takes an interface to the storage as a parameter. This means we can dynamically replace the underlying storage without even modifying this function. It would be simple, for example, to connect storage to a separate API in order to consume and modify it.</p>
<p>We added a context to these interfaces to add additional flexibility and allow the interface to handle timeout as well. Separating your application logic from the underlying storage provides a variety of benefits, but it can be difficult to pick the right places to draw boundaries, and this will vary widely by application.</p>


            </article>

            
        </section>
    </body></html>