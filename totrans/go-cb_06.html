<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Web Clients and APIs</h1>
                </header>
            
            <article>
                
<p>In this chapter we will cover the following recipes:</p>
<ul>
<li>Initializing, storing, and passing http.Client structs</li>
<li>Writing a client for a REST API</li>
<li>Executing parallel and async client requests</li>
<li>Making use of OAuth2 clients</li>
<li>Implementing an OAuth2 token storage interface</li>
<li>Wrapping a client in added functionality and function composition</li>
<li>Understanding GRPC clients</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Working with APIs and writing web clients can be a tricky subject. Different APIs have different types of authorization, authentication, and protocols. We'll explore the <kbd>http.Client</kbd> struct object, working with OAuth2 clients and long-term token storage, and finish off with GRPC with an additional REST interface.</p>
<p>By the end of this chapter, you should have an idea of how to interface with third-party or in-house APIs and have some patterns for common operations, such as async requests to APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing, storing, and passing http.Client structs</h1>
                </header>
            
            <article>
                
<p>The Go <kbd>net/http</kbd> package exposes a flexible <kbd>http.Client</kbd> struct for working with HTTP APIs. This struct has separate transport functionality and is relatively simple to short-circuit requests, modify headers for each client operation, and handle any REST operations. Creating clients is a very common operation, and this recipe will start with the basics of working and creating an <kbd>http.Client</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application.</li>
<li>Navigate to <kbd>GOPATH/src</kbd> and create a project directory. For example, <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="4">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter6/client</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter6/client">https://github.com/agtorre/go-cookbook/tree/master/chapter6/client</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>client.go</kbd> with the following content:</li>
</ol>
<pre>
        package client<br/><br/>        import (<br/>            "crypto/tls"<br/>            "net/http"<br/>        )<br/><br/>        // Setup configures our client and redefines<br/>        // the global DefaultClient<br/>        func Setup(isSecure, nop bool) *http.Client {<br/>            c := http.DefaultClient<br/><br/>            // Sometimes for testing, we want to<br/>            // turn off SSL verification<br/>            if !isSecure {<br/>                c.Transport = &amp;http.Transport{<br/>                TLSClientConfig: &amp;tls.Config{<br/>                    InsecureSkipVerify: false,<br/>                },<br/>            }<br/>        }<br/>        if nop {<br/>            c.Transport = &amp;NopTransport{}<br/>        }<br/>        http.DefaultClient = c<br/>        return c<br/>        }<br/><br/>        // NopTransport is a No-Op Transport<br/>        type NopTransport struct {<br/>        }<br/><br/>        // RoundTrip Implements RoundTripper interface<br/>        func (n *NopTransport) RoundTrip(*http.Request) <br/>        (*http.Response, error) {<br/>            // note this is an unitialized Response<br/>            // if you're looking at headers etc<br/>            return &amp;http.Response{StatusCode: http.StatusTeapot}, nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>exec.go</kbd> with the following content:</li>
</ol>
<pre>
        package client<br/><br/>        import (<br/>            "fmt"<br/>            "net/http"<br/>        )<br/><br/>        // DoOps takes a client, then fetches<br/>        // google.com<br/>        func DoOps(c *http.Client) error {<br/>            resp, err := c.Get("http://www.google.com")<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("results of DoOps:", resp.StatusCode)<br/><br/>            return nil<br/>        }<br/><br/>        // DefaultGetGolang uses the default client<br/>        // to get golang.org<br/>        func DefaultGetGolang() error {<br/>            resp, err := http.Get("https://www.golang.org")<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("results of DefaultGetGolang:", <br/>            resp.StatusCode)<br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>store.go</kbd> with the following content:</li>
</ol>
<pre>
        package client<br/><br/>        import (<br/>            "fmt"<br/>            "net/http"<br/>        )<br/><br/>        // Controller embeds an http.Client<br/>        // and uses it internally<br/>        type Controller struct {<br/>            *http.Client<br/>        }<br/><br/>        // DoOps with a controller object<br/>        func (c *Controller) DoOps() error {<br/>            resp, err := c.Client.Get("http://www.google.com")<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("results of client.DoOps", resp.StatusCode)<br/>            return nil<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
</ol>
<ol start="7">
<li>Create a file named <kbd>main.go</kbd> with the following content. Ensure that you modify the <kbd>client</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter6/client"<br/><br/>        func main() {<br/>            // secure and op!<br/>            cli := client.Setup(true, false)<br/><br/>            if err := client.DefaultGetGolang(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            if err := client.DoOps(cli); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            c := client.Controller{Client: cli}<br/>            if err := c.DoOps(); err != nil {<br/>                panic(err)<br/>            }<br/><br/>            // secure and noop<br/>            // also modifies default<br/>            client.Setup(true, true)<br/><br/>            if err := client.DefaultGetGolang(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You shou</span>ld now see the fol<span>lowing output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      results of DefaultGetGolang: 200</strong><br/><strong>      results of DoOps: 200</strong><br/><strong>      results of client.DoOps 200</strong><br/><strong>      results of DefaultGetGolang: 418</strong>
</pre>
<ol start="10">
<li><span>If you cop</span>ied or wrote your own te<span>sts, go up one directory and ru</span>n <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>net/http</kbd> package exposes a <kbd>DefaultClient</kbd> package variable, which is used by the internal operations, <kbd>Do</kbd>, <kbd>GET</kbd>, <kbd>POST</kbd>, and so on. Our <kbd>Setup()</kbd> function returns a client and sets the default client to be the same. When setting up a client, most of your modifications will take place in the transport, which only needs to implement the <kbd>RoundTripper</kbd> interface.</p>
<p>This recipe gives an example of a no-op round tripper that always returns a 418 status code. You can imagine how this might be useful for testing. It also demonstrates passing in clients as function arguments, using them as struct parameters, and using the default client to process requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a client for a REST API</h1>
                </header>
            
            <article>
                
<p>Writing a client for a REST API will not only help you better understand the API in question, but also gives you a useful tool for all future applications using that API. This will explore structuring a client and show some strategies that you can immediately take advantage of.</p>
<p>For this client, we'll assume that the authentication is handled by basic auth, but it would also be possible to hit an endpoint to retrieve a token, and so on. For the sake of simplicity, we'll assume our API exposes one endpoint, <kbd>GetGoogle()</kbd>, which returns that status code returned from doing a <kbd>GET</kbd> request to <a href="https://www.google.com">https://www.google.com</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Refer to the <span><em>Getting ready</em> section of the <em>Initializing, storing, and passing http.Client structs</em></span> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter6/rest</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter6/rest">https://github.com/agtorre/go-cookbook/tree/master/chapter6/rest</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>client.go</kbd> with the following content:</li>
</ol>
<pre>
        package rest<br/><br/>        import "net/http"<br/><br/>        // APIClient is our custom client<br/>        type APIClient struct {<br/>            *http.Client<br/>        }<br/><br/>        // NewAPIClient constructor initializes the client with our<br/>        // custom Transport<br/>        func NewAPIClient(username, password string) *APIClient {<br/>            t := http.Transport{}<br/>            return &amp;APIClient{<br/>                Client: &amp;http.Client{<br/>                    Transport: &amp;APITransport{<br/>                        Transport: &amp;t,<br/>                        username: username,<br/>                        password: password,<br/>                    },<br/>                },<br/>            }<br/>        }<br/><br/>        // GetGoogle is an API Call - we abstract away<br/>        // the REST aspects<br/>        func (c *APIClient) GetGoogle() (int, error) {<br/>            resp, err := c.Get("http://www.google.com")<br/>            if err != nil {<br/>                return 0, err<br/>            }<br/>            return resp.StatusCode, nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>transport.go</kbd> with the following content:</li>
</ol>
<pre>
        package rest<br/><br/>        import "net/http"<br/><br/>        // APITransport does a SetBasicAuth<br/>        // for every request<br/>        type APITransport struct {<br/>            *http.Transport<br/>            username, password string<br/>        }<br/><br/>        // RoundTrip does the basic auth before deferring to the<br/>        // default transport<br/>        func (t *APITransport) RoundTrip(req *http.Request) <br/>        (*http.Response, error) {<br/>            req.SetBasicAuth(t.username, t.password)<br/>            return t.Transport.RoundTrip(req)<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>exec.go</kbd> with the following content:</li>
</ol>
<pre>
        package rest<br/><br/>        import "fmt"<br/><br/>        // Exec creates an API Client and uses its<br/>        // GetGoogle method, then prints the result<br/>        func Exec() error {<br/>            c := NewAPIClient("username", "password")<br/><br/>            StatusCode, err := c.GetGoogle()<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("Result of GetGoogle:", StatusCode)<br/>            return nil<br/>        }
</pre>
<ol start="6">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
</ol>
<ol start="7">
<li>Create a file named <kbd>main.go</kbd> with the following content. Ensure that you modify the <kbd>rest</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter6/rest"<br/><br/>        func main() {<br/>            if err := rest.Exec(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following commands:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should now see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Result of GetGoogle: 200</strong>
</pre>
<ol start="10">
<li><span>If y</span>ou copied <span>or wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This code demonstrates how to hide logic such as authentication, token refresh, and more using the <kbd>Transport</kbd> interface. It also demonstrates exposing an API call via a method. Had we been implementing against something like a user API, we would expect methods like:</p>
<pre>
type API interface{<br/>  GetUsers() (Users, error)<br/>  CreateUser(User) error<br/>  UpdateUser(User) error<br/>  DeleteUser(User)<br/>}
</pre>
<p>If you've read <a href="e4c2a55e-c570-4490-b981-2685a89be7d2.xhtml" target="_blank">Chapter 5</a>, <em>All ab</em><em>out Databases and Storage</em>, this may look similar to the recipe. This composition through interfaces, especially common interfaces like the <kbd>RoundTripper</kbd> interface, provide a lot of flexibility for writing APIs. In addition, it may be useful to write a top-level interface as we did earlier and pass the interface around instead of the client directly. We'll explore this more in the next recipe as we explore writing an OAuth2 client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing parallel and async client requests</h1>
                </header>
            
            <article>
                
<p>Performing client requests in parallel is relatively simple in Go. In the following recipe, we'll use a client to retrieve multiple URLs using Go buffered channels. Responses and errors will both go to a separate channel that is readily accessible by anyone with access to the client.</p>
<p>In the case of this recipe, creation of the client, reading the channels, and handling of responses and errors will all be done in the <kbd>main.go</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Refer to the <span><em>Getting ready</em> section of the</span> <em>Initializing, storing, and passing http.Client structs</em> recipe in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter6/async</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter6/async">https://github.com/agtorre/go-cookbook/tree/master/chapter6/async</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>config.go</kbd> with the following content:</li>
</ol>
<pre>
        package async<br/><br/>        import "net/http"<br/><br/>        // NewClient creates a new client and <br/>        // sets its appropriate channels<br/>        func NewClient(client *http.Client, bufferSize int) *Client {<br/>            respch := make(chan *http.Response, bufferSize)<br/>            errch := make(chan error, bufferSize)<br/>            return &amp;Client{<br/>                Client: client,<br/>                Resp: respch,<br/>                Err: errch,<br/>            }<br/>        }<br/><br/>        // Client stores a client and has two channels to aggregate<br/>        // responses and errors<br/>        type Client struct {<br/>            *http.Client<br/>            Resp chan *http.Response<br/>            Err chan error<br/>        }<br/><br/>        // AsyncGet performs a Get then returns<br/>        // the resp/error to the appropriate channel<br/>        func (c *Client) AsyncGet(url string) {<br/>            resp, err := c.Get(url)<br/>            if err != nil {<br/>                c.Err &lt;- err<br/>                return<br/>            }<br/>            c.Resp &lt;- resp<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>exec.go</kbd> with the following content:</li>
</ol>
<pre>
        package async<br/><br/>        // FetchAll grabs a list of urls<br/>        func FetchAll(urls []string, c *Client) {<br/>            for _, url := range urls {<br/>                go c.AsyncGet(url)<br/>            }<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a file named <kbd>main.go</kbd> with the following content. Ensure that you modify the <kbd>client</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "net/http"<br/><br/>            "github.com/agtorre/go-cookbook/chapter6/async"<br/>        )<br/><br/>        func main() {<br/>            urls := []string{<br/>                "https://www.google.com",<br/>                "https://golang.org",<br/>                "https://www.github.com",<br/>            }<br/>            c := async.NewClient(http.DefaultClient, len(urls))<br/>            async.FetchAll(urls, c)<br/><br/>            for i := 0; i &lt; len(urls); i++ {<br/>                select {<br/>                    case resp := &lt;-c.Resp:<br/>                    fmt.Printf("Status received for %s: %d\n", <br/>                    resp.Request.URL, resp.StatusCode)<br/>                    case err := &lt;-c.Err:<br/>                   fmt.Printf("Error received: %s\n", err)<br/>                }<br/>            }<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following commands:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You sho</span>uld see the fo<span>llowing output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Status received for https://www.google.com: 200</strong><br/><strong>      Status received for https://golang.org: 200</strong><br/><strong>      Status received for https://github.com/: 200</strong>
</pre>
<ol start="9">
<li><span>If yo</span>u copied o<span>r wrote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe creates a framework for processing requests in a fan-out async way using a single client. It will attempt to retrieve as many URLs as you specify as quickly as it can. In many cases, you'd want to restrict this further with something like a worker pool. It may also make sense to handle these async Go routines outside of the client and for specific storage or retrieval interfaces.</p>
<p>This recipe also explores using a case statement to switch on multiple channels. We handle the locking problem since we know how many responses we'll receive and we complete only after receiving them all. Another option would be a timeout if we were okay with dropping certain responses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making use of OAuth2 clients</h1>
                </header>
            
            <article>
                
<p>OAuth2 is a relatively common protocol for speaking with APIs. The <kbd>golang.org/x/oauth2</kbd> package provides a pretty flexible client for working with OAuth2. It has subpackages that specify endpoints for various providers such as Facebook, Google, and GitHub.</p>
<p>This recipe will demonstrate how to create a new GitHub OAuth2 client and some of its basic usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Refer to the <span><em>Getting ready</em> section of the <em>Initializing, storing, and passing http.Client structs</em></span> recipe.</li>
<li>Run the <kbd>go get golang.org/x/oauth2</kbd> command.</li>
<li>Configure an OAuth Client at <a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a>.</li>
<li>Set the environment variables with your Client ID and Secret:
<ol>
<li><kbd>export GITHUB_CLIENT="your_client"</kbd></li>
<li><kbd>export GITHUB_SECRET="your_secret"</kbd></li>
</ol>
</li>
<li>Brush up on the GitHub API documentation at <a href="https://developer.github.com/v3/">https://developer.github.com/v3/</a>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter6/client</kbd> directory.</li>
</ol>
<ol start="2">
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter6/oauthcli">https://github.com/agtorre/go-cookbook/tree/master/chapter6/oauthcli</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>config.go</kbd> with the following content:</li>
</ol>
<pre>
        package oauthcli<br/><br/>        import (<br/>            "context"<br/>            "fmt"<br/>            "os"<br/><br/>            "golang.org/x/oauth2"<br/>            "golang.org/x/oauth2/github"<br/>        )<br/><br/>        // Setup return an oauth2Config configured to talk<br/>        // to github, you need environment variables set<br/>        // for your id and secret<br/>        func Setup() *oauth2.Config {<br/>            return &amp;oauth2.Config{<br/>                ClientID: os.Getenv("GITHUB_CLIENT"),<br/>                ClientSecret: os.Getenv("GITHUB_SECRET"),<br/>                Scopes: []string{"repo", "user"},<br/>                Endpoint: github.Endpoint,<br/>            }<br/>        }<br/><br/>        // GetToken retrieves a github oauth2 token<br/>        func GetToken(ctx context.Context, conf *oauth2.Config) <br/>        (*oauth2.Token, error) {<br/>            url := conf.AuthCodeURL("state")<br/>            fmt.Printf("Type the following url into your browser and <br/>            follow the directions on screen: %v\n", url)<br/>            fmt.Println("Paste the code returned in the redirect URL <br/>            and hit Enter:")<br/><br/>            var code string<br/>            if _, err := fmt.Scan(&amp;code); err != nil {<br/>                return nil, err<br/>            }<br/>            return conf.Exchange(ctx, code)<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>exec.go</kbd> with the following content:</li>
</ol>
<pre>
        package oauthcli<br/><br/>        import (<br/>            "fmt"<br/>            "net/http"<br/>        )<br/><br/>        // GetUsers uses an initialized oauth2 client to get<br/>        // information about a user<br/>        func GetUsers(client *http.Client) error {<br/>            url := fmt.Sprintf("https://api.github.com/user")<br/><br/>            resp, err := client.Get(url)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            defer resp.Body.Close()<br/>            fmt.Println("Status Code from", url, ":", resp.StatusCode)<br/>            io.Copy(os.Stdout, resp.Body)<br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>client</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "context"<br/><br/>            "github.com/agtorre/go-cookbook/chapter6/oauthcli"<br/>        )<br/><br/>        func main() {<br/>            ctx := context.Background()<br/>            conf := oauthcli.Setup()<br/><br/>            tok, err := oauthcli.GetToken(ctx, conf)<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            client := conf.Client(ctx, tok)<br/><br/>            if err := oauthcli.GetUsers(client); err != nil {<br/>                panic(err)<br/>            }<br/><br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should now see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Visit the URL for the auth dialog: <br/>      https://github.com/login/oauth/authorize?<br/>      access_type=offline&amp;client_id=<br/>      &lt;your_id&gt;&amp;response_type=code&amp;scope=repo+user&amp;state=state</strong><br/><strong>      Paste the code returned in the redirect URL and hit Enter:</strong><br/><strong>      &lt;your_code&gt;</strong><br/><strong>      Status Code from https://api.github.com/user: 200</strong><br/><strong>      {&lt;json_payload&gt;}</strong>
</pre>
<ol start="9">
<li><span>If you c</span>opied or <span>wrote your own tests, go up one directory and</span> run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The standard OAuth2 flow is redirect-based and ends with the server redirecting to an endpoint you specify. Your server is then responsible for grabbing the code and exchanging it for a token. This recipe bypasses that requirement by allowing us to use a URL such as <kbd>https://localhost</kbd> or <kbd>https://a-domain-you-own</kbd> and manually copying/pasting the code, then hitting enter. Once the token has been exchanged, the client will intelligently refresh the token as needed.</p>
<p>It's important to note that we're not storing the token in any way. If the program crashes, it must re-exchange for the token. It's also important to note that we need to retrieve the token explicitly only once unless the refresh token expires, is lost, or is corrupted. Once the client is configure, it should be able to do all typical HTTP operations for the API which it authorized against and for which it has appropriate scopes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing an OAuth2 token storage interface</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we retrieved a token for our client and performed API requests. The downside of this approach is that we have no long-term storage for our token. In an HTTP server, for example, we'd like to have consistent storage of the token between requests.</p>
<p>This recipe will explore modifying the OAuth2 client to store a token between requests and retrieve them at will using a key. For the sake of simplicity, this key will be a file, but it could also be a database, Redis, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Refer to the <em>Getting ready</em> section of the <em>Making use of OAuth2 clients</em></span> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter6/client</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter6/oauthstore">https://github.com/agtorre/go-cookbook/tree/master/chapter6/oauthstore</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>config.go</kbd> with the following content:</li>
</ol>
<pre>
        package oauthstore<br/><br/>        import (<br/>            "context"<br/>            "net/http"<br/><br/>            "golang.org/x/oauth2"<br/>        )<br/><br/>        // Config wraps the default oauth2.Config<br/>        // and adds our storage<br/>        type Config struct {<br/>            *oauth2.Config<br/>            Storage<br/>        }<br/><br/>        // Exchange stores a token after retrieval<br/>        func (c *Config) Exchange(ctx context.Context, code string)     <br/>        (*oauth2.Token, error) {<br/>            token, err := c.Config.Exchange(ctx, code)<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/>            if err := c.Storage.SetToken(token); err != nil {<br/>                return nil, err<br/>            }<br/>            return token, nil<br/>        }<br/>        <br/>        // TokenSource can be passed a token which<br/>        // is stored, or when a new one is retrieved,<br/>        // that's stored<br/>        func (c *Config) TokenSource(ctx context.Context, t <br/>        *oauth2.Token) oauth2.TokenSource {<br/>            return StorageTokenSource(ctx, c, t)<br/>        }<br/><br/>        // Client is attached to our TokenSource<br/>        func (c *Config) Client(ctx context.Context, t *oauth2.Token) <br/>        *http.Client {<br/>            return oauth2.NewClient(ctx, c.TokenSource(ctx, t))<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>tokensource.go</kbd> with the following content:</li>
</ol>
<pre>
        package oauthstore<br/><br/>        import (<br/>            "context"<br/><br/>            "golang.org/x/oauth2"<br/>        )<br/><br/>        type storageTokenSource struct {<br/>            *Config<br/>            oauth2.TokenSource<br/>        }<br/><br/>        // Token satisfies the TokenSource interface<br/>        func (s *storageTokenSource) Token() (*oauth2.Token, error) {<br/>            if token, err := s.Config.Storage.GetToken(); err == nil &amp;&amp; <br/>            token.Valid() {<br/>                return token, err<br/>            }<br/>            token, err := s.TokenSource.Token()<br/>            if err != nil {<br/>                return token, err<br/>            }<br/>            if err := s.Config.Storage.SetToken(token); err != nil {<br/>                return nil, err<br/>            }<br/>            return token, nil<br/>        }<br/><br/>        // StorageTokenSource will be used by out configs TokenSource<br/>        // function<br/>        func StorageTokenSource(ctx context.Context, c *Config, t <br/>        *oauth2.Token) oauth2.TokenSource {<br/>            if t == nil || !t.Valid() {<br/>                if tok, err := c.Storage.GetToken(); err == nil {<br/>                   t = tok<br/>                }<br/>            }<br/>            ts := c.Config.TokenSource(ctx, t)<br/>            return &amp;storageTokenSource{c, ts}<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>storage.go</kbd> with the following content:</li>
</ol>
<pre>
        package oauthstore<br/><br/>        import (<br/>            "context"<br/>            "fmt"<br/><br/>            "golang.org/x/oauth2"<br/>        )<br/><br/>        // Storage is our generic storage interface<br/>        type Storage interface {<br/>            GetToken() (*oauth2.Token, error)<br/>            SetToken(*oauth2.Token) error<br/>        }<br/><br/>        // GetToken retrieves a github oauth2 token<br/>        func GetToken(ctx context.Context, conf Config) (*oauth2.Token, <br/>        error) {<br/>            token, err := conf.Storage.GetToken()<br/>            if err == nil &amp;&amp; token.Valid() {<br/>                return token, err<br/>            }<br/>            url := conf.AuthCodeURL("state")<br/>            fmt.Printf("Type the following url into your browser and <br/>            follow the directions on screen: %v\n", url)<br/>            fmt.Println("Paste the code returned in the redirect URL <br/>            and hit Enter:")<br/><br/>            var code string<br/>            if _, err := fmt.Scan(&amp;code); err != nil {<br/>                return nil, err<br/>            }<br/>            return conf.Exchange(ctx, code)<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>filestorage.go</kbd> with the following content:</li>
</ol>
<pre>
        package oauthstore<br/><br/>        import (<br/>            "encoding/json"<br/>            "errors"<br/>            "os"<br/>            "sync"<br/><br/>            "golang.org/x/oauth2"<br/>        )<br/><br/>        // FileStorage satisfies our storage interface<br/>        type FileStorage struct {<br/>            Path string<br/>            mu sync.RWMutex<br/>        }<br/><br/>        // GetToken retrieves a token from a file<br/>        func (f *FileStorage) GetToken() (*oauth2.Token, error) {<br/>            f.mu.RLock()<br/>            defer f.mu.RUnlock()<br/>            in, err := os.Open(f.Path)<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/>            defer in.Close()<br/>            var t *oauth2.Token<br/>            data := json.NewDecoder(in)<br/>            return t, data.Decode(&amp;t)<br/>        }<br/><br/>        // SetToken creates, truncates, then stores a token<br/>        // in a file<br/>        func (f *FileStorage) SetToken(t *oauth2.Token) error {<br/>            if t == nil || !t.Valid() {<br/>                return errors.New("bad token")<br/>            }<br/><br/>            f.mu.Lock()<br/>            defer f.mu.Unlock()<br/>            out, err := os.OpenFile(f.Path, <br/>            os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)<br/>            if err != nil {<br/>                return err<br/>            }<br/>            defer out.Close()<br/>            data, err := json.Marshal(&amp;t)<br/>            if err != nil {<br/>                return err<br/>            }<br/><br/>            _, err = out.Write(data)<br/>            return err<br/>        }
</pre>
<ol start="7">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a file named <kbd>main.go</kbd> with the following content. Ensure that you modify the <kbd>oauthstore</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "context"<br/>            "io"<br/>            "os"<br/>        <br/>            "github.com/agtorre/go-cookbook/chapter6/oauthstore"<br/><br/>            "golang.org/x/oauth2"<br/>            "golang.org/x/oauth2/github"<br/>        )<br/><br/>        func main() {<br/>            conf := oauthstore.Config{<br/>                Config: &amp;oauth2.Config{<br/>                    ClientID: os.Getenv("GITHUB_CLIENT"),<br/>                    ClientSecret: os.Getenv("GITHUB_SECRET"),<br/>                    Scopes: []string{"repo", "user"},<br/>                    Endpoint: github.Endpoint,<br/>                },<br/>                Storage: &amp;oauthstore.FileStorage{Path: "token.txt"},<br/>            }<br/>            ctx := context.Background()<br/>            token, err := oauthstore.GetToken(ctx, conf)<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/><br/>            cli := conf.Client(ctx, token)<br/>            resp, err := cli.Get("https://api.github.com/user")<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            defer resp.Body.Close()<br/>            io.Copy(os.Stdout, resp.Body)<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You shoul</span>d now see the follo<span>wing output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      Visit the URL for the auth dialog: <br/>      https://github.com/login/oauth/authorize?<br/>      access_type=offline&amp;client_id=<br/>      &lt;your_id&gt;&amp;response_type=code&amp;scope=repo+user&amp;state=state</strong><br/><strong>      Paste the code returned in the redirect URL and hit Enter:</strong><br/><strong>      &lt;your_code&gt;</strong><br/><strong>      {&lt;json_payload&gt;}</strong><br/><br/><strong>      $ go run main.go</strong><br/><strong>      {&lt;json_payload&gt;}</strong>
</pre>
<ol start="11">
<li><span>If you</span> copied or w<span>rote your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe takes care of storing and retrieving the contents of the token to/from a file. If it's a first run, it must execute the entire code exchange, but the subsequent runs will reuse the access token, and if one is available, it will refresh using the refresh token.</p>
<p>There is currently no way in this code to differentiate between users/tokens, but that could be accomplished with cookies as a key for a filename or a row in the database as well. Let's walk through what this code does:</p>
<ul>
<li>The <kbd>config.go</kbd> file wraps the standard OAuth2 config. For every method that involves retrieving a token, we first check whether we have a valid token in the local storage. If not, we retrieve one using the standard config and then store it.</li>
<li>The <kbd>tokensource.go</kbd> file implements our custom <kbd>TokenSource</kbd> interface that pairs with <kbd>Config</kbd>. Similar to <kbd>Config</kbd>, we always first try to retrieve our token from a file and set it with the new token otherwise.</li>
<li>The <kbd>storage.go</kbd> file is the <kbd>storage</kbd> interface used by <kbd>Config</kbd> and <kbd>TokenSource</kbd>. It only defines two methods and we also include a helper function to bootstrap the OAuth2 code-based flow similar to what we did in the previous recipe, but if the file with a valid token already exists, it will be used instead.</li>
<li>The <kbd>filestorage.go</kbd> file implements the <kbd>storage</kbd> interface. When we store a new token, we first truncate the file and write a JSON representation of the <kbd>token</kbd> struct. Otherwise, we decode the file and return <kbd>token</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping a client in added functionality and function composition</h1>
                </header>
            
            <article>
                
<p>In 2015, Tom√°s Senart gave an excellent talk on wrapping an <kbd>http.Client</kbd> struct with an interface, allowing you to take advantage of middleware and function composition. You can find out more on this at <a href="https://github.com/gophercon/2015-talks">https://github.com/gophercon/2015-talks</a>. This recipe takes from his ideas and demonstrates an example of doing the same to the <kbd>Transport</kbd> interface of the <kbd>http.Client</kbd> struct similar to our earlier recipe, <em>Writing a client for a REST API.</em></p>
<p>This recipe will implement a logging and basic auth middleware for a standard <kbd>http.Client</kbd> struct. It also includes a decorate function that can be used when you need to with a large variety of middleware.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Refer to the <em>Getting ready</em> section of the <em>Initializing, storing, and passing http.Client structs</em> recipe in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter6/decorator</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter6/decorator">https://github.com/agtorre/go-cookbook/tree/master/chapter6/decorator</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>config.go</kbd> with the following content:</li>
</ol>
<pre>
        package decorator<br/><br/>        import (<br/>            "log"<br/>            "net/http"<br/>            "os"<br/>        )<br/><br/>        // Setup initializes our ClientInterface<br/>        func Setup() *http.Client {<br/>            c := http.Client{}<br/><br/>            t := Decorate(&amp;http.Transport{},<br/>                Logger(log.New(os.Stdout, "", 0)),<br/>                BasicAuth("username", "password"),<br/>            )<br/>            c.Transport = t<br/>            return &amp;c<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>decorator.go</kbd> with the following content:</li>
</ol>
<pre>
        package decorator<br/><br/>        import "net/http"<br/><br/>        // TransportFunc implements the RountTripper interface<br/>        type TransportFunc func(*http.Request) (*http.Response, error)<br/><br/>        // RoundTrip just calls the original function<br/>        func (tf TransportFunc) RoundTrip(r *http.Request) <br/>        (*http.Response, error) {<br/>            return tf(r)<br/>        }<br/><br/>        // Decorator is a convenience function to represent our<br/>        // middleware inner function<br/>        type Decorator func(http.RoundTripper) http.RoundTripper<br/><br/>        // Decorate is a helper to wrap all the middleware<br/>        func Decorate(t http.RoundTripper, rts ...Decorator) <br/>        http.RoundTripper {<br/>            decorated := t<br/>            for _, rt := range rts {<br/>                decorated = rt(decorated)<br/>            }<br/>            return decorated<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>middleware.go</kbd> with the following content:</li>
</ol>
<pre>
        package decorator<br/><br/>        import (<br/>            "log"<br/>            "net/http"<br/>            "time"<br/>        )<br/><br/>        // Logger is one of our 'middleware' decorators<br/>        func Logger(l *log.Logger) Decorator {<br/>            return func(c http.RoundTripper) http.RoundTripper {<br/>                return TransportFunc(func(r *http.Request) <br/>                (*http.Response, error) {<br/>                   start := time.Now()<br/>                   l.Printf("started request to %s at %s", r.URL,     <br/>                   start.Format("2006-01-02 15:04:05"))<br/>                   resp, err := c.RoundTrip(r)<br/>                   l.Printf("completed request to %s in %s", r.URL, <br/>                   time.Since(start))<br/>                   return resp, err<br/>                })<br/>            }<br/>        }<br/><br/>        // BasicAuth is another of our 'middleware' decorators<br/>        func BasicAuth(username, password string) Decorator {<br/>            return func(c http.RoundTripper) http.RoundTripper {<br/>                return TransportFunc(func(r *http.Request) <br/>                (*http.Response, error) {<br/>                    r.SetBasicAuth(username, password)<br/>                    resp, err := c.RoundTrip(r)<br/>                    return resp, err<br/>                })<br/>            }<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>exec.go</kbd> with the following content:</li>
</ol>
<pre>
        package decorator<br/><br/>        import "fmt"<br/><br/>        // Exec creates a client, calls google.com<br/>        // then prints the response<br/>        func Exec() error {<br/>            c := Setup()<br/><br/>            resp, err := c.Get("https://www.google.com")<br/>            if err != nil {<br/>                return err<br/>            }<br/>            fmt.Println("Response code:", resp.StatusCode)<br/>            return nil<br/>        }
</pre>
<ol start="7">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>decorator</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import "github.com/agtorre/go-cookbook/chapter6/decorator"<br/><br/>        func main() {<br/>            if err := decorator.Exec(); err != nil {<br/>                panic(err)<br/>            }<br/>        }
</pre>
<ol start="9">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"/>
<p style="padding-left: 60px"><span>You sho</span>uld now see the following output:</p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      started request to https://www.google.com at 2017-01-01 13:38:42</strong><br/><strong>      completed request to https://www.google.com in 194.013054ms</strong><br/><strong>      Response code: 200</strong>
</pre>
<ol start="11">
<li><span>If y</span>ou copied or wrote <span>your own tests, go up one directory and run</span> <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe takes advantage of closures as first-class citizens and interfaces. The main trick that allows for this is having a function implement an interface. This allows us to wrap an interface implemented by a structure with an interface implemented by a function.</p>
<p>The <kbd>middleware.go</kbd> file contains two example client middleware functions. These could be extended to contain additional middleware, such as more sophisticated auth, metrics, and more. This recipe can also be combined with the previous recipe to produce an OAuth2 client that can be extended by additional middleware.</p>
<p>The <kbd>Decorator</kbd> function is a convenience function that allows the following:</p>
<pre>
Decorate(RoundTripper, Middleware1, Middleware2, etc)<br/><br/>vs<br/><br/>var t RoundTripper<br/>t = Middleware1(t)<br/>t = Middleware2(t)<br/>etc
</pre>
<p>The advantage of this approach compared to wrapping the client is that we can keep the interface sparse. If you want a fully featured client, you'd also need to implement methods such as <kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>PostForm</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding GRPC clients</h1>
                </header>
            
            <article>
                
<p>GRPC is a high performance RPC framework that is built using protocol buffers (<a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a>) and HTTP/2 (<a href="https://http2.github.io">https://http2.github.io</a>). Creating a GRPC client in Go has a lot of the same intricacies as working with Go HTTP clients. In order to demonstrate basic client usage, it's easiest to also implement a server. This recipe will create a <kbd>greeter</kbd> service, which takes a greeting and a name and returns the sentence <kbd>&lt;greeting&gt; &lt;name&gt;!</kbd>. In addition, the server can specify whether to exclaim <kbd>!</kbd> or not <kbd>.</kbd>.</p>
<p>This recipe won't explore some details about GRPC such as streaming, but will hopefully serve as an introduction to creating a very basic server and client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li><span>Refer to the <em>Getting ready</em> section of the</span> <em>Initializing, storing, and passing http.Client structs</em> recipe in this chapter.</li>
<li>Install GRPC at <a href="https://github.com/grpc/grpc/blob/master/INSTALL.md">https://github.com/grpc/grpc/blob/master/INSTALL.md</a>.</li>
<li><span class="s3">Run t</span>he <kbd>go get github.com/golang/protobuf/proto</kbd> command.</li>
<li>Run the <kbd>go get github.com/golang/protobuf/protoc-gen-go</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter6/grpc</kbd> directory.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter6/grpc">https://github.com/agtorre/go-cookbook/tree/master/chapter6/grpc</a> or use this as an exercise to write some of your own code.</li>
<li>Create a new directory named <kbd>greeter</kbd> and navigate to it.</li>
<li>Create a file called <kbd>greeter.proto</kbd> with the following content:</li>
</ol>
<pre>
        syntax = "proto3";<br/><br/>        package greeter;<br/><br/>        service GreeterService{<br/>            rpc Greet(GreetRequest) returns (GreetResponse) {}<br/>        }<br/><br/>        message GreetRequest {<br/>            string greeting = 1;<br/>            string name = 2;<br/>        }<br/><br/>        message GreetResponse{<br/>            string response = 1;<br/>        }
</pre>
<ol start="5">
<li>Run the following command:</li>
</ol>
<pre>
<strong>      protoc --go_out=plugins=grpc:. greeter.proto</strong>
</pre>
<ol start="6">
<li>Navigate back up a directory.</li>
<li>Create a new directory named <kbd>server</kbd> and navigate to it.</li>
<li>Create a file called <kbd>server.go</kbd> with the following content. <span>Ensure that you modify the <kbd>greeter</kbd> import to use the path you set up in step 3:</span></li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "net"<br/> <br/>            "github.com/agtorre/go-cookbook/chapter6/grpc/greeter"<br/>            "google.golang.org/grpc"<br/>        )<br/><br/>        func main() {<br/>            grpcServer := grpc.NewServer()<br/>            greeter.RegisterGreeterServiceServer(grpcServer, <br/>            &amp;Greeter{Exclaim: true})<br/>            lis, err := net.Listen("tcp", ":4444")<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            fmt.Println("Listening on port :4444")<br/>            grpcServer.Serve(lis)<br/>        }
</pre>
<ol start="9">
<li>Create a file called <kbd>greeter.go</kbd> with the following content. Ensure that you modify the <kbd>greeter</kbd> import to use the path you set up in step 3:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter6/grpc/greeter"<br/>            "golang.org/x/net/context"<br/>        )<br/><br/>        // Greeter implements the interface<br/>        // generated by protoc<br/>        type Greeter struct {<br/>            Exclaim bool<br/>        }<br/><br/>        // Greet implements grpc Greet<br/>        func (g *Greeter) Greet(ctx context.Context, r <br/>        *greeter.GreetRequest) (*greeter.GreetResponse, error) {<br/>            msg := fmt.Sprintf("%s %s", r.GetGreeting(), r.GetName())<br/>            if g.Exclaim {<br/>                msg += "!"<br/>            } else {<br/>                msg += "."<br/>            }<br/>            return &amp;greeter.GreetResponse{Response: msg}, nil<br/>        }
</pre>
<ol start="10">
<li>Navigate back up a directory.</li>
<li>Create a new directory named <kbd>client</kbd> and navigate to it.</li>
<li>Create a file called <kbd>client.go</kbd> with the following content. En<span>sure that you modify the</span> <kbd><span>greeter</span></kbd> <span>import to use the path you set up in step 3:</span></li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "context"<br/>            "fmt"<br/><br/>            "github.com/agtorre/go-cookbook/chapter6/grpc/greeter"<br/>            "google.golang.org/grpc"<br/>        )<br/><br/>        func main() {<br/>            conn, err := grpc.Dial(":4444", grpc.WithInsecure())<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            defer conn.Close()<br/><br/>            client := greeter.NewGreeterServiceClient(conn)<br/><br/>            ctx := context.Background()<br/>            req := greeter.GreetRequest{Greeting: "Hello", Name: <br/>            "Reader"}<br/>            resp, err := client.Greet(ctx, &amp;req)<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            fmt.Println(resp)<br/><br/>            req.Greeting = "Goodbye"<br/>            resp, err = client.Greet(ctx, &amp;req)<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            fmt.Println(resp)<br/>        }
</pre>
<ol start="13">
<li>Navigate back up a directory.</li>
<li>Run <kbd>go run server/server.go server/greeter.go</kbd>, and you will see the following output:</li>
</ol>
<pre>
<strong>      $ go run server/server.go server/greeter.go</strong><br/><strong>      Listening on port :4444</strong>
</pre>
<ol start="15">
<li>In a separate terminal, run <kbd>go run client/client.go</kbd> from the <kbd>grpc</kbd> directory, you will see the following output:</li>
</ol>
<pre>
<strong>      $ go run client/client.go</strong><br/><strong>      response:"Hello Reader!" </strong><br/><strong>      response:"Goodbye Reader!"</strong>
</pre>
<ol start="16">
<li><span>If you copied or wrote your own tests, go up one directory and r</span>un <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The GRPC server is set up to listen on port <kbd>4444</kbd>. Once the client connects, it can send requests and receive responses from the server. The structure of the requests, responses, and supported methods are dictated by the <kbd>.proto</kbd> file we created in step 4. In practice, when integrating against GRPC servers, they should provide the <kbd>.proto</kbd> file, which can be used to automatically generate a client.</p>
<p>In addition to the client, the <kbd>protoc</kbd> command generates the stubs for the server and all that's required is to fill in the implementation details. The generated Go code also has JSON tags and the same structs could be reused for JSON REST services. Our code sets up an insecure client. To handle GRPC securely, you need to use an SSL certificate.</p>
<p>¬†</p>


            </article>

            
        </section>
    </body></html>