- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Mocking using the standard library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库进行模拟
- en: Using the Mockgen package
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mockgen包
- en: Using table-driven tests to improve coverage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表格驱动测试来提高覆盖率
- en: Using third-party testing tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方测试工具
- en: Practical fuzzing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践模糊测试
- en: Behavior testing using Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go进行行为测试
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will be different from the previous chapters; this will focus on
    testing and testing methodologies. Go provides excellent testing support out of
    the box, however, it can be difficult to understand coming from more dynamic languages
    where monkey patching and mocking are relatively straightforward.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将与前面的章节不同；这将专注于测试和测试方法。Go提供了出色的测试支持，然而，对于来自更动态的语言（在这些语言中猴子补丁和模拟相对简单）的开发者来说，这可能很难理解。
- en: Go testing encourages a specific structure for your code, in particular, testing
    and mocking interfaces is very straightforward and well supported. Some types
    of code can be more difficult to test. For example, it can be difficult to test
    code that makes use of package-level global variables, places that have not been
    abstracted into interfaces, and structs that have non-exported variables or methods.
    This chapter will share some recipes for testing Go code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go测试鼓励代码采用特定的结构，特别是测试和模拟接口非常直接且支持良好。某些类型的代码可能更难测试。例如，测试使用包级全局变量、未抽象为接口的地方以及具有非导出变量或方法的结构的代码可能很困难。本章将分享一些测试Go代码的食谱。
- en: Mocking using the standard library
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准库进行模拟
- en: In Go, mocking typically means implementing an interface with a test version
    that allows you to control runtime behavior from tests. It may also refer to mocking
    functions and methods, for which we'll explore another trick in this recipe. This
    trick uses the `Patch` and `Restore` functions defined at [https://play.golang.org/p/oLF1XnRX3C](https://play.golang.org/p/oLF1XnRX3C).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，模拟通常意味着实现一个带有测试版本的接口，允许您从测试中控制运行时行为。它也可能指代模拟函数和方法，我们将在本食谱中探索另一个技巧。这个技巧使用了在[https://play.golang.org/p/oLF1XnRX3C](https://play.golang.org/p/oLF1XnRX3C)中定义的`Patch`和`Restore`函数。
- en: In general, it's better to compose code so that you can use interfaces frequently
    and the code is in small testable chunks. Code that contains lots of branching
    conditions or deeply nested logic can be tricky to test and tests tend to be more
    brittle at the end. This is because a developer will need to keep track of more
    mock objects, patches, return values, and states within their tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将代码组合起来以便频繁使用接口，并将代码分成小块进行测试会更好。包含大量分支条件或深层嵌套逻辑的代码可能很难测试，并且测试最终可能更脆弱。这是因为开发者需要在测试中跟踪更多的模拟对象、补丁、返回值和状态。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://golang.org/doc/install](https://golang.org/doc/install)下载并安装Go到您的操作系统上，并配置您的`GOPATH`环境变量。
- en: Open a terminal/console application.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端/控制台应用程序。
- en: Navigate to your `GOPATH/src` and create a project directory, for example, `$GOPATH/src/github.com/yourusername/customrepo`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您的`GOPATH/src`并创建一个项目目录，例如，`$GOPATH/src/github.com/yourusername/customrepo`。
- en: All code will be run and modified from this directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都将从这个目录运行和修改。
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，使用`go get github.com/agtorre/go-cookbook/`命令安装代码的最新测试版本。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These steps cover writing and running your application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter8/mocking` directory
    and navigate to it.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端/控制台应用程序中，创建`chapter8/mocking`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/mocking](https://github.com/agtorre/go-cookbook/tree/master/chapter8/mocking)
    or use this as an exercise to write some of your own code.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter8/mocking](https://github.com/agtorre/go-cookbook/tree/master/chapter8/mocking)复制测试或将其作为练习编写一些自己的代码。
- en: 'Create a file called `mock.go` with the following content:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mock.go`的文件，内容如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called `patch.go` with the following content:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`patch.go`的文件，内容如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec.go`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a file called `mock_test.go` with the following content:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mock_test.go`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a file called `exec_test.go` with the following content:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec_test.go`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Fill in tests for the remaining functions, go up one directory and run `go
    test`. Ensure that all the tests pass:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为剩余的函数填写测试，然后向上移动一个目录并运行`go test`。确保所有测试都通过：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe demonstrates how to mock interfaces as well as functions that have
    been declared as variables. There are also certain libraries that can mimic this
    patch/restore directly on declared functions, but they bypass a lot of Go''s type
    safety to accomplish that feat. If you need to patch functions from an external
    package, you may use the following trick:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱演示了如何模拟接口以及已声明为变量的函数。还有一些库可以直接在声明的函数上模拟这个补丁/恢复，但为了完成这个功能，它们绕过了Go的许多类型安全性。如果你需要从外部包中修补函数，你可以使用以下技巧：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For this recipe, we start by setting up our test and using table-driven tests.
    There's a lot of literature about this technique, and I recommend exploring it
    further. Once our tests are set up, we choose outputs for our mocked functions.
    In order to mock our interface, our mocked objects define closures that can be
    rewritten at runtime. The patch/restore technique is applied to change our global
    function and restore it after each loop. This is thanks to `t.Run`, which sets
    up a new function for each loop of the test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们首先设置测试并使用表格驱动测试。关于这种技术的文献有很多，我建议进一步探索。一旦我们的测试设置完成，我们就为模拟函数选择输出。为了模拟我们的接口，我们的模拟对象定义了可以在运行时重写的闭包。我们应用补丁/恢复技术来更改全局函数，并在每次循环后恢复它。这要归功于`t.Run`，它为测试的每个循环设置一个新的函数。
- en: Using the Mockgen package
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mockgen包
- en: The previous example used our custom mock objects. When you're working with
    a lot of interfaces, writing these can become cumbersome and error prone. This
    is a place where generating code makes a lot of sense. Fortunately, there's a
    package called `github.com/golang/mock/gomock` that provides a generation of mock
    objects and gives us a very useful library to use in conjunction with interface
    testing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了我们的自定义模拟对象。当你与许多接口一起工作时，编写这些对象可能会变得繁琐且容易出错。这是一个生成代码非常有意义的地方。幸运的是，有一个名为`github.com/golang/mock/gomock`的包，它提供了模拟对象的生成，并为我们提供了一个非常实用的库，可以与接口测试一起使用。
- en: This recipe will explore some of the functionality of `gomock` and will cover
    trade-offs on where, when, and how to work with and generate mock objects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将探索`gomock`的一些功能，并涵盖在哪里、何时以及如何与生成模拟对象一起工作的权衡。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Configure your environment according to these steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
    recipe of this chapter.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章“使用标准库进行模拟”食谱中的“准备就绪”部分。
- en: Run the `go get github.com/golang/mock/` command.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/golang/mock/`命令。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter8/mockgen` directory
    and navigate to it.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建`chapter8/mockgen`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/mockgen](https://github.com/agtorre/go-cookbook/tree/master/chapter8/mockgen)
    or use this as an exercise to write some of your own.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter8/mockgen](https://github.com/agtorre/go-cookbook/tree/master/chapter8/mockgen)复制测试或将其作为练习来编写你自己的测试。
- en: 'Create a file called `interface.go` with the following content:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`interface.go`的文件，内容如下：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a directory named `internal`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`internal`的目录。
- en: 'Run the `mockgen -destination internal/mocks.go -package internal github.com/agtorre/go-cookbook/chapter8/mockgen
    GetSetter` command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mockgen -destination internal/mocks.go -package internal github.com/agtorre/go-cookbook/chapter8/mockgen
    GetSetter`命令：
- en: Ensure that you replace the package path with your local version.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你将包路径替换为你的本地版本。
- en: This will create a file named `internal/mocks.go`.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将创建一个名为`internal/mocks.go`的文件。
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec.go`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a file called `interface_test.go` with the following content:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`interface_test.go`的文件，内容如下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a file called `exec_test.go` with the following content:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec_test.go`的文件，内容如下：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Fill in tests for the remaining functions, go up one directory, and run `go
    test`. Ensure that all the tests pass.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为剩余的函数填写测试，然后向上移动一个目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The generated mock objects allow tests to specify what arguments are expected,
    the number of times a function will be called, and what to return, and they allow
    us to set additional artifacts, for example, we could write to a channel directly
    if the original function had a similar workflow. The `interface_test.go` file
    showcases some examples of using mock objects while calling them in-line. Generally,
    tests will look more like `exec_test.go` where we'll want intercept interface
    function calls performed by our actual code and change their behavior at test
    time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模拟对象允许测试指定预期的参数，函数将被调用的次数，以及返回的内容，并且允许我们设置额外的工件，例如，如果原始函数有类似的流程，我们可以直接写入通道。`interface_test.go`文件展示了在调用时使用模拟对象的示例。通常，测试将看起来更像`exec_test.go`，我们将在其中拦截实际代码执行的接口函数调用并在测试时改变它们的行为。
- en: The `exec_test.go` file also showcases how you might use mocked objects in a
    table-driven test environment. The `Any()` function means that the mocked function
    can be called zero or more times, which is great for cases where the code terminates
    early.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec_test.go`文件还展示了如何在表格驱动测试环境中使用模拟对象。`Any()`函数意味着模拟函数可以被调用零次或多次，这对于代码提前终止的情况非常有用。'
- en: One last trick demonstrated in this recipe is sticking mocked objects into the
    `internal` package. This is useful when you need to mock functions declared in
    packages outside your own. This allows those methods to be defined in a `non _test.go`
    file, but doesn't allow to export them to users of your libraries. Generally,
    it's easier to just stick mocked objects into `_test.go` files using the same
    package name as the tests you're currently writing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中演示的最后一个技巧是将模拟对象放入`internal`包中。当你需要模拟你自己的包外声明的函数时，这很有用。这允许这些方法在非`_test.go`文件中定义，但不会允许将它们导出给库的用户。通常，直接将模拟对象放入与当前编写的测试相同的包名的`_test.go`文件中会更简单。
- en: Using table-driven tests to improve coverage
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表格驱动测试来提高覆盖率
- en: This recipe will demonstrate the process to write a table-driven test, collect
    test coverage, and improve it. It will also make use of the `github.com/cweill/gotests`
    package to generate tests. If you've been downloading the test code for other
    chapters, these should look very familiar. Using a combination of this recipe
    and the previous two, you should be able to achieve 100% test coverage in all
    cases with some work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将演示编写表格驱动测试、收集测试覆盖率并提高覆盖率的过程。它还将使用`github.com/cweill/gotests`包来生成测试。如果你已经下载了其他章节的测试代码，这些应该看起来非常熟悉。通过结合这个菜谱和前两个菜谱，你应该能够在所有情况下通过一些工作实现100%的测试覆盖率。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
    recipe of this chapter.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章“Mocking using the standard library”菜谱的“准备工作”部分。
- en: Run the `go get github.com/cweill/gotests/` command.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/cweill/gotests/`命令。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter8/coverage` directory
    and navigate to it.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端/控制台应用程序中，创建`chapter8/coverage`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/coverage](https://github.com/agtorre/go-cookbook/tree/master/chapter8/coverage)
    or use this as an exercise to write some of your own code.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter8/coverage](https://github.com/agtorre/go-cookbook/tree/master/chapter8/coverage)复制测试或将其用作练习编写一些你自己的代码。
- en: 'Create a file called `coverage.go` with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`coverage.go`的文件，其内容如下：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the `gotests -all -w` command.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`gotests -all -w`命令。
- en: 'This will generate a file named `coverage_test.go` with the following content:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成一个名为`coverage_test.go`的文件，其内容如下：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Fill in the `TODO` section with the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TODO`部分填写以下内容：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the `go test -cover` command, and you will see the following output:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go test -cover`命令，你将看到以下输出：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add another item to the `TODO` section:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TODO`部分添加另一个条目：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the `go test -cover` command, and you will see the following output:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go test -cover`命令，你将看到以下输出：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following commands:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the `coverage.html` file in a browser to see a graphical coverage report.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`coverage.html`文件以查看图形覆盖率报告。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `go test -cover` command comes with a basic Go installation. It can be used
    to collect a coverage report of your Go application. In addition, it has the ability
    to output coverage metrics and an HTML coverage report. This tool is often wrapped
    by other tools, which will be covered in the next recipe. These table-driven test
    styles are covered at [https://github.com/golang/go/wiki/TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests)
    and are an excellent way to make clean tests that can handle many cases without
    writing a bunch of extra code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test -cover`命令是基本Go安装的一部分。它可以用来收集Go应用程序的覆盖率报告。此外，它还具有输出覆盖率指标和HTML覆盖率报告的能力。这个工具通常被其他工具包装，将在下一个配方中介绍。这些基于表格的测试风格在[https://github.com/golang/go/wiki/TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests)中有介绍，是编写干净测试的极好方式，可以处理许多情况而无需编写大量额外的代码。'
- en: This recipe starts by automatically generating test code, then filling in test
    cases as needed to help create more coverage. The only time this is especially
    tricky is when you have non-variable functions or methods being invoked. For example,
    it can be tricky to make `gob.Encode()` return an error to increase test coverage.
    It can also seem quirky to use the method described in the *Mocking using the
    standard library* recipe of this chapter and use `var gobEncode = gob.Encode`
    to allow patching. For this reason, it can be difficult to advocate for 100% test
    coverage and instead argue for focusing on testing the external interface extensively,
    that is, testing many variations of input and output, and in some cases, as we'll
    see in the *Behavior testing using Go* recipe of this chapter, fuzzing can become
    useful.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方首先自动生成测试代码，然后根据需要填充测试用例，以帮助创建更多覆盖率。唯一特别棘手的时候是当你调用非变量函数或方法时。例如，让`gob.Encode()`返回错误以增加测试覆盖率可能很棘手。使用本章中*使用标准库进行模拟*配方中描述的方法，并使用`var
    gobEncode = gob.Encode`来允许修补，也可能显得有些奇怪。因此，很难主张100%的测试覆盖率，相反，可以主张重点测试外部接口，即测试许多输入和输出的变体，在某些情况下，正如我们在本章的*使用Go进行行为测试*配方中所看到的，模糊测试可能变得有用。
- en: Using third-party testing tools
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方测试工具
- en: There are a number of helpful tools for Go testing. Tools that make it easier
    to get an idea of code coverage at a per-function level, tools to do assertions
    to reduce testing lines of code, and test runners. This recipe will cover `github.com/axw/gocov`
    and `github.com/smartystreets/goconvey` packages to demonstrate some of this functionality.
    There are a number of other notable test frameworks depending on your needs. The
    `github.com/smartystreets/goconvey` package supports both assertions and is a
    test runner. It used to be the cleanest way to have labeled subtests prior to
    Go 1.7.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多有助于Go测试的工具。这些工具可以更容易地了解代码覆盖率，每个函数级别的工具，用于断言以减少测试代码行数，以及测试运行器。这个配方将涵盖`github.com/axw/gocov`和`github.com/smartystreets/goconvey`包，以展示一些这种功能。根据您的需求，还有许多其他值得注意的测试框架。`github.com/smartystreets/goconvey`包支持断言和测试运行器。在Go
    1.7之前，它曾经是拥有标记子测试的最干净的方式。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Configure your environment according to these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的环境：
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章*准备就绪*部分中的*使用标准库进行模拟*
- en: recipe of this chapter.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章的配方。
- en: Run the `go get github.com/axw/gocov` command.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/axw/gocov`命令。
- en: Run the `go get github.com/smartystreets/goconvey/` command.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/smartystreets/goconvey/`命令。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter8/tools` directory
    and navigate to it.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端/控制台应用程序中，创建`chapter8/tools`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/tools](https://github.com/agtorre/go-cookbook/tree/master/chapter8/tools)
    or use this as an exercise to write some of your own code.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter8/tools](https://github.com/agtorre/go-cookbook/tree/master/chapter8/tools)复制测试或将其用作练习来编写一些您自己的代码。
- en: 'Create a file called `funcs.go` with the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`funcs.go`的文件，内容如下：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a file called `structs.go` with the following content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`structs.go`的文件，内容如下：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a file called `funcs_test.go` with the following content:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`funcs_test.go`的文件，内容如下：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a file called `structs_test.go` with the following content:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`structs_test.go`的文件，内容如下：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the `gocov test | gocov report` command, and you will see the following
    output:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`gocov test | gocov report`命令，您将看到以下输出：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the `goconvey` command, and it will open a browser that should look like
    this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`goconvey`命令，它将打开一个看起来像这样的浏览器：
- en: '![](img/4ade351b-624e-4f0c-9f64-615cb799df68.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ade351b-624e-4f0c-9f64-615cb799df68.png)'
- en: Ensure that all the tests pass.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有测试都通过。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe demonstrates how to wire `goconvey` command into your tests. The
    `Convey` keyword basically replaces `t.Run` and adds additional labels in the
    `goconvey` web UI, but it behaves slightly differently. If you have nested convey
    blocks, they''re always re-executed in order, that is, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱演示了如何将`goconvey`命令连接到您的测试。`Convey`关键字基本上替换了`t.Run`并在`goconvey`网络UI中添加了额外的标签，但它的行为略有不同。如果您有嵌套的convey块，它们总是按顺序重新执行，即如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code, using `goconvey` command, will print `1`. If we would used
    the built-in `t.Run` instead, it would instead print `2`. In other words, Go `t.Run`
    tests are run sequentially and are never repeated. This behavior can be useful
    for putting the setup code in outer convey blocks, but it's important to remember
    this distinction if you have to work with both.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用`goconvey`命令的代码将打印`1`。如果我们使用内置的`t.Run`，它将打印`2`。换句话说，Go的`t.Run`测试是顺序执行的，并且永远不会重复。这种行为对于在外部convey块中放置设置代码很有用，但如果有必要同时使用两者，请记住这个区别。
- en: When using convey assertions, there's a check mark on successes in the UI and
    additional stats. It can also reduce the size of if checks to a single line and
    it's even possible to create custom assertions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用convey断言时，UI中的成功会有一个勾选标记，并且还有额外的统计数据。它还可以将if检查的长度减少到一行，甚至可以创建自定义断言。
- en: If you leave up the `goconvey` web interface and turn on notifications, as you
    save your code, tests will automatically be run and you'll receive notifications
    on any increase or decrease in coverage as well as when your build fails.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`goconvey`网络界面并开启通知，每次保存代码时，测试将自动运行，并且您将收到关于覆盖率增加或减少以及构建失败的通知。
- en: All three tools assertions, the test runner, and the web UI can be used independently
    or together.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种工具断言、测试运行器和网络UI都可以独立使用或一起使用。
- en: The `gocov` tool can be useful when working toward higher test coverage. It
    can quickly identify functions that are lacking in coverage and help you deep
    dive into your coverage report. In addition, `gocov` can be used to generate an
    alternate HTML report that is shipped with the Go code by using the `github.com/matm/gocov-html`
    package.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您努力提高测试覆盖率时，`gocov`工具非常有用。它可以快速识别缺乏覆盖率的函数，并帮助您深入了解覆盖率报告。此外，`gocov`可以通过使用`github.com/matm/gocov-html`包生成与Go代码一起分发的替代HTML报告。
- en: Practical fuzzing
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践模糊测试
- en: This recipe will explore fuzzing and how it can be used to help validate functions.
    In the *Currency conversions and float64 considerations* recipe from [Chapter
    3](1157db74-cc47-41c7-bed2-b3d0872397d6.xhtml), *Data Conversion and Composition*,
    we created a function that takes decimal US currency as a string and returns an
    int64 version representing cents. We'll modify that function and demonstrate finding
    a panic with fuzzing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将探讨模糊测试及其如何帮助验证函数。在[第3章](1157db74-cc47-41c7-bed2-b3d0872397d6.xhtml)的“货币转换和float64考虑”食谱中，我们在“数据转换和组合”中创建了一个函数，该函数接受作为字符串的十进制美国货币并返回表示美分的int64版本。我们将修改该函数并通过模糊测试演示如何找到panic。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Configure your environment according to these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
    recipe of this chapter.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章“使用标准库进行模拟”食谱中的“准备就绪”部分。
- en: Run the `go get github.com/dvyukov/go-fuzz/go-fuzz` command.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/dvyukov/go-fuzz/go-fuzz`命令。
- en: Run the `go get github.com/dvyukov/go-fuzz/go-fuzz-build` command.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/dvyukov/go-fuzz/go-fuzz-build`命令。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These steps cover writing and running your application:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter8/fuzz` directory
    and navigate to it.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端/控制台应用程序中，创建`chapter8/fuzz`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/fuzz](https://github.com/agtorre/go-cookbook/tree/master/chapter8/fuzz)
    or use this as an exercise to write some of your own code.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter8/fuzz](https://github.com/agtorre/go-cookbook/tree/master/chapter8/fuzz)
    复制测试，或者将其作为练习编写您自己的代码。
- en: 'Create a file called `dollars.go` with the following content:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dollars.go`的文件，内容如下：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a file called `fuzz.go` with the following content:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fuzz.go`的文件，内容如下：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the `go-fuzz-build github.com/agtorre/go-cookbook/chapter8/fuzz` command
    or change the path to match your own code.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go-fuzz-build github.com/agtorre/go-cookbook/chapter8/fuzz`命令或更改路径以匹配您的代码。
- en: 'Run the following commands:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the `go-fuzz -bin=./fuzz-fuzz.zip -workdir=output` command, and you will
    see the following output:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go-fuzz -bin=./fuzz-fuzz.zip -workdir=output`命令，你将看到以下输出：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exit by pressing *Ctrl* + *C* after a few iterations have been run.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行几次迭代后，通过按*Ctrl* + *C*退出。
- en: Fill in the tests for the remaining functions, go up one directory, and run
    the `go test`. Ensure that all the tests pass.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写剩余函数的测试，向上移动一个目录，并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `github.com/dvyukov/go-fuzz` package uses evolutionary algorithms to build
    a corpus of inputs in order to test Go code. In our case, we introduced an intentional
    panic in order to demonstrate the behavior when a crash is found. Fuzzing is a
    practical way to find unexpected panics, especially when doing programming handling
    array bounds or arbitrary input.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/dvyukov/go-fuzz`包使用进化算法构建输入语料库以测试Go代码。在我们的例子中，我们故意引入了panic，以演示找到崩溃时的行为。模糊测试是一种发现意外panic的实用方法，尤其是在处理数组边界或任意输入的编程中。'
- en: When fuzzing an application, on of the most difficult parts is writing an appropriate
    fuzz function. The `go-fuzz` application will adapt based on the responses from
    this function. If your fuzz function returns `1`, it considered a successful input.
    If `-1` is returned, the item will not be included in the corpus, and if `0` is
    returned, it's given lower priority. We can change the fuzz function in step 4
    to return `-1` instead of `0` in order to find interesting input that is accepted
    but that may not have been expected. For example, `+1` is a possible input for
    this function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在模糊测试一个应用程序时，最困难的部分之一是编写一个合适的模糊函数。`go-fuzz`应用程序将根据此函数的响应进行适应。如果你的模糊函数返回`1`，则被视为成功的输入。如果返回`-1`，则该条目将不会包含在语料库中，如果返回`0`，则给予较低优先级。我们可以通过在步骤4中更改模糊函数以返回`-1`而不是`0`来找到被接受但可能未预期的有趣输入。例如，`+1`是这个函数的可能输入。
- en: We also helped our fuzzer by suggesting some items to the corpus. These items
    were taken from our unit tests and represent known good values. This is important
    to help Go fuzz converge on relevant input, for example, if your function takes
    a range of integers as input, testing non-integer input can take a lot of time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过向语料库建议一些项目来帮助我们的fuzzer。这些项目来自我们的单元测试，代表已知的好值。这有助于Go模糊收敛到相关输入，例如，如果您的函数以整数范围作为输入，测试非整数输入可能需要很长时间。
- en: Behavior testing using Go
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go进行行为测试
- en: Behavior testing or integration testing is a good method of performing end-to-end
    black box testing. One popular framework for this type of testing is cucumber
    ([https://cucumber.io/](https://cucumber.io/)), which uses the Gherkin language
    to describe the steps to a test in English and then implement those steps in code.
    Go has a cucumber library as well (`github.com/DATA-DOG/godog`). This recipe will
    explore using `godog` package to write behavior tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 行为测试或集成测试是执行端到端黑盒测试的好方法。此类测试的一个流行框架是cucumber ([https://cucumber.io/](https://cucumber.io/))，它使用Gherkin语言用英语描述测试步骤，然后在代码中实现这些步骤。Go也有一个cucumber库（`github.com/DATA-DOG/godog`）。本食谱将探讨使用`godog`包编写行为测试。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考文档的*准备工作*部分。
- en: recipe of this chapter.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章的食谱。
- en: Run the `go get github.com/DATA-DOG/godog` command.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/DATA-DOG/godog`命令。
- en: Run the `go get github.com/DATA-DOG/godog/cmd/godog` command.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/DATA-DOG/godog/cmd/godog`命令。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter8/bdd` directory
    and navigate to it.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端/控制台应用程序中，创建`chapter8/bdd`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/bdd](https://github.com/agtorre/go-cookbook/tree/master/chapter8/bdd)
    or use this as an exercise to write some of your own code.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter8/bdd](https://github.com/agtorre/go-cookbook/tree/master/chapter8/bdd)复制测试或将其用作练习编写一些自己的代码。
- en: 'Create a file called `handler.go` with the following content:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `handler.go` 的文件，内容如下：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new directory called `features`, and create a file called `features/handler.go`
    with the following content:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `features` 的新目录，并创建一个名为 `features/handler.go` 的文件，内容如下：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the `godog` command, and you will see the following output:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `godog` 命令，你将看到以下输出：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should give you a skeleton to implement the tests that we wrote in our
    feature file; copy those into `handler_test.go` and implement the first two steps:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该为你提供了一个实现我们在特性文件中编写的测试的框架；将这些内容复制到 `handler_test.go` 中并实现前两个步骤：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the `godog` command, and you will see the following output:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `godog` 命令，你将看到以下输出：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Fill in the remaining two steps:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写剩余的两个步骤：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the `godog` command, and you will see the following output:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `godog` 命令，你将看到以下输出：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cucumber frameworks work excellently for pair programming, end-to-end testing,
    and any sort of testing that is best communicated with written instructions and
    is understandable for non-technical people. Once a step has been implemented,
    it's generally possible to reuse it wherever it's needed. If you want to test
    integrations between services, tests can be written to use actual HTTP clients
    if you first ensure that your environment is set up to receive HTTP connections.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 框架非常适合结对编程、端到端测试以及任何最好用书面指令进行沟通且对非技术人员可理解的测试类型。一旦某个步骤被实现，通常可以在需要的地方重用它。如果你想要测试服务之间的集成，可以编写使用实际
    HTTP 客户端的测试，前提是你首先确保你的环境已经设置好以接收 HTTP 连接。
- en: The datadog implementation of BDD is lacking a few features that you might expect
    if you've used other Cucumber frameworks, including lack of examples, passing
    a context between functions, and a number of other key words. However, it's a
    good start, and by using a few tricks in this recipe, such as globals for tracking
    state (and ensuring that you clean up those globals between scenarios), it's possible
    to build a fairly robust set of tests. The datadog testing package also uses a
    third-party test runner, so it's impossible to put it together with packages such
    as `gocov` or `go test -cover`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Datadog 对 BDD 的实现缺少一些你可能期望的功能，如果你使用过其他 Cucumber 框架，包括缺少示例、在函数间传递上下文以及许多其他关键字。然而，这是一个良好的开端，通过在这个菜谱中使用一些技巧，例如使用全局变量来跟踪状态（并确保在场景之间清理这些全局变量），可以构建一个相当健壮的测试集。Datadog
    测试包还使用第三方测试运行器，因此无法与 `gocov` 或 `go test -cover` 等包一起使用。
