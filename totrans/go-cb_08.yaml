- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking using the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Mockgen package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using table-driven tests to improve coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party testing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical fuzzing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior testing using Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be different from the previous chapters; this will focus on
    testing and testing methodologies. Go provides excellent testing support out of
    the box, however, it can be difficult to understand coming from more dynamic languages
    where monkey patching and mocking are relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Go testing encourages a specific structure for your code, in particular, testing
    and mocking interfaces is very straightforward and well supported. Some types
    of code can be more difficult to test. For example, it can be difficult to test
    code that makes use of package-level global variables, places that have not been
    abstracted into interfaces, and structs that have non-exported variables or methods.
    This chapter will share some recipes for testing Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking using the standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, mocking typically means implementing an interface with a test version
    that allows you to control runtime behavior from tests. It may also refer to mocking
    functions and methods, for which we'll explore another trick in this recipe. This
    trick uses the `Patch` and `Restore` functions defined at [https://play.golang.org/p/oLF1XnRX3C](https://play.golang.org/p/oLF1XnRX3C).
  prefs: []
  type: TYPE_NORMAL
- en: In general, it's better to compose code so that you can use interfaces frequently
    and the code is in small testable chunks. Code that contains lots of branching
    conditions or deeply nested logic can be tricky to test and tests tend to be more
    brittle at the end. This is because a developer will need to keep track of more
    mock objects, patches, return values, and states within their tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal/console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to your `GOPATH/src` and create a project directory, for example, `$GOPATH/src/github.com/yourusername/customrepo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All code will be run and modified from this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter8/mocking` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/mocking](https://github.com/agtorre/go-cookbook/tree/master/chapter8/mocking)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `mock.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `patch.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `mock_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill in tests for the remaining functions, go up one directory and run `go
    test`. Ensure that all the tests pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe demonstrates how to mock interfaces as well as functions that have
    been declared as variables. There are also certain libraries that can mimic this
    patch/restore directly on declared functions, but they bypass a lot of Go''s type
    safety to accomplish that feat. If you need to patch functions from an external
    package, you may use the following trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For this recipe, we start by setting up our test and using table-driven tests.
    There's a lot of literature about this technique, and I recommend exploring it
    further. Once our tests are set up, we choose outputs for our mocked functions.
    In order to mock our interface, our mocked objects define closures that can be
    rewritten at runtime. The patch/restore technique is applied to change our global
    function and restore it after each loop. This is thanks to `t.Run`, which sets
    up a new function for each loop of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Mockgen package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example used our custom mock objects. When you're working with
    a lot of interfaces, writing these can become cumbersome and error prone. This
    is a place where generating code makes a lot of sense. Fortunately, there's a
    package called `github.com/golang/mock/gomock` that provides a generation of mock
    objects and gives us a very useful library to use in conjunction with interface
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explore some of the functionality of `gomock` and will cover
    trade-offs on where, when, and how to work with and generate mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
    recipe of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/golang/mock/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter8/mockgen` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/mockgen](https://github.com/agtorre/go-cookbook/tree/master/chapter8/mockgen)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `interface.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Create a directory named `internal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `mockgen -destination internal/mocks.go -package internal github.com/agtorre/go-cookbook/chapter8/mockgen
    GetSetter` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you replace the package path with your local version.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This will create a file named `internal/mocks.go`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `interface_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Fill in tests for the remaining functions, go up one directory, and run `go
    test`. Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The generated mock objects allow tests to specify what arguments are expected,
    the number of times a function will be called, and what to return, and they allow
    us to set additional artifacts, for example, we could write to a channel directly
    if the original function had a similar workflow. The `interface_test.go` file
    showcases some examples of using mock objects while calling them in-line. Generally,
    tests will look more like `exec_test.go` where we'll want intercept interface
    function calls performed by our actual code and change their behavior at test
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The `exec_test.go` file also showcases how you might use mocked objects in a
    table-driven test environment. The `Any()` function means that the mocked function
    can be called zero or more times, which is great for cases where the code terminates
    early.
  prefs: []
  type: TYPE_NORMAL
- en: One last trick demonstrated in this recipe is sticking mocked objects into the
    `internal` package. This is useful when you need to mock functions declared in
    packages outside your own. This allows those methods to be defined in a `non _test.go`
    file, but doesn't allow to export them to users of your libraries. Generally,
    it's easier to just stick mocked objects into `_test.go` files using the same
    package name as the tests you're currently writing.
  prefs: []
  type: TYPE_NORMAL
- en: Using table-driven tests to improve coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate the process to write a table-driven test, collect
    test coverage, and improve it. It will also make use of the `github.com/cweill/gotests`
    package to generate tests. If you've been downloading the test code for other
    chapters, these should look very familiar. Using a combination of this recipe
    and the previous two, you should be able to achieve 100% test coverage in all
    cases with some work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
    recipe of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/cweill/gotests/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter8/coverage` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/coverage](https://github.com/agtorre/go-cookbook/tree/master/chapter8/coverage)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `coverage.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the `gotests -all -w` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will generate a file named `coverage_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill in the `TODO` section with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `go test -cover` command, and you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another item to the `TODO` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `go test -cover` command, and you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Open the `coverage.html` file in a browser to see a graphical coverage report.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go test -cover` command comes with a basic Go installation. It can be used
    to collect a coverage report of your Go application. In addition, it has the ability
    to output coverage metrics and an HTML coverage report. This tool is often wrapped
    by other tools, which will be covered in the next recipe. These table-driven test
    styles are covered at [https://github.com/golang/go/wiki/TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests)
    and are an excellent way to make clean tests that can handle many cases without
    writing a bunch of extra code.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe starts by automatically generating test code, then filling in test
    cases as needed to help create more coverage. The only time this is especially
    tricky is when you have non-variable functions or methods being invoked. For example,
    it can be tricky to make `gob.Encode()` return an error to increase test coverage.
    It can also seem quirky to use the method described in the *Mocking using the
    standard library* recipe of this chapter and use `var gobEncode = gob.Encode`
    to allow patching. For this reason, it can be difficult to advocate for 100% test
    coverage and instead argue for focusing on testing the external interface extensively,
    that is, testing many variations of input and output, and in some cases, as we'll
    see in the *Behavior testing using Go* recipe of this chapter, fuzzing can become
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of helpful tools for Go testing. Tools that make it easier
    to get an idea of code coverage at a per-function level, tools to do assertions
    to reduce testing lines of code, and test runners. This recipe will cover `github.com/axw/gocov`
    and `github.com/smartystreets/goconvey` packages to demonstrate some of this functionality.
    There are a number of other notable test frameworks depending on your needs. The
    `github.com/smartystreets/goconvey` package supports both assertions and is a
    test runner. It used to be the cleanest way to have labeled subtests prior to
    Go 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: recipe of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the `go get github.com/axw/gocov` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/smartystreets/goconvey/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter8/tools` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/tools](https://github.com/agtorre/go-cookbook/tree/master/chapter8/tools)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `funcs.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `structs.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `funcs_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `structs_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `gocov test | gocov report` command, and you will see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `goconvey` command, and it will open a browser that should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ade351b-624e-4f0c-9f64-615cb799df68.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe demonstrates how to wire `goconvey` command into your tests. The
    `Convey` keyword basically replaces `t.Run` and adds additional labels in the
    `goconvey` web UI, but it behaves slightly differently. If you have nested convey
    blocks, they''re always re-executed in order, that is, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code, using `goconvey` command, will print `1`. If we would used
    the built-in `t.Run` instead, it would instead print `2`. In other words, Go `t.Run`
    tests are run sequentially and are never repeated. This behavior can be useful
    for putting the setup code in outer convey blocks, but it's important to remember
    this distinction if you have to work with both.
  prefs: []
  type: TYPE_NORMAL
- en: When using convey assertions, there's a check mark on successes in the UI and
    additional stats. It can also reduce the size of if checks to a single line and
    it's even possible to create custom assertions.
  prefs: []
  type: TYPE_NORMAL
- en: If you leave up the `goconvey` web interface and turn on notifications, as you
    save your code, tests will automatically be run and you'll receive notifications
    on any increase or decrease in coverage as well as when your build fails.
  prefs: []
  type: TYPE_NORMAL
- en: All three tools assertions, the test runner, and the web UI can be used independently
    or together.
  prefs: []
  type: TYPE_NORMAL
- en: The `gocov` tool can be useful when working toward higher test coverage. It
    can quickly identify functions that are lacking in coverage and help you deep
    dive into your coverage report. In addition, `gocov` can be used to generate an
    alternate HTML report that is shipped with the Go code by using the `github.com/matm/gocov-html`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Practical fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will explore fuzzing and how it can be used to help validate functions.
    In the *Currency conversions and float64 considerations* recipe from [Chapter
    3](1157db74-cc47-41c7-bed2-b3d0872397d6.xhtml), *Data Conversion and Composition*,
    we created a function that takes decimal US currency as a string and returns an
    int64 version representing cents. We'll modify that function and demonstrate finding
    a panic with fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
    recipe of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/dvyukov/go-fuzz/go-fuzz` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/dvyukov/go-fuzz/go-fuzz-build` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter8/fuzz` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/fuzz](https://github.com/agtorre/go-cookbook/tree/master/chapter8/fuzz)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dollars.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `fuzz.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run the `go-fuzz-build github.com/agtorre/go-cookbook/chapter8/fuzz` command
    or change the path to match your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `go-fuzz -bin=./fuzz-fuzz.zip -workdir=output` command, and you will
    see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Exit by pressing *Ctrl* + *C* after a few iterations have been run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the tests for the remaining functions, go up one directory, and run
    the `go test`. Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `github.com/dvyukov/go-fuzz` package uses evolutionary algorithms to build
    a corpus of inputs in order to test Go code. In our case, we introduced an intentional
    panic in order to demonstrate the behavior when a crash is found. Fuzzing is a
    practical way to find unexpected panics, especially when doing programming handling
    array bounds or arbitrary input.
  prefs: []
  type: TYPE_NORMAL
- en: When fuzzing an application, on of the most difficult parts is writing an appropriate
    fuzz function. The `go-fuzz` application will adapt based on the responses from
    this function. If your fuzz function returns `1`, it considered a successful input.
    If `-1` is returned, the item will not be included in the corpus, and if `0` is
    returned, it's given lower priority. We can change the fuzz function in step 4
    to return `-1` instead of `0` in order to find interesting input that is accepted
    but that may not have been expected. For example, `+1` is a possible input for
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: We also helped our fuzzer by suggesting some items to the corpus. These items
    were taken from our unit tests and represent known good values. This is important
    to help Go fuzz converge on relevant input, for example, if your function takes
    a range of integers as input, testing non-integer input can take a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior testing using Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavior testing or integration testing is a good method of performing end-to-end
    black box testing. One popular framework for this type of testing is cucumber
    ([https://cucumber.io/](https://cucumber.io/)), which uses the Gherkin language
    to describe the steps to a test in English and then implement those steps in code.
    Go has a cucumber library as well (`github.com/DATA-DOG/godog`). This recipe will
    explore using `godog` package to write behavior tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Mocking using the standard library*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: recipe of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the `go get github.com/DATA-DOG/godog` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/DATA-DOG/godog/cmd/godog` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter8/bdd` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter8/bdd](https://github.com/agtorre/go-cookbook/tree/master/chapter8/bdd)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `handler.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new directory called `features`, and create a file called `features/handler.go`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `godog` command, and you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you a skeleton to implement the tests that we wrote in our
    feature file; copy those into `handler_test.go` and implement the first two steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `godog` command, and you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill in the remaining two steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `godog` command, and you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber frameworks work excellently for pair programming, end-to-end testing,
    and any sort of testing that is best communicated with written instructions and
    is understandable for non-technical people. Once a step has been implemented,
    it's generally possible to reuse it wherever it's needed. If you want to test
    integrations between services, tests can be written to use actual HTTP clients
    if you first ensure that your environment is set up to receive HTTP connections.
  prefs: []
  type: TYPE_NORMAL
- en: The datadog implementation of BDD is lacking a few features that you might expect
    if you've used other Cucumber frameworks, including lack of examples, passing
    a context between functions, and a number of other key words. However, it's a
    good start, and by using a few tricks in this recipe, such as globals for tracking
    state (and ensuring that you clean up those globals between scenarios), it's possible
    to build a fairly robust set of tests. The datadog testing package also uses a
    third-party test runner, so it's impossible to put it together with packages such
    as `gocov` or `go test -cover`.
  prefs: []
  type: TYPE_NORMAL
