["```go\n        package channels\n\n        import \"time\"\n\n        // Sender sends \"tick\"\" on ch until done is\n        // written to, then it sends \"sender done.\"\n        // and exits\n        func Sender(ch chan string, done chan bool) {\n            t := time.Tick(100 * time.Millisecond)\n            for {\n                select {\n                    case <-done:\n                        ch <- \"sender done.\"\n                        return\n                    case <-t:\n                        ch <- \"tick\"\n                }\n            }\n        }\n\n```", "```go\n        package channels\n\n        import (\n            \"context\"\n            \"fmt\"\n            \"time\"\n        )\n\n        // Printer will print anything sent on the ch chan\n        // and will print tock every 200 milliseconds\n        // this will repeat forever until a context is\n        // Done, i.e. timed out or cancelled\n        func Printer(ctx context.Context, ch chan string) {\n            t := time.Tick(200 * time.Millisecond)\n            for {\n                select {\n                  case <-ctx.Done():\n                      fmt.Println(\"printer done.\")\n                      return\n                  case res := <-ch:\n                      fmt.Println(res)\n                  case <-t:\n                      fmt.Println(\"tock\")\n                }\n            }\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"context\"\n            \"time\"\n\n            \"github.com/agtorre/go-cookbook/chapter9/channels\"\n        )\n\n        func main() {\n            ch := make(chan string)\n            done := make(chan bool)\n\n            ctx := context.Background()\n            ctx, cancel := context.WithCancel(ctx)\n            defer cancel()\n\n            go channels.Printer(ctx, ch)\n            go channels.Sender(ch, done)\n\n            time.Sleep(2 * time.Second)\n            done <- true\n            cancel()\n            //sleep a bit extra so channels can clean up\n            time.Sleep(1 * time.Second)\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n tick\n tock\n tick\n tick\n tock\n tick\n tick\n tock\n tick\n .\n .\n .\n sender done.\n printer done.\n\n```", "```go\nselect{\n    case <-time.Tick(200 * time.Millisecond):\n    //this resets whenever any other 'lane' is chosen\n}\n\n```", "```go\n        package waitgroup\n\n        import (\n            \"fmt\"\n            \"log\"\n            \"net/http\"\n            \"strings\"\n            \"time\"\n        )\n\n        // GetURL gets a url, and logs the time it took\n        func GetURL(url string) (*http.Response, error) {\n            start := time.Now()\n            log.Printf(\"getting %s\", url)\n            resp, err := http.Get(url)\n            log.Printf(\"completed getting %s in %s\", url, \n            time.Since(start))\n            return resp, err\n        }\n\n        // CrawlError is our custom error type\n        // for aggregating errors\n        type CrawlError struct {\n            Errors []string\n        }\n\n        // Add adds another error\n        func (c *CrawlError) Add(err error) {\n            c.Errors = append(c.Errors, err.Error())\n        }\n\n        // Error implements the error interface\n        func (c *CrawlError) Error() string {\n            return fmt.Sprintf(\"All Errors: %s\", strings.Join(c.Errors, \n            \",\"))\n        }\n\n        // Valid can be used to determine if\n        // we should return this\n        func (c *CrawlError) Valid() bool {\n            return len(c.Errors) != 0\n        }\n\n```", "```go\n        package waitgroup\n\n        import (\n            \"log\"\n            \"sync\"\n            \"time\"\n        )\n\n        // Crawl collects responses from a list of urls\n        // that are passed in. It waits for all requests\n        // to complete before returning.\n        func Crawl(sites []string) ([]int, error) {\n            start := time.Now()\n            log.Printf(\"starting crawling\")\n            wg := &sync.WaitGroup{}\n\n            var resps []int\n            cerr := &CrawlError{}\n            for _, v := range sites {\n                wg.Add(1)\n                go func(v string) {\n                    defer wg.Done()\n                    resp, err := GetURL(v)\n                    if err != nil {\n                        cerr.Add(err)\n                        return\n                    }\n                    resps = append(resps, resp.StatusCode)\n                }(v)\n            }\n            wg.Wait()\n            if cerr.Valid() {\n                return resps, cerr\n            }\n            log.Printf(\"completed crawling in %s\", time.Since(start))\n            return resps, nil\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/agtorre/go-cookbook/chapter9/waitgroup\"\n        )\n\n        func main() {\n            sites := []string{\n                \"https://golang.org\",\n                \"https://godoc.org\",\n                \"https://www.google.com/search?q=golang\",\n            }\n\n            resps, err := waitgroup.Crawl(sites)\n            if err != nil {\n                panic(err)\n            }\n            fmt.Println(\"Resps received:\", resps)\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n 2017/04/05 19:45:07 starting crawling\n 2017/04/05 19:45:07 getting https://www.google.com/search?\n      q=golang\n 2017/04/05 19:45:07 getting https://golang.org\n 2017/04/05 19:45:07 getting https://godoc.org\n 2017/04/05 19:45:07 completed getting https://golang.org in \n      178.22407ms\n 2017/04/05 19:45:07 completed getting https://godoc.org in \n      181.400873ms\n 2017/04/05 19:45:07 completed getting \n      https://www.google.com/search?q=golang in 238.019327ms\n 2017/04/05 19:45:07 completed crawling in 238.191791ms\n Resps received: [200 200 200]\n\n```", "```go\n        package atomic\n\n        import (\n            \"errors\"\n            \"sync\"\n        )\n\n        // SafeMap uses a mutex to allow\n        // getting and setting in a thread-safe way\n        type SafeMap struct {\n            m map[string]string\n            mu *sync.RWMutex\n        }\n\n        // NewSafeMap creates a SafeMap\n        func NewSafeMap() SafeMap {\n            return SafeMap{m: make(map[string]string), mu: \n            &sync.RWMutex{}}\n        }\n\n        // Set uses a write lock and sets the value given\n        // a key\n        func (t *SafeMap) Set(key, value string) {\n            t.mu.Lock()\n            defer t.mu.Unlock()\n\n            t.m[key] = value\n        }\n\n        // Get uses a RW lock and gets the value if it exists,\n        // otherwise an error is returned\n        func (t *SafeMap) Get(key string) (string, error) {\n            t.mu.RLock()\n            defer t.mu.RUnlock()\n\n            if v, ok := t.m[key]; ok {\n                return v, nil\n            }\n\n            return \"\", errors.New(\"key not found\")\n        }\n\n```", "```go\n        package atomic\n\n        import (\n            \"sync\"\n            \"sync/atomic\"\n        )\n\n        // Ordinal holds a global a value\n        // and can only be initialized once\n        type Ordinal struct {\n            ordinal uint64\n            once *sync.Once\n        }\n\n        // NewOrdinal returns ordinal with once\n        // setup\n        func NewOrdinal() *Ordinal {\n            return &Ordinal{once: &sync.Once{}}\n        }\n\n        // Init sets the ordinal value\n        // can only be done once\n        func (o *Ordinal) Init(val uint64) {\n            o.once.Do(func() {\n                atomic.StoreUint64(&o.ordinal, val)\n            })\n        }\n\n        // GetOrdinal will return the current\n        // ordinal\n        func (o *Ordinal) GetOrdinal() uint64 {\n            return atomic.LoadUint64(&o.ordinal)\n        }\n\n        // Increment will increment the current\n        // ordinal\n        func (o *Ordinal) Increment() {\n            atomic.AddUint64(&o.ordinal, 1)\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"sync\"\n\n            \"github.com/agtorre/go-cookbook/chapter9/atomic\"\n        )\n\n        func main() {\n            o := atomic.NewOrdinal()\n            m := atomic.NewSafeMap()\n            o.Init(1123)\n            fmt.Println(\"initial ordinal is:\", o.GetOrdinal())\n            wg := sync.WaitGroup{}\n            for i := 0; i < 10; i++ {\n                wg.Add(1)\n                go func(i int) {\n                    defer wg.Done()\n                    m.Set(fmt.Sprint(i), \"success\")\n                    o.Increment()\n                }(i)\n            }\n\n            wg.Wait()\n            for i := 0; i < 10; i++ {\n                v, err := m.Get(fmt.Sprint(i))\n                if err != nil || v != \"success\" {\n                    panic(err)\n                }\n            }\n            fmt.Println(\"final ordinal is:\", o.GetOrdinal())\n            fmt.Println(\"all keys found and marked as: 'success'\")\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n\n initial ordinal is: 1123\n final ordinal is: 1133\n all keys found and marked as: 'success'\n\n```", "```go\n        package context\n\n        import \"context\"\n\n        type key string\n\n        const (\n            timeoutKey key = \"TimeoutKey\"\n            deadlineKey key = \"DeadlineKey\"\n        )\n\n        // Setup sets some values\n        func Setup(ctx context.Context) context.Context {\n\n            ctx = context.WithValue(ctx, timeoutKey,\n            \"timeout exceeded\")\n            ctx = context.WithValue(ctx, deadlineKey,\n            \"deadline exceeded\")\n\n            return ctx\n        }\n\n        // GetValue grabs a value given a key and\n        // returns a string representation of the\n        // value\n        func GetValue(ctx context.Context, k key) string {\n\n            if val, ok := ctx.Value(k).(string); ok {\n                return val\n            }\n            return \"\"\n\n        }\n\n```", "```go\n        package context\n\n        import (\n            \"context\"\n            \"fmt\"\n            \"math/rand\"\n            \"time\"\n        )\n\n        // Exec sets two random timers and prints\n        // a different context value for whichever\n        // fires first\n        func Exec() {\n            // a base context\n            ctx := context.Background()\n            ctx = Setup(ctx)\n\n            rand.Seed(time.Now().UnixNano())\n\n            timeoutCtx, cancel := context.WithTimeout(ctx, \n            (time.Duration(rand.Intn(2)) * time.Millisecond))\n            defer cancel()\n\n            deadlineCtx, cancel := context.WithDeadline(ctx, \n            time.Now().Add(time.Duration(rand.Intn(2))\n            *time.Millisecond))\n            defer cancel()\n\n            for {\n                select {\n                    case <-timeoutCtx.Done():\n                    fmt.Println(GetValue(ctx, timeoutKey))\n                    return\n                    case <-deadlineCtx.Done():\n                        fmt.Println(GetValue(ctx, deadlineKey))\n                        return\n                }\n            }\n        }\n\n```", "```go\n        package main\n\n            import \"github.com/agtorre/go-cookbook/chapter9/context\"\n\n        func main() {\n            context.Exec()\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n timeout exceeded\n\n OR\n\n $ go run main.go\n deadline exceeded\n\n```", "```go\nfunc ModifyContext(ctx context.Context) context.Context\n\n```", "```go\n        package state\n\n        type op string\n\n        const (\n            // Add values\n            Add op = \"add\"\n            // Subtract values\n            Subtract = \"sub\"\n            // Multiply values\n            Multiply = \"mult\"\n            // Divide values\n            Divide = \"div\"\n        )\n\n        // WorkRequest perform an op\n        // on two values\n        type WorkRequest struct {\n            Operation op\n            Value1 int64\n            Value2 int64\n        }\n\n        // WorkResponse returns the result\n        // and any errors\n        type WorkResponse struct {\n            Wr *WorkRequest\n            Result int64\n            Err error\n        }\n\n```", "```go\n        package state\n\n        import \"context\"\n\n        // Processor routes work to Process\n        func Processor(ctx context.Context, in chan *WorkRequest, out \n        chan *WorkResponse) {\n            for {\n                select {\n                    case <-ctx.Done():\n                        return\n                    case wr := <-in:\n                        out <- Process(wr)\n                }\n            }\n        }\n\n```", "```go\n        package state\n\n        import \"errors\"\n\n        // Process switches on operation type\n        // Then does work\n        func Process(wr *WorkRequest) *WorkResponse {\n            resp := WorkResponse{Wr: wr}\n\n            switch wr.Operation {\n                case Add:\n                    resp.Result = wr.Value1 + wr.Value2\n                case Subtract:\n                    resp.Result = wr.Value1 - wr.Value2\n                case Multiply:\n                    resp.Result = wr.Value1 * wr.Value2\n                case Divide:\n                    if wr.Value2 == 0 {\n                        resp.Err = errors.New(\"divide by 0\")\n                        break\n                    }\n                    resp.Result = wr.Value1 / wr.Value2\n                    default:\n                        resp.Err = errors.New(\"unsupported operation\")\n            }\n            return &resp\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"context\"\n            \"fmt\"\n\n            \"github.com/agtorre/go-cookbook/chapter9/state\"\n        )\n\n        func main() {\n            in := make(chan *state.WorkRequest, 10)\n            out := make(chan *state.WorkResponse, 10)\n            ctx := context.Background()\n            ctx, cancel := context.WithCancel(ctx)\n            defer cancel()\n\n            go state.Processor(ctx, in, out)\n\n            req := state.WorkRequest{state.Add, 3, 4}\n            in <- &req\n\n            req2 := state.WorkRequest{state.Subtract, 5, 2}\n            in <- &req2\n\n            req3 := state.WorkRequest{state.Multiply, 9, 9}\n            in <- &req3\n\n            req4 := state.WorkRequest{state.Divide, 8, 2}\n            in <- &req4\n\n            req5 := state.WorkRequest{state.Divide, 8, 0}\n            in <- &req5\n\n            for i := 0; i < 5; i++ {\n                resp := <-out\n                fmt.Printf(\"Request: %v; Result: %v, Error: %vn\",\n                resp.Wr, resp.Result, resp.Err)\n            }\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n Request: &{add 3 4}; Result: 7, Error: <nil>\n Request: &{sub 5 2}; Result: 3, Error: <nil>\n Request: &{mult 9 9}; Result: 81, Error: <nil>\n Request: &{div 8 2}; Result: 4, Error: <nil>\n Request: &{div 8 0}; Result: 0, Error: divide by 0\n\n```", "```go\n        package pool\n\n        import (\n            \"context\"\n            \"fmt\"\n        )\n\n        // Dispatch creates numWorker workers, returns a cancel \n        // function channels for adding work and responses, \n        // cancel must be called\n        func Dispatch(numWorker int) (context.CancelFunc, chan \n        WorkRequest, chan WorkResponse) {\n            ctx := context.Background()\n            ctx, cancel := context.WithCancel(ctx)\n            in := make(chan WorkRequest, 10)\n            out := make(chan WorkResponse, 10)\n\n            for i := 0; i < numWorker; i++ {\n                go Worker(ctx, i, in, out)\n            }\n            return cancel, in, out\n        }\n\n        // Worker loops forever and is part of the worker pool\n        func Worker(ctx context.Context, id int, in chan WorkRequest, \n        out chan WorkResponse) {\n            for {\n                select {\n                    case <-ctx.Done():\n                        return\n                    case wr := <-in:\n                        fmt.Printf(\"worker id: %d, performing %s\n                        workn\", id, wr.Op)\n                        out <- Process(wr)\n                }\n            }\n        }\n\n```", "```go\n        package pool\n\n        import \"errors\"\n\n        type op string\n\n        const (\n            // Hash is the bcrypt work type\n            Hash op = \"encrypt\"\n            // Compare is bcrypt compare work\n            Compare = \"decrypt\"\n        )\n\n        // WorkRequest is a worker req\n        type WorkRequest struct {\n            Op op\n            Text []byte\n            Compare []byte // optional\n        }\n\n        // WorkResponse is a worker resp\n        type WorkResponse struct {\n            Wr WorkRequest\n            Result []byte\n            Matched bool\n            Err error\n        }\n\n        // Process dispatches work to the worker pool channel\n        func Process(wr WorkRequest) WorkResponse {\n            switch wr.Op {\n            case Hash:\n                return hashWork(wr)\n            case Compare:\n                return compareWork(wr)\n            default:\n                return WorkResponse{Err: errors.New(\"unsupported \n                operation\")}\n            }\n        }\n\n```", "```go\n        package pool\n\n        import \"golang.org/x/crypto/bcrypt\"\n\n        func hashWork(wr WorkRequest) WorkResponse {\n            val, err := bcrypt.GenerateFromPassword(wr.Text, \n            bcrypt.DefaultCost)\n            return WorkResponse{\n                Result: val,\n                Err: err,\n                Wr: wr,\n            }\n        }\n\n        func compareWork(wr WorkRequest) WorkResponse {\n            var matched bool\n            err := bcrypt.CompareHashAndPassword(wr.Compare, wr.Text)\n            if err == nil {\n                matched = true\n            }\n            return WorkResponse{\n                Matched: matched,\n                Err: err,\n                Wr: wr,\n            }\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/agtorre/go-cookbook/chapter9/pool\"\n        )\n\n        func main() {\n            cancel, in, out := pool.Dispatch(10)\n            defer cancel()\n\n            for i := 0; i < 10; i++ {\n                in <- pool.WorkRequest{Op: pool.Hash, Text: \n                []byte(fmt.Sprintf(\"messages %d\", i))}\n            }\n\n            for i := 0; i < 10; i++ {\n                res := <-out\n                if res.Err != nil {\n                    panic(res.Err)\n                }\n                in <- pool.WorkRequest{Op: pool.Compare, Text: \n                res.Wr.Text, Compare: res.Result}\n            }\n\n            for i := 0; i < 10; i++ {\n                res := <-out\n                if res.Err != nil {\n                    panic(res.Err)\n                }\n                fmt.Printf(\"string: \"%s\"; matched: %vn\", \n                string(res.Wr.Text), res.Matched)\n            }\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n worker id: 9, performing encrypt work\n worker id: 5, performing encrypt work\n worker id: 2, performing encrypt work\n worker id: 8, performing encrypt work\n worker id: 6, performing encrypt work\n worker id: 1, performing encrypt work\n worker id: 0, performing encrypt work\n worker id: 4, performing encrypt work\n worker id: 3, performing encrypt work\n worker id: 7, performing encrypt work\n worker id: 2, performing decrypt work\n worker id: 6, performing decrypt work\n worker id: 8, performing decrypt work\n worker id: 1, performing decrypt work\n worker id: 0, performing decrypt work\n worker id: 9, performing decrypt work\n worker id: 3, performing decrypt work\n worker id: 4, performing decrypt work\n worker id: 7, performing decrypt work\n worker id: 5, performing decrypt work\n string: \"messages 9\"; matched: true\n string: \"messages 3\"; matched: true\n string: \"messages 4\"; matched: true\n string: \"messages 0\"; matched: true\n string: \"messages 1\"; matched: true\n string: \"messages 8\"; matched: true\n string: \"messages 5\"; matched: true\n string: \"messages 7\"; matched: true\n string: \"messages 2\"; matched: true\n string: \"messages 6\"; matched: true\n\n```", "```go\n        package pipeline\n\n        import \"context\"\n\n        // Worker have one role\n        // that is determined when\n        // Work is called\n        type Worker struct {\n            in chan string\n            out chan string\n        }\n\n        // Job is a job a worker can do\n        type Job string\n\n        const (\n            // Print echo's all input to\n            // stdout\n            Print Job = \"print\"\n            // Encode base64 encodes input\n            Encode Job = \"encode\"\n        )\n\n        // Work is how to dispatch a worker, they are assigned\n        // a job here\n        func (w *Worker) Work(ctx context.Context, j Job) {\n            switch j {\n                case Print:\n                    w.Print(ctx)\n                case Encode:\n                    w.Encode(ctx)\n                default:\n                    return\n            }\n        }\n\n```", "```go\n        package pipeline\n\n        import (\n            \"context\"\n            \"fmt\"\n        )\n\n        // Print prints w.in and repalys it\n        // on w.out\n        func (w *Worker) Print(ctx context.Context) {\n            for {\n                select {\n                    case <-ctx.Done():\n                        return\n                    case val := <-w.in:\n                        fmt.Println(val)\n                        w.out <- val\n                }\n            }\n        }\n\n```", "```go\n        package pipeline\n\n        import (\n            \"context\"\n            \"encoding/base64\"\n            \"fmt\"\n        )\n\n        // Encode takes plain text as int\n        // and returns \"string => <base64 string encoding>\n        // as out\n        func (w *Worker) Encode(ctx context.Context) {\n            for {\n                select {\n                    case <-ctx.Done():\n                        return\n                    case val := <-w.in:\n                        w.out <- fmt.Sprintf(\"%s => %s\", val, \n                        base64.StdEncoding.EncodeToString([]byte(val)))\n                }\n            }\n        }\n\n```", "```go\n        package pipeline\n\n        import \"context\"\n\n        // NewPipeline initializes the workers and\n        // connects them, it returns the input of the pipeline\n        // and the final output\n        func NewPipeline(ctx context.Context, numEncoders, numPrinters \n        int) (chan string, chan string) {\n            inEncode := make(chan string, numEncoders)\n            inPrint := make(chan string, numPrinters)\n            outPrint := make(chan string, numPrinters)\n            for i := 0; i < numEncoders; i++ {\n                w := Worker{\n                    in: inEncode,\n                    out: inPrint,\n                }\n                go w.Work(ctx, Encode)\n            }\n\n            for i := 0; i < numPrinters; i++ {\n                w := Worker{\n                    in: inPrint,\n                   out: outPrint,\n                }\n                go w.Work(ctx, Print)\n            }\n            return inEncode, outPrint\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"context\"\n            \"fmt\"\n\n            \"github.com/agtorre/go-cookbook/chapter9/pipeline\"\n        )\n\n        func main() {\n            ctx := context.Background()\n            ctx, cancel := context.WithCancel(ctx)\n            defer cancel()\n\n            in, out := pipeline.NewPipeline(ctx, 10, 2)\n\n            go func() {\n                for i := 0; i < 20; i++ {\n                    in <- fmt.Sprint(\"Message\", i)\n                }\n            }()\n\n            for i := 0; i < 20; i++ {\n                <-out\n            }\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n Message3 => TWVzc2FnZTM=\n Message7 => TWVzc2FnZTc=\n Message8 => TWVzc2FnZTg=\n Message9 => TWVzc2FnZTk=\n Message5 => TWVzc2FnZTU=\n Message11 => TWVzc2FnZTEx\n Message10 => TWVzc2FnZTEw\n Message4 => TWVzc2FnZTQ=\n Message12 => TWVzc2FnZTEy\n Message6 => TWVzc2FnZTY=\n Message14 => TWVzc2FnZTE0\n Message13 => TWVzc2FnZTEz\n Message0 => TWVzc2FnZTA=\n Message15 => TWVzc2FnZTE1\n Message1 => TWVzc2FnZTE=\n Message17 => TWVzc2FnZTE3\n Message16 => TWVzc2FnZTE2\n Message19 => TWVzc2FnZTE5\n Message18 => TWVzc2FnZTE4\n Message2 => TWVzc2FnZTI=\n\n```"]