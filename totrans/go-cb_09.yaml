- en: Parallelism and Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using channels and the select statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing async operations with sync.WaitGroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic operations and mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the context package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing state management for channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the worker pool design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using workers to create pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers worker pools, wait groups for async operations, and the
    use of the `context` package. Parallelism and concurrency are some of the most
    advertised and promoted features of the Go language. This chapter will offer a
    number of useful patterns to get you started and help you understand these features.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides primitives that make parallel applications possible. Goroutines
    allow any function to become asynchronous and concurrent. Channels allow an application
    to set up communication with goroutines. One of the famous sayings in Go is *Do
    not communicate by sharing memory; instead, share memory by communicating* from
    [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating).
  prefs: []
  type: TYPE_NORMAL
- en: Using channels and the select statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go channels, in combination with goroutines, are first-class citizens for asynchronous
    communication. Channels become especially powerful when using select statements.
    These statements allow a goroutine to intelligently handle requests from multiple
    channels at once.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal/console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `GOPATH/src` and create a project directory, such as `$GOPATH/src/github.com/yourusername/customrepo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All code will be run and modified from this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter9/channels` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/channels](https://github.com/agtorre/go-cookbook/tree/master/chapter9/channels)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `sender.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `printer.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content and ensure that you
    modify the `channels` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates two ways to launch a worker process that either reads
    or writes to a channel, and may potentially do both. The terminate conditions
    are a `done` channel, or by using a `context` package. The *Using the context
    package* recipe will cover the context in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` package is used to wire together the separate functions; thanks to
    this, it is possible to set up multiple pairs as long as the channels are not
    shared. In addition, it's possible to have multiple goroutines listening on the
    same channel, as we'll explore in the *Using the worker pool design pattern* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, due to the asynchronous nature of goroutines, it can be tricky to establish
    cleanup and terminate conditions; for example, a common mistake is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By putting the tick in the `select` statement, it's possible to prevent this
    case from ever occurring. There's also no simple way to prioritize traffic in
    a `select` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Performing async operations with sync.WaitGroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is useful to perform a number of operations asynchronously, then
    wait till they complete before moving on. For example, if an operation requires
    pulling information from multiple APIs and aggregate that information, it can
    be helpful to make those client requests asynchronously. This chapter will explore
    using `sync.WaitGroup` to orchestrate non-dependent tasks in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`chapter9/waitgroup` directory and navigate to it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/waitgroup](https://github.com/agtorre/go-cookbook/tree/master/chapter9/waitgroup)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `tasks.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `process.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `waitgroup` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to use `waitgroups` as a synchronization mechanism when
    waiting for work. In essence, `waitgroup.Wait()` will wait until its internal
    counter has reached `0`. The `waitgroup.Add(int)` method will increment the counter
    by the amount entered, and `waitgroup.Done()` will decrement the counter by `1`.
    Because of this, it is necessary to asynchronously `Wait()` while the various
    goroutines mark the `waitgroup` as `Done()`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we increment before dispatching each HTTP request and then call
    a defer `wg.Done()` method, so that we can decrement whenever the goroutine terminates.
    We then wait for all goroutines to finish before returning our aggregated results.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it's better to use channels for passing the error and responses
    around.
  prefs: []
  type: TYPE_NORMAL
- en: When performing operations asynchronously like this, you should consider thread
    safety for things such as modifying a shared map. If you keep this in mind, `waitgroups`
    are a useful feature for waiting on any kind of asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Using atomic operations and mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a language like Go, where you have build in asynchronous operations and parallelism,
    it becomes important to consider things such as thread safety. For example, it
    is dangerous to access a map from multiple goroutines simultaneously. Go provides
    a number of helpers in the `sync` and `sync/atomic` packages to make sure that
    certain events occur only once or that goroutines can serialize on an operation.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will demonstrate the use of these packages to safely modify a map
    with various goroutines and to keep a global ordinal value that can be safely
    accessed by numerous goroutines. It will also showcase the `Once.Do` method, which
    can be used to ensure that something is only done by a Go application once, such
    as reading a config or initializing a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter9/atomic` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/atomic](https://github.com/agtorre/go-cookbook/tree/master/chapter9/atomic)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `map.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `ordinal.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content and ensure that you
    modify the `atomic` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our map recipe, we used a `ReadWrite` mutex. The idea behind this mutex
    is that any number of readers can acquire a read lock, but only one writer can
    acquire a write lock. Additionally, a writer cannot acquire a lock when anyone
    else (reader or writer) has one. This is useful because reads are very fast and
    non-blocking when compared to a standard mutex. Whenever we want to set data,
    we use `Lock()` object and whenever we want to read data we use `RLock()`. It
    is critical that you use `Unlock()` or `RUnlock()` eventually so that you don't
    deadlock your application. A defer `Unlock()` object can be useful, but may be
    slower than calling `Unlock()` manually.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern may not be flexible enough when you want to group additional actions
    with the locked value. For example, in some cases, you may want to lock, do some
    additional processing, and only after you've completed this will you unlock. It's
    important to consider this for your designs.
  prefs: []
  type: TYPE_NORMAL
- en: The `sync/atmoic` package is used by `Ordinal` to get and set values. There
    are also atomic comparison operations such as `atomic.CompareAndSwapUInt64()`,
    which are extremely valuable. This recipe allows Init to be called on an `Ordinal`
    object only once; otherwise, it can only be incremented and does so atomically.
  prefs: []
  type: TYPE_NORMAL
- en: We loop and create 10 goroutines (synchronizing with `sync.Waitgroup`) and show
    that the ordinal correctly incremented 10 times and that every key in our map
    was appropriately set.
  prefs: []
  type: TYPE_NORMAL
- en: Using the context package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several recipes throughout this book make use of the `context` package. This
    recipe will explore the basics of creating and managing contexts. A good reference
    for understanding context is [https://blog.golang.org/context](https://blog.golang.org/context).
    Since this blog post was written, context moved from `net/context` to a package
    called `context`. This still occasionally causes problems when interacting with
    third-party libraries such as GRPC.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explore setting and getting values for contexts, cancelation,
    and timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter9/context` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/context](https://github.com/agtorre/go-cookbook/tree/master/chapter9/context)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `values.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `context` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with context values, it's good to create a new type to represent
    the key. In this case, we created a `key` type, then declared some corresponding
    `const` values to represent all of our possible keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we initialize all our key/value pairs at the same time using
    the `Setup()` function. When modifying contexts, functions generally take a `context`
    argument and return a `context` value. So the signature often looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, these methods also return an error or `cancel()` function, such as
    in the cases of `context.WithCancel`, `context.WithTimeout`, and `context.WithDeadline`.
    All child contexts inherit the attributes of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we create two child contexts, one with a deadline and one with
    a timeout. We set these to timeout to be random ranges, then terminate when either
    is received. Lastly, we extract a value given a set key and print it.
  prefs: []
  type: TYPE_NORMAL
- en: Executing state management for channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Channels can be any type in Go. A channel of structs allows you to pass a lot
    of state with a single message. This recipe will explore using of channels to
    pass around complex request structs and return their results in complex response
    structs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, *Using the worker pool design pattern*, the value of this
    becomes even more apparent as you can create general purpose workers capable of
    performing a variety of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create and navigate to the `chapter9/state`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/state](https://github.com/agtorre/go-cookbook/tree/master/chapter9/state)
    or [use this as an exercise to write some of your own code.](https://github.com/agtorre/go-cookbook/tree/master/chapter9/state)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `state.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `processor.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `process.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `state` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Processor()` function in this recipe is a function that loops forever until
    its context is canceled, either through explicit calls to cancel or via timeout.
    It dispatches all work to `Process()`, which can handle different functions given
    various operations. It would also be possible to have each of these cases dispatch
    another function for even more modular code.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the response is returned to a response channel, and we loop over
    and print all the results at the very end. We also demonstrate an error case in
    the divide by `0` example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the worker pool design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worker pool design pattern is one where you dispatch long-running goroutines
    as workers. These workers can process a variety of work either using multiple
    channels or by using a stateful request struct that specifies the type as described
    in the preceding recipe.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will create stateful workers and demonstrate how to coordinate and
    spin up multiple workers all handling requests concurrently on the same channel.
    These workers will be crypto workers like in a web authentication app. Their purpose
    will be to hash plain text strings using `bcrypt` package and compare a text password
    against a hash.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter9/pool` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/pool](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pool)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `worker.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `work.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `crypto.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `state` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses the `Dispatch()` method to create a number of workers on a
    single input channel, output channel, and those attached to a single `cancel()`
    function. This can be used if you want to make different pools for different purposes.
    For example, you can create 10 crypto and 20 compare workers by using separate
    pools. For this recipe, we use a single pool, send hash requests to the workers,
    retrieve the responses, and then send compare requests to the same pool. Because
    of this, the worker performing the work will be different each time, but they're
    all capable of performing either type of work.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage to this approach is that both allow for parallelism and can also
    control the maximum concurrency. Bounding the maximum number of goroutines can
    also be important for limiting memory. I chose crypto for this recipe because
    crypto is a good example of code that can overwhelm your CPU or memory if you
    spin up a new goroutine for every new request, for example in a web service.
  prefs: []
  type: TYPE_NORMAL
- en: Using workers to create pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates creating groups of worker pools and connecting them
    together to form a pipeline. For this recipe, we link together two pools, but
    the pattern can be used for much more complex operations similar to middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Worker pools can be useful to keep workers relatively simple and to also further
    control concurrency. For example, it may be useful to serialize logging while
    parallelizing other operations. This may also be useful to have a smaller pool
    for more expensive operations, so you don't overload machine resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter9/pipeline` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline)
    or [use this as an exercise to write some of your own code.](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `worker.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `print.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `encode.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `pipeline.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content and ensure that you
    modify the `state` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` package creates a pipeline consisting of 10 encoders and two printers.
    It enqueues 20 strings on the in channel and waits for 20 responses on the out
    channel. If messages reach the out channel, it indicates that they've gone through
    the entire pipeline successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The `NewPipeline` function is used to wire up the pools. It ensures that the
    channels are created with the proper buffered sizes and that the output channels
    of some pools are connected to the appropriate input channels of other pools.
    It's also possible to fan out the pipeline by using an array of in channels and
    an array of out channels on each worker, multiple named channels, or maps of channels.
    This would allow for things such as sending messages to a logger at each step.
  prefs: []
  type: TYPE_NORMAL
