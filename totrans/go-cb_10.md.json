["```go\n        package discovery\n\n        import \"github.com/hashicorp/consul/api\"\n\n        // Client exposes api methods we care\n        // about\n        type Client interface {\n            Register(tags []string) error\n            Service(service, tag string) ([]*api.ServiceEntry,  \n            *api.QueryMeta, error)\n        }\n\n        type client struct {\n            client *api.Client\n            address string\n            name string\n            port int\n        }\n\n        //NewClient iniitalizes a consul client\n        func NewClient(config *api.Config, address, name string, port         \n        int) (Client, error) {\n            c, err := api.NewClient(config)\n            if err != nil {\n                return nil, err\n            }\n            cli := &client{\n                client: c,\n                name: name,\n                address: address,\n                port: port,\n            }\n            return cli, nil\n        }\n\n```", "```go\n        package discovery\n\n        import \"github.com/hashicorp/consul/api\"\n\n        // Register adds our service to consul\n        func (c *client) Register(tags []string) error {\n            reg := &api.AgentServiceRegistration{\n                ID: c.name,\n                Name: c.name,\n                Port: c.port,\n                Address: c.address,\n                Tags: tags,\n            }\n            return c.client.Agent().ServiceRegister(reg)\n        }\n\n        // Service return a service\n        func (c *client) Service(service, tag string) \n        ([]*api.ServiceEntry, *api.QueryMeta, error) {\n            return c.client.Health().Service(service, tag, false, \n            nil)\n        }\n\n```", "```go\n        package discovery\n\n        import (\n            \"fmt\"\n\n            consul \"github.com/hashicorp/consul/api\"\n        )\n\n        // Exec creates a consul entry then queries it\n        func Exec() error {\n            config := consul.DefaultConfig()\n            config.Address = \"localhost:8500\"\n            name := \"discovery\"\n\n            // faked name and port for example\n            cli, err := NewClient(config, \"localhost\", name, 8080)\n            if err != nil {\n                return err\n            }\n\n            if err := cli.Register([]string{\"Go\", \"Awesome\"}); err !=   \n            nil {\n                return err\n            }\n\n            entries, _, err := cli.Service(name, \"Go\")\n            if err != nil {\n                return err\n            }\n            for _, entry := range entries {\n                fmt.Printf(\"%#v\\n\", entry.Service)\n            }\n\n            return nil\n        }\n\n```", "```go\n        package main\n\n        import \"github.com/agtorre/go-cookbook/chapter10/discovery\"\n\n        func main() {\n            if err := discovery.Exec(); err != nil {\n                panic(err)\n            }\n        }\n\n```", "```go\n      go build\n      ./example\n\n```", "```go\n $ go run main.go\n &api.AgentService{ID:\"discovery\", Service:\"discovery\", Tags:    \n      []string{\"Go\", \"Awesome\"}, Port:8080, Address:\"localhost\",     \n      EnableTagOverride:false, CreateIndex:0x23, ModifyIndex:0x23}\n\n```", "```go\n        package consensus\n\n        type state string\n\n        const (\n            first state = \"first\"\n            second = \"second\"\n            third = \"third\"\n        )\n\n        var allowedState map[state][]state\n\n        func init() {\n            // setup valid states\n            allowedState = make(map[state][]state)\n            allowedState[first] = []state{second, third}\n            allowedState[second] = []state{third}\n            allowedState[third] = []state{first}\n        }\n\n        // CanTransition checks if a new state is valid\n        func (s *state) CanTransition(next state) bool {\n            for _, n := range allowedState[*s] {\n                if n == next {\n                    return true\n                }\n            }\n            return false\n        }\n\n        // Transition will move a state to the next\n        // state if able\n        func (s *state) Transition(next state) {\n            if s.CanTransition(next) {\n                *s = next\n            }\n        }\n\n```", "```go\n        package consensus\n\n        import \"github.com/hashicorp/raft\"\n\n        var rafts map[string]*raft.Raft\n\n        func init() {\n            rafts = make(map[string]*raft.Raft)\n        }\n\n        // Config creates num in-memory raft\n        // nodes and connects them\n        func Config(num int) {\n            conf := raft.DefaultConfig()\n            snapshotStore := raft.NewDiscardSnapshotStore()\n\n            addrs := []string{}\n            transports := []*raft.InmemTransport{}\n            for i := 0; i < num; i++ {\n                addr, transport := raft.NewInmemTransport(\"\")\n                addrs = append(addrs, addr)\n                transports = append(transports, transport)\n            }\n            peerStore := &raft.StaticPeers{StaticPeers: addrs}\n            memstore := raft.NewInmemStore()\n\n            for i := 0; i < num; i++ {\n                for j := 0; j < num; j++ {\n                    if i != j {\n                        transports[i].Connect(addrs[j], transports[j])\n                    }\n                }\n\n                r, err := raft.NewRaft(conf, NewFSM(), memstore, \n                memstore, snapshotStore, peerStore, transports[i])\n                if err != nil {\n                    panic(err)\n                }\n                r.SetPeers(addrs)\n                rafts[addrs[i]] = r\n            }\n        }\n\n```", "```go\n        package consensus\n\n        import (\n            \"io\"\n\n            \"github.com/hashicorp/raft\"\n        )\n\n        // FSM implements the raft FSM interface\n        // and holds a state\n        type FSM struct {\n            state state\n        }\n\n        // NewFSM creates a new FSM with\n        // start state of \"first\"\n        func NewFSM() *FSM {\n            return &FSM{state: first}\n        }\n\n        // Apply updates our FSM\n        func (f *FSM) Apply(r *raft.Log) interface{} {\n            f.state.Transition(state(r.Data))\n            return string(f.state)\n        }\n\n        // Snapshot needed to satisfy the raft FSM interface\n        func (f *FSM) Snapshot() (raft.FSMSnapshot, error) {\n            return nil, nil\n        }\n\n        // Restore needed to satisfy the raft FSM interface\n        func (f *FSM) Restore(io.ReadCloser) error {\n            return nil\n        }\n\n```", "```go\n        package consensus\n\n        import (\n            \"net/http\"\n            \"time\"\n        )\n\n        // Handler grabs the get param ?next= and tries\n        // to transition to the state contained there\n        func Handler(w http.ResponseWriter, r *http.Request) {\n            r.ParseForm()\n            for k, rf := range rafts {\n                if k == rf.Leader() {\n                    state := r.FormValue(\"next\")\n                    result := rf.Apply([]byte(state), 1*time.Second)\n                    if result.Error() != nil {\n                        w.WriteHeader(http.StatusBadRequest)\n                        return\n                    }\n                    newState, ok := result.Response().(string)\n                    if !ok {\n                        w.WriteHeader(http.StatusInternalServerError)\n                        return\n                    }\n\n                    if newState != state {\n                        w.WriteHeader(http.StatusBadRequest)\n                        w.Write([]byte(\"invalid transition\"))\n                        return\n                    }\n                    w.WriteHeader(http.StatusOK)\n                    w.Write([]byte(result.Response().(string)))\n                    return\n                }\n            }\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            \"github.com/agtorre/go-cookbook/chapter10/consensus\"\n        )\n\n        func main() {\n            consensus.Config(3)\n\n            http.HandleFunc(\"/\", consensus.Handler)\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n\n```", "```go\n go build\n ./example\n\n```", "```go\n $ go run main.go\n 2017/04/23 16:49:24 [INFO] raft: Node at 95c86c4c-9192-a8a6-  \n      5e38-66c033bb3955 [Follower] entering Follower state (Leader:   \n      \"\")\n 2017/04/23 16:49:24 [INFO] raft: Node at 2406e36b-7e3e-0965- \n      8863-70a5dc1a2e69 [Follower] entering Follower state (Leader: \n      \"\")\n 2017/04/23 16:49:24 [INFO] raft: Node at 2b5367e6-eea6-e195-  \n      df40-1aeebfe8cdc7 [Follower] entering Follower state (Leader:   \n      \"\")\n 2017/04/23 16:49:25 [WARN] raft: Heartbeat timeout from \"\"   \n      reached, starting election\n 2017/04/23 16:49:25 [INFO] raft: Node at 2406e36b-7e3e-0965-  \n      8863-70a5dc1a2e69 [Candidate] entering Candidate state\n 2017/04/23 16:49:25 [DEBUG] raft: Votes needed: 2\n 2017/04/23 16:49:25 [DEBUG] raft: Vote granted from 2406e36b-\n      7e3e-0965-8863-70a5dc1a2e69\\. Tally: 1\n 2017/04/23 16:49:25 [DEBUG] raft: Vote granted from 95c86c4c-  \n      9192-a8a6-5e38-66c033bb3955\\. Tally: 2\n 2017/04/23 16:49:25 [INFO] raft: Election won. Tally: 2\n 2017/04/23 16:49:25 [INFO] raft: Node at 2406e36b-7e3e-0965-  \n      8863-70a5dc1a2e69 [Leader] entering Leader state\n 2017/04/23 16:49:25 [INFO] raft: pipelining replication to peer   \n      95c86c4c-9192-a8a6-5e38-66c033bb3955\n 2017/04/23 16:49:25 [INFO] raft: pipelining replication to peer   \n      2b5367e6-eea6-e195-df40-1aeebfe8cdc7\n 2017/04/23 16:49:25 [DEBUG] raft: Node 2406e36b-7e3e-0965-8863- \n      70a5dc1a2e69 updated peer set (2): [2406e36b-7e3e-0965-8863- \n      70a5dc1a2e69 95c86c4c-9192-a8a6-5e38-66c033bb3955 2b5367e6-\n      eea6-e195-df40-1aeebfe8cdc7]\n 2017/04/23 16:49:25 [DEBUG] raft: Node 95c86c4c-9192-a8a6-5e38-  \n      66c033bb3955 updated peer set (2): [2406e36b-7e3e-0965-8863-  \n      70a5dc1a2e69 95c86c4c-9192-a8a6-5e38-66c033bb3955 2b5367e6-\n      eea6-e195-df40-1aeebfe8cdc7]\n 2017/04/23 16:49:25 [DEBUG] raft: Node 2b5367e6-eea6-e195-df40- \n      1aeebfe8cdc7 updated peer set (2): [2406e36b-7e3e-0965-8863-  \n      70a5dc1a2e69 95c86c4c-9192-a8a6-5e38-66c033bb3955 2b5367e6-  \n      eea6-e195-df40-1aeebfe8cdc7]\n\n```", "```go\n $ curl \"http://localhost:3333/?next=second\" \n second\n\n $ curl \"http://localhost:3333/?next=third\" \n third\n\n $ curl \"http://localhost:3333/?next=second\" \n invalid transition\n\n $ curl \"http://localhost:3333/?next=first\" \n first\n\n```", "```go\n        FROM alpine\n\n        ADD ./example/example /example\n        EXPOSE 8000\n        ENTRYPOINT /example \n\n```", "```go\n        #!/usr/bin/env bash\n\n        pushd example\n        env GOOS=linux go build -ldflags \"-X main.version=1.0 -X     \n        main.builddate=$(date +%s)\"\n        popd\n        docker build . -t example\n        docker run -d -p 8000:8000 example \n\n```", "```go\n        package docker\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n            \"time\"\n        )\n\n        // VersionInfo holds artifacts passed in\n        // at build time\n        type VersionInfo struct {\n            Version string\n            BuildDate time.Time\n            Uptime time.Duration\n        }\n\n        // VersionHandler writes the latest version info\n        func VersionHandler(v *VersionInfo) http.HandlerFunc {\n            t := time.Now()\n            return func(w http.ResponseWriter, r *http.Request) {\n                v.Uptime = time.Since(t)\n                vers, err := json.Marshal(v)\n                    if err != nil {\n                        w.WriteHeader\n                        (http.StatusInternalServerError)\n                        return\n                    }\n                    w.WriteHeader(http.StatusOK)\n                    w.Write(vers)\n            }\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n            \"strconv\"\n            \"time\"\n\n            \"github.com/agtorre/go-cookbook/chapter10/docker\"\n        )\n\n        // these are set at build time\n        var (\n            version string\n            builddate string\n            )\n\n            var versioninfo docker.VersionInfo\n\n            func init() {\n                // parse buildtime variables\n                versioninfo.Version = version\n                i, err := strconv.ParseInt(builddate, 10, 64)\n                    if err != nil {\n                        panic(err)\n                    }\n                    tm := time.Unix(i, 0)\n                    versioninfo.BuildDate = tm\n            }\n\n            func main() {\n            http.HandleFunc(\"/version\",     \n            docker.VersionHandler(&versioninfo))\n            fmt.Printf(\"version %s listening on :8000\\n\",   \n            versioninfo.Version)\n            panic(http.ListenAndServe(\":8000\", nil))\n        }\n\n```", "```go\n $ bash setup.sh\n\n```", "```go\n $ bash setup.sh\n ~/go/src/github.com/agtorre/go- \n      cookbook/chapter10/docker/example   \n      ~/go/src/github.com/agtorre/go-cookbook/chapter10/docker\n ~/go/src/github.com/agtorre/go-cookbook/chapter10/docker\n Sending build context to Docker daemon 6.031 MB\n Step 1/4 : FROM alpine\n ---> 4a415e366388\n Step 2/4 : ADD ./example/example /example\n ---> de34c3c5451e\n Removing intermediate container bdcd9c4f4381\n Step 3/4 : EXPOSE 8000\n ---> Running in 188f450d4e7b\n ---> 35d1a2652b43\n Removing intermediate container 188f450d4e7b\n Step 4/4 : ENTRYPOINT /example\n ---> Running in cf0af4f48c3a\n ---> 3d737fc4e6e2\n Removing intermediate container cf0af4f48c3a\n Successfully built 3d737fc4e6e2\n b390ef429fbd6e7ff87058dc82e15c3e7a8b2e\n      69a601892700d1d434e9e8e43b\n\n```", "```go\n $ docker ps\n CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\n b390ef429fbd example \"/bin/sh -c /example\" 22 seconds ago Up 23    \n      seconds 0.0.0.0:8000->8000/tcp optimistic_wescoff\n\n $ curl localhost:8000/version\n {\"Version\":\"1.0\",\"BuildDate\":\"2017-04-   \n      30T21:55:56Z\",\"Uptime\":48132111264}\n\n $docker kill optimistic_wescoff # grab from first output\n optimistic_wescoff\n\n```", "```go\n        FROM golang:alpine\n\n        ENV GOPATH /code/\n        ADD . /code/src/github.com/agtorre/go-   \n        cookbook/chapter10/docker\n        WORKDIR /code/src/github.com/agtorre/go-    \n        cookbook/chapter10/docker/example\n        RUN go build\n\n        ENTRYPOINT /code/src/github.com/agtorre/go-  \n        cookbook/chapter10/docker/example/example\n\n```", "```go\n        version: '2'\n        services:\n         app:\n         build: .\n         mongodb:\n         image: \"mongo:latest\"\n\n```", "```go\n        package orchestrate\n\n        import (\n            \"fmt\"\n\n            mgo \"gopkg.in/mgo.v2\"\n            \"gopkg.in/mgo.v2/bson\"\n        )\n\n        // State is our data model\n        type State struct {\n            Name string `bson:\"name\"`\n            Population int `bson:\"pop\"`\n        }\n\n        // ConnectAndQuery connects, inserts a document, then\n        // queries it\n        func ConnectAndQuery(session *mgo.Session) error {\n            conn := session.DB(\"gocookbook\").C(\"example\")\n\n            // we can inserts many rows at once\n            if err := conn.Insert(&State{\"Washington\", 7062000}, \n            &State{\"Oregon\", 3970000}); err != nil {\n                return err\n            }\n\n            var s State\n            if err := conn.Find(bson.M{\"name\": \"Washington\"}).One(&s); \n            err!= nil {\n                return err\n            }\n            fmt.Printf(\"State: %#v\\n\", s)\n            return nil\n        }\n\n```", "```go\n        package main\n\n        import (\n             \"github.com/agtorre/go-cookbook/chapter10/orchestrate\"\n             mgo \"gopkg.in/mgo.v2\"\n        )\n\n        func main() {\n            session, err := mgo.Dial(\"mongodb\")\n            if err != nil {\n                panic(err)\n            }\n            if err := orchestrate.ConnectAndQuery(session); err != nil \n            {\n                panic(err)\n            }\n        }\n\n```", "```go\n $ docker logs docker_app_1\n State: docker.State{Name:\"Washington\", Population:7062000}\n\n```", "```go\n        FROM golang:alpine\n\n        ENV GOPATH /code/\n        ADD . /code/src/github.com/agtorre/go-\n        cookbook/chapter10/monitoring\n        WORKDIR /code/src/github.com/agtorre/go-\n        cookbook/chapter10/monitoring\n        RUN go build\n\n        ENTRYPOINT /code/src/github.com/agtorre/go-\n        cookbook/chapter10/monitoring/monitoring\n\n```", "```go\n        version: '2'\n        services:\n         app:\n         build: .\n         prometheus:\n         ports: \n         - 9090:9090\n         volumes: \n         - ./prometheus.yml:/etc/prometheus/prometheus.yml\n         image: \"prom/prometheus\"\n\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            \"github.com/prometheus/client_golang/prometheus/promhttp\"\n        )\n\n        func main() {\n            http.Handle(\"/metrics\", promhttp.Handler())\n            panic(http.ListenAndServe(\":80\", nil))\n        }\n\n```", "```go\n        global:\n         scrape_interval: 15s # By default, scrape targets every 15 \n         seconds.\n\n        # A scrape configuration containing exactly one endpoint to \n        scrape:\n        # Here it's Prometheus itself.\n        scrape_configs:\n         # The job name is added as a label `job=<job_name>` to any \n         timeseries scraped from this config.\n         - job_name: 'app'\n\n         # Override the global default and scrape targets from this job          \n         every 5 seconds.\n         scrape_interval: 5s\n\n         static_configs:\n         - targets: ['app:80']\n\n```", "```go\n $ docker-compose up\n Creating monitoring_app_1\n Creating monitoring_prometheus_1\n Attaching to monitoring_app_1, monitoring_prometheus_1\n prometheus_1 | time=\"2017-04-30T02:35:17Z\" level=info \n      msg=\"Starting prometheus (version=1.6.1, branch=master,       \n      revision=4666df502c0e239ed4aa1d80abbbfb54f61b23c3)\" \n      source=\"main.go:88\" \n prometheus_1 | time=\"2017-04-30T02:35:17Z\" level=info msg=\"Build       \n      context (go=go1.8.1, user=root@7e45fa0366a7, date=20170419-\n      14:32:22)\" source=\"main.go:89\" \n prometheus_1 | time=\"2017-04-30T02:35:17Z\" level=info \n      msg=\"Loading configuration file /etc/prometheus/prometheus.yml\"       \n      source=\"main.go:251\" \n prometheus_1 | time=\"2017-04-30T02:35:17Z\" level=info \n      msg=\"Loading series map and head chunks...\"      \n      source=\"storage.go:421\" \n prometheus_1 | time=\"2017-04-30T02:35:17Z\" level=info msg=\"0       \n      series loaded.\" source=\"storage.go:432\" \n prometheus_1 | time=\"2017-04-30T02:35:17Z\" level=info \n      msg=\"Starting target manager...\" source=\"targetmanager.go:61\" \n prometheus_1 | time=\"2017-04-30T02:35:17Z\" level=info \n      msg=\"Listening on :9090\" source=\"web.go:259\" \n\n```", "```go\n        package metrics\n\n        import (\n            \"net/http\"\n            \"time\"\n\n            metrics \"github.com/rcrowley/go-metrics\"\n        )\n\n        // CounterHandler will update a counter each time it's called\n        func CounterHandler(w http.ResponseWriter, r *http.Request) {\n            c := metrics.GetOrRegisterCounter(\"counterhandler.counter\", \n            nil)\n            c.Inc(1)\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(\"success\"))\n        }\n\n        // TimerHandler records the duration required to compelete\n        func TimerHandler(w http.ResponseWriter, r *http.Request) {\n            currt := time.Now()\n            t := metrics.GetOrRegisterTimer(\"timerhandler.timer\", nil)\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(\"success\"))\n            t.UpdateSince(currt)\n        }\n\n```", "```go\n        package metrics\n\n        import (\n            \"net/http\"\n\n            gometrics \"github.com/rcrowley/go-metrics\"\n        )\n\n        // ReportHandler will emit the current metrics in json format\n        func ReportHandler(w http.ResponseWriter, r *http.Request) {\n\n            w.WriteHeader(http.StatusOK)\n\n            t := gometrics.GetOrRegisterTimer(\n            \"reporthandler.writemetrics\", nil)\n            t.Time(func() {\n                gometrics.WriteJSONOnce(gometrics.DefaultRegistry, w)\n            })\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            \"github.com/agtorre/go-cookbook/chapter10/metrics\"\n        )\n\n        func main() {\n            // handler to populate metrics\n            http.HandleFunc(\"/counter\", metrics.CounterHandler)\n            http.HandleFunc(\"/timer\", metrics.TimerHandler)\n            http.HandleFunc(\"/report\", metrics.ReportHandler)\n            fmt.Println(\"listening on :8080\")\n            panic(http.ListenAndServe(\":8080\", nil))\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n listening on :8080\n\n```", "```go\n $ curl localhost:8080/counter \n success\n\n $ curl localhost:8080/timer \n success\n\n $ curl localhost:8080/report \n {\"counterhandler.counter\":{\"count\":1},\n      \"reporthandler.writemetrics\":      {\"15m.rate\":0,\"1m.rate\":0,\"5m.\n      rate\":0,\"75%\":0,\"95%\":0,\"99%\":0,\"99.9%\":0,\"count\":0,\"max\":0,\"mean\n      \":0,\"mean.rate\":0,\"median\":0,\"min\":0,\"stddev\":0},\"timerhandler.ti\n      mer\":{\"15m.rate\":0.0011080303990206543,\"1m.rate\"\n      :0.015991117074135343,\"5m.rate\":0.0033057092356765017,\"75%\":60485\n      ,\"95%\":60485,\"99%\":60485,\"99.9%\":60485,\"count\":1,\"max\":60485,\"mea\n      n\":60485,\"mean.rate\":1.1334543719787356,\"median\":60485,\"min\":6048\n      5,\"stddev\":0}}\n\n```"]