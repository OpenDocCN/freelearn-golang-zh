- en: Distributed Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using service discovery with Consul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic consensus using Raft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using containerization with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestration and deployment strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, application-level parallelism is not enough, and things that seem
    simple in development can become complex during deployment. Distributed systems
    provide a number of challenges not found when developing on a single machine.
    These applications have added complexity for things such as monitoring, writing
    applications that require strong consistency guarantees, and service discovery.
    In addition, you must always be mindful of single points of failure, such as a
    database. Otherwise your distributed applications can fail when this single component
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore methods of managing distributed data, orchestration,
    containerization, metrics, and monitoring. These will become part of your toolbox
    for writing and maintaining microservices and large distributed applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using service discovery with Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the microservice approach to applications, you end up with a lot
    of servers listening on a variety of IPs, domains, and ports. These IP addresses
    will vary by environment (staging versus production), and it can be tricky to
    keep them static for configuration between services. You also want to know when
    a machine or service is down or unreachable due to a network partition. Consul
    is a tool that provides a lot of functionality, but we'll explore registering
    services with Consul and querying them from our other services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: "Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)\
    \ and [\uFEFF](https://golang.org/doc/install)configure your `GOPATH` environment\
    \ variable."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal/console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `GOPATH/src` and create a project directory, for example, `$GOPATH/src/github.com/yourusername/customrepo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All code will be run and modified from this directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, install the latest tested version of the code by running the `go
    get github.com/agtorre/go-cookbook/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Consul from [https://www.consul.io/intro/getting-started/install.html](https://www.consul.io/intro/getting-started/install.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/hashicorp/consul/api` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter10/discovery` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/discovery](https://github.com/agtorre/go-cookbook/tree/master/chapter10/discovery),
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `client.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `operations.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Start Consul in a separate terminal using the `consul agent -dev -node=localhost`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go run main.go` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consul provides a robust Go API library. It can feel daunting when first starting,
    but this recipe shows how you might approach wrapping it. Configuring Consul further
    is beyond the scope of this recipe, but this shows the basic for registering a
    service and querying for other services given a key and tag.
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible using this to register new microservices at startup time,
    query for all dependent services, and deregister at shutdown. You might also want
    to cache this information so that you're not hitting Consul for every request,
    but this recipe provides the basic tools that you can expand upon. The Consul
    agent also makes these repeated requests fast and efficient ([https://www.consul.io/intro/getting-started/agent.html](https://www.consul.io/intro/getting-started/agent.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic consensus using Raft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raft is a consensus algorithm that allows distributed systems to keep a shared
    and managed state ([https://raft.github.io/](https://raft.github.io/)). Setting
    up a Raft system is complex in many ways, for one you need consensus for an election
    to occur and succeed. This can be difficult to bootstrap when working with multiple
    nodes and it can be difficult to get started. A basic cluster can be run on a
    single node/leader, but if you want redundancy, at least three nodes allows for
    a single node failure.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe implements a basic in-memory Raft cluster, constructs a state machine
    that can transition between certain allowed states, and connects the distributed
    state machine to a web handler that can trigger the transition. This can be useful
    when you're implementing the base finite state machine interface that Raft requires
    or when testing. This recipe uses [https://github.com/hashicorp/raft](https://github.com/hashicorp/raft)
    for the base Raft implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using service discovery with Consul*
    recipe in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/hashicorp/raft` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter10/consensus` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/consensus](https://github.com/agtorre/go-cookbook/tree/master/chapter10/consensus),
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `state.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `config.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `fsm.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `handler.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `go run main.go` command. Alternatively, you may also run the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output by running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In a separate terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application starts, we initialize multiple Raft objects. These each
    have their own address and transport. The `InmemTransport{}` function also provides
    a method to connect the other transports called `Connect()`. Once these connections
    are established, the Raft cluster holds an election. When communicating to a Raft
    cluster, clients must communicate with the leader. In our case, one handler can
    talk to all of the nodes, so the handler is responsible for having the leader
    `Raft` object `call Apply()`. This in turn runs `apply()` on all of the other
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe does not deal with snapshots and is only concerned with FSM state
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: The `InmemTransport{}` function simplifies the election and bootstrapping process
    by allowing everything to reside in memory. In practice, this isn't very helpful
    besides testing and proof of concepts since go routines can freely access shared
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Using containerization with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a container technology for packaging and shipping applications. Other
    advantages include portability, a container will run the same way regardless of
    the host OS. It provides a lot of the advantages of a virtual machine, in a more
    light-weight container. It's possible to limit resources consumption of individual
    containers and sandbox your environment. It can be extremely useful for having
    a common environment for your applications locally and when you ship your code
    to production. Docker is written in Go and is open source, so it's simple to take
    advantage of the client and libraries. This recipe will set up a Docker container
    for a basic Go application, store some version information about the container,
    and demonstrate hitting a handler from a Docker endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using service discovery for Consul*
    recipe of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Docker from [https://store.docker.com/search?type=edition&offering=community](https://store.docker.com/search?type=edition&offering=community).
    This will also include Docker compose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter10/docker` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/docker](https://github.com/agtorre/go-cookbook/tree/master/chapter10/docker)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `setup.sh` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `version.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Navigate back to the starting directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe created a script that compiles the Go binary for the Linux architecture
    and sets a variety of private variables in `main.go`. These variables are used
    to return version information on a version endpoint. Once the binary is compiled,
    a Docker container is created that contains the binary. This allows us to use
    very small container images as the Go runtime is self contained in the binary.
    We then run the container while exposing the port on which the container is listening
    for HTTP traffic. Lastly, we curl the port on localhost and see our version information
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration and deployment strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker makes orchestration and deployment much more simple. In this recipe,
    we'll set up a connection to MongoDB, inserting a document and querying it all
    from Docker containers. This recipe will set up the same environment as the *Using
    NoSQL with MongoDB and mgo* recipe, in [Chapter 5](e4c2a55e-c570-4490-b981-2685a89be7d2.xhtml),
    *All about Databases and Storage*, but will run the application and environment
    inside of containers and will use Docker compose to orchestrate and connect them.
    This can later be used in conjunction with Docker Swarm, an integrated Docker
    tool that allows you to manage a cluster, to create and deploy nodes that can
    be scaled up or down easily, and to manage load balancing ([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)).
    Another good example of container orchestration is Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)),
    a container orchestration framework written by Google using the Go programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using containerization with Docker*
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get gopkg.in/mgo.v2` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/tools/godep` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter10/orchestrate` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/orchestrate](https://github.com/agtorre/go-cookbook/tree/master/chapter10/orchestrate)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `docker-compose.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `mongo.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following content. Ensure that you modify
    the `orchestrate` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Navigate back to the starting directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `godep save ./...` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `docker-compose up -d` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `docker logs docker_app_1` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This configuration is good for local development. Once the `docker-compose up`
    command is run, the local directory is rebuilt, it establishes a connection to
    a MongoDB instance using the latest version and begins operating against it. This
    recipe uses godeps for dependency management so that the entire `GOPATH` environment
    variable doesn't need to be mounted by the `Dockerfile` file.
  prefs: []
  type: TYPE_NORMAL
- en: This can provide a good baseline when starting on apps that require connections
    to external services, all of the [Chapter 5](e4c2a55e-c570-4490-b981-2685a89be7d2.xhtml),
    *All about Databases and Storage*, can make use of this approach rather than creating
    a local instance of the database. For production, you likely won't want to run
    your datastorage behind a Docker container, but you'll also generally have static
    host names for configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of ways to monitor Go applications. One of the easiest ways
    is to set up Prometheus, a monitoring application written in Go ([https://prometheus.io](https://prometheus.io)).
    This is an application that polls an endpoint based on your configuration file
    and collects a lot of information about your app, including the number of goroutines,
    memory usage, and much more. This app will use the techniques from the previous
    recipe to set up a Docker environment to host Prometheus and connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using containerization with Docker*
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/prometheus/client_golang/prometheus/promhttp` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter10/monitoring` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/monitoring](https://github.com/agtorre/go-cookbook/tree/master/chapter10/monitoring)
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `Dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `docker-compose.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `prometheus.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Run the `godep save ./...` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `docker-compose up -d` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Navigate your browser to `http://localhost:9090/`. You should see a variety
    of metrics related to your app!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Prometheus client handler will return a variety of stats about your application
    to a Prometheus server. This allows you to point multiple Prometheus servers at
    an app without the need to reconfigure or deploy the app. Most of these stats
    are generic and beneficial for things such as detecting memory leaks. A lot of
    other solutions require you to periodically send information to a server instead.
    The next recipe, *Collecting metrics*, will demonstrate how to ship custom metrics
    to the Prometheus server.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to general information about your app, it can be helpful to emit
    metrics that are app specific. For example, we might want to collect timing data
    or keep track of the number of times an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will use the `github.com/rcrowley/go-metrics` package to collect
    metrics and expose them via an endpoint. There are various exporter tools to export
    metrics to places such as Prometheus and InfluxDB, also written in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using service discovery with Consul*
    recipe in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/rcrowley/go-metrics` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter10/metrics` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/metrics](https://github.com/agtorre/go-cookbook/tree/master/chapter10/metrics),
    or use this as an exercise to write some of your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `handler.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `report.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `go run main.go`. Alternatively, you may also run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands from a separate shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Try hitting all the endpoints a few more times to see how they change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The gometrics keeps all of your metrics in a registry. Once it's set up, you
    can use any of the metric omit options, such as counter or timer, and it will
    store this update in the registry. There are multiple exporters that will export
    metrics to third-party tools. In our case, we set up a handler that omits all
    the metrics in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: We set up three handlers--one that increments a counter, one that records the
    time to exit the handler, and one that prints a report (while also incrementing
    an additional counter). The `GetOrRegister` functions are useful for atomically
    getting or creating a metric emitter if it doesn't currently exist in a thread-safe
    way. Alternatively, you can register everything once in advance.
  prefs: []
  type: TYPE_NORMAL
