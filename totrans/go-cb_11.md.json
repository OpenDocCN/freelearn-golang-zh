["```go\n        package goflow\n\n        import (\n            \"encoding/base64\"\n            \"fmt\"\n            flow \"github.com/trustmaster/goflow\"\n        )\n\n        // Encoder base64 encodes all input\n        type Encoder struct {\n            flow.Component\n            Val <-chan string\n            Res chan<- string\n        }\n\n        // OnVal does the encoding then pushes the result onto Re\n        func (e *Encoder) OnVal(val string) {\n            encoded := base64.StdEncoding.EncodeToString([]byte(val))\n            e.Res <- fmt.Sprintf(\"%s => %s\", val, encoded)\n        }\n\n        // Printer is a component for printing to stdout\n        type Printer struct {\n            flow.Component\n            Line <-chan string\n        }\n\n        // OnLine Prints the current line received\n        func (p *Printer) OnLine(line string) {\n            fmt.Println(line)\n        }\n\n```", "```go\n        package goflow\n\n        import flow \"github.com/trustmaster/goflow\"\n\n        // EncodingApp creates a flow-based\n        // pipeline to encode and print the\n        // result\n        type EncodingApp struct {\n            flow.Graph\n        }\n\n        // NewEncodingApp wires together the components\n        func NewEncodingApp() *EncodingApp {\n            e := &EncodingApp{}\n            e.InitGraphState()\n\n            // define component types\n            e.Add(&Encoder{}, \"encoder\")\n            e.Add(&Printer{}, \"printer\")\n\n            // connect the components using channels\n            e.Connect(\"encoder\", \"Res\", \"printer\", \"Line\")\n\n            // map the in channel to Val, which is\n            // tied to OnVal function\n            e.MapInPort(\"In\", \"encoder\", \"Val\")\n\n            return e\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/agtorre/go-cookbook/chapter11/goflow\"\n            flow \"github.com/trustmaster/goflow\"\n        )\n\n        func main() {\n\n            net := goflow.NewEncodingApp()\n\n            in := make(chan string)\n            net.SetInPort(\"In\", in)\n\n            flow.RunNet(net)\n\n            for i := 0; i < 20; i++ {\n                in <- fmt.Sprint(\"Message\", i)\n            }\n\n            close(in)\n            <-net.Wait()\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n Message6 => TWVzc2FnZTY=\n Message5 => TWVzc2FnZTU=\n Message1 => TWVzc2FnZTE=\n Message0 => TWVzc2FnZTA=\n Message4 => TWVzc2FnZTQ=\n Message8 => TWVzc2FnZTg=\n Message2 => TWVzc2FnZTI=\n Message3 => TWVzc2FnZTM=\n Message7 => TWVzc2FnZTc=\n Message10 => TWVzc2FnZTEw\n Message9 => TWVzc2FnZTk=\n Message12 => TWVzc2FnZTEy\n Message11 => TWVzc2FnZTEx\n Message14 => TWVzc2FnZTE0\n Message13 => TWVzc2FnZTEz\n Message16 => TWVzc2FnZTE2\n Message15 => TWVzc2FnZTE1\n Message18 => TWVzc2FnZTE4\n Message17 => TWVzc2FnZTE3\n Message19 => TWVzc2FnZTE5\n\n```", "```go\n        package reactive\n\n        // Wine represents a bottle\n        // of wine and is our\n        // input stream\n        type Wine struct {\n            Name string\n            Age int\n            Rating float64 // 1-5\n        }\n\n        // GetWine returns an array of wines,\n        // ages, and ratings\n        func GetWine() interface{} {\n            // some example wines\n            w := []interface{}{\n                Wine{\"Merlot\", 2011, 3.0},\n                Wine{\"Cabernet\", 2010, 3.0},\n                Wine{\"Chardonnay\", 2010, 4.0},\n                Wine{\"Pinot Grigio\", 2009, 4.5},\n            }\n            return w\n        }\n\n        // Results holds a list of results by age\n        type Results map[int]Result\n\n        // Result is used for aggregation\n        type Result struct {\n            SumRating float64\n            NumSamples int\n        }\n\n```", "```go\n        package reactive\n\n        import (\n            \"github.com/reactivex/rxgo/iterable\"\n            \"github.com/reactivex/rxgo/observable\"\n            \"github.com/reactivex/rxgo/observer\"\n            \"github.com/reactivex/rxgo/subscription\"\n        )\n\n        // Exec connects rxgo and returns\n        // our results side-effect + a subscription\n        // channel to block on at the end\n        func Exec() (Results, <-chan subscription.Subscription) {\n            results := make(Results)\n            watcher := observer.Observer{\n                NextHandler: func(item interface{}) {\n                    wine, ok := item.(Wine)\n                    if ok {\n                        result := results[wine.Age]\n                        result.SumRating += wine.Rating\n                        result.NumSamples++\n                        results[wine.Age] = result\n                    }\n                },\n            }\n            wine := GetWine()\n            it, _ := iterable.New(wine)\n\n            source := observable.From(it)\n            sub := source.Subscribe(watcher)\n\n            return results, sub\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/agtorre/go-cookbook/chapter11/reactive\"\n        )\n\n        func main() {\n            results, sub := reactive.Exec()\n\n            // wait for the channel to emit a Subscription\n            <-sub\n\n            // process results\n            for key, val := range results {\n                fmt.Printf(\"Age: %d, Sample Size: %d, Average Rating: \n                %.2f\\n\", key, val.NumSamples, \n                val.SumRating/float64(val.NumSamples))\n            }\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n Age: 2011, Sample Size: 1, Average Rating: 3.00\n Age: 2010, Sample Size: 2, Average Rating: 3.50\n Age: 2009, Sample Size: 1, Average Rating: 4.50\n\n```", "```go\n        package main\n\n        import (\n            \"log\"\n\n            sarama \"gopkg.in/Shopify/sarama.v1\"\n        )\n\n        func main() {\n            consumer, err := \n            sarama.NewConsumer([]string{\"localhost:9092\"}, nil)\n            if err != nil {\n                panic(err)\n            }\n            defer consumer.Close()\n\n            partitionConsumer, err := \n\n           consumer.ConsumePartition(\"example\", 0, \n            sarama.OffsetNewest)\n            if err != nil {\n                panic(err)\n            }\n            defer partitionConsumer.Close()\n\n            for {\n                msg := <-partitionConsumer.Messages()\n                log.Printf(\"Consumed message: \\\"%s\\\" at offset: %d\\n\", \n                msg.Value, msg.Offset)\n            }\n        }\n\n```", "```go\n        package main\n\n        import (\n\n           \"fmt\"\n           \"log\"\n\n            sarama \"gopkg.in/Shopify/sarama.v1\"\n        )\n\n        func sendMessage(producer sarama.SyncProducer, value string) {\n            msg := &sarama.ProducerMessage{Topic: \"example\", Value: \n            sarama.StringEncoder(value)}\n            partition, offset, err := producer.SendMessage(msg)\n            if err != nil {\n\n               log.Printf(\"FAILED to send message: %s\\n\", err)\n                return\n            }\n            log.Printf(\"> message sent to partition %d at offset %d\\n\", \n            partition, offset)\n        }\n\n        func main() {\n            producer, err := \n            sarama.NewSyncProducer([]string{\"localhost:9092\"}, nil)\n            if err != nil {\n                panic(err)\n            }\n            defer producer.Close()\n\n            for i := 0; i < 10; i++ {\n                sendMessage(producer, fmt.Sprintf(\"Message %d\", i))\n            }\n        }\n\n```", "```go\n $ go run producer/main.go \n 2017/05/07 11:50:38 > message sent to partition 0 at offset 0\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 1\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 2\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 3\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 4\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 5\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 6\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 7\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 8\n 2017/05/07 11:50:38 > message sent to partition 0 at offset 9\n\n```", "```go\n $ go run consumer/main.go \n 2017/05/07 11:50:38 Consumed message: \"Message 0\" at offset: 0\n 2017/05/07 11:50:38 Consumed message: \"Message 1\" at offset: 1\n 2017/05/07 11:50:38 Consumed message: \"Message 2\" at offset: 2\n 2017/05/07 11:50:38 Consumed message: \"Message 3\" at offset: 3\n 2017/05/07 11:50:38 Consumed message: \"Message 4\" at offset: 4\n 2017/05/07 11:50:38 Consumed message: \"Message 5\" at offset: 5\n 2017/05/07 11:50:38 Consumed message: \"Message 6\" at offset: 6\n 2017/05/07 11:50:38 Consumed message: \"Message 7\" at offset: 7\n 2017/05/07 11:50:38 Consumed message: \"Message 8\" at offset: 8\n 2017/05/07 11:50:38 Consumed message: \"Message 9\" at offset: 9\n\n```", "```go\n        package main\n\n        import (\n            \"log\"\n\n            sarama \"gopkg.in/Shopify/sarama.v1\"\n        )\n\n        // Process response grabs results and errors from a producer\n        // asynchronously\n        func ProcessResponse(producer sarama.AsyncProducer) {\n            for {\n                select {\n                    case result := <-producer.Successes():\n                    log.Printf(\"> message: \\\"%s\\\" sent to partition \n                    %d at offset %d\\n\", result.Value, \n                    result.Partition, result.Offset)\n                    case err := <-producer.Errors():\n                    log.Println(\"Failed to produce message\", err)\n                }\n            }\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            sarama \"gopkg.in/Shopify/sarama.v1\"\n        )\n\n        // KafkaController allows us to attach a producer\n        // to our handlers\n        type KafkaController struct {\n            producer sarama.AsyncProducer\n        }\n\n        // Handler grabs a message from a GET parama and\n        // send it to the kafka queue asynchronously\n        func (c *KafkaController) Handler(w http.ResponseWriter, r \n        *http.Request) {\n            if err := r.ParseForm(); err != nil {\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            }\n\n            msg := r.FormValue(\"msg\")\n            if msg == \"\" {\n                w.WriteHeader(http.StatusBadRequest)\n                w.Write([]byte(\"msg must be set\"))\n                return\n            }\n            c.producer.Input() <- &sarama.ProducerMessage{Topic: \n            \"example\", Key: nil, Value: \n            sarama.StringEncoder(r.FormValue(\"msg\"))}\n            w.WriteHeader(http.StatusOK)\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            sarama \"gopkg.in/Shopify/sarama.v1\"\n        )\n\n        func main() {\n            config := sarama.NewConfig()\n            config.Producer.Return.Successes = true\n            config.Producer.Return.Errors = true\n            producer, err := \n            sarama.NewAsyncProducer([]string{\"localhost:9092\"}, config)\n            if err != nil {\n                panic(err)\n            }\n            defer producer.AsyncClose()\n\n            go ProcessResponse(producer)\n\n            c := KafkaController{producer}\n            http.HandleFunc(\"/\", c.Handler)\n            fmt.Println(\"Listening on port :3333\")\n            panic(http.ListenAndServe(\":3333\", nil))\n        }\n\n```", "```go\n $ curl \"http://localhost:3333/?msg=this\" \n $ curl \"http://localhost:3333/?msg=is\" \n $ curl \"http://localhost:3333/?msg=an\" \n $ curl \"http://localhost:3333/?msg=example\" \n\n```", "```go\n $ ./producer/producer \n Listening on port :3333\n 2017/05/07 13:52:54 > message: \"this\" sent to partition 0 at \n offset 0\n 2017/05/07 13:53:25 > message: \"is\" sent to partition 0 at offset \n 1\n 2017/05/07 13:53:27 > message: \"an\" sent to partition 0 at offset \n 2\n 2017/05/07 13:53:29 > message: \"example\" sent to partition 0 at \n offset 3\n\n```", "```go\n $ go run consumer/main.go \n 2017/05/07 13:52:54 Consumed message: \"this\" at offset: 0\n 2017/05/07 13:53:25 Consumed message: \"is\" at offset: 1\n 2017/05/07 13:53:27 Consumed message: \"an\" at offset: 2\n 2017/05/07 13:53:29 Consumed message: \"example\" at offset: 3\n\n```", "```go\n        package kafkaflow\n\n        import (\n            \"fmt\"\n            \"strings\"\n\n            flow \"github.com/trustmaster/goflow\"\n        )\n\n        // Upper upper cases the incoming\n        // stream\n        type Upper struct {\n            flow.Component\n            Val <-chan string\n            Res chan<- string\n        }\n\n        // OnVal does the encoding then pushes the result onto Re\n        func (e *Upper) OnVal(val string) {\n            e.Res <- strings.ToUpper(val)\n        }\n\n        // Printer is a component for printing to stdout\n        type Printer struct {\n            flow.Component\n            Line <-chan string\n        }\n\n        // OnLine Prints the current line received\n        func (p *Printer) OnLine(line string) {\n            fmt.Println(line)\n        }\n\n```", "```go\n        package kafkaflow\n\n        import flow \"github.com/trustmaster/goflow\"\n\n        // UpperApp creates a flow-based\n        // pipeline to upper case and print the\n        // result\n        type UpperApp struct {\n            flow.Graph\n        }\n\n        // NewUpperApp wires together the compoents\n        func NewUpperApp() *UpperApp {\n            u := &UpperApp{}\n            u.InitGraphState()\n\n            u.Add(&Upper{}, \"upper\")\n            u.Add(&Printer{}, \"printer\")\n\n            u.Connect(\"upper\", \"Res\", \"printer\", \"Line\")\n            u.MapInPort(\"In\", \"upper\", \"Val\")\n\n            return u\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"github.com/agtorre/go-cookbook/chapter11/kafkaflow\"\n            flow \"github.com/trustmaster/goflow\"\n            sarama \"gopkg.in/Shopify/sarama.v1\"\n        )\n\n        func main() {\n            consumer, err := \n            sarama.NewConsumer([]string{\"localhost:9092\"}, nil)\n            if err != nil {\n                panic(err)\n            }\n            defer consumer.Close()\n\n            partitionConsumer, err := \n            consumer.ConsumePartition(\"example\", 0, \n            sarama.OffsetNewest)\n            if err != nil {\n                panic(err)\n            }\n            defer partitionConsumer.Close()\n\n            net := kafkaflow.NewUpperApp()\n\n            in := make(chan string)\n            net.SetInPort(\"In\", in)\n\n            flow.RunNet(net)\n            defer func() {\n                close(in)\n                <-net.Wait()\n            }()\n\n            for {\n                msg := <-partitionConsumer.Messages()\n                in <- string(msg.Value)\n            }\n        }\n\n```", "```go\n $ go run producer/main.go \n go run producer/main.go !3300\n 2017/05/07 18:24:12 > message \"Message 0\" sent to partition 0 at \n offset 0\n 2017/05/07 18:24:12 > message \"Message 1\" sent to partition 0 at \n offset 1\n 2017/05/07 18:24:12 > message \"Message 2\" sent to partition 0 at \n offset 2\n 2017/05/07 18:24:12 > message \"Message 3\" sent to partition 0 at \n offset 3\n 2017/05/07 18:24:12 > message \"Message 4\" sent to partition 0 at \n offset 4\n 2017/05/07 18:24:12 > message \"Message 5\" sent to partition 0 at \n offset 5\n 2017/05/07 18:24:12 > message \"Message 6\" sent to partition 0 at \n offset 6\n 2017/05/07 18:24:12 > message \"Message 7\" sent to partition 0 at \n offset 7\n 2017/05/07 18:24:12 > message \"Message 8\" sent to partition 0 at \n offset 8\n 2017/05/07 18:24:12 > message \"Message 9\" sent to partition 0 at \n offset 9\n\n```", "```go\n $ go run consumer/main.go \n MESSAGE 0\n MESSAGE 1\n MESSAGE 2\n MESSAGE 3\n MESSAGE 4\n MESSAGE 5\n MESSAGE 6\n MESSAGE 7\n MESSAGE 8\n MESSAGE 9\n\n```", "```go\n        package cards\n\n        // Card represents a standard playing\n        // card\n        type Card struct {\n            Value string\n            Suit string\n        }\n\n        var cards []Card\n\n        func init() {\n            cards = []Card{\n                {\"A\", \"Spades\"}, {\"2\", \"Spades\"}, {\"3\", \"Spades\"},\n                {\"4\", \"Spades\"}, {\"5\", \"Spades\"}, {\"6\", \"Spades\"},\n                {\"7\", \"Spades\"}, {\"8\", \"Spades\"}, {\"9\", \"Spades\"},\n                {\"10\", \"Spades\"}, {\"J\", \"Spades\"}, {\"Q\", \"Spades\"},\n                {\"K\", \"Spades\"},\n                {\"A\", \"Hearts\"}, {\"2\", \"Hearts\"}, {\"3\", \"Hearts\"},\n                {\"4\", \"Hearts\"}, {\"5\", \"Hearts\"}, {\"6\", \"Hearts\"},\n                {\"7\", \"Hearts\"}, {\"8\", \"Hearts\"}, {\"9\", \"Hearts\"},\n                {\"10\", \"Hearts\"}, {\"J\", \"Hearts\"}, {\"Q\", \"Hearts\"},\n                {\"K\", \"Hearts\"},\n                {\"A\", \"Clubs\"}, {\"2\", \"Clubs\"}, {\"3\", \"Clubs\"},\n                {\"4\", \"Clubs\"}, {\"5\", \"Clubs\"}, {\"6\", \"Clubs\"},\n                {\"7\", \"Clubs\"}, {\"8\", \"Clubs\"}, {\"9\", \"Clubs\"},\n                {\"10\", \"Clubs\"}, {\"J\", \"Clubs\"}, {\"Q\", \"Clubs\"},\n                {\"K\", \"Clubs\"},\n                {\"A\", \"Diamonds\"}, {\"2\", \"Diamonds\"}, {\"3\", \n                \"Diamonds\"},\n                {\"4\", \"Diamonds\"}, {\"5\", \"Diamonds\"}, {\"6\", \n                \"Diamonds\"},\n                {\"7\", \"Diamonds\"}, {\"8\", \"Diamonds\"}, {\"9\", \n                \"Diamonds\"},\n                {\"10\", \"Diamonds\"}, {\"J\", \"Diamonds\"}, {\"Q\", \n                \"Diamonds\"},\n                {\"K\", \"Diamonds\"},\n            }\n        }\n\n```", "```go\n        package cards\n\n        import \"github.com/graphql-go/graphql\"\n\n        // CardType returns our card graphql object\n        func CardType() *graphql.Object {\n            cardType := graphql.NewObject(graphql.ObjectConfig{\n                Name: \"Card\",\n                Description: \"A Playing Card\",\n                Fields: graphql.Fields{\n                    \"value\": &graphql.Field{\n                        Type: graphql.String,\n                        Description: \"Ace through King\",\n                        Resolve: func(p graphql.ResolveParams) \n                        (interface{}, error) {\n                            if card, ok := p.Source.(Card); ok {\n                                return card.Value, nil\n                            }\n                            return nil, nil\n                        },\n                    },\n                    \"suit\": &graphql.Field{\n                        Type: graphql.String,\n                        Description: \"Hearts, Diamonds, Clubs, Spades\",\n                        Resolve: func(p graphql.ResolveParams) \n                        (interface{}, error) {\n                            if card, ok := p.Source.(Card); ok {\n                                return card.Suit, nil\n                            }\n                            return nil, nil\n                        },\n                    },\n                },\n            })\n            return cardType\n        }\n\n```", "```go\n        package cards\n\n        import (\n            \"strings\"\n\n            \"github.com/graphql-go/graphql\"\n        )\n\n        // Resolve handles filtering cards\n        // by suit and value\n        func Resolve(p graphql.ResolveParams) (interface{}, error) {\n            finalCards := []Card{}\n            suit, suitOK := p.Args[\"suit\"].(string)\n            suit = strings.ToLower(suit)\n\n            value, valueOK := p.Args[\"value\"].(string)\n            value = strings.ToLower(value)\n\n            for _, card := range cards {\n                if suitOK && suit != strings.ToLower(card.Suit) {\n                    continue\n                }\n                if valueOK && value != strings.ToLower(card.Value) {\n                    continue\n                }\n\n                finalCards = append(finalCards, card)\n            }\n            return finalCards, nil\n        }\n\n```", "```go\n        package cards\n\n        import \"github.com/graphql-go/graphql\"\n\n        // Setup prepares and returns our card\n        // schema\n        func Setup() (graphql.Schema, error) {\n            cardType := CardType()\n\n            // Schema\n            fields := graphql.Fields{\n                \"cards\": &graphql.Field{\n                    Type: graphql.NewList(cardType),\n                    Args: graphql.FieldConfigArgument{\n                        \"suit\": &graphql.ArgumentConfig{\n                            Description: \"Filter cards by card suit \n                            (hearts, clubs, diamonds, spades)\",\n                            Type: graphql.String,\n                        },\n                        \"value\": &graphql.ArgumentConfig{\n                            Description: \"Filter cards by card \n                            value (A-K)\",\n                            Type: graphql.String,\n                        },\n                    },\n                    Resolve: Resolve,\n                },\n            }\n\n            rootQuery := graphql.ObjectConfig{Name: \"RootQuery\", \n            Fields: fields}\n            schemaConfig := graphql.SchemaConfig{Query: \n            graphql.NewObject(rootQuery)}\n            schema, err := graphql.NewSchema(schemaConfig)\n\n            return schema, err\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"encoding/json\"\n            \"fmt\"\n            \"log\"\n\n            \"github.com/agtorre/go-cookbook/chapter11/graphql/cards\"\n            \"github.com/graphql-go/graphql\"\n        )\n\n        func main() {\n            // grab our schema\n            schema, err := cards.Setup()\n            if err != nil {\n                panic(err)\n            }\n\n            // Query\n            query := `\n            {\n                cards(value: \"A\"){\n                    value\n                    suit\n                }\n            }\n `\n            params := graphql.Params{Schema: schema, RequestString: \n            query}\n            r := graphql.Do(params)\n            if len(r.Errors) > 0 {\n                log.Fatalf(\"failed to execute graphql operation, \n                errors: %+v\", r.Errors)\n            }\n            rJSON, err := json.MarshalIndent(r, \"\", \" \")\n            if err != nil {\n                panic(err)\n            }\n            fmt.Printf(\"%s \\n\", rJSON)\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n {\n \"data\": {\n \"cards\": [\n {\n \"suit\": \"Spades\",\n \"value\": \"A\"\n },\n {\n \"suit\": \"Hearts\",\n \"value\": \"A\"\n },\n {\n \"suit\": \"Clubs\",\n \"value\": \"A\"\n },\n {\n \"suit\": \"Diamonds\",\n \"value\": \"A\"\n }\n ]\n }\n } \n\n```"]