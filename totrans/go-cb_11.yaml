- en: Reactive Programming and Data Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Goflow for dataflow programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming with RxGo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kafka with Sarama
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using async producers with Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting Kafka to Goflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a GraphQL server in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will discuss reactive programming design patterns in Go. Reactive
    programming is a programming concept that focuses on data streams and the propagation
    of change ([https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)).
    Technologies such as Kafka allow you to quickly produce or consume a stream of
    data. As a result, these technologies are a natural fit for one another. In the
    *Connecting Kafka to Goflow* recipe, we'll explore combining a `kafka` message
    queue with `goflow` to show a practical example of using these technologies. This
    chapter will also explore various ways to connect with Kafka and use it to process
    messages. Lastly, this chapter will demonstrate how to create a basic `graphql`
    server in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Goflow for dataflow programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `github.com/trustmaster/goflow` package is useful for creating dataflow-based
    applications. It tries to abstract concepts so that you can write components and
    connect them together using a custom network. This recipe will recreate the application
    discussed in [Chapter 8](ab72719b-7fbf-4127-a091-b4ca5cf59775.xhtml), *Testing*,
    but it will do so using the `goflow` package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal/console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to your `GOPATH/src` and create a project directory, for example, `$GOPATH/src/github.com/yourusername/customrepo`.
    All code will be run and modified from this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/trustmaster/goflow` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter11/goflow` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/goflow](https://github.com/agtorre/go-cookbook/tree/master/chapter11/goflow)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `components.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `network.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `goflow` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `github.com/trustmaster/goflow` package works by defining a network/graph,
    registering some components, and then wiring them together. This can feel a bit
    error-prone since these are described using strings, but usually this will fail
    early in runtime until it's set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we set up two components, one that base64 encodes an incoming
    string and one that prints anything passed to it. We connect it to an in channel
    that is initialized in `main.go`, and anything passed onto that channel will flow
    through our pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the emphasis of this approach is on ignoring the internals of what's
    going on. We treat everything like a connected black box and let `goflow` do the
    rest. You can see in this recipe how small the code is to accomplish this pipeline
    of tasks and that we have fewer knobs to control the number of workers, among
    other things.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming with RxGo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ReactiveX ([http://reactivex.io/](http://reactivex.io/)) is an API for programming
    with observable streams. RxGo ([github.com/reactivex/rxgo](http://github.com/reactivex/rxgo))
    is a library to support this pattern in Go. It helps you to think of your application
    as a big stream of events that responds in different ways when those events occur.
    This recipe will create an application that uses this approach to process different
    wines. Ideally, this approach can be tied to wine data or wine APIs and can aggregate
    information about wine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Goflow for dataflow programming*
    recipe in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/reactivex/rxgo` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter11/reactive` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/reactive](https://github.com/agtorre/go-cookbook/tree/master/chapter11/reactive)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `wine.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `reactive` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxGo works by abstracting a source stream, which can be an array or a channel,
    allowing you to aggregate streams, and finally creating observers that handle
    events. These can handle errors or data. RxGo uses an `interface{}` type for its
    argument so that you can pass in arbitrary values. As a result, you must use reflection
    in order to convert incoming data to its correct type. This can be tricky if you
    need to return errors on your observers. In addition, the added reflection can
    be costly in terms of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you must modify some shared state, either global or within a local closure,
    which will be used at the end. In our case, we have a `Results` type, which is
    a map with a key of the year and the value of the aggregate score and number of
    samples. This allows us to emit averages about each year. If we had used wine
    names instead of types, we could also aggregate by types. This library is still
    in its early stages. In many ways, you can achieve the same effect using basic
    Go channels. It helps to illustrate how some of these ideas may translate to Go.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kafka with Sarama
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kafka is a popular distributed message queue with a lot of advanced functions
    for building distributed systems. This recipe will show how to write to a Kafka
    topic using a synchronous producer and how to consume the same topic using a partition
    consumer. This recipe will not explore different configurations of Kafka as that
    is a much wider topic, but I suggest beginning at [https://kafka.apache.org/intro](https://kafka.apache.org/intro).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Goflow for dataflow programming*
    recipe in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Kafka using the steps mentioned at [https://www.tutorialspoint.com/apache_kafka/apache_kafka_installation_steps.htm](https://www.tutorialspoint.com/apache_kafka/apache_kafka_installation_steps.htm).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, you can also access [https://github.com/spotify/docker-kafka](https://github.com/spotify/docker-kafka).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get gopkg.in/Shopify/sarama.v1` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter11/synckafka` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/synckafka](https://github.com/agtorre/go-cookbook/tree/master/chapter11/synckafka)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Kafka is up and running on `localhost:9092`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `main.go` in a directory named `consumer` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `main.go` in a directory named `producer` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run consumer/main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a separate terminal, run `go run producer/main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the producer terminal, you should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the consumer terminal, you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates passing simple messages via Kafka. More complex methods
    should use a serialization format such as `json`, `gob`, `protobuf`, or others.
    The producer can send a message to Kafka synchronously through `sendMessage`.
    This does not the handle cases well where the Kafka cluster is down and may result
    in a hung process for these cases. This is important to consider for applications
    such as web handlers as it may result in timeouts and hard dependencies on the
    Kafka cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the message queues correctly, our consumer will observe the Kafka stream
    and do something with the results. Previous recipes in this chapter might make
    use of this stream to do some additional processing.
  prefs: []
  type: TYPE_NORMAL
- en: Using async producers with Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's often useful to not wait for a Kafka producer to complete before moving
    on to the next task. In cases like this, you can use an async producer. These
    producers take Sarama messages on a channel and have methods to return a success/error
    channel that can be checked separately.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create a go routine that will handle success and failure
    messages while we allow a handler to queue messages to send regardless of the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using Kafka with Sarama* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter11/asyncsarama` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/asyncsarama](https://github.com/agtorre/go-cookbook/tree/master/chapter11/asyncsarama)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Kafka is up and running on `localhost:9092`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the consumer directory from the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory named `producer` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `producer.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `handler.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the `go build` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate up a directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go run consumer/main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a separate terminal from the same directory, run `./producer/producer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a third terminal, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the producer terminal, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the consumer terminal, you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our modifications in this chapter were all made to the producer. This time,
    we created a separate go routine to handle successes and errors. If these are
    left unhandled, your application will deadlock. Next, we attached our producer
    to a handler and we emit messages on it whenever a message is received via a `GET`
    call to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: The handler will immediately return success upon sending the message regardless
    of its response. If this is not acceptable, a synchronous approach should be used
    instead. In our case, we're okay with later processing success and errors separately.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we curl our endpoint with a few different messages and you can see them
    flow from the handler to where they're eventually printed by the Kafka consumer
    we wrote in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Kafka to Goflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will combine a Kafka consumer with a Goflow pipeline. As our consumer
    receives messages from Kafka, it will run `strings.ToUpper()` on them and then
    print the results. These naturally pair as Goflow is designed to operate on an
    incoming stream, which is exactly what Kafka provides us.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Using Kafka with Sarama* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter11/kafkaflow` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/kafkaflow](https://github.com/agtorre/go-cookbook/tree/master/chapter11/kafkaflow)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Kafka is up and running on `localhost:9092`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `components.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `network.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `main.go` in a directory named `consumer` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Copy the consumer directory from the *Using Kafka with Saram* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go run consumer/main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a separate terminal, run `go run producer/main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the producer terminal, you should now see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the consumer terminal, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe combines ideas from previous recipes in this chapter. Like previous
    recipes, we set up a Kafka consumer and producer. This recipe uses the synchronous
    producer from the *Using Kafka With Sarama* recipe, but could have also used an
    asynchronous producer instead. Once a message is received, we enqueue it on an
    in channel just like we did in the *Goflow for dataflow programming* recipe*.*
    We modify the components from this recipe to uppercase our incoming string rather
    than base64 encoding it. We reuse the print components and the resultant network
    configuration is similar.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that all messages received through the Kafka consumer are
    transported into our flow-based work pipeline to be operated on. This allows us
    to instrument our pipeline components to be modular and reusable, and we can use
    the same component multiple times in different configurations. Similarly, we'll
    receive traffic from any producer that writes to Kafka, so we can multiplex producers
    into a single data stream.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a GraphQL server in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL is an alternative to REST, created by Facebook ([http://graphql.org/](http://graphql.org/)).
    This technology allows a server to implement and publish a schema and the clients
    then can ask for the information they need rather than understanding and making
    use of various API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll create a `Graphql` schema that represents a deck of playing
    cards. We'll expose one resource card, which can be filtered by suit and value.
    Alternatively, it can return all the cards in the deck if no arguments are specified.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Getting ready* section of the *Goflow for dataflow programming*
    recipe in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/graphql-go/graphql` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your terminal/console application, create the `chapter11/graphql` directory
    and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/graphql](https://github.com/agtorre/go-cookbook/tree/master/chapter11/graphql)
    or use this as an exercise to write some of your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and navigate to the `cards` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `card.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `type.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `resolve.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `schema.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Navigate back to the `graphql` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `cards` import to use the path you set up in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Test some additional queries, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cards(suit: "Spades")`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cards(value: "3", suit:"Diamonds")`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cards.go` file defines a `card` object and initializes the base deck in
    a global variable called cards. This state could also be held in long-term storage
    such as a database. We then define `CardType` in `types.go` that allows `graphql`
    to resolve card objects to responses. Next, we jump into `resolve.go`, where we
    define how to filter cards by value and type. This `Resolve` function will be
    used by the final schema, which is defined in `schema.go`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you would modify the `Resolve` function in this recipe in order
    to retrieve data from a database. Lastly, we load the schema and run a query against
    it. It's a small modification to mount our schema onto a rest endpoint, but for
    brevity, this recipe just runs a hardcoded query. For more information about `GraphQL`
    queries, visit [http://graphql.org/learn/queries/](http://graphql.org/learn/queries/).
  prefs: []
  type: TYPE_NORMAL
