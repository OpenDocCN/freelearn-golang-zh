<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Serverless Programming</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Go programming on Lambda with Apex</li>
<li>Apex serverless logging and metrics</li>
<li>Google App Engine with Go</li>
<li>Working with Firebase using zabawaba99/firego</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>This chapter will focus on serverless architectures and using them with the Go language. It will also explore app engine and Firebase, two services to quickly deploy applications and data storage to the web.</p>
<p>All of the recipes in this chapter deal with third-party services that bill for use; ensure that you clean up when you're done using them. Otherwise, think of these recipes as kick-starters for spinning up larger applications on these platforms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go programming on Lambda with Apex</h1>
                </header>
            
            <article>
                
<p>Apex is a tool for building, deploying, and managing AWS Lambda functions. It provides wrappers for Go (using a <kbd>Node.js</kbd> shim). Currently, there is not a way to run native Go code on Lambda without such a shim. This recipe will explore creating Go Lambda functions and deploying them with Apex.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system (<a href="https://golang.org/doc/install">https://golang.org/doc/install</a>) and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application.</li>
<li>Navigate to your <kbd>GOPATH/src</kbd> directory and create a project directory, for example, <strong><kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd></strong>. All code will be run and modified from this directory.</li>
<li>Optionally, install the latest tested version of the code using the<br/>
<br/>
<br/>
<br/>
<strong><kbd>go get github.com/agtorre/go-cookbook/...</kbd></strong> command.</li>
<li>Install Apex from <a href="http://apex.run/">http://apex.run/</a>.</li>
<li>Run the <strong><kbd>go get github.com/apex/go-apex</kbd></strong> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter12/lambda</kbd> directory and navigate to it.</li>
<li>Create an Amazon account and an IAM role that can edit Lambda functions, which can be done from <a href="https://aws.amazon.com/lambda/">https://aws.amazon.com/lambda/</a>.</li>
<li>Create a file called <kbd>~/.aws/credentials</kbd> with the following content, copying your credentials from what you set up in the Amazon console:</li>
</ol>
<pre>
        [example]<br/>        aws_access_key_id = xxxxxxxx<br/>        aws_secret_access_key = xxxxxxxxxxxxxxxxxxxxxxxx
</pre>
<ol start="4">
<li>Create an environment variable to hold your desired region:</li>
</ol>
<pre>
        export AWS_REGION=us-west-2
</pre>
<ol start="5">
<li>Run the <kbd>apex init</kbd> command and follow the onscreen instructions:</li>
</ol>
<pre>
<strong>      $ apex init </strong><br/><br/><strong>      Enter the name of your project. It should be machine-friendly, </strong><br/><strong>      as this is used to prefix your functions in Lambda.</strong><br/><br/><strong>      Project name: go-cookbook</strong><br/><br/><strong>      Enter an optional description of your project.</strong><br/><br/><strong>      Project description: Demonstrating Apex with the Go Cookbook</strong><br/><br/><strong>      [+] creating IAM go-cookbook_lambda_function role</strong><br/><strong>      [+] creating IAM go-cookbook_lambda_logs policy</strong><br/><strong>      [+] attaching policy to lambda_function role.</strong><br/><strong>      [+] creating ./project.json</strong><br/><strong>      [+] creating ./functions</strong><br/><br/><strong>      Setup complete, deploy those functions!</strong><br/><br/><strong>      $ apex deploy</strong>
</pre>
<ol start="6">
<li>Remove the <kbd>lambda/functions/hello</kbd> directory.</li>
<li>Create a new <kbd>lambda/functions/greeter/main.go</kbd> file with the following content:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "encoding/json"<br/>            "fmt"<br/><br/>            "github.com/apex/go-apex"<br/>        )<br/><br/>        type message struct {<br/>            Name string `json:"name"`<br/>        }<br/><br/>        func main() {<br/>            apex.HandleFunc(func(event json.RawMessage, ctx <br/>            *apex.Context) (interface{}, error) {<br/>                var m message<br/>                if err := json.Unmarshal(event, &amp;m); err != nil {<br/>                    return nil, err<br/>                }<br/><br/>                resp := map[string]string{<br/>                    "greeting": fmt.Sprintf("Hello, %s", m.Name),<br/>                }<br/><br/>                return resp, nil<br/>            })<br/>        }
</pre>
<ol start="8">
<li>To test your function, you can run the following:</li>
</ol>
<pre>
<strong>      $ echo '{"event":{"name": "test"}}' | go run </strong><br/><strong>      functions/greeter1/main.go </strong><br/><br/><strong>      {"value":{"greeting":"Hello, test"}}</strong>
</pre>
<ol start="9">
<li>Deploy it to your specified region:</li>
</ol>
<pre>
<strong>      $apex deploy</strong><br/><strong>      • creating function env= function=greeter</strong><br/><strong>      • created alias current env= function=greeter version=1</strong><br/><strong>      • function created env= function=greeter name=go-</strong><br/><strong>        cookbook_greeter1 version=1</strong>
</pre>
<ol start="10">
<li>To invoke it, run the following command:</li>
</ol>
<pre>
<strong>      $ echo '{"name": "test"}' | apex invoke greeter</strong><br/><strong>      {"greeting":"Hello, test"}</strong>
</pre>
<ol start="11">
<li>Now modify <kbd>lambda/functions/greeter/main.go</kbd>:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "encoding/json"<br/>            "fmt"<br/><br/>            "github.com/apex/go-apex"<br/>        )<br/><br/>        type message struct {<br/>            FirstName string `json:"first_name"`<br/>            LastName string `json:"last_name"`<br/>        }<br/><br/>        func main() {<br/>            apex.HandleFunc(func(event json.RawMessage, ctx <br/>            *apex.Context) (interface{}, error) {<br/>                var m message<br/>                if err := json.Unmarshal(event, &amp;m); err != nil {<br/>                    return nil, err<br/>                }<br/><br/>                resp := map[string]string{<br/>                    "greeting": fmt.Sprintf("Hello, %s %s", <br/>                    m.FirstName, m.LastName),<br/>                }<br/><br/>                return resp, nil<br/>            })<br/>        }
</pre>
<ol start="12">
<li>Redeploy, creating version 2:</li>
</ol>
<pre>
<strong>      $ apex deploy </strong><br/><strong>      • creating function env= function=greeter</strong><br/><strong>      • created alias current env= function=greeter version=2</strong><br/><strong>      • function created env= function=greeter name=go-</strong><br/><strong>        cookbook_greeter1 version=2</strong>
</pre>
<ol start="13">
<li>Invoke the newly deployed function:</li>
</ol>
<pre>
<strong>      $ echo '{"first_name": "Go", "last_name": "Coders"}' | apex <br/>      invoke </strong><strong>greeter2</strong><br/><strong>      {"greeting":"Hello, Go Coders"}</strong>
</pre>
<ol start="14">
<li>Take a look at the logs:</li>
</ol>
<pre>
<strong>      $ apex logs greeter</strong><br/><strong>      apex logs greeter</strong><br/><strong>      /aws/lambda/go-cookbook_greeter START RequestId: 7c0f9129-3830-</strong><br/><strong>      11e7-8755-75aeb52a51b9 Version: 2</strong><br/><strong>      /aws/lambda/go-cookbook_greeter END RequestId: 7c0f9129-3830-</strong><br/><strong>      11e7-8755-75aeb52a51b9</strong><br/><strong>      /aws/lambda/go-cookbook_greeter REPORT RequestId: 7c0f9129-3830-</strong><br/><strong>      11e7-8755-75aeb52a51b9 Duration: 93.84 ms Billed Duration: 100 ms </strong><br/><strong>      Memory Size: 128 MB Max Memory Used: 19 MB</strong> 
</pre>
<ol start="15">
<li>Clean up the deployed services:</li>
</ol>
<pre>
<strong>      $ apex delete</strong><br/><strong>      The following will be deleted:</strong><br/><br/><strong>      - greeter</strong><br/><br/><strong>      Are you sure? (yes/no) yes</strong><br/><strong>      • deleting env= function=greeter</strong><br/><strong>      • function deleted env= function=greeter</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>AWS Lambda makes it easy to run functions on demand without maintaining a server. Apex provides facilities for deploying, versioning, and testing functions as you ship them to Lambda. It also provides a shim that allows us to execute arbitrary Go code. This is accomplished by defining a handler, processing incoming request payloads, and returning a response, which is a very similar flow to a standard web handler.</p>
<p>In this recipe, we initially took a name input and greeted that name. Later, we split the name into a first and last name, taking advantage of versioning. It would also be possible to deploy a separate function instead. It's possible to roll back with <kbd>apex rollback greeter</kbd> as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Apex serverless logging and metrics</h1>
                </header>
            
            <article>
                
<p>When working with serverless functions such as Lambda, it is valuable to have portable, structured logs. In addition, you can combine earlier recipes dealing with logging to this recipe. The recipes covered in <a href="e501e4de-b31e-447a-8109-6eee1a7f3a57.xhtml">Chapter 4</a>, <em>Error Handling in Go</em>, are just as relevant. Because we're using Apex to handle our lambda functions, we chose to use the Apex logger for this recipe. We'll also rely on metrics provided by Apex as well as the AWS console. The earlier recipes explored more complex logging and metrics examples, and those still apply--the Apex logger can easily be configured to aggregate logs using something like Amazon Kinesis or Elasticsearch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Refer to the <em>Getting ready</em> section of the <em>Go programming on Lambda with Apex</em> recipe in this chapter.</li>
<li>Run the <strong><kbd>go get github.com/apex/log</kbd></strong> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter12/logging</kbd> directory and navigate to it.</li>
<li>Create an Amazon account and an IAM role that can edit lambda functions, which can be done at <a href="https://aws.amazon.com/lambda/">https://aws.amazon.com/lambda/</a>.</li>
<li>Create a <kbd>~/.aws/credentials</kbd> file with the following content, copying your credentials from what you set up in the Amazon console:</li>
</ol>
<pre>
        [example]<br/>        aws_access_key_id = xxxxxxxx<br/>        aws_secret_access_key = xxxxxxxxxxxxxxxxxxxxxxxx
</pre>
<ol start="4">
<li>Create an environment variable to hold your desired region:</li>
</ol>
<pre>
        export AWS_REGION=us-west-2
</pre>
<ol start="5">
<li>Run the <kbd>apex init</kbd> command and follow the onscreen instructions:</li>
</ol>
<pre>
<strong>      $ apex init </strong><br/><br/><strong>      Enter the name of your project. It should be machine-friendly, as </strong><br/><strong>      this is used to prefix your functions in Lambda.</strong><br/><br/><strong>      Project name: logging </strong><br/><br/><strong>      Enter an optional description of your project.</strong><br/><br/><strong>      Project description: An example of apex logging and metrics</strong><br/><br/><strong>      [+] creating IAM logging_lambda_function role</strong><br/><strong>      [+] creating IAM logging_lambda_logs policy</strong><br/><strong>      [+] attaching policy to lambda_function role.</strong><br/><strong>      [+] creating ./project.json</strong><br/><strong>      [+] creating ./functions</strong><br/><br/><strong>      Setup complete, deploy those functions!</strong><br/><br/><strong>      $ apex deploy</strong>
</pre>
<ol start="6">
<li>Remove the <kbd>lambda/functions/hello</kbd> directory.</li>
<li>Create a new <kbd>lambda/functions/secret/main.go</kbd> file with the following content:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "encoding/json"<br/>            "os"<br/><br/>            "github.com/apex/go-apex"<br/>            "github.com/apex/log"<br/>            "github.com/apex/log/handlers/text"<br/>        )<br/><br/>        // Input takes in a secret<br/>        type Input struct {<br/>            Secret string `json:"secret"`<br/>        }<br/><br/>        func main() {<br/>            apex.HandleFunc(func(event json.RawMessage, ctx <br/>            *apex.Context) (interface{}, error) {<br/>                log.SetHandler(text.New(os.Stderr))<br/><br/>                var input Input<br/>                if err := json.Unmarshal(event, &amp;input); err != nil {<br/>                    log.WithError(err).Error("failed to unmarshal key <br/>                    input")<br/>                    return nil, err<br/>                }<br/>                log.WithField("secret", input.Secret).Info("secret <br/>                guessed")<br/><br/>                if input.Secret == "klaatu barada nikto" {<br/>                    return "secret guessed!", nil<br/>                }<br/>                return "try again", nil<br/>            })<br/>        }
</pre>
<ol start="8">
<li>Deploy it to your specified region:</li>
</ol>
<pre>
<strong>      $ apex deploy</strong><br/><strong>      • creating function env= function=secret</strong><br/><strong>      • created alias current env= function=secret version=1</strong><br/><strong>      • function created env= function=secret name=logging_secret </strong><br/><strong>        version=1</strong>
</pre>
<ol start="9">
<li>To invoke it, run the following command:</li>
</ol>
<pre>
<strong>      $ echo '{"secret": "open sesame"}' | apex invoke secret</strong><br/><strong>      "try again"</strong><br/><br/><strong>      $ echo '{"secret": "open sesame"}' | apex invoke secret</strong><br/><strong>      "secret guessed!"</strong>
</pre>
<ol start="10">
<li>Check the logs:</li>
</ol>
<pre>
<strong>      $ apex logs secret</strong><br/><strong>      /aws/lambda/logging_secret START RequestId: cfa6f655-3834-11e7-</strong><br/><strong>      b99d-89998a7f39dd Version: 1</strong><br/><strong>      /aws/lambda/logging_secret INFO[0000] secret guessed secret=open </strong><br/><strong>      sesame</strong><br/><strong>      /aws/lambda/logging_secret END RequestId: cfa6f655-3834-11e7-</strong><br/><strong>      b99d-89998a7f39dd</strong><br/><strong>      /aws/lambda/logging_secret REPORT RequestId: cfa6f655-3834-11e7-</strong><br/><strong>      b99d-89998a7f39dd Duration: 52.23 ms Billed Duration: 100 ms </strong><br/><strong>      Memory Size: 128 MB Max Memory Used: 19 MB </strong><br/><strong>      /aws/lambda/logging_secret START RequestId: d74ea688-3834-11e7-</strong><br/><strong>      aa4e-d592c1fbc35f Version: 1</strong><br/><strong>      /aws/lambda/logging_secret INFO[0012] secret guessed </strong><br/><strong>      secret=klaatu barada nikto</strong><br/><strong>      /aws/lambda/logging_secret END RequestId: d74ea688-3834-11e7-</strong><br/><strong>      aa4e-d592c1fbc35f</strong><br/><strong>      /aws/lambda/logging_secret REPORT RequestId: d74ea688-3834-11e7-</strong><br/><strong>      aa4e-d592c1fbc35f Duration: 7.43 ms Billed Duration: 100 ms </strong><br/><strong>      Memory Size: 128 MB Max Memory Used: 19 MB</strong> 
</pre>
<ol start="11">
<li>Check your metrics:</li>
</ol>
<pre>
<strong>      $ apex metrics secret !3445</strong><br/><br/><strong>      secret</strong><br/><strong>      total cost: $0.00</strong><br/><strong>      invocations: 0 ($0.00)</strong><br/><strong>      duration: 0s ($0.00)</strong><br/><strong>      throttles: 0</strong><br/><strong>      errors: 0</strong><br/><strong>      memory: 128</strong>
</pre>
<ol start="12">
<li>Clean up the deployed services:</li>
</ol>
<pre>
<strong>      $ apex delete</strong><br/><strong>      Are you sure? (yes/no) yes</strong><br/><strong>      • deleting env= function=secret</strong><br/><strong>      • function deleted env= function=secret</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a new lambda function, secret, that will respond with whether or not you guessed a secret phrase. The function parses an incoming JSON request, performs some logging using <kbd>Stderr</kbd>, and returns a response.</p>
<p>After using the function a few times, we see that our logs are visible using the <kbd>apex logs</kbd> command. This command can be run on a single lambda function or across all of our managed functions. This is especially useful if you are chaining Apex commands together and want to watch logs across many services.</p>
<p>In addition, we show how to use the apex metrics command to collect general metrics about your application, including cost and invocations. You can also see a lot of this information directly in the AWS console in the Lambda section. Like other recipes, we try and clean up after ourselves at the end.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Google App Engine with Go</h1>
                </header>
            
            <article>
                
<p>App Engine is a Google service that facilitates the quick deployment of web applications. These applications have access to cloud storage and various other Google APIs. The general idea is that App Engine will scale easily with load and simplify any operations management associated with hosting an app. This recipe will show how to create and optionally deploy a basic App Engine application. This recipe won't get into the details of setting up a Google cloud account, setting up billing, or the specifics on cleaning up your instance. At a minimum, access to Google Cloud Datastore (<a href="https://cloud.google.com/datastore/docs/concepts/overview">https://cloud.google.com/datastore/docs/concepts/overview</a>) is required for this recipe to work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application.</li>
<li>Navigate to your <kbd>GOPATH/src</kbd> and create a project directory, for example, <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>. All code will be run and modified from this directory.</li>
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/...</kbd> command.</li>
<li>Download the Google Cloud SDK from <a href="https://cloud.google.com/appengine/docs/flexible/go/quickstart">https://cloud.google.com/appengine/docs/flexible/go/quickstart</a>.</li>
<li>Create an app that allows for deploying and datastore access and record the app name.</li>
<li>Run the <kbd>go get cloud.google.com/go/datastore</kbd> command.</li>
<li>Run the <kbd>go get google.golang.org/appengine</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter12/appengine</kbd> directory and navigate to it.</li>
<li>Copy tests from <kbd>https://github.com/agtorre/go-cookbook/tree/master/chapter12/appengine</kbd> or use this as an exercise to write some of your own.</li>
<li>Create a file called <kbd>app.yml</kbd> with the following content, replacing <kbd>go-cookbook</kbd> with the name of the app you created in the <em>Getting ready</em> section:</li>
</ol>
<pre>
        runtime: go<br/>        env: flex<br/><br/>        #[START env_variables]<br/>        env_variables:<br/>            GCLOUD_DATASET_ID: go-cookbook<br/>        #[END env_variables]
</pre>
<ol start="4">
<li>Create a file called <kbd>message.go</kbd> with the following content:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "context"<br/>            "time"<br/><br/>            "cloud.google.com/go/datastore"<br/>        )<br/><br/>        // Message is the object we store<br/>        type Message struct {<br/>            Timestamp time.Time<br/>            Message string<br/>        }<br/><br/>        func (c *Controller) storeMessage(ctx context.Context, message <br/>        string) error {<br/>            m := &amp;Message{<br/>                Timestamp: time.Now(),<br/>                Message: message,<br/>            }<br/><br/>            k := datastore.IncompleteKey("Message", nil)<br/>            _, err := c.store.Put(ctx, k, m)<br/>            return err<br/>        }<br/><br/>        func (c *Controller) queryMessages(ctx context.Context, limit <br/>        int) ([]*Message, error) {<br/>            q := datastore.NewQuery("Message").<br/>            Order("-Timestamp").<br/>            Limit(limit)<br/><br/>            messages := make([]*Message, 0)<br/>            _, err := c.store.GetAll(ctx, q, &amp;messages)<br/>            return messages, err<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>controller.go</kbd> with the following content:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "context"<br/>            "fmt"<br/>            "log"<br/>            "net/http"<br/><br/>            "cloud.google.com/go/datastore"<br/>        )<br/><br/>        // Controller holds our storage and other<br/>        // state<br/>        type Controller struct {<br/>            store *datastore.Client<br/>        }<br/><br/>        func (c *Controller) handle(w http.ResponseWriter, r <br/>        *http.Request) {<br/>            if r.Method != http.MethodGet {<br/>                http.Error(w, "invalid method", <br/>                http.StatusMethodNotAllowed)<br/>            }<br/><br/>            ctx := context.Background()<br/><br/>            // store the new message<br/>            r.ParseForm()<br/>            if message := r.FormValue("message"); message != "" {<br/>                if err := c.storeMessage(ctx, message); err != nil {<br/>                    log.Printf("could not store message: %v", err)<br/>                    http.Error(w, fmt.Sprintf("could not store <br/>                    message"), <br/>                    http.StatusInternalServerError)<br/>                    return<br/>                }<br/>            }<br/><br/>            // get the current messages and display them<br/>            fmt.Fprintln(w, "Messages:")<br/>            messages, err := c.queryMessages(ctx, 10)<br/>            if err != nil {<br/>                log.Printf("could not get messages: %v", err)<br/>                http.Error(w, "could not get messages", <br/>                http.StatusInternalServerError)<br/>                return<br/>            }<br/><br/>            for _, message := range messages {<br/>                fmt.Fprintln(w, message.Message)<br/>            }<br/>        }
</pre>
<ol start="6">
<li>Create a file <kbd>main.go</kbd> with the following content:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "log"<br/>            "net/http"<br/>            "os"<br/><br/>            "cloud.google.com/go/datastore"<br/>            "golang.org/x/net/context"<br/>            "google.golang.org/appengine"<br/>        )<br/><br/>        func main() {<br/>            ctx := context.Background()<br/>            log.SetOutput(os.Stderr)<br/><br/>            // Set this in app.yaml when running in production.<br/>            projectID := os.Getenv("GCLOUD_DATASET_ID")<br/><br/>            datastoreClient, err := datastore.NewClient(ctx, projectID)<br/>            if err != nil {<br/>                log.Fatal(err)<br/>            }<br/><br/>            c := Controller{datastoreClient}<br/><br/>            http.HandleFunc("/", c.handle)<br/>            appengine.Main()<br/>        }
</pre>
<ol start="7">
<li>Run the <kbd>gcloud config set project go-cookbook</kbd> command, where <kbd>go-cookbook</kbd> is the project you created in the <em>Getting ready</em> section.</li>
<li>Run the <kbd>gcloud auth application-default login</kbd> command and follow the instructions.</li>
<li>Run the <kbd>export PORT=8080</kbd> command.</li>
<li>Run the <kbd>export GCLOUD_DATASET_ID=go-cookbook</kbd> command, <span>where <kbd>go-cookbook</kbd> is the project you created in the <em>Getting ready</em> section.</span></li>
<li>Run the <kbd>go build</kbd> command.</li>
<li>Run the <kbd>./example</kbd> command.</li>
<li>Navigate to <a href="http://localhost:8080/?message=hello%20there">http://localhost:8080/?message=hello%20there</a>.</li>
<li>Try a few more messages (<kbd>?message=other</kbd><span>)</span></li>
<li>Optionally, deploy the app to your instance with <kbd>gcloud app deploy</kbd>.</li>
<li>Navigate to the deployed app with <kbd>gcloud app browse</kbd>.</li>
<li>Clean up your appengine instance and datastore:
<ul>
<li><a href="https://console.cloud.google.com/datastore">https://console.cloud.google.com/datastore</a></li>
<li><a href="https://console.cloud.google.com/appengine">https://console.cloud.google.com/appengine</a></li>
</ul>
</li>
<li>If you copied or wrote your own tests, run the <kbd>go test</kbd> command. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Once the cloud SDK is configured to point at your application and has been authenticated, the GCloud tool allows quick deployment and configuration, allowing local applications to access Google services.</p>
<p>After authenticating and setting the port, we run the application on localhost, and we can begin working with code. The application defines a message object that can be stored and retrieved from the datastore. This demonstrates how you might isolate this sort of code. You might also use a storage/database interface, as shown in earlier chapters.</p>
<p>Next, we set up a handler that attempts to insert a message into the datastore, then retrieves all messages, displaying them in a browser. This creates something resembling a basic guestbook. You may notice that the message does not always appear immediately. If you navigate without a message parameter or send another message, it should appear on a reload.</p>
<p>Lastly, ensure that you clean up instances if you're no longer using them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Firebase using zabawaba99/firego</h1>
                </header>
            
            <article>
                
<p>Firebase is another Google cloud service that creates a scalable, easy-to-manage database that can support authentication and works especially well with mobile applications. The service provides significantly more than what will be covered in this recipe, but we will look at storing data, reading it, modifying it, and restoring it. We'll also look into how to set up authentication for your application and wrap the Firebase client with our own custom client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment according to these steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/installand">https://golang.org/doc/installand</a> and configure your <strong><kbd>GOPATH</kbd></strong> environment variable.</li>
<li>Open a terminal/console application.</li>
<li>Navigate to your <kbd>GOPATH/src</kbd> and create a project directory, for example, <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>. All code will be run and modified from this directory.</li>
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/...</kbd> command.</li>
<li>Create an account and database at <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a>.</li>
<li>Generate a service admin token from <a href="https://console.firebase.google.com/project/go-cookbook/settings/serviceaccounts/adminsdk">https://console.firebase.google.com/project/go-cookbook/settings/serviceaccounts/adminsdk</a>.</li>
<li>Move the downloaded token to <kbd>/tmp/service_account.json</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter12/firebase</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter12/firebase">https://github.com/agtorre/go-cookbook/tree/master/chapter12/firebase</a> or use this as an exercise to write some of your own.</li>
<li>Create a file called <kbd>client.go</kbd> with the following content:</li>
</ol>
<pre>
        package firebase<br/><br/>        import (<br/>            "log"<br/><br/>            "gopkg.in/zabawaba99/firego.v1"<br/>        )<br/><br/>        // Client Interface for mocking<br/>        type Client interface {<br/>            Get() (map[string]interface{}, error)<br/>            Set(key string, value interface{}) error<br/>        }<br/>        type firebaseClient struct {<br/>            *firego.Firebase<br/>        }<br/><br/>        func (f *firebaseClient) Get() (map[string]interface{}, error) <br/>        {<br/>            var v2 map[string]interface{}<br/>            if err := f.Value(&amp;v2); err != nil {<br/>                log.Fatalf("error getting")<br/>            }<br/>            return v2, nil<br/>        }<br/><br/>        func (f *firebaseClient) Set(key string, value interface{}) <br/>        error {<br/>            v := map[string]interface{}{key: value}<br/>            if err := f.Firebase.Set(v); err != nil {<br/>                return err<br/>            }<br/>            return nil<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>auth.go</kbd> with the following contents. Tweak <strong><a href="https://go-cookbook.firebaseio.com">https://go-cookbook.firebaseio.com</a></strong> to match whatever your apps, name is:</li>
</ol>
<pre>
        package firebase<br/><br/>        import (<br/>            "io/ioutil"<br/><br/>            "golang.org/x/oauth2"<br/>            "golang.org/x/oauth2/google"<br/>            "gopkg.in/zabawaba99/firego.v1"<br/>        )<br/><br/>        // Authenticate grabs oauth scopes using a generated<br/>        // service_account.json file from<br/>        // https://console.firebase.google.com/project/go-<br/>        cookbook/settings/serviceaccounts/adminsdk<br/>        func Authenticate() (Client, error) {<br/>            d, err := ioutil.ReadFile("/tmp/service_account.json")<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/><br/>            conf, err := google.JWTConfigFromJSON(d, <br/>            "https://www.googleapis.com/auth/userinfo.email",<br/>            "https://www.googleapis.com/auth/firebase.database")<br/>            if err != nil {<br/>                return nil, err<br/>            }<br/>            f := firego.New("https://go-cookbook.firebaseio.com", <br/>            conf.Client(oauth2.NoContext))<br/>            return &amp;firebaseClient{f}, err<br/>        }
</pre>
<ol start="5">
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a file named <kbd>main.go</kbd> with the following content. Ensure that you modify the <kbd>channels</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "log"<br/><br/>            "github.com/agtorre/go-cookbook/chapter12/firebase"<br/>        )<br/><br/>        func main() {<br/>            f, err := firebase.Authenticate()<br/>            if err != nil {<br/>                log.Fatalf("error authenticating")<br/>            }<br/>            f.Set("key", []string{"val1", "val2"})<br/>            res, _ := f.Get()<br/>            fmt.Println(res)<br/><br/>            vals := res["key"].([]interface{})<br/>            vals = append(vals, map[string][]string{"key2": <br/>            []string{"val3"}})<br/>            f.Set("key", vals)<br/>            res, _ = f.Get()<br/>            fmt.Println(res)<br/>        }
</pre>
<ol start="7">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run <kbd>go build ./example</kbd>.</li>
</ol>
<p style="padding-left: 60px"><span>You should now see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      map[key:[val1 val2]]</strong><br/><strong>      map[key:[val1 val2 map[key2:[val3]]]]</strong>
</pre>
<ol start="9">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Firebase uses OAuth2 for authentication. In this case, we downloaded a credentials file that can be used, along with a request for appropriate scopes, to return a token that may work with the Firebase database. We can store any sort of structured map-like object. In this case, we store <kbd>map[string]interface{}</kbd>.</p>
<p>The client code wraps all operations in an interface for ease of testing. This is a common pattern when writing client code and is also used in other recipes.</p>


            </article>

            
        </section>
    </body></html>