<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Performance Improvements, Tips, and Tricks</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Speeding up compilation and testing cycles</li>
<li>Using the pprof tool</li>
<li>Benchmarking and finding bottlenecks</li>
<li>Memory allocation and heap management</li>
<li>Vendoring and project layout</li>
<li>Using fasthttprouter and fasthttp</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>This chapter will focus on optimizing an application, discovering bottlenecks, and vendoring dependencies. These are some tips and tricks that can be used immediately by existing applications. Many of these recipes are necessary if you or your organization require fully reproducible builds. They're also useful when you want to benchmark an applications' performance. The final recipe focuses on increasing the speed of HTTP, however, it's always important to remember that the web world moves quickly, and it's important to refresh yourself on best practices. For example, if you require HTTP/2, it is now available using the built-in Go <kbd>net/http</kbd> package since version 1.6.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Speeding up compilation and testing cycles</h1>
                </header>
            
            <article>
                
<p>There are a few reasons why an application might be slow to compile, and by extension, run tests against. Usually, this is a combination requiring the application to compile from scratch every time (no intermediate builds), large code bases, and many dependencies. This recipe will explore some tools that can be used to look at the current dependency lists and to speed up compilation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment by performing the following steps:</p>
<ol>
<li>Download and install Go on your operating system from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> and configure your <kbd>GOPATH</kbd> environment variable.</li>
<li>Open a terminal/console application.</li>
<li>Navigate to your <kbd>GOPATH/src</kbd> directory and create a project directory, for example, <kbd>$GOPATH/src/github.com/yourusername/customrepo</kbd>.</li>
</ol>
<p style="padding-left: 60px">All code will be run and modified from this directory.</p>
<ol start="4">
<li>Optionally, install the latest tested version of the code using the <kbd>go get github.com/agtorre/go-cookbook/</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>To demonstrate how go build performance can degrade, either remove your <kbd>pkg</kbd> directory by running the <kbd>rm -rf $GOPATH/pkg/</kbd> <span class="s3">command</span> or set up a new <kbd>GOPATH</kbd> for this recipe. Ensure that <kbd>$GOPATH</kbd> is set.</li>
<li>Build the <kbd>github.com/agtorre/go-cookbook/chapter6/grpc/server</kbd><strong><br/></strong>package by running the <kbd>cd $GOPATH/src/github.com/agtorre/go-cookbook/chapter6/grpc/server</kbd> command.</li>
<li>Run the <kbd>time go build</kbd> command:</li>
</ol>
<pre>
<strong>      $ time go build .</strong><br/><strong>      go build 4.10s user 0.59s system 181% cpu 2.580 total</strong>
</pre>
<ol start="4">
<li>Test the <kbd>github.com/agtorre/go-cookbook/chapter6/grpc/server</kbd> package using the following command:</li>
</ol>
<pre>
<strong>      $ time go test</strong><br/><strong>      PASS</strong><br/><strong>      ok github.com/agtorre/go-cookbook/chapter6/grpc/server 0.014s</strong><br/><strong>      go test 4.01s user 0.60s system 176% cpu 2.608 total</strong>
</pre>
<ol start="5">
<li>Explore what's causing the 4-second builds; it doesn't appear to be the size of our project:</li>
</ol>
<pre>
<strong>      $ wc -l *.go</strong><br/><strong>      25 greeter.go</strong><br/><strong>      44 greeter_test.go</strong><br/><strong>      20 server.go</strong><br/><strong>      89 total</strong>
</pre>
<ol start="6">
<li>List all imports:</li>
</ol>
<pre>
<strong>      $ go list -f '{{ join .Imports "\n"}}'</strong><br/><strong>      fmt</strong><br/><strong>      github.com/agtorre/go-cookbook/chapter6/grpc/greeter</strong><br/><strong>      golang.org/x/net/context</strong><br/><strong>      google.golang.org/grpc</strong><br/><strong>      net</strong><br/><br/><strong>      $go list -f '{{ join .Imports "\n"}}' github.com/agtorre/go-</strong><br/><strong>      cookbook/chapter6/grpc/greeter</strong><br/><strong>      fmt</strong><br/><strong>      github.com/golang/protobuf/proto</strong><br/><strong>      golang.org/x/net/context</strong><br/><strong>      google.golang.org/grpc</strong><br/><strong>      math</strong>
</pre>
<ol start="7">
<li>List dependencies instead; check the number. Note the difference when compared to an empty <kbd>main.go</kbd> file:</li>
</ol>
<pre>
<strong>      $ go list -f '{{ join .Deps "\n"}}' . </strong><br/><strong>      .</strong><br/><strong>      .</strong><br/><strong>      .</strong><br/><strong>      google.golang.org/grpc</strong><br/><strong>      google.golang.org/grpc/codes</strong><br/><strong>      google.golang.org/grpc/credentials</strong><br/><strong>      google.golang.org/grpc/grpclog</strong><br/><strong>      google.golang.org/grpc/internal</strong><br/><strong>      google.golang.org/grpc/metadata</strong><br/><strong>      google.golang.org/grpc/naming</strong><br/><strong>      google.golang.org/grpc/peer</strong><br/><strong>      google.golang.org/grpc/stats</strong><br/><strong>      google.golang.org/grpc/tap</strong><br/><strong>      google.golang.org/grpc/transport</strong><br/><strong>      .</strong><br/><strong>      .</strong><br/><strong>      .</strong><br/><br/><strong>      $ go list -f '{{ join .Deps "\n"}}' . | wc -l </strong><br/><strong>      111</strong><br/><br/><strong>      $ go list -f '{{ join .Deps "\n"}}' /path/to/empty/main/package | </strong><br/><strong>      wc -l</strong><br/><strong>      4</strong>
</pre>
<ol start="8">
<li>Speed it up:</li>
</ol>
<pre>
<strong>      $ cd $GOPATH/src/github.com/agtorre/go-</strong><br/><strong>      cookbook/chapter6/grpc/server</strong><br/><strong>      $ go install ./...</strong><br/><strong>      $ go test -i ./...</strong>
</pre>
<ol start="9">
<li>Try running the following commands again:</li>
</ol>
<pre>
<strong>      $ time go build .</strong><br/><strong>      go build . 0.65s user 0.15s system 117% cpu 0.683 total</strong><br/><br/><strong>      $ time go test .</strong><br/><strong>      ok github.com/agtorre/go-cookbook/chapter6/grpc/server 0.015s</strong><br/><strong>      go test . 0.63s user 0.17s system 118% cpu 0.669 total</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If you're experiencing slow Go compilation speed, there are a few things to consider. Firstly, Go 1.5 was the first Go compile written entirely in Go. This came with a large increase in compilation times, and every release since has improved this. If you're working with Go 1.5 or later, your first step should be upgrading to the latest version of Go.</p>
<p>Next, some analysis of dependencies can be critical. Some go packages have large dependency changes, and you may unknowingly be adding hundreds of thousands of lines of code with a single import. It's worthwhile analyzing your dependencies. This is possible with the Go list tool, but there are also third-party tools, including the new dep (<a href="https://github.com/golang/dep">https://github.com/golang/dep</a>), godep (<a href="https://github.com/tools/godep">https://github.com/tools/godep</a>), and glide (<a href="https://github.com/Masterminds/glide">https://github.com/Masterminds/glide</a>), and most vendor repositories will place all dependencies in the vendor directory.</p>
<p>Lastly, saving intermediate builds of libraries can often give a significant boost. This is accomplished with the <kbd>go install ./...</kbd> and <kbd>go test -i ./...</kbd> commands, which will create artifacts in the <kbd>pkg</kbd> directory. The <kbd>install</kbd> command does this for imported packages, and <kbd>go test -i</kbd> does the same for test packages. This can be useful if you're using a framework such as <kbd>goconvey</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the pprof tool</h1>
                </header>
            
            <article>
                
<p>The pprof tools allows Go applications to collect and export runtime profiling data. It also provides web hooks to access the tool from a web interface. This recipe will create a basic application that verifies a bcrypt hashed password against a plaintext one, then it will profile the application.</p>
<p>You might expect the pprof tool to be in the <a href="c869fa02-b731-4966-a966-0b7e996f242a.xhtml">Chapter 10</a>, <em>Distributed Systems</em>,with other metrics and monitoring recipes. It was instead put in this chapter because it will be used to analyze and improve a program much in the same way benchmarking can be used. As a result, this recipe will largely focus on pprof for analyzing and improving the memory usage of an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment by performing these steps:</p>
<ol>
<li>Refer to the <em>Getting ready</em> section of the <em>Speeding up compilation and testing cycles</em> recipe in this chapter.</li>
<li>Optionally, install Graphviz from <a href="http://www.graphviz.org/Home.php">http://www.graphviz.org/Home.php</a>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create and navigate to the <kbd>chapter13/pprof</kbd> directory.</li>
<li>Copy tests from <strong><a href="https://github.com/agtorre/go-cookbook/tree/master/chapter13/pprof">https://github.com/agtorre/go-cookbook/tree/master/chapter13/pprof</a><br/></strong>or use this as an exercise to write some of your own code.</li>
<li>Create a directory named <kbd>crypto</kbd> and navigate to it.</li>
<li>Create a file called <kbd>handler.go</kbd> with the following content:</li>
</ol>
<pre>
        package crypto<br/><br/>        import (<br/>            "net/http"<br/><br/>            "golang.org/x/crypto/bcrypt"<br/>        )<br/><br/>        // GuessHandler checks if ?message=password<br/>        func GuessHandler(w http.ResponseWriter, r *http.Request) {<br/>            r.ParseForm()<br/><br/>            msg := r.FormValue("message")<br/><br/>            // "password"<br/>            real := <br/>            []byte("$2a$10$2ovnPWuIjMx2S0HvCxP/mutzdsGhyt8rq/<br/>            JqnJg/6OyC3B0APMGlK")<br/><br/>            if err := bcrypt.CompareHashAndPassword(real, []byte(msg)); <br/>            err != nil {<br/>                w.WriteHeader(http.StatusBadRequest)<br/>                w.Write([]byte("try again"))<br/>                return<br/>            }<br/><br/>            w.WriteHeader(http.StatusOK)<br/>            w.Write([]byte("you got it"))<br/>            return<br/>        }
</pre>
<ol start="5">
<li>Navigate up a directory.</li>
<li>Create a new directory named <kbd>example</kbd> and navigate to it.</li>
<li>Create a <kbd>main.go</kbd> file with the following content. Ensure that you modify the <kbd>crypto</kbd> import to use the path you set up in step 2:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "log"<br/>            "net/http"<br/>            _ "net/http/pprof"<br/><br/>            "github.com/agtorre/go-cookbook/chapter13/pprof/crypto"<br/>        )<br/><br/>        func main() {<br/><br/>            http.HandleFunc("/guess", crypto.GuessHandler)<br/>            fmt.Println("server started at localhost:8080")<br/>            log.Panic(http.ListenAndServe("localhost:8080", nil))<br/>        }
</pre>
<ol start="8">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following command:</li>
</ol>
<pre>
<strong>      go build<br/></strong><strong>      ./example</strong>
</pre>
<p style="padding-left: 60px"><span>You should now see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      server started at localhost:8080</strong>
</pre>
<ol start="10">
<li>In a separate terminal, run the following:</li>
</ol>
<pre>
<strong>      $ go tool pprof http://localhost:8080/debug/pprof/profile</strong>
</pre>
<ol start="11">
<li>This will start a 30 second timer.</li>
</ol>
<ol start="12">
<li>Run several curls while <kbd>pprof</kbd> runs:</li>
</ol>
<pre>
<strong>      $ curl "http://localhost:8080/guess?message=test"</strong><br/><strong>      try again</strong><br/><br/><strong>      $curl "http://localhost:8080/guess?message=password" </strong><br/><strong>      you got it</strong><br/><br/><strong>      .</strong><br/><strong>      .</strong><br/><strong>      .</strong><br/><strong>      .</strong><br/><br/><strong>      $curl "http://localhost:8080/guess?message=password" </strong><br/><strong>      you got it</strong>  
</pre>
<ol start="13">
<li>Return to the <kbd>pprof</kbd> command and wait for it to complete.</li>
<li>Run the <kbd>top10</kbd> command from the <kbd>pprof</kbd> command:</li>
</ol>
<pre>
<strong>      (pprof) top 10</strong><br/><strong>      930ms of 930ms total ( 100%)</strong><br/><strong>      Showing top 10 nodes out of 15 (cum &gt;= 930ms)</strong><br/><strong>      flat flat% sum% cum cum%</strong><br/><strong>      870ms 93.55% 93.55% 870ms 93.55% </strong><br/><strong>      golang.org/x/crypto/blowfish.encryptBlock</strong><br/><strong>      30ms 3.23% 96.77% 900ms 96.77% </strong><br/><strong>      golang.org/x/crypto/blowfish.ExpandKey</strong><br/><strong>      30ms 3.23% 100% 30ms 3.23% runtime.memclrNoHeapPointers</strong><br/><strong>      0 0% 100% 930ms 100% github.com/agtorre/go-</strong><br/><strong>      cookbook/chapter13/pprof/crypto.GuessHandler</strong><br/><strong>      0 0% 100% 930ms 100% </strong><br/><strong>      golang.org/x/crypto/bcrypt.CompareHashAndPassword</strong><br/><strong>      0 0% 100% 30ms 3.23% golang.org/x/crypto/bcrypt.base64Encode</strong><br/><strong>      0 0% 100% 930ms 100% golang.org/x/crypto/bcrypt.bcrypt</strong><br/><strong>      0 0% 100% 900ms 96.77% </strong><br/><strong>      golang.org/x/crypto/bcrypt.expensiveBlowfishSetup</strong><br/><strong>      0 0% 100% 930ms 100% net/http.(*ServeMux).ServeHTTP</strong><br/><strong>      0 0% 100% 930ms 100% net/http.(*conn).serve</strong>
</pre>
<ol start="15">
<li>If you installed Graphviz, run the <kbd>pprof web</kbd> command. You should see something like this:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="531" width="477" class="image-border" src="assets/58ea20d4-c074-4591-9b44-5685f316c916.png"/></div>
<ol start="16">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The pprof tool provides a lot of runtime information about your application. Using the <kbd>net/pprof</kbd> package is usually the most simple to configure--all that's required is listening on a port and doing an import.</p>
<p>In our case, we wrote a handler that uses a very compute-heavy applications (bcrypt) so that we can demonstrate how they pop up when profiling with pprof. This will quickly isolate chunks of code that are creating bottlenecks in your application.</p>
<p>We chose to collect a general profile that causes pprof to poll our application endpoint for 30 seconds. We then generated traffic against the endpoint to help produce results. This can be helpful when you're attempting to check a single handler or branch of code.</p>
<p>Lastly, we looked at the top 10 functions in terms of CPU utilization. It's also possible to look at memory/heap management with the <kbd>pprof http://localhost:8080/debug/pprof/heap</kbd> <span class="s1">command. The</span> <kbd>pprof web</kbd> <span class="s1">command can be used to look at a visualization of your</span> CPU/memory <span class="s1">profile and helps highlight more active code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benchmarking and finding bottlenecks</h1>
                </header>
            
            <article>
                
<p>Another method for determining slow parts of code is to use benchmarks. Benchmarks can be used to test functions for average performance and can also run benchmarks in parallel. This can be useful when comparing functions or doing micro-optimizations for certain code, especially to see how a function implementation might perform when using it concurrently. For this recipe, we'll create two structs that both implement an atomic counter. The first will use the <kbd>sync</kbd> package, and the other will use <kbd>sync/atomic</kbd>. We'll then benchmark both the solutions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Refer to the <em>Getting ready</em> section of the <em>Speeding up compilation and testing cycles</em> recipe in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter13/bench</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter13/bench">https://github.com/agtorre/go-cookbook/tree/master/chapter13/bench</a> or use this as an exercise to write some of your own code.</li>
</ol>
<div class="packt_infobox">Note that copied tests also include benchmarks written later in this recipe.</div>
<ol start="3">
<li>Create a file called <kbd>lock.go</kbd> with the following content:</li>
</ol>
<pre>
        package bench<br/><br/>        import "sync"<br/><br/>        // Counter uses a sync.RWMutex to safely<br/>        // modify a value<br/>        type Counter struct {<br/>            value int64<br/>            mu *sync.RWMutex<br/>        }<br/><br/>        // Add increments the counter<br/>        func (c *Counter) Add(amount int64) {<br/>            c.mu.Lock()<br/>            c.value += amount<br/>            c.mu.Unlock()<br/>        }<br/><br/>        // Read returns the current counter amount<br/>        func (c *Counter) Read() int64 {<br/>            c.mu.RLock()<br/>            defer c.mu.RUnlock()<br/>            return c.value<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>atomic.go</kbd> with the following content:</li>
</ol>
<pre>
        package bench<br/><br/>        import "sync/atomic"<br/><br/>        // AtomicCounter implements an atmoic lock<br/>        // using the atomic package<br/>        type AtomicCounter struct {<br/>            value int64<br/>        }<br/><br/>        // Add increments the counter<br/>        func (c *AtomicCounter) Add(amount int64) {<br/>            atomic.AddInt64(&amp;c.value, amount)<br/>        }<br/><br/>        // Read returns the current counter amount<br/>        func (c *AtomicCounter) Read() int64 {<br/>            var result int64<br/>            result = atomic.LoadInt64(&amp;c.value)<br/>            return result<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>lock_test.go</kbd> with the following content:</li>
</ol>
<pre>
        package bench<br/><br/>        import "testing"<br/><br/>        func BenchmarkCounterAdd(b *testing.B) {<br/>            c := Counter{0, &amp;sync.RWMutex{}}<br/>            for n := 0; n &lt; b.N; n++ {<br/>                c.Add(1)<br/>            }<br/>        }<br/><br/>        func BenchmarkCounterRead(b *testing.B) {<br/>            c := Counter{0, &amp;sync.RWMutex{}}<br/>            for n := 0; n &lt; b.N; n++ {<br/>                c.Read()<br/>            }<br/>        }<br/><br/>        func BenchmarkCounterAddRead(b *testing.B) {<br/>            c := Counter{0, &amp;sync.RWMutex{}}<br/>            b.RunParallel(func(pb *testing.PB) {<br/>                for pb.Next() {<br/>                    c.Add(1)<br/>                    c.Read()<br/>                }<br/>            })<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>atomic_test.go</kbd> with the following content:</li>
</ol>
<pre>
        package bench<br/><br/>        import "testing"<br/><br/>        func BenchmarkAtomicCounterAdd(b *testing.B) {<br/>            c := AtomicCounter{0}<br/>            for n := 0; n &lt; b.N; n++ {<br/>                c.Add(1)<br/>            }<br/>        }<br/><br/>        func BenchmarkAtomicCounterRead(b *testing.B) {<br/>            c := AtomicCounter{0}<br/>            for n := 0; n &lt; b.N; n++ {<br/>                c.Read()<br/>            }<br/>        }<br/><br/>        func BenchmarkAtomicCounterAddRead(b *testing.B) {<br/>            c := AtomicCounter{0}<br/>            b.RunParallel(func(pb *testing.PB) {<br/>                for pb.Next() {<br/>                    c.Add(1)<br/>                    c.Read()<br/>                }<br/>            })<br/>        }
</pre>
<ol start="7">
<li>Run the <kbd>go test -bench1</kbd> command, and you will see the following output:</li>
</ol>
<pre>
<strong>      $ go test -bench . </strong><br/><strong>      BenchmarkAtomicCounterAdd-4 200000000 8.38 ns/op</strong><br/><strong>      BenchmarkAtomicCounterRead-4 1000000000 2.09 ns/op</strong><br/><strong>      BenchmarkAtomicCounterAddRead-4 50000000 24.5 ns/op</strong><br/><strong>      BenchmarkCounterAdd-4 50000000 34.8 ns/op</strong><br/><strong>      BenchmarkCounterRead-4 20000000 66.0 ns/op</strong><br/><strong>      BenchmarkCounterAddRead-4 10000000 146 ns/op</strong><br/><strong>      PASS</strong><br/><strong>      ok github.com/agtorre/go-cookbook/chapter13/bench 10.919s</strong>
</pre>
<ol start="8">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe is an example of comparing a critical path of code. For example, sometimes your application must execute certain functionality often, maybe every call. In this case, we've written an atomic counter that can add or read values from multiple go routines.</p>
<p>The first solution uses <kbd>RWMutex</kbd> and <kbd>Lock</kbd> or <kbd>RLock</kbd> objects to write and read, respectively. The second uses the atomic package that provides the same functionality out of the box. We make the signatures of our functions the same, so benchmarks can be reused with minor modifications and so that either can satisfy the same atomic integer interface.</p>
<p>Lastly, we write standard benchmarks for adding values and reading them. Then, we write a parallel benchmark that calls the add and read functions. The parallel benchmark will create lot of lock contention, so we expect a slowdown. Perhaps unexpectedly, the atomic package significantly outperforms <kbd>RWMutex</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory allocation and heap management</h1>
                </header>
            
            <article>
                
<p>Some applications can benefit a lot from optimization. Consider routers, for example, which we'll look at in a later recipe. Fortunately, the tool benchmark suite provides flags to collect a number of memory allocations as well as memory allocation size. It can be helpful to tune certain critical code paths to minimize these two attributes.</p>
<p>This recipe will show two approaches to writing a function that glues together strings with a space, similar to <kbd>strings.Join("a", "b", "c")</kbd>. One approach will use concatenation, while the other will use the <kbd>strings</kbd> package. We'll then compare performance and memory allocations between the two.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Refer to the <em>Getting ready</em> section of the <em>Speeding up compilation and testing cycles</em> recipe in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter13/tuning</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter14/tuning">https://github.com/agtorre/go-cookbook/tree/master/chapter13/tuning</a> or use this as an exercise to write some of your own code.</li>
</ol>
<div class="packt_infobox">Note that copied tests also include benchmarks written later in this recipe.</div>
<ol start="3">
<li>Create a file called <kbd>concat.go</kbd> with the following content:</li>
</ol>
<pre>
        package tuning<br/><br/>        func concat(vals ...string) string {<br/>            finalVal := ""<br/>            for i := 0; i &lt; len(vals); i++ {<br/>                finalVal += vals[i]<br/>                if i != len(vals)-1 {<br/>                    finalVal += " "<br/>                }<br/>            }<br/>            return finalVal<br/>        }
</pre>
<ol start="4">
<li>Create a file called <kbd>join.go</kbd> with the following content:</li>
</ol>
<pre>
        package tuning<br/><br/>        import "strings"<br/><br/>        func join(vals ...string) string {<br/>            c := strings.Join(vals, " ")<br/>            return c<br/>        }
</pre>
<ol start="5">
<li>Create a file called <kbd>concat_test.go</kbd> with the following content:</li>
</ol>
<pre>
        package tuning<br/><br/>        import "testing"<br/><br/>        func Benchmark_concat(b *testing.B) {<br/>            b.Run("one", func(b *testing.B) {<br/>                one := []string{"1"}<br/>                for i := 0; i &lt; b.N; i++ {<br/>                    concat(one...)<br/>                }<br/>            })<br/>            b.Run("five", func(b *testing.B) {<br/>                five := []string{"1", "2", "3", "4", "5"}<br/>                for i := 0; i &lt; b.N; i++ {<br/>                    concat(five...)<br/>                }<br/>            })<br/><br/>            b.Run("ten", func(b *testing.B) {<br/>                ten := []string{"1", "2", "3", "4", "5",<br/>                "6", "7", "8", "9", "10"}<br/>                for i := 0; i &lt; b.N; i++ {<br/>                    concat(ten...)<br/>                }<br/>            })<br/>        }
</pre>
<ol start="6">
<li>Create a file called <kbd>join_test.go</kbd> with the following content:</li>
</ol>
<pre>
        package tuning<br/><br/>        import "testing"<br/><br/>        func Benchmark_join(b *testing.B) {<br/>            b.Run("one", func(b *testing.B) {<br/>                one := []string{"1"}<br/>                for i := 0; i &lt; b.N; i++ {<br/>                    join(one...)<br/>                }<br/>            })<br/>            b.Run("five", func(b *testing.B) {<br/>                five := []string{"1", "2", "3", "4", "5"}<br/>                for i := 0; i &lt; b.N; i++ {<br/>                    join(five...)<br/>                }<br/>            })<br/><br/>            b.Run("ten", func(b *testing.B) {<br/>                ten := []string{"1", "2", "3", "4", "5",<br/>                "6", "7", "8", "9", "10"}<br/>                    for i := 0; i &lt; b.N; i++ {<br/>                        join(ten...)<br/>                    }<br/>            })<br/>        }
</pre>
<ol start="7">
<li>Run the <kbd>GOMAXPROCS=1 go test -bench=. -benchmem -benchtime=1s</kbd> command and you will see the following output:</li>
</ol>
<pre>
<strong>      $ GOMAXPROCS=1 go test -bench=. -benchmem -benchtime=1s</strong><br/><strong>      Benchmark_concat/one 100000000 13.6 ns/op 0 B/op 0 allocs/op</strong><br/><strong>      Benchmark_concat/five 5000000 386 ns/op 48 B/op 8 allocs/op</strong><br/><strong>      Benchmark_concat/ten 2000000 992 ns/op 256 B/op 18 allocs/op</strong><br/><strong>      Benchmark_join/one 200000000 6.30 ns/op 0 B/op 0 allocs/op</strong><br/><strong>      Benchmark_join/five 10000000 124 ns/op 32 B/op 2 allocs/op</strong><br/><strong>      Benchmark_join/ten 10000000 183 ns/op 64 B/op 2 allocs/op</strong><br/><strong>      PASS</strong><br/><strong>      ok github.com/agtorre/go-cookbook/chapter13/tuning 12.003s</strong>
</pre>
<ol start="8">
<li>If you copied or wrote your own tests, go up one directory and run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Benchmarking helps us tune applications and do certain micro-optimizations for things such as memory allocations. When benchmarking allocations for applications with input, it's important to try a variety of input sizes to determine if it affects allocations. We wrote two functions, <kbd>concat</kbd> and <kbd>join</kbd>. Both join together a <kbd>variadic</kbd> string parameter with spaces, so the arguments (<em>a</em>, <em>b</em>, <em>c</em>) will return the string <em>a b c</em>.</p>
<p>The <kbd>concat</kbd> approach accomplishes this solely through string concatenation. We create a string and append the strings in the list and spaces in a <kbd>for</kbd> loop. We omit adding a space on the last loop. The <kbd>join</kbd> function uses the internal <kbd>Strings.Join</kbd> function to accomplish this far more efficiently in most cases. It can be helpful to benchmark standard library compared to your own functions to help better understand tradeoffs in performance, simplicity, and functionality.</p>
<p>We used sub-benchmarks to test all of our parameters, which also work excellently with table-driven benchmarks. We can see how the <kbd>concat</kbd> approach results in a lot more allocations than join, at least for single length inputs. A good exercise would be to try this with variable length input strings as well as number of arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vendoring and project layout</h1>
                </header>
            
            <article>
                
<p>Vendoring Go applications is still a largely unresolved issue. There are discussions and plans to produce an official vendoring solution (<a href="https://github.com/golang/dep">https://github.com/golang/dep</a>), but it's very early days and things are far from complete. For now, there are a number of alternative solutions. By default, you can place packages into a local vendor directory to use them instead of those in your <kbd>GOPATH</kbd> environment variable. This allows packages to pin on the version in their vendor directory and allows for reproducible builds without having to commit your entire <kbd>GOPATH</kbd> into version control. Most package managers take advantage of this. For this recipe, we'll explore the layout for a web application and how to manage its vendor dependencies with <kbd>godep</kbd> <a href="http://github.com/tools/godep">github.com/tools/godep</a>, a popular tool for managing dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment by performing these steps:</p>
<ol>
<li>Refer to the <em>Getting ready</em> section of the <em>Speeding up compilation and testing cycles</em> recipe in this chapter.</li>
<li>Run the <kbd>go get github.com/tools/godep</kbd> command.</li>
<li>Run the <kbd>go get github.com/sirupsen/logrus</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter13/vendoring</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter14/vendoring">https://github.com/agtorre/go-cookbook/tree/master/chapter13/vendoring</a><br/>
or use this as an exercise to write some of your own code.</li>
<li>Create a directory named <kbd>models</kbd> and navigate to it.</li>
</ol>
<ol start="4">
<li>Create a file called <kbd>models.go</kbd> with the following content:</li>
</ol>
<pre>
        package models<br/><br/>        import "sync/atomic"<br/><br/>        // DB Interface is our storage<br/>        // layer<br/>        type DB interface {<br/>            GetScore() (int64, error)<br/>            SetScore(int64) error<br/>        }<br/><br/>        // NewDB returns our db struct that<br/>        // satisfies DB interface<br/>        func NewDB() DB {<br/>            return &amp;db{0}<br/>        }<br/><br/>        type db struct {<br/>            score int64<br/>        }<br/><br/>        // GetScore returns the score atomically<br/>        func (d *db) GetScore() (int64, error) {<br/>            return atomic.LoadInt64(&amp;d.score), nil<br/>        }<br/><br/>        // SetScore stores a new value atomically<br/>        func (d *db) SetScore(score int64) error {<br/>            atomic.StoreInt64(&amp;d.score, score)<br/>            return nil<br/>        }
</pre>
<ol start="5">
<li>Navigate back up a directory.</li>
<li>Create a directory named <kbd>handlers</kbd> and navigate to it.</li>
<li>Create a file called <kbd>controller.go</kbd> with the following content:</li>
</ol>
<pre>
        package handlers<br/><br/>        import "github.com/agtorre/go-<br/>        cookbook/chapter13/vendoring/models"<br/><br/>        type Controller struct {<br/>            db models.DB<br/>        }<br/><br/>        func NewController(db models.DB) *Controller {<br/>            return &amp;Controller{db: db}<br/>        }<br/><br/>        type resp struct {<br/>            Status string `json:"status"`<br/>            Value int64 `json:"value"`<br/>        }
</pre>
<ol start="8">
<li>Create a file called <kbd>get.go</kbd> with the following content:</li>
</ol>
<pre>
        package handlers<br/><br/>        import (<br/>            "encoding/json"<br/>            "net/http"<br/><br/>            "github.com/sirupsen/logrus"<br/>        )<br/><br/>        // GetHandler returns the current score in a resp object<br/>        func (c *Controller) GetHandler(w http.ResponseWriter, r <br/>        *http.Request) {<br/>            enc := json.NewEncoder(w)<br/>            payload := resp{Status: "error"}<br/>            oldScore, err := c.db.GetScore()<br/>            if err != nil {<br/>                logrus.WithField("error", err).Error("failed to get the <br/>                score")<br/>                w.WriteHeader(http.StatusInternalServerError)<br/>                enc.Encode(&amp;payload)<br/>                return<br/>            }<br/>            w.WriteHeader(http.StatusOK)<br/>            payload.Value = oldScore<br/>            payload.Status = "ok"<br/>            enc.Encode(&amp;payload)<br/>        }
</pre>
<ol start="9">
<li>Create a file called <kbd>set.go</kbd> with the following content:</li>
</ol>
<pre>
        package handlers<br/><br/>        import (<br/>            "encoding/json"<br/>            "net/http"<br/>            "strconv"<br/><br/>            "github.com/sirupsen/logrus"<br/>        )<br/><br/>        // SetHandler Sets the value, and returns it in a resp<br/>        func (c *Controller) SetHandler(w http.ResponseWriter, r <br/>        *http.Request) {<br/>            enc := json.NewEncoder(w)<br/>            payload := resp{Status: "error"}<br/>            r.ParseForm()<br/>            val := r.FormValue("score")<br/>            score, err := strconv.ParseInt(val, 10, 64)<br/>            if err != nil {<br/>                logrus.WithField("error", err).Error("failed to parse <br/>                input")<br/>                w.WriteHeader(http.StatusBadRequest)<br/>                enc.Encode(&amp;payload)<br/>                return<br/>            }<br/><br/>            if err := c.db.SetScore(score); err != nil {<br/>                logrus.WithField("error", err).Error("failed to set the <br/>                score")<br/>                w.WriteHeader(http.StatusInternalServerError)<br/>                enc.Encode(&amp;payload)<br/>                return<br/>            }<br/>            w.WriteHeader(http.StatusOK)<br/>            payload.Value = score<br/>            payload.Status = "ok"<br/>            enc.Encode(&amp;payload)<br/>        }
</pre>
<ol start="10">
<li>Vendor your dependencies:</li>
</ol>
<pre>
<strong>      $ godep save ./...</strong><br/><strong>      $ cat Godeps/Godeps.json</strong><br/><strong>      {</strong><br/><strong>      "ImportPath": "github.com/agtorre/go-</strong><br/><strong>      cookbook/chapter13/vendoring",</strong><br/><strong>      "GoVersion": "go1.8",</strong><br/><strong>      "GodepVersion": "v79",</strong><br/><strong>      "Packages": [</strong><br/><strong>      "./..."</strong><br/><strong>      ],</strong><br/><strong>      "Deps": [</strong><br/><strong>      {</strong><br/><strong>      "ImportPath": "github.com/sirupsen/logrus",</strong><br/><strong>      "Comment": "v0.11.2-1-g3f603f4",</strong><br/><strong>      "Rev": "3f603f494d61c73457fb234161d8982b9f0f0b71"</strong><br/><strong>      },</strong><br/><strong>      {</strong><br/><strong>      "ImportPath": "golang.org/x/sys/unix",</strong><br/><strong>      "Rev": "dbc2be9168a660ef302e04b6ff6406de6f967473"</strong><br/><strong>      }</strong><br/><strong>      ]</strong><br/><strong>      }</strong>
</pre>
<ol start="11">
<li>Navigate up one directory.</li>
<li>Create a file called <kbd>main.go</kbd> with the following content:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "net/http"<br/> <br/>            "github.com/agtorre/go-<br/>            cookbook/chapter13/vendoring/handlers"<br/>            "github.com/agtorre/go-cookbook/chapter13/vendoring/models"<br/>            "github.com/sirupsen/logrus"<br/>        )<br/><br/>        func main() {<br/>            c := handlers.NewController(models.NewDB())<br/><br/>            logrus.SetFormatter(&amp;logrus.JSONFormatter{})<br/><br/>            http.HandleFunc("/get", c.GetHandler)<br/>            http.HandleFunc("/set", c.SetHandler)<br/>            fmt.Println("server started at localhost:8080")<br/>            panic(http.ListenAndServe("localhost:8080", nil))<br/>        }
</pre>
<ol start="13">
<li>Run <kbd>go run main.go</kbd>.</li>
<li>You may also run the following command:</li>
</ol>
<pre>
<strong>      go build</strong><br/><strong>      ./vendoring</strong>
</pre>
<p style="padding-left: 60px"><span>You should see the following output:</span></p>
<pre>
<strong>      $ go run main.go</strong><br/><strong>      server started at localhost:8080</strong>
</pre>
<ol start="15">
<li>In a separate terminal, run some curls:</li>
</ol>
<pre>
<strong>      $ curl "http://localhost:8080/set?score=24" </strong><br/><strong>      {"status":"ok","value":24}</strong><br/><br/><strong>      $ curl "http://localhost:8080/get"</strong><br/><strong>      {"status":"ok","value":24}</strong><br/><br/><strong>      $ curl "http://localhost:8080/set?score=abc" </strong><br/><strong>      {"status":"error","value":0}</strong>
</pre>
<ol start="16">
<li>Look at the server logs:</li>
</ol>
<pre>
<strong>      {"error":"strconv.ParseInt: parsing \"abc\": invalid </strong><br/><strong>      syntax","level":"error","msg":"failed to parse </strong><br/><strong>      input","time":"2017-05-26T20:49:47-07:00"}</strong>
</pre>
<ol start="17">
<li>If you copied or wrote your own tests, run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe shows how to separate basic concerns in an applications. For resources such as models or clients, it's good to first create an interface for what actions it will perform, then satisfy that interface and provide convenient setup functions. Model/client code will also frequently produce custom error types.</p>
<p>Next, we create our controller and handlers, which isolate all client requests to the server. The <kbd>Controller</kbd> object uses the storage interface, making it easy to swap storage solutions without modifying application code. Lastly, <kbd>main.go</kbd> is used to set up routes, initialize controllers, and configure things such as logging. We use a package-level global logger so that any of our methods can freely log if needed. We still try to log only when we're dealing with an error rather than whenever we encounter and quickly return one.</p>
<p>We used logrus as our logging system, which introduced a dependency that we'd like to vendor for ease of reproducible builds. We used the Godep tool to store a local copy of logrus in our vendor directory. Checkouts of this project will use the pinned version in vendors for future builds and it can be upgraded when ready.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using fasthttprouter and fasthttp</h1>
                </header>
            
            <article>
                
<p>Although the Go standard library provides everything you would need to run an HTTP server, sometimes you need to further optimize for things such as routing and request time. This recipe will explore a library that speeds up request handling called <kbd>fasthttp</kbd> (<a href="https://github.com/valyala/fasthttp">https://github.com/valyala/fasthttp</a>) and a router, that dramatically speeds up routing performance called <kbd>fasthttprouter</kbd> (<a href="https://github.com/buaazp/fasthttprouter">https://github.com/buaazp/fasthttprouter</a>). Although fasthttp is quick, it's important to note that it doesn't support HTTP/2 (<a href="https://github.com/valyala/fasthttp/issues/45">https://github.com/valyala/fasthttp/issues/45</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Configure your environment by performing these steps:</p>
<ol>
<li>Refer to the <em>Getting ready</em> section of the <em>Speeding up compilation and testing cycles</em> recipe in this chapter.</li>
<li>Run the <kbd>go get github.com/buaazp/fasthttprouter</kbd> command.</li>
<li>Run the <kbd>go get github.com/valyala/fasthttp</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>These steps cover writing and running your application:</p>
<ol>
<li>From your terminal/console application, create the <kbd>chapter13/fastweb</kbd> directory and navigate to it.</li>
<li>Copy tests from <a href="https://github.com/agtorre/go-cookbook/tree/master/chapter14/fastweb">https://github.com/agtorre/go-cookbook/tree/master/chapter13/fastweb</a> or use this as an exercise to write some of your own code.</li>
<li>Create a file called <kbd>items.go</kbd> with the following content:</li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "sync"<br/>        )<br/><br/>        var items []string<br/>        var mu *sync.RWMutex<br/><br/>        func init() {<br/>            mu = &amp;sync.RWMutex{}<br/>        }<br/><br/>        // AddItem adds an item to our list<br/>        // in a thread-safe way<br/>        func AddItem(item string) {<br/>            mu.Lock()<br/>            items = append(items, item)<br/>            mu.Unlock()<br/>        }<br/><br/>        // ReadItems returns our list of items<br/>        // in a thread-safe way<br/>        func ReadItems() []string {<br/>            mu.RLock()<br/>            defer mu.RUnlock()<br/>            return items<br/>        }
</pre>
<ol start="4">
<li><span>Create a file calle</span>d <kbd>handlers.go</kbd> with th<span>e following content:</span></li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "encoding/json"<br/><br/>            "github.com/valyala/fasthttp"<br/>        )<br/><br/>        // GetItems will return our items object<br/>        func GetItems(ctx *fasthttp.RequestCtx) {<br/>            enc := json.NewEncoder(ctx)<br/>            items := ReadItems()<br/>            enc.Encode(&amp;items)<br/>            ctx.SetStatusCode(fasthttp.StatusOK)<br/>        }<br/><br/>        // AddItems modifies our array<br/>        func AddItems(ctx *fasthttp.RequestCtx) {<br/>            item, ok := ctx.UserValue("item").(string)<br/>            if !ok {<br/>                ctx.SetStatusCode(fasthttp.StatusBadRequest)<br/>            }<br/><br/>            AddItem(item)<br/>            ctx.SetStatusCode(fasthttp.StatusOK)<br/>        }
</pre>
<ol start="5">
<li><span>Create a file call</span>ed <kbd>main.go</kbd> with t<span>he following content:</span></li>
</ol>
<pre>
        package main<br/><br/>        import (<br/>            "fmt"<br/>            "log"<br/><br/>            "github.com/buaazp/fasthttprouter"<br/>            "github.com/valyala/fasthttp"<br/>        )<br/><br/>        func main() {<br/>            router := fasthttprouter.New()<br/>            router.GET("/item", GetItems)<br/>            router.POST("/item/:item", AddItems)<br/><br/>            fmt.Println("server starting on localhost:8080")<br/>            log.Fatal(fasthttp.ListenAndServe("localhost:8080", <br/>            router.Handler))<br/>        }
</pre>
<ol start="6">
<li>Run the <kbd>go build</kbd> command.</li>
<li>Run the <kbd>./fastweb</kbd> command:</li>
</ol>
<pre>
<strong>      $ ./fastweb</strong><br/><strong>      server starting on localhost:8080</strong>
</pre>
<ol start="8">
<li>From a separate terminal, test it our with some curls:</li>
</ol>
<pre>
<strong>      $ curl "http://localhost:8080/item/hi" -X POST </strong><br/><br/><strong>      $ curl "http://localhost:8080/item/how" -X POST </strong><br/><br/><strong>      $ curl "http://localhost:8080/item/are" -X POST </strong><br/><br/><strong>      $ curl "http://localhost:8080/item/you" -X POST </strong><br/><br/><strong>      $ curl "http://localhost:8080/item" -X GET </strong><br/><strong>      ["hi","how", "are", "you"]</strong>
</pre>
<ol start="9">
<li>If you copied or wrote your own tests, run <kbd>go test</kbd>. Ensure that all the tests pass.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>fasthttp</kbd> and <kbd>fasthttprouter</kbd> packages can do a lot to speed up the life cycle of a web request. Both packages do a lot of optimization on the hot path of code, but with the unfortunate caveat of rewriting your handlers to use a new context object rather than traditional requests and response writer.</p>
<p>There are a number of frameworks that have taken a similar approach to routing, and some have directly incorporated <kbd>fasthttp</kbd>. These projects keep up-to-date information in their <kbd>README</kbd> files.</p>
<p>Our recipe implemented a simple list object that we can append to with one endpoint and that will be returned by the other. The primary purpose of this recipe is to demonstrate working with parameters, setting up a router that now explicitly defines the supported methods instead of the generic <kbd>Handle</kbd> and <kbd>HandleFunc</kbd>, and to show how similar it is to standard handlers, but with many other benefits.</p>


            </article>

            
        </section>
    </body></html>