["```go\n $ time go build .\n go build 4.10s user 0.59s system 181% cpu 2.580 total\n\n```", "```go\n $ time go test\n PASS\n ok github.com/agtorre/go-cookbook/chapter6/grpc/server 0.014s\n go test 4.01s user 0.60s system 176% cpu 2.608 total\n\n```", "```go\n $ wc -l *.go\n 25 greeter.go\n 44 greeter_test.go\n 20 server.go\n 89 total\n\n```", "```go\n $ go list -f '{{ join .Imports \"\\n\"}}'\n fmt\n github.com/agtorre/go-cookbook/chapter6/grpc/greeter\n golang.org/x/net/context\n google.golang.org/grpc\n net\n\n $go list -f '{{ join .Imports \"\\n\"}}' github.com/agtorre/go-\n cookbook/chapter6/grpc/greeter\n fmt\n github.com/golang/protobuf/proto\n golang.org/x/net/context\n google.golang.org/grpc\n math\n\n```", "```go\n $ go list -f '{{ join .Deps \"\\n\"}}' . \n .\n .\n .\n google.golang.org/grpc\n google.golang.org/grpc/codes\n google.golang.org/grpc/credentials\n google.golang.org/grpc/grpclog\n google.golang.org/grpc/internal\n google.golang.org/grpc/metadata\n google.golang.org/grpc/naming\n google.golang.org/grpc/peer\n google.golang.org/grpc/stats\n google.golang.org/grpc/tap\n google.golang.org/grpc/transport\n .\n .\n .\n\n $ go list -f '{{ join .Deps \"\\n\"}}' . | wc -l \n 111\n\n $ go list -f '{{ join .Deps \"\\n\"}}' /path/to/empty/main/package | \n wc -l\n 4\n\n```", "```go\n $ cd $GOPATH/src/github.com/agtorre/go-\n cookbook/chapter6/grpc/server\n $ go install ./...\n $ go test -i ./...\n\n```", "```go\n $ time go build .\n go build . 0.65s user 0.15s system 117% cpu 0.683 total\n\n $ time go test .\n ok github.com/agtorre/go-cookbook/chapter6/grpc/server 0.015s\n go test . 0.63s user 0.17s system 118% cpu 0.669 total\n\n```", "```go\n        package crypto\n\n        import (\n            \"net/http\"\n\n            \"golang.org/x/crypto/bcrypt\"\n        )\n\n        // GuessHandler checks if ?message=password\n        func GuessHandler(w http.ResponseWriter, r *http.Request) {\n            r.ParseForm()\n\n            msg := r.FormValue(\"message\")\n\n            // \"password\"\n            real := \n            []byte(\"$2a$10$2ovnPWuIjMx2S0HvCxP/mutzdsGhyt8rq/\n            JqnJg/6OyC3B0APMGlK\")\n\n            if err := bcrypt.CompareHashAndPassword(real, []byte(msg)); \n            err != nil {\n                w.WriteHeader(http.StatusBadRequest)\n                w.Write([]byte(\"try again\"))\n                return\n            }\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(\"you got it\"))\n            return\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"log\"\n            \"net/http\"\n            _ \"net/http/pprof\"\n\n            \"github.com/agtorre/go-cookbook/chapter13/pprof/crypto\"\n        )\n\n        func main() {\n\n            http.HandleFunc(\"/guess\", crypto.GuessHandler)\n            fmt.Println(\"server started at localhost:8080\")\n            log.Panic(http.ListenAndServe(\"localhost:8080\", nil))\n        }\n\n```", "```go\n go build ./example\n\n```", "```go\n $ go run main.go\n server started at localhost:8080\n\n```", "```go\n $ go tool pprof http://localhost:8080/debug/pprof/profile\n\n```", "```go\n $ curl \"http://localhost:8080/guess?message=test\"\n try again\n\n $curl \"http://localhost:8080/guess?message=password\" \n you got it\n\n .\n .\n .\n .\n\n $curl \"http://localhost:8080/guess?message=password\" \n you got it  \n\n```", "```go\n (pprof) top 10\n 930ms of 930ms total ( 100%)\n Showing top 10 nodes out of 15 (cum >= 930ms)\n flat flat% sum% cum cum%\n 870ms 93.55% 93.55% 870ms 93.55% \n golang.org/x/crypto/blowfish.encryptBlock\n 30ms 3.23% 96.77% 900ms 96.77% \n golang.org/x/crypto/blowfish.ExpandKey\n 30ms 3.23% 100% 30ms 3.23% runtime.memclrNoHeapPointers\n 0 0% 100% 930ms 100% github.com/agtorre/go-\n cookbook/chapter13/pprof/crypto.GuessHandler\n 0 0% 100% 930ms 100% \n golang.org/x/crypto/bcrypt.CompareHashAndPassword\n 0 0% 100% 30ms 3.23% golang.org/x/crypto/bcrypt.base64Encode\n 0 0% 100% 930ms 100% golang.org/x/crypto/bcrypt.bcrypt\n 0 0% 100% 900ms 96.77% \n golang.org/x/crypto/bcrypt.expensiveBlowfishSetup\n 0 0% 100% 930ms 100% net/http.(*ServeMux).ServeHTTP\n 0 0% 100% 930ms 100% net/http.(*conn).serve\n\n```", "```go\n        package bench\n\n        import \"sync\"\n\n        // Counter uses a sync.RWMutex to safely\n        // modify a value\n        type Counter struct {\n            value int64\n            mu *sync.RWMutex\n        }\n\n        // Add increments the counter\n        func (c *Counter) Add(amount int64) {\n            c.mu.Lock()\n            c.value += amount\n            c.mu.Unlock()\n        }\n\n        // Read returns the current counter amount\n        func (c *Counter) Read() int64 {\n            c.mu.RLock()\n            defer c.mu.RUnlock()\n            return c.value\n        }\n\n```", "```go\n        package bench\n\n        import \"sync/atomic\"\n\n        // AtomicCounter implements an atmoic lock\n        // using the atomic package\n        type AtomicCounter struct {\n            value int64\n        }\n\n        // Add increments the counter\n        func (c *AtomicCounter) Add(amount int64) {\n            atomic.AddInt64(&c.value, amount)\n        }\n\n        // Read returns the current counter amount\n        func (c *AtomicCounter) Read() int64 {\n            var result int64\n            result = atomic.LoadInt64(&c.value)\n            return result\n        }\n\n```", "```go\n        package bench\n\n        import \"testing\"\n\n        func BenchmarkCounterAdd(b *testing.B) {\n            c := Counter{0, &sync.RWMutex{}}\n            for n := 0; n < b.N; n++ {\n                c.Add(1)\n            }\n        }\n\n        func BenchmarkCounterRead(b *testing.B) {\n            c := Counter{0, &sync.RWMutex{}}\n            for n := 0; n < b.N; n++ {\n                c.Read()\n            }\n        }\n\n        func BenchmarkCounterAddRead(b *testing.B) {\n            c := Counter{0, &sync.RWMutex{}}\n            b.RunParallel(func(pb *testing.PB) {\n                for pb.Next() {\n                    c.Add(1)\n                    c.Read()\n                }\n            })\n        }\n\n```", "```go\n        package bench\n\n        import \"testing\"\n\n        func BenchmarkAtomicCounterAdd(b *testing.B) {\n            c := AtomicCounter{0}\n            for n := 0; n < b.N; n++ {\n                c.Add(1)\n            }\n        }\n\n        func BenchmarkAtomicCounterRead(b *testing.B) {\n            c := AtomicCounter{0}\n            for n := 0; n < b.N; n++ {\n                c.Read()\n            }\n        }\n\n        func BenchmarkAtomicCounterAddRead(b *testing.B) {\n            c := AtomicCounter{0}\n            b.RunParallel(func(pb *testing.PB) {\n                for pb.Next() {\n                    c.Add(1)\n                    c.Read()\n                }\n            })\n        }\n\n```", "```go\n $ go test -bench . \n BenchmarkAtomicCounterAdd-4 200000000 8.38 ns/op\n BenchmarkAtomicCounterRead-4 1000000000 2.09 ns/op\n BenchmarkAtomicCounterAddRead-4 50000000 24.5 ns/op\n BenchmarkCounterAdd-4 50000000 34.8 ns/op\n BenchmarkCounterRead-4 20000000 66.0 ns/op\n BenchmarkCounterAddRead-4 10000000 146 ns/op\n PASS\n ok github.com/agtorre/go-cookbook/chapter13/bench 10.919s\n\n```", "```go\n        package tuning\n\n        func concat(vals ...string) string {\n            finalVal := \"\"\n            for i := 0; i < len(vals); i++ {\n                finalVal += vals[i]\n                if i != len(vals)-1 {\n                    finalVal += \" \"\n                }\n            }\n            return finalVal\n        }\n\n```", "```go\n        package tuning\n\n        import \"strings\"\n\n        func join(vals ...string) string {\n            c := strings.Join(vals, \" \")\n            return c\n        }\n\n```", "```go\n        package tuning\n\n        import \"testing\"\n\n        func Benchmark_concat(b *testing.B) {\n            b.Run(\"one\", func(b *testing.B) {\n                one := []string{\"1\"}\n                for i := 0; i < b.N; i++ {\n                    concat(one...)\n                }\n            })\n            b.Run(\"five\", func(b *testing.B) {\n                five := []string{\"1\", \"2\", \"3\", \"4\", \"5\"}\n                for i := 0; i < b.N; i++ {\n                    concat(five...)\n                }\n            })\n\n            b.Run(\"ten\", func(b *testing.B) {\n                ten := []string{\"1\", \"2\", \"3\", \"4\", \"5\",\n                \"6\", \"7\", \"8\", \"9\", \"10\"}\n                for i := 0; i < b.N; i++ {\n                    concat(ten...)\n                }\n            })\n        }\n\n```", "```go\n        package tuning\n\n        import \"testing\"\n\n        func Benchmark_join(b *testing.B) {\n            b.Run(\"one\", func(b *testing.B) {\n                one := []string{\"1\"}\n                for i := 0; i < b.N; i++ {\n                    join(one...)\n                }\n            })\n            b.Run(\"five\", func(b *testing.B) {\n                five := []string{\"1\", \"2\", \"3\", \"4\", \"5\"}\n                for i := 0; i < b.N; i++ {\n                    join(five...)\n                }\n            })\n\n            b.Run(\"ten\", func(b *testing.B) {\n                ten := []string{\"1\", \"2\", \"3\", \"4\", \"5\",\n                \"6\", \"7\", \"8\", \"9\", \"10\"}\n                    for i := 0; i < b.N; i++ {\n                        join(ten...)\n                    }\n            })\n        }\n\n```", "```go\n $ GOMAXPROCS=1 go test -bench=. -benchmem -benchtime=1s\n Benchmark_concat/one 100000000 13.6 ns/op 0 B/op 0 allocs/op\n Benchmark_concat/five 5000000 386 ns/op 48 B/op 8 allocs/op\n Benchmark_concat/ten 2000000 992 ns/op 256 B/op 18 allocs/op\n Benchmark_join/one 200000000 6.30 ns/op 0 B/op 0 allocs/op\n Benchmark_join/five 10000000 124 ns/op 32 B/op 2 allocs/op\n Benchmark_join/ten 10000000 183 ns/op 64 B/op 2 allocs/op\n PASS\n ok github.com/agtorre/go-cookbook/chapter13/tuning 12.003s\n\n```", "```go\n        package models\n\n        import \"sync/atomic\"\n\n        // DB Interface is our storage\n        // layer\n        type DB interface {\n            GetScore() (int64, error)\n            SetScore(int64) error\n        }\n\n        // NewDB returns our db struct that\n        // satisfies DB interface\n        func NewDB() DB {\n            return &db{0}\n        }\n\n        type db struct {\n            score int64\n        }\n\n        // GetScore returns the score atomically\n        func (d *db) GetScore() (int64, error) {\n            return atomic.LoadInt64(&d.score), nil\n        }\n\n        // SetScore stores a new value atomically\n        func (d *db) SetScore(score int64) error {\n            atomic.StoreInt64(&d.score, score)\n            return nil\n        }\n\n```", "```go\n        package handlers\n\n        import \"github.com/agtorre/go-\n        cookbook/chapter13/vendoring/models\"\n\n        type Controller struct {\n            db models.DB\n        }\n\n        func NewController(db models.DB) *Controller {\n            return &Controller{db: db}\n        }\n\n        type resp struct {\n            Status string `json:\"status\"`\n            Value int64 `json:\"value\"`\n        }\n\n```", "```go\n        package handlers\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n\n            \"github.com/sirupsen/logrus\"\n        )\n\n        // GetHandler returns the current score in a resp object\n        func (c *Controller) GetHandler(w http.ResponseWriter, r \n        *http.Request) {\n            enc := json.NewEncoder(w)\n            payload := resp{Status: \"error\"}\n            oldScore, err := c.db.GetScore()\n            if err != nil {\n                logrus.WithField(\"error\", err).Error(\"failed to get the \n                score\")\n                w.WriteHeader(http.StatusInternalServerError)\n                enc.Encode(&payload)\n                return\n            }\n            w.WriteHeader(http.StatusOK)\n            payload.Value = oldScore\n            payload.Status = \"ok\"\n            enc.Encode(&payload)\n        }\n\n```", "```go\n        package handlers\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n            \"strconv\"\n\n            \"github.com/sirupsen/logrus\"\n        )\n\n        // SetHandler Sets the value, and returns it in a resp\n        func (c *Controller) SetHandler(w http.ResponseWriter, r \n        *http.Request) {\n            enc := json.NewEncoder(w)\n            payload := resp{Status: \"error\"}\n            r.ParseForm()\n            val := r.FormValue(\"score\")\n            score, err := strconv.ParseInt(val, 10, 64)\n            if err != nil {\n                logrus.WithField(\"error\", err).Error(\"failed to parse \n                input\")\n                w.WriteHeader(http.StatusBadRequest)\n                enc.Encode(&payload)\n                return\n            }\n\n            if err := c.db.SetScore(score); err != nil {\n                logrus.WithField(\"error\", err).Error(\"failed to set the \n                score\")\n                w.WriteHeader(http.StatusInternalServerError)\n                enc.Encode(&payload)\n                return\n            }\n            w.WriteHeader(http.StatusOK)\n            payload.Value = score\n            payload.Status = \"ok\"\n            enc.Encode(&payload)\n        }\n\n```", "```go\n $ godep save ./...\n $ cat Godeps/Godeps.json\n {\n \"ImportPath\": \"github.com/agtorre/go-\n cookbook/chapter13/vendoring\",\n \"GoVersion\": \"go1.8\",\n \"GodepVersion\": \"v79\",\n \"Packages\": [\n \"./...\"\n ],\n \"Deps\": [\n {\n \"ImportPath\": \"github.com/sirupsen/logrus\",\n \"Comment\": \"v0.11.2-1-g3f603f4\",\n \"Rev\": \"3f603f494d61c73457fb234161d8982b9f0f0b71\"\n },\n {\n \"ImportPath\": \"golang.org/x/sys/unix\",\n \"Rev\": \"dbc2be9168a660ef302e04b6ff6406de6f967473\"\n }\n ]\n }\n\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            \"github.com/agtorre/go-\n            cookbook/chapter13/vendoring/handlers\"\n            \"github.com/agtorre/go-cookbook/chapter13/vendoring/models\"\n            \"github.com/sirupsen/logrus\"\n        )\n\n        func main() {\n            c := handlers.NewController(models.NewDB())\n\n            logrus.SetFormatter(&logrus.JSONFormatter{})\n\n            http.HandleFunc(\"/get\", c.GetHandler)\n            http.HandleFunc(\"/set\", c.SetHandler)\n            fmt.Println(\"server started at localhost:8080\")\n            panic(http.ListenAndServe(\"localhost:8080\", nil))\n        }\n\n```", "```go\n go build\n ./vendoring\n\n```", "```go\n $ go run main.go\n server started at localhost:8080\n\n```", "```go\n $ curl \"http://localhost:8080/set?score=24\" \n {\"status\":\"ok\",\"value\":24}\n\n $ curl \"http://localhost:8080/get\"\n {\"status\":\"ok\",\"value\":24}\n\n $ curl \"http://localhost:8080/set?score=abc\" \n {\"status\":\"error\",\"value\":0}\n\n```", "```go\n {\"error\":\"strconv.ParseInt: parsing \\\"abc\\\": invalid \n syntax\",\"level\":\"error\",\"msg\":\"failed to parse \n input\",\"time\":\"2017-05-26T20:49:47-07:00\"}\n\n```", "```go\n        package main\n\n        import (\n            \"sync\"\n        )\n\n        var items []string\n        var mu *sync.RWMutex\n\n        func init() {\n            mu = &sync.RWMutex{}\n        }\n\n        // AddItem adds an item to our list\n        // in a thread-safe way\n        func AddItem(item string) {\n            mu.Lock()\n            items = append(items, item)\n            mu.Unlock()\n        }\n\n        // ReadItems returns our list of items\n        // in a thread-safe way\n        func ReadItems() []string {\n            mu.RLock()\n            defer mu.RUnlock()\n            return items\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"encoding/json\"\n\n            \"github.com/valyala/fasthttp\"\n        )\n\n        // GetItems will return our items object\n        func GetItems(ctx *fasthttp.RequestCtx) {\n            enc := json.NewEncoder(ctx)\n            items := ReadItems()\n            enc.Encode(&items)\n            ctx.SetStatusCode(fasthttp.StatusOK)\n        }\n\n        // AddItems modifies our array\n        func AddItems(ctx *fasthttp.RequestCtx) {\n            item, ok := ctx.UserValue(\"item\").(string)\n            if !ok {\n                ctx.SetStatusCode(fasthttp.StatusBadRequest)\n            }\n\n            AddItem(item)\n            ctx.SetStatusCode(fasthttp.StatusOK)\n        }\n\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"log\"\n\n            \"github.com/buaazp/fasthttprouter\"\n            \"github.com/valyala/fasthttp\"\n        )\n\n        func main() {\n            router := fasthttprouter.New()\n            router.GET(\"/item\", GetItems)\n            router.POST(\"/item/:item\", AddItems)\n\n            fmt.Println(\"server starting on localhost:8080\")\n            log.Fatal(fasthttp.ListenAndServe(\"localhost:8080\", \n            router.Handler))\n        }\n\n```", "```go\n $ ./fastweb\n server starting on localhost:8080\n\n```", "```go\n $ curl \"http://localhost:8080/item/hi\" -X POST \n\n $ curl \"http://localhost:8080/item/how\" -X POST \n\n $ curl \"http://localhost:8080/item/are\" -X POST \n\n $ curl \"http://localhost:8080/item/you\" -X POST \n\n $ curl \"http://localhost:8080/item\" -X GET \n [\"hi\",\"how\", \"are\", \"you\"]\n\n```"]