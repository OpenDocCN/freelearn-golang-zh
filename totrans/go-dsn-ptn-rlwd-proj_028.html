<html><head></head><body>
<div class="book" title="Go in a nutshell">
<div class="book" title="Interfaces"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch01lvl2sec16" class="calibre1"/>Interfaces</h2></div></div></div><p class="calibre10">Go supports the notion of a programmatic interface. However, as you will see in <a class="calibre1" title="Chapter 8. Methods, Interfaces, and Objects" href="part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 8</a>, <span class="strong"><em class="calibre11">Methods, Interfaces, and Objects</em></span>, the Go interface is itself a type that aggregates a set of methods that can project capabilities onto values of other types. Staying true to its simplistic nature, implementing a Go interface does not require a keyword to explicitly declare an interface. Instead, the type system implicitly resolves implemented interfaces using the methods attached to a type.</p><p class="calibre10">For instance, Go includes the built-in interface called <code class="email">Stringer</code>, defined as follows:</p><pre class="programlisting">type Stringer interface { 
    String() string 
} 
</pre><p class="calibre10">Any type that has the method <code class="email">String()</code> attached, automatically implements the <code class="email">Stringer</code> interface. So, modifying the definition of the type <code class="email">metalloid</code>, from the previous program, to attach the method <code class="email">String()</code> will automatically implement the <code class="email">Stringer</code> interface:</p><pre class="programlisting">type metalloid struct { 
    name string 
    number int32 
    weight amu 
} 
func (m metalloid) String() string { 
  return fmt.Sprintf( 
    "%-10s %-10d %-10.3f %e", 
    m.name, m.number, m.weight.float(), atoms(moles(m.weight)), 
  ) 
}  
</pre><p class="calibre10">golang.fyi/ch01/metalloids2.go</p><p class="calibre10">The <code class="email">String()</code> methods return a pre-formatted string that represents the value of a <code class="email">metalloid</code>. The function <code class="email">Print()</code>, from the standard library package <code class="email">fmt</code>, will automatically call the method <code class="email">String()</code>, if its parameter implements <code class="email">stringer</code>. So, we can use this fact to print <code class="email">metalloid</code> values as follow:</p><pre class="programlisting">func main() { 
  fmt.Print(headers()) 
  for _, m := range metalloids { 
    fmt.Print(m, "\n") 
  } 
} 
</pre><p class="calibre10">Again, refer to <a class="calibre1" title="Chapter 8. Methods, Interfaces, and Objects" href="part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 8</a>, <span class="strong"><em class="calibre11">Methods, Interfaces, and Objects</em></span>, for a thorough treatment of the topic of interfaces.</p></div></div></body></html>