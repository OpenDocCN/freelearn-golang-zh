<html><head></head><body>
<div class="book" title="Go in a nutshell">
<div class="book" title="Concurrency and channels"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch01lvl2sec17" class="calibre1"/>Concurrency and channels</h2></div></div></div><p class="calibre10">One of the main features that has rocketed Go to its current level of adoption is its inherent support for simple concurrency idioms. The language uses a unit of concurrency known as a <code class="email">goroutine</code>, which lets programmers structure programs with independent and highly concurrent code.</p><p class="calibre10">As you will see in the following example, Go also relies on a construct known as a channel used for both communication and coordination among independently running <code class="email">goroutines</code>. This approach avoids the perilous and (sometimes brittle) traditional approach of thread communicating by sharing memory. Instead, Go facilitates the approach of sharing by communicating using channels. This is illustrated in the following example that uses both <code class="email">goroutines</code> and channels as processing and communication primitives:</p><pre class="programlisting">// Calculates sum of all multiple of 3 and 5 less than MAX value. 
// See https://projecteuler.net/problem=1 
package main 
 
import ( 
  "fmt" 
) 
 
const MAX = 1000 
 
func main() { 
  work := make(chan int, MAX) 
  result := make(chan int) 
 
  // 1. Create channel of multiples of 3 and 5 
  // concurrently using goroutine 
  go func(){ 
    for i := 1; i &lt; MAX; i++ { 
      if (i % 3) == 0 || (i % 5) == 0 { 
        work &lt;- i // push for work 
      } 
    } 
    close(work)  
  }() 
 
  // 2. Concurrently sum up work and put result 
  //    in channel result  
  go func(){ 
    r := 0 
    for i := range work { 
      r = r + i 
    } 
    result &lt;- r 
  }() 
 
  // 3. Wait for result, then print 
  fmt.Println("Total:", &lt;- result) 
} 
</pre><p class="calibre10">golang.fyi/ch01/euler1.go</p><p class="calibre10">The code in the previous example splits the work to be done between two concurrently running <code class="email">goroutines</code> (declared with the <code class="email">go</code> keyword) as annotated in the code comment. Each <code class="email">goroutine</code> runs independently and uses the Go channels, <code class="email">work</code> and <code class="email">result</code>, to communicate and coordinate the calculation of the final result. Again, if this code does not make sense at all, rest assured, concurrency has the whole of <a class="calibre1" title="Chapter 9. Concurrency" href="part0061_split_000.html#1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 9</a>, <span class="strong"><em class="calibre11">Concurrency</em></span>, dedicated to it.</p></div></div></body></html>