- en: Concurrency and channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main features that has rocketed Go to its current level of adoption
    is its inherent support for simple concurrency idioms. The language uses a unit
    of concurrency known as a `goroutine`, which lets programmers structure programs
    with independent and highly concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see in the following example, Go also relies on a construct known
    as a channel used for both communication and coordination among independently
    running `goroutines`. This approach avoids the perilous and (sometimes brittle)
    traditional approach of thread communicating by sharing memory. Instead, Go facilitates
    the approach of sharing by communicating using channels. This is illustrated in
    the following example that uses both `goroutines` and channels as processing and
    communication primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch01/euler1.go
  prefs: []
  type: TYPE_NORMAL
- en: The code in the previous example splits the work to be done between two concurrently
    running `goroutines` (declared with the `go` keyword) as annotated in the code
    comment. Each `goroutine` runs independently and uses the Go channels, `work`
    and `result`, to communicate and coordinate the calculation of the final result.
    Again, if this code does not make sense at all, rest assured, concurrency has
    the whole of [Chapter 9](part0061_split_000.html#1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 9. Concurrency"), *Concurrency*, dedicated to it.
  prefs: []
  type: TYPE_NORMAL
