- en: Memory management and safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to other compiled and statically-typed languages such as C and C++,
    Go lets developers have direct influence on memory allocation and layout. When
    a developer creates a `slice` (think `array`) of bytes, for instance, there is
    a direct representation of those bytes in the underlying physical memory of the
    machine. Furthermore, Go borrows the notion of pointers to represent the memory
    addresses of stored values giving Go programs the support of passing function
    parameters by both value and reference.
  prefs: []
  type: TYPE_NORMAL
- en: Go asserts a highly opinionated safety barrier around memory management with
    little to no configurable parameters. Go automatically handles the drudgery of
    bookkeeping for memory allocation and release using a runtime garbage collector.
    Pointer arithmetic is not permitted at runtime; therefore, developers cannot traverse
    memory blocks by adding to or subtracting from a base memory address.
  prefs: []
  type: TYPE_NORMAL
