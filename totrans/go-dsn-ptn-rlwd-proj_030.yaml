- en: Memory management and safety
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理和安全性
- en: Similar to other compiled and statically-typed languages such as C and C++,
    Go lets developers have direct influence on memory allocation and layout. When
    a developer creates a `slice` (think `array`) of bytes, for instance, there is
    a direct representation of those bytes in the underlying physical memory of the
    machine. Furthermore, Go borrows the notion of pointers to represent the memory
    addresses of stored values giving Go programs the support of passing function
    parameters by both value and reference.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编译型和静态类型语言，如C和C++类似，Go允许开发者直接影响内存分配和布局。例如，当开发者创建一个`slice`（可以想象成`array`）的字节数组时，这些字节在机器的底层物理内存中有一个直接的表示。此外，Go借鉴了指针的概念来表示存储值的内存地址，这使得Go程序可以通过值和引用两种方式传递函数参数。
- en: Go asserts a highly opinionated safety barrier around memory management with
    little to no configurable parameters. Go automatically handles the drudgery of
    bookkeeping for memory allocation and release using a runtime garbage collector.
    Pointer arithmetic is not permitted at runtime; therefore, developers cannot traverse
    memory blocks by adding to or subtracting from a base memory address.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go在内存管理周围设定了一个高度意见化的安全屏障，几乎没有可配置的参数。Go自动使用运行时垃圾回收器处理内存分配和释放的繁琐工作。在运行时不允许指针算术；因此，开发者不能通过向或从基本内存地址添加或减去来遍历内存块。
