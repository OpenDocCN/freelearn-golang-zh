- en: Chapter 3. Go Control Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Go 控制流
- en: 'Go borrows several of its control flow syntax from the C-family of languages.
    It supports all of the expected control structures, including `if...else`, `switch`,
    `for` loop, and even `goto`. Conspicuously absent, though, are `while` or `do...while`
    statements. The following topics in this chapter examine Go''s control flow elements,
    some of which you may already be familiar with, and others that bring a new set
    of functionalities not found in other languages:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 从 C 家族语言中借用了其控制流语法的大部分。它支持所有预期的控制结构，包括 `if...else`、`switch`、`for` 循环，甚至 `goto`。然而，`while`
    或 `do...while` 语句却明显缺失。本章以下内容将探讨 Go 的控制流元素，其中一些你可能已经熟悉，而其他则带来了一组在其他语言中找不到的新功能：
- en: The `if` statement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: The `switch` statement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: The type `Switch`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 `Switch`
- en: The `for` statement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 语句'
- en: The if statement
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: 'The `if` statement, in Go, borrows its basic structural form from other C-like
    languages. The statement conditionally executes a code block when the Boolean
    expression that follows the `if` keyword evaluates to `true`, as illustrated in
    the following abbreviated program, which displays information about world currencies:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 `if` 语句借鉴了其他 C 类似语言的基本结构形式。当跟在 `if` 关键字后面的布尔表达式评估为 `true` 时，该语句有条件地执行一个代码块，如下面的简化的程序所示，该程序显示有关世界货币的信息：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch03/ifstmt.go
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/ifstmt.go
- en: 'The `if` statement in Go looks similar to other languages. However, it sheds
    a few syntactic rules, while enforcing new ones:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 `if` 语句看起来与其他语言类似。然而，它省略了一些语法规则，同时强制执行新的规则：
- en: 'The parentheses around the test expression are not necessary. While the following
    `if` statement will compile, it is not idiomatic:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表达式的括号不是必需的。虽然以下 `if` 语句可以编译，但它不符合习惯用法：
- en: '[PRE1]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the following instead:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代替：
- en: '[PRE2]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The curly braces for the code block are always required. The following snippet
    will not compile:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块的括号总是必需的。以下片段将无法编译：
- en: '[PRE3]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, this will compile:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，这将编译：
- en: '[PRE4]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is idiomatic, however, to write the `if` statement on multiple lines (no
    matter how simple the statement block may be). This encourages good style and
    clarity. The following snippet will compile with no issues:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，将 `if` 语句写在一行或多行上（无论语句块多么简单）是习惯用法。这鼓励了良好的风格和清晰度。以下片段将无问题编译：
- en: '[PRE5]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, the preferred idiomatic layout for the statement is to use multiple
    lines, as follows:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，语句的推荐习惯布局是使用多行，如下所示：
- en: '[PRE6]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `if` statement may include an optional `else` block, which is executed
    when the expression in the `if` block evaluates to `false`. The code in the `else`
    block must be wrapped in curly braces using multiple lines, as shown in the following
    snippet:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句可以包含一个可选的 `else` 块，当 `if` 块中的表达式评估为 `false` 时执行。`else` 块中的代码必须使用多行括号包裹，如下面的片段所示：'
- en: '[PRE7]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `else` keyword may be immediately followed by another `if` statement forming
    an `if...else...if` chain, as used in the function `printCurr()` from the source
    code listed earlier:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else` 关键字可以立即跟在另一个 `if` 语句后面，形成一个 `if...else...if` 链，正如前面列出的源代码中的 `printCurr()`
    函数所使用的那样：'
- en: '[PRE8]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `if...else...if` statement chain can grow as long as needed and may be
    terminated by an optional `else` statement to express all other untested conditions.
    Again, this is done in the `printCurr()` function, which tests four conditions
    using the `if...else...if` blocks. Lastly, it includes an `else` statement block
    to catch any other untested conditions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else...if` 语句链可以按需增长，并且可以通过一个可选的 `else` 语句来终止，以表达所有其他未测试的条件。再次强调，这是在
    `printCurr()` 函数中完成的，该函数使用 `if...else...if` 块测试四个条件。最后，它包括一个 `else` 语句块来捕获任何其他未测试的条件：'
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Go, however, the idiomatic, and cleaner, way to write such a deep `if...else...if`
    code block is to use an expressionless `switch` statement. This is covered later,
    in the *Switch statement* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Go 中，编写这种深层次的 `if...else...if` 代码块的习惯用法，是使用无表达式的 `switch` 语句。这将在后面的 *Switch
    语句* 部分中介绍。
- en: The if statement initialization
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if` 语句的初始化'
- en: 'The `if` statement supports a composite syntax where the tested expression
    is preceded by an initialization statement. At runtime, the initialization is
    executed before the test expression is evaluated, as illustrated in this code
    snippet (from the program listed earlier):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句支持复合语法，其中测试表达式前面有一个初始化语句。在运行时，初始化在评估测试表达式之前执行，如下面的代码片段（来自前面列出的程序）所示：'
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The initialization statement follows normal variable declaration and initialization
    rules. The scope of the initialized variables is bound to the `if` statement block,
    beyond which they become unreachable. This is a commonly used idiom in Go and
    is supported in other flow control constructs covered in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句遵循正常的变量声明和初始化规则。初始化变量的作用域绑定到 `if` 语句块，超出此范围它们将变得不可达。这是 Go 中常用的一种惯用法，并且在本章中介绍的其他流程控制结构中也得到了支持。
- en: Switch statements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: 'Go also supports a `switch` statement similar to that found in other languages
    such as, C or Java. The `switch` statement in Go achieves multi-way branching
    by evaluating values or expressions from `case` clauses, as shown in the following,
    abbreviated, source code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还支持类似于 C 或 Java 等其他语言的 `switch` 语句。Go 中的 `switch` 语句通过评估 `case` 子句中的值或表达式来实现多路分支，如下所示，这是缩写的源代码：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch03/switchstmt.go
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt.go
- en: 'The `switch` statement in Go has some interesting properties and rules that
    make it easy to use and reason about:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 `switch` 语句有一些有趣的特性和规则，使得它易于使用和推理：
- en: 'Semantically, Go''s `switch` statement can be used in two contexts:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从语义上讲，Go 的 `switch` 语句可以在两个上下文中使用：
- en: An expression`switch` statement
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `switch` 语句
- en: A type`switch` statement
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 `switch` 语句
- en: The `break` statement can be used to escape out of a switch code block early.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `break` 语句提前退出 `switch` 代码块。
- en: The `switch` statement can include a default case when no other case expressions
    evaluate to a match. There can only be one default case and it may be placed anywhere
    within the switch block.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 语句可以包含一个默认情况，当没有其他情况表达式评估为匹配时。只能有一个默认情况，并且它可以放置在 `switch` 块内的任何位置。'
- en: Using expression switches
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表达式切换
- en: 'Expression switches are flexible and can be used in many contexts where control
    flow of a program needs to follow multiple path. An expression switch supports
    many attributes, as outlined in the following bullets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式切换非常灵活，可以在许多需要程序控制流遵循多个路径的上下文中使用。表达式切换支持许多属性，如下列要点所述：
- en: 'Expression switches can test values of any types. For instance, the following
    code snippet (from the previous program listing) tests variable `Curr` of type
    `struct`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式切换可以测试任何类型的值。例如，以下代码片段（来自前面的程序列表）测试了类型为 `struct` 的变量 `Curr`：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The expressions in `case` clauses are evaluated from left to right, top to bottom,
    until a value (or expression) is found that is equal to that of the `switch` expression.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case` 子句中的表达式从左到右、从上到下进行评估，直到找到一个与 `switch` 表达式相等的值（或表达式）。'
- en: Upon encountering the first case that matches the `switch` expression, the program
    will execute the statements for the `case` block and then immediately exit the
    `switch` block. Unlike other languages, the Go `case` statement does not need
    to use a break to avoid falling through the next case (see the *Fallthrough cases*
    section). For instance, calling `isDollar(Curr{"HKD", "Hong Kong Dollar", "Hong
    Kong", 344})` will match the second `case` statement in the preceding function.
    The code will set the result to `true` and exit the `switch` code block immediately.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当遇到第一个与 `switch` 表达式匹配的情况时，程序将执行 `case` 块中的语句，然后立即退出 `switch` 块。与其他语言不同，Go 的
    `case` 语句不需要使用 `break` 来避免跌入下一个情况（请参阅 *Fallthrough cases* 部分）。例如，调用 `isDollar(Curr{"HKD",
    "Hong Kong Dollar", "Hong Kong", 344})` 将匹配前面函数中的第二个 `case` 语句。代码将结果设置为 `true`
    并立即退出 `switch` 代码块。
- en: '`Case` clauses can have multiple values (or expressions) separated by commas
    with a logical `OR` operator implied between them. For instance, in the following
    snippet, the `switch` expression `curr` is tested against values `currencies[2]`,
    `currencies[4]`, or `currencies[10]`, using one case clause until a match is found:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Case` 子句可以有多个值（或表达式），它们之间用逗号分隔，并隐含逻辑 `OR` 操作符。例如，在以下代码片段中，`switch` 表达式 `curr`
    被测试与 `currencies[2]`、`currencies[4]` 或 `currencies[10]` 的值匹配，使用一个情况子句直到找到匹配项：'
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `switch` statement is the cleaner and preferred idiomatic approach to writing
    complex conditional statements in Go. This is evident when the preceding snippet
    is compared to the following, which does the same comparison using `if` statements:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 语句是 Go 中编写复杂条件语句的更简洁、更首选的惯用法。当将前面的代码片段与以下使用 `if` 语句执行相同比较的代码进行比较时，这一点很明显：'
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fallthrough cases
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跌入情况
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch03/switchstmt.go
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt.go
- en: 'When a case is matched, the `fallthrough` statements cascade down to the first
    statement of the successive `case` block. So, if `curr = Curr{"AUD", "Australian
    Dollar", "Australia", 36}`, the first case will be matched. Then the flow cascades
    down to the first statement of the second case block, which is also a `fallthrough`
    statement. This causes the first statement, to return `true`, of the third case
    block to execute. This is functionally equivalent to the following snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配到某个 case 时，`fallthrough` 语句会级联到后续 `case` 块的第一个语句。因此，如果 `curr = Curr{"AUD",
    "Australian Dollar", "Australia", 36}"，第一个 case 将会被匹配。然后流程级联到第二个 case 块的第一个语句，它也是一个
    `fallthrough` 语句。这导致第三个 case 块的第一个语句执行，以返回 `true`。这在功能上等同于以下代码片段：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Expressionless switches
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无表达式开关
- en: 'Go supports a form of the `switch` statement that does not specify an expression.
    In this format, each `case` expression must evaluate to a Boolean value `true`.
    The following abbreviated source code illustrates the uses of an expressionless
    `switch` statement, as listed in function `find()`. The function loops through
    the slice of `Curr` values to search for a match based on field values in the
    `struct` function that''s passed in:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持一种不指定表达式的 `switch` 语句形式。在这种格式中，每个 `case` 表达式必须评估为布尔值 `true`。以下简化的源代码说明了无表达式的
    `switch` 语句的用法，如函数 `find()` 中所示。该函数遍历 `Curr` 值的切片，根据传入的 `struct` 函数中的字段值搜索匹配项：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt2.go
- en: 'Notice in the previous example, the `switch` statement in function `find()`
    does not include an expression. Each `case` expression is separated by a comma
    and must be evaluated to a Boolean value with an implied `OR` operator between
    each. The previous `switch` statement is equivalent to the following use of an
    `if` statement to achieve the same logic:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的例子中，函数 `find()` 中的 `switch` 语句没有包含表达式。每个 `case` 表达式之间用逗号分隔，并且必须评估为布尔值，每个
    `case` 表达式之间隐含地使用 `OR` 操作符。先前的 `switch` 语句等同于以下使用 `if` 语句实现相同逻辑的用法：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Switch initializer
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开关初始化器
- en: 'The `switch` keyword may be immediately followed by a simple initialization
    statement where variables, local to the `switch` code block, may be declared and
    initialized. This convenient syntax uses a semi-colon between the initializer
    statement and the `switch` expression to declare variables, which may appear anywhere
    in the `switch` code block. The following code sample shows how this is done by
    initializing two variables, `name` and `curr`, as part of the `switch` declaration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 关键字可以立即后跟一个简单的初始化语句，其中可以声明并初始化局部于 `switch` 代码块中的变量。这种方便的语法在初始化语句和
    `switch` 表达式之间使用分号来声明变量，这些变量可以出现在 `switch` 代码块的任何位置。以下代码示例展示了如何通过初始化两个变量，`name`
    和 `curr`，作为 `switch` 声明的一部分来实现这一点：'
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Type switches
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型开关
- en: Given Go's strong type support, it should be of little surprise that the language
    supports the ability to query type information. The type `switch` is a statement
    that uses the Go interface type to compare the underlying type information of
    values (or expressions). A full discussion on interface types and type assertion
    is beyond the scope of this section. You can find more details on the subject
    in [Chapter 8](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces, and Objects*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 Go 强大的类型支持，该语言支持查询类型信息的能力应该不会令人惊讶。`type switch` 是一个使用 Go 接口类型来比较值的底层类型信息的语句（或表达式）。关于接口类型和类型断言的完整讨论超出了本节的范围。您可以在[第
    8 章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd "第 8 章。方法、接口和对象")*方法、接口和对象*中找到更多关于这个主题的详细信息。
- en: 'Nevertheless, for the sake of completeness, a short discussion on type switches
    is provided here. For now, all you need to know is that Go offers the type `interface{}`,
    or empty interface, as a super type that is implemented by all other types in
    the type system. When a value is assigned type `interface{}`, it can be queried
    using the type `switch`, as shown in function `findAny()` in the following code
    snippet, to query information about its underlying type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，为了完整性，这里提供了一个关于类型开关的简短讨论。目前，您需要知道的是，Go 提供了 `interface{}` 类型，或空接口，作为类型系统中所有其他类型的超类型。当一个值被赋予
    `interface{}` 类型时，可以使用 `type switch` 来查询其底层类型信息，如下面的代码片段中的 `findAny()` 函数所示，以查询其底层类型信息：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt2.go
- en: 'The function `findAny()` takes an `interface{}` as its parameter. The type
    `switch` is used to determine the underlying type and value of the variable `val`
    using the type assertion expression:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `findAny()` 以 `interface{}` 作为其参数。使用 `switch` 语句通过类型断言表达式确定变量 `val` 的底层类型和值：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice the use of the keyword `type` in the preceding type assertion expression.
    Each case clause will be tested against the type information queried from `val.(type)`.
    Variable `i` will be assigned the actual value of the underlying type and is used
    to invoke a function with the respective value. The default block is invoked to
    guard against any unexpected type assigned to the parameter `val` parameter. Function
    `findAny` may then be invoked with values of diverse types, as shown in the following
    code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面类型断言表达式中关键字 `type` 的使用。每个情况子句将针对从 `val.(type)` 查询的类型信息进行测试。变量 `i` 将分配底层类型的实际值，并用于调用具有相应值的函数。默认块被调用以防止将任何意外的类型分配给参数
    `val`。然后可以像以下代码片段所示那样使用 `findAny` 函数调用具有不同类型的值：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The for statements
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for` 语句'
- en: 'As a language related to the C-family, Go also supports `for` loop style control
    structures. However, as you may have come to expect by now, Go''s `for` statements
    work interestingly differently and simply. The `for` statement in Go supports
    four distinct idioms, as summarized in the following table:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为与 C 家族相关的语言，Go 也支持 `for` 循环样式控制结构。然而，正如你现在可能已经预料到的，Go 的 `for` 语句以有趣且简单的方式工作。Go
    中的 `for` 语句支持四种不同的惯用法，如下表所示：
- en: '| **For Statement** | **Usage** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **for 语句** | **用途** |'
- en: '| For condition | Used to semantically replace `while` and `do...while` loops:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '| 条件 `for` | 用于在语义上替换 `while` 和 `do...while` 循环：'
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Infinite loop | The conditional expression may be omitted to create an infinite
    loop:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '| 无限循环 | 可以省略条件表达式以创建无限循环：'
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Traditional | This is the traditional form of the C-family `for` loop with
    the initializer, test, and update clauses:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传统 | 这是 C 家族 `for` 循环的传统形式，具有初始化、测试和更新子句：'
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| For range | Used to iterate over an expression representing a collection
    of items stored in an array, string (array of rune), slice, map, and channel:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| 范围 `for` | 用于遍历表示存储在数组、字符串（rune 数组）、切片、映射和通道中的项目集合的表达式：'
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Notice, as with all other control statements in Go, the `for` statements do
    not use parentheses around their expressions. All statements for the loop code
    block must be enclosed within curly brackets or the compiler will produce an error.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 Go 中的所有其他控制语句一样，`for` 语句在其表达式周围不使用括号。所有循环代码块中的语句都必须在花括号内，否则编译器将产生错误。
- en: For condition
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件
- en: 'The `for` condition uses a construct that is semantically equivalent to the
    `while` loop found in other languages. It uses the keyword `for`, followed by
    a Boolean expression that allows the loop to proceed as long as it is evaluated
    to true. The following abbreviated source listing shows an example of this form
    of the `for` loop:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 条件使用与在其他语言中找到的 `while` 循环语义上等价的结构。它使用关键字 `for`，后跟一个布尔表达式，只要评估为真，循环就会继续。以下简化的源代码列表显示了这种形式的
    `for` 循环的示例：'
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch03/forstmt.go
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/forstmt.go
- en: The `for` statement, in function `listCurrs()`, iterates as long as the conditional
    expression `i < len(currencencies)` returns `true`. Care must be taken to ensure
    the value of `i` is updated with each iteration to avoid creating an accidental
    infinite loop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 `listCurrs()` 中，`for` 语句在条件表达式 `i < len(currencencies)` 返回 `true` 时迭代。必须注意确保每次迭代时更新
    `i` 的值，以避免创建意外的无限循环。
- en: Infinite loop
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限循环
- en: 'When the Boolean expression is omitted in the `for` statement, the loop runs
    indefinitely, as shown the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `for` 语句中省略布尔表达式时，循环将无限进行，如下面的示例所示：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is equivalent to the `for(;;)` or the `while (true)` found in other languages,
    such as C or Java.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于在其他语言（如 C 或 Java）中找到的 `for(;;)` 或 `while (true)`。
- en: The traditional for statement
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统 `for` 语句
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It turns out that the traditional `for` statement is a superset of the other
    forms of the loop discussed so far, as summarized in the following table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，传统的 `for` 语句是之前讨论的其他循环形式的超集，如下表所示：
- en: '| **For statement** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **for 语句** | **描述** |'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| The initialization statement is omitted. Variable `k` is initialized outside
    of the `for` statement. The idiomatic way, however, is to initialize your variables
    with the `for` statement. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 初始化语句被省略。变量 `k` 在 `for` 语句外部初始化。然而，习惯上是用 `for` 语句初始化变量。|'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| The `update` statement (after the last semi-colon) is omitted here. The developer
    must provide update logic elsewhere or you risk creating an infinite loop. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 在这里省略了 `update` 语句（在最后一个分号之后）。开发者必须在其他地方提供更新逻辑，否则可能会创建一个无限循环。|'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| This is equivalent to the `for` condition form (discussed earlier) `for k
    < 10 { ... }`. Again, the variable `k` is expected to be declared prior to the
    loop. Care must be taken to update `k` or you risk creating an infinite loop.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 这与前面讨论的 `for` 条件形式（`for k < 10 { ... }`）等价。再次强调，变量 `k` 应在循环之前声明。必须小心更新 `k`，否则可能会创建一个无限循环。|'
- en: '|'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| Here, the conditional expression is omitted. As before, this evaluates the
    conditional to `true`, which will produce an infinite loop if proper termination
    logic is not introduced in the loop. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 这里省略了条件表达式。与之前一样，这会评估条件为 `true`，如果没有在循环中引入适当的终止逻辑，则会产生无限循环。|'
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| This is equivalent to the form `for{ ... }` and produces an infinite loop.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 这与形式 `for{ ... }` 等价，并会产生无限循环。|'
- en: 'The initialization and the `update` statements, in the `for` loop, are regular
    Go statements. As such, they can be used to initialize and update multiple variables,
    as is supported by Go. To illustrate this point, the next example initializes
    and updates two variables, `w1` and `w2`, at the same time in the statement clauses:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环中，初始化语句和 `update` 语句是常规的 Go 语句。因此，它们可以用来初始化和更新多个变量，正如 Go 所支持的。为了说明这一点，下一个示例在语句子句中同时初始化和更新了两个变量
    `w1` 和 `w2`：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: golang.fyi/ch03/forstmt2.go
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/forstmt2.go
- en: The initialization statements initialize variables `w1` and `w2` by calling
    the function `nextPair()`. The condition uses a compound logical expression that
    will keep the loop running as long as it is evaluated to true. Lastly, variables
    `w1` and `w2` are both updated with each iteration of the loop by calling `nextPair()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句通过调用函数 `nextPair()` 来初始化变量 `w1` 和 `w2`。条件使用一个复合逻辑表达式，只要它评估为真，循环就会继续运行。最后，变量
    `w1` 和 `w2` 都通过调用 `nextPair()` 在循环的每次迭代中更新。
- en: The for range
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for range
- en: 'Lastly, the `for` statement supports one additional form that uses the keyword
    `range` to iterate over an expression that evaluates to an array, slice, map,
    string, or channel. The for-range loop has this generic form:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`for` 语句支持一种额外的形式，使用关键字 `range` 来遍历一个求值为数组、切片、映射、字符串或通道的表达式。for-range 循环具有以下通用形式：
- en: '*for [<identifier-list> :=] range <expression> { ... }*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*for [<标识符列表>] := range <表达式> { ... }*'
- en: 'Depending on the type produced by the `range` expression, there can be up to
    two variables emitted by each iteration, as summarized in the following table:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `range` 表达式产生的类型，每次迭代可以产生多达两个变量，如下表所示：
- en: '| **Range Expression** | **Range Variables** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **范围表达式** | **范围变量** |'
- en: '| Loop over array or slice:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '| 遍历数组或切片：'
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| The range produces two values, where `i` is the loop index and `v` is the
    value `v[i]` from the collection. Further discussions on array and slice are covered
    in [Chapter 7](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 7. Composite Types"), *Composite Types*. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 范围生成两个值，其中 `i` 是循环索引，`v` 是集合中的值 `v[i]`。关于数组和切片的进一步讨论请参阅[第7章](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第7章。复合类型")，*复合类型*。|'
- en: '| Loop over string value:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '| 遍历字符串值：'
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| The range produces two values, where `i` is the index of byte in the string
    and `v` is the value of the UTF-8 encoded byte at `v[i]` returned as a rune. Further
    discussion on the string type is covered in in [Chapter 4](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 4. Data Types"), *Data Types*. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 范围生成两个值，其中 `i` 是字符串中的字节索引，`v` 是 UTF-8 编码的字节值，在 `v[i]` 处返回为 rune。关于字符串类型的进一步讨论请参阅[第4章](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第4章。数据类型")，*数据类型*。|'
- en: '| Loop over map:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '| 遍历映射：'
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| The `range` produces two values, where `k` is assigned the value of the map
    key of type `K` and `v` gets stored at `map[k]` of type `V`. Further discussion
    on map is covered in [Chapter 7](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 7. Composite Types"), *Composite Types*. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `range` 产生两个值，其中 `k` 被分配为类型 `K` 的映射键的值，而 `v` 被存储在 `map[k]` 中，类型为 `V`。关于映射的进一步讨论请参阅[第7章](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第7章。复合类型")，*复合类型*。|'
- en: '| Loop on channel values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在通道值上循环：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '| An adequate discussion of channels is covered in [Chapter 9](part0061_split_000.html#1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 9. Concurrency"), *Concurrency*. A channel is a two-way conduit able
    to receive and emit values. The `for...range` statement assigns each value received
    from the channel to variable `c` with each iteration. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 有关通道的充分讨论请参阅[第9章](part0061_split_000.html#1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第9章。并发")，*并发*。通道是一种双向导线，能够接收和发出值。`for...range` 语句将每次从通道接收到的值分配给变量 `c`。|'
- en: 'You should be aware that the value emitted with each iteration is a copy of
    the original item stored in the source. For instance, in the following program,
    the values in the slice do not get updated after the loop completes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，每次迭代发出的值是源中存储的原始项的副本。例如，在以下程序中，循环完成后切片中的值不会更新：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To update the original value using the `for...range` loop, use the index expression
    to access the original value, as illustrated in the following.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `for...range` 循环更新原始值，请使用索引表达式访问原始值，如下所示。
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the previous example, value `i` is used in a slice index expression  `vals[i]`
    to update the original value stored in the slice. It is possible to omit the iteration
    value (the second variable in the assignment) if you only need access to the index
    value of an array, slice, or string (or key for a map). For instance, in the following
    example, the `for...range` statement only emits the current index value with each
    iteration:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，值 `i` 被用于切片索引表达式 `vals[i]` 以更新存储在切片中的原始值。如果你只需要访问数组、切片或字符串（或映射的键）的索引值，则可以省略迭代值（赋值中的第二个变量）。例如，在以下示例中，`for...range`
    语句仅在每个迭代中发出当前索引值：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: golang.fyi/ch03/for-range-stmt.go
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/for-range-stmt.go
- en: 'Finally, there are some situations where you may not be interested in any of
    the values generated by the iteration, but rather the iteration mechanic itself.
    The next form of the for statement was introduced (as of Version 1.4 of Go) to
    express a for range without any variable declaration as shown in the following
    code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有些情况下你可能对迭代生成的任何值都不感兴趣，而是对迭代机制本身感兴趣。Go 1.4 版本中引入了 for 语句的下一形式，以表达没有变量声明的
    for range，如下代码片段所示：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The previous code will print `"Looping"` four times on the standard output.
    This form of the `for...range` loop is used sometimes when the range expression
    is over a channel. It is used to simply notify of the presence of a value in the
    channel.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在标准输出上打印 `"Looping"` 四次。当范围表达式在通道上时，会使用这种 `for...range` 循环的形式。它用于简单地通知通道中存在值。
- en: The break, continue, and goto statements
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: break、continue 和 goto 语句
- en: Go supports a group of statements designed specifically to exit abruptly out
    of a running code block, such as switch and for statement, and transfer control
    to a different section of the code. All three statements can accept a label identifier
    that specifies a targeted location in the code where control is to be transferred.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持一组专门设计的语句，用于突然退出正在运行的代码块，例如 switch 和 for 语句，并将控制权转移到代码的不同部分。所有三个语句都可以接受一个标签标识符，该标识符指定了控制要转移到的代码中的目标位置。
- en: The label identifier
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签标识符
- en: 'Before diving into the core of this section, it is worthwhile to look at the
    label used by these statements. Declaring a label in Go requires an identifier
    followed by a colon, as shown in the following snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本节的核心之前，看看这些语句使用的标签是值得的。在 Go 中声明标签需要标识符后跟冒号，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Naming your label is a matter of style. However, one should follow the identifier
    naming guidelines covered in the previous chapter. A label must be enclosed within
    a function. The Go compiler will not allow unused labels to dangle in the code.
    Similar to variables, if a label is declared, it must be referenced in the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的命名是风格问题。然而，应该遵循上一章中提到的标识符命名指南。标签必须位于函数内部。Go编译器不允许在代码中悬挂未使用的标签。与变量类似，如果声明了标签，必须在代码中引用它。
- en: The break statement
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`break`语句'
- en: 'As in other C-like languages, the Go `break` statement terminates and exits
    the innermost enclosing `switch` or `for` statement code block and transfers control
    to another part of the running program. The `break` statement can accept an optional
    label identifier specifying a labeled location, in the enclosing function, where
    the flow of the program will resume. Here are some attributes of the label for
    the `break` statement to remember:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其他C-like语言一样，Go的`break`语句终止并退出最内层封装的`switch`或`for`语句代码块，并将控制权转移到运行程序的另一部分。`break`语句可以接受一个可选的标签标识符，指定程序流程将从中恢复的标签位置。以下是关于`break`语句标签的一些属性需要记住：
- en: The label must be declared within the same running function where the `break`
    statement is located
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签必须在包含`break`语句的同一运行函数内声明
- en: A declared label must be followed immediately by the enclosing control statement
    (a `for` loop or `switch` statement) where the break is nested
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的标签必须立即跟随封装的控制语句（一个`for`循环或`switch`语句），其中嵌套了`break`语句
- en: If a `break` statement is followed by a label, control is transferred, not to
    the location where the label is, but rather to the statement immediately following
    the labeled block. If a label is not provided, the `break` statement abruptly
    exits and transfers control to the next statement following its enclosing `for`
    statement (or `switch` statement) block.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`break`语句后面跟着一个标签，控制权将转移到标签所在的位置，而不是标签后的语句。如果没有提供标签，`break`语句将突然退出，并将控制权转移到其封装的`for`语句（或`switch`语句）块之后的下一个语句。
- en: 'The following code is an overly exaggerated linear search that illustrates
    the working of the `break` statement. It does a word search and exits once the
    first instance of the word is found in the slice:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个过度夸张的线性搜索，用于说明`break`语句的工作原理。它执行单词搜索，并在找到切片中单词的第一个实例时退出：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The continue statement
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`continue`语句'
- en: 'The `continue` statement causes the control flow to immediately terminate the
    current iteration of the enclosing `for` loop and jump to the next iteration.
    The `continue` statement can take an optional label as well. The label has similar
    properties to that of the `break` statement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句会导致控制流立即终止封装的`for`循环的当前迭代，并跳转到下一个迭代。`continue`语句也可以接受一个可选的标签。标签具有与`break`语句类似的属性：'
- en: The label must be declared within the same running function where the `continue`
    statement is located
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签必须在包含`continue`语句的同一运行函数内声明
- en: The declared label must be followed immediately by an enclosing `for` loop statement
    where the continue statement is nested
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的标签必须立即跟随一个封装的`for`循环语句，其中嵌套了`continue`语句
- en: When present, the `continue` statement is reached within a `for` statement block,
    the `for` loop will be abruptly terminated and control will be transferred to
    the outermost labeled `for` loop block for continuation. If a label is not specified,
    the `continue` statement will simply transfer control to the start of its enclosing
    `for` loop block for continuation of the next iteration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当`continue`语句存在于`for`语句块中时，如果存在，`for`循环将突然终止，并将控制权转移到最外层的带有标签的`for`循环块以继续。如果没有指定标签，`continue`语句将简单地转移到其封装的`for`循环块的开始，以继续下一个迭代。
- en: 'To illustrate, let us revisit the previous example of word search. This version
    uses a `continue` statement, which causes the search to find multiple occurrences
    of the searched word in the slice:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们回顾一下之前的单词搜索示例。这个版本使用了一个`continue`语句，它会导致在切片中找到搜索单词的多个实例：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: golang.fyi/ch03/breakstmt2.go
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/breakstmt2.go
- en: The `continue DoSearch` statement causes the current iteration of the innermost
    loop to stop and transfer control to the labeled outer loop, causing it to continue
    with the next iteration.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue DoSearch`语句会导致最内层循环的当前迭代停止，并将控制权转移到带有标签的外层循环，使其继续下一个迭代。'
- en: The goto statement
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`goto`语句'
- en: 'The `goto` statement is more flexible, in that it allows flow control to be
    transferred to an arbitrary location, inside a function, where a target label
    is defined. The `goto` statement causes an abrupt transfer of control to the label
    referenced by the `goto` statement. The following shows Go''s `goto` statement
    in action in a simple, but functional example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句更加灵活，因为它允许将流程控制转移到函数内定义的目标标签的任意位置。`goto`语句导致控制突然转移到由`goto`语句引用的标签。以下是一个简单但功能性的示例，展示了Go的`goto`语句的实际应用：'
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: golang.fyi/ch03/gotostmt.go
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/gotostmt.go
- en: 'The code uses the `goto` statement to jump to different sections of the `main()`
    function. Notice that the `goto` statement can target labels defined anywhere
    in the code. The superfluous usage of the `Start:` label is left in the code for
    completeness and is not necessary in this context (since continue, without the
    label, would have the same effect). The following provides some guidance when
    using the `goto` statement:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`goto`语句跳转到`main()`函数的不同部分。注意，`goto`语句可以针对代码中任何地方定义的标签。代码中多余的`Start:`标签保留是为了完整性，在此上下文中并非必需（因为不带标签的`continue`会有相同的效果）。以下是在使用`goto`语句时的一些指导：
- en: Avoid using the `goto` statement unless the logic being implemented can only
    be achieved using `goto` branching. This is because overuse of the `goto` statement
    can make code harder to reason about and debug.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非实现的逻辑只能通过`goto`分支来实现，否则请避免使用`goto`语句。这是因为过度使用`goto`语句会使代码更难推理和调试。
- en: Place `goto` statements and their targeted label within the same enclosing code
    block when possible.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当可能时，将`goto`语句及其目标标签放置在相同的封装代码块内。
- en: Avoid placing labels where a `goto` statement will cause the flow to skip new
    variable declarations or cause them to be re-declared.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将标签放置在`goto`语句会导致跳过新变量声明或重新声明变量的地方。
- en: Go will let you jump from inner to outer enclosing code blocks.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go允许你从内部跳转到外部的封装代码块。
- en: It is a compilation error if you try to jump to a peer or to an enclosing code
    block.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试跳转到同级或封装代码块，将会出现编译错误。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a walkthrough of the mechanism of control flow in Go,
    including `if`, `switch`, and `for` statements. While Go's flow control constructs
    appear simple and easy to use, they are powerful and implement all branching primitives
    expected of a modern language. Readers are introduced to each concept with ample
    detail and examples to ensure clarity of the topics. The next chapter continues
    our look into Go fundamentals by introducing the reader to the Go type systems.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了Go中控制流机制的概述，包括`if`、`switch`和`for`语句。虽然Go的流程控制结构看起来简单且易于使用，但它们功能强大，实现了现代语言所期望的所有分支原语。读者通过充分的细节和示例了解每个概念，以确保对主题的清晰理解。下一章通过介绍Go类型系统，继续深入探讨Go的基本概念。
