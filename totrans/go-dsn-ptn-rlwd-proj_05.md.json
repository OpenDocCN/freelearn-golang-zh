["```go\npackage main \nimport ( \n   \"fmt\" \n   \"unsafe\" \n) \n\nvar ( \n   a uint8   = 72 \n   b int32   = 240 \n   c uint64  = 1234564321 \n   d float32 = 12432345.232 \n   e int64   = -1233453443434 \n   f float64 = -1.43555622362467 \n   g int16   = 32000 \n   h [5]rune = [5]rune{'O', 'n', 'T', 'o', 'p'} \n) \n\nfunc main() { \n   fmt.Printf(\"a = %v [%T, %d bits]\\n\", a, a, unsafe.Sizeof(a)*8) \n   fmt.Printf(\"b = %v [%T, %d bits]\\n\", b, b, unsafe.Sizeof(b)*8) \n   fmt.Printf(\"c = %v [%T, %d bits]\\n\", c, c, unsafe.Sizeof(c)*8) \n   fmt.Printf(\"d = %v [%T, %d bits]\\n\", d, d, unsafe.Sizeof(d)*8) \n   fmt.Printf(\"e = %v [%T, %d bits]\\n\", e, e, unsafe.Sizeof(e)*8) \n   fmt.Printf(\"f = %v [%T, %d bits]\\n\", f, f, unsafe.Sizeof(f)*8) \n   fmt.Printf(\"g = %v [%T, %d bits]\\n\", g, g, unsafe.Sizeof(g)*8) \n   fmt.Printf(\"h = %v [%T, %d bits]\\n\", h, h, unsafe.Sizeof(h)*8) \n} \n\n```", "```go\n$>go run alloc.go\na = 72 [uint8, 8 bits]\nb = 240 [int32, 32 bits]\nc = 1234564321 [uint64, 64 bits]\nd = 1.2432345e+07 [float32, 32 bits]\ne = -1233453443434 [int64, 64 bits]\nf = -1.43555622362467 [float64, 64 bits]\ng = 32000 [int16, 16 bits]\nh = [79 110 84 111 112] [[5]int32, 160 bits]\n\n```", "```go\npackage main \nimport ( \n   \"math\" \n   \"unsafe\" \n) \n\nvar _ int8 = 12 \nvar _ int16 = -400 \nvar _ int32 = 12022 \nvar _ int64 = 1 << 33 \nvar _ int = 3 + 1415 \n\nvar _ uint8 = 18 \nvar _ uint16 = 44 \nvar _ uint32 = 133121 \nvar i uint64 = 23113233 \nvar _ uint = 7542 \nvar _ byte = 255 \nvar _ uintptr = unsafe.Sizeof(i) \n\nvar _ float32 = 0.5772156649 \nvar _ float64 = math.Pi \n\nvar _ complex64 = 3.5 + 2i \nvar _ complex128 = -5.0i \n\nfunc main() { \n   fmt.Println(\"all types declared!\") \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   vals := []int{ \n       1024, \n       0x0FF1CE, \n       0x8BADF00D, \n       0xBEEF, \n       0777, \n   } \n   for _, i := range vals { \n         if i == 0xBEEF { \n               fmt.Printf(\"Got %d\\n\", i) \n               break \n         } \n   } \n} \n\n```", "```go\npackage main \n\nimport \"fmt\" \n\nfunc main() { \n   p := 3.1415926535 \n   e := .5772156649 \n   x := 7.2E-5 \n   y := 1.616199e-35 \n   z := .416833e32 \n\n   fmt.Println(p, e, x, y, z) \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   a := -3.5 + 2i \n   fmt.Printf(\"%v\\n\", a) \n   fmt.Printf(\"%+g, %+g\\n\", real(a), imag(a)) \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   var readyToGo bool = false \n   if !readyToGo { \n       fmt.Println(\"Come on\") \n   } else { \n       fmt.Println(\"Let's go!\") \n   } \n} \n\n```", "```go\n$>go run runes.go\n8\n9\n10\n632\n2438\n35486\n873\n250\n37 \n\n```", "```go\ntxt being assigned a string literal containing seven characters including two embedded Chinese characters. As referenced earlier, the Go compiler will automatically interpret string literal values as Unicode characters and encode them using UTF-8\\. This means that under the cover, each literal character is stored as a rune and may end up taking more than one byte for storage per visible character. In fact, when the program is executed, it prints the length of txt as 11, instead of the expected seven characters for the string, accounting for the additional bytes used for the Chinese symbols.\n```", "```go\ntxt2 and txt3 respectively. As you can see, these two literals have the exact same content, however, the compiler will treat them differently:\n```", "```go\nvar ( \n   txt2 = \"\\u6C34\\x20brings\\x20\\x6c\\x69\\x66\\x65.\" \n   txt3 = ` \n   \\u6C34\\x20 \n   brings\\x20 \n   \\x6c\\x69\\x66\\x65\\. \n   ` \n) \n\n```", "```go `` ```", "```go\n\\u6C34\\x20brings\\x20\\x6c\\x69\\x66\\x65.\n\n```", "```go\npackage main \nimport \"fmt\" \n\nvar valPtr *float32 \nvar countPtr *int \nvar person *struct { \n   name string \n   age  int \n} \nvar matrix *[1024]int \nvar row []*int64 \n\nfunc main() { \n   fmt.Println(valPtr, countPtr, person, matrix, row) \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   var a int = 1024 \n   var aptr *int = &a \n\n   fmt.Printf(\"a=%v\\n\", a) \n   fmt.Printf(\"aptr=%v\\n\", aptr) \n} \n\n```", "```go\nvar a int = 1024 \nvar aptr *int = &a  \n\n```", "```go\na=1024 \naptr=0xc208000150\n\n```", "```go\nvar aptr *int = &1024  \nfmt.Printf(\"a ptr1 = %v\\n\", aptr)  \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   structPtr := &struct{ x, y int }{44, 55} \n   pairPtr := &[2]string{\"A\", \"B\"} \n\n   fmt.Printf(\"struct=%#v, type=%T\\n\", structPtr, structPtr) \n   fmt.Printf(\"pairPtr=%#v, type=%T\\n\", pairPtr, pairPtr) \n} \n\n&struct{ x, y int }{44, 55} and &[2]string{\"A\", \"B\"} to return pointer types *struct { x int; y int } and *[2]string respectively. This is a bit of syntactic sugar that eliminates the intermediary step of assigning the values to a variable, then retrieving their assigned addresses.\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   intptr := new(int) \n   *intptr = 44 \n\n   p := new(struct{ first, last string }) \n   p.first = \"Samuel\" \n   p.last = \"Pierre\" \n\n   fmt.Printf(\"Value %d, type %T\\n\", *intptr, intptr) \n   fmt.Printf(\"Person %+v\\n\", p) \n} \n\n```", "```go\npackage main \nimport ( \n   \"fmt\" \n   \"strings\" \n) \n\nfunc main() { \n   a := 3 \n   double(&a) \n   fmt.Println(a) \n   p := &struct{ first, last string }{\"Max\", \"Planck\"} \n   cap(p) \n   fmt.Println(p) \n} \n\nfunc double(x *int) { \n   *x = *x * 2 \n} \n\nfunc cap(p *struct{ first, last string }) { \n   p.first = strings.ToUpper(p.first) \n   p.last = strings.ToUpper(p.last) \n} \n\n```", "```go\n*x * 2   \n\n```", "```go\n*(*x) * 2   \n\n```", "```go\n3 * 2 = 6   \n\n```", "```go\n*(*x) = 6   \n\n```", "```go\ntype truth bool \ntype quart float64 \ntype gallon float64 \ntype node string \n\n```", "```go\npackage main \nimport \"fmt\" \n\ntype fahrenheit float64 \ntype celsius float64 \ntype kelvin float64 \n\nfunc fharToCel(f fahrenheit) celsius { \n   return celsius((f - 32) * 5 / 9) \n} \n\nfunc fharToKel(f fahrenheit) celsius { \n   return celsius((f-32)*5/9 + 273.15) \n} \n\nfunc celToFahr(c celsius) fahrenheit { \n   return fahrenheit(c*5/9 + 32) \n} \n\nfunc celToKel(c celsius) kelvin { \n   return kelvin(c + 273.15) \n} \n\nfunc main() { \n   var c celsius = 32.0 \n   f := fahrenheit(122) \n   fmt.Printf(\"%.2f \\u00b0C = %.2f \\u00b0K\\n\", c, celToKel(c)) \n   fmt.Printf(\"%.2f \\u00b0F = %.2f \\u00b0C\\n\", f, fharToCel(f)) \n} \n\nfloat64. Once the new type has been declared, it can be assigned to variables and participate in expressions just like its underlying type. The newly declared type will have the same zero-value and can be converted to and from its underlying type.\n```", "```go\npackage main \nimport \"fmt\" \n\ntype signal int \n\nfunc main() { \n   var count int32 \n   var actual int \n   var test int64 = actual + count \n\n   var sig signal \n   var event int = sig \n\n   fmt.Println(test) \n   fmt.Println(event) \n} \n\n```", "```go\ntype signal int \nfunc main() { \n   var count int32 \n   var actual int \n   var test int32 = int32(actual) + count \n\n   var sig signal \n   var event int = int(sig) \n} \n\nvar test int32 = int32(actual) + count converts variable actual to the proper type to match the rest of the expression. Similarly, expression var event int = int(sig) converts variable sig to match the target type int in the assignment.\n```", "```go\nvar i int   \nvar i2 int32 = int32(i)   \nvar re float64 = float64(i +   int(i2))   \n\n```", "```go\nvar cn64 complex64   \nvar cn128 complex128 =   complex128(cn64)   \n\n```", "```go\ntype signal int   \nvar sig signal   \nvar event int = int(sig)   \n\n```", "```go\na := string(72)   \nb := string(int32(101))   \nc := string(rune(108))   \n\n```", "```go\nmsg0 := string([]byte{'H','i'})   \nmsg1 := string([]rune{'Y','o','u','!'})   \n\n```", "```go\ndata0 := []byte(\"Hello\")   \ndata0 := []int32(\"World!\")   \n\n```"]