- en: Chapter 4. Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go is a strongly-typed language, which means any language element that stores
    (or expression that produces) a value has a type associated with it. In this chapter,
    readers will learn about the features of the type system as they explore the common
    data types supported by the language as outlined in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help launch the conversation about types, let us take a peek at the types
    available. Go implements a simple type system that provides programmers direct
    control over how memory is allocated and laid out. When a program declares a variable,
    two things must take place:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable must receive a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable will also be bound to a value (even when none is assigned)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the type system to allocate the number of bytes necessary to store
    the declared value. The memory layout for declared variables maps directly to
    their declared types. There is no type boxing or automatic type conversion that
    takes place. The space you expect to be allocated is actually what gets reserved
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this fact, the following program uses a special package called
    `unsafe` to circumvent the type system and extract memory size information for
    declared variables. It is important to note that this is purely illustrative as
    most programs do not commonly make use of the `unsafe` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/alloc.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program is executed, it prints out the amount of memory (in bits)
    consumed by each declared variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that variable `a` (of type `uint8`) will
    be stored using eight bits (or one byte), variable `b` using 32 bits (or four
    bytes), and so on. With the ability to influence memory consumption coupled with
    Go's support for pointer types, programmers are able to strongly control how memory
    is allocated and consumed in their programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the types listed in the following table. They include
    basic types such as numeric, Boolean, and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | Type for storing text values |'
  prefs: []
  type: TYPE_TB
- en: '| `rune` | An integer type (int32) used to represent characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `uintptr` | Types for storing integral values. |'
  prefs: []
  type: TYPE_TB
- en: '| `float32`, `float64` | Types for storing floating point decimal values. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64`, `complex128` | Types that can represent complex numbers with
    both real and imaginary parts. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | Type for Boolean values. |'
  prefs: []
  type: TYPE_TB
- en: '| `*T`, pointer to type T | A type that represents a memory address where a
    value of type T is stored. |'
  prefs: []
  type: TYPE_TB
- en: The remaining types supported by Go, such as those listed in the following table,
    include composite, interface, function, and channels. They are covered later in
    chapters dedicated to their respective topics.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Array `[n]T` | An ordered collection of fixed size `n` of numerically indexed
    sequence of elements of a type `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| Slice`[]T` | A collection of unspecified size of numerically indexed sequence
    of elements of type `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| `struct{}` | A structure is a composite type composed of elements known as
    fields (think of an object). |'
  prefs: []
  type: TYPE_TB
- en: '| `map[K]T` | An unordered sequence of elements of type `T` indexed by a key
    of arbitrary type `K`. |'
  prefs: []
  type: TYPE_TB
- en: '| `interface{}` | A named set of function declarations that define a set of
    operations that can be implemented by other types. |'
  prefs: []
  type: TYPE_TB
- en: '| `func (T) R` | A type that represents all functions with a given parameter
    type `T` and return type `R`. |'
  prefs: []
  type: TYPE_TB
- en: '| `chan T` | A type for an internal communication channel to send or receive
    values of type `T`. |'
  prefs: []
  type: TYPE_TB
- en: Numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go's numeric types include support for integral and decimal values with a variety
    of sizes ranging from 8 to 64 bits. Each numeric type has its own layout in memory
    and is considered unique by the type system. As a way of enforcing this, and to
    avoid any sort of confusion when porting Go on different platforms, the name of
    a numeric type reflects its size requirement. For instance, type `*int16*` indicates
    an integer type that uses 16 bits for internal storage*.* This means that numberic
    values must be explicitly be converted when crossing type boundaries in assignments,
    expressions, and operations.
  prefs: []
  type: TYPE_NORMAL
- en: The following program is not all that functional, since all values are assigned
    to the blank identifier. However, it illustrates all of the numeric data types
    supported in Go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/nums.go
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integer types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table lists all available types that can represent unsigned integers
    and their storage requirements in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8` | Unsigned 8-bit | Range 0 - 255 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint16` | Unsigned 16-bit | Range 0 - 65535 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | Unsigned 32-bit | Range 0 - 4294967295 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | Unsigned 64-bit | Range 0 - 18446744073709551615 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | Implementation specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `uint` represents a
    32-bit unsigned integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | Unsigned 8-bit | Alias for the `unit8` type. |'
  prefs: []
  type: TYPE_TB
- en: '| `uintptr` | Unsigned | An unsigned integer type designed to store pointers
    (memory addresses) for the underlying machine architecture. |'
  prefs: []
  type: TYPE_TB
- en: Signed integer types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table lists all available types that can represent signed integers
    and their storage requirements in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `int8` | Signed 8-bit | Range -128 - 127 |'
  prefs: []
  type: TYPE_TB
- en: '| `int16` | Signed 16-bit | Range -32768 - 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | Signed 32-bit | Range -2147483648 - 2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | Signed 64-bit | Range -9223372036854775808 - 9223372036854775807
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Implementati specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `int` represents a
    32-bit signed integer. |'
  prefs: []
  type: TYPE_TB
- en: Floating point types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go supports the following types for representation of decimal values using
    IEEE standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | Signed 32-bit | IEEE-754 standard representation of single precision
    floating point values. |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | Signed 64-bit | IEEE-754 standard representation of double-precision
    floating point values. |'
  prefs: []
  type: TYPE_TB
- en: Complex number types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go also supports representation of complex numbers with both imaginary and
    real parts as shown by the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | float32 | Represents complex numbers with real and imaginary
    parts stored as `float32` values. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex128` | float64 | Represents complex numbers with real and imaginary
    parts stored as `float64` values. |'
  prefs: []
  type: TYPE_TB
- en: Numeric literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go supports the natural representation of integer values using a sequence of
    digits with a combination of a sign and decimal point (as seen in the previous
    example). Optionally, Go integer literals can also represent hexadecimal and octal
    numbers as illustrated in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/intslit.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexadecimal values are prepended with the `0x` or (`0X`) prefix while octal
    values start with the number 0 as shown in the previous example. Floating point
    values can be represented using both decimal and exponential notations as shown
    in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/floats.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous program shows several representations of floating point literals
    in Go. Numbers can include an optional exponent portion indicated by `e` (or `E`)
    at the end of the number. For instance, `1.616199e-35` in the code represents
    numerical value 1.616199 x 10^(-35). Lastly, Go supports literals for expressing
    complex numbers as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/complex.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, variable `a` is assigned a complex number with both
    a real and an imaginary part. The imaginary literal is a floating point number
    followed by the letter `i`. Notice that Go also offers two built-in functions,
    `real()` and `imag(),` to deconstruct complex numbers into their real and imaginary
    parts respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, Boolean binary values are stored using the `bool` type. Although a variable
    of type `bool` is stored as a 1-byte value, it is not, however, an alias for a
    numeric value. Go provides two pre-declared literals, `true` and `false`, to represent
    Boolean values as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/bool.go
  prefs: []
  type: TYPE_NORMAL
- en: Rune and string types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start our discussion about the `rune` and `string` types, some background
    context is in order. Go can treat character and string literal constants in its
    source code as Unicode. It is a global standard whose goal is to catalog symbols
    for known writing systems by assigning a numerical value (known as code point)
    to each character.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Go inherently supports UTF-8 which is an efficient way of encoding
    and storing Unicode numerical values. That is all the background needed to continue
    with this subject. No further detail will be discussed as it is beyond the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The rune
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, what exactly does the `rune` type have to do with Unicode? The rune is
    an alias for the *int32* type. It is specifically intended to store Unicode integer
    values encoded as UTF-8\. Let us take a look at some rune literals in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The rune](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: golang.fyi/ch04/rune.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Each variable in the previous program stores a Unicode character as a `rune`
    value. In Go, the `rune` may be specified as a string literal constant surrounded
    by single quotes. The literal may be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A printable character (as shown with variables `char1`, `char2`, and `char3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single character escaped with backslash for non-printable control values as
    tab, linefeed, newline, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u` followed by Unicode values directly (`\u0369`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\x` followed by two hex digits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A backslash followed by three octal digits (`\045`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regardless of the `rune` literal value within the single quotes, the compiler
    compiles and assigns an integer value as shown by the printout of the previous
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Interpreted and raw string literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/string.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal value assigned to variable `txt2` is enclosed in double quotes.
    This is known as an interpreted string. An interpreted string may contain normal
    printable characters as well as backslash-escaped values which are parsed and
    interpreted as `rune` literals. So, when `txt2` is printed, the escape values
    are translated as the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpreted and raw string literals](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each symbol, in the interpreted string, corresponds to an escape value or a
    printable symbol as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Interpreted and raw string literals](img/00012.jpeg) | **<space>** | **brings**
    | **<space>** | **life** | . |'
  prefs: []
  type: TYPE_TB
- en: '| \u6C34 | \x20 | brings | \x20 | \x6c\x69\x66\x65 | . |'
  prefs: []
  type: TYPE_TB
- en: On the other hand, the literal value assigned to variable `txt3` is surrounded
    by the grave accent characters [PRE11]. This creates what is known as a raw string
    in Go. Raw string values are uninterpreted where escape sequences are ignored
    and all valid characters are encoded as they appear in the literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'When variable `txt3` is printed, it produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the printed string contains all the backslash-escaped values as
    they appear in the original string literal. Uninterpreted string literals are
    a great way to embed large multi-line textual content within the body of a source
    code without breaking its syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, when a piece of data is stored in memory, the value for that data may
    be accessed directly or a pointer may be used to reference the memory address
    where the data is located. As with other C-family languages, pointers in Go provide
    a level of indirection that let programmers process data more efficiently without
    having to copy the actual data value every time it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C, however, the Go runtime maintains control of the management of pointers
    at runtime. A programmer cannot add an arbitrary integer value to the pointer
    to generate a new pointer address (a practice known as pointer arithmetic). Once
    an area of memory is referenced by a pointer, the data in that area will remain
    reachable until it is no longer referenced any pointer variable. At that point,
    the unreferenced value becomes eligible for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to C/C++, Go uses the `*` operator to designate a type as a pointer.
    The following snippet shows several pointers with different underlying types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/pointers.go
  prefs: []
  type: TYPE_NORMAL
- en: Given a variable of type `T`, Go uses expression `*T` as its pointer type. The
    type system considers `T` and `*T` as distinct and are not fungible. The zero
    value of a pointer, when it is not pointing to anything, is the address 0, represented
    by the literal *constant* nil.
  prefs: []
  type: TYPE_NORMAL
- en: The address operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pointer values can only be assigned addresses of their declared types. One
    way you can do so in Go is to use the address operator `&`(ampersand) to obtain
    the address value of a variable as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/pointers.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable `aptr`, of pointer type `*int`, is initialized and assigned the address
    value of variable `a` using expression `&a` as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'While variable `a` stores the actual value, we say that `aptr` points to `a`.
    The following shows the output of the program with the value of variable `a` and
    its memory location assigned to `aptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The assigned address value will always be the same (always pointing to `a`)
    regardless of where `aptr` may be accessed in the code. It is also worth noting
    that Go does not allow the use of the address operator with literal constant for
    numeric, string, and bool types. Therefore, the following will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a syntactical exception to this rule, however, when initializing composite
    types such as struct and array with literal constants. The following program illustrates
    such scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The new() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The built-in function *new(<type>)* can also be used to initialize a pointer
    value. It first allocates the appropriate memory for a zero-value of the specified
    type. The function then returns the address for the newly created value. The following
    program uses the `new()` function to initialize variables `intptr` and `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/newptr.go
  prefs: []
  type: TYPE_NORMAL
- en: Variable `intptr` is initialized as `*int` and `p` as `*struct{first, last string}`.
    Once initialized, both values are updated accordingly later in the code. You can
    use the `new()` function to initialize pointer variables with zero values when
    the actual values are not available at the time of initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer indirection - accessing referenced values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If all you have is an address, you can access the value to which it points
    by applying the `*` operator to the pointer value itself (or dereferencing). The
    following program illustrates this idea in functions `double()` and `cap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/derefptr.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, the expression `*x = *x * 2`, in function `double()`,
    can be decomposed as follows to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Step** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| Original expression where `x` is of type `*int`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| Dereferencing pointers by applying `*` to address values. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| Dereferenced value of `*(*x) = 3`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| The right side of this expression dereferences the value of `x`. It is updated
    with the result 6. |'
  prefs: []
  type: TYPE_TB
- en: In function `cap()`, a similar approach is used to access and update fields
    in composite variable `p` of type `struct{first, last string}`. However, when
    dealing with composites, the idiom is more forgiving. It is not necessary to write
    `*p.first` to access the pointer's field value. We can drop the `*` and just use
    `p.first = strings.ToUpper(p.first).`
  prefs: []
  type: TYPE_NORMAL
- en: Type declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, it is possible to bind a type to an identifier to create a new named
    type that can be referenced and used wherever the type is needed. Declaring a
    type takes the general format as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*type <name identifier> <underlying type name>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type declaration starts with the keyword `type` followed by a *name identifier *and
    the name of an existing *underlying type*. The underlying type can be a built-in
    named type such as one of the numeric types, a Boolean, or a string type as shown
    in the following snippet of type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A type declaration can also use a composite *type literal* as its underlying
    type. Composite types include array, slice, map, and struct. This section focuses
    on non-composite types. For further details on composite types, refer to [Chapter
    7](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 7. Composite
    Types"), *Composite Types*.
  prefs: []
  type: TYPE_NORMAL
- en: The following sample illustrates how named types work in their most basic forms.
    The code in the example converts temperature values. Each temperature unit is
    represented by a declared type including `fahrenheit`, `celsius`, and `kelvin`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, Go considers each type to be different. This means under normal
    circumstances, values of different types are not fungible in assignment, function
    parameters, and expression contexts. This is true for built-in and declared types.
    For instance, the following will cause a build error due to type mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/type_conv.go
  prefs: []
  type: TYPE_NORMAL
- en: The expression `actual + count` causes a build time error because both variables
    are of different types. Even though variables `actual` and `count` are of numeric
    types and `int32` and `int` have the same memory representation, the compiler
    still rejects the expression.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for declared named types and their underlying types. The compiler
    will reject assignment `var event int = sig` because type `signal` is considered
    to be different from type `int`. This is true even though `signal` uses `int`
    as its underlying type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cross type boundaries, Go supports a type conversion expression that converts
    value from one type to another. Type conversion is done using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<target_type>(<value or expression>)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet fixes the previous example by converting the variables
    to the proper types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion expressions satisfy the assignment by explicitly changing the
    type of the enclosing values. Obviously, not all types can be converted from one
    to another. The following table summarizes common scenarios when type conversion
    is appropriate and allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **Code** |'
  prefs: []
  type: TYPE_TB
- en: '| The target type and converted value are both simple numeric types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type and the converted value are both complex numeric types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type and converted value have the same underlying types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type is a string and the converted value is a valid integer type.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type is string and the converted value is a slice of bytes, int32,
    or runes. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type is a slice of byte, int32, or rune values and the converted
    value is a string. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the conversion rules also work when the target type and converted
    value are pointers that reference the same types. Besides these scenarios in the
    previous table, Go types cannot be explicitly converted. Any attempt to do so
    will result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented its readers with an introduction the Go type system.
    The chapter opened with an overview of types and dove into a comprehensive exploration
    of the basic built-in types such as numeric, Boolean, string, and pointer types.
    The discussion continued by exposing the reader to other important topics such
    as named type definition. The chapter closed with coverage of the mechanics of
    type conversion. In coming chapters, you will get a chance to learn more about
    other types such as composite, function, and interface.
  prefs: []
  type: TYPE_NORMAL
