- en: Chapter 4. Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 数据类型
- en: 'Go is a strongly-typed language, which means any language element that stores
    (or expression that produces) a value has a type associated with it. In this chapter,
    readers will learn about the features of the type system as they explore the common
    data types supported by the language as outlined in the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种强类型语言，这意味着任何存储值（或产生值的表达式）的语言元素都有一个与之关联的类型。在本章中，读者将了解类型系统的特性，当他们探索语言支持的语言数据类型时，这些类型将在以下内容中概述：
- en: Go types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 类型
- en: Numeric types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值类型
- en: Boolean type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔类型
- en: Pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针
- en: Type declaration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型声明
- en: Type conversion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Go types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 类型
- en: 'To help launch the conversation about types, let us take a peek at the types
    available. Go implements a simple type system that provides programmers direct
    control over how memory is allocated and laid out. When a program declares a variable,
    two things must take place:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助启动关于类型的对话，让我们看看可用的类型。Go 实现了一个简单的类型系统，它为程序员提供了直接控制内存分配和布局的能力。当程序声明一个变量时，必须发生两件事：
- en: The variable must receive a type
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量必须接收一个类型
- en: The variable will also be bound to a value (even when none is assigned)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量也将被绑定到一个值（即使没有分配）
- en: This allows the type system to allocate the number of bytes necessary to store
    the declared value. The memory layout for declared variables maps directly to
    their declared types. There is no type boxing or automatic type conversion that
    takes place. The space you expect to be allocated is actually what gets reserved
    in memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许类型系统分配存储声明值所需的字节数。声明变量的内存布局直接映射到它们的声明类型。没有类型装箱或自动类型转换发生。你期望分配的空间实际上是在内存中保留的。
- en: To demonstrate this fact, the following program uses a special package called
    `unsafe` to circumvent the type system and extract memory size information for
    declared variables. It is important to note that this is purely illustrative as
    most programs do not commonly make use of the `unsafe` package.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，以下程序使用一个名为 `unsafe` 的特殊包来绕过类型系统并提取声明变量的内存大小信息。重要的是要注意，这纯粹是说明性的，因为大多数程序并不经常使用
    `unsafe` 包。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch04/alloc.go
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/alloc.go
- en: 'When the program is executed, it prints out the amount of memory (in bits)
    consumed by each declared variable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，它将打印出每个声明变量消耗的内存量（以位为单位）：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding output, we can see that variable `a` (of type `uint8`) will
    be stored using eight bits (or one byte), variable `b` using 32 bits (or four
    bytes), and so on. With the ability to influence memory consumption coupled with
    Go's support for pointer types, programmers are able to strongly control how memory
    is allocated and consumed in their programs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到变量 `a`（类型为 `uint8`）将使用八个位（或一个字节）存储，变量 `b` 使用32位（或四个字节），依此类推。结合影响内存消耗的能力以及
    Go 对指针类型的支持，程序员能够强有力地控制程序中内存的分配和消耗。
- en: 'This chapter will cover the types listed in the following table. They include
    basic types such as numeric, Boolean, and strings:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下表格中列出的类型。它们包括基本类型，如数值、布尔值和字符串：
- en: '| **Type** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** |'
- en: '| `string` | Type for storing text values |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 用于存储文本值的类型 |'
- en: '| `rune` | An integer type (int32) used to represent characters. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `rune` | 用于表示字符的整数类型（int32）。 |'
- en: '| `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `uintptr` | Types for storing integral values. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `uintptr` | 用于存储整数值的类型。 |'
- en: '| `float32`, `float64` | Types for storing floating point decimal values. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `float32`, `float64` | 用于存储浮点十进制值的类型。 |'
- en: '| `complex64`, `complex128` | Types that can represent complex numbers with
    both real and imaginary parts. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `complex64`, `complex128` | 可以表示具有实部和虚部的复数的类型。 |'
- en: '| `bool` | Type for Boolean values. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 用于布尔值的类型。 |'
- en: '| `*T`, pointer to type T | A type that represents a memory address where a
    value of type T is stored. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `*T`, 指向类型 T 的指针 | 表示存储类型 T 值的内存地址的类型。 |'
- en: The remaining types supported by Go, such as those listed in the following table,
    include composite, interface, function, and channels. They are covered later in
    chapters dedicated to their respective topics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持的其余类型，如以下表格中列出，包括复合类型、接口、函数和通道。它们将在各自的章节中详细说明。
- en: '| **Type** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** |'
- en: '| Array `[n]T` | An ordered collection of fixed size `n` of numerically indexed
    sequence of elements of a type `T`. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 数组 `[n]T` | 一个有序的、大小为 `n` 的、数值索引的元素序列集合，元素类型为 `T`。 |'
- en: '| Slice`[]T` | A collection of unspecified size of numerically indexed sequence
    of elements of type `T`. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 切片 `[]T` | 一个由类型 `T` 的元素组成的、大小未指定的、数值索引的序列集合。 |'
- en: '| `struct{}` | A structure is a composite type composed of elements known as
    fields (think of an object). |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `struct{}` | 结构体是由称为字段的元素组成的复合类型（可以想象为一个对象）。 |'
- en: '| `map[K]T` | An unordered sequence of elements of type `T` indexed by a key
    of arbitrary type `K`. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `map[K]T` | 一个由类型 `T` 的元素组成的、无序序列，由任意类型的键 `K` 索引。 |'
- en: '| `interface{}` | A named set of function declarations that define a set of
    operations that can be implemented by other types. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `interface{}` | 一个命名函数声明集，定义了一组可以被其他类型实现的操作。 |'
- en: '| `func (T) R` | A type that represents all functions with a given parameter
    type `T` and return type `R`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `func (T) R` | 表示具有给定参数类型 `T` 和返回类型 `R` 的所有函数的类型。 |'
- en: '| `chan T` | A type for an internal communication channel to send or receive
    values of type `T`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `chan T` | 一个用于发送或接收类型 `T` 值的内部通信通道的类型。 |'
- en: Numeric types
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值类型
- en: Go's numeric types include support for integral and decimal values with a variety
    of sizes ranging from 8 to 64 bits. Each numeric type has its own layout in memory
    and is considered unique by the type system. As a way of enforcing this, and to
    avoid any sort of confusion when porting Go on different platforms, the name of
    a numeric type reflects its size requirement. For instance, type `*int16*` indicates
    an integer type that uses 16 bits for internal storage*.* This means that numberic
    values must be explicitly be converted when crossing type boundaries in assignments,
    expressions, and operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的数值类型包括对从 8 位到 64 位各种大小的整数和小数值的支持。每种数值类型在内存中都有自己的布局，并且由类型系统视为独特。为了强制执行这一点，并避免在将
    Go 移植到不同平台时产生任何混淆，数值类型的名称反映了其大小要求。例如，类型 `*int16*` 表示一个使用 16 位内部存储的整数类型。这意味着在赋值、表达式和操作跨越类型边界时，数值值必须显式转换。
- en: The following program is not all that functional, since all values are assigned
    to the blank identifier. However, it illustrates all of the numeric data types
    supported in Go.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序并不十分功能化，因为所有值都分配给了空白标识符。然而，它说明了 Go 支持的所有数值数据类型。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch04/nums.go
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/nums.go
- en: Unsigned integer types
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无符号整数类型
- en: 'The following table lists all available types that can represent unsigned integers
    and their storage requirements in Go:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了 Go 中可以表示无符号整数及其存储要求的所有类型：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `uint8` | Unsigned 8-bit | Range 0 - 255 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | 无符号 8 位 | 范围 0 - 255 |'
- en: '| `uint16` | Unsigned 16-bit | Range 0 - 65535 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | 无符号 16 位 | 范围 0 - 65535 |'
- en: '| `uint32` | Unsigned 32-bit | Range 0 - 4294967295 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 无符号 32 位 | 范围 0 - 4294967295 |'
- en: '| `uint64` | Unsigned 64-bit | Range 0 - 18446744073709551615 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 无符号 64 位 | 范围 0 - 18446744073709551615 |'
- en: '| `uint` | Implementation specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `uint` represents a
    32-bit unsigned integer. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | 实现特定 | 一个预定义的类型，用于表示 32 或 64 位整数。截至 Go 1.x 版本，`uint` 表示 32 位无符号整数。
    |'
- en: '| `byte` | Unsigned 8-bit | Alias for the `unit8` type. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 无符号 8 位 | `uint8` 类型的别名。 |'
- en: '| `uintptr` | Unsigned | An unsigned integer type designed to store pointers
    (memory addresses) for the underlying machine architecture. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `uintptr` | 无符号 | 一种无符号整数类型，用于存储底层机器架构的指针（内存地址）。 |'
- en: Signed integer types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有符号整数类型
- en: 'The following table lists all available types that can represent signed integers
    and their storage requirements in Go:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了 Go 中可以表示有符号整数及其存储要求的所有类型：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `int8` | Signed 8-bit | Range -128 - 127 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | 有符号 8 位 | 范围 -128 - 127 |'
- en: '| `int16` | Signed 16-bit | Range -32768 - 32767 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | 有符号 16 位 | 范围 -32768 - 32767 |'
- en: '| `int32` | Signed 32-bit | Range -2147483648 - 2147483647 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | 有符号 32 位 | 范围 -2147483648 - 2147483647 |'
- en: '| `int64` | Signed 64-bit | Range -9223372036854775808 - 9223372036854775807
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | 有符号 64 位 | 范围 -9223372036854775808 - 9223372036854775807 |'
- en: '| `int` | Implementati specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `int` represents a
    32-bit signed integer. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 实现特定 | 一个预定义的类型，用于表示 32 或 64 位整数。截至 Go 1.x 版本，`int` 表示 32 位有符号整数。
    |'
- en: Floating point types
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数类型
- en: 'Go supports the following types for representation of decimal values using
    IEEE standards:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持以下类型，用于使用 IEEE 标准表示十进制值：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `float32` | Signed 32-bit | IEEE-754 standard representation of single precision
    floating point values. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | 有符号 32 位 | IEEE-754 标准表示的单精度浮点值。|'
- en: '| `float64` | Signed 64-bit | IEEE-754 standard representation of double-precision
    floating point values. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | 有符号 64 位 | IEEE-754 标准表示的双精度浮点值。|'
- en: Complex number types
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数类型
- en: 'Go also supports representation of complex numbers with both imaginary and
    real parts as shown by the following table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还支持以下表格所示，具有实部和虚部的复数表示：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `complex64` | float32 | Represents complex numbers with real and imaginary
    parts stored as `float32` values. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | float32 | 表示具有实部和虚部的复数，实部和虚部存储为 `float32` 值。|'
- en: '| `complex128` | float64 | Represents complex numbers with real and imaginary
    parts stored as `float64` values. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `complex128` | float64 | 表示具有实部和虚部的复数，实部和虚部存储为 `float64` 值。|'
- en: Numeric literals
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值文字
- en: 'Go supports the natural representation of integer values using a sequence of
    digits with a combination of a sign and decimal point (as seen in the previous
    example). Optionally, Go integer literals can also represent hexadecimal and octal
    numbers as illustrated in the following program:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持使用数字序列的自然表示法表示整数值，结合符号和小数点（如前例所示）。可选地，Go 整数文字也可以表示十六进制和八进制数字，如下面的程序所示：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch04/intslit.go
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/intslit.go
- en: 'Hexadecimal values are prepended with the `0x` or (`0X`) prefix while octal
    values start with the number 0 as shown in the previous example. Floating point
    values can be represented using both decimal and exponential notations as shown
    in the following examples:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制值以 `0x` 或 (`0X`) 前缀开头，而八进制值以数字 0 开头，如前例所示。浮点值可以使用十进制和指数表示法表示，如下例所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch04/floats.go
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/floats.go
- en: 'The previous program shows several representations of floating point literals
    in Go. Numbers can include an optional exponent portion indicated by `e` (or `E`)
    at the end of the number. For instance, `1.616199e-35` in the code represents
    numerical value 1.616199 x 10^(-35). Lastly, Go supports literals for expressing
    complex numbers as shown in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序展示了 Go 中浮点文字的几种表示形式。数字可以包含一个可选的指数部分，由数字末尾的 `e`（或 `E`）表示。例如，代码中的 `1.616199e-35`
    表示数值 1.616199 x 10^(-35)。最后，Go 支持以下示例所示的表达复数的文字：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch04/complex.go
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/complex.go
- en: In the previous example, variable `a` is assigned a complex number with both
    a real and an imaginary part. The imaginary literal is a floating point number
    followed by the letter `i`. Notice that Go also offers two built-in functions,
    `real()` and `imag(),` to deconstruct complex numbers into their real and imaginary
    parts respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，变量 `a` 被分配了一个具有实部和虚部的复数。虚数文字是一个浮点数后跟字母 `i`。请注意，Go 还提供了两个内置函数，`real()`
    和 `imag()`，可以将复数分解为其实部和虚部。
- en: Boolean type
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'In Go, Boolean binary values are stored using the `bool` type. Although a variable
    of type `bool` is stored as a 1-byte value, it is not, however, an alias for a
    numeric value. Go provides two pre-declared literals, `true` and `false`, to represent
    Boolean values as shown in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，布尔二进制值使用 `bool` 类型存储。尽管 `bool` 类型的变量存储为一个字节的值，但它并不是一个数值的别名。Go 提供了两个预定义的文字
    `true` 和 `false`，用于表示布尔值，如下例所示：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: golang.fyi/ch04/bool.go
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/bool.go
- en: Rune and string types
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时和字符串类型
- en: In order to start our discussion about the `rune` and `string` types, some background
    context is in order. Go can treat character and string literal constants in its
    source code as Unicode. It is a global standard whose goal is to catalog symbols
    for known writing systems by assigning a numerical value (known as code point)
    to each character.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们关于 `rune` 和 `string` 类型的讨论，一些背景信息是必要的。Go 可以将其源代码中的字符和字符串文字常量视为 Unicode。这是一个全球标准，其目标是通过对每个字符分配一个数值（称为代码点）来编目已知书写系统的符号。
- en: By default, Go inherently supports UTF-8 which is an efficient way of encoding
    and storing Unicode numerical values. That is all the background needed to continue
    with this subject. No further detail will be discussed as it is beyond the scope
    of this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Go 内置支持 UTF-8，这是一种高效编码和存储 Unicode 数值的方法。这就是继续本主题所需的全部背景知识。本书范围之外将不再讨论更多细节。
- en: The rune
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符文
- en: 'So, what exactly does the `rune` type have to do with Unicode? The rune is
    an alias for the *int32* type. It is specifically intended to store Unicode integer
    values encoded as UTF-8\. Let us take a look at some rune literals in the following
    program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`rune`类型究竟与Unicode有什么关系？`rune`是`int32`类型的别名。它专门用于存储编码为UTF-8的Unicode整数值。让我们看看以下程序中的某些`rune`字面量：
- en: '![The rune](img/00009.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![符文](img/00009.jpeg)'
- en: golang.fyi/ch04/rune.go
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/rune.go
- en: 'Each variable in the previous program stores a Unicode character as a `rune`
    value. In Go, the `rune` may be specified as a string literal constant surrounded
    by single quotes. The literal may be one of the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序中的每个变量都存储一个作为`rune`值的Unicode字符。在Go中，`rune`可以指定为单引号包围的字符串字面量常量。字面量可以是以下之一：
- en: A printable character (as shown with variables `char1`, `char2`, and `char3`)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可打印字符（如变量`char1`、`char2`和`char3`所示）
- en: A single character escaped with backslash for non-printable control values as
    tab, linefeed, newline, and so on
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反斜杠转义的非打印控制值（如制表符、换行符、换行等）的单个字符
- en: '`\u` followed by Unicode values directly (`\u0369`)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u`后跟直接Unicode值（`\u0369`）'
- en: '`\x` followed by two hex digits'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\x`后跟两个十六进制数字'
- en: A backslash followed by three octal digits (`\045`)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个反斜杠后跟三个八进制数字（`\045`）
- en: 'Regardless of the `rune` literal value within the single quotes, the compiler
    compiles and assigns an integer value as shown by the printout of the previous
    variables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论单引号内的`rune`字面量值如何，编译器都会编译并分配一个整数值，如前一个变量的打印输出所示：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The string
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Interpreted and raw string literals
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释和原始字符串字面量
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: golang.fyi/ch04/string.go
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/string.go
- en: 'The literal value assigned to variable `txt2` is enclosed in double quotes.
    This is known as an interpreted string. An interpreted string may contain normal
    printable characters as well as backslash-escaped values which are parsed and
    interpreted as `rune` literals. So, when `txt2` is printed, the escape values
    are translated as the following string:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给变量`txt2`的字面量值用双引号括起来。这被称为解释字符串。解释字符串可以包含正常可打印字符以及反斜杠转义值，这些转义值被解析和解释为`rune`字面量。因此，当`txt2`被打印时，转义值被翻译为以下字符串：
- en: '![Interpreted and raw string literals](img/00011.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![解释和原始字符串字面量](img/00011.jpeg)'
- en: 'Each symbol, in the interpreted string, corresponds to an escape value or a
    printable symbol as summarized in the following table:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解释字符串中的每个符号对应于以下表格中总结的转义值或可打印符号：
- en: '| ![Interpreted and raw string literals](img/00012.jpeg) | **<space>** | **brings**
    | **<space>** | **life** | . |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| ![解释和原始字符串字面量](img/00012.jpeg) | **<space>** | **带来** | **<space>** | **生命**
    | . |'
- en: '| \u6C34 | \x20 | brings | \x20 | \x6c\x69\x66\x65 | . |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| \u6C34 | \x20 | brings | \x20 | \x6c\x69\x66\x65 | . |'
- en: On the other hand, the literal value assigned to variable `txt3` is surrounded
    by the grave accent characters [PRE11]. This creates what is known as a raw string
    in Go. Raw string values are uninterpreted where escape sequences are ignored
    and all valid characters are encoded as they appear in the literal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，分配给变量`txt3`的字面量值被方括号[PRE11]包围。这创建了Go中的原始字符串。原始字符串值是不解释的，其中转义序列被忽略，所有有效字符都按字面量中的方式编码。
- en: 'When variable `txt3` is printed, it produces the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量`txt3`被打印时，它会产生以下输出：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the printed string contains all the backslash-escaped values as
    they appear in the original string literal. Uninterpreted string literals are
    a great way to embed large multi-line textual content within the body of a source
    code without breaking its syntax.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，打印的字符串包含原始字符串字面量中出现的所有转义值。未解释的字符串字面量是嵌入源代码体中大量多行文本内容的好方法，而不会破坏其语法。
- en: Pointers
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: In Go, when a piece of data is stored in memory, the value for that data may
    be accessed directly or a pointer may be used to reference the memory address
    where the data is located. As with other C-family languages, pointers in Go provide
    a level of indirection that let programmers process data more efficiently without
    having to copy the actual data value every time it is needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，当数据存储在内存中时，可以直接访问该数据的值，或者使用指针来引用数据所在的内存地址。与其他C系列语言一样，Go中的指针提供了一种间接级别，允许程序员更有效地处理数据，而无需每次需要时都复制实际的数据值。
- en: Unlike C, however, the Go runtime maintains control of the management of pointers
    at runtime. A programmer cannot add an arbitrary integer value to the pointer
    to generate a new pointer address (a practice known as pointer arithmetic). Once
    an area of memory is referenced by a pointer, the data in that area will remain
    reachable until it is no longer referenced any pointer variable. At that point,
    the unreferenced value becomes eligible for garbage collection.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言不同，然而，Go运行时在运行时维护对指针管理的控制。程序员不能将任意整数值添加到指针以生成新的指针地址（这种做法称为指针算术）。一旦某个内存区域被指针引用，该区域的数据将保持可访问状态，直到它不再被任何指针变量引用。到那时，未引用的值将符合垃圾回收的条件。
- en: The pointer type
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针类型
- en: 'Similar to C/C++, Go uses the `*` operator to designate a type as a pointer.
    The following snippet shows several pointers with different underlying types:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与C/C++类似，Go使用`*`运算符来指定一个类型为指针。以下代码片段展示了几个具有不同底层类型的指针：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch04/pointers.go
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/pointers.go
- en: Given a variable of type `T`, Go uses expression `*T` as its pointer type. The
    type system considers `T` and `*T` as distinct and are not fungible. The zero
    value of a pointer, when it is not pointing to anything, is the address 0, represented
    by the literal *constant* nil.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个类型为`T`的变量，Go使用表达式`*T`作为其指针类型。类型系统认为`T`和`*T`是不同的，并且不是可互换的。指针的零值，当它没有指向任何东西时，是地址0，用字面常量*nil*表示。
- en: The address operator
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址运算符
- en: 'Pointer values can only be assigned addresses of their declared types. One
    way you can do so in Go is to use the address operator `&`(ampersand) to obtain
    the address value of a variable as shown in the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 指针值只能分配其声明类型的地址。在Go中，你可以使用地址运算符`&`（和号）来获取变量的地址值，如下例所示：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch04/pointers.go
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/pointers.go
- en: 'Variable `aptr`, of pointer type `*int`, is initialized and assigned the address
    value of variable `a` using expression `&a` as listed here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 指针类型的变量`aptr`被初始化并分配了变量`a`的地址值，使用表达式`&a`，如下所示：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While variable `a` stores the actual value, we say that `aptr` points to `a`.
    The following shows the output of the program with the value of variable `a` and
    its memory location assigned to `aptr`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量`a`存储实际值时，我们说`aptr`指向`a`。以下展示了程序输出，其中变量`a`的值及其内存位置被分配给`aptr`：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The assigned address value will always be the same (always pointing to `a`)
    regardless of where `aptr` may be accessed in the code. It is also worth noting
    that Go does not allow the use of the address operator with literal constant for
    numeric, string, and bool types. Therefore, the following will not compile:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的地址值始终相同（始终指向`a`），无论`aptr`在代码中的访问位置如何。还值得注意的是，Go不允许使用地址运算符与数值、字符串和bool类型的字面常量一起使用。因此，以下代码将无法编译：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is a syntactical exception to this rule, however, when initializing composite
    types such as struct and array with literal constants. The following program illustrates
    such scenarios:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在用字面常量初始化复合类型，如struct和array时，存在一个语法上的例外。以下程序说明了这种情况：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The new() function
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: new()函数
- en: 'The built-in function *new(<type>)* can also be used to initialize a pointer
    value. It first allocates the appropriate memory for a zero-value of the specified
    type. The function then returns the address for the newly created value. The following
    program uses the `new()` function to initialize variables `intptr` and `p`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`*new(<type>)*`也可以用来初始化指针值。该函数首先为指定类型的零值分配适当的内存。然后函数返回新创建值的地址。以下程序使用`new()`函数初始化变量`intptr`和`p`：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch04/newptr.go
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/newptr.go
- en: Variable `intptr` is initialized as `*int` and `p` as `*struct{first, last string}`.
    Once initialized, both values are updated accordingly later in the code. You can
    use the `new()` function to initialize pointer variables with zero values when
    the actual values are not available at the time of initialization.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `intptr` 被初始化为 `*int`，而 `p` 被初始化为 `*struct{first, last string}`。一旦初始化，这两个值将在代码的后续部分相应地更新。当初始化时实际值不可用时，您可以使用
    `new()` 函数用零值初始化指针变量。
- en: Pointer indirection - accessing referenced values
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针间接引用 - 访问引用的值
- en: 'If all you have is an address, you can access the value to which it points
    by applying the `*` operator to the pointer value itself (or dereferencing). The
    following program illustrates this idea in functions `double()` and `cap()`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只有地址，可以通过将 `*` 操作符应用于指针值本身（或解引用）来访问它所指向的值。以下程序通过函数 `double()` 和 `cap()` 说明了这一概念：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch04/derefptr.go
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/derefptr.go
- en: 'In the preceding code, the expression `*x = *x * 2`, in function `double()`,
    can be decomposed as follows to understand how it works:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，函数 `double()` 中的表达式 `*x = *x * 2` 可以如下分解，以了解其工作原理：
- en: '| **Expression** | **Step** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **步骤** |'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| Original expression where `x` is of type `*int`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 原始表达式，其中 `x` 是 `*int` 类型。 |'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| Dereferencing pointers by applying `*` to address values. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 通过将 `*` 应用于地址值来解引用指针。 |'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Dereferenced value of `*(*x) = 3`. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `*(*x) = 3` 的解引用值。 |'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| The right side of this expression dereferences the value of `x`. It is updated
    with the result 6. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 此表达式的右侧解引用了 `x` 的值。它被更新为结果 6。 |'
- en: In function `cap()`, a similar approach is used to access and update fields
    in composite variable `p` of type `struct{first, last string}`. However, when
    dealing with composites, the idiom is more forgiving. It is not necessary to write
    `*p.first` to access the pointer's field value. We can drop the `*` and just use
    `p.first = strings.ToUpper(p.first).`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 `cap()` 中，使用类似的方法来访问和更新复合变量 `p` 的字段，其类型为 `struct{first, last string}`。然而，当处理复合类型时，惯用法更为宽容。访问指针的字段值不需要写
    `*p.first`。我们可以省略 `*` 并直接使用 `p.first = strings.ToUpper(p.first).`
- en: Type declaration
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型声明
- en: 'In Go, it is possible to bind a type to an identifier to create a new named
    type that can be referenced and used wherever the type is needed. Declaring a
    type takes the general format as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，可以将类型绑定到标识符以创建新的命名类型，该类型可以在需要类型的地方进行引用和使用。声明类型的通用格式如下：
- en: '*type <name identifier> <underlying type name>*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*type <名称标识符> <基础类型名称>*'
- en: 'The type declaration starts with the keyword `type` followed by a *name identifier *and
    the name of an existing *underlying type*. The underlying type can be a built-in
    named type such as one of the numeric types, a Boolean, or a string type as shown
    in the following snippet of type declarations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明以关键字 `type` 开头，后跟一个 *名称标识符* 和一个现有 *基础类型* 的名称。基础类型可以是以下类型之一：数值类型、布尔值或字符串类型，如下面的类型声明片段所示：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A type declaration can also use a composite *type literal* as its underlying
    type. Composite types include array, slice, map, and struct. This section focuses
    on non-composite types. For further details on composite types, refer to [Chapter
    7](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 7. Composite
    Types"), *Composite Types*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明还可以使用复合 *类型字面量* 作为其基础类型。复合类型包括数组、切片、映射和结构体。本节重点介绍非复合类型。有关复合类型的更多详细信息，请参阅
    [第 7 章](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd "第 7 章。复合类型")，*复合类型*。
- en: The following sample illustrates how named types work in their most basic forms.
    The code in the example converts temperature values. Each temperature unit is
    represented by a declared type including `fahrenheit`, `celsius`, and `kelvin`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了命名类型在基本形式下的工作方式。示例中的代码将温度值进行转换。每个温度单位都由一个声明的类型表示，包括 `fahrenheit`、`celsius`
    和 `kelvin`。
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Type conversion
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'In general, Go considers each type to be different. This means under normal
    circumstances, values of different types are not fungible in assignment, function
    parameters, and expression contexts. This is true for built-in and declared types.
    For instance, the following will cause a build error due to type mismatch:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Go 将每个类型视为不同。这意味着在正常情况下，不同类型的值在赋值、函数参数和表达式上下文中是不可互换的。这对于内置和声明的类型都适用。例如，以下代码将由于类型不匹配而导致构建错误：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch04/type_conv.go
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/type_conv.go
- en: The expression `actual + count` causes a build time error because both variables
    are of different types. Even though variables `actual` and `count` are of numeric
    types and `int32` and `int` have the same memory representation, the compiler
    still rejects the expression.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `actual + count` 会导致编译时错误，因为这两个变量属于不同的类型。尽管变量 `actual` 和 `count` 都是数值类型，且
    `int32` 和 `int` 具有相同的内存表示，但编译器仍然拒绝这个表达式。
- en: The same is true for declared named types and their underlying types. The compiler
    will reject assignment `var event int = sig` because type `signal` is considered
    to be different from type `int`. This is true even though `signal` uses `int`
    as its underlying type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于声明的命名类型及其底层类型，也是如此。编译器会拒绝赋值 `var event int = sig`，因为类型 `signal` 被认为是与类型 `int`
    不同的。即使 `signal` 使用 `int` 作为其底层类型，这也是正确的。
- en: 'To cross type boundaries, Go supports a type conversion expression that converts
    value from one type to another. Type conversion is done using the following format:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要跨越类型边界，Go 支持类型转换表达式，可以将值从一种类型转换为另一种类型。类型转换使用以下格式进行：
- en: '*<target_type>(<value or expression>)*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*<目标类型>(<值或表达式>)*'
- en: 'The following code snippet fixes the previous example by converting the variables
    to the proper types:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段通过将变量转换为正确的类型来修复前面的示例：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The conversion expressions satisfy the assignment by explicitly changing the
    type of the enclosing values. Obviously, not all types can be converted from one
    to another. The following table summarizes common scenarios when type conversion
    is appropriate and allowed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 转换表达式通过显式更改封装值的类型来满足赋值。显然，并非所有类型都可以相互转换。以下表格总结了类型转换适当且允许的常见场景：
- en: '| **Description** | **Code** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **代码** |'
- en: '| The target type and converted value are both simple numeric types. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 目标类型和转换后的值都是简单的数值类型。 |'
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| The target type and the converted value are both complex numeric types. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 目标类型和转换后的值都是复杂的数值类型。 |'
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| The target type and converted value have the same underlying types. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 目标类型和转换后的值具有相同的底层类型。 |'
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| The target type is a string and the converted value is a valid integer type.
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 目标类型是字符串，转换后的值是有效的整数类型。 |'
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| The target type is string and the converted value is a slice of bytes, int32,
    or runes. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 目标类型是字符串，转换后的值是字节切片、int32 或 rune。 |'
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| The target type is a slice of byte, int32, or rune values and the converted
    value is a string. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 目标类型是字节切片、int32 或 rune 值的切片，转换后的值是字符串。 |'
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Additionally, the conversion rules also work when the target type and converted
    value are pointers that reference the same types. Besides these scenarios in the
    previous table, Go types cannot be explicitly converted. Any attempt to do so
    will result in a compilation error.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当目标类型和转换后的值都是指向相同类型的指针时，转换规则也适用。除了上表中的这些场景外，Go 类型不能显式转换。任何尝试这样做都会导致编译错误。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter presented its readers with an introduction the Go type system.
    The chapter opened with an overview of types and dove into a comprehensive exploration
    of the basic built-in types such as numeric, Boolean, string, and pointer types.
    The discussion continued by exposing the reader to other important topics such
    as named type definition. The chapter closed with coverage of the mechanics of
    type conversion. In coming chapters, you will get a chance to learn more about
    other types such as composite, function, and interface.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向读者介绍了 Go 的类型系统。本章从类型概述开始，深入探讨了基本内置类型，如数值、布尔、字符串和指针类型。讨论继续，向读者介绍了其他重要主题，例如命名类型定义。本章以类型转换机制的内容结束。在接下来的章节中，你将有机会了解更多关于其他类型，如复合类型、函数和接口。
