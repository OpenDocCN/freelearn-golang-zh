- en: Assigning untyped constants
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配未类型化的常量
- en: 'Untyped constant values are of limited use until they are assigned to variables,
    used as function parameters, or are part of an expression assigned to a variable.
    In a strongly-typed language like Go, this means there is a potential for some
    type adjustment to ensure that the value stored in the constant can be properly
    assigned to the target variable. One advantage of using untyped constants is that
    the type system relaxes the strict application of type checking. An untyped constant
    can be assigned to different, though compatible, types of different precision
    without any complaint from the compiler, as shown in the following example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 未类型化的常量值在分配给变量、用作函数参数或作为分配给变量的表达式的部分之前用途有限。在像Go这样的强类型语言中，这意味着存在一些类型调整的潜在可能性，以确保存储在常量中的值可以正确地分配给目标变量。使用未类型化常量的一个优点是类型系统放宽了对类型检查的严格应用。未类型化常量可以分配给不同但兼容的不同精度的类型，而不会引起编译器的任何抱怨，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While the type system will accommodate the assignment of `m2` to variables
    of different precision, the resulting assignment is adjusted to fit the variable
    type, as noted in the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型系统可以适应将`m2`分配给不同精度的变量，但结果分配将调整为适合变量类型，如下所示：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What about variable `u3`, which is itself an untyped variable? Since `u3` does
    not have a specified type, it will rely on type inference from the constant value
    to receive a type assignment. Recall from the discussion in the section *Omitting
    Variable Types* earlier, that constant literals are mapped to basic Go types based
    on their textual representations. Since constant `m2` represents a decimal value,
    the compiler will infer its default to be a `float64`, which will be automatically
    assigned to variable `u3`, as shown:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于未指定类型的变量`u3`，它本身就是一个未类型化的变量？由于`u3`没有指定类型，它将依赖于从常量值中推断出的类型来接收类型分配。回想一下之前在*省略变量类型*部分中的讨论，常量字面量根据其文本表示映射到基本的Go类型。由于常量`m2`表示一个十进制值，编译器将推断其默认类型为`float64`，这将自动分配给变量`u3`，如下所示：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, Go's treatment of untyped raw constant literals increases the
    language's usability by automatically applying some simple, but effective, type
    inference rules without sacrificing type-safety. Unlike other languages, developers
    do not have to explicitly specify the type in the value literal or perform some
    sort of typecast to make this work.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Go对未类型化的原始常量字面量的处理通过自动应用一些简单但有效的类型推断规则，在不牺牲类型安全性的情况下提高了语言的可用性。与其他语言不同，开发者不需要在值字面量中显式指定类型或执行某种类型的转换来使这成为可能。
