- en: Chapter 5. Functions in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of Go''s syntactical *tour de force* is via its support for higher-order
    functions as is found in dynamic languages such as Python or Ruby. As we will
    see in this chapter, a function is also a typed entity with a value that can be
    assigned to a variable. In this chapter, we are going to explore functions in
    Go covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Go functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameter values
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions and closures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error signaling handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferring function calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function panic and recovery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, functions are first-class, typed programming elements. A declared function
    literal always has a type and a value (the defined function itself) and can optionally
    be bound to a named identifier. Because functions can be used as data, they can
    be assigned to variables or passed around as parameters of other functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Function declaration
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring a function in Go takes the general form illustrated in the following
    figure. This canonical form is used to declare named and anonymous functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Function declaration](img/00013.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: The most common form of function definition in Go includes the function's assigned
    identifier in the function literal. To illustrate this, the following table shows
    the source code of several programs with definitions of named functions with different
    combinations of parameters and return types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch05/func0.go | A function with the name identifier `printPi`. It
    takes no parameter and returns no values. Notice when there is nothing to return,
    the `return` statement is optional. |
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch05/func1.go | A function named `avogadro.` It takes no parameter
    but returns a value of type `float64`. Notice the `return` statement is required
    when a return value is declared as part of the function's signature. |
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch05/func2.go | This defines the function `fib`. It takes parameter
    `n` of type `int` and prints the Fibonacci sequence for up to `n`. Again, nothing
    to return, therefore the `return` statement is omitted. |
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch05/func3.go | The last example defines the `isPrime` function.
    It takes a parameter of type `int` and returns a value of type `bool`. Since the
    function is declared to return a value of type `bool`, the last logical statement
    in the execution flow must be a `return` statement that returns a value of the
    declared type. |
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Function signature**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The set of specified parameter types, result types, and the order in which those
    types are declared is known as the signature of the function. It is another unique
    characteristic that help identify a function. Two functions may have the same
    number of parameters and result values; however, if the order of those elements
    are different, then the functions have different signatures.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The function type
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, the name identifier, declared in a function literal, is used to invoke
    the function using an invocation expression whereby the function identifier is
    followed by a parameter list. This is what we have seen throughout the book so
    far and it is illustrated in the following example calling the `fib` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When, however, a function''s identifier appears without parentheses, it is
    treated as a regular variable with a type and a value as shown in the following
    program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch05/functype.go
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The type of a function is determined by its signature. Functions are considered
    to be of the same type when they have the same number of arguments with the same
    types in the same order. In the previous example the `opAdd` variable is declared
    having the type `func (int, int) int` . This is the same signature as the declared
    functions `add` and `sub`. Therefore, the `opAdd` variable is assigned the `add`
    function variable. This allows `opAdd` to be invoked as you would invoke the `add`
    function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The same is done for the  `opSub` variable. It is assigned the value represented
    by the function identifier `sub` and type `func (int, int)`. Therefore, `opSub(99,13)`
    invokes the second function, which returns the result of a subtraction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Variadic parameters
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last parameter of a function can be declared as **variadic** (**variable
    length arguments**) by affixing ellipses (`…`) before the parameter's type. This
    indicates that zero or more values of that type may be passed to the function
    when it is called.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example implements two functions that accept variadic parameters.
    The first function calculates the average of the passed values and the second
    function sums up the numbers passed in as arguments:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: points := []float64{9, 4, 3.7, 7.1, 7.9, 9.2, 10}
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("sum(%v) = %f\n", points, sum(points...))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Function result parameters
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go functions can be defined to return one or more result values. So far in the
    book, most of the functions we have encountered have been defined to return a
    single result value. In general, a function is able to return a list of result
    values, with diverse types, separated by a comma (see the previous section, *Function
    declaration*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this concept, let us examine the following simple program which
    defines a function that implements an Euclidian division algorithm (see [http://en.wikipedia.org/wiki/Division_algorithm](http://en.wikipedia.org/wiki/Division_algorithm)).
    The `div` function returns both the quotient and the remainder values as its result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: golang.fyi/ch05/funcret0.go
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The `**return**` keyword is followed by the number of result values matching
    (respectively) the declared results in the function's signature. In the previous
    example, the signature of the `div` function specifies two `int` values to be
    returned as result values. Internally, the function defines `int` variables `p`
    and `r` that are returned as result values upon completion of the function. Those
    returned values must match the types defined in the function's signature or risk
    compilation errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions with multiple result values must be invoked in the proper context:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: They must be assigned to a list of identifiers of the same types respectively
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only be included in expressions that expect the same number of returned
    values
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is illustrated in the following source snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Named result parameters
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, the result list of a function''s signature can be specified using
    variable identifiers along with their types. When using named identifiers, they
    are passed to the function as regular declared variables and can be accessed and
    modified as needed. Upon encountering a `return` statement, the last assigned
    result values are returned. This is illustrated in the following source snippet,
    which is a rewrite of the previous program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: golang.fyi/ch05/funcret1.go
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `return` statement is naked; it omits all identifiers. As stated
    earlier, the values assigned in `q` and `r` will be returned to the caller. For
    readability, consistency, or style, you may elect not to use a naked `return`
    statement. It is perfectly legal to attach the identifier's name with the `return`
    statement (such as `return q, r`) as before.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameter values
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, all parameters passed to a function are done so by value. This means
    a local copy of the passed values is created inside the called function. There
    is no inherent concept of passing parameter values by reference. The following
    code illustrates this mechanism by modifying the value of the passed parameter,
    `val`, inside the `dbl` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch05/funcpassbyval.go
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program runs, it produces the following output that chronicles the
    state of the `p` variable before it is passed to the `dbl` function. The update
    is made locally to the passed parameter variable inside the `dbl` function, and
    lastly the value of the `p` variable after the `dbl` function is called:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding output shows that the original value assigned to variable `p`
    remains variable unchanged, even after it is passed to a function that seems to
    update its value internally. This is because the `val` parameter in the `dbl`
    function receives a local copy of the passed parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Achieving pass-by-reference
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the pass-by-value is appropriate in many cases, it is important to note
    that Go can achieve pass-by-reference semantics using pointer parameter values.
    This allows a called function to reach outside of its lexical scope and change
    the value stored at the location referenced by the pointer parameter as is done
    in the `half` function in the following example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch05/funcpassbyref.go
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the call to the `half(&num)` function in `main()`
    updates, in place, the original value referenced by its `num` parameter. So, when
    the code is executed, it shows the original value of `num` and its value after
    the call to the `half` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As was stated earlier, Go function parameters are passed by value. This is true
    even when the function takes a pointer value as its parameter. Go still creates
    and passes in a local copy of the pointer value. In the previous example, the
    `half` function receives a copy of the pointer value it receives via the `val`
    parameter. The code uses pointer operator (`*`) to dereference and manipulate,
    in place, the value referenced by `val`. When the `half` function exits and goes
    out of scope, its changes are accessible by calling the `main` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions and Closures
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions can be written as literals without a named identifier. These are
    known as anonymous functions and can be assigned to a variable to be invoked later
    as shown in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch05/funcs.go
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The previous program shows two anonymous functions declared and bound to the
    `mul` and `sqr` variables. In both cases, the functions take in parameters and
    return a value. Later in `main()`, the variables are used to invoke the function
    code bound to them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Invoking anonymous function literals
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is worth noting that an anonymous function does not have to be bound to
    an identifier. The function literal can be evaluated, in place, as an expression
    that returns the function''s result. This is done by ending the function literal
    with a list of argument values, enclosed in parentheses, as shown in the following
    program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the function literal ends with a parameter list enclosed within parentheses,
    the function is invoked as an expression.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go function literals are closures. This means they have lexical visibility
    to non-local variables declared outside of their enclosing code block. The following
    example illustrates this fact:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: github.com/vladimirvivien/learning-go/ch05/funcs.go
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In the previous program, the function literal code block, `func() float64 {return
    deg * math.Pi / 180}()`, is defined as an expression that converts degrees to
    radians. With each iteration of the loop, a closure is formed between the enclosed
    function literal and the outer non-local variable, `i`. This provides a simpler
    idiom where the function naturally accesses non-local values without resorting
    to other means such as pointers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go, lexically closed values can remain bounded to their closures long after
    the outer function that created the closure has gone out of scope. The garbage
    collector will handle cleanups as these closed values become unbounded.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already established that Go functions are values bound to a type. So,
    it should not be a surprise that a Go function can take another function as a
    parameter and also return a function as a result value. This describes the notion
    known as a higher-order function, which is a concept adopted from mathematics.
    While types such as `struct` let programmers abstract data, higher-order functions
    provide a mechanism to encapsulate and abstract behaviors that can be composed
    together to form more complex behaviors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this concept clearer, let us examine the following program, which uses
    a higher-order function, `apply`, to do three things. It accepts a slice of integers
    and a function as parameters. It applies the specified function to each element
    in the slice. Lastly, the `apply` function also returns a function as its result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch05/funchighorder.go
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'In the program, the `apply` function is invoked with an anonymous function
    that halves each element in the slice as highlighted in the following snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Error signaling and handling
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, let us address how to idiomatically signal and handle errors
    when you make a function call. If you have worked with languages such as Python,
    Java, or C#, you may be familiar with interrupting the flow of your executing
    code by throwing an exception when an undesirable state arises.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: As we will explore in this section, Go has a simplified approach to error signaling
    and error handling that puts the onus on the programmer to handle possible errors
    immediately after a called function returns. Go discourages the notion of interrupting
    an execution by indiscriminately short-circuiting the executing program with an
    exception in the hope that it will be properly handled further up the call stack.
    In Go, the traditional way of signaling errors is to return a value of type `error`
    when something goes wrong during the execution of your function. So let us take
    a closer look how this is done.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Signaling errors
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand what has been described in the previous paragraph, let
    us start with an example. The following source code implements an anagram program,
    as described in Column 2 from Jon Bentley's popular *Programming Pearls* book
    (second edition). The code reads a dictionary file (`dict.txt`) and groups all
    words with the same anagram. If the code does not quite make sense, please see
    [golang.fyi/ch05/anagram1.go](http://learning.golang.fyi/ch05/anagram1.go) for
    an annotated explanation of how each part of the program works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: when the expected filename (`fname`) is empty
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when the call to `os.Open()` fails (for example, permission error, or otherwise)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, when a filename is not provided, the code returns an error
    using `errors.New()` to create a value of type `error` to exit the function. In
    the second case, the `os.Open` function returns a pointer representing the file
    and an error assigned to the `file` and `err` variables respectively. If `err`
    is not `nil` (meaning an error was generated), the execution of the `load` function
    is halted prematurely and the value of `err` is returned to be handled by the
    calling function further up the call stack.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When returning an error for a function with multiple result parameters, it is
    customary to return the zero-value for the other (non-error type) parameters.
    In the example, a value of `nil` is returned for the result of type `[]string`.
    While not necessary, it simplifies error handling and avoids any confusion for
    function callers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `main` function is the topmost caller in the call stack, it handles
    the error by terminating the entire program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: This is all there is to the mechanics of error handling in Go. The language
    forces the programmer to always test for an erroneous state on every function
    call that returns a value of the type `error`. The `if…not…nil error` handling
    idiom may seem excessive and verbose to some, especially if you are coming from
    a language with formal exception mechanisms. However, the gain here is that the
    program can construct a robust execution flow where programmers always know where
    errors may come from and handle them appropriately.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The error type
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `error` type is a built-in interface and, therefore must be implemented
    before it can be used. Fortunately, the Go standard library comes with implementations
    ready to be used. We have already used one of the implementation from the package,
    `errors`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also create parameterized error values using the `fmt.Errorf` function
    as shown in the following snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[http://golang.org/src/os/error.go](http://golang.org/src/os/error.go)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: You can also create your own implementation of the `error` interface to create
    custom errors. This topic is revisited in [Chapter 7](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces, and Objects* where
    the book discusses the notion of extending types.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Deferring function calls
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go supports the notion of deferring a function call. Placing the keyword `defer`
    before a function call has the interesting effect of pushing the function unto
    an internal stack, delaying its execution right before the enclosing function
    returns. To better explain this, let us start with the following simple program
    that illustrates the use of `defer`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch05/defer1.go
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example defines the `do` function that takes variadic parameter
    `steps`. The function defers the statement with `defer fmt.Println("All done!")`.
    Next, the function loops through slice `steps` and defers the output of each element
    with `defer fmt.Println(s).` The last statement in the function `do` is a non-deferred
    call to `fmt.Println("Starting").` Notice the order of the printed string values
    when the program is executed, as shown in the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are a couple facts that explain the reverse order of the printout. First,
    recall that deferred functions are executed right before their enclosing function
    returns. Therefore, the first value printed is generated by the last non-deferred
    method call. Next, as stated earlier, deferred statements are pushed into a stack.
    Therefore, deferred calls are executed using a last-in-first-out order. That is
    why `"All done!"` is the last string value printed in the output.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Using defer
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch05/anagram2.go
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The pattern of opening-defer-closing resources is widely used in Go. By placing
    the deferred intent immediately after opening or creating a resource allows the
    code to read naturally and reduces the likeliness of creating a resource leakage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Function panic and recovery
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the chapter, it was stated that Go does not have the traditional
    exception mechanism offered by other languages. Nevertheless, in Go, there is
    a way to abruptly exit an executing function known as function panic. Conversely,
    when a program is panicking, Go provides a way of recovering and regaining control
    of the execution flow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Function panic
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Function panic recovery
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a function panics, as explained earlier, it can crash an entire program.
    That may be the desired outcome depending on your requirements. It is possible,
    however, to regain control after a panic sequence has started. To do this, Go
    offers the built-in function called `recover`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Recover works in tandem with panic. A call to function recover returns the
    value that was passed as an argument to panic. The following code shows how to
    recover from the panic call that was introduced in the previous example. In this
    version, the write function is moved inside `makeAnagram()` for clarity. When
    the `write` function is invoked from `makeAnagram()` and fails to open a file,
    it will panic. However, additional code is now added to recover:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: golang.fyi/ch05/anagram3.go
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to recover from an unwinding panic sequence, the code must make
    a deferred call to the recover function. In the previous code, this is done in
    the `makeAnagrams` function by wrapping `recover()` inside an anonymous function
    literal, as highlighted in the following snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the deferred `recover` function is executed, the program has an opportunity
    to regain control and prevent the panic from crashing the running program. If
    `recover()` returns `nil`, it means there is no current panic unwinding up the
    call stack or the panic was already handled downstream.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now when the program is executed, instead of crashing with a stack trace,
    the program recovers and gracefully displays the issue as shown in the following
    output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当程序执行时，它不会因为堆栈跟踪而崩溃，而是恢复并优雅地显示问题，如下面的输出所示：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering why we are using a `nil` to test the value returned by
    the `recover` function when a string was passed inside the call to `panic`. This
    is because both panic and recover take an empty interface type. As you will learn,
    the empty interface type is a generic type with the ability to represent any type
    in Go's type system. We will learn more about the empty interface in [Chapter
    7](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 8. Methods,
    Interfaces, and Objects"), *Methods, Interfaces and Objects* during discussions
    about interfaces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在调用`panic`函数时传递了一个字符串，却在测试`recover`函数返回的值时使用了一个`nil`。这是因为`panic`和`recover`都接受一个空的接口类型。正如你将要学习的，空的接口类型是一个泛型类型，它具有在Go的类型系统中表示任何类型的能力。我们将在[第7章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第8章。方法、接口和对象")，*方法、接口和对象*的讨论中了解更多关于空接口的内容。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented its reader with an exploration of Go functions. It started
    with an overview of named function declarations, followed by a discussion on function
    parameters. The chapter delved into a discussion of function types and function
    values. The last portion of the chapter discussed the semantics of error handling,
    panic, and recovery. The next chapter continues the discussion of functions; however,
    it does so within the context of Go packages. It explains the role of a package
    as a logical grouping of Go functions (and other code elements) to form sharable
    and callable code modules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向读者展示了Go函数的探索。它从命名函数声明的概述开始，然后讨论了函数参数。本章深入讨论了函数类型和函数值。章节的最后部分讨论了错误处理、panic和恢复的语义。下一章将继续讨论函数；然而，它是在Go包的上下文中进行的。它解释了包作为Go函数（和其他代码元素）的逻辑分组的作用，以形成可共享和可调用的代码模块。
