["```go\n foo\n ├── blat.go\n └── bazz\n ├── quux.go\n └── qux.go \n\n```", "```go\npackage foo \n\nimport ( \n   \"fmt\" \n   \"foo/bar/bazz\" \n) \n\nfunc fooIt() { \n   fmt.Println(\"Foo!\") \n   bazz.Qux() \n} \n\n```", "```go\npackage bazz\nimport \"fmt\"\nfunc Qux() {\n  fmt.Println(\"bazz.Qux\")\n}\n```", "```go\npackage bazz\nimport \"fmt\"\nfunc Quux() {\n  Qux()fmt.Println(\"gazz.Quux\")\n}\n```", "```go\n/home/vladimir/Go/   \n├── bin   \n│  ├── circ   \n│  ├── golint   \n│  ...   \n├── pkg   \n│  └── linux_amd64    \n│    ├── github.com   \n│    │  ├── golang   \n│    │  │  └── lint.a   \n│    │  └── vladimirvivien   \n│    │    └── learning-go   \n│    │      └── ch06   \n│    │        ├── current.a   \n│    ...       ...    \n└── src   \n  ├── github.com   \n  │  ├── golang   \n  │  │  └── lint   \n  │  │    ├── golint   \n  │  │    │  ├── golint.go   \n  │  ...   ... ...   \n  │  └── vladimirvivien   \n  │    └── learning-go   \n  │      ├── ch01   \n  │      ...   \n  │      ├── ch06   \n  │      │  ├── current   \n  │      │  │  ├── doc.go   \n  │      │  │  └── lib.go   \n  ...     ...      \n\n```", "```go\n$> export GOPATH=/home/username/Go \n\n```", "```go\n$> export GOPATH=/home/myaccount/Go;/home/myaccount/poc/Go\n\n```", "```go\n/home/username/Go\n└── foo\n ├── ablt.go\n └── bazz\n ├── quux.go\n └── qux.go \n\n```", "```go\n\"foo\"   \n\n```", "```go\n\"foo/bar\"   \n\n```", "```go\n\"foo/bar/bazz\"   \n\n```", "```go\ngithub.com/vladimirvivien/learning-go/ch06   \n├── current   \n│  ├── curr.go   \n│  └── doc.go   \n├── power   \n│  ├── doc.go   \n│  ├── ir   \n│  │  └── power.go   \n│  ├── powlib.go   \n│  └── vr   \n│    └── power.go   \n├── resistor   \n│  ├── doc.go   \n│  ├── lib.go   \n│  ├── res_equivalence.go   \n│  ├── res.go   \n│  └── res_power.go   \n└── volt   \n  ├── doc.go   \n  └── volt.go   \n\n```", "```go\npackage volt \n\nfunc V(i, r float64) float64 { \n   return i * r \n} \n\nfunc Vser(volts ...float64) (Vtotal float64) { \n   for _, v := range volts { \n         Vtotal = Vtotal + v \n   } \n   return \n} \n\nfunc Vpi(p, i float64) float64 { \n   return p / i \n} \n\n```", "```go\npackage resistor   \n\nfunc recip(val float64) float64 {   \n   return 1 / val   \n}   \n\n```", "```go\n  package resistor   \n\nfunc Rser(resists ...float64) (Rtotal float64) {   \n   for _, r := range resists {   \n         Rtotal = Rtotal + r   \n   }   \n   return   \n}   \n\nfunc Rpara(resists ...float64) (Rtotal float64) {   \n   for _, r := range resists {   \n         Rtotal = Rtotal + recip(r)   \n   }   \n   return   \n}   \n\n```", "```go\npackage resistor   \n\nfunc R(v, i float64) float64 {   \n   return v / i   \n}   \n\n```", "```go\npackage resistor   \n\nfunc Rvp(v, p float64) float64 {   \n   return (v * v) / p   \n}   \n\n```", "```go\n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go\n$> go build ./ch06/volt \n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06\n$> go build ./volt \n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06/volt\n$> go build . \n$> cd $GOPATH/src/ \n$> go build github.com/vladimirvivien/learning-go/ch06/current /volt\n\n```", "```go\n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06\n$> go build ./...\n\n```", "```go\n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06\n$> go install ./volt\n\n```", "```go\n$GOPATH/pkg/linux_amd64/github.com/vladimirvivien/learning-go/\n└── ch06\n └── volt.a\n\n```", "```go\npackage foo   \n\nvar (   \n  bar int = 12   \n)   \n\nfunc qux () {   \n  bar += bar   \n}   \n\n```", "```go\npackage foo   \n\nvar bar struct{   \n  x, y int   \n}   \n\nfunc quux() {   \n  bar = bar * bar   \n}   \n\n```", "```go\npackage foo   \n\nvar (   \n  bar int = 12   \n)   \n\nfunc qux () {   \n  bar += bar   \n}   \n\n```", "```go\npackage foo   \n\nvar (   \n  fooVal int = 12   \n)   \n\nfunc qux (inc int) int {   \n  return fooVal += inc   \n}   \n\n```", "```go\npackage resistor   \n\nfunc R(v, i float64) float64 {   \n   return v / i   \n}   \n\n```", "```go\npackage resistor   \n\nfunc recip(val float64) float64 {   \n   return 1 / val   \n}   \n\n```", "```go\nimport ( \n   \"flag\" \n   \"fmt\" \n   \"os\" \n\n   \"github.com/vladimirvivien/learning-go/ch06/current\" \n   \"github.com/vladimirvivien/learning-go/ch06/power\" \n   \"github.com/vladimirvivien/learning-go/ch06/power/ir\" \n   \"github.com/vladimirvivien/learning-go/ch06/power/vr\" \n      \"github.com/vladimirvivien/learning-go/ch06/volt\" \n) \n\n```", "```go\nvolt.V() is invoked from imported package \"github.com/vladimirvivien/learning-go/ch06/volt\":\n```", "```go\n... \nimport \"github.com/vladimirvivien/learning-go/ch06/volt\" \nfunc main() { \n   ... \n   switch op { \n   case \"V\", \"v\": \n         val := volt.V(i, r) \n  ... \n} \n\n```", "```go\nimport res \"github.com/vladimirvivien/learning-go/ch06/resistor\"\n```", "```go\npackage foo \nimport ( \n   flog \"github.com/woom/bat/logger\" \n   hlog \"foo/bar/util/logger\" \n) \n\nfunc main() { \n   flog.Info(\"Programm started\") \n   err := doSomething() \n   if err != nil { \n     hlog.SubmitError(\"Error - unable to do something\") \n   } \n} \n\n\"logger\" by default. To resolve this, at least one of the imported packages must be assigned a name identifier to resolve the name clash. In the previous example, both import paths were named with a meaningful name to help with code comprehension.\n```", "```go\nSubmitError from the logger package, the package name is omitted:\n```", "```go\npackage foo \n\nimport ( \n   . \"foo/bar/util/logger\" \n) \n\nfunc main() { \n   err := doSomething() \n   if err != nil { \n     SubmitError(\"Error - unable to do something\") \n   } \n} \n\n```", "```go\nfmt; however, it never uses it in the subsequent source code:\n```", "```go\npackage foo \nimport ( \n   _ \"fmt\" \n   \"foo/bar/util/logger\" \n) \n\nfunc main() { \n   err := doSomething() \n   if err != nil { \n     logger.Submit(\"Error - unable to do something\") \n   } \n} \n\n```", "```go\nfoo will be a, y, b, and x:\n```", "```go\npackage foo \nvar x = a + b(a) \nvar a = 2 \nvar b = func(i int) int {return y * i} \nvar y = 3 \n\n```", "```go\npackage resistor \n\nvar Rpi func(float64, float64) float64 \n\nfunc init() { \n   Rpi = func(p, i float64) float64 { \n         return p / (i * i) \n   } \n} \n\nfunc Rvp(v, p float64) float64 { \n   return (v * v) / p \n} \n\n```", "```go\npackage main \nimport ( \n   \"flag\" \n   \"fmt\" \n   \"os\" \n\n   \"github.com/vladimirvivien/learning-go/ch06/current\" \n   \"github.com/vladimirvivien/learning-go/ch06/power\" \n   \"github.com/vladimirvivien/learning-go/ch06/power/ir\" \n   \"github.com/vladimirvivien/learning-go/ch06/power/vr\" \n   res \"github.com/vladimirvivien/learning-go/ch06/resistor\" \n   \"github.com/vladimirvivien/learning-go/ch06/volt\" \n) \n\nvar ( \n   op string \n   v float64 \n   r float64 \n   i float64 \n   p float64 \n\n   usage = \"Usage: ./circ <command> [arguments]\\n\" + \n     \"Valid command { V | Vpi | R | Rvp | I | Ivp |\"+  \n    \"P | Pir | Pvr }\" \n) \n\nfunc init() { \n   flag.Float64Var(&v, \"v\", 0.0, \"Voltage value (volt)\") \n   flag.Float64Var(&r, \"r\", 0.0, \"Resistance value (ohms)\") \n   flag.Float64Var(&i, \"i\", 0.0, \"Current value (amp)\") \n   flag.Float64Var(&p, \"p\", 0.0, \"Electrical power (watt)\") \n   flag.StringVar(&op, \"op\", \"V\", \"Command - one of { V | Vpi |\"+   \n    \" R | Rvp | I | Ivp | P | Pir | Pvr }\") \n} \n\nfunc main() { \n   flag.Parse() \n   // execute operation \n   switch op { \n   case \"V\", \"v\": \n    val := volt.V(i, r) \n    fmt.Printf(\"V = %0.2f * %0.2f = %0.2f volts\\n\", i, r, val) \n   case \"Vpi\", \"vpi\": \n   val := volt.Vpi(p, i) \n    fmt.Printf(\"Vpi = %0.2f / %0.2f = %0.2f volts\\n\", p, i, val) \n   case \"R\", \"r\": \n   val := res.R(v, i)) \n    fmt.Printf(\"R = %0.2f / %0.2f = %0.2f Ohms\\n\", v, i, val) \n   case \"I\", \"i\": \n   val := current.I(v, r)) \n    fmt.Printf(\"I = %0.2f / %0.2f = %0.2f amps\\n\", v, r, val) \n   ... \n   default: \n         fmt.Println(usage) \n         os.Exit(1) \n   } \n} \n\n```", "```go\npackage main \nimport ( \n   \"fmt\" \n   \"os\" \n) \n\nfunc main() { \n   for _, arg := range os.Args { \n         fmt.Println(arg) \n   } \n} \n\n```", "```go\n$> go run hello.go hello world how are you?\n/var/folders/.../exe/hello\nhello\nworld\nhow\nare\nyou?\n\n```", "```go\nvar ( \n   op string \n   v float64 \n   r float64 \n   i float64 \n   p float64 \n) \n\nfunc init() { \n   flag.Float64Var(&v, \"v\", 0.0, \"Voltage value (volt)\") \n   flag.Float64Var(&r, \"r\", 0.0, \"Resistance value (ohms)\") \n   flag.Float64Var(&i, \"i\", 0.0, \"Current value (amp)\") \n   flag.Float64Var(&p, \"p\", 0.0, \"Electrical power (watt)\") \n   flag.StringVar(&op, \"op\", \"V\", \"Command - one of { V | Vpi |\"+   \n    \" R | Rvp | I | Ivp | P | Pir | Pvr }\") \n} \nfunc main(){ \n  flag.Parse() \n  ... \n} \n\ninit used to parse and initialize expected flags \"v\", \"i\", \"p\", and \"op\" (at runtime, each flag is prefixed with a minus sign). The initialization functions in package flag sets up the expected type, the default value, a flag description, and where to store the parsed value for the flag. The flag package also supports the special flag \"help\", used to provide helpful hints about each flag.\n```", "```go\n$> go run main.go -op I -v 12 -r 300\nI = 12.00 / 300.00 = 0.04 amps\n\n```", "```go\n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06\n$> go build .\n\n```", "```go\n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06\n$> go build -o ohms\n\n```", "```go\n$> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06\n$> go install .\n\n```", "```go\n$> go get github.com/vladimirvivien/learning-go/ch06/volt\n\n```"]