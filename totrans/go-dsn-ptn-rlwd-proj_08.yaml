- en: Chapter 7. Composite Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。复合类型
- en: 'In prior chapters, you may have caught glimpses of the use of composite types
    such as arrays, slices, maps, and structs in some of the sample code. While early
    exposure to these types may have left you curious, rest assured in this chapter
    you will get a chance to learn all about these composite types. This chapter continues
    what started in [Chapter 4](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 4. Data Types"), *Data Types*, with discussions covering the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你可能在一些示例代码中瞥见了复合类型（如数组、切片、映射和结构体）的使用。虽然早期接触这些类型可能让你感到好奇，但请放心，在本章中，你将有机会学习所有关于这些复合类型的内容。本章继续了[第4章](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第4章。数据类型")中开始的内容，*数据类型*，讨论以下主题：
- en: The array type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型
- en: The slice type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片类型
- en: The map type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射类型
- en: The struct type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体类型
- en: The array type
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组类型
- en: 'As you would find in other languages, Go arrays are containers for storing
    sequenced values of the same type that are numerically indexed. The following
    code snippet shows samples of variables that are assigned array types:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在其他语言中找到的那样，Go 数组是用于存储相同类型数值序列的容器，这些数值可以通过数字索引访问。以下代码片段展示了被分配数组类型的变量示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch07/arrtypes.go
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrtypes.go
- en: 'Notice the types that are assigned to each variable in the previous example
    are specified using the following type format:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前面示例中分配给每个变量的类型是使用以下类型格式指定的：
- en: '*[<length>]<element_type>*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*[<长度>]<元素类型>*'
- en: 'The type definition of an array is composed of its length, enclosed within
    brackets, followed by the type of its stored elements. For instance, the `days`
    variable is assigned a type `[7]string`. This is an important distinction as Go''s
    type system considers two arrays, storing the same type of elements but with different
    lengths, to be of different types. The following code illustrates this situation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型定义由其长度组成，长度用括号括起来，后跟存储元素的类型。例如，`days` 变量被分配了一个类型 `[7]string`。这是一个重要的区别，因为
    Go 的类型系统认为存储相同类型元素但长度不同的两个数组是不同类型的。以下代码说明了这种情况：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though both variables are arrays with elements of type `string`, the type
    system considers the `days` and `weekdays` variables as different types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这两个变量都是类型为 `string` 的数组，类型系统仍然将 `days` 和 `weekdays` 变量视为不同的类型。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Later in the chapter, you will see how this type restriction is mitigated with
    the use of the slice type instead of arrays.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将看到如何使用切片类型而不是数组来减轻这种类型限制。
- en: 'Array types can be defined to be multi-dimensions. This is done by combining
    and nesting the definition of one-dimensional array types as shown in the following
    snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型可以被定义为多维。这是通过组合和嵌套一维数组类型的定义来实现的，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch07/arrtypes.go
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrtypes.go
- en: Go does not have a separate type for multi-dimensional arrays. An array with
    more than one dimension is composed of one-dimensional arrays that are nested
    within each other. The next section covers how single and multi-dimensional arrays
    are initialized.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go 没有单独的多维数组类型。具有多个维度的数组是由嵌套在彼此内部的一维数组组成的。下一节将介绍如何初始化单维和多维数组。
- en: Array initialization
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组初始化
- en: 'When an array variable is not explicitly initialized, all of its elements will
    be assigned the zero-value for the declared type of the elements. An array can
    be initialized with a composite literal value with the following general format:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数组变量没有显式初始化时，它的所有元素都将被分配给声明类型为零值。数组可以使用以下通用格式的复合字面量值进行初始化：
- en: '*<array_type>{<comma-separated list of element values>}*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*<数组类型>{<逗号分隔的元素值列表}>*'
- en: 'The literal value for an array is composed of the array type definition (discussed
    in the previous section) followed by a set of comma-separated values, enclosed
    in curly brackets, as illustrated by the following code snippet, which shows several
    arrays being declared and initialized:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的字面值由数组类型定义（在上一节中讨论）后跟一组逗号分隔的值组成，并用大括号括起来，如下面的代码片段所示，该片段展示了几个数组的声明和初始化：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch07/arrinit.go
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrinit.go
- en: 'The number of elements in the literal must be less than or equal to the size
    declared in the array type. If the array defined is multi-dimensional, it can
    be initialized using literal values by nesting each dimension within the enclosing
    brackets of another, as shown in the following example snippets:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 字面值中的元素数量必须小于或等于数组类型中声明的尺寸。如果定义的数组是多维的，可以通过在每个维度内部嵌套另一个维度的括号来使用字面值进行初始化，如下面的示例片段所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The literal value of an array can also be indexed. This is useful if you want
    to initialize only certain array elements while allowing others to be initialized
    with their natural zero-value. The following specifies the initial values for
    elements at positions 0, `2`, `4`, `6`, `8`. The remaining elements will be assigned
    the empty string:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的字面值也可以进行索引。如果你只想初始化某些数组元素，同时允许其他元素使用它们的自然零值进行初始化，这很有用。以下指定了位置0、`2`、`4`、`6`、`8`的元素初始值。其余元素将被分配空字符串：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Declaring named array types
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明命名数组类型
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: golang.fyi/ch07/arrtype_dec.go
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrtype_dec.go
- en: The declared named type, `matrix`, can be used in all contexts where its underlying
    array type is used. This allows a simplified syntax that promotes reuse of the
    complex array type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的命名类型`matrix`可以在所有其底层数组类型被使用的上下文中使用。这允许使用简化的语法，从而促进复杂数组类型的重用。
- en: Using arrays
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组
- en: Arrays are static entities that cannot grow or shrink in size once they are
    declared with a specified length. Arrays are a great option when a program needs
    to allocate a block of sequential memory of a predefined size. When a variable
    of an array type is declared, it is ready to be used without any further allocation
    semantics.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是静态实体，一旦声明了指定长度，就不能增长或缩小。当程序需要分配一个预定义大小的连续内存块时，数组是一个很好的选择。当声明数组类型的变量时，它就准备好使用，无需任何进一步的分配语义。
- en: 'So the following declaration of the `image` variable would allocate a memory
    block composed of 256 adjacent `int` values initialized with zeroes, as shown
    in the following figure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下`image`变量的声明将分配一个由256个相邻的`int`值组成的内存块，这些值初始化为零，如图所示：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Using arrays](img/00015.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用数组](img/00015.jpeg)'
- en: 'Similar to C and Java, Go uses the square brackets index expression to access
    values stored in an array variable. This is done by specifying the variable identifier
    followed by an index of the element enclosed within the square brackets, as shown
    in the following code sample:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与C和Java类似，Go使用方括号索引表达式来访问存储在数组变量中的值。这是通过指定变量标识符后跟方括号内元素的索引来完成的，如下面的代码示例所示：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code updates the fifth element and prints the first element in
    the array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码更新了数组的第五个元素并打印了第一个元素。
- en: Array length and capacity
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组长度和容量
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For arrays, the `cap()` function always returns the same value as `len()`. This
    is because the maximum capacity of an array value is its declared length. The
    capacity function is better suited for use with the slice type (discussed later
    in the chapter).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，`cap()`函数始终返回与`len()`相同的值。这是因为数组值的最大容量是其声明的长度。容量函数更适合与切片类型（本章后面讨论）一起使用。
- en: Array traversal
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组遍历
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch07/arrmax_iter.go
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrmax_iter.go
- en: In the traditional `for` statement, the loop's index variable `i` is used to
    access the value of the array using the index expression `num[i]`. In the `for…range`
    statement, in the `max` function, the iterated value is stored in the `val` variable
    with each pass of the loop and the index is ignored (assigned to the blank identifier).
    If you do not understand how *for* statements work, refer to [Chapter 3](part0022_split_000.html#KVCC1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 3. Go Control Flow"), *Go Control Flow*, for a thorough explanation of
    the mechanics of loops in Go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的`for`循环语句中，循环的索引变量`i`用于通过索引表达式`num[i]`访问数组的值。在`for…range`语句中，在`max`函数中，每次循环迭代值存储在`val`变量中，而索引被忽略（赋给空标识符）。如果你不明白`for`语句是如何工作的，请参阅[第3章](part0022_split_000.html#KVCC1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第3章。Go控制流")，*Go控制流*，以详细了解Go中循环的机制。
- en: Array as parameters
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组作为参数
- en: Arrays values are treated as a single unit. An array variable is not a pointer
    to a location in memory, but rather represents the entire block of memory containing
    the array elements. This has the implications of creating a new copy of an array
    value when the array variable is reassigned or passed in as a function parameter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数组值被视为一个单一单元。数组变量不是指向内存中位置的指针，而是代表包含数组元素的整个内存块。这意味着当数组变量被重新赋值或作为函数参数传递时，会创建数组值的副本。
- en: 'This could have unwanted side effects on memory consumption for a program.
    One fix for is to use pointer types to reference array values. In the following
    example, a named type, `numbers`, is declared to represent array type `[1024 *
    1024]]int`. Instead of taking the array value directly as parameters, functions
    `initialize()` and `max()` receive a pointer of type `*numbers`, as shown in the
    following source snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会对程序的内存消耗产生不良影响。一个解决方案是使用指针类型来引用数组值。在以下示例中，声明了一个名为`numbers`的命名类型，以表示数组类型`[1024
    * 1024]int`。函数`initialize()`和`max()`接收类型为`*numbers`的指针，如下面的源代码片段所示：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch07/arraddr.go
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arraddr.go
- en: The array type is a low-level storage construct in Go. Arrays, for instance,
    are usually used as the basis for storage primitives, where there are strict memory
    allocation requirements to minimize space consumption. In more common cases however,
    the slice, covered in the next section, is often used as the more idiomatic way
    of working with sequenced indexed collections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型是Go中的低级存储结构。例如，数组通常用作存储原语的基础，其中对内存分配有严格的限制，以最小化空间消耗。然而，在更常见的案例中，下一节中介绍的切片通常用作处理有序索引集合的更习惯的方式。
- en: The slice type
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片类型
- en: 'The slice type is commonly used as the idiomatic construct for indexed data
    in Go. The slice is more flexible and has many more interesting characteristics
    than arrays. The slice itself is a composite type with semantics similar to arrays.
    In fact, a slice uses an array as its underlying data storage mechanism. The general
    form of a slice type is given as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类型在Go中通常用作索引数据的习惯构造。切片比数组更灵活，具有许多更有趣的特性。切片本身是一个复合类型，其语义类似于数组。实际上，切片使用数组作为其底层数据存储机制。切片类型的通用形式如下所示：
- en: '*[ ]<element_type>*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*[ ]<element_type>*'
- en: 'The one obvious difference between a slice and an array type is omission of
    the size in the type declaration, as shown in the following examples:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类型与数组类型之间一个明显的区别是在类型声明中省略了大小，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch07/slicetypes.go
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slicetypes.go
- en: 'The missing size attribute in the slice type indicates the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类型中缺失的大小属性表示以下内容：
- en: Unlike arrays, the size of a slice is not fixed
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组不同，切片的大小不是固定的
- en: A slice type represents all sets of the specified element type
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片类型代表所有指定元素类型的集合
- en: This means a slice can theoretically grow unbounded (though in practice this
    is not true as the slice is backed by an underlying bounded array). A slice of
    a given element type is considered to be the same type regardless of its underlying
    size. This removes the restriction found in arrays where the size determines the
    type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着切片理论上可以无限制地增长（尽管在实践中并不总是这样，因为切片由一个底层的有界数组支持）。给定元素类型的切片被认为是同一类型，无论其底层大小如何。这消除了数组中存在的限制，即大小决定了类型。
- en: 'For instance, the following variables, `months` and `q1`, have the same type
    of `[]string` and will compile with no problem:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下变量`months`和`q1`具有相同的`[]string`类型，并且可以无问题编译：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch07/slicetypes.go
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slicetypes.go
- en: 'Similar to arrays, slice types may be nested to create multi-dimensional slices,
    as shown in the following code snippet. Each dimension can independently have
    its own size and must be initialized individually:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，切片类型可以嵌套以创建多维切片，如下代码片段所示。每个维度可以独立地有自己的大小，并且必须单独初始化：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Slice initialization
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片初始化
- en: A slice is represented by the type system as a value (the next section explores
    the internal representation of a slice). However, unlike the array type, an uninitialized
    slice has a zero value of *nil*, which means any attempt to access elements of
    an uninitialized slice will cause a program to panic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 切片在类型系统中表示为一个值（下一节将探讨切片的内部表示）。然而，与数组类型不同，未初始化的切片具有零值`nil`，这意味着尝试访问未初始化切片的元素将导致程序崩溃。
- en: 'One of the simplest ways to initialize a slice is with a composite literal
    value using the following format (similar to an array):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化切片的最简单方法之一是使用以下格式的复合字面值（类似于数组）：
- en: '*<slice_type>{<comma-separated list of element values>}*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*<slice_type>{<逗号分隔的元素值列表}>*'
- en: 'The literal value for a slice is composed of the slice type followed by a set
    of comma-separated values, enclosed in curly brackets, that are assigned to the
    elements of the slice. The following code snippet illustrates several slice variables
    initialized with composite literal values:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的字面值由切片类型后跟一系列用逗号分隔的值组成，这些值用花括号括起来，并分配给切片的元素。以下代码片段展示了几个使用复合字面值初始化的切片变量：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch07/sliceinit.go
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/sliceinit.go
- en: As mentioned, the composite literal value of a slice is expressed using a similar
    form as the array. However, the number of elements provided in the literal is
    not bounded by a fixed size. This implies that the literal can be as large as
    needed. Under the cover though, Go creates and manages an array of appropriate
    size to store the values expressed in the literal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，切片的复合字面值使用与数组类似的形式表示。然而，字面值中提供的元素数量不受固定大小的限制。这意味着字面值可以按需扩展。然而，在幕后，Go 会创建并管理一个适当大小的数组来存储字面值中表达的价值。
- en: Slice representation
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片表示
- en: 'Earlier it was mentioned that the slice value uses an underlying array to store
    data. The name *slice*, in fact, is a reference to a slice of data segment from
    the array. Internally, a slice is represented by a composite value with the followings
    three attributes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到，切片值使用底层数组来存储数据。实际上，“切片”这个名字是指向数组数据段的引用。在内部，切片通过以下三个属性表示为一个复合值：
- en: '| **Attribute** | **Description** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| a *pointer* | The pointer is the address of the first element of the slice
    stored in an underlying array. When the slice value is uninitialized, its pointer
    value is nil, indicating that it is not pointing to an array yet.Go uses the pointer
    as the zero value of the slice itself. An uninitialized slice will return nil
    as its zero value. However, the slice value is not treated as a reference value
    by the type system. This means certain functions can be applied to a nil slice
    while others will cause a panic.Once a slice is created, the pointer does not
    change. To point to a different starting point, a new slice must be created. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| *指针* | 指针是切片存储在底层数组中的第一个元素的地址。当切片值未初始化时，其指针值为 nil，表示它尚未指向一个数组。Go 使用指针作为切片本身的零值。未初始化的切片将返回
    nil 作为其零值。然而，切片值在类型系统中不被视为引用值。这意味着某些函数可以应用于 nil 切片，而其他函数将导致恐慌。一旦创建切片，指针就不会改变。要指向不同的起始点，必须创建一个新的切片。|'
- en: '| a *length* | The length indicates the number of contiguous elements that
    can be accessed starting with the first element. It is a dynamic value that can
    grow up to the capacity of the slice (see capacity next).The length of a slice
    is always less than or equal to its capacity. Attempts to access elements beyond
    the length of a slice, without resizing, will result in a panic. This is true
    even when the capacity is larger than the length. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| *长度* | 长度表示从第一个元素开始可以访问的连续元素的数量。它是一个动态值，可以增长到切片的容量（见下文容量）。切片的长度始终小于或等于其容量。尝试访问切片长度之外的元素，而不进行大小调整，将导致恐慌。即使容量大于长度，这也适用。|'
- en: '| a *capacity* | The capacity of a slice is the maximum number of elements
    that may be stored in the slice, starting from its first element. The capacity
    of a slice is bounded by the length of the underlying array. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| *容量* | 切片的容量是指从第一个元素开始可能存储在切片中的最大元素数量。切片的容量受底层数组长度的限制。|'
- en: 'So, when the following variable `halfyr` is initialized as shown:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当以下变量 `halfyr` 如下初始化时：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It will be stored in an array of type `[6]string` with a pointer to the first
    element, a length, and a capacity of `6`, as represented graphically in the following
    figure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被存储在一个类型为 `[6]string` 的数组中，包含指向第一个元素的指针、长度和容量为 `6`，如图所示：
- en: '![Slice representation](img/00016.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![切片表示](img/00016.jpeg)'
- en: Slicing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片操作
- en: 'Another way to create a slice value is by slicing an existing array or another
    slice value (or pointers to these values). Go provides an indexing format that
    makes it easy to express the slicing operation, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建切片值的另一种方法是通过对现有数组或另一个切片值（或这些值的指针）进行切片。Go 提供了一种索引格式，使得表达切片操作变得容易，如下所示：
- en: '*<slice or array value>[<low_index>:<high_index>]*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*<切片或数组值>[<低索引>:<高索引>]*'
- en: The slicing expression uses the [`:`] operator to specify the low and high bound
    indices, separated by a colon, for the slice segment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 切片表达式使用 `[:]` 操作符来指定低界和高界索引，由冒号分隔，用于切片段。
- en: The *low* value is the zero-based index where the slice segment starts
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*低*值是切片段开始的零基于索引'
- en: The *high* value is the *n^(th)* element offset where the segment stops
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高*值是段停止处的第 *n* 个元素偏移量'
- en: 'The following table shows examples of slice expressions by re-slicing the following
    value: `halfyr := []string{"Jan","Feb","Mar","Apr","May","Jun"}`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了通过重新切片以下值 `halfyr := []string{"Jan","Feb","Mar","Apr","May","Jun"}` 的切片表达式示例。
- en: '| **Expression** | **Description** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `all := halfyr[:]` | Omitting the low and high indices in the expression
    is equivalent to the following:`all := halfyr[0 : 6]`This produces a new slice
    segment equal to the original, which starts at index position 0 and stops at offset
    position `6`:`["Jan","Feb","Mar","Apr","May","Jun"]` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `all := halfyr[:]` | 在表达式中省略低索引和高索引相当于以下内容：`all := halfyr[0 : 6]` 这将产生一个新的切片段，与原始切片相等，从索引位置
    0 开始，到偏移位置 `6` 结束：`["Jan","Feb","Mar","Apr","May","Jun"]` |'
- en: '| `q1 := halfyr[:3]` | Here the slice expression omits low index value and
    specifies a slice segment length of `3`. It returns new slice, `["Jan","Feb","Mar"]`.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `q1 := halfyr[:3]` | 这里切片表达式省略了低索引值并指定了切片段长度为 `3`。它返回一个新的切片，`["Jan","Feb","Mar"]`。|'
- en: '| `q2 := halfyr[3:]` | This creates a new slice segment with the last three
    elements by specifying the staring index position of `3` and omitting the high
    bound index value, which defaults to `6`. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `q2 := halfyr[3:]` | 这通过指定起始索引位置为 `3` 并省略高界索引值（默认为 `6`），创建了一个新的切片段，包含最后三个元素。|'
- en: '| `mapr := halfyr[2:4]` | To clear any confusion about slicing expressions,
    this example shows how to create a new slice with the months `"Mar"` and `"Apr"`.
    This returns a slice with the value `["Mar","Apr"]`. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `mapr := halfyr[2:4]` | 为了消除对切片表达式的任何混淆，此示例展示了如何创建一个新的切片，包含月份 `"Mar"` 和 `"Apr"`。这返回一个值为
    `["Mar","Apr"]` 的切片。|'
- en: Slicing a slice
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片切片
- en: 'Slicing an existing slice or array value does not create a new underlying array.
    The new slice creates new pointer location to the underlying array. For instance,
    the following code shows the slicing of the slice value `halfyr` into two additional
    slices:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 切片现有的切片或数组值不会创建一个新的底层数组。新的切片创建新的指针位置指向底层数组。例如，以下代码展示了将切片值 `halfyr` 切片成两个额外的切片：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyi/ch07/slice_reslice.go
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_reslice.go
- en: 'The backing array may have many slices projecting a particular view of its
    data. The following figure illustrates how slicing in the previous code may be
    represented visually:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 支持数组的切片可能有多个，以特定视图投影其数据。以下图示说明了前述代码中的切片可能如何直观表示：
- en: '![Slicing a slice](img/00017.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![切片切片](img/00017.jpeg)'
- en: Notice that both slices `q1` and `q2` are pointing to different elements in
    the same underlying array. Slice `q1` has an initial length of `3` with a capacity
    of `6`. This implies `q1` can be resized up to `6` elements in total. Slice `q2`,
    however, has a size of `3` and a capacity of `3` and cannot grow beyond its initial
    size (slice resizing is covered later).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，切片 `q1` 和 `q2` 都指向同一底层数组中的不同元素。切片 `q1` 的初始长度为 `3`，容量为 `6`。这意味着 `q1` 可以调整大小至总共
    `6` 个元素。然而，切片 `q2` 的大小为 `3`，容量为 `3`，不能超过其初始大小（切片调整大小将在后面介绍）。
- en: Slicing an array
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片数组
- en: 'As mentioned, an array can also be sliced directly. When that is the case,
    the provided array value becomes the underlying array. The capacity and the length
    the slices will be calculated using the provided array. The following source snippet
    shows the slicing of an existing array value called months:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数组也可以直接切片。在这种情况下，提供的数组值成为底层数组。切片的容量和长度将使用提供的数组来计算。以下源代码片段展示了现有数组值 `months`
    的切片：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch07/slice_reslice_arr.go
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_reslice_arr.go
- en: Slice expressions with capacity
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带容量的切片表达式
- en: 'Lastly, Go''s slice expression supports a longer form where the maximum capacity
    of the slice is included in the expression, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Go 的切片表达式支持更长的形式，其中包含切片的最大容量，如下所示：
- en: '*<slice_or_array_value>[<low_index>:<high_index>:max]*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*<切片或数组值>[<低索引>:<高索引>:max]*'
- en: 'The *max* attribute specifies the index value to be used as the maximum capacity
    of the new slice. That value may be less than, or equal to, the actual capacity
    of the underlying array. The following example slices an array with the max value
    included:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*max* 属性指定用作新切片最大容量的索引值。该值可能小于或等于底层数组的实际容量。以下示例展示了包含最大值的数组切片：'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Making a slice
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建切片
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creates an underlying array of type `[6]string`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类型为`[6]string`的底层数组
- en: Creates the slice value with length and capacity of `6`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用长度和容量为`6`创建切片值
- en: Returns a slice value (not a pointer)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回切片值（不是指针）
- en: 'After initialization with the `make()` function, access to a legal index position
    will return the zero value for the slice element instead of causing a program
    panic. The `make()` function can take an optional third parameter that specifies
    the maximum capacity of the slice, as shown in the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make()`函数初始化后，访问合法的索引位置将返回切片元素的零值，而不是导致程序崩溃。`make()`函数可以接受一个可选的第三个参数，用于指定切片的最大容量，如下面的示例所示：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using slices
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切片
- en: 'The simplest operation to do with a slice value is to access its elements.
    As was mentioned, slices use index notation to access its elements similar to
    arrays. The following example accesses element at index position 0 and updates
    to `15`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片值最简单的操作是访问其元素。如前所述，切片使用索引表示法来访问其元素，类似于数组。以下示例访问索引位置为0的元素并将其更新为`15`：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch07/slice_use.go
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_use.go
- en: When the program runs, it prints the updated value using index expression `h[0]`
    to retrieve the value of the item at position `0`. Note that the slice expression
    with only the index number, `h[0]` for instance, returns the value of the item
    at that position. When, however, the expression includes a colon, say `h[2:]`
    or `h[:6]`, that expression returns a new slice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它使用索引表达式`h[0]`打印更新后的值，以检索位置`0`的项的值。请注意，只有索引数字的切片表达式，例如`h[0]`，返回该位置的项的值。然而，当表达式包含冒号时，例如`h[2:]`或`h[:6]`，该表达式返回一个新的切片。
- en: 'Slice traversal can be done using the traditional `for`statement or with the,
    more idiomatic, `for…range` statement as shown in the following code snippets:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的`for`语句或更惯用的`for…range`语句进行切片遍历，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Slices as parameters
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将切片作为参数
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch07/slice_loop.go
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_loop.go
- en: Length and capacity
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度和容量
- en: 'Go provides two built-in functions to query the length and capacity attributes
    of a slice. Given a slice, its length and maximum capacity can be queried, using
    the `len` and `cap` functions respectively, as shown in the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了两个内置函数来查询切片的长度和容量属性。给定一个切片，可以使用`len`和`cap`函数分别查询其长度和最大容量，如下面的示例所示：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Recall that a slice is a value (not a pointer) that has a nil as its zero-value.
    Therefore, the code is able to query the length (and capacity) of an uninitialized
    slice without causing a panic at runtime.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，切片是一个值（不是指针），其零值为nil。因此，代码能够在运行时查询未初始化切片的长度（和容量）而不会导致崩溃。
- en: Appending to slices
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向切片中追加
- en: 'The one indispensable feature of slice types is their ability to dynamically
    grow. By default, a slice has a static length and capacity. Any attempt to access
    an index beyond that limit will cause a panic. Go makes available the built-in
    variadic function `append` to dynamically add new values to a specified slice,
    growing its lengths and capacity, as necessary. The following code snippet shows
    how that is done:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类型的一个不可或缺的特性是它们能够动态增长。默认情况下，切片具有静态的长度和容量。任何尝试访问超出该限制的索引的操作都将导致崩溃。Go提供了内置的变长函数`append`，可以动态地向指定的切片添加新值，根据需要增长其长度和容量。以下代码片段展示了如何实现这一点：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Copying slices
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制切片
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Strings as slices
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串作为切片
- en: 'Internally, the string type is implemented as a slice using a composite value
    that points to an underlying array of rune. This affords the string type the same
    idiomatic treatment given to slices. For instance, the following code snippet
    uses index expressions to extract slices of strings from a given string value:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，字符串类型是通过使用指向底层rune数组复合值的切片实现的。这使得字符串类型获得了与切片相同的惯用处理方式。例如，以下代码片段使用索引表达式从给定的字符串值中提取字符串切片：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: golang.fyi/ch07/slice_string.go
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_string.go
- en: 'The slice expression on a string will return a new string value pointing to
    its underlying array of runes. The string values can be converted to a slice of
    byte (or slice of rune) as shown in the following function snippet, which sorts
    the characters of a given string:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串上的切片表达式将返回一个指向其底层runes数组的新的字符串值。字符串值可以转换为字节数组（或rune切片），如下面的函数片段所示，该片段对给定字符串的字符进行排序：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: golang.fyi/ch07/slice_string.go
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_string.go
- en: The previous code shows the explicit conversion of a slice of bytes to a string
    value. Note that each character may be accessed using the index expression.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了将字节数组显式转换为字符串值。请注意，每个字符都可以使用索引表达式访问。
- en: The map type
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型
- en: 'The Go map is a composite type that is used as containers for storing unordered
    elements of the same type indexed by an arbitrary key value. The following code
    snippet shows a variety of map variables declarations with a variety of key types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的映射是一个复合类型，用作存储无序元素的容器，这些元素由任意键值索引。以下代码片段展示了具有各种键类型的多种映射变量声明：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The *key* specifies the type of a value that will be used to index the stored
    elements of the map. Unlike arrays and slices, map keys can be of any type, not
    just `int`. Map keys, however, must be of types that are comparable including
    numeric, string, Boolean, pointers, arrays, struct, and interface types (see [Chapter
    4](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 4. Data
    Types")*, Data Types*, for discussion on comparable types).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键字*指定了将要用于索引映射存储元素的值的类型。与数组和切片不同，映射的键可以是任何类型，而不仅仅是`int`。然而，映射的键必须是可比较的类型，包括数值、字符串、布尔值、指针、数组、结构体和接口类型（参见[第4章](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第4章。数据类型")*数据类型*，关于可比较类型的讨论）。'
- en: Map initialization
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射初始化
- en: Similar to a slice, a map manages an underlying data structure, opaque to its
    user, to store its values. An uninitialized map has a nil zero-value as well.
    Attempts to insert into an uninitialized map will result in a program panic. Unlike
    a slice, however, it is possible to access elements from a nil map, which will
    return the zero value of the element.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，映射管理一个对用户不可见的底层数据结构来存储其值。未初始化的映射具有nil的零值。尝试向未初始化的映射中插入数据将导致程序崩溃。然而，与切片不同，从nil映射中访问元素是可能的，这将返回元素的零值。
- en: 'Like other composite types, maps may be initialized using a composite literal
    value of the following form:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他复合类型一样，映射可以使用以下形式的复合字面量值进行初始化：
- en: '*<map_type>{<comma-separated list of key:value pairs>}*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*<映射类型>{<逗号分隔的键值对列表>}*'
- en: 'The following snippet shows variable initialization with map composite literals:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用映射复合字面量进行变量初始化：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: golang.fyi/ch07/mapinit.go
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/mapinit.go
- en: The literal mapped values are specified using a colon-separated pair of key
    and value as shown in the previous example. The type of each key and value pair
    must match that of the declared elements in the map.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冒号分隔的键值对指定映射的文本值，如先前的例子所示。每个键值对的类型必须与映射中声明的元素类型相匹配。
- en: Making Maps
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建映射
- en: 'Similar to a slice, a map value can also be initialized using the *make* function.
    Using the make function initializes the underlying storage allowing data to be
    inserted in the map as shown in the following short snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，映射值也可以使用*make*函数进行初始化。使用make函数初始化底层存储，允许数据以如下所示的方式插入映射中：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: golang.fyi/ch07/maptypes.go
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/maptypes.go
- en: The `make` function takes as argument the type of the map and it returns an
    initialized map. In the previous example, the `make` function will initialize
    a map of type `map[int]string`. The `make` function can optionally take a second
    parameter to specify the capacity of the map. However, a map will continue to
    grow as needed ignoring the initial capacity specified.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`函数接受映射的类型作为参数，并返回一个初始化后的映射。在先前的例子中，`make`函数将初始化一个类型为`map[int]string`的映射。`make`函数可以可选地接受第二个参数来指定映射的容量。然而，映射会根据需要继续增长，忽略指定的初始容量。'
- en: Using maps
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用映射
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Accessing an element with a given key is done with an index expression, placed
    on the right side of an assignment, as shown in the following example, where the
    value indexed with the `"Mar"` key is assigned the `val` variable:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引表达式访问给定键的元素，将其放置在赋值表达式的右侧，如下例所示，其中使用`"Mar"`键索引的值被分配给`val`变量：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Earlier it was mentioned that accessing a non-existent key will return the
    zero-value for that element. For instance, the previous code would return 0 if
    the element with the key `"Mar"` does not exist in the map. As you can imagine,
    this can be a problem. How would you know whether you are getting an actual value
    or the zero-value? Fortunately, Go provides a way to explicitly test for the absence
    of an element by returning an optional Boolean value as part of the result of
    an index expression, as shown in the following snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到，访问不存在的键将返回该元素的零值。例如，如果键为 `"Mar"` 的元素在映射中不存在，则前面的代码将返回 0。正如你所想象的那样，这可能会成为一个问题。你如何知道你得到的是实际值还是零值？幸运的是，Go
    提供了一种方法，可以通过返回索引表达式的结果中的可选布尔值来显式测试元素是否存在，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Map traversal
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射遍历
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: golang.fyi/ch07/map_use.go
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/map_use.go
- en: Each iteration returns a key and its associated element value. Iteration order,
    however, is not guaranteed. The internal map iterator may traverse the map in
    a different order with each run of the program. In order to maintain a predictable
    traversal order, keep (or generate) a copy of the keys in a separate structure,
    such as a slice for instance. During traversal, range over the slice of keys to
    traverse in a predictable manner.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代返回一个键及其关联的元素值。然而，迭代顺序是不确定的。内部映射迭代器可能会在每次程序运行时以不同的顺序遍历映射。为了保持可预测的遍历顺序，请保留（或生成）一个单独的结构中的键的副本，例如切片。在遍历过程中，遍历键的切片以可预测的方式遍历。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should be aware that update done to the emitted value during the iteration
    will be lost. Instead, use an index expression, such as `hist[key]` to update
    an element during iteration. For details on `for…range` loop, refer to [Chapter
    3](part0022_split_000.html#KVCC1-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 3. Go
    Control Flow"), *Go Control Flow*, for a thorough explanation of Go `for` loops.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，在迭代过程中对发出的值进行的更新将会丢失。相反，使用索引表达式，例如 `hist[key]`，在迭代过程中更新元素。有关 `for…range`
    循环的详细信息，请参阅 [第 3 章](part0022_split_000.html#KVCC1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第 3 章。Go 控制流")，*Go 控制流*，以获得对 Go `for` 循环的全面解释。
- en: Map functions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射函数
- en: 'Besides the `make` function, discussed earlier, map types support two additional
    functions discussed in the following table:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的 `make` 函数之外，映射类型还支持以下表格中讨论的两个附加函数：
- en: '| **Function** | **Description** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| len(map) | As with other composite types, the built-in `len()` function returns
    the number of entries in a map. For instance, the following would print **3**:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '| len(map) | 与其他复合类型一样，内置的 `len()` 函数返回映射中的条目数。例如，以下将打印 **3**:'
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `len` function will return zero for an uninitialized map. |
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 函数对于未初始化的映射将返回零。|'
- en: '| delete(map, key) | The built-in `delete` function deletes an element from
    a given map associated with the provided key. The following code snippet would
    print **2**:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '| delete(map, key) | 内置的 `delete` 函数用于从给定的映射中删除与提供的键关联的元素。以下代码片段将打印 **2**:'
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Maps as parameters
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射作为参数
- en: 'Because a map maintains an internal pointer to its backing storage structure,
    all updates to map parameter within a called function will be seen by the caller
    once the function returns. The following sample shows a call to the `remove` function
    to change the content of a map. The passed variable, `hist`, will reflect the
    change once the `remove` function returns:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于映射维护对其后端存储结构的内部指针，因此调用函数中对映射参数的所有更新将在函数返回后由调用者看到。以下示例显示了调用 `remove` 函数以更改映射内容。传递的变量
    `hist` 将在 `remove` 函数返回后反映更改：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: golang.fyi/ch07/map_use.go
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/map_use.go
- en: The struct type
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体类型
- en: 'The last type discussed in this chapter is Go''s `struct`. It is a composite
    type that serves as a container for other named types known as fields. The following
    code snippet shows several variables declared as structs:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后讨论的类型是 Go 的 `struct`。它是一种复合类型，用作其他称为字段的命名类型的容器。以下代码片段显示了几个作为结构体声明的变量：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Accessing struct fields
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问结构体字段
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Selectors can be chained to access fields that are nested inside a struct.
    The following snippet would print the street and city for the nested address value
    of a `person` variable:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器可以链式使用，以访问嵌套在结构体内部的字段。以下代码片段将打印嵌套在 `person` 变量的地址值中的街道和城市：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Struct initialization
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体初始化
- en: Similar to arrays, structs are pure values with no additional underlying storage
    structure. The fields for an uninitialized struct are assigned their respective
    zero values. This means an uninitialized struct requires no further allocation
    and is ready to be used.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，结构体是纯值，没有额外的底层存储结构。未初始化的结构体的字段被分配其各自的零值。这意味着未初始化的结构体不需要进一步分配，即可使用。
- en: 'Nevertheless, a struct variable can be explicitly initialized using a composite
    literal of the following form:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，可以使用以下形式的复合字面量显式初始化结构体变量：
- en: '*<struct_type>{<positional or named field values>}*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*<struct_type>{<positional or named field values>}*'
- en: 'The composite literal value for a struct can be initialized by a set of field
    values specified by their respective positions. Using this approach, all field
    values must be provided, to match their respective declared types, as shown in
    the following snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的复合字面量值可以通过指定一组字段值来初始化，这些值由它们的相应位置指定。使用这种方法，必须提供所有字段值，以匹配它们的声明类型，如下面的片段所示：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: golang.fyi/ch07/structinit.go
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structinit.go
- en: 'In the previous struct literal, all field values of the `struct` are provided,
    matching their declared field types. Alternatively, the composite literal value
    of a `struct` can be specified using a field indices and their associated value.
    As before, the index (the field name) and its value is separated by a colon, as
    shown in the following snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构体字面量中，提供了 `struct` 的所有字段值，与它们的声明字段类型相匹配。或者，可以使用字段索引及其关联值来指定 `struct` 的复合字面量值。与之前一样，索引（字段名称）及其值由冒号分隔，如下面的片段所示：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: golang.fyi/ch07/structinit.go
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structinit.go
- en: As you can see, field values of the composite literal can be selectively specified
    when the index and its value are provided. For instance, in the initialization
    of the `node` variable, the `edge` field is initialized while `weight` is omitted.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当提供索引及其值时，可以选择性指定复合字面量的字段值。例如，在 `node` 变量的初始化中，`edge` 字段被初始化，而 `weight`
    被省略。
- en: Declaring named struct types
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明命名结构体类型
- en: 'Attempting to reuse struct types can get unwieldy fast. For instance, having
    to write `struct { name string; address struct { street string; city string; state
    string; postal string }}` to express a struct type, every time it is needed, would
    not scale, would be error prone, and would make for grumpy Go developers. Luckily,
    the proper idiom to fix this is to use named types, as illustrated in the following
    source code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重复使用结构体类型可能会很快变得难以管理。例如，每次需要表达结构体类型时，都必须编写 `struct { name string; address
    struct { street string; city string; state string; postal string }}`，这不会扩展，容易出错，并且会让
    Go 开发者感到沮丧。幸运的是，修复这个问题的正确习惯是使用命名类型，如下面的源代码片段所示：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: golang.fyi/ch07/structtype_dec.go
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structtype_dec.go
- en: The previous example binds struct type definitions to the identifiers person
    and address. This allows the struct types to be reused in different contexts without
    the need to carry around the long form of the type definitions. You can refer
    to [Chapter 4](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 4. Data Types"), *Data Types*, to learn more about named types.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将结构体类型定义绑定到标识符 person 和 address。这允许在不同的上下文中重复使用结构体类型，而无需携带类型定义的长形式。您可以参考[第4章](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第4章 数据类型")，*数据类型*，以了解更多关于命名类型的信息。
- en: The anonymous field
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名字段
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To simplify field name resolution, Go follows the following rules when using
    anonymous fields:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化字段名称解析，Go 在使用匿名字段时遵循以下规则：
- en: The name of the type becomes the name of the field
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型名称成为字段名称
- en: The name of an anonymous field may not clash with other field names
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名字段的名称不能与其他字段名称冲突
- en: Use only the unqualified (omit package) type name of imported types
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用未限定的（省略包）类型名称导入类型
- en: 'These rules also hold when accessing the fields of embedded structs directly
    using selector expressions, as is shown in the following code snippet. Notice
    the name of the embedded types are resolved as fields names:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当直接使用选择器表达式访问内嵌结构体的字段时，这些规则同样适用，如下面的代码片段所示。注意，内嵌类型的名称被解析为字段名称：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: golang.fyi/ch07/struct_embed.go
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_embed.go
- en: Promoted fields
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升字段
- en: 'Fields of an embedded struct can be *promoted* to its enclosing type. Promoted
    fields appear in selector expressions without the qualified name of their types,
    as shown in the following example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 内嵌结构体的字段可以被*提升*到其封装类型。提升字段在选择器表达式中出现时，不需要它们的类型限定名称，如下面的示例所示：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Structs as parameters
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体作为参数
- en: 'Recall that struct variables store actual values. This implies that a new copy
    of a struct value is created whenever a `struct` variable is reassigned or passed
    in as a function parameter. For instance, the following will not update the value
    of name after the call to `updateName()`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，结构体变量存储实际值。这意味着每当将`struct`变量重新分配或作为函数参数传递时，就会创建结构体值的新副本。例如，以下在调用`updateName()`后不会更新name的值：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: golang.fyi/ch07/struct_ptr.go
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_ptr.go
- en: 'This can be remedied by passing a pointer to the `struct` value of the person
    type, as shown in the following snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过传递指向`person`类型`struct`值的指针来修复，如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: golang.fyi/ch07/struct_ptr2.go
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_ptr2.go
- en: In this version, the `p` variable is declared as `*person` and is initialized
    using the built-in `new()` function. After `updateName()` returns, its changes
    are seen by the calling function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，`p`变量被声明为`*person`，并使用内置的`new()`函数进行初始化。在`updateName()`返回后，调用函数可以看到其更改。
- en: Field tags
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段标签
- en: The last topic on structs has to do with field tags. During the definition of
    a `struct` type, optional `string` values may be added to each field declaration.
    The value of the string is arbitrary and it can serve as hints to tools or other
    APIs that use reflection to consume the tags.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的最后一个主题与字段标签有关。在定义`struct`类型时，可以为每个字段声明添加可选的`string`值。字符串的值是任意的，它可以作为提示，供使用反射来消费标签的工具或其他API使用。
- en: 'The following shows a definition of the Person and Address structs that are
    tagged with JSON annotation which can be interpreted by Go''s JSON encoder and
    decoder (found in the standard library):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了带有JSON注释的Person和Address结构体的定义，这些注释可以被Go的JSON编码器和解码器（在标准库中找到）解释：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: golang.fyi/ch07/struct_ptr2.go
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_ptr2.go
- en: Notice the tags are represented as raw string values (wrapped within a pair
    of [PRE63]). The tags are ignored by normal code execution. However, they can
    be collected using Go's reflection API as is done by the JSON library. You will
    encounter more on this subject in [Chapter 10](part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10. Data IO in Go"), *Data IO in Go*, when the book discusses input and
    output streams.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签被表示为原始字符串值（用一对[PRE63]括起来）。在正常代码执行中，标签会被忽略。然而，它们可以通过Go的反射API被收集，正如JSON库所做的那样。你将在[第10章](part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第10章。Go中的数据输入输出")，*Go中的数据输入输出*中遇到更多关于这个主题的内容，当本书讨论输入和输出流时。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a lot of ground as it walked through each of the composite
    types found in Go to provide insightful coverage of their characteristics. The
    chapter opened with a coverage of the array type, where readers learned how to
    declare, initialize, and use array values. Next, readers learned all about the
    slice type, specifically the declaration, initialization, and practical examples
    that uses slice index expressions to create new or re-slice existing slices. The
    chapter covered the map type, which included information on map initialization,
    access, update, and traversal. Lastly, the chapter provided information about
    the definition, initialization, and usage of the struct type.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在遍历Go中找到的每个复合类型时覆盖了大量的内容，为它们的特性提供了深入的覆盖。章节从对数组类型的覆盖开始，读者学习了如何声明、初始化和使用数组值。接下来，读者学习了关于切片类型的所有内容，特别是声明、初始化以及使用切片索引表达式创建新切片或重新切片现有切片的实用示例。本章还涵盖了map类型，包括有关map初始化、访问、更新和遍历的信息。最后，本章提供了有关结构体类型定义、初始化和使用的详细信息。
- en: Needless to say, this is probably one of the longest chapters of the book. However,
    the information covered here will prove to be invaluable as the book continues
    to explore new topics. The next chapter will introduce the idea of using Go to
    support object-like idioms using methods and interfaces.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这可能是本书中最长的章节之一。然而，这里涵盖的信息将在本书继续探索新主题时证明是无价的。下一章将介绍使用Go通过方法和接口支持类似对象的习惯用法。
