<html><head></head><body>
<div class="book" title="Switch statements">
<div class="book" title="Type switches"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec59" class="calibre1"/>Type switches</h2></div></div></div><p class="calibre10">Given Go's strong type support, it should be of little surprise that the language supports the ability to query type information. The type <code class="email">switch</code> is a statement that uses the Go interface type to compare the underlying type information of values (or expressions). A full discussion on interface types and type assertion is beyond the scope of this section. You can find more details on the subject in <a class="calibre1" title="Chapter 8. Methods, Interfaces, and Objects" href="part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 8</a>, <span class="strong"><em class="calibre11">Methods, Interfaces, and Objects</em></span>.</p><p class="calibre10">Nevertheless, for the sake of completeness, a short discussion on type switches is provided here. For now, all you need to know is that Go offers the type <code class="email">interface{}</code>, or empty interface, as a super type that is implemented by all other types in the type system. When a value is assigned type <code class="email">interface{}</code>, it can be queried using the type <code class="email">switch</code>, as shown in function <code class="email">findAny()</code> in the following code snippet, to query information about its underlying type:</p><pre class="programlisting">func find(name string) { 
  for i := 0; i &lt; 10; i++ { 
    c := currencies[i] 
    switch { 
    case strings.Contains(c.Currency, name), 
      strings.Contains(c.Name, name), 
      strings.Contains(c.Country, name): 
      fmt.Println("Found", c) 
    } 
  } 
}  
 
func findNumber(num int) { 
  for _, curr := range currencies { 
    if curr.Number == num { 
      fmt.Println("Found", curr) 
    } 
  } 
}  
 
func findAny(val interface{}) {  
  switch i := val.(type) {  
  case int:  
    findNumber(i)  
  case string:  
    find(i)  
  default:  
    fmt.Printf("Unable to search with type %T\n", val)  
  }  
} 
 
func main() { 
findAny("Peso") 
  findAny(404) 
  findAny(978) 
  findAny(false) 
} 
</pre><p class="calibre10">golang.fyi/ch03/switchstmt2.go</p><p class="calibre10">The function <code class="email">findAny()</code> takes an <code class="email">interface{}</code> as its parameter. The type <code class="email">switch</code> is used to determine the underlying type and value of the variable <code class="email">val</code> using the type assertion expression:</p><pre class="programlisting">switch i := val.(type) 
</pre><p class="calibre10">Notice the use of the keyword <code class="email">type</code> in the preceding type assertion expression. Each case clause will be tested against the type information queried from <code class="email">val.(type)</code>. Variable <code class="email">i</code> will be assigned the actual value of the underlying type and is used to invoke a function with the respective value. The default block is invoked to guard against any unexpected type assigned to the parameter <code class="email">val</code> parameter. Function <code class="email">findAny</code> may then be invoked with values of diverse types, as shown in the following code snippet:</p><pre class="programlisting">findAny("Peso")  
findAny(404)  
findAny(978)  
findAny(false)  
</pre></div></div></body></html>