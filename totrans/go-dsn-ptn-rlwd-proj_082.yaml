- en: Type switches
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型开关
- en: Given Go's strong type support, it should be of little surprise that the language
    supports the ability to query type information. The type `switch` is a statement
    that uses the Go interface type to compare the underlying type information of
    values (or expressions). A full discussion on interface types and type assertion
    is beyond the scope of this section. You can find more details on the subject
    in [Chapter 8](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces, and Objects*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 强大的类型支持，语言支持查询类型信息的能力应该不会令人惊讶。`type switch` 是一个使用 Go 接口类型来比较值的底层类型信息的语句。关于接口类型和类型断言的完整讨论超出了本节的范围。您可以在[第
    8 章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd "第 8 章。方法、接口和对象")中找到更多关于这个主题的详细信息，*方法、接口和对象*。
- en: 'Nevertheless, for the sake of completeness, a short discussion on type switches
    is provided here. For now, all you need to know is that Go offers the type `interface{}`,
    or empty interface, as a super type that is implemented by all other types in
    the type system. When a value is assigned type `interface{}`, it can be queried
    using the type `switch`, as shown in function `findAny()` in the following code
    snippet, to query information about its underlying type:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，为了完整性，这里提供了一个关于类型开关的简短讨论。目前，您需要知道的是，Go 提供了 `interface{}` 类型，或称为空接口，作为类型系统中所有其他类型实现的超类型。当一个值被分配为
    `interface{}` 类型时，可以使用 `type switch` 来查询其底层类型信息，如下面的代码片段中的 `findAny()` 函数所示：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt2.go
- en: 'The function `findAny()` takes an `interface{}` as its parameter. The type
    `switch` is used to determine the underlying type and value of the variable `val`
    using the type assertion expression:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `findAny()` 接收一个 `interface{}` 类型的参数。使用 `type switch` 来确定变量 `val` 的底层类型和值，通过类型断言表达式：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice the use of the keyword `type` in the preceding type assertion expression.
    Each case clause will be tested against the type information queried from `val.(type)`.
    Variable `i` will be assigned the actual value of the underlying type and is used
    to invoke a function with the respective value. The default block is invoked to
    guard against any unexpected type assigned to the parameter `val` parameter. Function
    `findAny` may then be invoked with values of diverse types, as shown in the following
    code snippet:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的类型断言表达式中使用了关键字 `type`。每个情况子句都将与从 `val.(type)` 查询到的类型信息进行匹配。变量 `i` 将被分配底层类型的实际值，并用于调用具有相应值的函数。默认块被调用以防止将任何意外的类型分配给参数
    `val`。然后可以调用 `findAny` 函数，使用各种类型的值，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
