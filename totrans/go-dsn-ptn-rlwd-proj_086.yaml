- en: The traditional for statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that the traditional `for` statement is a superset of the other
    forms of the loop discussed so far, as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **For statement** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| The initialization statement is omitted. Variable `k` is initialized outside
    of the `for` statement. The idiomatic way, however, is to initialize your variables
    with the `for` statement. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| The `update` statement (after the last semi-colon) is omitted here. The developer
    must provide update logic elsewhere or you risk creating an infinite loop. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| This is equivalent to the `for` condition form (discussed earlier) `for k
    < 10 { ... }`. Again, the variable `k` is expected to be declared prior to the
    loop. Care must be taken to update `k` or you risk creating an infinite loop.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| Here, the conditional expression is omitted. As before, this evaluates the
    conditional to `true`, which will produce an infinite loop if proper termination
    logic is not introduced in the loop. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| This is equivalent to the form `for{ ... }` and produces an infinite loop.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The initialization and the `update` statements, in the `for` loop, are regular
    Go statements. As such, they can be used to initialize and update multiple variables,
    as is supported by Go. To illustrate this point, the next example initializes
    and updates two variables, `w1` and `w2`, at the same time in the statement clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/forstmt2.go
  prefs: []
  type: TYPE_NORMAL
- en: The initialization statements initialize variables `w1` and `w2` by calling
    the function `nextPair()`. The condition uses a compound logical expression that
    will keep the loop running as long as it is evaluated to true. Lastly, variables
    `w1` and `w2` are both updated with each iteration of the loop by calling `nextPair()`.
  prefs: []
  type: TYPE_NORMAL
