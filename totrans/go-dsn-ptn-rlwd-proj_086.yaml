- en: The traditional for statement
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统 `for` 语句
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It turns out that the traditional `for` statement is a superset of the other
    forms of the loop discussed so far, as summarized in the following table:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，传统的 `for` 语句是之前讨论的其他循环形式的超集，如下表所示：
- en: '| **For statement** | **Description** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **For 语句** | **描述** |'
- en: '|'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| The initialization statement is omitted. Variable `k` is initialized outside
    of the `for` statement. The idiomatic way, however, is to initialize your variables
    with the `for` statement. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 初始化语句被省略了。变量 `k` 在 `for` 语句外部初始化。然而，按照惯例，应该使用 `for` 语句来初始化变量。 |'
- en: '|'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| The `update` statement (after the last semi-colon) is omitted here. The developer
    must provide update logic elsewhere or you risk creating an infinite loop. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 在最后一个分号之后的 `update` 语句被省略了。开发者必须在其他地方提供更新逻辑，否则可能会创建一个无限循环。 |'
- en: '|'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| This is equivalent to the `for` condition form (discussed earlier) `for k
    < 10 { ... }`. Again, the variable `k` is expected to be declared prior to the
    loop. Care must be taken to update `k` or you risk creating an infinite loop.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 这与之前讨论过的 `for` 条件形式（`for k < 10 { ... }`）等价。再次强调，变量 `k` 应在循环之前声明。必须注意更新 `k`，否则可能会创建一个无限循环。
    |'
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Here, the conditional expression is omitted. As before, this evaluates the
    conditional to `true`, which will produce an infinite loop if proper termination
    logic is not introduced in the loop. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 这里省略了条件表达式。与之前一样，这会将条件评估为 `true`，如果没有在循环中引入适当的终止逻辑，将会产生一个无限循环。 |'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| This is equivalent to the form `for{ ... }` and produces an infinite loop.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 这与 `for{ ... }` 形式等价，并会产生一个无限循环。 |'
- en: 'The initialization and the `update` statements, in the `for` loop, are regular
    Go statements. As such, they can be used to initialize and update multiple variables,
    as is supported by Go. To illustrate this point, the next example initializes
    and updates two variables, `w1` and `w2`, at the same time in the statement clauses:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环中，初始化和 `update` 语句是常规的 Go 语句。因此，它们可以用来初始化和更新多个变量，正如 Go 所支持的。为了说明这一点，下面的例子在语句子句中同时初始化和更新了两个变量
    `w1` 和 `w2`：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: golang.fyi/ch03/forstmt2.go
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/forstmt2.go
- en: The initialization statements initialize variables `w1` and `w2` by calling
    the function `nextPair()`. The condition uses a compound logical expression that
    will keep the loop running as long as it is evaluated to true. Lastly, variables
    `w1` and `w2` are both updated with each iteration of the loop by calling `nextPair()`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句通过调用函数 `nextPair()` 来初始化变量 `w1` 和 `w2`。条件使用了一个复合逻辑表达式，只要评估为 `true`，循环就会继续运行。最后，变量
    `w1` 和 `w2` 在每次循环迭代中都会通过调用 `nextPair()` 来更新。
