<html><head></head><body>
<div class="book" title="Chapter&#xA0;4.&#xA0;Data Types" id="PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Go types"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec23" class="calibre1"/>Go types</h1></div></div></div><p class="calibre10">To help launch the conversation about types, let us take a peek at the types available. Go implements a simple type system that provides programmers direct control over how memory is allocated and laid out. When a program declares a variable, two things must take place:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The variable must receive a type</li><li class="listitem">The variable will also be bound to a value (even when none is assigned)</li></ul></div><p class="calibre10">This allows the type system to allocate the number of bytes necessary to store the declared value. The memory layout for declared variables maps directly to their declared types. There is no type boxing or automatic type conversion that takes place. The space you expect to be allocated is actually what gets reserved in memory.</p><p class="calibre10">To demonstrate this fact, the following program uses a special package called <code class="email">unsafe</code> to circumvent the type system and extract memory size information for declared variables. It is important to note that this is purely illustrative as most programs do not commonly make use of the <code class="email">unsafe</code> package.</p><pre class="programlisting">package main 
import ( 
   "fmt" 
   "unsafe" 
) 
 
var ( 
   a uint8   = 72 
   b int32   = 240 
   c uint64  = 1234564321 
   d float32 = 12432345.232 
   e int64   = -1233453443434 
   f float64 = -1.43555622362467 
   g int16   = 32000 
   h [5]rune = [5]rune{'O', 'n', 'T', 'o', 'p'} 
) 
 
func main() { 
   fmt.Printf("a = %v [%T, %d bits]\n", a, a, unsafe.Sizeof(a)*8) 
   fmt.Printf("b = %v [%T, %d bits]\n", b, b, unsafe.Sizeof(b)*8) 
   fmt.Printf("c = %v [%T, %d bits]\n", c, c, unsafe.Sizeof(c)*8) 
   fmt.Printf("d = %v [%T, %d bits]\n", d, d, unsafe.Sizeof(d)*8) 
   fmt.Printf("e = %v [%T, %d bits]\n", e, e, unsafe.Sizeof(e)*8) 
   fmt.Printf("f = %v [%T, %d bits]\n", f, f, unsafe.Sizeof(f)*8) 
   fmt.Printf("g = %v [%T, %d bits]\n", g, g, unsafe.Sizeof(g)*8) 
   fmt.Printf("h = %v [%T, %d bits]\n", h, h, unsafe.Sizeof(h)*8) 
} 
</pre><p class="calibre10">golang.fyi/ch04/alloc.go</p><p class="calibre10">When the program is executed, it prints out the amount of memory (in bits) consumed by each declared variable:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt;go run alloc.go</strong></span>
<span class="strong"><strong class="calibre2">a = 72 [uint8, 8 bits]</strong></span>
<span class="strong"><strong class="calibre2">b = 240 [int32, 32 bits]</strong></span>
<span class="strong"><strong class="calibre2">c = 1234564321 [uint64, 64 bits]</strong></span>
<span class="strong"><strong class="calibre2">d = 1.2432345e+07 [float32, 32 bits]</strong></span>
<span class="strong"><strong class="calibre2">e = -1233453443434 [int64, 64 bits]</strong></span>
<span class="strong"><strong class="calibre2">f = -1.43555622362467 [float64, 64 bits]</strong></span>
<span class="strong"><strong class="calibre2">g = 32000 [int16, 16 bits]</strong></span>
<span class="strong"><strong class="calibre2">h = [79 110 84 111 112] [[5]int32, 160 bits]</strong></span>
</pre><p class="calibre10">From the preceding output, we can see that variable <code class="email">a</code> (of type <code class="email">uint8</code>) will be stored using eight bits (or one byte), variable <code class="email">b</code> using 32 bits (or four bytes), and so on. With the ability to influence memory consumption coupled with Go's support for pointer types, programmers are able to strongly control how memory is allocated and consumed in their programs.</p><p class="calibre10">This chapter will cover the types listed in the following table. They include basic types such as numeric, Boolean, and strings:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Type</strong></span></p>
</td><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Description</strong></span></p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">string</code></p>
</td><td class="calibre22">
<p class="calibre23">Type for storing text values</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">rune</code></p>
</td><td class="calibre22">
<p class="calibre23">An integer type (int32) used to represent characters.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">byte</code>, <code class="literal">int</code>, <code class="literal">int8</code>, <code class="literal">int16</code>, <code class="literal">int32</code>, <code class="literal">int64</code>, <code class="literal">rune</code>, <code class="literal">uint</code>, <code class="literal">uint8</code>, <code class="literal">uint16</code>, <code class="literal">uint32</code>, <code class="literal">uint64</code>, <code class="literal">uintptr</code></p>
</td><td class="calibre22">
<p class="calibre23">Types for storing integral values.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">float32</code>, <code class="literal">float64</code></p>
</td><td class="calibre22">
<p class="calibre23">Types for storing floating point decimal values.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">complex64</code>, <code class="literal">complex128</code></p>
</td><td class="calibre22">
<p class="calibre23">Types that can represent complex numbers with both real and imaginary parts.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">bool</code></p>
</td><td class="calibre22">
<p class="calibre23">Type for Boolean values.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">*T</code>, pointer to type T</p>
</td><td class="calibre22">
<p class="calibre23">A type that represents a memory address where a value of type T is stored.</p>
</td></tr></tbody></table></div><p class="calibre10">The remaining types supported by Go, such as those listed in the following table, include composite, interface, function, and channels.Â They are covered later in chapters dedicated to their respective topics.</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Type</strong></span></p>
</td><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Description</strong></span></p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">Array
<code class="literal">[n]T</code></p>
</td><td class="calibre22">
<p class="calibre23">An ordered collection of fixed size <code class="literal">n</code> of numerically indexed sequence of elements of a type <code class="literal">T</code>.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">Slice<code class="literal">[]T</code></p>
</td><td class="calibre22">
<p class="calibre23">A collection of unspecified size of numerically indexed sequence of elements of type <code class="literal">T</code>.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">struct{}</code></p>
</td><td class="calibre22">
<p class="calibre23">A structure is a composite type composed of elements known as fields (think of an object).</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">map[K]T</code></p>
</td><td class="calibre22">
<p class="calibre23">An unordered sequence of elements of type <code class="literal">T</code> indexed by a key of arbitrary type <code class="literal">K</code>.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">interface{}</code></p>
</td><td class="calibre22">
<p class="calibre23">A named set of function declarations that define a set of operations that can be implemented by other types.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">func (T) R</code></p>
</td><td class="calibre22">
<p class="calibre23">A type that represents all functions with a given parameter type <code class="literal">T</code> and return type <code class="literal">R</code>.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">chan T</code></p>
</td><td class="calibre22">
<p class="calibre23">A type for an internal communication channel to send or receive values of type <code class="literal">T</code>.</p>
</td></tr></tbody></table></div></div></div></body></html>