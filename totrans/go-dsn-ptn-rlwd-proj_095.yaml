- en: Go types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help launch the conversation about types, let us take a peek at the types
    available. Go implements a simple type system that provides programmers direct
    control over how memory is allocated and laid out. When a program declares a variable,
    two things must take place:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable must receive a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable will also be bound to a value (even when none is assigned)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the type system to allocate the number of bytes necessary to store
    the declared value. The memory layout for declared variables maps directly to
    their declared types. There is no type boxing or automatic type conversion that
    takes place. The space you expect to be allocated is actually what gets reserved
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this fact, the following program uses a special package called
    `unsafe` to circumvent the type system and extract memory size information for
    declared variables. It is important to note that this is purely illustrative as
    most programs do not commonly make use of the `unsafe` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/alloc.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program is executed, it prints out the amount of memory (in bits)
    consumed by each declared variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that variable `a` (of type `uint8`) will
    be stored using eight bits (or one byte), variable `b` using 32 bits (or four
    bytes), and so on. With the ability to influence memory consumption coupled with
    Go's support for pointer types, programmers are able to strongly control how memory
    is allocated and consumed in their programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the types listed in the following table. They include
    basic types such as numeric, Boolean, and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | Type for storing text values |'
  prefs: []
  type: TYPE_TB
- en: '| `rune` | An integer type (int32) used to represent characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `uintptr` | Types for storing integral values. |'
  prefs: []
  type: TYPE_TB
- en: '| `float32`, `float64` | Types for storing floating point decimal values. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64`, `complex128` | Types that can represent complex numbers with
    both real and imaginary parts. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | Type for Boolean values. |'
  prefs: []
  type: TYPE_TB
- en: '| `*T`, pointer to type T | A type that represents a memory address where a
    value of type T is stored. |'
  prefs: []
  type: TYPE_TB
- en: The remaining types supported by Go, such as those listed in the following table,
    include composite, interface, function, and channels.Â They are covered later in
    chapters dedicated to their respective topics.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Array `[n]T` | An ordered collection of fixed size `n` of numerically indexed
    sequence of elements of a type `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| Slice`[]T` | A collection of unspecified size of numerically indexed sequence
    of elements of type `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| `struct{}` | A structure is a composite type composed of elements known as
    fields (think of an object). |'
  prefs: []
  type: TYPE_TB
- en: '| `map[K]T` | An unordered sequence of elements of type `T` indexed by a key
    of arbitrary type `K`. |'
  prefs: []
  type: TYPE_TB
- en: '| `interface{}` | A named set of function declarations that define a set of
    operations that can be implemented by other types. |'
  prefs: []
  type: TYPE_TB
- en: '| `func (T) R` | A type that represents all functions with a given parameter
    type `T` and return type `R`. |'
  prefs: []
  type: TYPE_TB
- en: '| `chan T` | A type for an internal communication channel to send or receive
    values of type `T`. |'
  prefs: []
  type: TYPE_TB
