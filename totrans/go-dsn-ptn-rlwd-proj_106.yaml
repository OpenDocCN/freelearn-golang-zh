- en: Interpreted and raw string literals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释和原始字符串字面量
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch04/string.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/string.go
- en: 'The literal value assigned to variable `txt2` is enclosed in double quotes.
    This is known as an interpreted string. An interpreted string may contain normal
    printable characters as well as backslash-escaped values which are parsed and
    interpreted as `rune` literals. So, when `txt2` is printed, the escape values
    are translated as the following string:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给变量 `txt2` 的字面值被双引号包围。这被称为解释字符串。解释字符串可以包含普通可打印字符以及作为 `rune` 字面量解析和解释的反斜杠转义值。因此，当
    `txt2` 被打印时，转义值会被翻译成以下字符串：
- en: '![Interpreted and raw string literals](img/00011.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![解释和原始字符串字面量](img/00011.jpeg)'
- en: 'Each symbol, in the interpreted string, corresponds to an escape value or a
    printable symbol as summarized in the following table:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释字符串中，每个符号对应一个转义值或可打印符号，如下表所示：
- en: '| ![Interpreted and raw string literals](img/00012.jpeg) | **<space>** | **brings**
    | **<space>** | **life** | . |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| ![解释和原始字符串字面量](img/00012.jpeg) | **<space>** | **brings** | **<space>** |
    **life** | . |'
- en: '| \u6C34 | \x20 | brings | \x20 | \x6c\x69\x66\x65 | . |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| \u6C34 | \x20 | brings | \x20 | \x6c\x69\x66\x65 | . |'
- en: On the other hand, the literal value assigned to variable `txt3` is surrounded
    by the grave accent characters [PRE2]. This creates what is known as a raw string
    in Go. Raw string values are uninterpreted where escape sequences are ignored
    and all valid characters are encoded as they appear in the literal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，分配给变量 `txt3` 的字面值被重音符号字符 [PRE2] 包围。这创建了Go中的原始字符串。原始字符串值未进行解释，其中转义序列被忽略，所有有效字符都按其在字面量中出现的顺序进行编码。
- en: 'When variable `txt3` is printed, it produces the following output:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量 `txt3` 被打印时，它会产生以下输出：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the printed string contains all the backslash-escaped values as
    they appear in the original string literal. Uninterpreted string literals are
    a great way to embed large multi-line textual content within the body of a source
    code without breaking its syntax.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，打印的字符串包含了原始字符串字面量中出现的所有反斜杠转义值。未解释的字符串字面量是在不破坏源代码语法的情况下嵌入大量多行文本内容的好方法。
