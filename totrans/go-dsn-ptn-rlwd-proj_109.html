<html><head></head><body>
<div class="book" title="Pointers" id="TI1E1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="The address operator"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec77" class="calibre1"/>The address operator</h2></div></div></div><p class="calibre10">Pointer values can only be assigned addresses of their declared types. One way you can do so in Go is to use the address operator <code class="email">&amp;</code>(ampersand) to obtain the address value of a variable as shown in the following example:</p><pre class="programlisting">package main 
import "fmt" 
 
func main() { 
   var a int = 1024 
   var aptr *int = &amp;a 
 
   fmt.Printf("a=%v\n", a) 
   fmt.Printf("aptr=%v\n", aptr) 
} 
</pre><p class="calibre10">golang.fyi/ch04/pointers.go</p><p class="calibre10">Variable <code class="email">aptr</code>, of pointer type <code class="email">*int</code>, is initialized and assigned the address value of variable <code class="email">a</code> using expression <code class="email">&amp;a</code> as listed here:</p><pre class="programlisting">var a int = 1024 
var aptr *int = &amp;a  
</pre><p class="calibre10">While variable <code class="email">a</code> stores the actual value, we say that <code class="email">aptr</code> points to <code class="email">a</code>. The following shows the output of the program with the value of variable <code class="email">a</code> and its memory location assigned to <code class="email">aptr</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">a=1024 </strong></span>
<span class="strong"><strong class="calibre2">aptr=0xc208000150</strong></span>
</pre><p class="calibre10">The assigned address value will always be the same (always pointing to <code class="email">a</code>) regardless of where <code class="email">aptr</code> may be accessed in the code. It is also worth noting that Go does not allow the use of the address operator with literal constant for numeric, string, and bool types. Therefore, the following will not compile:</p><pre class="programlisting">var aptr *int = &amp;1024  
fmt.Printf("a ptr1 = %v\n", aptr)  
</pre><p class="calibre10">There is a syntactical exception to this rule, however, when initializing composite types such as struct and array with literal constants. The following program illustrates such scenarios:</p><pre class="programlisting">package main 
import "fmt" 
 
func main() { 
   structPtr := &amp;struct{ x, y int }{44, 55} 
   pairPtr := &amp;[2]string{"A", "B"} 
 
   fmt.Printf("struct=%#v, type=%T\n", structPtr, structPtr) 
   fmt.Printf("pairPtr=%#v, type=%T\n", pairPtr, pairPtr) 
} 
</pre><p class="calibre10">golang.fyi/ch04/address2.go</p><p class="calibre10">In the previous code snippet, the address operator is used directly with composite literal <code class="email">&amp;struct{ x, y int }{44, 55}</code> and <code class="email">&amp;[2]string{"A", "B"} </code>to return pointer types <code class="email">*struct { x int; y int }</code> and <code class="email">*[2]string</code> respectively. This is a bit of syntactic sugar that eliminates the intermediary step of assigning the values to a variable, then retrieving their assigned addresses.</p></div></div></body></html>