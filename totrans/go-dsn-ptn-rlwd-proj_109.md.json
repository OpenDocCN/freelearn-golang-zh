["```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   var a int = 1024 \n   var aptr *int = &a \n\n   fmt.Printf(\"a=%v\\n\", a) \n   fmt.Printf(\"aptr=%v\\n\", aptr) \n} \n\n```", "```go\nvar a int = 1024 \nvar aptr *int = &a  \n\n```", "```go\na=1024 \naptr=0xc208000150\n\n```", "```go\nvar aptr *int = &1024  \nfmt.Printf(\"a ptr1 = %v\\n\", aptr)  \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   structPtr := &struct{ x, y int }{44, 55} \n   pairPtr := &[2]string{\"A\", \"B\"} \n\n   fmt.Printf(\"struct=%#v, type=%T\\n\", structPtr, structPtr) \n   fmt.Printf(\"pairPtr=%#v, type=%T\\n\", pairPtr, pairPtr) \n} \n\n&struct{ x, y int }{44, 55} and &[2]string{\"A\", \"B\"} to return pointer types *struct { x int; y int } and *[2]string respectively. This is a bit of syntactic sugar that eliminates the intermediary step of assigning the values to a variable, then retrieving their assigned addresses.\n```"]