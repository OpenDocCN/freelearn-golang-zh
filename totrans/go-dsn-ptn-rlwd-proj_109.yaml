- en: The address operator
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址运算符
- en: 'Pointer values can only be assigned addresses of their declared types. One
    way you can do so in Go is to use the address operator `&`(ampersand) to obtain
    the address value of a variable as shown in the following example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 指针值只能分配其声明类型的地址。在 Go 中，你可以使用地址运算符 `&`（和号）来获取变量的地址值，如下例所示：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch04/pointers.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/pointers.go
- en: 'Variable `aptr`, of pointer type `*int`, is initialized and assigned the address
    value of variable `a` using expression `&a` as listed here:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `aptr`，类型为 `*int` 的指针，通过表达式 `&a` 初始化并分配变量 `a` 的地址值，如下所示：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While variable `a` stores the actual value, we say that `aptr` points to `a`.
    The following shows the output of the program with the value of variable `a` and
    its memory location assigned to `aptr`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量 `a` 存储实际值时，我们说指针 `aptr` 指向 `a`。以下展示了程序输出，其中变量 `a` 的值及其内存位置被分配给 `aptr`：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The assigned address value will always be the same (always pointing to `a`)
    regardless of where `aptr` may be accessed in the code. It is also worth noting
    that Go does not allow the use of the address operator with literal constant for
    numeric, string, and bool types. Therefore, the following will not compile:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的地址值始终相同（始终指向 `a`），无论在代码中 `aptr` 可能被访问的位置如何。还值得注意的是，Go 不允许使用地址运算符与数值、字符串和布尔类型的字面常量一起使用。因此，以下代码将无法编译：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is a syntactical exception to this rule, however, when initializing composite
    types such as struct and array with literal constants. The following program illustrates
    such scenarios:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于使用字面常量初始化复合类型，如结构体和数组，存在一个语法上的例外。以下程序说明了这种情况：
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
