- en: The address operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pointer values can only be assigned addresses of their declared types. One
    way you can do so in Go is to use the address operator `&`(ampersand) to obtain
    the address value of a variable as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/pointers.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable `aptr`, of pointer type `*int`, is initialized and assigned the address
    value of variable `a` using expression `&a` as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While variable `a` stores the actual value, we say that `aptr` points to `a`.
    The following shows the output of the program with the value of variable `a` and
    its memory location assigned to `aptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The assigned address value will always be the same (always pointing to `a`)
    regardless of where `aptr` may be accessed in the code. It is also worth noting
    that Go does not allow the use of the address operator with literal constant for
    numeric, string, and bool types. Therefore, the following will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a syntactical exception to this rule, however, when initializing composite
    types such as struct and array with literal constants. The following program illustrates
    such scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
