- en: Chapter 10. Data IO in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previous chapters of this book focused mainly on fundamentals. In this and
    future chapters, readers are introduced to some of the powerful APIs provided
    by Go''s standard library. This chapter discusses in detail how to input, process,
    transform, and output data using APIs from the standard library and their respective
    packages with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: IO with readers and writers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The io.Reader interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The io.Writer interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the io package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatted IO with fmt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffered IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding and decoding data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IO with readers and writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to other languages, such as Java, Go models data input and output as
    a stream that flows from sources to targets. Data resources, such as files, networked
    connections, or even some in-memory objects, can be modeled as streams of bytes
    from which data can be *read* or *written* to, as illustrated in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IO with readers and writers](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The stream of data is represented as a **slice of bytes** (**[]byte**) that
    can be accessed for reading or writing. As we will explore in this chapter, the
    `*io*` package makes available the `io.Reader` interface to implement code that
    *reads* and transfers data from a source into a stream of bytes. Conversely, the
    `io.Writer` interface lets implementers create code that reads data from a provided
    stream of bytes and *writes* it as output to a target resource. Both interfaces
    are used extensively in Go as a standard idiom to express IO operations. This
    makes it possible to interchange readers and writers of different implementations
    and contexts with predictable results.
  prefs: []
  type: TYPE_NORMAL
- en: The io.Reader interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io.Reader` interface, as shown in the following listing, is simple. It
    consists of a single method, `Read([]byte)(int, error)`, intended to let programmers
    implement code that *reads* data, from an arbitrary source, and transfers it into
    the provided slice of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Read` method returns the total number of bytes transferred into the provided
    slice and an error value (if necessary). As a guideline, implementations of the
    `io.Reader` should return an error value of `io.EOF` when the reader has no more
    data to transfer into stream `p`. The following shows the type `alphaReader`,
    a trivial implementation of the `io.Reader` that filters out non-alpha characters
    from its string source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/reader0.go
  prefs: []
  type: TYPE_NORMAL
- en: Since values of the `alphaReader` type implement the `io.Reader` interface,
    they can participate anywhere a reader is expected as shown in the call to `io.Copy(os.Stdout,
    &str)`. This copies the stream of bytes emitted by the `alphaReader` variable
    into a writer interface, `os.Stdout` (covered later).
  prefs: []
  type: TYPE_NORMAL
- en: Chaining readers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/reader2.go
  prefs: []
  type: TYPE_NORMAL
- en: The io.Writer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `io.Writer` interface, as shown in the following code, is just as simple
    as its reader counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/writer2.go.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the io package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The obvious place to start with IO is, well, the `io` package ([https://golang.org/pkg/io](https://golang.org/pkg/io)).
    As we have already seen, the `io` package defines input and output primitives
    as the `io.Reader` and `io.Writer` interfaces. The following table summarizes
    additional functions and types, available in the `io` package, that facilitate
    streaming IO operations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `io.Copy()` | The `io.Copy` function (and its variants `io.CopyBuffer` and
    `io.CopyN`) make it easy to copy data from an arbitrary `io.Reader` source into
    an equally arbitrary `io.Writer` sink as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iocopy.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `PipeReader PipeWriter` | The `io` package includes the *PipeReader* and
    *PipeWriter* types that model IO operations as an in-memory pipe. Data is written
    to the pipe''s `io.Writer` and can independently be read at the pipe''s `io.Reader`.
    The following abbreviated snippet illustrates a simple pipe that writes a string
    to the writer `pw`. The data is then consumed with the `pr` reader and copied
    to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iopipe.goNote that the pipe writer will block until the reader
    completely consumes the pipe content or an error is encountered. Therefore, both
    the reader and writer should be wrapped in a goroutine to avoid deadlocks. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.TeeReader()` | Similar to the `io.Copy` function, `io.TeeReader` transfers
    content from a reader to a writer. However, the function also emits the copied
    bytes (unaltered) via a returned `io.Reader`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'golang.fyi/ch10/ioteerdr0.goIf we wanted to calculate both SHA-1 and MD5, we
    can update the code to nest the two `TeeReader` values as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/ioteerdr1.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.WriteString()` | The `io.WriteString` function writes the content of
    string into a specified writer. The following writes the content of a string to
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iowritestr.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.LimitedReader` | As its name suggests, the `io.LimitedReader` struct is
    a reader that reads only *N* number of bytes from the specified `io.Reader`. The
    following snippet will print the first 19 bytes from the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iolimitedrdr.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.SectionReader` | The `io.SectionReader` type implements seek and skip
    primitives by specifying an index (zero-based) where to start reading and an offset
    value indicating the number of bytes to read as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iosectionrdr.goThis example will print `jumps over the lazy
    dog`. |
  prefs: []
  type: TYPE_NORMAL
- en: '| Package `io/ioutil` | The `io/ioutil` sub-package implements a small number
    of functions that provide utilitarian shortcuts to IO primitives such as file
    read, directory listing, temp directory creation, and file write. |'
  prefs: []
  type: TYPE_TB
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os` package ([https://golang.org/pkg/os/](https://golang.org/pkg/os/))
    exposes the `os.File` type which represents a file handle on the system. The `os.File`
    type implements several IO primitives, including the `io.Reader` and `io.Writer`
    interfaces, which allows file content to be processed using the standard streaming
    IO API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and opening files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/file0.go
  prefs: []
  type: TYPE_NORMAL
- en: Function os.OpenFile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/file1.go
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you already have a reference to an OS file descriptor, you can also use the
    `os.NewFile` function to create a file handle in your program. The `os.NewFile`
    function is rarely used, as files are usually initialized using the file functions
    discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Files writing and reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/filewrite0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, the source of your data is not text, you can write raw bytes directly
    to the file as shown in the following source snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fileread.go
  prefs: []
  type: TYPE_NORMAL
- en: Standard input, output, and error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/osstd.go
  prefs: []
  type: TYPE_NORMAL
- en: Formatted IO with fmt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most widely used packages for IO is `fmt` ([https://golang.org/pkg/fmt](https://golang.org/pkg/fmt)).
    It comes with an amalgam of functions designed for formatted input and output.
    The most common usage of the `fmt` package is for writing to standard output and
    reading from standard input. This section also highlights other functions that
    make `fmt` a great tool for IO.
  prefs: []
  type: TYPE_NORMAL
- en: Printing to io.Writer interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtfprint0.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the `fmt.Fprintf` function uses format specifiers to
    write formatted text to the io.File `file` variable. The `fmt.Fprintf` function
    supports a large number of format specifiers whose proper treatment is beyond
    the scope of this text. Refer to the online documentation for complete coverage
    of these specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Printing to standard output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtprint0.go
  prefs: []
  type: TYPE_NORMAL
- en: Reading from io.Reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtfscan0.go
  prefs: []
  type: TYPE_NORMAL
- en: The code reads from the `io.File` variable `data`, until it encounters an `io.EOF`
    error indicating the end of the file. Each line of text it reads is parsed using
    format specifiers `"%s %d %d %s\n"` which matches the space-delimited layout of
    the records stored in the file. Each parsed token is then assigned to its respective
    variable `name`, `diam`, `moons`, and `hasRing,` which are printed to the standard
    output using the `fm.Printf` function.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from standard input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of reading from an arbitrary `io.Reader`, the `fmt.Scan`, `fmt.Scanf`,
    and `fmt.Scanln` are used to read data from standard input file handle, `os.Stdin`.
    The following code snippet shows a simple program that reads text input from the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtscan1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous program, the `fmt.Scanf` function parses the input using the
    format specifier `"%d"` to read an integer value from the standard input. The
    function will throw an error if the value read does not match exactly the specified
    format. For instance, the following shows what happens when character `D` is read
    instead of an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Buffered IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most IO operations covered so far have been unbuffered. This implies that each
    read and write operation could be negatively impacted by the latency of the underlying
    OS to handle IO requests. Buffered operations, on the other hand, reduces latency
    by buffering data in internal memory during IO operations. The `bufio` package
    ([https://golang.org/pkg/bufio](https://golang.org/pkg/bufio)/) offers functions
    for buffered read and write IO operations.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered writers and readers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bufio` package offers several functions to do buffered writing of IO streams
    using an `io.Writer` interface. The following snippet creates a text file and
    writes to it using buffered IO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: golang`.fyi/ch10/bufread0.go`
  prefs: []
  type: TYPE_NORMAL
- en: The previous code uses the `reader.ReadString` method to read a text file using
    the `'\n'` character as the content delimiter. To influence the size of the internal
    buffer, use the constructor function `bufio.NewReaderSize(w io.Reader, n int)`
    to specify the internal buffer size. The `bufio.Reader` type also offers the *Read*,
    *ReadByte*, and *ReadBytes* methods for reading raw bytes from a stream and the
    *ReadRune* method for reading Unicode-encoded characters.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning the buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/bufscan0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `bufio.Scanner` is done in four steps as shown in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, use `bufio.NewScanner(io.Reader)` to create a scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `scanner.Split` method to configure how the content is tokenized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traverse the generated tokens with the `scanner.Scan` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the tokenized data with the `scanner.Text` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code uses the pre-defined function `bufio.ScanLines` to parse the buffered
    content using a line-delimiter. The `bufio` package comes with several pre-defined
    splitter functions including *ScanBytes* to scan each byte as a token, *ScanRunes*
    to scan UTF-8 encoded tokens, and *ScanWords* which scan each space-separated
    words as tokens.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/bytesbuf0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The same example can easily be updated to stream the content to a regular file
    as shown in the following abbreviate code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/bytesbuf1.go
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and decoding data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common aspect of IO in Go is the encoding of data, from one representation
    to another, as it is being streamed. The encoders and decoders of the standard
    library, found in the *encoding* package ([https://golang.org/pkg/encoding/](https://golang.org/pkg/encoding/)),
    use the `io.Reader` and `io.Writer` interfaces to leverage IO primitives as a
    way of streaming data during encoding and decoding.
  prefs: []
  type: TYPE_NORMAL
- en: Go supports several encoding formats for a variety of purposes including data
    conversion, data compaction, and data encryption. This chapter will focus on encoding
    and decoding data using the *Gob* and *JSON* format for data conversion. In [Chapter
    11](part0078_split_000.html#2ACBS2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 11. Writing
    Networked Services"), *Writing Networked Programs*, we will explore using encoders
    to convert data for client and server communication using **remote procedure calls**
    (**RPC**).
  prefs: []
  type: TYPE_NORMAL
- en: Binary encoding with gob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/gob1.go
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a previously encoded gob data is done by creating a decoder using `dec
    := gob.NewDecoder(file)`. The next step is to declare the variable that will store
    the decoded data. In our example, the `books` variable, of the `[]Book` type,
    is declared as the destination of the decoded data. The actual decoding is done
    by invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of this writing, gob encoder and decoder APIs are only available in the Go
    programming language. This means that data encoded as gob can only be consumed
    by Go programs.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding data as JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The encoding package also comes with a *json* encoder sub-package ([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))
    to support JSON-formatted data. This greatly broadens the number of languages
    with which Go programs can exchange complex data structures. JSON encoding works
    similarly as the encoder and decoder from the gob package. The difference is that
    the generated data takes the form of a clear text JSON-encoded format instead
    of a binary. The following code updates the previous example to encode the data
    as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is exactly the same as before. It uses the same slice of nested structs
    assigned to the `books` variable. The only difference is the encoder is created
    with `enc := json.NewEncoder(file)` which creates a JSON encoder that will use
    the `file` variable as its `io.Writer` destination. When `enc.Encode(books)` is
    executed, the content of the variable `books` is serialized as JSON to the local
    file `books.dat`, shown in the following code (formatted for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json1.go
  prefs: []
  type: TYPE_NORMAL
- en: The data in the books.dat file is stored as an array of JSON objects. Therefore,
    the code must declare a variable capable of storing an indexed collection of nested
    struct values. In the previous example, the `books` variable, of the type `[]Book` is
    declared as the destination of the decoded data. The actual decoding is done by
    invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling JSON mapping with struct tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The tags and their meaning are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tags** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `` Title string `json:"book_title"` `` | Maps the `Title` struct field to
    the JSON object key, `"book_title"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `` PageCount int `json:"pages,string"` `` | Maps the `PageCount` struct field
    to the JSON object key, `"pages",` and outputs the value as a string instead of
    a number. |'
  prefs: []
  type: TYPE_TB
- en: '| `` ISBN string `json:"-"` `` | The dash causes the `ISBN` field to be skipped
    during encoding and decoding. |'
  prefs: []
  type: TYPE_TB
- en: '| `` Authors []Name `json:"auths,omniempty"` `` | Maps the `Authors` field
    to the JSON object key, `"auths"`. The annotation, `omniempty,` causes the field
    to be omitted if its value is nil. |'
  prefs: []
  type: TYPE_TB
- en: '| `` Publisher string `json:",omniempty"` `` | Maps the struct field name,
    `Publisher,` as the JSON object key name. The annotation, `omniempty,` causes
    the field to be omitted when empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `` PublishDate time.Time `json:"pub_date"` `` | Maps the field name, `PublishDate,`
    to the JSON object key, `"pub_date"`. |'
  prefs: []
  type: TYPE_TB
- en: 'When the previous struct is encoded, it produces the following JSON output
    in the `books.dat` file (formatted for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Notice the JSON object keys are titled as specified in the `struct` tags. The
    object key `"pages"` (mapped to the struct field, `PageCount`) is encoded as a
    string. Finally, the struct field, `ISBN,` is omitted, as annotated in the `struct`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Custom encoding and decoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json3.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, values of the `Name` type are serialized as a JSON
    string (instead of an object as earlier). The serialization is handled by the
    method `Name.MarshallJSON` which returns an array of bytes that contains the last
    and first name separated by a comma. The preceding code generates the following
    JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json4.go
  prefs: []
  type: TYPE_NORMAL
- en: The `Name` type is an implementation of `json.Unmarshaler`. When the decoder
    encounters a JSON object with the key `"Authors"`, it uses the method `Name.Unmarshaler`
    to reconstitute the Go struct `Name` type from the JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Go standard libraries offer additional encoders (not covered here) including
    `base32`, `bas364`, `binary`, `csv`, `hex`, `xml`, `gzip`, and numerous encryption
    format encoders.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides a high-level view of Go's data input and output idioms
    and the packages involved in implementing IO primitives. The chapter starts by
    covering the fundamentals of a stream-based IO in Go with the `io.Reader` and
    `io.Writer` interfaces. Readers are walked through the implementation strategies
    and examples for both an `io.Reader` and an `io.Writer`.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter goes on to cover packages, types, and functions that that support
    the streaming IO mechanism including working with files, formatted IO, buffered,
    and in-memory IO. The last portion of the chapter covers encoders and decoders
    that convert data as it is being streamed. In the next chapter, the IO theme is
    carried further when the discussion turns to creating programs that use IO to
    communicate via networking.
  prefs: []
  type: TYPE_NORMAL
