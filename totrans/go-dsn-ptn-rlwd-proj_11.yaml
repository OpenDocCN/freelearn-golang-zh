- en: Chapter 10. Data IO in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. Go 中的数据 IO
- en: 'Previous chapters of this book focused mainly on fundamentals. In this and
    future chapters, readers are introduced to some of the powerful APIs provided
    by Go''s standard library. This chapter discusses in detail how to input, process,
    transform, and output data using APIs from the standard library and their respective
    packages with the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章主要关注基础知识。在本章和未来的章节中，读者将介绍 Go 标准库提供的强大 API 的一些内容。本章详细讨论如何使用标准库及其各自的包的 API
    输入、处理、转换和输出数据，以下是一些主题：
- en: IO with readers and writers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读取器和写入器进行IO操作
- en: The io.Reader interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.Reader` 接口'
- en: The io.Writer interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.Writer` 接口'
- en: Working with the io package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `io` 包进行工作
- en: Working with files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件一起工作
- en: Formatted IO with fmt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `fmt` 进行格式化 IO
- en: Buffered IO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲IO
- en: In-memory IO
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中的 IO
- en: Encoding and decoding data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的编码和解码
- en: IO with readers and writers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用读取器和写入器进行 IO 操作
- en: 'Similar to other languages, such as Java, Go models data input and output as
    a stream that flows from sources to targets. Data resources, such as files, networked
    connections, or even some in-memory objects, can be modeled as streams of bytes
    from which data can be *read* or *written* to, as illustrated in the following
    figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言，如 Java，Go 将数据输入和输出建模为从源到目标的流。数据资源，如文件、网络连接，甚至一些内存中的对象，都可以建模为字节流，可以从其中读取或写入数据，如下面的图示所示：
- en: '![IO with readers and writers](img/00026.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![使用读取器和写入器进行IO操作](img/00026.jpeg)'
- en: The stream of data is represented as a **slice of bytes** (**[]byte**) that
    can be accessed for reading or writing. As we will explore in this chapter, the
    `*io*` package makes available the `io.Reader` interface to implement code that
    *reads* and transfers data from a source into a stream of bytes. Conversely, the
    `io.Writer` interface lets implementers create code that reads data from a provided
    stream of bytes and *writes* it as output to a target resource. Both interfaces
    are used extensively in Go as a standard idiom to express IO operations. This
    makes it possible to interchange readers and writers of different implementations
    and contexts with predictable results.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流表示为可以访问以读取或写入的 **字节切片**（**[]byte**）。正如我们将在本章中探讨的，`*io*` 包提供了 `io.Reader`
    接口以实现代码，从源读取并传输数据到字节流。相反，`io.Writer` 接口允许实现者创建代码，从提供的字节流中读取数据并将其写入目标资源。这两个接口在
    Go 中被广泛用作标准习语来表示 IO 操作。这使得可以以可预测的结果交换不同实现和上下文中的读取器和写入器。
- en: The io.Reader interface
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`io.Reader` 接口'
- en: The `io.Reader` interface, as shown in the following listing, is simple. It
    consists of a single method, `Read([]byte)(int, error)`, intended to let programmers
    implement code that *reads* data, from an arbitrary source, and transfers it into
    the provided slice of bytes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`io.Reader` 接口很简单。它由一个方法组成，`Read([]byte)(int, error)`，旨在让程序员实现代码，从任意源读取数据并将其传输到提供的字节切片中。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Read` method returns the total number of bytes transferred into the provided
    slice and an error value (if necessary). As a guideline, implementations of the
    `io.Reader` should return an error value of `io.EOF` when the reader has no more
    data to transfer into stream `p`. The following shows the type `alphaReader`,
    a trivial implementation of the `io.Reader` that filters out non-alpha characters
    from its string source:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read` 方法返回传输到提供的切片中的总字节数和一个错误值（如果需要）。作为一个指导原则，`io.Reader` 的实现应该在读取器没有更多数据传输到流
    `p` 时返回错误值 `io.EOF`。以下显示了 `alphaReader` 类型，这是一个从其字符串源过滤掉非 alpha 字符的 `io.Reader`
    的简单实现：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch10/reader0.go
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/reader0.go
- en: Since values of the `alphaReader` type implement the `io.Reader` interface,
    they can participate anywhere a reader is expected as shown in the call to `io.Copy(os.Stdout,
    &str)`. This copies the stream of bytes emitted by the `alphaReader` variable
    into a writer interface, `os.Stdout` (covered later).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `alphaReader` 类型的值实现了 `io.Reader` 接口，因此它们可以在需要读取器的任何地方参与，如 `io.Copy(os.Stdout,
    &str)` 调用所示。这会将 `alphaReader` 变量发出的字节流复制到写入器接口 `os.Stdout`（稍后介绍）。
- en: Chaining readers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接读取器
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch10/reader2.go
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/reader2.go
- en: The io.Writer interface
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`io.Writer` 接口'
- en: 'The `io.Writer` interface, as shown in the following code, is just as simple
    as its reader counterpart:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`io.Writer` 接口与其读取器对应者一样简单：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: golang.fyi/ch10/writer2.go.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/writer2.go.
- en: Working with the io package
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `io` 包进行工作
- en: The obvious place to start with IO is, well, the `io` package ([https://golang.org/pkg/io](https://golang.org/pkg/io)).
    As we have already seen, the `io` package defines input and output primitives
    as the `io.Reader` and `io.Writer` interfaces. The following table summarizes
    additional functions and types, available in the `io` package, that facilitate
    streaming IO operations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IO 操作中，最明显的地方是从 `io` 包开始，嗯，`io` 包（[https://golang.org/pkg/io](https://golang.org/pkg/io)）。正如我们已经看到的，`io`
    包定义了输入和输出原语为 `io.Reader` 和 `io.Writer` 接口。以下表格总结了在 `io` 包中可用的其他函数和类型，这些函数和类型有助于简化流式
    IO 操作。
- en: '| **Function** | **Description** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `io.Copy()` | The `io.Copy` function (and its variants `io.CopyBuffer` and
    `io.CopyN`) make it easy to copy data from an arbitrary `io.Reader` source into
    an equally arbitrary `io.Writer` sink as shown in the following snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.Copy()` | `io.Copy` 函数（及其变体 `io.CopyBuffer` 和 `io.CopyN`）使得从任意 `io.Reader`
    源复制数据到任意 `io.Writer` 汇入变得容易，如下面的代码片段所示：'
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: golang.fyi/ch10/iocopy.go |
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iocopy.go |
- en: '| `PipeReader PipeWriter` | The `io` package includes the *PipeReader* and
    *PipeWriter* types that model IO operations as an in-memory pipe. Data is written
    to the pipe''s `io.Writer` and can independently be read at the pipe''s `io.Reader`.
    The following abbreviated snippet illustrates a simple pipe that writes a string
    to the writer `pw`. The data is then consumed with the `pr` reader and copied
    to a file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '| `PipeReader PipeWriter` | `io` 包包括 *PipeReader* 和 *PipeWriter* 类型，它们将 IO
    操作建模为内存管道。数据写入管道的 `io.Writer`，然后可以独立地从管道的 `io.Reader` 读取。以下简化的代码片段演示了一个简单的管道，它将字符串写入写入器
    `pw`。然后使用 `pr` 读取器消耗数据，并将其复制到文件中：'
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: golang.fyi/ch10/iopipe.goNote that the pipe writer will block until the reader
    completely consumes the pipe content or an error is encountered. Therefore, both
    the reader and writer should be wrapped in a goroutine to avoid deadlocks. |
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iopipe.go 注意，管道写入器将在读取器完全消耗管道内容或遇到错误时阻塞。因此，读取器和写入器都应该被包装在 goroutine
    中，以避免死锁。|
- en: '| `io.TeeReader()` | Similar to the `io.Copy` function, `io.TeeReader` transfers
    content from a reader to a writer. However, the function also emits the copied
    bytes (unaltered) via a returned `io.Reader`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.TeeReader()` | 与 `io.Copy` 函数类似，`io.TeeReader` 将内容从读取器传输到写入器。然而，该函数还会通过返回的
    `io.Reader` 发射复制的字节（未更改）。'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'golang.fyi/ch10/ioteerdr0.goIf we wanted to calculate both SHA-1 and MD5, we
    can update the code to nest the two `TeeReader` values as shown in the following
    snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/ioteerdr0.go 如果我们想要同时计算 SHA-1 和 MD5，我们可以更新代码，将两个 `TeeReader`
    值嵌套，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch10/ioteerdr1.go |
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/ioteerdr1.go |
- en: '| `io.WriteString()` | The `io.WriteString` function writes the content of
    string into a specified writer. The following writes the content of a string to
    a file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.WriteString()` | `io.WriteString` 函数将字符串的内容写入指定的写入器。以下示例将字符串的内容写入文件：'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch10/iowritestr.go |
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iowritestr.go |
- en: '| `io.LimitedReader` | As its name suggests, the `io.LimitedReader` struct is
    a reader that reads only *N* number of bytes from the specified `io.Reader`. The
    following snippet will print the first 19 bytes from the string:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.LimitedReader` | 如其名称所示，`io.LimitedReader` 结构体是一个只从指定的 `io.Reader` 读取
    *N* 个字节的读取器。以下代码片段将打印字符串的前 19 个字节：'
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch10/iolimitedrdr.go
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iolimitedrdr.go
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.SectionReader` | The `io.SectionReader` type implements seek and skip
    primitives by specifying an index (zero-based) where to start reading and an offset
    value indicating the number of bytes to read as shown in the following snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.SectionReader` | `io.SectionReader` 类型通过指定一个索引（基于零）来开始读取，以及一个表示要读取的字节数的偏移量值来实现
    seek 和 skip 原语，如下面的代码片段所示：'
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch10/iosectionrdr.goThis example will print `jumps over the lazy
    dog`. |
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iosectionrdr.go 此示例将打印 `jumps over the lazy dog`。|
- en: '| Package `io/ioutil` | The `io/ioutil` sub-package implements a small number
    of functions that provide utilitarian shortcuts to IO primitives such as file
    read, directory listing, temp directory creation, and file write. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 包 `io/ioutil` | `io/ioutil` 子包实现了一小部分函数，这些函数提供了对 IO 原语（如文件读取、目录列出、临时目录创建和文件写入）的实用快捷方式。'
- en: Working with files
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件
- en: The `os` package ([https://golang.org/pkg/os/](https://golang.org/pkg/os/))
    exposes the `os.File` type which represents a file handle on the system. The `os.File`
    type implements several IO primitives, including the `io.Reader` and `io.Writer`
    interfaces, which allows file content to be processed using the standard streaming
    IO API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 包 ([https://golang.org/pkg/os/](https://golang.org/pkg/os/)) 提供了 `os.File`
    类型，它表示系统上的文件句柄。`os.File` 类型实现了多个 IO 原语，包括 `io.Reader` 和 `io.Writer` 接口，这使得可以使用标准的流式
    IO API 处理文件内容。'
- en: Creating and opening files
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和打开文件
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch10/file0.go
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/file0.go
- en: Function os.OpenFile
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数 os.OpenFile
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: golang.fyi/ch10/file1.go
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/file1.go
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you already have a reference to an OS file descriptor, you can also use the
    `os.NewFile` function to create a file handle in your program. The `os.NewFile`
    function is rarely used, as files are usually initialized using the file functions
    discussed previously.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个指向操作系统文件描述符的引用，你也可以使用 `os.NewFile` 函数在你的程序中创建一个文件句柄。`os.NewFile` 函数很少使用，因为文件通常使用之前讨论过的文件函数进行初始化。
- en: Files writing and reading
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件读写
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch10/filewrite0.go
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/filewrite0.go
- en: 'If, however, the source of your data is not text, you can write raw bytes directly
    to the file as shown in the following source snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的数据源不是文本，你可以直接将原始字节写入文件，如下面的源代码片段所示：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch10/fileread.go
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fileread.go
- en: Standard input, output, and error
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输入、输出和错误
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch10/osstd.go
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/osstd.go
- en: Formatted IO with fmt
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fmt 进行格式化 IO
- en: One of the most widely used packages for IO is `fmt` ([https://golang.org/pkg/fmt](https://golang.org/pkg/fmt)).
    It comes with an amalgam of functions designed for formatted input and output.
    The most common usage of the `fmt` package is for writing to standard output and
    reading from standard input. This section also highlights other functions that
    make `fmt` a great tool for IO.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的 IO 包之一是 `fmt` ([https://golang.org/pkg/fmt](https://golang.org/pkg/fmt))。它包含了一系列用于格式化输入和输出的函数。`fmt`
    包最常用的用途是写入标准输出和读取标准输入。本节还突出了其他使 `fmt` 成为优秀 IO 工具的函数。
- en: Printing to io.Writer interfaces
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 io.Writer 接口打印
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch10/fmtfprint0.go
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtfprint0.go
- en: In the previous example, the `fmt.Fprintf` function uses format specifiers to
    write formatted text to the io.File `file` variable. The `fmt.Fprintf` function
    supports a large number of format specifiers whose proper treatment is beyond
    the scope of this text. Refer to the online documentation for complete coverage
    of these specifiers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`fmt.Fprintf` 函数使用格式说明符将格式化文本写入到 io.File 变量 `file`。`fmt.Fprintf` 函数支持大量的格式说明符，其正确处理超出了本文的范围。请参阅在线文档以获取这些说明符的完整覆盖。
- en: Printing to standard output
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向标准输出打印
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch10/fmtprint0.go
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtprint0.go
- en: Reading from io.Reader
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 io.Reader 读取
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: golang.fyi/ch10/fmtfscan0.go
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtfscan0.go
- en: The code reads from the `io.File` variable `data`, until it encounters an `io.EOF`
    error indicating the end of the file. Each line of text it reads is parsed using
    format specifiers `"%s %d %d %s\n"` which matches the space-delimited layout of
    the records stored in the file. Each parsed token is then assigned to its respective
    variable `name`, `diam`, `moons`, and `hasRing,` which are printed to the standard
    output using the `fm.Printf` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从 `io.File` 变量 `data` 读取，直到遇到表示文件结束的 `io.EOF` 错误。它读取的每一行文本都使用格式说明符 `"%s %d
    %d %s\n"` 进行解析，这与存储在文件中的记录的空格分隔布局相匹配。然后，每个解析的标记被分配给相应的变量 `name`、`diam`、`moons`
    和 `hasRing`，这些变量使用 `fm.Printf` 函数打印到标准输出。
- en: Reading from standard input
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从标准输入读取
- en: 'Instead of reading from an arbitrary `io.Reader`, the `fmt.Scan`, `fmt.Scanf`,
    and `fmt.Scanln` are used to read data from standard input file handle, `os.Stdin`.
    The following code snippet shows a simple program that reads text input from the
    console:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与从任意的 `io.Reader` 读取不同，`fmt.Scan`、`fmt.Scanf` 和 `fmt.Scanln` 用于从标准输入文件句柄 `os.Stdin`
    读取数据。以下代码片段展示了从控制台读取文本输入的简单程序：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: golang.fyi/ch10/fmtscan1.go
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtscan1.go
- en: 'In the previous program, the `fmt.Scanf` function parses the input using the
    format specifier `"%d"` to read an integer value from the standard input. The
    function will throw an error if the value read does not match exactly the specified
    format. For instance, the following shows what happens when character `D` is read
    instead of an integer:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序中，`fmt.Scanf` 函数使用格式说明符 `"%d"` 解析输入，从标准输入读取一个整数值。如果读取的值与指定的格式不精确匹配，该函数将抛出一个错误。例如，以下展示了当读取字符
    `D` 而不是整数时会发生什么：
- en: '[PRE35]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Buffered IO
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲输入输出
- en: Most IO operations covered so far have been unbuffered. This implies that each
    read and write operation could be negatively impacted by the latency of the underlying
    OS to handle IO requests. Buffered operations, on the other hand, reduces latency
    by buffering data in internal memory during IO operations. The `bufio` package
    ([https://golang.org/pkg/bufio](https://golang.org/pkg/bufio)/) offers functions
    for buffered read and write IO operations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数 IO 操作都是非缓冲的。这意味着每个读写操作都可能受到底层操作系统处理 IO 请求延迟的负面影响。另一方面，缓冲操作通过在 IO 操作期间在内部内存中缓冲数据来减少延迟。`bufio`
    包（[https://golang.org/pkg/bufio](https://golang.org/pkg/bufio)/）提供了缓冲读写 IO 操作的函数。
- en: Buffered writers and readers
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲写入器和读取器
- en: 'The `bufio` package offers several functions to do buffered writing of IO streams
    using an `io.Writer` interface. The following snippet creates a text file and
    writes to it using buffered IO:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio` 包提供了几个函数，用于使用 `io.Writer` 接口进行缓冲的 IO 流写入。以下代码片段创建了一个文本文件，并使用缓冲 IO 向其写入：'
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: golang`.fyi/ch10/bufread0.go`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: golang`.fyi/ch10/bufread0.go`
- en: The previous code uses the `reader.ReadString` method to read a text file using
    the `'\n'` character as the content delimiter. To influence the size of the internal
    buffer, use the constructor function `bufio.NewReaderSize(w io.Reader, n int)`
    to specify the internal buffer size. The `bufio.Reader` type also offers the *Read*,
    *ReadByte*, and *ReadBytes* methods for reading raw bytes from a stream and the
    *ReadRune* method for reading Unicode-encoded characters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `reader.ReadString` 方法通过 `'\n'` 字符作为内容分隔符来读取文本文件。要影响内部缓冲区的大小，请使用构造函数
    `bufio.NewReaderSize(w io.Reader, n int)` 来指定内部缓冲区大小。`bufio.Reader` 类型还提供了 *Read*、*ReadByte*
    和 *ReadBytes* 方法，用于从流中读取原始字节，以及 *ReadRune* 方法用于读取 Unicode 编码的字符。
- en: Scanning the buffer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描缓冲区
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: golang.fyi/ch10/bufscan0.go
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/bufscan0.go
- en: 'Using `bufio.Scanner` is done in four steps as shown in the previous example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bufio.Scanner` 的步骤如前一个示例所示，共有四个步骤：
- en: First, use `bufio.NewScanner(io.Reader)` to create a scanner
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用 `bufio.NewScanner(io.Reader)` 创建一个扫描器
- en: Call the `scanner.Split` method to configure how the content is tokenized
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `scanner.Split` 方法来配置内容如何被标记化
- en: Traverse the generated tokens with the `scanner.Scan` method
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `scanner.Scan` 方法遍历生成的标记
- en: Read the tokenized data with the `scanner.Text` method
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `scanner.Text` 方法读取标记化数据
- en: The code uses the pre-defined function `bufio.ScanLines` to parse the buffered
    content using a line-delimiter. The `bufio` package comes with several pre-defined
    splitter functions including *ScanBytes* to scan each byte as a token, *ScanRunes*
    to scan UTF-8 encoded tokens, and *ScanWords* which scan each space-separated
    words as tokens.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用预定义函数 `bufio.ScanLines` 使用行分隔符解析缓冲内容。`bufio` 包附带几个预定义的拆分函数，包括 *ScanBytes*
    用于将每个字节作为标记扫描，*ScanRunes* 用于扫描 UTF-8 编码的标记，以及 *ScanWords* 用于将每个空格分隔的单词作为标记扫描。
- en: In-memory IO
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的 IO
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: golang.fyi/ch10/bytesbuf0.go
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/bytesbuf0.go
- en: 'The same example can easily be updated to stream the content to a regular file
    as shown in the following abbreviate code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的示例可以很容易地更新为将内容流式传输到常规文件，如下面的简略代码片段所示：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: golang.fyi/ch10/bytesbuf1.go
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/bytesbuf1.go
- en: Encoding and decoding data
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据的编码和解码
- en: Another common aspect of IO in Go is the encoding of data, from one representation
    to another, as it is being streamed. The encoders and decoders of the standard
    library, found in the *encoding* package ([https://golang.org/pkg/encoding/](https://golang.org/pkg/encoding/)),
    use the `io.Reader` and `io.Writer` interfaces to leverage IO primitives as a
    way of streaming data during encoding and decoding.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中 IO 的另一个常见方面是在流式传输过程中将数据从一种表示形式编码到另一种表示形式。标准库中的编码器和解码器，位于 *encoding* 包中（[https://golang.org/pkg/encoding/](https://golang.org/pkg/encoding/）），使用
    `io.Reader` 和 `io.Writer` 接口来利用 IO 原语作为编码和解码过程中流式传输数据的方式。
- en: Go supports several encoding formats for a variety of purposes including data
    conversion, data compaction, and data encryption. This chapter will focus on encoding
    and decoding data using the *Gob* and *JSON* format for data conversion. In [Chapter
    11](part0078_split_000.html#2ACBS2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 11. Writing
    Networked Services"), *Writing Networked Programs*, we will explore using encoders
    to convert data for client and server communication using **remote procedure calls**
    (**RPC**).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持多种编码格式，用于各种目的，包括数据转换、数据压缩和数据加密。本章将专注于使用*Gob*和*JSON*格式进行数据转换的编码和解码。在[第11章](part0078_split_000.html#2ACBS2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第11章。编写网络服务")《编写网络程序》中，我们将探讨使用编码器将数据转换为客户端和服务器通信，使用**远程过程调用**（**RPC**）。
- en: Binary encoding with gob
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gob进行二进制编码
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: golang.fyi/ch10/gob1.go
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/gob1.go
- en: Decoding a previously encoded gob data is done by creating a decoder using `dec
    := gob.NewDecoder(file)`. The next step is to declare the variable that will store
    the decoded data. In our example, the `books` variable, of the `[]Book` type,
    is declared as the destination of the decoded data. The actual decoding is done
    by invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个解码器`dec := gob.NewDecoder(file)`来解码先前编码的gob数据。下一步是声明将存储解码数据的变量。在我们的例子中，`books`变量，其类型为`[]Book`，被声明为解码数据的目的地。实际的解码操作是通过调用`dec.Decode(&books)`来完成的。注意`Decode()`方法接受其目标变量的地址作为参数。一旦解码完成，`books`变量将包含从文件中流出的重构数据结构。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of this writing, gob encoder and decoder APIs are only available in the Go
    programming language. This means that data encoded as gob can only be consumed
    by Go programs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，gob编码器和解码器API仅适用于Go编程语言。这意味着以gob编码的数据只能由Go程序消费。
- en: Encoding data as JSON
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据编码为JSON
- en: 'The encoding package also comes with a *json* encoder sub-package ([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))
    to support JSON-formatted data. This greatly broadens the number of languages
    with which Go programs can exchange complex data structures. JSON encoding works
    similarly as the encoder and decoder from the gob package. The difference is that
    the generated data takes the form of a clear text JSON-encoded format instead
    of a binary. The following code updates the previous example to encode the data
    as JSON:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 编码包还附带了一个*json*编码子包([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))，以支持JSON格式的数据。这大大增加了Go程序可以与之交换复杂数据结构的语言数量。JSON编码与gob包中的编码器和解码器类似。区别在于生成数据采用清晰的文本JSON编码格式，而不是二进制格式。以下代码更新了先前的例子，以将数据编码为JSON：
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: golang.fyi/ch10/json0.go
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json0.go
- en: 'The code is exactly the same as before. It uses the same slice of nested structs
    assigned to the `books` variable. The only difference is the encoder is created
    with `enc := json.NewEncoder(file)` which creates a JSON encoder that will use
    the `file` variable as its `io.Writer` destination. When `enc.Encode(books)` is
    executed, the content of the variable `books` is serialized as JSON to the local
    file `books.dat`, shown in the following code (formatted for readability):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与之前完全相同。它使用分配给`books`变量的相同嵌套结构切片。唯一的区别是使用`enc := json.NewEncoder(file)`创建编码器，这将创建一个使用`file`变量作为其`io.Writer`目的地的JSON编码器。当执行`enc.Encode(books)`时，`books`变量的内容将被序列化为JSON格式并写入本地文件`books.dat`，如下面的代码所示（格式化以提高可读性）：
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: golang.fyi/ch10/json1.go
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json1.go
- en: The data in the books.dat file is stored as an array of JSON objects. Therefore,
    the code must declare a variable capable of storing an indexed collection of nested
    struct values. In the previous example, the `books` variable, of the type `[]Book` is
    declared as the destination of the decoded data. The actual decoding is done by
    invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 书本.dat文件中的数据存储为一个JSON对象的数组。因此，代码必须声明一个变量，能够存储嵌套结构值的索引集合。在先前的例子中，`books`变量，其类型为`[]Book`，被声明为解码数据的目的地。实际的解码操作是通过调用`dec.Decode(&books)`来完成的。注意`Decode()`方法接受其目标变量的地址作为参数。一旦解码完成，`books`变量将包含从文件中流出的重构数据结构。
- en: Controlling JSON mapping with struct tags
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用结构体标签控制JSON映射
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: golang.fyi/ch10/json2.go
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json2.go
- en: 'The tags and their meaning are summarized in the following table:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了标签及其含义：
- en: '| **Tags** | **Description** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | **描述** |'
- en: '| `` Title string `json:"book_title"` `` | Maps the `Title` struct field to
    the JSON object key, `"book_title"`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `` Title string `json:"book_title"` `` | 将 `Title` 结构体字段映射到 JSON 对象键 `"book_title"`。
    |'
- en: '| `` PageCount int `json:"pages,string"` `` | Maps the `PageCount` struct field
    to the JSON object key, `"pages",` and outputs the value as a string instead of
    a number. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `` PageCount int `json:"pages,string"` `` | 将 `PageCount` 结构体字段映射到 JSON 对象键
    `"pages"`，并将值输出为字符串而不是数字。 |'
- en: '| `` ISBN string `json:"-"` `` | The dash causes the `ISBN` field to be skipped
    during encoding and decoding. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `` ISBN string `json:"-"` `` | 短横线导致 `ISBN` 字段在编码和解码过程中被跳过。 |'
- en: '| `` Authors []Name `json:"auths,omniempty"` `` | Maps the `Authors` field
    to the JSON object key, `"auths"`. The annotation, `omniempty,` causes the field
    to be omitted if its value is nil. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `` Authors []Name `json:"auths,omniempty"` `` | 将 `Authors` 字段映射到 JSON 对象键
    `"auths"`。注释 `omniempty` 导致字段值为 nil 时被省略。 |'
- en: '| `` Publisher string `json:",omniempty"` `` | Maps the struct field name,
    `Publisher,` as the JSON object key name. The annotation, `omniempty,` causes
    the field to be omitted when empty. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `` Publisher string `json:",omniempty"` `` | 将结构体字段名称 `Publisher` 映射为 JSON
    对象键名称。注释 `omniempty` 导致字段为空时被省略。 |'
- en: '| `` PublishDate time.Time `json:"pub_date"` `` | Maps the field name, `PublishDate,`
    to the JSON object key, `"pub_date"`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `` PublishDate time.Time `json:"pub_date"` `` | 将字段名称 `PublishDate` 映射到 JSON
    对象键 `"pub_date"`。 |'
- en: 'When the previous struct is encoded, it produces the following JSON output
    in the `books.dat` file (formatted for readability):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的结构体被编码时，在 `books.dat` 文件中产生以下 JSON 输出（格式化以提高可读性）：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice the JSON object keys are titled as specified in the `struct` tags. The
    object key `"pages"` (mapped to the struct field, `PageCount`) is encoded as a
    string. Finally, the struct field, `ISBN,` is omitted, as annotated in the `struct`
    tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 JSON 对象键的命名方式与 `struct` 标签中指定的一致。键 `"pages"`（映射到结构体字段 `PageCount`）被编码为字符串。最后，结构体字段
    `ISBN` 被省略，如 `struct` 标签中注释所示。
- en: Custom encoding and decoding
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义编码和解码
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: golang.fyi/ch10/json3.go
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json3.go
- en: 'In the previous example, values of the `Name` type are serialized as a JSON
    string (instead of an object as earlier). The serialization is handled by the
    method `Name.MarshallJSON` which returns an array of bytes that contains the last
    and first name separated by a comma. The preceding code generates the following
    JSON output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Name` 类型的值被序列化为 JSON 字符串（而不是之前的对象）。序列化由 `Name.MarshallJSON` 方法处理，该方法返回一个包含由逗号分隔的姓氏和名字的字节序列数组。前面的代码生成了以下
    JSON 输出：
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: golang.fyi/ch10/json4.go
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json4.go
- en: The `Name` type is an implementation of `json.Unmarshaler`. When the decoder
    encounters a JSON object with the key `"Authors"`, it uses the method `Name.Unmarshaler`
    to reconstitute the Go struct `Name` type from the JSON string.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name` 类型是 `json.Unmarshaler` 的实现。当解码器遇到键为 `"Authors"` 的 JSON 对象时，它使用 `Name.Unmarshaler`
    方法从 JSON 字符串重新构建 Go 结构体 `Name` 类型。'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Go standard libraries offer additional encoders (not covered here) including
    `base32`, `bas364`, `binary`, `csv`, `hex`, `xml`, `gzip`, and numerous encryption
    format encoders.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供了额外的编码器（此处未涵盖），包括 `base32`、`base64`、`binary`、`csv`、`hex`、`xml`、`gzip`
    以及许多加密格式编码器。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provides a high-level view of Go's data input and output idioms
    and the packages involved in implementing IO primitives. The chapter starts by
    covering the fundamentals of a stream-based IO in Go with the `io.Reader` and
    `io.Writer` interfaces. Readers are walked through the implementation strategies
    and examples for both an `io.Reader` and an `io.Writer`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了 Go 的数据输入和输出惯用语的概述以及实现 IO 原语所涉及的包。本章首先介绍了 Go 中基于流的 IO 的基础知识，包括 `io.Reader`
    和 `io.Writer` 接口。读者将了解 `io.Reader` 和 `io.Writer` 的实现策略和示例。
- en: The chapter goes on to cover packages, types, and functions that that support
    the streaming IO mechanism including working with files, formatted IO, buffered,
    and in-memory IO. The last portion of the chapter covers encoders and decoders
    that convert data as it is being streamed. In the next chapter, the IO theme is
    carried further when the discussion turns to creating programs that use IO to
    communicate via networking.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续介绍支持流式IO机制的各种包、类型和函数，包括处理文件、格式化IO、缓冲IO和内存IO。本章的最后部分涵盖了编码器和解码器，它们在数据流传输过程中将数据进行转换。在下一章中，当讨论转向创建使用网络进行通信的程序时，IO主题将进一步展开。
