<html><head></head><body>
<div class="book" title="Pointers" id="TI1E1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Pointer indirection - accessing referenced values"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec79" class="calibre1"/>Pointer indirection - accessing referenced values</h2></div></div></div><p class="calibre10">If all you have is an address, you can access the value to which it points by applying the <code class="email">*</code> operator to the pointer value itself (or dereferencing). The following program illustrates this idea in functions <code class="email">double()</code> and <code class="email">cap()</code>:</p><pre class="programlisting">package main 
import ( 
   "fmt" 
   "strings" 
) 
 
func main() { 
   a := 3 
   double(&amp;a) 
   fmt.Println(a) 
   p := &amp;struct{ first, last string }{"Max", "Planck"} 
   cap(p) 
   fmt.Println(p) 
} 
 
func double(x *int) { 
   *x = *x * 2 
} 
 
func cap(p *struct{ first, last string }) { 
   p.first = strings.ToUpper(p.first) 
   p.last = strings.ToUpper(p.last) 
} 
</pre><p class="calibre10">golang.fyi/ch04/derefptr.go</p><p class="calibre10">In the preceding code, the expression <code class="email">*x = *x * 2</code>, in function <code class="email">double()</code>, can be decomposed as follows to understand how it works:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Expression</strong></span></p>
</td><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Step</strong></span></p>
</td></tr><tr class="calibre21"><td class="calibre22">
<pre class="programlisting1">*x * 2   
</pre>
</td><td class="calibre22">
<p class="calibre23">Original expression where<code class="literal"> x</code> is of type <code class="literal">*int</code>.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<pre class="programlisting1">*(*x) * 2   
</pre>
</td><td class="calibre22">
<p class="calibre23">Dereferencing pointers by applying <code class="literal">* </code>to address values.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<pre class="programlisting1">3 * 2 = 6   
</pre>
</td><td class="calibre22">
<p class="calibre23">Dereferenced value of <code class="literal">*(*x) = 3</code>.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<pre class="programlisting1">*(*x) = 6   
</pre>
</td><td class="calibre22">
<p class="calibre23">The right side of this expression dereferences the value of <code class="literal">x</code>. It is updated with the result 6.</p>
</td></tr></tbody></table></div><p class="calibre10">In function <code class="email">cap()</code>, a similar approach is used to access and update fields in composite variable <code class="email">p</code> of type <code class="email">struct{first, last string}</code>. However, when dealing with composites, the idiom is more forgiving. It is not necessary to write <code class="email">*p.first</code> to access the pointer's field value. We can drop the <code class="email">*</code> and just use <code class="email">p.first = strings.ToUpper(p.first).</code></p></div></div></body></html>