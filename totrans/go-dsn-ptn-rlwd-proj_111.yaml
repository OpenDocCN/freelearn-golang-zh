- en: Pointer indirection - accessing referenced values
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针间接引用 - 访问引用值
- en: 'If all you have is an address, you can access the value to which it points
    by applying the `*` operator to the pointer value itself (or dereferencing). The
    following program illustrates this idea in functions `double()` and `cap()`:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有地址，你可以通过将 `*` 操作符应用于指针值本身（或解引用）来访问它所指向的值。以下程序通过 `double()` 和 `cap()` 函数说明了这个概念：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch04/derefptr.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/derefptr.go
- en: 'In the preceding code, the expression `*x = *x * 2`, in function `double()`,
    can be decomposed as follows to understand how it works:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，函数 `double()` 中的表达式 `*x = *x * 2` 可以分解如下，以了解其工作原理：
- en: '| **Expression** | **Step** |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **步骤** |'
- en: '|'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| Original expression where `x` is of type `*int`. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 原始表达式，其中 `x` 是 `*int` 类型。 |'
- en: '|'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| Dereferencing pointers by applying `*` to address values. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 通过对地址值应用 `*` 来解引用指针。 |'
- en: '|'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| Dereferenced value of `*(*x) = 3`. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `*(*x) = 3` 的解引用值。 |'
- en: '|'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| The right side of this expression dereferences the value of `x`. It is updated
    with the result 6. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 该表达式的右侧解引用了 `x` 的值。它被更新为结果 6。 |'
- en: In function `cap()`, a similar approach is used to access and update fields
    in composite variable `p` of type `struct{first, last string}`. However, when
    dealing with composites, the idiom is more forgiving. It is not necessary to write
    `*p.first` to access the pointer's field value. We can drop the `*` and just use
    `p.first = strings.ToUpper(p.first).`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 `cap()` 中，使用类似的方法来访问和更新复合变量 `p` 的字段，该变量类型为 `struct{first, last string}`。然而，当处理复合变量时，这种表达方式更为宽容。访问指针的字段值时，不需要编写
    `*p.first`。我们可以省略 `*` 并直接使用 `p.first = strings.ToUpper(p.first).`
