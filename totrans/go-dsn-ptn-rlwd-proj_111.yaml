- en: Pointer indirection - accessing referenced values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If all you have is an address, you can access the value to which it points
    by applying the `*` operator to the pointer value itself (or dereferencing). The
    following program illustrates this idea in functions `double()` and `cap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/derefptr.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, the expression `*x = *x * 2`, in function `double()`,
    can be decomposed as follows to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Step** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| Original expression where `x` is of type `*int`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| Dereferencing pointers by applying `*` to address values. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| Dereferenced value of `*(*x) = 3`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| The right side of this expression dereferences the value of `x`. It is updated
    with the result 6. |'
  prefs: []
  type: TYPE_TB
- en: In function `cap()`, a similar approach is used to access and update fields
    in composite variable `p` of type `struct{first, last string}`. However, when
    dealing with composites, the idiom is more forgiving. It is not necessary to write
    `*p.first` to access the pointer's field value. We can drop the `*` and just use
    `p.first = strings.ToUpper(p.first).`
  prefs: []
  type: TYPE_NORMAL
