<html><head></head><body><div class="book" title="Type declaration" id="UGI01-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec28" class="calibre1"/>Type declaration</h1></div></div></div><p class="calibre10">In Go, it is possible to bind a type to an identifier to create a new named type that can be referenced and used wherever the type is needed. Declaring a type takes the general format as follows:</p><p class="calibre10"><span class="strong"><em class="calibre11">type &lt;name identifier&gt; &lt;underlying type name&gt;</em></span></p><p class="calibre10">The type declaration starts with the keyword <code class="email">type</code> followed by a <span class="strong"><em class="calibre11">name identifier </em></span>and the name of an existing <span class="strong"><em class="calibre11">underlying type</em></span>. The underlying type can be a built-in named type such as one of the numeric types, a Boolean, or a string type as shown in the following snippet of type declarations:</p><pre class="programlisting">type truth bool 
type quart float64 
type gallon float64 
type node string 
</pre><div class="informaltable" title="Note"><h3 class="title2"><a id="note5" class="calibre1"/>Note</h3><p class="calibre10">A type declaration can also use a composite <span class="strong"><em class="calibre11">type literal</em></span> as its underlying type. Composite types include array, slice, map, and struct. This section focuses on non-composite types. For further details on composite types, refer to <a class="calibre1" title="Chapter 7. Composite Types" href="part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 7</a>, <span class="strong"><em class="calibre11">Composite Types</em></span>.</p></div><p class="calibre10">The following sample illustrates how named types work in their most basic forms. The code in the example converts temperature values. Each temperature unit is represented by a declared type including <code class="email">fahrenheit</code>, <code class="email">celsius</code>, and <code class="email">kelvin</code>.</p><pre class="programlisting">package main 
import "fmt" 
 
type fahrenheit float64 
type celsius float64 
type kelvin float64 
 
func fharToCel(f fahrenheit) celsius { 
   return celsius((f - 32) * 5 / 9) 
} 
 
func fharToKel(f fahrenheit) celsius { 
   return celsius((f-32)*5/9 + 273.15) 
} 
 
func celToFahr(c celsius) fahrenheit { 
   return fahrenheit(c*5/9 + 32) 
} 
 
func celToKel(c celsius) kelvin { 
   return kelvin(c + 273.15) 
} 
 
func main() { 
   var c celsius = 32.0 
   f := fahrenheit(122) 
   fmt.Printf("%.2f \u00b0C = %.2f \u00b0K\n", c, celToKel(c)) 
   fmt.Printf("%.2f \u00b0F = %.2f \u00b0C\n", f, fharToCel(f)) 
} 
</pre><p class="calibre10">golang.fyi/ch04/typedef.go</p><p class="calibre10">In the preceding code snippet, the new declared types are all based on the underlying built-in numeric type <code class="email">float64</code>. Once the new type has been declared, it can be assigned to variables and participate in expressions just like its underlying type. The newly declared type will have the same zero-value and can be converted to and from its underlying type.</p></div></body></html>