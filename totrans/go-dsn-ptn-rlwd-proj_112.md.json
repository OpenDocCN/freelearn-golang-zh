["```go\ntype truth bool \ntype quart float64 \ntype gallon float64 \ntype node string \n\n```", "```go\npackage main \nimport \"fmt\" \n\ntype fahrenheit float64 \ntype celsius float64 \ntype kelvin float64 \n\nfunc fharToCel(f fahrenheit) celsius { \n   return celsius((f - 32) * 5 / 9) \n} \n\nfunc fharToKel(f fahrenheit) celsius { \n   return celsius((f-32)*5/9 + 273.15) \n} \n\nfunc celToFahr(c celsius) fahrenheit { \n   return fahrenheit(c*5/9 + 32) \n} \n\nfunc celToKel(c celsius) kelvin { \n   return kelvin(c + 273.15) \n} \n\nfunc main() { \n   var c celsius = 32.0 \n   f := fahrenheit(122) \n   fmt.Printf(\"%.2f \\u00b0C = %.2f \\u00b0K\\n\", c, celToKel(c)) \n   fmt.Printf(\"%.2f \\u00b0F = %.2f \\u00b0C\\n\", f, fharToCel(f)) \n} \n\nfloat64. Once the new type has been declared, it can be assigned to variables and participate in expressions just like its underlying type. The newly declared type will have the same zero-value and can be converted to and from its underlying type.\n```"]