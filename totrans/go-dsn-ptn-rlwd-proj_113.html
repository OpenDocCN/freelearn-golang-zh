<html><head></head><body><div class="book" title="Type conversion" id="VF2I1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec29" class="calibre1"/>Type conversion</h1></div></div></div><p class="calibre10">In general, Go considers each type to be different. This means under normal circumstances, values of different types are not fungible in assignment, function parameters, and expression contexts. This is true for built-in and declared types. For instance, the following will cause a build error due to type mismatch:</p><pre class="programlisting">package main 
import "fmt" 
 
type signal int 
 
func main() { 
   var count int32 
   var actual int 
   var test int64 = actual + count 
 
   var sig signal 
   var event int = sig 
 
   fmt.Println(test) 
   fmt.Println(event) 
} 
</pre><p class="calibre10">golang.fyi/ch04/type_conv.go</p><p class="calibre10">The expression <code class="email">actual + count</code> causes a build time error because both variables are of different types. Even though variables <code class="email">actual</code> and <code class="email">count</code> are of numeric types and <code class="email">int32</code> and <code class="email">int</code> have the same memory representation, the compiler still rejects the expression.</p><p class="calibre10">The same is true for declared named types and their underlying types. The compiler will reject assignment <code class="email">var event int = sig</code> because type <code class="email">signal</code> is considered to be different from type <code class="email">int</code>. This is true even though <code class="email">signal</code> uses <code class="email">int</code> as its underlying type.</p><p class="calibre10">To cross type boundaries, Go supports a type conversion expression that converts value from one type to another. Type conversion is done using the following format:</p><p class="calibre10"><span class="strong"><em class="calibre11">&lt;target_type&gt;(&lt;value or expression&gt;)</em></span></p><p class="calibre10">The following code snippet fixes the previous example by converting the variables to the proper types:</p><pre class="programlisting">type signal int 
func main() { 
   var count int32 
   var actual int 
   var test int32 = int32(actual) + count 
 
   var sig signal 
   var event int = int(sig) 
} 
</pre><p class="calibre10">golang.fyi/ch04/type_conv2.go</p><p class="calibre10">Note that in the previous snippet assignment expression <code class="email">var test int32 = int32(actual) + count</code> converts variable <code class="email">actual</code> to the proper type to match the rest of the expression. Similarly, expression <code class="email">var event int = int(sig)</code> converts variable <code class="email">sig</code> to match the target type <code class="email">int</code> in the assignment.</p><p class="calibre10">The conversion expressions satisfy the assignment by explicitly changing the type of the enclosing values. Obviously, not all types can be converted from one to another. The following table summarizes common scenarios when type conversion is appropriate and allowed:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Description</strong></span></p>
</td><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Code</strong></span></p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">The target type and converted value are both simple numeric types.</p>
</td><td class="calibre22">
<pre class="programlisting1">var i int   
var i2 int32 = int32(i)   
var re float64 = float64(i +   int(i2))   
</pre>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">The target type and the converted value are both complex numeric types.</p>
</td><td class="calibre22">
<pre class="programlisting1">var cn64 complex64   
var cn128 complex128 =   complex128(cn64)   
</pre>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">The target type and converted value have the same underlying types.</p>
</td><td class="calibre22">
<pre class="programlisting1">type signal int   
var sig signal   
var event int = int(sig)   
</pre>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">The target type is a string and the converted value is a valid integer type.</p>
</td><td class="calibre22">
<pre class="programlisting1">a := string(72)   
b := string(int32(101))   
c := string(rune(108))   
</pre>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">The target type is string and the converted value is a slice of bytes, int32, or runes.</p>
</td><td class="calibre22">
<pre class="programlisting1">msg0 := string([]byte{'H','i'})   
msg1 := string([]rune{'Y','o','u','!'})   
</pre>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">The target type is a slice of byte, int32, or rune values and the converted value is a string.</p>
</td><td class="calibre22">
<pre class="programlisting1">data0 := []byte("Hello")   
data0 := []int32("World!")   
</pre>
</td></tr></tbody></table></div><p class="calibre10">Additionally, the conversion rules also work when the target type and converted value are pointers that reference the same types. Besides these scenarios in the previous table, Go types cannot be explicitly converted. Any attempt to do so will result in a compilation error.</p></div></body></html>