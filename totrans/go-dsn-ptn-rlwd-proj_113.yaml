- en: Type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, Go considers each type to be different. This means under normal
    circumstances, values of different types are not fungible in assignment, function
    parameters, and expression contexts. This is true for built-in and declared types.
    For instance, the following will cause a build error due to type mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/type_conv.go
  prefs: []
  type: TYPE_NORMAL
- en: The expression `actual + count` causes a build time error because both variables
    are of different types. Even though variables `actual` and `count` are of numeric
    types and `int32` and `int` have the same memory representation, the compiler
    still rejects the expression.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for declared named types and their underlying types. The compiler
    will reject assignment `var event int = sig` because type `signal` is considered
    to be different from type `int`. This is true even though `signal` uses `int`
    as its underlying type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cross type boundaries, Go supports a type conversion expression that converts
    value from one type to another. Type conversion is done using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<target_type>(<value or expression>)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet fixes the previous example by converting the variables
    to the proper types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion expressions satisfy the assignment by explicitly changing the
    type of the enclosing values. Obviously, not all types can be converted from one
    to another. The following table summarizes common scenarios when type conversion
    is appropriate and allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **Code** |'
  prefs: []
  type: TYPE_TB
- en: '| The target type and converted value are both simple numeric types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type and the converted value are both complex numeric types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type and converted value have the same underlying types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type is a string and the converted value is a valid integer type.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type is string and the converted value is a slice of bytes, int32,
    or runes. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The target type is a slice of byte, int32, or rune values and the converted
    value is a string. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the conversion rules also work when the target type and converted
    value are pointers that reference the same types. Besides these scenarios in the
    previous table, Go types cannot be explicitly converted. Any attempt to do so
    will result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
