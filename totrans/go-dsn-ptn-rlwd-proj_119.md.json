["```go\npackage main \nimport \"fmt\" \n\nfunc avg(nums ...float64) float64 { \n   n := len(nums) \n   t := 0.0 \n   for _, v := range nums { \n         t += v \n   } \n   return t / float64(n) \n} \n\nfunc sum(nums ...float64) float64 { \n   var sum float64 \n   for _, v := range nums { \n         sum += v \n   } \n   return sum \n} \n\nfunc main() { \n   fmt.Printf(\"avg([1, 2.5, 3.75]) =%.2f\\n\", avg(1, 2.5, 3.75)) \n   points := []float64{9, 4, 3.7, 7.1, 7.9, 9.2, 10} \n   fmt.Printf(\"sum(%v) = %.2f\\n\", points, sum(points...)) \n} \n\nWhen no parameters are provided, the function receives an empty slice. The astute reader may be wondering, \"Is it possible to pass in an existing slice of values as variadic arguments?\" Thankfully, Go provides an easy idiom to handle such a case. Let's examine the call to the Â `sum` function in the following code snippet:\n\n```", "```go\n\nA slice of floating-point values is declared and stored in variable `points`. The slice can be passed as a variadic parameter by adding ellipses to the parameter in the `sum(points...)` function call.\n```"]