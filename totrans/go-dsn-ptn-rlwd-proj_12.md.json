["```go\nfunc Dial(network, address string) (Conn, error) \n\n\"tcp\" network at the host address, www.gutenberg.org:80, which returns a TCP connection of the *net.TCPConn type. The abbreviated code uses the TCP connection to issue an \"HTTP GET\" request to retrieve the full text of the literary classic Beowulf from the Project Gutenberg's website (http://gutenberg.org/). The raw and unparsed HTTP response is subsequently written to a local file, beowulf.txt:\n```", "```go\nfunc main() { \n   host, port := \"www.gutenberg.org\", \"80\" \n   addr := net.JoinHostPort(host, port) \n   httpRequest:=\"GET  /cache/epub/16328/pg16328.txt HTTP/1.1\\n\" + \n         \"Host: \" + host + \"\\n\\n\" \n\n   conn, err := net.Dial(\"tcp\", addr) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer conn.Close() \n\n   if _, err = conn.Write([]byte(httpRequest)); err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   file, err := os.Create(\"beowulf.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer file.Close() \n\n   io.Copy(file, conn) \n   fmt.Println(\"Text copied to file\", file.Name()) \n}\n\n```", "```go\nfunc Listen(network, laddr string) (net.Listener, error) \n\n```", "```go\nfunc main() { \n   listener, err := net.Listen(\"tcp\", \":4040\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer listener.Close() \n\n   for { \n         conn, err := listener.Accept() \n         if err != nil { \n               fmt.Println(err) \n               return \n         } \n         conn.Write([]byte(\"Nice to meet you!\")) \n         conn.Close() \n   } \n} \n\n```", "```go\n$> go run listen0.go & \n[1] 83884 \n\n$> telnet 127.0.0.1 4040 \nTrying 127.0.0.1... \nConnected to localhost. \nEscape character is '^]'. \nNice to meet you! Connection closed by foreign host.\n\n```", "```go\nimport ( \n   \"net\" \n   ... \n   curr \"https://github.com/vladimirvivien/learning-go/ch11/curr0\" \n) \n\nvar currencies = curr.Load(\"./data.csv\") \n\nfunc main() { \n   ln, _ := net.Listen(\"tcp\", \":4040\") \n   defer ln.Close() \n\n   // connection loop \n   for { \n         conn, err := ln.Accept() \n         if err != nil { \n               fmt.Println(err) \n               conn.Close() \n               continue \n         }      \n         go handleConnection(conn) \n   } \n} \n\n// handle client connection \nfunc handleConnection(conn net.Conn) { \n   defer conn.Close() \n\n   // loop to stay connected with client \n   for { \n         cmdLine := make([]byte, (1024 * 4)) \n         n, err := conn.Read(cmdLine) \n         if n == 0 || err != nil { \n               return \n         } \n         cmd, param := parseCommand(string(cmdLine[0:n])) \n         if cmd == \"\" { \n               continue \n         } \n\n         // execute command \n         switch strings.ToUpper(cmd) { \n         case \"GET\": \n               result := curr.Find(currencies, param) \n               // stream result to client \n               for _, cur := range result { \n                     _, err := fmt.Fprintf( \n                           conn, \n                           \"%s %s %s %s\\n\", \n                           cur.Name, cur.Code, \n                           cur.Number, cur.Country, \n                     ) \n                     if err != nil { \n                           return \n                     } \n                     // reset deadline while writing, \n                     // closes conn if client is gone \n                     conn.SetWriteDeadline( \n                           time.Now().Add(time.Second * 5)) \n               } \n               // reset read deadline for next read \n               conn.SetReadDeadline( \n                     time.Now().Add(time.Second * 300)) \n\n         default: \n               conn.Write([]byte(\"Invalid command\\n\")) \n         } \n   } \n} \n\nfunc parseCommand(cmdLine string) (cmd, param string) { \n   parts := strings.Split(cmdLine, \" \") \n   if len(parts) != 2 { \n         return \"\", \"\" \n   } \n   cmd = strings.TrimSpace(parts[0]) \n   param = strings.TrimSpace(parts[1]) \n   return \n} \n\n```", "```go\n$> telnet localhost 4040\nTrying ::1...\nConnected to localhost.\nEscape character is '^]'.\nGET Gourde\nGourde HTG 332 HAITI\nGET USD\nUS Dollar USD 840 AMERICAN SAMOA\nUS Dollar USD 840 BONAIRE, SINT EUSTATIUS AND SABA\nUS Dollar USD 840 GUAM\nUS Dollar USD 840 HAITI\nUS Dollar USD 840 MARSHALL ISLANDS (THE)\nUS Dollar USD 840 UNITED STATES OF AMERICA (THE)\n...\nget india\nIndian Rupee INR 356 BHUTAN\nUS Dollar USD 840 BRITISH INDIAN OCEAN TERRITORY (THE)\nIndian Rupee INR 356 INDIA\n\n```", "```go\ngolang.fyi/ch11/tcpclient0.goThe source code for the Go client follows the same pattern as we have seen in the earlier client example. The first portion of the code dials out to the server using `net.Dial()`. Once a connection is obtained, the code sets up an event loop to capture text commands from the standard input, parses it, and sends it as a request to the server.There is a nested loop that is set up to handle incoming responses from the server (see code comment). It continuously streams incoming bytes into variablesÂ `buff` with `conn.Read(buff)`. This continues until the `Read` method encounters an error. The following lists the sample output produced by the client when it is executed:\n\n```", "```go\n\n```", "```go\n\ngolang.fyi/ch11/tcpclient1.goAs you can see, writing networked services directly on top of raw TCP has some costs. While raw TCP gives the programmer complete control of the application-level protocol, it also requires the programmer to carefully handle all data processing which can be error-prone. Unless it is absolutely necessary to implement your own custom protocol, a better approach is to leverage an existing and proven protocols to implement your server programs. The remainder of this chapter continues to explore this topic using services that are based on HTTP as an application-level protocol.\n```", "```go\nfunc main() { \n   client := http.Client{} \n   resp, err := client.Get( \n         \" http://gutenberg.org/cache/epub/16328/pg16328.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\n```", "```go\nGet(url string,   \n) (resp *http.Response, err   error)     \n\n```", "```go\nPost(   \n  url string,    \n  bodyType string,    \n  body io.Reader,   \n) (resp *http.Response, err error)   \n\n```", "```go\nPostForm(   \n  url string,    \n  data url.Values,   \n) (resp *http.Response, err error)   \n\n```", "```go\nHead(url string,   \n)(resp *http.Response, err error)   \n\n```", "```go\nfunc main() { \n   resp, err := http.Get( \n       \"http://gutenberg.org/cache/epub/16328/pg16328.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\n```", "```go\nTimeout attribute of the Client type:\n```", "```go\nfunc main() { \n   client := &http.Client{ \n         Timeout: 21 * time.Second \n   } \n   resp, err := client.Get( \n         \"http://tools.ietf.org/rfc/rfc7540.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\nDisableKeepAlive field. The code also uses the Dial function to specify further granular control over the HTTP connection used by the underlying client, setting its timeout value to 30 seconds:\n```", "```go\nfunc main() { \n   client := &http.Client{ \n         Transport: &http.Transport{ \n               DisableKeepAlives: true, \n               Dial: (&net.Dialer{ \n                  Timeout:   30 * time.Second, \n               }).Dial, \n         }, \n   } \n... \n} \n\n```", "```go\nhttp.Request type to create a new request which is used to specify the headers sent to the server:\n```", "```go\nfunc main() { \n   client := &http.Client{} \n   req, err := http.NewRequest( \n         \"GET\", \"http://tools.ietf.org/rfc/rfc7540.txt\", nil, \n   ) \n   req.Header.Add(\"Accept\", \"text/plain\") \n   req.Header.Add(\"User-Agent\", \"SampleClient/1.0\") \n\n   resp, err := client.Do(req) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\n```", "```go\nfunc NewRequest(method, uStr string, body io.Reader) (*http.Request, error) \n\nDo method of the http.Client type and has the following signature:\n```", "```go\nDo(req *http.Request) (*http.Response, error) \n\n```", "```go\ntype Handler interface { \n        ServeHTTP(ResponseWriter, *Request) \n} \n\nmsg type as handler registered to handle incoming client requests:\n```", "```go\ntype msg string \n\nfunc (m msg) ServeHTTP( \n   resp http.ResponseWriter, req *http.Request) { \n   resp.Header().Add(\"Content-Type\", \"text/html\") \n   resp.WriteHeader(http.StatusOK) \n   fmt.Fprint(resp, m) \n} \n\nfunc main() { \n   msgHandler := msg(\"Hello from high above!\") \n   server := http.Server{Addr: \":4040\", Handler: msgHandler} \n   server.ListenAndServe() \n} \n\n```", "```go\ntype msg string \nfunc (m msg) ServeHTTP( \n   resp http.ResponseWriter, req *http.Request) { \n   resp.Header().Add(\"Content-Type\", \"text/html\") \n   resp.WriteHeader(http.StatusOK) \n   fmt.Fprint(resp, m) \n} \nfunc main() { \n   msgHandler := msg(\"Hello from high above!\") \n   server := http.Server{ \n         Addr:         \":4040\", \n         Handler:      msgHandler, \n         ReadTimeout:  time.Second * 5, \n         WriteTimeout: time.Second * 3, \n   } \n   server.ListenAndServe() \n} \n\n```", "```go\ntype msg string \n\nfunc (m msg) ServeHTTP( \n    resp http.ResponseWriter, req *http.Request) { \n   resp.Header().Add(\"Content-Type\", \"text/html\") \n   resp.WriteHeader(http.StatusOK) \n   fmt.Fprint(resp, m) \n} \n\n   func main() { \n   msgHandler := msg(\"Hello from high above!\") \n   http.ListenAndServe(\":4040\", msgHandler) \n} \n\n```", "```go\nhttp.ServeMux variable mux configured to handle two URL paths \"/hello\" and \"/goodbye\":\n```", "```go\nfunc main() { \n   mux := http.NewServeMux() \n   hello := func(resp http.ResponseWriter, req *http.Request) { \n         resp.Header().Add(\"Content-Type\", \"text/html\") \n         resp.WriteHeader(http.StatusOK) \n         fmt.Fprint(resp, \"Hello from Above!\") \n   } \n\n   goodbye := func(resp http.ResponseWriter, req *http.Request) { \n         resp.Header().Add(\"Content-Type\", \"text/html\") \n         resp.WriteHeader(http.StatusOK) \n         fmt.Fprint(resp, \"Goodbye, it's been real!\") \n   } \n\n   mux.HandleFunc(\"/hello\", hello) \n   mux.HandleFunc(\"/goodbye\", goodbye) \n\n   http.ListenAndServe(\":4040\", mux) \n} \n\n```", "```go\nfunc main() { \n   hello := func(resp http.ResponseWriter, req *http.Request) { \n   ... \n   } \n\n   goodbye := func(resp http.ResponseWriter, req *http.Request) { \n   ... \n   } \n\n   http.HandleFunc(\"/hello\", hello) \n   http.HandleFunc(\"/goodbye\", goodbye) \n\n   http.ListenAndServe(\":4040\", nil) \n}\n\n```", "```go\ntype Currency struct { \n   Code    string `json:\"currency_code\"` \n   Name    string `json:\"currency_name\"` \n   Number  string `json:\"currency_number\"` \n   Country string `json:\"currency_country\"` \n} \n\ntype CurrencyRequest struct { \n   Get   string `json:\"get\"` \n   Limit int    `json:limit` \n} \n\n```", "```go\nimport ( \n   \"encoding/json\" \n   \"fmt\" \n   \"net/http\" \n\n   \" github.com/vladimirvivien/learning-go/ch11/curr1\" \n) \nvar currencies = curr1.Load(\"./data.csv\") \n\nfunc currs(resp http.ResponseWriter, req *http.Request) { \n   var currRequest curr1.CurrencyRequest \n   dec := json.NewDecoder(req.Body) \n   if err := dec.Decode(&currRequest); err != nil { \n         resp.WriteHeader(http.StatusBadRequest) \n         fmt.Println(err) \n         return \n   } \n\n   result := curr1.Find(currencies, currRequest.Get) \n   enc := json.NewEncoder(resp) \n   if err := enc.Encode(&result); err != nil { \n         fmt.Println(err) \n         resp.WriteHeader(http.StatusInternalServerError) \n         return \n   } \n} \n\nfunc main() { \n   mux := http.NewServeMux() \n   mux.HandleFunc(\"/currency\", get) \n\n   if err := http.ListenAndServe(\":4040\", mux); err != nil { \n         fmt.Println(err) \n   } \n} \n\n```", "```go\nvar currRequest curr1.CurrencyRequest \ndec := json.NewDecoder(req.Body) \nif err := dec.Decode(&currRequest); err != nil { ... } \n\n```", "```go\nresult := curr1.Find(currencies, currRequest.Get) \nenc := json.NewEncoder(resp) \nif err := enc.Encode(&result); err != nil { ... } \n\n```", "```go\n$> curl -X POST -d '{\"get\":\"Euro\"}' http://localhost:4040/currency \n[ \n... \n  { \n    \"currency_code\": \"EUR\", \n    \"currency_name\": \"Euro\", \n    \"currency_number\": \"978\", \n    \"currency_country\": \"BELGIUM\" \n  }, \n  { \n    \"currency_code\": \"EUR\", \n    \"currency_name\": \"Euro\", \n    \"currency_number\": \"978\", \n    \"currency_country\": \"FINLAND\" \n  }, \n  { \n    \"currency_code\": \"EUR\", \n    \"currency_name\": \"Euro\", \n    \"currency_number\": \"978\", \n    \"currency_country\": \"FRANCE\" \n  }, \n... \n] \n\n```", "```go\nhttp.Client type to communicate with the server. It also uses the encoding/json sub-package to decode incoming data (note that the client also makes use of the curr1 package, shown earlier, which contains the types needed to communicate with the server):\n```", "```go\nimport ( \n   \"bytes\" \n   \"encoding/json\" \n   \"fmt\" \n   \"net/http\" \n\n   \" github.com/vladimirvivien/learning-go/ch11/curr1\" \n) \n\nfunc main() { \n   var param string \n   fmt.Print(\"Currency> \") \n   _, err := fmt.Scanf(\"%s\", &param) \n\n   buf := new(bytes.Buffer) \n   currRequest := &curr1.CurrencyRequest{Get: param} \n   err = json.NewEncoder(buf).Encode(currRequest) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   // send request \n   client := &http.Client{} \n   req, err := http.NewRequest( \n         \"POST\", \"http://127.0.0.1:4040/currency\", buf) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   resp, err := client.Do(req) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n\n   // decode response \n   var currencies []curr1.Currency \n   err = json.NewDecoder(resp.Body).Decode(&currencies) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   fmt.Println(currencies) \n} \n\n```", "```go\n// serves HTML gui \nfunc gui(resp http.ResponseWriter, req *http.Request) { \n   file, err := os.Open(\"./currency.html\") \n   if err != nil { \n         resp.WriteHeader(http.StatusInternalServerError) \n         fmt.Println(err) \n         return \n   } \n   io.Copy(resp, file) \n} \n\nfunc main() { \n   mux := http.NewServeMux() \n   mux.HandleFunc(\"/\", gui) \n   mux.HandleFunc(\"/currency\", currs) \n\n   if err := http.ListenAndServe(\":4040\", mux); err != nil { \n         fmt.Println(err) \n   } \n} \n\ngui handler function responsible for serving a static HTML file that renders the GUI for the client. The root URL path is then mapped to the function with mux.HandleFunc(\"/\", gui). So, in addition to the \"/currency\" path, which hosts the API end-point the \"/\" path will return the web page shown in the following screenshot:\n```", "```go\n<body> \n<div class=\"container\"> \n  <h2>Global Currency Service</h2> \n  <p>Enter currency search string: <input id=\"in\"> \n     <button type=\"button\" class=\"btn btn-primary\" onclick=\"doRequest()\">Search</button> \n  </p>             \n  <table id=\"tbl\" class=\"table table-striped\"> \n    <thead> \n      <tr> \n           <th>Code</th> \n           <th>Name</th> \n           <th>Number</th> \n           <th>Country</th> \n      </tr> \n    </thead> \n    <tbody/> \n  </table> \n</div> \n\n<script> \n var tbl = document.getElementById(\"tbl\"); \n   function addRow(code, name, number, country) { \n         var rowCount = tbl.rows.length; \n         var row = tbl.insertRow(rowCount); \n         row.insertCell(0).innerHTML = code; \n         row.insertCell(1).innerHTML = name; \n         row.insertCell(2).innerHTML = number; \n         row.insertCell(3).innerHTML = country; \n   } \n\n    function doRequest() { \n   param = document.getElementById(\"in\").value \n        $.ajax('/currency', { \n            method: 'PUT', \n               contentType: 'application/json', \n               processData: false, \n               data: JSON.stringify({get:param}) \n         }).then( \n         function success(currencies) { \n               currs = JSON.parse(currencies) \n               for (i=0; i < currs.length; i++) { \n                     addRow( \n                           currs[i].currency_code, \n                           currs[i].currency_name, \n                           currs[i].currency_number, \n                           currs[i].currency_country \n                     ); \n               } \n\n         }); \n   } \n</script> \n\n```"]