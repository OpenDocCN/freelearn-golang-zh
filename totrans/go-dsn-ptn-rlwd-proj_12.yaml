- en: Chapter 11. Writing Networked Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。编写网络服务
- en: 'One of the many reasons for Go''s popularity, as a system language, is its
    inherent support for creating networked programs. The standard library exposes
    APIs ranging from low-level socket primitives to higher-level service abstractions
    such as HTTP and RPC. This chapter explores fundamental topics about creating
    connected applications including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 作为系统语言广受欢迎的许多原因之一是其创建网络程序的内建支持。标准库公开了从低级套接字原语到高级服务抽象（如 HTTP 和 RPC）的 API。本章探讨了创建连接应用程序的基本主题，包括以下内容：
- en: The net package
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net` 包'
- en: A TCP API server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP API 服务器
- en: The HTTP package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 包
- en: A JSON API server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON API 服务器
- en: The net package
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`net` 包'
- en: The starting point for all networked programs in Go is the *net* package ([https://golang.org/pkg/net](https://golang.org/pkg/net)).
    It provides a rich API to handle low-level networking primitives as well as application-level
    protocols such as HTTP. Each logical component of a network is represented by
    a Go type including hardware interfaces, networks, packets, addresses, protocols,
    and connections. Furthermore, each type exposes a multitude of methods giving
    Go one of the most complete standard libraries for network programming supporting
    both IPv4 and IPv6.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中所有网络程序的起点是 *net* 包 ([https://golang.org/pkg/net](https://golang.org/pkg/net))。它提供了一套丰富的
    API，用于处理低级网络原语以及应用层协议，如 HTTP。网络中的每个逻辑组件都由一个 Go 类型表示，包括硬件接口、网络、数据包、地址、协议和连接。此外，每个类型都公开了大量的方法，使
    Go 拥有支持 IPv4 和 IPv6 的最完整的标准库之一，用于网络编程。
- en: Whether creating a client or a server program, Go programmers will need, at
    a minimum, the network primitives covered in the following sections. These primitives
    are offered as functions and types to facilitate clients connecting to remote
    services and servers to handle incoming requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论创建客户端还是服务器程序，Go 程序员至少需要以下章节中涵盖的网络原语。这些原语作为函数和类型提供，以方便客户端连接到远程服务以及服务器处理传入请求。
- en: Addressing
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址解析
- en: One of the basic primitives, when doing network programming, is the *address*.
    The types and functions of the `net` package use a string literal to represent
    an address such as `"127.0.0.1"`. The address can also include a service port
    separated by a colon such as `"74.125.21.113:80"`. Functions and methods in the
    `net` package also support string literal representation for IPv6 addresses such
    as `"::1"` or `"[2607:f8b0:4002:c06::65]:80"` for an address with a service port
    of 80.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行网络编程时，一个基本原语是 *地址*。`net` 包的类型和函数使用字符串字面量来表示地址，例如 `"127.0.0.1"`。地址还可以包括由冒号分隔的服务端口，例如
    `"74.125.21.113:80"`。`net` 包中的函数和方法还支持 IPv6 地址的字符串字面量表示，例如 `"::1"` 或 `"[2607:f8b0:4002:c06::65]:80"`，其中地址的服务端口为
    80。
- en: The net.Conn Type
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`net.Conn` 类型'
- en: The `net.Conn` interface represents a generic connection established between
    two nodes on the network. It implements `io.Reader` and `io.Writer` interfaces
    which allow connected nodes to exchange data using streaming IO primitives. The
    `net` package offers network protocol-specific implementations of the `net.Conn`
    interface such as *IPConn*, *UDPConn*, and *TCPConn*. Each implementation exposes
    additional methods specific to its respective network and protocol. However, as
    we will see in this chapter, the default method set defined in net.Conn is adequate
    for most uses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Conn` 接口表示网络中两个节点之间建立的通用连接。它实现了 `io.Reader` 和 `io.Writer` 接口，允许连接的节点使用流式
    I/O 原语交换数据。`net` 包提供了针对 `net.Conn` 接口的特定网络协议实现，例如 *IPConn*、*UDPConn* 和 *TCPConn*。每个实现都公开了其各自网络和协议特有的额外方法。然而，正如我们将在本章中看到的，`net.Conn`
    中定义的默认方法集对于大多数用途来说是足够的。'
- en: Dialing a connection
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立连接
- en: 'Client programs use the `net.Dial` function, which has the following signature, to
    connect to a host service over the network:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序使用 `net.Dial` 函数连接到网络上的主机服务，该函数具有以下签名：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch11/dial0.go
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/dial0.go
- en: Because the `net.Conn` type implements the `io.Reader` and `io.Writer`, it can
    be used to both send data and receive data using streaming IO semantics. In the
    preceding example, `conn.Write([]byte(httpRequest))` sends the HTTP request to
    the server. The response returned by the host is copied from the `conn` variable
    to the `file` variable using `io.Copy(file, conn)`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `net.Conn` 类型实现了 `io.Reader` 和 `io.Writer`，它可以用来发送和接收数据，使用流式 I/O 语义。在先前的示例中，`conn.Write([]byte(httpRequest))`
    将 HTTP 请求发送到服务器。主机返回的响应通过 `io.Copy(file, conn)` 从 `conn` 变量复制到 `file` 变量。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the previous is an illustration that shows how to connect to an HTTP
    server using raw TCP. The Go standard library provides a separate package designed
    specifically for HTTP programming which abstracts away the low-level protocol
    details (covered later in the chapter).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的示例展示了如何使用原始 TCP 连接到 HTTP 服务器。Go 标准库提供了一个专门为 HTTP 编程设计的独立包，该包抽象了低级协议细节（将在本章后面介绍）。
- en: The `net` package also makes available network specific dialing functions such
    as `DialUDP`, `DiapTCP`, or `DialIP`, each returning its respective connection
    implementation. In most cases, the `net.Dial` function and the `net.Conn` interface
    provide adequate capabilities to connect and manage connections to a remote host.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`net` 包还提供了网络特定的拨号函数，如 `DialUDP`、`DiapTCP` 或 `DialIP`，每个都返回其相应的连接实现。在大多数情况下，`net.Dial`
    函数和 `net.Conn` 接口提供了连接和管理远程主机连接的足够功能。'
- en: Listening for incoming connections
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听传入连接
- en: 'When creating a service program, one the first steps is to announce the port
    which the service will use to listen for incoming requests from the network. This
    is done by invoking the `net.Listen` function which has the following signature:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务程序时，第一步是宣布服务将使用的端口号，以便监听来自网络的传入请求。这是通过调用 `net.Listen` 函数来完成的，该函数具有以下签名：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It takes two parameters where the first parameter specifies a protocol with
    valid values of `"tcp"`, `"tcp4"`, `"tcp6"`, `"unix"`, or `"unixpacket"`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两个参数，其中第一个参数指定一个协议，有效值为 `"tcp"`、`"tcp4"`、`"tcp6"`、`"unix"` 或 `"unixpacket"`。
- en: The second parameter is the local host address for the service. The local address
    can be specified without an IP address such as `":4040"`. Omitting the IP address
    of the host means that the service is bound to all network card interfaces installed
    on the host. As an alternative, the service can be bound to a specific network
    hardware interface on the host by specifying its IP address on the network, that
    is, `"10.20.130.240:4040"`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是服务的本地主机地址。本地地址可以指定为没有 IP 地址，例如 `":4040"`。省略主机 IP 地址意味着服务绑定到主机上安装的所有网络接口卡。作为替代，可以通过指定网络上的
    IP 地址将服务绑定到主机上的特定网络硬件接口，即 `"10.20.130.240:4040"`。
- en: A successful call to the `net.Listen` function returns a value of the `net.Listener`
    type (or a non-nil error if it fails). The `net.Listener` interface exposes methods
    used to manage the life cycle of incoming client connections. Depending on the
    value of the `network` parameter (`"tcp"`, `"tcp4"`, `"tcp6"`, and so on.), `net.Listen`
    will return either a `net.TCPListener` or `net.UnixListener` *,* both of which
    are concrete implementations of the `net.Listener` interface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用 `net.Listen` 函数返回 `net.Listener` 类型的值（如果失败，则返回非空错误）。`net.Listener` 接口公开用于管理传入客户端连接生命周期的方法。根据
    `network` 参数的值（`"tcp"`、`"tcp4"`、`"tcp6"` 等），`net.Listen` 将返回 `net.TCPListener`
    或 `net.UnixListener`，两者都是 `net.Listener` 接口的具体实现。
- en: Accepting client connections
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受客户端连接
- en: 'The `net.Listener` interface uses the *Accept* method to block indefinitely
    until a new connection arrives from a client. The following abbreviated code snippet
    shows a simple server that returns the string "Nice to meet you!" to each client
    connection and then disconnects immediately:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Listener` 接口使用 `*Accept*` 方法无限期地阻塞，直到从客户端收到新的连接。以下简化的代码片段展示了简单的服务器，它向每个客户端连接返回字符串
    "很高兴见到你！" 然后立即断开连接：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch11/listen0.go
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/listen0.go
- en: 'In the code, the `listener.Accept` method returns a value of the `net.Conn`
    type to handle data exchange between the server and the client (or it returns
    a non-nil `error` if it fails). The `conn.Write([]byte("Nice to meet you!"))`
    method call is used to write the response to the client. When the server program
    is running, it can be tested using a *telnet* client as shown in the following
    output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，`listener.Accept` 方法返回 `net.Conn` 类型的值以处理服务器和客户端之间的数据交换（如果失败，则返回非空错误）。`conn.Write([]byte("Nice
    to meet you!"))` 方法调用用于向客户端写入响应。当服务器程序运行时，可以使用以下输出中的 *telnet* 客户端进行测试：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To ensure that the server program continues to run and handle subsequent client
    connections, the call to the `Accept` method is wrapped within an infinite for-loop.
    As soon as a connection is closed, the loop restarts the cycle to wait for the
    next client connection. Also notice that it is a good practice to close the listener
    when the server process is shutting down with a call to `Listener.Close()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保服务器程序持续运行并处理后续的客户端连接，`Accept`方法的调用被包裹在一个无限循环中。一旦连接关闭，循环将重新启动周期以等待下一个客户端连接。同时请注意，在服务器进程关闭时，通过调用`Listener.Close()`关闭监听器是一个好的实践。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The observant reader may notice that this simple server will not scale as it
    cannot handle more than one client request at once. In the next section, we will
    see the techniques for creating a scalable server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者可能会注意到这个简单的服务器无法扩展，因为它不能同时处理多个客户端请求。在下一节中，我们将看到创建可扩展服务器的技术。
- en: A TCP API server
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP API服务器
- en: At this point, the chapter has covered the minimum networking components necessary
    to create client and service programs. The remainder of the chapter will discuss
    different versions of a server that implement a *monetary currency information*
    service. The service returns ISO 4217 monetary currency information with each
    request. The intent is to show the implications of creating networked services,
    along with their clients, using different application-level protocols.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经涵盖了创建客户端和服务程序所需的最基本的网络组件。本章的剩余部分将讨论实现*货币信息*服务的服务器不同版本。该服务在每个请求中返回ISO
    4217货币信息。目的是展示使用不同的应用层协议创建网络服务和它们的客户端的后果。
- en: 'Earlier we introduced a very simple server to demonstrate the necessary steps
    required to set up a networked service. This section dives deeper into network
    programming by creating a TCP server that scales to handle many concurrent connections.
    The server code presented in this section has the following design goals:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们介绍了一个非常简单的服务器来演示设置网络服务所需的必要步骤。本节通过创建一个可以扩展以处理多个并发连接的TCP服务器来深入探讨网络编程。本节中展示的服务器代码有以下设计目标：
- en: Use raw TCP to communicate between client and server
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始TCP在客户端和服务器之间进行通信
- en: Develop a simple text-based protocol, over TCP, for communication
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基于TCP的简单文本协议，用于通信
- en: Clients can query the server for global currency information with text commands
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以使用文本命令查询服务器的全局货币信息
- en: Use a goroutine per connection to handle connection concurrency
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用每个连接一个goroutine来处理连接并发
- en: Maintain connection until the client disconnects
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维持连接直到客户端断开
- en: The following lists an abbreviated version of the server code. The program uses
    the `curr` package (found at [https://github.com/vladimirvivien/learning-go/ch11/curr0](https://github.com/vladimirvivien/learning-go/ch11/curr0)),
    not discussed here, to load monetary currency data from a local CSV file into
    slice `currencies`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了服务器代码的简略版本。程序使用`curr`包（位于[https://github.com/vladimirvivien/learning-go/ch11/curr0](https://github.com/vladimirvivien/learning-go/ch11/curr0)），此处未讨论，用于从本地CSV文件中加载货币数据到切片`currencies`。
- en: 'Upon successful connection to a client, the server parses the incoming client
    commands specified with a simple text protocol with the format *GET <currency-filter-value>*
    where *<currency-filter-value>* specifies a string value used to search for currency
    information:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功连接到客户端后，服务器使用简单的文本协议解析传入的客户端命令，格式为*GET <currency-filter-value>*，其中*<currency-filter-value>*指定一个字符串值，用于搜索货币信息：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch11/tcpserv0.go
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/tcpserv0.go
- en: Unlike the simple server introduced in the last section, this server is able
    to service multiple client connections at the same time. Upon accepting a new
    connection, with `ln.Accept()`, it delegates the handling of new client connections
    to a goroutine with `go handleConnection(conn)`. The connection loop then continues
    immediately and waits for the next client connection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中介绍的简单服务器不同，这个服务器能够同时服务多个客户端连接。在通过`ln.Accept()`接受新的连接后，它将新客户端连接的处理委托给一个goroutine，使用`go
    handleConnection(conn)`。然后连接循环立即继续并等待下一个客户端连接。
- en: The `handleConnection` function manages the server communication with the connected
    client. It first reads and parses a slice of bytes, from the client, into a command
    string using `cmd, param := parseCommand(string(cmdLine[0:n]))`. Next, the code
    tests the command with a `switch` statement. If the `cmd` is equal to `"GET"`,
    the code searches slice `currencies` for values that matches `param` with a call
    to `curr.Find(currencies, param)`. Finally, it streams the search result to the
    client's connection using `fmt.Fprintf(conn, "%s %s %s %s\n", cur.Name, cur.Code,
    cur.Number, cur.Country)`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleConnection` 函数管理服务器与连接客户端的通信。它首先使用 `cmd, param := parseCommand(string(cmdLine[0:n]))`
    读取并解析从客户端接收的字节数组到命令字符串。接下来，代码使用 `switch` 语句测试命令。如果 `cmd` 等于 `"GET"`，代码通过调用 `curr.Find(currencies,
    param)` 在 `currencies` 切片中搜索与 `param` 匹配的值。最后，它使用 `fmt.Fprintf(conn, "%s %s %s
    %s\n", cur.Name, cur.Code, cur.Number, cur.Country)` 将搜索结果流式传输到客户端的连接。'
- en: The simple text protocol supported by the server does not include any sort of
    session control or control messages. Therefore, the code uses the `conn.SetWriteDeadline`
    method to ensure the connection to the client does not linger unnecessarily for
    long periods of time. The method is called during the loop that streams out a
    response to the client. It is set for a deadline of 5 seconds to ensure the client
    is always ready to receive the next chunk of bytes within that time, otherwise
    it times the connection out.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器支持的单个文本协议不包含任何类型的会话控制或控制消息。因此，代码使用 `conn.SetWriteDeadline` 方法确保与客户端的连接不会不必要地长时间挂起。该方法在循环中调用，循环将响应流式传输到客户端。它设置为
    5 秒的截止日期，以确保客户端总是在该时间内准备好接收下一块字节，否则它将超时连接。
- en: Connecting to the TCP server with telnet
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 telnet 连接到 TCP 服务器
- en: 'Because the currency server presented earlier uses a simple text-based protocol,
    it can be tested using a telnet client, assuming the server code has been compiled
    and running (and listening on port `4040`). The following shows the output of
    a telnet session querying the server for currency information:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面提出的货币服务器使用简单的基于文本的协议，它可以使用 telnet 客户端进行测试，假设服务器代码已被编译并运行（并监听端口 `4040`）。以下是一个
    telnet 会话的输出，该会话查询服务器以获取货币信息：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, you can query the server by using the `get` command followed
    by a filter parameter as explained earlier. The telnet client sends the raw text
    to the server which parses it and sends back raw text as the response. You can
    open multiple telnet sessions against the server and all request are served concurrently
    in their respective goroutine.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以通过使用前面解释的 `get` 命令后跟一个过滤器参数来查询服务器。telnet 客户端将原始文本发送到服务器，服务器解析它并作为响应发送回原始文本。您可以对服务器打开多个
    telnet 会话，并且所有请求都在各自的 goroutine 中并发处理。
- en: Connecting to the TCP server with Go
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Go 连接到 TCP 服务器
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: $> Connected to Global Currency Service
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: $> 连接到全球货币服务
- en: curr> get pound
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: curr> get pound
- en: Egyptian Pound EGP 818 EGYPT
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 埃及镑 EGP 818 埃及
- en: Gibraltar Pound GIP 292 GIBRALTAR
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 直布罗陀镑 GIP 292 直布罗陀
- en: Sudanese Pound SDG 938 SUDAN (THE)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 苏丹镑 SDG 938 苏丹（THE）
- en: '...'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Syrian Pound SYP 760 SYRIAN ARAB REPUBLIC
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 叙利亚镑 SYP 760 叙利亚阿拉伯共和国
- en: Pound Sterling GBP 826 UNITED KINGDOM OF GREAT BRITAIN (THE)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 英镑 GBP 826 大不列颠及北爱尔兰联合王国（THE）
- en: curr>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: curr>
- en: 'conbuf variable, of the bufio.Buffer type, is used to read and split incoming
    streams from the server using the conbuf.ReadString method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: conbuf 变量，bufio.Buffer 类型，用于使用 conbuf.ReadString 方法读取和分割来自服务器的输入流：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: conbuf := bufio.NewReaderSize(conn, 1024)
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: conbuf := bufio.NewReaderSize(conn, 1024)
- en: for {
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: for {
- en: str, err := conbuf.ReadString('\n')
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: str, err := conbuf.ReadString('\n')
- en: if err != nil {
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if err != nil {
- en: break
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: break
- en: '}'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: fmt.Print(str)
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: fmt.Print(str)
- en: conn.SetReadDeadline(
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: conn.SetReadDeadline(
- en: time.Now().Add(time.Millisecond * 700))
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: time.Now().Add(time.Millisecond * 700))
- en: '}'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The HTTP package
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 包
- en: Due to its importance and ubiquity, HTTP is one of a handful of protocols directly
    implemented in Go. The `net/http` package ([https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/))
    provides code to implement both HTTP clients and HTTP servers. This section explores
    the fundamentals of creating HTTP clients and servers using the `net/http` package.
    Later, we will return our attention back to building versions of our currency
    service using HTTP.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其重要性和普遍性，HTTP 是 Go 直接实现的一小部分协议之一。`net/http` 包 ([https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/))
    提供了实现 HTTP 客户端和 HTTP 服务器的代码。本节探讨了使用 `net/http` 包创建 HTTP 客户端和服务器的基本原理。稍后，我们将把注意力转回到使用
    HTTP 构建我们的货币服务版本。
- en: The http.Client type
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 客户端类型
- en: 'The `http.Client` struct represents an HTTP client and is used to create HTTP
    requests and retrieve responses from a server. The following illustrates how to
    retrieve the text content of Beowulf from Project Gutenberg''s website located
    at [http://gutenberg.org/cache/epub/16328/pg16328.txt](http://gutenberg.org/cache/epub/16328/pg16328.txt), using
    the `client` variable of the `http.Client` type and prints its content to a standard
    output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Client` 结构体代表一个 HTTP 客户端，用于创建 HTTP 请求并从服务器检索响应。以下示例展示了如何使用 `http.Client`
    类型的 `client` 变量从位于 [http://gutenberg.org/cache/epub/16328/pg16328.txt](http://gutenberg.org/cache/epub/16328/pg16328.txt)
    的 Project Gutenberg 网站检索 Beowulf 的文本内容，并将其内容打印到标准输出：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: golang.fyi/ch11/httpclient1.go
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpclient1.go
- en: The previous example uses the `client.Get` method to retrieve content from the
    remote server using the HTTP protocol method `GET` internally. The `GET` method
    is part of several convenience methods offered, by the Client type, to interact
    with HTTP servers as summarized in the following table. Notice that all of these
    methods return a value of the `*http.Response` type (discussed later) to handle
    responses returned by the HTTP server.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例使用 `client.Get` 方法通过 HTTP 协议内部方法 `GET` 从远程服务器检索内容。`GET` 方法是客户端类型提供的几个便利方法之一，用于与
    HTTP 服务器交互，如下表所示。请注意，所有这些方法都返回 `*http.Response` 类型的值（稍后讨论），以处理 HTTP 服务器返回的响应。
- en: '| **Method** | **Description** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Client.Get` | As discussed earlier, `Get` is a convenience method that issues
    an HTTP `GET` method to retrieve the resource specified by the `url` parameter
    from the server:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.Get` | 如前所述，`Get` 是一个便利方法，它向服务器发送一个 HTTP `GET` 方法，以从服务器检索由 `url`
    参数指定的资源：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.Post` | The `Post` method is a convenience method that issues an
    HTTP `POST` method to send the content specified by the `body` parameter to the
    server specified by the `url` parameter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.Post` | `Post` 方法是一个便利方法，它向服务器发送一个 HTTP `POST` 方法，将 `body` 参数指定的内容发送到由
    `url` 参数指定的服务器：'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.PostForm` | The `PostForm` method is a convenience method that uses
    the HTTP `POST` method to send form `data`, specified as mapped key/value pairs,
    to the server:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.PostForm` | `PostForm` 方法是一个便利方法，它使用 HTTP `POST` 方法将表单 `data`（指定为映射的键/值对）发送到服务器：'
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.Head` | The `Head` method is a convenience method that issues an
    HTTP method, `HEAD`, to the remote server specified by the `url` parameter:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.Head` | `Head` 方法是一个便利方法，它向由 `url` 参数指定的远程服务器发送 HTTP 方法 `HEAD`：'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.Do` | This method generalizes the request and response interaction
    with a remote HTTP server. It is wrapped internally by the methods listed in this
    table. Section *Handling client requests and responses* discusses how to use this
    method to talk to the server. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Client.Do` | 此方法泛化了与远程 HTTP 服务器的请求和响应交互。它被列在此表中的方法内部包装。*处理客户端请求和响应*节讨论了如何使用此方法与服务器通信。|'
- en: 'It should be noted that the HTTP package uses an internal `http.Client` variable
    designed to mirror the preceding methods as package functions for further convenience.
    They include `http.Get`, `*http.Post*` , `http.PostForm`, and `http.Head`. The
    following snippet shows the previous example using `http.Get` instead of the method
    from the `http.Client`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，HTTP 包使用一个内部 `http.Client` 变量，该变量旨在作为包函数来镜像前面的方法，以提供进一步的便利。它们包括 `http.Get`、`*http.Post*`、`http.PostForm`
    和 `http.Head`。以下代码片段显示了使用 `http.Get` 而不是 `http.Client` 方法的前一个示例：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch11/httpclient1a.go
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpclient1a.go
- en: Configuring the client
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户端
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Handling client requests and responses
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理客户端请求和响应
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch11/httpclient3.go
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpclient3.go
- en: 'The `http.NewRequest` function has the following signature:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.NewRequest` 函数具有以下签名：'
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method accepts a pointer to an `http.Request` value, as discussed in the
    previous section. It then returns a pointer to an `http.Response` value or an
    error if the request fails. In the previous source code, `resp, err := client.Do(req)`
    is used to send the request to the server and assigns the response to the `resp`
    variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个指向 `http.Request` 值的指针，如前节所述。然后它返回一个指向 `http.Response` 值的指针或一个错误（如果请求失败）。在前面的源代码中，`resp,
    err := client.Do(req)` 用于向服务器发送请求并将响应分配给 `resp` 变量。
- en: The response from the server is encapsulated in struct `http.Response` which
    contains several fields to describe the response including the HTTP response status,
    content length, headers, and the response body. The response body, exposed as
    the `http.Response.Body` field, implements the `io.Reader` which affords the use
    streaming IO primitives to consume the response content.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应被封装在结构体 `http.Response` 中，该结构体包含多个字段来描述响应，包括 HTTP 响应状态、内容长度、头部信息和响应体。响应体作为
    `http.Response.Body` 字段暴露，实现了 `io.Reader` 接口，这使得可以使用流式 IO 原语来消费响应内容。
- en: The `Body` field also implements `*io.Closer*` which allows the closing of IO
    resources. The previous source uses `defer resp.Body.Close()` to close the IO
    resource associated with the response body. This is a recommended idiom when the
    server is expected to return a non-nil body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Body` 字段还实现了 `*io.Closer*` 接口，这允许关闭 IO 资源。前面的源代码使用 `defer resp.Body.Close()`
    来关闭与响应体相关的 IO 资源。当预期服务器返回非 nil 的响应体时，这是一个推荐的惯用法。'
- en: A simple HTTP server
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的 HTTP 服务器
- en: 'The HTTP package provides two main components to accept HTTP requests and serve
    responses:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 包提供了两个主要组件来接受 HTTP 请求和提供响应：
- en: The `http.Handler` interface
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Handler` 接口'
- en: The `http.Server` type
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Server` 类型'
- en: 'The `http.Server` type uses the `http.Handler` interface type, defined in the
    following listing, to receive requests and server responses:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Server` 类型使用 `http.Handler` 接口类型，该接口在以下列表中定义，用于接收请求和服务器响应：'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: golang.fyi/ch11/httpserv0.go
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv0.go
- en: 'In the previous code, the `msg` type, which uses a string as its underlying
    type, implements the `ServeHTTP()` method making it a valid HTTP handler. Its
    `ServeHTTP` method uses the response parameter, `resp`, to print response headers
    `"200 OK"` and `"Content-Type: text/html"`. The method also writes the string
    value `m` to the response variable using `fmt.Fprint(resp, m)` which is sent back
    to the client.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，`msg` 类型，其底层类型为字符串，实现了 `ServeHTTP()` 方法，使其成为一个有效的 HTTP 处理程序。其 `ServeHTTP`
    方法使用响应参数 `resp` 来打印响应头部 `"200 OK"` 和 `"Content-Type: text/html"`。该方法还使用 `fmt.Fprint(resp,
    m)` 将字符串值 `m` 写入响应变量，并将其发送回客户端。'
- en: 'In the code, the variable `server` is initialized as `http.Server{Addr: ":4040",
    Handler: msgHandler}`. This means the server will listen on all network interfaces
    at port `4040` and will use variable `msgHandler` as its `http.Handler` implementation.
    Once initialized, the server is started with the `server.ListenAndServe()` method
    call that is used to block and listen for incoming requests.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '在代码中，变量 `server` 被初始化为 `http.Server{Addr: ":4040", Handler: msgHandler}`。这意味着服务器将在端口
    `4040` 上监听所有网络接口，并使用变量 `msgHandler` 作为其 `http.Handler` 实现方式。一旦初始化，服务器通过调用 `server.ListenAndServe()`
    方法启动，该方法用于阻塞并监听传入的请求。'
- en: 'Besides the `Addr` and `Handler`, the `http.Server` struct exposes several
    additional fields that can be used to control different aspects of the HTTP service
    such as connection, timeout values, header sizes, and TLS configuration. For instance,
    the following snippet shows an updated example which specifies the server''s read
    and write timeouts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Addr` 和 `Handler` 之外，`http.Server` 结构体还公开了几个其他字段，可用于控制 HTTP 服务的不同方面，如连接、超时值、头部大小和
    TLS 配置。例如，以下片段显示了一个更新的示例，它指定了服务器的读取和写入超时：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch11/httpserv1.go
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv1.go
- en: The default server
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认服务器
- en: 'It should be noted that the HTTP package includes a default server that can
    be used in simpler cases when there is no need for configuration of the server.
    The following abbreviated code snippet starts a simple server without explicitly
    creating a server variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意，HTTP 包包含一个默认的服务器，在不需要配置服务器的情况下，可以用于更简单的场景。以下简化的代码片段启动了一个简单的服务器，而没有显式创建服务器变量：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch11/httpserv2.go
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv2.go
- en: In the code, the `http.ListenAndServe(":4040", msgHandler)` function is used
    to start a server which is declared as a variable in the HTTP package. The server
    is configured with the local address `":4040"` and the handler `msgHandler` (as
    was done earlier) to handle all incoming requests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，使用 `http.ListenAndServe(":4040", msgHandler)` 函数启动了一个服务器，该服务器在 HTTP 包中声明为一个变量。服务器配置了本地地址
    `":4040"` 和处理程序 `msgHandler`（如之前所述）来处理所有传入的请求。
- en: Routing requests with http.ServeMux
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 http.ServeMux 路由请求
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch11/httpserv3.go
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv3.go
- en: The code declares two functions assigned to variables `hello` and `goodbye`.
    Each function is mapped to a path `"/hello"` and `"/goodbye"` respectively using
    the `mux.HandleFunc("/hello", hello)` and `mux.HandleFunc("/goodbye", goodbye)`
    method calls. When the server is launched, with `http.ListenAndServe(":4040",
    mux)`, its handler will route the request `"http://localhost:4040/hello"` to the
    `hello` function and requests with the path `"http://localhost:4040/goodbye"`
    to the `goodbye` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了两个函数，分别赋值给变量 `hello` 和 `goodbye`。每个函数分别使用 `mux.HandleFunc("/hello", hello)`
    和 `mux.HandleFunc("/goodbye", goodbye)` 方法调用映射到路径 `"/hello"` 和 `"/goodbye"`。当服务器启动时，使用
    `http.ListenAndServe(":4040", mux)`，其处理程序将请求 `"http://localhost:4040/hello"` 路由到
    `hello` 函数，并将路径为 `"http://localhost:4040/goodbye"` 的请求路由到 `goodbye` 函数。
- en: The default ServeMux
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认 ServeMux
- en: 'It is worth pointing out that the HTTP package makes available a default ServeMux
    internally. When used, it is not necessary to explicitly declare a ServeMux variable.
    Instead the code uses the package function, `http.HandleFunc,` to map a path to
    a handler function as illustrated in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，HTTP 包内部提供了一个默认的 ServeMux。当使用时，不需要显式声明一个 ServeMux 变量。相反，代码使用包函数 `http.HandleFunc`
    将路径映射到处理函数，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch11/httpserv4.go
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv4.go
- en: To launch the server, the code calls `http.ListenAndServe(":4040", nil)` where
    the ServerMux parameter is set to `nil`. This implies that the server will default
    to the per-declared package instance of http.ServeMux to handle incoming requests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器，代码调用 `http.ListenAndServe(":4040", nil)`，其中 ServerMux 参数设置为 `nil`。这意味着服务器将默认使用每个声明的包实例的
    http.ServeMux 来处理传入的请求。
- en: A JSON API server
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 JSON API 服务器
- en: 'Armed with the information from the last section, it is possible to use the
    HTTP package to create services over HTTP. Earlier we discussed the perils of
    creating services using raw TCP directly when we created a server for our global
    monetary currency service. In this section, we explore how to create an API server
    for the same service using HTTP as the underlying protocol. The new HTTP-based
    service has the following design goals:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 借助上一节的信息，可以使用 HTTP 包在 HTTP 上创建服务。在我们创建用于全球货币货币服务的服务器时，我们讨论了使用原始 TCP 直接创建服务的风险。在本节中，我们将探讨如何使用
    HTTP 作为底层协议创建相同服务的 API 服务器。基于 HTTP 的新服务有以下设计目标：
- en: Use HTTP as the transport protocol
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 作为传输协议
- en: Use JSON for structured communication between client and server
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON 在客户端和服务器之间进行结构化通信
- en: Clients query the server for currency information using JSON-formatted requests
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端使用 JSON 格式的请求查询服务器以获取货币信息
- en: The server respond using JSON-formatted responses
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器使用 JSON 格式的响应进行响应
- en: The following shows the code involved in the implementation of the new service.
    This time, the server will use the `curr1` package (see [github.com/vladimirvivien/learning-go
    /ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)) to
    load and query ISO 4217 currency data from a local CSV file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了实现新服务所涉及的代码。这次，服务器将使用 `curr1` 包（参见 [github.com/vladimirvivien/learning-go
    /ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)）从本地
    CSV 文件中加载和查询 ISO 4217 货币数据。
- en: 'The code in the curr1 package defines two types, `CurrencyRequest` and `Currency`,
    intended to represent the client request and currency data returned by the server,
    respectively as listed here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: curr1 包中的代码定义了两种类型，`CurrencyRequest` 和 `Currency`，分别用于表示客户端请求和服务器返回的货币数据，如下所示：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: golang.fyi/ch11/curr1/currency.go
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/curr1/currency.go
- en: 'Note that the preceding struct types shown are annotated with tags that describe
    the JSON properties for each field. This information is used by the JSON encoder
    to encode the key name of JSON objects (see [Chapter 10](part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10. Data IO in Go"), *Data IO in Go*, for detail on encoding). The remainder
    of the code, listed in the following snippet, defines the functions that set up
    the server and the handler function for incoming requests:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面显示的结构体类型都带有标签，这些标签描述了每个字段的 JSON 属性。这些信息被 JSON 编码器用于编码 JSON 对象的键名（参见[第 10
    章](part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd "第 10 章。Go
    中的数据输入输出")，*Go 中的数据输入输出*，有关编码的详细信息）。以下代码片段中列出的代码定义了设置服务器和接收请求的处理函数：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch11/jsonserv0.go
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/jsonserv0.go
- en: 'Since we are leveraging HTTP as the transport protocol for the service, you
    can see the code is now much smaller than the prior implementation which used
    pure TCP. The `currs` function implements the handler responsible for incoming
    requests. It sets up a decoder to decode the incoming JSON-encoded request to
    a value of the `curr1.CurrencyRequest` type as highlighted in the following snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用 HTTP 作为服务的传输协议，您可以看到代码现在比之前使用纯 TCP 的实现要小得多。`currs` 函数实现了处理传入请求的处理程序。它设置了一个解码器，将传入的
    JSON 编码请求解码为 `curr1.CurrencyRequest` 类型的值，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, the function executes the currency search by calling `curr1.Find(currencies,
    currRequest.Get)` which returns the slice `[]Currency` assigned to the `result`
    variable. The code then creates an encoder to encode the `result` as a JSON payload,
    highlighted in the following snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数通过调用 `curr1.Find(currencies, currRequest.Get)` 执行货币搜索，该函数返回分配给 `result`
    变量的 `[]Currency` 切片。然后，代码创建了一个编码器，将 `result` 编码为 JSON 有效负载，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Lastly, the handler function is mapped to the `"/currency"` path in the `main`
    function with the call to `mux.HandleFunc("/currency", currs)`. When the server
    receives a request for that path, it automatically executes the `currs` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理程序函数通过调用 `mux.HandleFunc("/currency", currs)` 将其映射到 `main` 函数中的 `"/currency"`
    路径。当服务器收到对该路径的请求时，它自动执行 `currs` 函数。
- en: Testing the API server with cURL
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cURL 测试 API 服务器
- en: 'Because the server is implemented over HTTP, it can easily be tested with any
    client-side tools that support HTTP. For instance, the following shows how to
    use the `cURL` command line tool ([http://curl.haxx.se/](http://curl.haxx.se/)))
    to connect to the API end-point and retrieve currency information about the `Euro`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器是在 HTTP 上实现的，它可以很容易地使用任何支持 HTTP 的客户端工具进行测试。例如，以下展示了如何使用 `cURL` 命令行工具 ([http://curl.haxx.se/](http://curl.haxx.se/)))
    连接到 API 端点并检索有关 `Euro` 的货币信息：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `cURL` command posts a JSON-formatted request object to the server using
    the `-X POST -d '{"get":"Euro"}'` parameters. The output (formatted for readability)
    from the server is comprised of a JSON array of the preceding currency items.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-X POST -d '{"get":"Euro"}'` 参数，`cURL` 命令将一个 JSON 格式的请求对象发送到服务器。服务器输出的结果（为了便于阅读进行了格式化）是一个包含先前货币项的
    JSON 数组。
- en: An API server client in Go
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 语言中的 API 服务器客户端
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: golang.fyi/ch11/jsonclient0.go
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/jsonclient0.go
- en: 'In the previous code, an HTTP client is created to send JSON-encoded request
    values as `currRequest := &curr1.CurrencyRequest{Get: param}` where `param` is
    the currency string to retrieve. The response from the server is a payload that
    represents an array of JSON-encoded objects (see the JSON array in the section,
    *Testing the API Server with cURL*). The code then uses a JSON decoder, `json.NewDecoder(resp.Body).Decode(&currencies)`,
    to decode the payload from the response body into the slice, `[]curr1.Currency`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，创建了一个 HTTP 客户端来发送 JSON 编码的请求值，`currRequest := &curr1.CurrencyRequest{Get:
    param}`，其中 `param` 是要检索的货币字符串。服务器的响应是一个表示 JSON 编码对象数组的有效负载（请参阅 *使用 cURL 测试 API
    服务器* 部分的 JSON 数组）。然后，代码使用 JSON 解码器，`json.NewDecoder(resp.Body).Decode(&currencies)`，将响应体中的有效负载解码到
    `[]curr1.Currency` 切片中。'
- en: A JavaScript API server client
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript API 服务器客户端
- en: So far, we have seen how to use the API service using the `cURL` command-line
    tool and a native Go client. This section shows the versatility of using HTTP
    to implement networked services by showcasing a web-based JavaScript client. In
    this approach, the client is a web-based GUI that uses modern HTML, CSS, and JavaScript
    to create an interface that interacts with the API server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用 `cURL` 命令行工具和原生 Go 客户端来使用 API 服务。本节展示了使用 HTTP 实现网络服务的多功能性，通过展示一个基于
    Web 的 JavaScript 客户端。在这种方法中，客户端是一个基于 Web 的图形用户界面，它使用现代的 HTML、CSS 和 JavaScript
    来创建与 API 服务器交互的界面。
- en: 'First, the server code is updated with an additional handler to serve the static
    HTML file that renders the GUI on the browser. This is illustrated in the following
    code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器代码更新了一个额外的处理程序来服务渲染浏览器上 GUI 的静态 HTML 文件。以下代码展示了这一点：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![A JavaScript API server client](img/00027.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript API 服务器客户端](img/00027.jpeg)'
- en: 'The next HTML page ([golang.fyi/ch11/currency.html](http://learning.golang.fyi/ch11/currency.html))
    is responsible for displaying the result of a currency search. It uses JavaScritpt
    functions along with the `jQuery.js` library (not covered here) to post JSON-encoded
    requests to the backend Go service as shown in the following abbreviated HTML
    and JavaScript snippets:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一页HTML页面([golang.fyi/ch11/currency.html](http://learning.golang.fyi/ch11/currency.html))负责显示货币搜索的结果。它使用JavaScript函数以及`jQuery.js`库（此处未介绍）将JSON编码的请求发送到后端Go服务，如下面的简略HTML和JavaScript片段所示：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: golang.fyi/ch11/currency.html
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/currency.html
- en: A line-by-line analysis of the HTML and JavaScript code in this example is beyond
    the scope of the book; however, it is worth pointing out that the JavaScript `doRequest`
    function is where the interaction between the client and the server happens. It
    uses the jQuery's `$.ajax` function to build an HTTP request with a `PUT` method
    and to specify a JSON-encoded currency request object, `JSON.stringify({get:param})`,
    to send to the server. The `then` method accepts the callback function, `success(currencies)`,
    which handles the response from the server that parses displays in an HTML table.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对本例中HTML和JavaScript代码的逐行分析超出了本书的范围；然而，值得注意的是，JavaScript的`doRequest`函数是客户端与服务器交互的地方。它使用jQuery的`$.ajax`函数构建一个使用`PUT`方法的HTTP请求，并指定一个JSON编码的货币请求对象`JSON.stringify({get:param})`发送到服务器。`then`方法接受回调函数`success(currencies)`，该函数处理来自服务器的响应，并将其解析显示在HTML表格中。
- en: 'When a search value is provided in the text box on the GUI, the page displays
    its results in the table dynamically as shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当在GUI上的文本框中提供搜索值时，页面会动态地在表格中显示其结果，如下面的屏幕截图所示：
- en: '![A JavaScript API server client](img/00028.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![一个JavaScript API服务器客户端](img/00028.jpeg)'
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter condenses several important notions about creating networked services
    in Go. It starts with a walkthrough of Go's `net` package including the `net.Conn`
    type to create a connection between network nodes, the `net.Dial` function to
    connect to a remote service, and the `net.Listen` function to handle incoming
    connections from a client. The chapter continues to cover different implementations
    of clients and server programs and shows the implications of creating custom protocols
    directly over raw TCP versus using an existing protocol such as HTTP with JSON
    data format.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了关于在Go中创建网络服务的一些重要概念。它从Go的`net`包的概述开始，包括用于在节点之间创建连接的`net.Conn`类型，用于连接远程服务的`net.Dial`函数，以及用于处理来自客户端的传入连接的`net.Listen`函数。本章继续介绍客户端和服务器程序的多种实现，并展示了在原始TCP上直接创建自定义协议与使用现有协议（如HTTP，JSON数据格式）之间的差异。
- en: The next chapter takes a different direction. It explores the packages, types,
    functions, and tools that are available in Go to facilitate source code testing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨不同的方向。它探讨了Go中可用于简化源代码测试的包、类型、函数和工具。
