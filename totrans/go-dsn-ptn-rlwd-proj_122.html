<html><head></head><body>
<div class="book" title="Passing parameter values" id="12AK81-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Achieving pass-by-reference"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec84" class="calibre1"/>Achieving pass-by-reference</h2></div></div></div><p class="calibre10">While the pass-by-value is appropriate in many cases, it is important to note that Go can achieve pass-by-reference semantics using pointer parameter values. This allows a called function to reach outside of its lexical scope and change the value stored at the location referenced by the pointer parameter as is done in the <code class="email">half</code> function in the following example:</p><pre class="programlisting">package main 
import "fmt" 
 
func half(val *float64) { 
   fmt.Printf("call half(%f)\n", *val) 
   *val = *val / 2 
} 
 
func main() { 
   num := 2.807770 
   fmt.Printf("num=%f\n", num) 
   half(&amp;num) 
   fmt.Printf("half(num)=%f\n", num) 
} 
</pre><p class="calibre10">golang.fyi/ch05/funcpassbyref.go</p><p class="calibre10">In the previous example, the call to the <code class="email">half(&amp;num)</code> function in <code class="email">main()</code> updates, in place, the original value referenced by its <code class="email">num</code> parameter. So, when the code is executed, it shows the original value of <code class="email">num</code> and its value after the call to the <code class="email">half</code> function:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go run funcpassbyref.go</strong></span>
<span class="strong"><strong class="calibre2">num=2.807770</strong></span>
<span class="strong"><strong class="calibre2">call half(2.807770)</strong></span>
<span class="strong"><strong class="calibre2">half(num)=1.403885</strong></span>
</pre><p class="calibre10">As was stated earlier, Go function parameters are passed by value. This is true even when the function takes a pointer value as its parameter. Go still creates and passes in a local copy of the pointer value. In the previous example, the <code class="email">half</code> function receives a copy of the pointer value it receives via the <code class="email">val</code> parameter. The code uses pointer operator (<code class="email">*</code>) to dereference and manipulate, in place, the value referenced by <code class="email">val</code>. When the <code class="email">half</code> function exits and goes out of scope, its changes are accessible by calling the <code class="email">main </code>function.</p></div></div></body></html>