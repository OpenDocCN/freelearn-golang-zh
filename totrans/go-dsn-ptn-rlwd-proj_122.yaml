- en: Achieving pass-by-reference
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现按引用传递
- en: 'While the pass-by-value is appropriate in many cases, it is important to note
    that Go can achieve pass-by-reference semantics using pointer parameter values.
    This allows a called function to reach outside of its lexical scope and change
    the value stored at the location referenced by the pointer parameter as is done
    in the `half` function in the following example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在许多情况下按值传递是合适的，但需要注意的是，Go可以通过使用指针参数值来实现按引用传递的语义。这允许被调用的函数超出其词法作用域，并改变由指针参数引用的位置存储的值，就像以下示例中的`half`函数所做的那样：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch05/funcpassbyref.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcpassbyref.go
- en: 'In the previous example, the call to the `half(&num)` function in `main()`
    updates, in place, the original value referenced by its `num` parameter. So, when
    the code is executed, it shows the original value of `num` and its value after
    the call to the `half` function:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`main()`函数中对`half(&num)`函数的调用，就地更新了由其`num`参数引用的原始值。因此，当代码执行时，它显示了`num`的原始值以及调用`half`函数后的值：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As was stated earlier, Go function parameters are passed by value. This is true
    even when the function takes a pointer value as its parameter. Go still creates
    and passes in a local copy of the pointer value. In the previous example, the
    `half` function receives a copy of the pointer value it receives via the `val`
    parameter. The code uses pointer operator (`*`) to dereference and manipulate,
    in place, the value referenced by `val`. When the `half` function exits and goes
    out of scope, its changes are accessible by calling the `main` function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go函数参数是按值传递的。即使函数将其参数作为指针值，这也是正确的。Go仍然创建并传递指针值的本地副本。在前面的示例中，`half`函数通过`val`参数接收它接收到的指针值的副本。代码使用指针运算符（`*`）进行解引用并就地操作由`val`引用的值。当`half`函数退出并超出作用域时，其更改可以通过调用`main`函数来访问。
