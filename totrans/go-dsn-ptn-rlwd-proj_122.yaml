- en: Achieving pass-by-reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the pass-by-value is appropriate in many cases, it is important to note
    that Go can achieve pass-by-reference semantics using pointer parameter values.
    This allows a called function to reach outside of its lexical scope and change
    the value stored at the location referenced by the pointer parameter as is done
    in the `half` function in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcpassbyref.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the call to the `half(&num)` function in `main()`
    updates, in place, the original value referenced by its `num` parameter. So, when
    the code is executed, it shows the original value of `num` and its value after
    the call to the `half` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As was stated earlier, Go function parameters are passed by value. This is true
    even when the function takes a pointer value as its parameter. Go still creates
    and passes in a local copy of the pointer value. In the previous example, the
    `half` function receives a copy of the pointer value it receives via the `val`
    parameter. The code uses pointer operator (`*`) to dereference and manipulate,
    in place, the value referenced by `val`. When the `half` function exits and goes
    out of scope, its changes are accessible by calling the `main` function.
  prefs: []
  type: TYPE_NORMAL
