<html><head></head><body>
<div class="book" title="Passing parameter values" id="12AK81-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Closures"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec87" class="calibre1"/>Closures</h2></div></div></div><p class="calibre10">Go function literals are closures. This means they have lexical visibility to non-local variables declared outside of their enclosing code block. The following example illustrates this fact:</p><pre class="programlisting">package main 
import ( 
   "fmt" 
   "math" 
) 
 
func main() { 
   for i := 0.0; i &lt; 360.0; i += 45.0 { 
         rad := func() float64 { 
               return i * math.Pi / 180 
         }() 
         fmt.Printf("%.2f Deg = %.2f Rad\n", i, rad) 
   } 
} 
</pre><p class="calibre10">github.com/vladimirvivien/learning-go/ch05/funcs.go</p><p class="calibre10">In the previous program, the function literal code block, <code class="email">func() float64 {return deg * math.Pi / 180}()</code>, is defined as an expression that converts degrees to radians. With each iteration of the loop, a closure is formed between the enclosed function literal and the outer non-local variable, <code class="email">i</code>. This provides a simpler idiom where the function naturally accesses non-local values without resorting to other means such as pointers.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note7" class="calibre1"/>Note</h3><p class="calibre10">In Go, lexically closed values can remain bounded to their closures long after the outer function that created the closure has gone out of scope. The garbage collector will handle cleanups as these closed values become unbounded.</p></div></div></div></body></html>