- en: Closures
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Go function literals are closures. This means they have lexical visibility
    to non-local variables declared outside of their enclosing code block. The following
    example illustrates this fact:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 函数字面量是闭包。这意味着它们对其封装代码块外部声明的非局部变量具有词法可见性。以下示例说明了这一事实：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: github.com/vladimirvivien/learning-go/ch05/funcs.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: github.com/vladimirvivien/learning-go/ch05/funcs.go
- en: In the previous program, the function literal code block, `func() float64 {return
    deg * math.Pi / 180}()`, is defined as an expression that converts degrees to
    radians. With each iteration of the loop, a closure is formed between the enclosed
    function literal and the outer non-local variable, `i`. This provides a simpler
    idiom where the function naturally accesses non-local values without resorting
    to other means such as pointers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，函数字面量代码块 `func() float64 {return deg * math.Pi / 180}()` 被定义为将度数转换为弧度的表达式。在循环的每次迭代中，封装的函数字面量和外部非局部变量
    `i` 之间形成一个闭包。这提供了一种更简单的语法，其中函数自然访问非局部值，而无需求助于指针等其他手段。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Go, lexically closed values can remain bounded to their closures long after
    the outer function that created the closure has gone out of scope. The garbage
    collector will handle cleanups as these closed values become unbounded.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，词法封闭的值可以在创建闭包的外部函数超出作用域很长时间后仍然与其闭包绑定。垃圾收集器将处理清理工作，因为这些封闭值变得无界。
