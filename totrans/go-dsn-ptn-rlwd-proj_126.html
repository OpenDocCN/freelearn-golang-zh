<html><head></head><body><div class="book" title="Higher-order functions" id="1394Q1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec33" class="calibre1"/>Higher-order functions</h1></div></div></div><p class="calibre10">We have already established that Go functions are values bound to a type. So, it should not be a surprise that a Go function can take another function as a parameter and also return a function as a result value. This describes the notion known as a higher-order function, which is a concept adopted from mathematics. While types such as <code class="email">struct</code> let programmers abstract data, higher-order functions provide a mechanism to encapsulate and abstract behaviors that can be composed together to form more complex behaviors.</p><p class="calibre10">To make this concept clearer, let us examine the following program, which uses a higher-order function, <code class="email">apply</code>, to do three things. It accepts a slice of integers and a function as parameters. It applies the specified function to each element in the slice. Lastly, the <code class="email">apply</code> function also returns a function as its result:</p><pre class="programlisting">package main 
import "fmt" 
 
func apply(nums []int, f func(int) int) func() { 
   for i, v := range nums { 
         nums[i] = f(v) 
   } 
   return func() { 
         fmt.Println(nums) 
   } 
} 
 
func main() { 
   nums := []int{4, 32, 11, 77, 556, 3, 19, 88, 422} 
   result := apply(nums, func(i int) int { 
         return i / 2 
   }) 
   result() 
} 
</pre><p class="calibre10">golang.fyi/ch05/funchighorder.go</p><p class="calibre10">In the program, the <code class="email">apply</code> function is invoked with an anonymous function that halves each element in the slice as highlighted in the following snippet:</p><pre class="programlisting">nums := []int{4, 32, 11, 77, 556, 3, 19, 88, 422} 
result := apply(nums, func(i int) int { 
   return i / 2 
}) 
result() 
</pre><p class="calibre10">As a higher-order function, <code class="email">apply</code> abstracts the transformation logic which can be provided by any function of type <code class="email">func(i int) int</code>, as shown next. Since the <code class="email">apply</code> function returns a function, the variable <code class="email">result</code> can be invoked as shown in the previous snippet.</p><p class="calibre10">As you explore this book, and the Go language, you will continue to encounter usage of higher-order functions. It is a popular idiom that is used heavily in the standard libraries. You will also find higher-order functions used in some concurrency patterns to distribute workloads (see <a class="calibre1" title="Chapter 9. Concurrency" href="part0061_split_000.html#1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 9</a>, <span class="strong"><em class="calibre11">Concurrency</em></span>).</p></div></body></html>