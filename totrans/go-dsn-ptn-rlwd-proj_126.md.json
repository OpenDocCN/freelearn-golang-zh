["```go\npackage main \nimport \"fmt\" \n\nfunc apply(nums []int, f func(int) int) func() { \n   for i, v := range nums { \n         nums[i] = f(v) \n   } \n   return func() { \n         fmt.Println(nums) \n   } \n} \n\nfunc main() { \n   nums := []int{4, 32, 11, 77, 556, 3, 19, 88, 422} \n   result := apply(nums, func(i int) int { \n         return i / 2 \n   }) \n   result() \n} \n\n```", "```go\nnums := []int{4, 32, 11, 77, 556, 3, 19, 88, 422} \nresult := apply(nums, func(i int) int { \n   return i / 2 \n}) \nresult() \n\nAs you explore this book, and the Go language, you will continue to encounter usage of higher-order functions. It is a popular idiom that is used heavily in the standard libraries. You will also find higher-order functions used in some concurrency patterns to distribute workloads (see Chapter 9, *Concurrency*).\n```"]