- en: Higher-order functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: We have already established that Go functions are values bound to a type. So,
    it should not be a surprise that a Go function can take another function as a
    parameter and also return a function as a result value. This describes the notion
    known as a higher-order function, which is a concept adopted from mathematics.
    While types such as `struct` let programmers abstract data, higher-order functions
    provide a mechanism to encapsulate and abstract behaviors that can be composed
    together to form more complex behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定 Go 函数是绑定到类型的值。因此，一个 Go 函数可以接受另一个函数作为参数，并返回一个函数作为结果值，这并不令人惊讶。这描述了被称为高阶函数的概念，这是一个从数学中采纳的概念。虽然
    `struct` 等类型允许程序员抽象数据，但高阶函数提供了一种封装和抽象行为的方式，这些行为可以组合在一起形成更复杂的行为。
- en: 'To make this concept clearer, let us examine the following program, which uses
    a higher-order function, `apply`, to do three things. It accepts a slice of integers
    and a function as parameters. It applies the specified function to each element
    in the slice. Lastly, the `apply` function also returns a function as its result:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个概念更清晰，让我们来检查以下程序，它使用一个高阶函数 `apply` 来完成三件事情。它接受一个整数切片和一个函数作为参数。它将指定的函数应用于切片中的每个元素。最后，`apply`
    函数还返回一个函数作为其结果：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch05/funchighorder.go
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funchighorder.go
- en: 'In the program, the `apply` function is invoked with an anonymous function
    that halves each element in the slice as highlighted in the following snippet:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，`apply` 函数使用一个匿名函数调用，该匿名函数将切片中的每个元素减半，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
