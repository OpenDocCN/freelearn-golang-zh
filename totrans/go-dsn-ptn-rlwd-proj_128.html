<html><head></head><body>
<div class="book" title="Error signaling and handling">
<div class="book" title="Signaling errors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec88" class="calibre1"/>Signaling errors</h2></div></div></div><p class="calibre10">To better understand what has been described in the previous paragraph, let us start with an example. The following source code implements an anagram program, as described in Column 2 from Jon Bentley's popular <span class="strong"><em class="calibre11">Programming Pearls</em></span> book (second edition). The code reads a dictionary file (<code class="email">dict.txt</code>) and groups all words with the same anagram. If the code does not quite make sense, please see <a class="calibre1" href="http://learning.golang.fyi/ch05/anagram1.go">golang.fyi/ch05/anagram1.go</a> for an annotated explanation of how each part of the program works.</p><pre class="programlisting">package main 
 
import ( 
   "bufio" 
   "bytes" 
   "fmt" 
   "os" 
   "errors" 
) 
 
// sorts letters in a word (i.e. "morning" -&gt; "gimnnor") 
func sortRunes(str string) string { 
   runes := bytes.Runes([]byte(str)) 
   var temp rune 
   for i := 0; i &lt; len(runes); i++ { 
         for j := i + 1; j &lt; len(runes); j++ { 
               if runes[j] &lt; runes[i] { 
                     temp = runes[i] 
                     runes[i], runes[j] = runes[j], temp 
               } 
 
         } 
   } 
   return string(runes) 
} 
 
// load loads content of file fname into memory as []string 
func load(fname string) ([]string, error) { 
   if fname == "" { 
         return nil, errors.New( 
               "Dictionary file name cannot be empty.")  
   } 
 
   file, err := os.Open(fname) 
   if err != nil { 
         return nil, err 
   } 
   defer file.Close() 
 
   var lines []string 
   scanner := bufio.NewScanner(file) 
   scanner.Split(bufio.ScanLines) 
   for scanner.Scan() { 
         lines = append(lines, scanner.Text()) 
   } 
   return lines, scanner.Err() 
} 
 
func main() { 
   words, err := load("dict.txt")       
   if err != nil { 
         fmt.Println("Unable to load file:", err) 
         os.Exit(1) 
   } 
 
      anagrams := make(map[string][]string) 
   for _, word := range words { 
         wordSig := sortRunes(word) 
         anagrams[wordSig] = append(anagrams[wordSig], word) 
   } 
 
   for k, v := range anagrams { 
         fmt.Println(k, "-&gt;", v) 
   } 
} 
</pre><p class="calibre10">golang.fyiy/ch05/anagram1.go</p><p class="calibre10">Again, if you want a more detail explanation of the previous program, take a look at the link supplied earlier. The focus here is on error signaling used in the previous program. As a convention, Go code uses the built-in type <code class="email">error</code> to signal when an error occurred during execution of a function. Therefore, a function must return a value of type error to indicate to its caller that something went wrong. This is illustrated in the following snippet of the <code class="email">load</code> function (extracted from the previous example):</p><pre class="programlisting">func load(fname string) ([]string, error) { 
   if fname == "" { 
       return nil, errors.New( 
         "Dictionary file name cannot be empty.")  
   } 
 
   file, err := os.Open(fname) 
   if err != nil { 
         return nil, err 
   } 
   ... 
} 
</pre><p class="calibre10">Notice that the <code class="email">load</code> function returns multiple result parameters. One is for the expected value, in this case <code class="email">[]string</code>, and the other is the error value. Idiomatic Go dictates that the programmer returns a non-nil value for result of type <code class="email">error</code> to indicate that something abnormal occurred during the execution of the function. In the previous snippet, the <code class="email">load</code> function signals an error occurrence to its callers in two possible instances:</p><div class="book"><ul class="itemizedlist"><li class="listitem">when the expected filename (<code class="email">fname</code>) is empty</li><li class="listitem">when the call to <code class="email">os.Open()</code> fails (for example, permission error, or otherwise)</li></ul></div><p class="calibre10">In the first case, when a filename is not provided, the code returns an error using <code class="email">errors.New()</code> to create a value of type <code class="email">error</code> to exit the function. In the second case, the <code class="email">os.Open</code> function returns a pointer representing the file and an error assigned to the <code class="email">file</code> and <code class="email">err </code>variables respectively. If <code class="email">err</code> is not <code class="email">nil</code> (meaning an error was generated), the execution of the <code class="email">load</code> function is halted prematurely and the value of <code class="email">err</code> is returned to be handled by the calling function further up the call stack.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note8" class="calibre1"/>Note</h3><p class="calibre10">When returning an error for a function with multiple result parameters, it is customary to return the zero-value for the other (non-error type) parameters. In the example, a value of <code class="email">nil</code> is returned for the result of type <code class="email">[]string</code>. While not necessary, it simplifies error handling and avoids any confusion for function callers.</p></div></div></div></body></html>