["```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"bytes\" \n   \"fmt\" \n   \"os\" \n   \"errors\" \n) \n\n// sorts letters in a word (i.e. \"morning\" -> \"gimnnor\") \nfunc sortRunes(str string) string { \n   runes := bytes.Runes([]byte(str)) \n   var temp rune \n   for i := 0; i < len(runes); i++ { \n         for j := i + 1; j < len(runes); j++ { \n               if runes[j] < runes[i] { \n                     temp = runes[i] \n                     runes[i], runes[j] = runes[j], temp \n               } \n\n         } \n   } \n   return string(runes) \n} \n\n// load loads content of file fname into memory as []string \nfunc load(fname string) ([]string, error) { \n   if fname == \"\" { \n         return nil, errors.New( \n               \"Dictionary file name cannot be empty.\")  \n   } \n\n   file, err := os.Open(fname) \n   if err != nil { \n         return nil, err \n   } \n   defer file.Close() \n\n   var lines []string \n   scanner := bufio.NewScanner(file) \n   scanner.Split(bufio.ScanLines) \n   for scanner.Scan() { \n         lines = append(lines, scanner.Text()) \n   } \n   return lines, scanner.Err() \n} \n\nfunc main() { \n   words, err := load(\"dict.txt\")       \n   if err != nil { \n         fmt.Println(\"Unable to load file:\", err) \n         os.Exit(1) \n   } \n\n      anagrams := make(map[string][]string) \n   for _, word := range words { \n         wordSig := sortRunes(word) \n         anagrams[wordSig] = append(anagrams[wordSig], word) \n   } \n\n   for k, v := range anagrams { \n         fmt.Println(k, \"->\", v) \n   } \n} \n\nload function (extracted from the previous example):\n```", "```go\nfunc load(fname string) ([]string, error) { \n   if fname == \"\" { \n       return nil, errors.New( \n         \"Dictionary file name cannot be empty.\")  \n   } \n\n   file, err := os.Open(fname) \n   if err != nil { \n         return nil, err \n   } \n   ... \n} \n\nload function signals an error occurrence to its callers in two possible instances:\n```"]