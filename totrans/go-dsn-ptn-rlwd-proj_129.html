<html><head></head><body>
<div class="book" title="Error signaling and handling">
<div class="book" title="Error handling"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec89" class="calibre1"/>Error handling</h2></div></div></div><p class="calibre10">As described previously, signaling of an erroneous state is as simple as returning a non-nil value, of type <code class="email">error</code>, during execution of a function. The caller may choose to handle the <code class="email">error</code> or <code class="email">return</code> it for further evaluation up the call stack as was done in the <code class="email">load</code> function. This idiom forces errors to propagate upwards until they are handled at some point. The next snippet shows how the error generated by the <code class="email">load</code> function is handled in the <code class="email">main</code> function:</p><pre class="programlisting">func main() { 
   words, err := load("dict.txt") 
   if err != nil { 
         fmt.Println("Unable to load file:", err) 
         os.Exit(1) 
   } 
   ... 
} 
</pre><p class="calibre10">Since the <code class="email">main</code> function is the topmost caller in the call stack, it handles the error by terminating the entire program.</p><p class="calibre10">This is all there is to the mechanics of error handling in Go. The language forces the programmer to always test for an erroneous state on every function call that returns a value of the type <code class="email">error</code>. The <code class="email">if…not…nil error</code> handling idiom may seem excessive and verbose to some, especially if you are coming from a language with formal exception mechanisms. However, the gain here is that the program can construct a robust execution flow where programmers always know where errors may come from and handle them appropriately.</p></div></div></body></html>