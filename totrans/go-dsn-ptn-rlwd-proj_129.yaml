- en: Error handling
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the `main` function is the topmost caller in the call stack, it handles
    the error by terminating the entire program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`main`函数是调用堆栈中的最高调用者，它通过终止整个程序来处理错误。
- en: This is all there is to the mechanics of error handling in Go. The language
    forces the programmer to always test for an erroneous state on every function
    call that returns a value of the type `error`. The `if…not…nil error` handling
    idiom may seem excessive and verbose to some, especially if you are coming from
    a language with formal exception mechanisms. However, the gain here is that the
    program can construct a robust execution flow where programmers always know where
    errors may come from and handle them appropriately.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Go语言中错误处理机制的所有内容。该语言强制程序员在每次函数调用返回`error`类型值时都测试错误状态。`if…not…nil error`处理惯用语句可能对某些人来说显得过于冗长，尤其是如果你来自具有正式异常机制的语言。然而，这里的收益是程序可以构建一个健壮的执行流程，程序员始终知道错误可能来自何处，并适当地处理它们。
