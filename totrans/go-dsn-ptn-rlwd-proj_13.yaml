- en: Chapter 12. Code Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a critical ritual of modern software development practices. Go brings
    testing directly into the development cycle by offering an API and command-line
    tool to seamlessly create and integrate automated test code. Here we will cover
    the Go testing suite, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The Go test tool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Go tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test coverage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code benchmark
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go test tool
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to writing any test code, let''s take a detour to discuss the tooling
    for automated testing in Go. Similar to the `go build` command, the `go test`
    command is designed to compile and exercise test source files in specified packages,
    as illustrated in the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous command will exercise all test functions in the current package.
    Although it appears to be simple, the previous command accomplishes several complex
    steps, including:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The compilation of all test files found in the current package
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an instrumented binary from the test file
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the test functions in the code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `go test` command targets multiple packages, the test tool generates
    multiple test binaries that are executed and tested independently, as shown in
    the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Test file names
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test command uses the import path standard (see [Chapter 6](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 6. Go Packages and Programs"), *Go Packages and Programs*) to specify
    which packages to test. Within a specified package, the test tool will compile
    all files with the `*_test.go` name pattern. For instance, assuming that we have
    a project that has a simple implementation of a mathematical vector type in a
    file called `vec.go`, a sensible name for its test file would be `vec_test.go`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Test organization
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, test files are kept in the same package (directory) as the code
    being tested. This is because there is no need to separate tests files, as they
    are excluded from the compiled program binary. The following shows the directory
    layout for a typical Go package, in this instance the `fmt` package from the standard
    library. It shows all of the test files for the package in the same directory
    as the regular source code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Besides having a simpler project structure, keeping the files together gives
    test functions full visibility of the package being tested. This facilitates access
    to and verification of package elements that would otherwise be opaque to testing
    code. When your functions are placed in a separate package from the code to be
    tested, they lose access to non-exported elements of the code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Writing Go tests
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The test functions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test source code in file `vec_test.go` defines a series of functions that
    exercise the behavior of type `SimpleVector` (see the preceding section) by testing
    each of its methods independently:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the tests
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the introductory section of this chapter, test functions are
    executed using the `go test` command-line tool. For instance, if we run the following
    command from within the package vector, it will automatically run all of the test
    functions of that package:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The test can also be executed by specifying a sub-package (or all packages
    with package wildcard `./...`) relative to where the command is issued, as shown
    in the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Filtering executed tests
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During the development of a large set of test functions, it is often desirable
    to focus on a function (or set of functions) during debugging phases. The Go test
    command-line tool supports the `-run` flag, which specifies a regular expression
    that executes only functions whose names match the specified expression. The following
    command will only execute test function `TestVectorAdd`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The use of the `-v` flag confirms that only one test function, `TestVectorAdd`,
    has been executed. As another example, the following executes all test functions
    that end with `VectorA.*$` or match function name `TestVectorMag`, while ignoring
    everything else:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Test logging
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch12/vector/vec_test.go
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen previously, the Go test tool runs tests with minimal output unless
    there is a test failure. However, the tool will output test logs when the verbose
    flag `*-v*` is provided. For instance, running the following in package vector
    will mute all logging statements:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the verbose flag `-v` is provided, as shown in the following command,
    the test runtime prints the output of the logs as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reporting failure
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the Go test runtime considers a test a success if the test function
    runs and returns normally without a panic. For example, the following test function
    is broken, since its expected value is not properly calculated. The test runtime,
    however, will always report it as passing because it does not include any code
    to report the failure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch12/vec_test.go
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'This false positive condition may go unnoticed, especially if the verbose flag
    is turned off, minimizing any visual clues that it is broken:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One way the previous test can be fixed is by using the `Fail` method from type
    `testing.T` to signal failure, as shown in the following snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So now, when the test is executed, it correctly reports that it is broken,
    as shown in the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Type `testing.T` also offers `Fatal` and `Formatf` methods as a way of combining
    the logging of a message and the immediate termination of a test function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Skipping tests
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice the code is using the `Skipf` method, which is a combination of the
    methods `SkipNow` and `Logf` from type `testing.T`. When the test is executed
    without the environment variable, it outputs the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the environment variable is provided, as is done with the following Linux/Unix
    command, the test executes as expected (consult your OS on how to set environment
    variables):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Table-driven tests
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One technique you often encounter in Go is the use of table-driven tests. This
    is where a set of input and expected output is stored in a data structure, which
    is then used to cycle through different test scenarios. For instance, in the following
    test function, the `cases` variable, of type `[]struct{vec SimpleVector; expected
    float64}`, to store several vector values and their expected magnitude values
    used to test the vector method `Mag`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，你经常会遇到的一种技术是使用表格驱动测试。这是指将一组输入和预期输出存储在数据结构中，然后使用它来循环不同的测试场景。例如，在下面的测试函数中，`cases`
    变量，其类型为 `[]struct{vec SimpleVector; expected float64}`，用于存储几个向量值及其预期的幅度值，用于测试向量方法
    `Mag`：
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: With each iteration of the loop, the code tests the value calculated by the
    `Mag` method against an expected value. Using this approach, we can test several
    combinations of input and their respective output, as is done in the preceding
    code. This technique can be expanded as necessary to include more parameters.
    For instance, a name field can be used to name each case, which is useful when
    the number of test cases is large. Or, to be even more fancy, one can include
    a function field in the test case struct to specify custom logic to use for each
    respective case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，代码都会将 `Mag` 方法计算出的值与预期值进行比较。使用这种方法，我们可以测试输入和它们各自的输出的多种组合，就像前面代码中所做的那样。根据需要，这种技术可以扩展以包括更多参数。例如，可以使用名称字段为每个案例命名，这在测试案例数量较多时很有用。或者，为了更加复杂，可以在测试案例结构体中包含一个函数字段，以指定为每个相应案例使用的自定义逻辑。
- en: HTTP testing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 测试
- en: '[PRE26]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch12/service/serv.go
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/service/serv.go
- en: Each function (`add`, `sub`, `dotprod`, `mag`, and `unit`) implements the `http.Handler`
    interface. The functions are used to handle HTTP requests from the client to calculate
    the respective operations from the `vector` package. Both requests and responses
    are formatted using JSON for simplicity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数（`add`、`sub`、`dotprod`、`mag` 和 `unit`）实现了 `http.Handler` 接口。这些函数用于处理来自客户端的
    HTTP 请求，并从 `vector` 包中计算相应的操作。请求和响应都使用 JSON 格式进行格式化，以简化处理。
- en: Testing HTTP server code
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 HTTP 服务器代码
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code uses `reg, err := http.NewRequest("POST", "http://0.0.0.0/", strings.NewReader(reqBody))`
    to create a new `*http.Request` value with a `"POST"` method, a fake URL, and
    a request body, variable `reqBody`, encoded as a JSON array. Later in the code,
    `w := httptest.NewRecorder()` is used to create an `httputil.ResponseRecorder`
    value, which is used to invoke the `add(w, req)` function along with the created
    request. The value recorded in `w`, during the execution of function `add`, is
    compared with expected value stored in `atual` with `if actual.String() != strings.TrimSpace(w.Body.String()){...}.`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `reg, err := http.NewRequest("POST", "http://0.0.0.0/", strings.NewReader(reqBody))`
    创建一个新的 `"POST"` 方法的 `*http.Request` 值，一个假 URL，以及一个请求体变量 `reqBody`，该请求体被编码为 JSON
    数组。在代码的后面部分，`w := httptest.NewRecorder()` 用于创建一个 `httputil.ResponseRecorder` 值，该值用于调用
    `add(w, req)` 函数以及创建的请求。在 `add` 函数执行期间记录在 `w` 中的值与存储在 `atual` 中的预期值通过 `if actual.String()
    != strings.TrimSpace(w.Body.String()){...}` 进行比较。
- en: Testing HTTP client code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 HTTP 客户端代码
- en: Creating test code for an HTTP client is more involved, since you actually need
    a server running for proper testing. Luckily, package `httptest` provides type
    `httptest.Server` to programmatically create servers to test client requests and
    send back mock responses to the client.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为 HTTP 客户端编写测试代码更为复杂，因为你实际上需要一个正在运行的服务器来进行适当的测试。幸运的是，`httptest` 包提供了 `httptest.Server`
    类型，可以用来程序化地创建服务器以测试客户端请求，并向客户端发送模拟响应。
- en: 'To illustrate, let us consider the following code, which partially shows the
    implementation of an HTTP client to the vector server presented earlier (see the
    full code listing at [https://github.com/vladimirvivien/learning-go/ch12/client/client.go](https://github.com/vladimirvivien/learning-go/ch12/client/client.go)).
    The `add` method encodes the parameters `vec0` and `vec2` of type `vector.SimpleVector`
    as JSON objects, which are sent to the server using `c.client.Do(req)`. The response
    is decoded from the JSON array into type `vector.SimpleVector` assigned to variable
    `result`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们考虑以下代码，它部分展示了之前提到的向量服务器 HTTP 客户端的实现（请参阅完整的代码列表[https://github.com/vladimirvivien/learning-go/ch12/client/client.go](https://github.com/vladimirvivien/learning-go/ch12/client/client.go)）。`add`
    方法将 `vec0` 和 `vec2` 参数编码为 JSON 对象，这些对象通过 `c.client.Do(req)` 发送到服务器。响应从 JSON 数组解码到类型为
    `vector.SimpleVector` 的变量 `result`：
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: golang.fyi/ch12/client/client.go
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/client/client.go
- en: We can use type `httptest.Server` to create code to test the requests sent by
    a client and to return data to the client code for further inspection. Function
    `httptest.NewServer` takes a value of type `http.Handler`, where the test logic
    for the server is encapsulated. The function then returns a new running HTTP server
    ready to serve on a system-selected port.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类型`httptest.Server`来创建测试客户端发送的请求的代码，并将数据返回给客户端代码以进行进一步检查。函数`httptest.NewServer`接受一个类型为`http.Handler`的值，其中封装了服务器的测试逻辑。然后该函数返回一个新的正在运行的HTTP服务器，准备在系统选择的端口上提供服务。
- en: 'The following test function shows how to use `httptest.Server` to exercise
    the `add` method from the client code presented earlier. Notice that when creating
    the server, the code uses type `http.HandlerFunc`, which is an adapter that takes
    a function value to produce an `http.Handler`. This convenience allows us to skip
    the creation of a separate type to implement a new `http.Handler`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试函数展示了如何使用`httptest.Server`来测试前面展示的客户端代码中的`add`方法。请注意，在创建服务器时，代码使用类型`http.HandlerFunc`，这是一个适配器，它接受一个函数值以生成一个`http.Handler`。这种便利性允许我们跳过创建一个单独的类型来实现新的`http.Handler`：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch12/client/client_test.go
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/client/client_test.go
- en: The test function first sets up the `server` along with its handler function.
    Inside the function of `http.HandlerFunc`, the code first ensures that the client
    requests the proper path of `"/vec/add"`. Next, the code inspects the request
    body from the client, ensuring proper JSON format and valid parameters for the
    add operation. Finally, the handler function encodes the expected result as JSON
    and sends it as a response to the client.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数首先设置`server`及其处理函数。在`http.HandlerFunc`的函数内部，代码首先确保客户端请求正确的路径`"/vec/add"`。接下来，代码检查客户端的请求体，确保适当的JSON格式和加法操作的参数有效。最后，处理函数将预期的结果编码为JSON，并将其作为响应发送给客户端。
- en: The code uses the system-generated `server` address to create a new `client`
    with `newVecClient(server.URL)`. Method call `client.add(vector.New(1, 2), vector.New(3,
    4))` sends a request to the test server to calculate the vector addition of the
    two values in its parameter list. As shown earlier, the test server merely simulates
    the real server code and returns the calculated vector value. The `result` is
    inspected against the `expected` value to ensure proper working of the `add` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用系统生成的`server`地址通过`newVecClient(server.URL)`创建一个新的`client`。方法调用`client.add(vector.New(1,
    2), vector.New(3, 4))`向测试服务器发送请求，以计算其参数列表中两个值的向量加法。如前所述，测试服务器仅模拟真实服务器的代码，并返回计算出的向量值。`result`与`expected`值进行比较，以确保`add`方法正常工作。
- en: Test coverage
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: When writing tests, it is often important to know how much of the actual code
    is getting exercised (or covered) by the tests. That number is an indication of
    the penetration of the test logic against the source code. Whether you agree or
    not, in many software development practices, test coverage is a critical metric
    as it is a measure of how well the code is tested.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，了解实际代码中有多少被测试（或覆盖）是很重要的。这个数字是测试逻辑对源代码渗透程度的指示。无论你是否同意，在许多软件开发实践中，测试覆盖率是一个关键的指标，因为它衡量了代码被测试的程度。
- en: 'Fortunately, the Go test tool comes with a built-in coverage tool. Running
    the Go test command with the `-cover` flag instruments the original source code
    with coverage logic. It then runs the generated test binary, providing a summary
    of the overall coverage profile of the package, as shown in the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go测试工具自带了一个内置的覆盖率工具。使用带有`-cover`标志的Go测试命令会对原始源代码进行覆盖率逻辑的配置。然后运行生成的测试二进制文件，提供包的整体覆盖率概要，如下所示：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result shows a well-tested code with a coverage number of `87.8%`. We can
    use the test tool to extract more details about the section of the code that is
    tested. To do this, we use the `-coverprofile` flag to record coverage metrics
    to a file, as shown:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，代码经过良好测试，覆盖率为`87.8%`。我们可以使用测试工具提取有关测试代码部分的更多详细信息。为此，我们使用`-coverprofile`标志将覆盖率指标记录到文件中，如下所示：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The cover tool
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖工具
- en: 'Once the coverage data is saved, it can be presented in a textual tab-formatted
    table using the `go tool cover` command. The following shows a partial output
    of the breakdown of the coverage metrics for each tested function in the coverage
    file generated previously:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦覆盖率数据被保存，可以使用`go tool cover`命令以文本表格格式展示。以下显示了之前生成的覆盖率文件中每个测试函数覆盖率分解的部分输出：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `cover` tool can overlay the coverage metrics over the actual code, providing
    a visual aid to show the covered (and uncovered) portion of the code. Use the
    `-html` flag to generate an HTML page using the coverage data gathered previously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`cover` 工具可以将覆盖率指标叠加到实际代码上，提供视觉辅助来显示代码的已覆盖（和未覆盖）部分。使用 `-html` 标志可以生成一个使用之前收集的覆盖率数据的
    HTML 页面：'
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The command opens the installed default web browser and displays the coverage
    data, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将打开已安装的默认网页浏览器并显示覆盖率数据，如下面的截图所示：
- en: '![The cover tool](img/00029.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![The cover tool](img/00029.jpeg)'
- en: The preceding screenshot shows only a portion of the generated HTML page. It
    shows covered code in green and code that is not covered in red. Anything else
    is displayed in gray.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图仅显示了生成的 HTML 页面的一部分。它显示了绿色的已覆盖代码和红色的未覆盖代码。其他内容以灰色显示。
- en: Code benchmark
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码基准
- en: 'The purpose of benchmarking is to measure a code''s performance. The Go test
    command-line tool comes with support for the automated generation and measurement
    of benchmark metrics. Similar to unit tests, the test tool uses benchmark functions
    to specify what portion of the code to measure. The benchmark function uses the
    following function naming pattern and signature:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的目的是衡量代码的性能。Go 测试命令行工具支持自动生成和测量基准指标。与单元测试类似，测试工具使用基准函数来指定要测量的代码部分。基准函数使用以下函数命名模式和签名：
- en: '*func Benchmark<Name>(*testing.B)*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*func Benchmark<Name>(*testing.B)*'
- en: 'Benchmark functions are expected to have names that start with *benchmark*
    and accept a pointer value of type `*testing.B`. The following shows a function
    that benchmarks the `Add` method for type `SimpleVector` (introduced earlier):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基准函数的预期名称应以 *benchmark* 开头，并接受类型为 `*testing.B` 的指针值。以下是一个基准测试 `SimpleVector`
    类型的 `Add` 方法（之前已介绍）的函数：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: golang.fyi/ch12/vector/vec_bench_test.go
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec_bench_test.go
- en: Go's test runtime invokes the benchmark functions by injecting pointer `*testing.B`
    as a parameter. That value defines methods for interacting with the benchmark
    framework such as logging, failure-signaling, and other functionalities similar
    to type `testing.T`. Type `testing.B` also offers additional benchmark-specific
    elements, including an integer field `N`. It is intended to be the number of iterations
    that the benchmark function should use for effective measurements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的测试运行时通过注入指针 `*testing.B` 作为参数来调用基准函数。该值定义了与基准框架交互的方法，例如日志记录、失败信号和其他类似于 `testing.T`
    类型的功能。类型 `testing.B` 还提供了额外的基准特定元素，包括一个整数字段 `N`。它打算用作基准函数应使用的迭代次数，以进行有效的测量。
- en: The code being benchmarked should be placed within a `for` loop bounded by `N`,
    as illustrated in the previous example. For the benchmark to be effective, there
    should be no variances in the size of the input for each iteration of the loop.
    For instance, in the preceding benchmark, each iteration always uses a vector
    of size `2` (while the actual values of the vectors are randomized).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 被基准测试的代码应放置在由 `N` 界定的 `for` 循环内，如前一个示例所示。为了使基准测试有效，循环每次迭代的输入大小不应有差异。例如，在先前的基准测试中，每次迭代始终使用大小为
    `2` 的向量（而向量的实际值是随机化的）。
- en: Running the benchmark
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: 'Benchmark functions are not executed unless the test command-line tool receives
    the flag `-bench`. The following command runs all the benchmarks functions in
    the current package:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基准函数只有在测试命令行工具接收到 `-bench` 标志时才会执行。以下命令运行当前包中的所有基准函数：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Before dissecting the benchmark result, let us understand the previously issued
    command. The `go test -bench=.` command first executes all the test functions
    in the package followed by all the benchmark functions (you can verify this by
    adding the verbose flag `-v` to the command).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析基准测试结果之前，让我们了解之前发出的命令。`go test -bench=.` 命令首先执行包中的所有测试函数，然后是所有基准函数（你可以通过在命令中添加详细标志
    `-v` 来验证这一点）。
- en: 'Similar to the `-run` flag, the `-bench` flag specifies a regular expression
    used to select the benchmark functions that get executed. The `-bench=.` flag
    matches the name of all benchmark functions, as shown in the previous example.
    The following, however, only runs benchmark functions that contain the pattern
    `"VectorA"` in their names. This includes the `BenchmarkVectroAngle()` and `BenchmarkVectorAngle()` functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Skipping test functions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, when benchmarks are executed, the test tool will also
    run all test functions. This may be undesirable, especially if you have a large
    number of tests in your package. A simple way to skip the test functions during
    benchmark execution is to set the `-run` flag to a value that matches no test
    functions, as shown in the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous command only executes benchmark functions, as shown by the partial
    verbose output. The value of the `-run` flag is completely arbitrary and can be
    set to any value that will cause it to skip the execution of test functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The benchmark report
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike tests, a benchmark report is always verbose and displays several columns
    of metrics, as shown in the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first column contains the names of the benchmark functions, with each name
    suffixed with a number that reflects the value of *GOMAXPROCS*, which can be set
    at test time using the `-cpu` flag (relevant for running benchmarks in parallel).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The next column displays the number of iterations for each benchmark loop. For
    instance, in the previous report, the first two benchmark functions looped 2 million
    times, while the final benchmark function iterated 5 million times. The last column
    of the report shows the average time it takes to execute the tested function.
    For instance, the 5 million calls to the `Scale` method executed in benchmark
    function `BenchmarkVectorScale` took on average 266 nanoseconds to complete.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting N
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the test framework gradually adjusts `N` to be large enough to
    arrive at stable and meaningful metrics over a period of *one second*. You cannot
    change `N` directly. However, you can use flag `-benchtime` to specify a benchmark
    run time and thus influence the number of iterations during a benchmark. For instance,
    the following runs the benchmark for a period of `5` seconds:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that even though there is a drastic jump in the number iterations (factor
    of five or more) for each benchmark, the average performance time for each benchmark
    function remains reasonably consistent. This information provides valuable insight
    into the performance of your code. It is a great way to observe the impact of
    code or load changes on performance, as discussed in the following section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Comparative benchmarks
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful aspect of benchmarking code is to compare the performance of
    different algorithms that implement similar functionalities. Exercising the algorithms
    using performance benchmarks will indicate which of the implementations may be
    more compute- and memory-efficient.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试代码的另一个有用方面是对比实现类似功能的不同算法的性能。使用性能基准测试算法将表明哪些实现可能更计算和内存高效。
- en: 'For instance, two vectors are said to be equal if they have the same magnitude
    and same direction (or have an angle value of zero between them). We can implement
    this definition using the following source snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果两个向量具有相同的幅度和相同的方向（或者它们之间有一个零角度值），则称这两个向量相等。我们可以使用以下源代码片段来实现这个定义：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: 'When the preceding method is benchmarked, it yields to the following result.
    Each of its 3 million iterations takes an average of half a millisecond to run:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的方法进行基准测试时，它产生了以下结果。它的每300万次迭代平均运行时间为半个毫秒：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The benchmark result is not bad, especially when compared to the other benchmarked
    methods that we saw earlier. However, suppose we want to improve on the performance
    of the `Eq` method (maybe because it is a critical part of a program). We can
    use the `-benchmem` flag to get additional information about the benchmarked test:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果并不差，特别是与之前看到的其他基准测试方法相比。然而，如果我们想提高 `Eq` 方法的性能（可能是因为它是程序的一个关键部分），我们可以使用
    `-benchmem` 标志来获取有关基准测试测试的更多信息：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `-benchmem` flag causes the test tool to reveal two additional columns,
    which provide memory allocation metrics, as shown in the previous output. We see
    that the `Eq` method allocates a total of 48 bytes, with two allocations calls
    per operation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`-benchmem` 标志会导致测试工具显示两列额外的信息，这些信息提供了内存分配的指标，如前一个输出所示。我们看到 `Eq` 方法总共分配了 48
    字节，每个操作有两次分配调用。'
- en: 'This does not tell us much until we have something else to compare it to. Fortunately,
    there is another equality algorithm that we can try. It is based on the fact that
    two vectors are also equal if they have the same number of elements and each element
    is equal. This definition can be implemented by traversing the vector and comparing
    its elements, as is done in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们没有其他东西可以与之比较之前，这并没有告诉我们太多。幸运的是，还有一个我们可以尝试的相等性算法。这个算法基于这样一个事实：如果两个向量具有相同数量的元素，并且每个元素都相等，那么这两个向量也是相等的。这个定义可以通过遍历向量并比较其元素来实现，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: 'Now let us benchmark the `Eq` and `Eq2` equality methods to see which is more
    performant, as done in the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来基准测试 `Eq` 和 `Eq2` 相等性方法，看看哪个更高效，如下所示：
- en: '[PRE46]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: According to the benchmark report, method `Eq2` is more performant of the two
    equality methods. It runs in about half the time of the original method, with
    considerably less memory allocated. Since both benchmarks run with similar input
    data, we can confidently say the second method is a better choice than the first.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基准报告，方法 `Eq2` 在两个相等性方法中表现更优。它运行时间大约是原始方法的一半，分配的内存也少得多。由于这两个基准测试都使用了类似的数据输入，我们可以有信心地说第二个方法比第一个方法更好。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on Go version and machine size and architecture, these benchmark numbers
    will vary. However, the result will always show that the Eq2 method is more performant.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Go版本、机器大小和架构的不同，这些基准测试数字会有所变化。然而，结果总是显示 Eq2 方法更高效。
- en: This discussion only scratches the surface of comparative benchmarks. For instance,
    the previous benchmark tests use the same size input. Sometimes it is useful to
    observe the change in performance as the input size changes. We could have compared
    the performance profile of the equality method as we change the size of the input,
    say, from 3, 10, 20, or 30 elements. If the algorithm is sensitive size, expanding
    the benchmark using such attributes will reveal any bottlenecks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段讨论只是比较基准测试的表面。例如，之前的基准测试使用相同大小的输入。有时观察输入大小变化时的性能变化是有用的。我们可以比较相等性方法在输入大小从3、10、20或30个元素变化时的性能曲线。如果算法对大小敏感，使用这样的属性扩展基准测试将揭示任何瓶颈。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a broad introduction to the practice of writing tests
    in Go. It discussed several key topics, including the use of the `go test` tool
    to compile and execute automated tests. Readers learned how to write test functions
    to ensure their code is properly tested and covered. The chapter also discussed
    the topic of testing HTTP clients and servers. Finally, the chapter introduced
    the topic of benchmarking as a way to automate, analyze, and measure code performance
    using built-in Go tools.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了对Go语言中编写测试实践的广泛介绍。它讨论了几个关键主题，包括使用`go test`工具来编译和执行自动化测试。读者学习了如何编写测试函数以确保他们的代码得到适当的测试和覆盖。本章还讨论了测试HTTP客户端和服务器的话题。最后，本章介绍了基准测试作为使用内置Go工具自动化、分析和衡量代码性能的一种方法。
