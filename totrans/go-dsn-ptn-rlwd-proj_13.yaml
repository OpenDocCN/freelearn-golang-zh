- en: Chapter 12. Code Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a critical ritual of modern software development practices. Go brings
    testing directly into the development cycle by offering an API and command-line
    tool to seamlessly create and integrate automated test code. Here we will cover
    the Go testing suite, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go test tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Go tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code benchmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go test tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to writing any test code, let''s take a detour to discuss the tooling
    for automated testing in Go. Similar to the `go build` command, the `go test`
    command is designed to compile and exercise test source files in specified packages,
    as illustrated in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will exercise all test functions in the current package.
    Although it appears to be simple, the previous command accomplishes several complex
    steps, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The compilation of all test files found in the current package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an instrumented binary from the test file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the test functions in the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `go test` command targets multiple packages, the test tool generates
    multiple test binaries that are executed and tested independently, as shown in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Test file names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test command uses the import path standard (see [Chapter 6](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 6. Go Packages and Programs"), *Go Packages and Programs*) to specify
    which packages to test. Within a specified package, the test tool will compile
    all files with the `*_test.go` name pattern. For instance, assuming that we have
    a project that has a simple implementation of a mathematical vector type in a
    file called `vec.go`, a sensible name for its test file would be `vec_test.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Test organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, test files are kept in the same package (directory) as the code
    being tested. This is because there is no need to separate tests files, as they
    are excluded from the compiled program binary. The following shows the directory
    layout for a typical Go package, in this instance the `fmt` package from the standard
    library. It shows all of the test files for the package in the same directory
    as the regular source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Besides having a simpler project structure, keeping the files together gives
    test functions full visibility of the package being tested. This facilitates access
    to and verification of package elements that would otherwise be opaque to testing
    code. When your functions are placed in a separate package from the code to be
    tested, they lose access to non-exported elements of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Go tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec.go
  prefs: []
  type: TYPE_NORMAL
- en: The test functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test source code in file `vec_test.go` defines a series of functions that
    exercise the behavior of type `SimpleVector` (see the preceding section) by testing
    each of its methods independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the introductory section of this chapter, test functions are
    executed using the `go test` command-line tool. For instance, if we run the following
    command from within the package vector, it will automatically run all of the test
    functions of that package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The test can also be executed by specifying a sub-package (or all packages
    with package wildcard `./...`) relative to where the command is issued, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Filtering executed tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During the development of a large set of test functions, it is often desirable
    to focus on a function (or set of functions) during debugging phases. The Go test
    command-line tool supports the `-run` flag, which specifies a regular expression
    that executes only functions whose names match the specified expression. The following
    command will only execute test function `TestVectorAdd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the `-v` flag confirms that only one test function, `TestVectorAdd`,
    has been executed. As another example, the following executes all test functions
    that end with `VectorA.*$` or match function name `TestVectorMag`, while ignoring
    everything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Test logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec_test.go
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen previously, the Go test tool runs tests with minimal output unless
    there is a test failure. However, the tool will output test logs when the verbose
    flag `*-v*` is provided. For instance, running the following in package vector
    will mute all logging statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the verbose flag `-v` is provided, as shown in the following command,
    the test runtime prints the output of the logs as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reporting failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the Go test runtime considers a test a success if the test function
    runs and returns normally without a panic. For example, the following test function
    is broken, since its expected value is not properly calculated. The test runtime,
    however, will always report it as passing because it does not include any code
    to report the failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vec_test.go
  prefs: []
  type: TYPE_NORMAL
- en: 'This false positive condition may go unnoticed, especially if the verbose flag
    is turned off, minimizing any visual clues that it is broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'One way the previous test can be fixed is by using the `Fail` method from type
    `testing.T` to signal failure, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, when the test is executed, it correctly reports that it is broken,
    as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec.go
  prefs: []
  type: TYPE_NORMAL
- en: Type `testing.T` also offers `Fatal` and `Formatf` methods as a way of combining
    the logging of a message and the immediate termination of a test function.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the code is using the `Skipf` method, which is a combination of the
    methods `SkipNow` and `Logf` from type `testing.T`. When the test is executed
    without the environment variable, it outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the environment variable is provided, as is done with the following Linux/Unix
    command, the test executes as expected (consult your OS on how to set environment
    variables):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Table-driven tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One technique you often encounter in Go is the use of table-driven tests. This
    is where a set of input and expected output is stored in a data structure, which
    is then used to cycle through different test scenarios. For instance, in the following
    test function, the `cases` variable, of type `[]struct{vec SimpleVector; expected
    float64}`, to store several vector values and their expected magnitude values
    used to test the vector method `Mag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec.go
  prefs: []
  type: TYPE_NORMAL
- en: With each iteration of the loop, the code tests the value calculated by the
    `Mag` method against an expected value. Using this approach, we can test several
    combinations of input and their respective output, as is done in the preceding
    code. This technique can be expanded as necessary to include more parameters.
    For instance, a name field can be used to name each case, which is useful when
    the number of test cases is large. Or, to be even more fancy, one can include
    a function field in the test case struct to specify custom logic to use for each
    respective case.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/service/serv.go
  prefs: []
  type: TYPE_NORMAL
- en: Each function (`add`, `sub`, `dotprod`, `mag`, and `unit`) implements the `http.Handler`
    interface. The functions are used to handle HTTP requests from the client to calculate
    the respective operations from the `vector` package. Both requests and responses
    are formatted using JSON for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Testing HTTP server code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code uses `reg, err := http.NewRequest("POST", "http://0.0.0.0/", strings.NewReader(reqBody))`
    to create a new `*http.Request` value with a `"POST"` method, a fake URL, and
    a request body, variable `reqBody`, encoded as a JSON array. Later in the code,
    `w := httptest.NewRecorder()` is used to create an `httputil.ResponseRecorder`
    value, which is used to invoke the `add(w, req)` function along with the created
    request. The value recorded in `w`, during the execution of function `add`, is
    compared with expected value stored in `atual` with `if actual.String() != strings.TrimSpace(w.Body.String()){...}.`
  prefs: []
  type: TYPE_NORMAL
- en: Testing HTTP client code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating test code for an HTTP client is more involved, since you actually need
    a server running for proper testing. Luckily, package `httptest` provides type
    `httptest.Server` to programmatically create servers to test client requests and
    send back mock responses to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let us consider the following code, which partially shows the
    implementation of an HTTP client to the vector server presented earlier (see the
    full code listing at [https://github.com/vladimirvivien/learning-go/ch12/client/client.go](https://github.com/vladimirvivien/learning-go/ch12/client/client.go)).
    The `add` method encodes the parameters `vec0` and `vec2` of type `vector.SimpleVector`
    as JSON objects, which are sent to the server using `c.client.Do(req)`. The response
    is decoded from the JSON array into type `vector.SimpleVector` assigned to variable
    `result`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/client/client.go
  prefs: []
  type: TYPE_NORMAL
- en: We can use type `httptest.Server` to create code to test the requests sent by
    a client and to return data to the client code for further inspection. Function
    `httptest.NewServer` takes a value of type `http.Handler`, where the test logic
    for the server is encapsulated. The function then returns a new running HTTP server
    ready to serve on a system-selected port.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test function shows how to use `httptest.Server` to exercise
    the `add` method from the client code presented earlier. Notice that when creating
    the server, the code uses type `http.HandlerFunc`, which is an adapter that takes
    a function value to produce an `http.Handler`. This convenience allows us to skip
    the creation of a separate type to implement a new `http.Handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/client/client_test.go
  prefs: []
  type: TYPE_NORMAL
- en: The test function first sets up the `server` along with its handler function.
    Inside the function of `http.HandlerFunc`, the code first ensures that the client
    requests the proper path of `"/vec/add"`. Next, the code inspects the request
    body from the client, ensuring proper JSON format and valid parameters for the
    add operation. Finally, the handler function encodes the expected result as JSON
    and sends it as a response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the system-generated `server` address to create a new `client`
    with `newVecClient(server.URL)`. Method call `client.add(vector.New(1, 2), vector.New(3,
    4))` sends a request to the test server to calculate the vector addition of the
    two values in its parameter list. As shown earlier, the test server merely simulates
    the real server code and returns the calculated vector value. The `result` is
    inspected against the `expected` value to ensure proper working of the `add` method.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests, it is often important to know how much of the actual code
    is getting exercised (or covered) by the tests. That number is an indication of
    the penetration of the test logic against the source code. Whether you agree or
    not, in many software development practices, test coverage is a critical metric
    as it is a measure of how well the code is tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the Go test tool comes with a built-in coverage tool. Running
    the Go test command with the `-cover` flag instruments the original source code
    with coverage logic. It then runs the generated test binary, providing a summary
    of the overall coverage profile of the package, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result shows a well-tested code with a coverage number of `87.8%`. We can
    use the test tool to extract more details about the section of the code that is
    tested. To do this, we use the `-coverprofile` flag to record coverage metrics
    to a file, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The cover tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the coverage data is saved, it can be presented in a textual tab-formatted
    table using the `go tool cover` command. The following shows a partial output
    of the breakdown of the coverage metrics for each tested function in the coverage
    file generated previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cover` tool can overlay the coverage metrics over the actual code, providing
    a visual aid to show the covered (and uncovered) portion of the code. Use the
    `-html` flag to generate an HTML page using the coverage data gathered previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The command opens the installed default web browser and displays the coverage
    data, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The cover tool](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows only a portion of the generated HTML page. It
    shows covered code in green and code that is not covered in red. Anything else
    is displayed in gray.
  prefs: []
  type: TYPE_NORMAL
- en: Code benchmark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of benchmarking is to measure a code''s performance. The Go test
    command-line tool comes with support for the automated generation and measurement
    of benchmark metrics. Similar to unit tests, the test tool uses benchmark functions
    to specify what portion of the code to measure. The benchmark function uses the
    following function naming pattern and signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '*func Benchmark<Name>(*testing.B)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Benchmark functions are expected to have names that start with *benchmark*
    and accept a pointer value of type `*testing.B`. The following shows a function
    that benchmarks the `Add` method for type `SimpleVector` (introduced earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec_bench_test.go
  prefs: []
  type: TYPE_NORMAL
- en: Go's test runtime invokes the benchmark functions by injecting pointer `*testing.B`
    as a parameter. That value defines methods for interacting with the benchmark
    framework such as logging, failure-signaling, and other functionalities similar
    to type `testing.T`. Type `testing.B` also offers additional benchmark-specific
    elements, including an integer field `N`. It is intended to be the number of iterations
    that the benchmark function should use for effective measurements.
  prefs: []
  type: TYPE_NORMAL
- en: The code being benchmarked should be placed within a `for` loop bounded by `N`,
    as illustrated in the previous example. For the benchmark to be effective, there
    should be no variances in the size of the input for each iteration of the loop.
    For instance, in the preceding benchmark, each iteration always uses a vector
    of size `2` (while the actual values of the vectors are randomized).
  prefs: []
  type: TYPE_NORMAL
- en: Running the benchmark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Benchmark functions are not executed unless the test command-line tool receives
    the flag `-bench`. The following command runs all the benchmarks functions in
    the current package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Before dissecting the benchmark result, let us understand the previously issued
    command. The `go test -bench=.` command first executes all the test functions
    in the package followed by all the benchmark functions (you can verify this by
    adding the verbose flag `-v` to the command).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `-run` flag, the `-bench` flag specifies a regular expression
    used to select the benchmark functions that get executed. The `-bench=.` flag
    matches the name of all benchmark functions, as shown in the previous example.
    The following, however, only runs benchmark functions that contain the pattern
    `"VectorA"` in their names. This includes the `BenchmarkVectroAngle()` and `BenchmarkVectorAngle()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Skipping test functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, when benchmarks are executed, the test tool will also
    run all test functions. This may be undesirable, especially if you have a large
    number of tests in your package. A simple way to skip the test functions during
    benchmark execution is to set the `-run` flag to a value that matches no test
    functions, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The previous command only executes benchmark functions, as shown by the partial
    verbose output. The value of the `-run` flag is completely arbitrary and can be
    set to any value that will cause it to skip the execution of test functions.
  prefs: []
  type: TYPE_NORMAL
- en: The benchmark report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike tests, a benchmark report is always verbose and displays several columns
    of metrics, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first column contains the names of the benchmark functions, with each name
    suffixed with a number that reflects the value of *GOMAXPROCS*, which can be set
    at test time using the `-cpu` flag (relevant for running benchmarks in parallel).
  prefs: []
  type: TYPE_NORMAL
- en: The next column displays the number of iterations for each benchmark loop. For
    instance, in the previous report, the first two benchmark functions looped 2 million
    times, while the final benchmark function iterated 5 million times. The last column
    of the report shows the average time it takes to execute the tested function.
    For instance, the 5 million calls to the `Scale` method executed in benchmark
    function `BenchmarkVectorScale` took on average 266 nanoseconds to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting N
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the test framework gradually adjusts `N` to be large enough to
    arrive at stable and meaningful metrics over a period of *one second*. You cannot
    change `N` directly. However, you can use flag `-benchtime` to specify a benchmark
    run time and thus influence the number of iterations during a benchmark. For instance,
    the following runs the benchmark for a period of `5` seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that even though there is a drastic jump in the number iterations (factor
    of five or more) for each benchmark, the average performance time for each benchmark
    function remains reasonably consistent. This information provides valuable insight
    into the performance of your code. It is a great way to observe the impact of
    code or load changes on performance, as discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparative benchmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful aspect of benchmarking code is to compare the performance of
    different algorithms that implement similar functionalities. Exercising the algorithms
    using performance benchmarks will indicate which of the implementations may be
    more compute- and memory-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, two vectors are said to be equal if they have the same magnitude
    and same direction (or have an angle value of zero between them). We can implement
    this definition using the following source snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preceding method is benchmarked, it yields to the following result.
    Each of its 3 million iterations takes an average of half a millisecond to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The benchmark result is not bad, especially when compared to the other benchmarked
    methods that we saw earlier. However, suppose we want to improve on the performance
    of the `Eq` method (maybe because it is a critical part of a program). We can
    use the `-benchmem` flag to get additional information about the benchmarked test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `-benchmem` flag causes the test tool to reveal two additional columns,
    which provide memory allocation metrics, as shown in the previous output. We see
    that the `Eq` method allocates a total of 48 bytes, with two allocations calls
    per operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not tell us much until we have something else to compare it to. Fortunately,
    there is another equality algorithm that we can try. It is based on the fact that
    two vectors are also equal if they have the same number of elements and each element
    is equal. This definition can be implemented by traversing the vector and comparing
    its elements, as is done in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us benchmark the `Eq` and `Eq2` equality methods to see which is more
    performant, as done in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: According to the benchmark report, method `Eq2` is more performant of the two
    equality methods. It runs in about half the time of the original method, with
    considerably less memory allocated. Since both benchmarks run with similar input
    data, we can confidently say the second method is a better choice than the first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on Go version and machine size and architecture, these benchmark numbers
    will vary. However, the result will always show that the Eq2 method is more performant.
  prefs: []
  type: TYPE_NORMAL
- en: This discussion only scratches the surface of comparative benchmarks. For instance,
    the previous benchmark tests use the same size input. Sometimes it is useful to
    observe the change in performance as the input size changes. We could have compared
    the performance profile of the equality method as we change the size of the input,
    say, from 3, 10, 20, or 30 elements. If the algorithm is sensitive size, expanding
    the benchmark using such attributes will reveal any bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a broad introduction to the practice of writing tests
    in Go. It discussed several key topics, including the use of the `go test` tool
    to compile and execute automated tests. Readers learned how to write test functions
    to ensure their code is properly tested and covered. The chapter also discussed
    the topic of testing HTTP clients and servers. Finally, the chapter introduced
    the topic of benchmarking as a way to automate, analyze, and measure code performance
    using built-in Go tools.
  prefs: []
  type: TYPE_NORMAL
