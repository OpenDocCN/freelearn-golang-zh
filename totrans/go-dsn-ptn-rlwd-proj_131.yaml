- en: Deferring function calls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟函数调用
- en: 'Go supports the notion of deferring a function call. Placing the keyword `defer`
    before a function call has the interesting effect of pushing the function unto
    an internal stack, delaying its execution right before the enclosing function
    returns. To better explain this, let us start with the following simple program
    that illustrates the use of `defer`:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持延迟函数调用的概念。在函数调用之前放置关键字 `defer` 具有将函数推入内部栈的有趣效果，这会在封装函数返回之前延迟其执行。为了更好地解释这一点，让我们从以下简单的程序开始，该程序说明了
    `defer` 的用法：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch05/defer1.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/defer1.go
- en: 'The previous example defines the `do` function that takes variadic parameter
    `steps`. The function defers the statement with `defer fmt.Println("All done!")`.
    Next, the function loops through slice `steps` and defers the output of each element
    with `defer fmt.Println(s).` The last statement in the function `do` is a non-deferred
    call to `fmt.Println("Starting").` Notice the order of the printed string values
    when the program is executed, as shown in the following output:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子定义了一个 `do` 函数，它接受可变参数 `steps`。该函数使用 `defer fmt.Println("All done!")` 延迟执行语句。接下来，该函数遍历
    `steps` 切片，并使用 `defer fmt.Println(s)` 延迟输出每个元素。函数 `do` 中的最后一个语句是对 `fmt.Println("Starting")`
    的非延迟调用。注意程序执行时打印的字符串值的顺序，如下面的输出所示：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are a couple facts that explain the reverse order of the printout. First,
    recall that deferred functions are executed right before their enclosing function
    returns. Therefore, the first value printed is generated by the last non-deferred
    method call. Next, as stated earlier, deferred statements are pushed into a stack.
    Therefore, deferred calls are executed using a last-in-first-out order. That is
    why `"All done!"` is the last string value printed in the output.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个事实可以解释打印输出的反向顺序。首先，回想一下，延迟函数是在其封装函数返回之前执行的。因此，第一个打印的值是由最后一个非延迟方法调用生成的。其次，正如之前所述，延迟语句被推入一个栈中。因此，延迟调用是按照后进先出的顺序执行的。这就是为什么在输出中
    `"All done!"` 是最后一个打印的字符串值。
