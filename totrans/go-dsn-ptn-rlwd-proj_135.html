<html><head></head><body>
<div class="book" title="Function panic and recovery" id="164MG1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Function panic recovery"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec93" class="calibre1"/>Function panic recovery</h2></div></div></div><p class="calibre10">When a function panics, as explained earlier, it can crash an entire program. That may be the desired outcome depending on your requirements. It is possible, however, to regain control after a panic sequence has started. To do this, Go offers the built-in function called <code class="email">recover</code>.</p><p class="calibre10">Recover works in tandem with panic. A call to function recover returns the value that was passed as an argument to panic. The following code shows how to recover from the panic call that was introduced in the previous example. In this version, the write function is moved inside <code class="email">makeAnagram()</code> for clarity. When the <code class="email">write</code> function is invoked from <code class="email">makeAnagram() </code>and fails to open a file, it will panic. However, additional code is now added to recover:</p><pre class="programlisting">package main 
... 
func write(fname string, anagrams map[string][]string) { 
   file, err := os.OpenFile( 
         fname,  
         os.O_WRONLY+os.O_CREATE+os.O_EXCL,  
         0644, 
   ) 
   if err != nil { 
         msg := fmt.Sprintf( 
               "Unable to create output file: %v", err, 
         ) 
         panic(msg) 
   } 
   ... 
} 
 
func makeAnagrams(words []string, fname string) { 
   defer func() { 
         if r := recover(); r != nil { 
               fmt.Println("Failed to make anagram:", r) 
         } 
   }() 
 
   anagrams := mapWords(words) 
   write(fname, anagrams) 
} 
func main() { 
   words, err := load("") 
   if err != nil { 
         fmt.Println("Unable to load file:", err) 
         os.Exit(1) 
   } 
   makeAnagrams(words, "") 
} 
</pre><p class="calibre10">golang.fyi/ch05/anagram3.go</p><p class="calibre10">To be able to recover from an unwinding panic sequence, the code must make a deferred call to the recover function. In the previous code, this is done in the <code class="email">makeAnagrams</code> function by wrapping <code class="email">recover()</code> inside an anonymous function literal, as highlighted in the following snippet:</p><pre class="programlisting">defer func() { 
   if r := recover(); r != nil { 
         fmt.Println("Failed to make anagram:", r) 
   } 
}() 
</pre><p class="calibre10">When the deferred <code class="email">recover</code> function is executed, the program has an opportunity to regain control and prevent the panic from crashing the running program. If <code class="email">recover()</code> returns <code class="email">nil</code>, it means there is no current panic unwinding up the call stack or the panic was already handled downstream.</p><p class="calibre10">So, now when the program is executed, instead of crashing with a stack trace, the program recovers and gracefully displays the issue as shown in the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; go run anagram3.go</strong></span>
<span class="strong"><strong class="calibre2">Failed to make anagram: Unable to open output file for creation: open out.txt: file exists</strong></span>
</pre><div class="informaltable" title="Note"><h3 class="title2"><a id="note9" class="calibre1"/>Note</h3><p class="calibre10">You may be wondering why we are using a <code class="email">nil</code> to test the value returned by the <code class="email">recover</code> function when a string was passed inside the call to <code class="email">panic</code>. This is because both panic and recover take an empty interface type. As you will learn, the empty interface type is a generic type with the ability to represent any type in Go's type system. We will learn more about the empty interface in <a class="calibre1" title="Chapter 8. Methods, Interfaces, and Objects" href="part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 7</a>, <span class="strong"><em class="calibre11">Methods, Interfaces and Objects</em></span> during discussions about interfaces.</p></div></div></div></body></html>