- en: Function panic recovery
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数恐慌恢复
- en: When a function panics, as explained earlier, it can crash an entire program.
    That may be the desired outcome depending on your requirements. It is possible,
    however, to regain control after a panic sequence has started. To do this, Go
    offers the built-in function called `recover`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数恐慌时，如前所述，它可能会使整个程序崩溃。这可能是根据你的需求所期望的结果。然而，在恐慌序列开始后，仍然有可能恢复控制。为了做到这一点，Go提供了一个名为`recover`的内置函数。
- en: 'Recover works in tandem with panic. A call to function recover returns the
    value that was passed as an argument to panic. The following code shows how to
    recover from the panic call that was introduced in the previous example. In this
    version, the write function is moved inside `makeAnagram()` for clarity. When
    the `write` function is invoked from `makeAnagram()` and fails to open a file,
    it will panic. However, additional code is now added to recover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复与恐慌协同工作。对`recover`函数的调用返回传递给`panic`的值。以下代码展示了如何从上一个示例中引入的恐慌调用中恢复。在这个版本中，为了清晰起见，将`write`函数移动到了`makeAnagram()`内部。当从`makeAnagram()`调用`write`函数并无法打开文件时，它将引发恐慌。然而，现在还添加了额外的代码来恢复：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch05/anagram3.go
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/anagram3.go
- en: 'To be able to recover from an unwinding panic sequence, the code must make
    a deferred call to the recover function. In the previous code, this is done in
    the `makeAnagrams` function by wrapping `recover()` inside an anonymous function
    literal, as highlighted in the following snippet:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够从展开的恐慌序列中恢复，代码必须对恢复函数进行延迟调用。在之前的代码中，这是通过在`makeAnagrams`函数中将`recover()`包裹在匿名函数字面量中来实现的，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the deferred `recover` function is executed, the program has an opportunity
    to regain control and prevent the panic from crashing the running program. If
    `recover()` returns `nil`, it means there is no current panic unwinding up the
    call stack or the panic was already handled downstream.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当延迟的`recover`函数执行时，程序有机会恢复控制并防止恐慌导致正在运行的程序崩溃。如果`recover()`返回`nil`，则表示当前没有恐慌正在调用栈中展开，或者恐慌已经被下游处理。
- en: 'So, now when the program is executed, instead of crashing with a stack trace,
    the program recovers and gracefully displays the issue as shown in the following
    output:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在当程序执行时，而不是崩溃并显示堆栈跟踪，程序会恢复并优雅地显示问题，如下面的输出所示：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering why we are using a `nil` to test the value returned by
    the `recover` function when a string was passed inside the call to `panic`. This
    is because both panic and recover take an empty interface type. As you will learn,
    the empty interface type is a generic type with the ability to represent any type
    in Go's type system. We will learn more about the empty interface in [Chapter
    7](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 8. Methods,
    Interfaces, and Objects"), *Methods, Interfaces and Objects* during discussions
    about interfaces.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在调用`panic`时传递了一个字符串，却在测试`recover`函数返回的值时使用了一个`nil`。这是因为`panic`和`recover`都接受一个空的接口类型。正如你将要学习的，空的接口类型是一个泛型类型，它能够在Go的类型系统中表示任何类型。我们将在讨论接口时了解更多关于空接口的内容。[第7章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第8章。方法、接口和对象")，*方法、接口和对象*。
