<html><head></head><body>
<div class="book" title="Creating packages">
<div class="book" title="Naming packages"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec100" class="calibre1"/>Naming packages</h2></div></div></div><p class="calibre10">As mentioned earlier, Go expects each package in a workspace to have a unique fully qualified import path. Your program may have as many packages as you want and your package structure can be as deep as you like in the workspace. However, idiomatic Go prescribes some <span class="strong"><strong class="calibre2">rules </strong></span>for the naming and organization of your packages to make creating and using packages simple.</p><div class="book" title="Use globally unique namespaces"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec4" class="calibre1"/>Use globally unique namespaces</h3></div></div></div><p class="calibre10">Firstly, it is a good idea to fully qualify the import path of your packages in a global context, especially if you plan to share your code with others. Consider starting the name of your import path with a namespace scheme that uniquely identifies you or your organization. For instance, company <span class="strong"><em class="calibre11">Acme, Inc.</em></span> may choose to start all of their Go package names with <code class="email">acme.com/apps</code>. So a fully qualified import path for a package would be <code class="email">"acme.com/apps/foo/bar"</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre10">Later in this chapter, we will see how package import paths can be used when integrating Go with source code repository services such as GitHub.</p></div></div><div class="book" title="Add context to path"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec5" class="calibre1"/>Add context to path</h3></div></div></div><p class="calibre10">Next, as you devise a naming scheme for your package, use the package's path to add context to the name of your package name. The context in the name should start generic and get more specific from left to right. As an example, let us refer to the import paths for the power package (from the example earlier). The calculation of power values is split among three sub-packages shownÂ as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">github.com/vladimirvivien/learning-go/ch06/<span class="strong"><strong class="calibre2">power</strong></span>
</code></li><li class="listitem"><code class="email">github.com/vladimirvivien/learning-go/ch06/<span class="strong"><strong class="calibre2">power/ir</strong></span>
</code></li><li class="listitem"><code class="email">github.com/vladimirvivien/learning-go/ch06/<span class="strong"><strong class="calibre2">power/vr</strong></span>
</code></li></ul></div><p class="calibre10">The parent path <code class="email">power</code> contains package members with broader context. The sub-packages <code class="email">ir</code> and <code class="email">vr</code> contain members that are more specific with narrower contexts. This naming pattern is used heavily in Go, including the built-in packages such as the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">crypto/md5</code></li><li class="listitem"><code class="email">net/http</code></li><li class="listitem"><code class="email">net/http/httputil</code></li><li class="listitem"><code class="email">reflect</code></li></ul></div><p class="calibre10">Note a package depth of one is a perfectly legitimate package name (see <code class="email">reflect</code>) as long as it captures both context and the essence of what it does. Again, keep things simple. Avoid the temptation of nesting your packages beyond a depth of more than three inside your namespace. This temptation will be especially strong if you are a Java developer used to long nested package names.</p></div><div class="book" title="Use short names"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec6" class="calibre1"/>Use short names</h3></div></div></div><p class="calibre10">When reviewing the names of built-in Go packages, one thing you will notice is the brevity of the names compared to other languages. In Go, a package is considered to be a collection of code that implements a specific set of closely related functionalities. As such, the import paths of your packages should be succinct and reflect what they do without being excessively long. Our example source code exemplifies this by naming the package directory with short names such as volt, power, resistance, current. In their respective contexts, each directory name states exactly what the package does.</p><p class="calibre10">The short name rule is rigorously applied in the built-in packages of Go. For instance, following are several package names from Go's built-in packages: <code class="email">log</code>, <code class="email">http</code>, <code class="email">xml</code>, and <code class="email">zip</code>. Each name readily identifies the purpose of the package.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre10">Short package names have the advantage of reducing keystrokes in larger code bases. However, having short and generic package names also has the disadvantage of being prone to import path clashes where developers in a large project (or developers of open source libraries) may end up using the same popular names (in other words, <code class="email">log</code>, <code class="email">util</code>, <code class="email">db</code>, and so on) in their code. As we will see later in the chapter, this can be handled using <code class="email">named</code> import paths.</p></div></div></div></div></body></html>