- en: Naming packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Go expects each package in a workspace to have a unique
    fully qualified import path. Your program may have as many packages as you want
    and your package structure can be as deep as you like in the workspace. However,
    idiomatic Go prescribes some **rules** for the naming and organization of your
    packages to make creating and using packages simple.
  prefs: []
  type: TYPE_NORMAL
- en: Use globally unique namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firstly, it is a good idea to fully qualify the import path of your packages
    in a global context, especially if you plan to share your code with others. Consider
    starting the name of your import path with a namespace scheme that uniquely identifies
    you or your organization. For instance, company *Acme, Inc.* may choose to start
    all of their Go package names with `acme.com/apps`. So a fully qualified import
    path for a package would be `"acme.com/apps/foo/bar"`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later in this chapter, we will see how package import paths can be used when
    integrating Go with source code repository services such as GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Add context to path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, as you devise a naming scheme for your package, use the package''s path
    to add context to the name of your package name. The context in the name should
    start generic and get more specific from left to right. As an example, let us
    refer to the import paths for the power package (from the example earlier). The
    calculation of power values is split among three sub-packages shownÂ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`github.com/vladimirvivien/learning-go/ch06/**power**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github.com/vladimirvivien/learning-go/ch06/**power/ir**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github.com/vladimirvivien/learning-go/ch06/**power/vr**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parent path `power` contains package members with broader context. The
    sub-packages `ir` and `vr` contain members that are more specific with narrower
    contexts. This naming pattern is used heavily in Go, including the built-in packages
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`crypto/md5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http/httputil`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reflect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note a package depth of one is a perfectly legitimate package name (see `reflect`)
    as long as it captures both context and the essence of what it does. Again, keep
    things simple. Avoid the temptation of nesting your packages beyond a depth of
    more than three inside your namespace. This temptation will be especially strong
    if you are a Java developer used to long nested package names.
  prefs: []
  type: TYPE_NORMAL
- en: Use short names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When reviewing the names of built-in Go packages, one thing you will notice
    is the brevity of the names compared to other languages. In Go, a package is considered
    to be a collection of code that implements a specific set of closely related functionalities.
    As such, the import paths of your packages should be succinct and reflect what
    they do without being excessively long. Our example source code exemplifies this
    by naming the package directory with short names such as volt, power, resistance,
    current. In their respective contexts, each directory name states exactly what
    the package does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The short name rule is rigorously applied in the built-in packages of Go. For
    instance, following are several package names from Go''s built-in packages: `log`,
    `http`, `xml`, and `zip`. Each name readily identifies the purpose of the package.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Short package names have the advantage of reducing keystrokes in larger code
    bases. However, having short and generic package names also has the disadvantage
    of being prone to import path clashes where developers in a large project (or
    developers of open source libraries) may end up using the same popular names (in
    other words, `log`, `util`, `db`, and so on) in their code. As we will see later
    in the chapter, this can be handled using `named` import paths.
  prefs: []
  type: TYPE_NORMAL
