["```go\ntar -zxvf go*.*.*.linux-amd64.tar.gz\nsudo mv go /usr/local/go\n\n```", "```go\nmkdir -p $HOME/go/bin\n\n```", "```go\nexport PATH=$PATH:/usr/local/go/bin\n\n```", "```go\n$ go version\nGo version go1.6.2 linux/amd64\n\n```", "```go\n$ go version\nGo version go1.6.2 darwin/amd64\n\n```", "```go\nmkdir -p $HOME/go\n\n```", "```go\nexport GOPATH=${HOME}/go\n\n```", "```go\necho $GOPATH\n/home/mcastro/go\n\n```", "```go\npackage main \n\nfunc main(){ \nprintln(\"Hello World!\") \n} \n\n```", "```go\ngo run main.go\nHello World!\n\n```", "```go\ngo build -o hello_world\n\n```", "```go\n/hello_world\nHello World!\n\n```", "```go\n    //Explicitly declaring a \"string\" variable \n    var explicit string = \"Hello, I'm a explicitly declared variable\" \n\n```", "```go\n    //Implicitly declaring a \"string\". Type inferred \ninferred := \", I'm an inferred variable \" \n\n```", "```go\n    fmt.Println(\"Variable 'explicit' is of type:\", \n        reflect.TypeOf(explicit)) \n    fmt.Println(\"Variable 'inferred' is of type:\", \n        reflect.TypeOf(inferred)) \n\n```", "```go\n$ go run main.go\nHello, I'm a explicitly declared variable\nHello, I'm an inferred variable\nVariable 'explicit' is of type: string\nVariable 'inferred' is of type: string\n\n```", "```go\nten := 10 \nif ten == 20 { \n    println(\"This shouldn't be printed as 10 isn't equal to 20\") \n} else { \n    println(\"Ten is not equals to 20\"); \n} \n\n```", "```go\nif \"a\" == \"b\" ||  10 == 10 || true == false { \n    println(\"10 is equal to 10\") \n  } else if 11 == 11 &&\"go\" == \"go\" { \n  println(\"This isn't print because previous condition was satisfied\"); \n    } else { \n        println(\"In case no condition is satisfied, print this\") \n    } \n} \n\n```", "```go\nnumber := 3 \nswitch(number){ \n    case 1: \n        println(\"Number is 1\") \n    case 2: \n        println(\"Number is 2\") \n    case 3: \n        println(\"Number is 3\") \n} \n\n```", "```go\nfor i := 0; i<=10; i++ { \n    println(i) \n} \n\n```", "```go\nfor index, value := range my_array { \n    fmt.Printf(\"Index is %d and value is %d\", index, value) \n} \n\n```", "```go\nfor index := 0, index < len(my_array); index++ { \n    value := my_array[index] \n    fmt.Printf(\"Index is %d and value is %d\", index, value) \n} \n\n```", "```go\nfunc [function_name] (param1 type, param2 type...) (returned type1, returned type2...) { \n    //Function body \n} \n\n```", "```go\nfunc hello(message string) error { \n    fmt.Printf(\"Hello %s\\n\", message) \n    return nil \n} \n\n```", "```go\nfunc main(){ \n    add := func(m int){ \n         return m+1 \n} \n\n    result := add(6) \n\n    //1 + 6 must print 7 \n    println(result) \n} \n\n```", "```go\nfunc main(){ \n    addN := func(m int){ \n        return func(n int){ \n            return m+n \n        }            \n    } \n\n    addFive := addN(5) \n    result := addN(6)  \n    //5 + 6 must print 7 \n\n    println(result) \n}\n```", "```go\nerr := errors.New(\"Error example\") \n\n```", "```go\nfunc main(){ \n    err := doesReturnError() \n    if err != nil { \n        panic(err) \n    } \n} \n\nfunc doesReturnError() error { \n    err := errors.New(\"this function simply returns an error\") \n    return err \n} \n\n```", "```go\nfunc main() { \n    fmt.Printf(\"%d\\n\", sum(1,2,3)) \n    fmt.Printf(\"%d\\n\", sum(4,5,6,7,8)) \n} \n\nfunc sum(args ...int) (result int) { \n    for _, v := range args { \n        result += v \n    } \n    return \n} \n\n```", "```go\nvar arr [100]int \n\n```", "```go\narr := [3]string{\"go\", \"is\", \"awesome\"} \n\n```", "```go\nvar arr [2]bool \narr[0] = true \narr[1] = false \n\n```", "```go\nmySlice := make([]int, 10) \n\n```", "```go\nmySlice := append(mySlice, 5) \n\n```", "```go\nmySlice := mySlice[1:] \n\n```", "```go\nmySlice = append(mySlice[:1], mySlice[2:]...) \n\n```", "```go\nmyMap := make(map[string]int) \nmyMap[\"one\"] = 1 \nmyMap[\"two\"] = 2 \nfmt.Println(myMap[\"one\"]) \n\n```", "```go\nmyJsonMap := make(map[string]interface{}) \njsonData := []byte(`{\"hello\":\"world\"}`) \nerr := json.Unmarshal(jsonData, &myJsonMap) \nif err != nil { \npanic(err) \n} \nfmt.Printf(\"%s\\n\", myJsonMap[\"hello\"]) \n\n```", "```go\npackage hello \n\nfunc Hello_world(){ \n    println(\"Hello World!\") \n} \n\n```", "```go\npackage different_package \n\nimport \"github.com/sayden/go-design-patters/first_chapter/hello\" \n\nfunc myLibraryFunc() { \nhello.Hello_world() \n} \n\n```", "```go\nfunc main() { \n    res := divisibleBy(10,0) \n    fmt.Printf(\"%v\\n\", res) \n} \n\nfunc divisibleBy(n, divisor int) bool { \n    if divisor == 0 { \n        //You cannot divide by zero \n        return false \n    } \n\n    return (n % divisor == 0) \n} \n\n```", "```go\nfunc main() { \n    res, err := divisibleBy(10,0) \n    if err != nil { \nlog.Fatal(err) \n    } \n\n    log.Printf(\"%v\\n\", res) \n} \n\nfunc divisibleBy(n, divisor int) (bool, error) { \n    if divisor == 0 { \n        //You cannot divide by zero \n        return false, errors.New(\"A number cannot be divided by zero\") \n    } \n\n    return (n % divisor == 0), nil \n} \n\n```", "```go\nnumber := 5 \n\n```", "```go\nprintln(pointer_to_number) \n0x005651FA \n\n```", "```go\n println(*pointer_to_number) \n5 \n\n```", "```go\ntype Person struct { \n    Name string \n    Surname string \n    Hobbies []string \n    id string \n} \n\n```", "```go\nfunc (person *Person) GetFullName() string { \n    return fmt.Sprintf(\"%s %s\", person.Name, person.Surname) \n} \n\nfunc main() { \n    p := Person{ \n        Name: \"Mario\", \n        Surname: \"Castro\", \n        Hobbies: []string{\"cycling\", \"electronics\", \"planes\"}, \n        id: \"sa3-223-asd\", \n    } \n\n    fmt.Printf(\"%s likes %s, %s and %s\\n\", p.GetFullName(), p.Hobbies[0], p.Hobbies[1], p.Hobbies[2]) \n} \n\n```", "```go\nfunc (person Person) GetFullName() string { \n    return fmt.Sprintf(\"%s %s\", person.Name, person.Surname) \n} \n\n```", "```go\n$ go run main.go \nMario Castro likes cycling, electronics and planes\n\n```", "```go\ntype RailroadWideChecker interface { \n    CheckRailsWidth() int \n} \n\n```", "```go\ntype Railroad struct { \n    Width int \n} \n\nfunc (r *Railroad) IsCorrectSizeTrain(r RailRoadWideChecker) bool { \n    return r.CheckRailsWidth() != r.Width \n} \n\n```", "```go\nType Train struct { \n    TrainWidth int \n} \n\nfunc (p *Train) CheckRailsWidth() int { \n    return p.TrainWidth \n} \n\n```", "```go\nfunc main(){ \n    railroad := Railroad{Width:10} \n\n    passengerTrain := Train{TrainWidth: 10} \n    cargoTrain := Train {TrainWidth: 15} \n\n    canPassengerTrainPass := railroad.IsCorrectSizeTrain(passengerTrain) \n    canCargoTrainPass := railroad.IsCorrectSizeTrain(cargoTrain) \n\n    fmt.Printf(\"Can passenger train pass? %b\\n\", canPassengerTrainPass) \n    fmt.Printf(\"Can cargo train pass? %b\\n\", canCargoTrainPass) \n} \n\n```", "```go\nCan passenger train pass? true\nCan cargo train pass? false\n\n```", "```go\nfunc main() { \n    //Atoi converts a string to an int \n    a, _ := strconv.Atoi(os.Args[1]) \n    b, _ := strconv.Atoi(os.Args[2]) \n\n    result := sum(a,b) \n    fmt.Printf(\"The sum of %d and %d is %d\\n\", a, b, result) \n} \n\nfunc sum(a, b int) int { \n    return a + b \n} \n\n```", "```go\n$ go run main.go 3 4\nThe sum of 3 and 4 is 7\n\n```", "```go\nfunc TestSum(t *testing.T) { \n    a := 5 \n    b := 6 \n    expected := 11 \n\n    res := sum(a, b) \n    if res != expected { \n        t.Errorf(\"Our sum function doens't work, %d+%d isn't %d\\n\", a, b, res) \n    } \n} \n\n```", "```go\n$ go test -v\n=== RUN   TestSum\n--- PASS: TestSum (0.00s)\nPASS\nok   github.com/go-design-patterns/introduction/ex_xx_testing 0.001s\n\n```", "```go\n$ go test\n--- FAIL: TestSum (0.00s)\n main_test.go:12: Our sum function doens't work, 5+6 isn't 10\nFAIL\nexit status 1\nFAIL  github.com/sayden/go-design-patterns/introduction/ex_xx_testing 0.002s\n\n```", "```go\n$ go test -cover\nPASS\ncoverage: 20.0% of statements\nok  github.com/sayden/go-design-patterns/introduction/ex_xx_testing 0.001s\n\n```", "```go\nfunc multiply(a, b int) int { \n    return 0 \n} \n\n```", "```go\nimport \"testing\" \n\nfunc TestMultiply(t *testing.T) { \n    a := 5 \n    b := 6 \n    expected := 30 \n\n    res := multiply(a, b) \n    if res != expected { \n        t.Errorf(\"Our multiply function doens't work, %d*%d isn't %d\\n\", a, b, res) \n    } \n} \n\n```", "```go\n$ go test\n--- FAIL: TestMultiply (0.00s)\nmain_test.go:12: Our multiply function doens't work, 5+6 isn't 0\nFAIL\nexit status 1\nFAIL    github.com/sayden/go-designpatterns/introduction/ex_xx_testing/multiply \n0.002s\n\n```", "```go\nfunc multiply(a, b int) int { \n return a*b \n} \n\n```", "```go\n$ go test\nPASS\nok      github.com/sayden/go-design-patterns/introduction/ex_xx_testing/multiply    \n0.001s\n\n```", "```go\npackage arithmetic \n\nfunc Sum(args ...int) (res int) { \n    for _, v := range args { \n        res += v \n    } \n    return \n} \n\n```", "```go\nfunc Subtract(args ...int) int { \n    if len(args) < 2 { \n        return 0 \n    } \n\n    res := args[0] \n    for i := 1; i < len(args); i++ { \n        res -= args[i] \n    } \n    return res \n} \n\n```", "```go\nfunc Multiply(args ...int) int { \n    if len(args) < 2 { \n        return 0 \n    } \n\n    res := 1 \n    for i := 0; i < len(args); i++ { \n        res *= args[i] \n    } \n    return res \n} \n\n```", "```go\nfunc Divide(a, b int) (float64, error) { \n    if b == 0 { \n        return 0, errors.New(\"You cannot divide by zero\") \n    }  \n    return float64(a) / float64(b), nil \n} \n\n```", "```go\npackage main \n\nimport ( \n\"fmt\" \n\n\"bitbucket.org/mariocastro/go-design-patterns/introduction/libraries/arithmetic\" \n) \n\nfunc main() { \n    sumRes := arithmetic.Sum(5, 6) \n    subRes := arithmetic.Subtract(10, 5) \n    multiplyRes := arithmetic.Multiply(8, 7) \n    divideRes, _ := arithmetic.Divide(10, 2) \n\n    fmt.Printf(\"5+6 is %d. 10-5 is %d, 8*7 is %d and 10/2 is %f\\n\", sumRes, subRes, multiplyRes, divideRes) \n} \n\n```", "```go\n$ go get github.com/coreos/etcd\n\n```", "```go\nimport \"github.com/coreos/etcd\" \n\n```", "```go\nimport ( \n\"encoding/json\" \n\"fmt\" \n) \n\nfunc main(){ \n    packt := \"packt\" \n    jsonPackt, ok := json.Marshal(packt) \n    if !ok { \n        panic(\"Could not marshal object\")  \n    }  \n    fmt.Println(string(jsonPackt)) \n} \n$ \"pack\"\n\n```", "```go\ntype MyObject struct { \n    Number int \n    `json:\"number\"` \n    Word string \n} \n\nfunc main(){ \n    object := MyObject{5, \"Packt\"} \n    oJson, _ := json.Marshal(object) \n    fmt.Printf(\"%s\\n\", oJson) \n} \n$ {\"Number\":5,\"Word\":\"Packt\"}\n\n```", "```go\ntype MyObject struct { \n    Number int \n    Word string \n} \n\nfunc main(){ \n    object := MyObject{5, \"Packt\"} \n    oJson, _ := json.Marshal(object) \n    fmt.Printf(\"%s\\n\", oJson) \n} \n$ {\"number\":5,\"string\":\"Packt\"}\n\n```", "```go\ntype MyObject struct { \nNumber int`json:\"number\"` \nWord string`json:\"string\"` \n} \n\nfunc main(){ \n    jsonBytes := []byte(`{\"number\":5, \"string\":\"Packt\"}`) \n    var object MyObject \n    err := json.Unmarshal(jsonBytes, &object) \n    if err != nil { \n        panic(err) \n    } \n    fmt.Printf(\"Number is %d, Word is %s\\n\", object.Number, object.Word) \n} \n\n```", "```go\ntype MyObject struct { \n    Number int     `json:\"number\"` \n    Word string    `json:\"string\"` \n} \n\nfunc main(){ \n    jsonBytes := []byte(`{\"number\":5, \"string\":\"Packt\"}`) \n    var dangerousObject map[string]interface{} \n    err := json.Unmarshal(jsonBytes, &dangerousObject) \n    if err != nil { \n        panic(err) \n    } \n\n    fmt.Printf(\"Number is %d, \", dangerousObject[\"number\"]) \n    fmt.Printf(\"Word is %s\\n\", dangerousObject[\"string\"]) \n    fmt.Printf(\"Error reference is %v\\n\",  \ndangerousObject[\"nothing\"])\n} \n$ Number is %!d(float64=5), Word is Packt \nError reference is <nil> \n\n```", "```go\n//Explicitly declaring a \"string\" variable \nvar explicit string = \"Hello, I'm a explicitly declared variable\" \n\n//Implicitly declaring a \"string\". \nType inferred inferred := \", I'm an inferred variable \" \n\n$ golint main.go\n\n```", "```go\nType Train struct { \n    TrainWidth int \n} \n\n$ golint main.go\n\n```", "```go\npackage main \n\nfunc  main(){ \n    println(\"Hello World!\") \n} \n\n$ gofmt main.go \npackage main \n\nfunc main() { \n        println(\"Hello World!\") \n} \n\n```", "```go\n$ gofmt -w main.go\n\n```", "```go\n$godoc cmd/encoding/json\n[...]\nFUNCTIONS\nfunc Compact(dst *bytes.Buffer, src []byte) error\nCompact appends to dst the JSON-encoded src with insignificant space\ncharacters elided.\nfunc HTMLEscape(dst *bytes.Buffer, src []byte)\n[...]\n\n```", "```go\n$ godoc cmd/encoding/json | grep parse\n\n```", "```go\npackage main \nimport \"github.com/original/a_library\" \n[some code] \n\n```", "```go\npackage main \nimport ( \n    \"github.com/original/a_library\" \n    \"github.com/myaccount/a_library/my_library\" \n) \n\n```", "```go\n$ go get github.com/original/a_library\n$ cd $GOPATH/src/github.com/original/a_library\n$ git remote add my_origin https://github.com/myaccount/a_libbrary\n\n```", "```go\n$ git push my_origin my_brach\n\n```"]