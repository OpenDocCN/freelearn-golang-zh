- en: Chapter 1. Ready... Steady... Go!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。准备... 稳定... 开始！
- en: 'Design Patterns have been the foundation for hundreds of thousands of pieces
    of software. Since the *Gang Of Four* (Erich Gamma, Richard Helm, Ralph Johnson
    and John Vlissides) wrote the book *Design Patterns: Elements of Reusable Object-Oriented
    Software* in 1994 with examples in C++ and Smalltalk, the twenty-three classic
    patterns have been re-implemented in most of major languages of today and they
    have been used in almost every project you know about.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式一直是数十万件软件的基础。自从1994年*四人帮*（Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides）编写了《设计模式：可复用面向对象软件元素》一书，并在C++和Smalltalk中提供了示例以来，二十三个经典模式已经在大多数主要语言中重新实现，并且它们几乎被用于你了解的每一个项目中。
- en: The *Gang of Four* detected that many small architectures were present in many
    of their projects, they started to rewrite them in a more abstract way and they
    released the famous book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*四人帮*发现，他们许多项目中都存在许多小型架构，他们开始以更抽象的方式重写它们，并发布了著名的书籍。'
- en: This book is a comprehensive explanation and implementation of the most common
    design patterns from the *Gang of Four* and today's patterns plus some of the
    most idiomatic concurrency patterns in Go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是对*四人帮*和当今最常见的设计模式以及一些Go中最常见的并发模式的全面解释和实现。
- en: But what is Go...?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但Go是什么...？
- en: A little bit of history
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史
- en: On the last 20 years, we have lived an incredible growth in computer science.
    Storage spaces have been increased dramatically, RAM has suffered a substantial
    growth, and CPU's are... well... simply faster. Have they grown as much as storage
    and RAM memory? Not really, CPU industry has reached a limit in the speed that
    their CPU's can deliver, mainly because they have become so fast that they cannot
    get enough power to work while they dissipate enough heat. The CPU manufacturers
    are now shipping more cores on each computer. This situation crashes against the
    background of many systems programming languages that weren't designed for multi-processor
    CPUs or large distributed systems that act as a unique machine. In Google, they
    realized that this was becoming more than an issue while they were struggling
    to develop distributed applications in languages like Java or C++ that weren't
    designed with concurrency in mind.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的20年里，我们在计算机科学领域经历了令人难以置信的增长。存储空间大幅增加，RAM经历了实质性的增长，CPU... 好吧... 简单来说就是更快。它们的增长是否与存储和RAM内存一样大？实际上并非如此，CPU行业在CPU可以提供速度方面已经达到了极限，主要是因为它们变得如此之快，以至于在散发热量的同时无法获得足够的能量来工作。CPU制造商现在在每个计算机上提供更多的核心。这种情况与许多系统编程语言的设计背景相冲突，这些语言并非为多处理器CPU或作为单一机器运作的大规模分布式系统而设计。在谷歌，当他们在Java或C++等非为并发设计的语言中努力开发分布式应用程序时，他们意识到这已经不仅仅是一个问题。
- en: At the same time, our programs were bigger, more complex, more difficult to
    maintain and with a lot of room for bad practices. While our computers had more
    cores and were faster, we were not faster when developing our code neither our
    distributed applications. This was Go's target.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们的程序更大、更复杂、更难以维护，并且有很多坏习惯的空间。虽然我们的计算机有更多的核心和更快的速度，但我们在编写代码或分布式应用程序时并没有更快。这是Go的目标。
- en: 'Go design started in 2007 by three Googlers in the research of a programming
    language that could solve common issues in large scale distributed systems like
    the ones you can find at Google. The creators were:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go的设计始于2007年，当时三位谷歌工程师在研究一种可以解决像谷歌那样的大规模分布式系统中常见问题的编程语言。创造者包括：
- en: 'Rob Pike: Plan 9 and Inferno OS.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rob Pike：Plan 9和Inferno OS。
- en: 'Robert Griesemer: Worked at Google''s V8 JavaScript engine that powers Google
    Chrome.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robert Griesemer：曾在谷歌的V8 JavaScript引擎工作，该引擎为谷歌Chrome提供动力。
- en: 'Ken Thompson: Worked at Bell labs and the Unix team. It has been involved in
    designing of the Plan 9 operating system as well as the definition of the UTF-8
    encoding.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ken Thompson：曾在贝尔实验室和Unix团队工作。他参与了Plan 9操作系统的设计和UTF-8编码的定义。
- en: In 2008, the compiler was done and the team got the help of Russ Cox and Ian
    Lance Taylor. The team started their journey to open source the project in 2009
    and in March 2012 they reached a version 1.0 after more than fifty releases.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，编译器完成，团队得到了Russ Cox和Ian Lance Taylor的帮助。2009年，团队开始开源项目，并在2012年3月经过超过五十次发布后达到了1.0版本。
- en: Installing Go
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Go
- en: 'Any Go Installation needs two basic things: the binaries of the language somewhere
    on your disk and a **GOPATH** path in your system where your projects and the
    projects that you download from other people will be stored.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Go安装都需要两个基本的东西：语言二进制文件在您的磁盘上的某个位置，以及系统中的**GOPATH**路径，您的项目和您从其他人那里下载的项目将存储在这里。
- en: In the following lines, we will explore how to install Go binaries in Linux,
    Windows and OS X. For a detailed explanation of how to install the latest version
    of Go, you can refer to the official documentation at [https://golang.org/doc/install](https://golang.org/doc/install).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下行中，我们将探讨如何在Linux、Windows和OS X中安装Go二进制文件。有关如何安装Go最新版本的详细说明，您可以参考官方文档[https://golang.org/doc/install](https://golang.org/doc/install)。
- en: Linux
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: 'To install Go in Linux you have two options:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux中安装Go，您有两个选项：
- en: '**Easy option**: Use your distribution package manager:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单选项**：使用您的发行版包管理器：'
- en: RHEL/Fedora/Centos users with YUM/DNF:`sudo yum install -y golang`
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RHEL/Fedora/Centos用户使用YUM/DNF：`sudo yum install -y golang`
- en: Ubuntu/Debian users using APT with:`sudo apt-get install -y golang`
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu/Debian用户使用APT：`sudo apt-get install -y golang`
- en: '**Advanced**: Downloading the latest distribution from [https://golang.org](https://golang.org).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级**：从[https://golang.org](https://golang.org)下载最新发行版。'
- en: I recommend using the second and downloading a distribution. Go's updates maintains
    backward compatibility and you usually should not be worried about updating your
    Go binaries frequently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用第二个选项并下载一个发行版。Go的更新保持向后兼容性，您通常不需要担心频繁更新Go二进制文件。
- en: Go Linux advanced installation
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go Linux高级安装
- en: The advanced installation of Go in Linux requires you to download the binaries
    from **golang** webpage. After entering [https://golang.org](https://golang.org)
    , click the **Download Go** button (usually at the right) some **Featured Downloads**
    option is available for each distribution. Select **Linux** distribution to download
    the latest stable version.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中高级安装Go需要您从**golang**网页下载二进制文件。进入[https://golang.org](https://golang.org)后，点击**下载Go**按钮（通常在右侧），每个发行版都有一些**特色下载**选项。选择**Linux**发行版以下载最新稳定版本。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At [https://golang.org](https://golang.org) you can also download beta versions
    of the language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://golang.org](https://golang.org)您还可以下载语言的测试版。
- en: 'Let''s say we have saved the `tar.gz` file in Downloads folder so let''s extract
    it and move it to a different path. By convention, Go binaries are usually placed
    in `/usr/local/go` directory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经将`tar.gz`文件保存在下载文件夹中，所以让我们将其解压并移动到不同的路径。按照惯例，Go二进制文件通常放置在`/usr/local/go`目录中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On extraction remember to replace asterisks (`*`) with the version you have
    downloaded.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在解压时，请记住将星号（`*`）替换为您下载的版本。
- en: Now we have our Go installation in`/usr/local/go` path so now we have to add
    the `bin` subfolder to our `PATH` and the `bin` folder within our GOPATH.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Go安装在了`/usr/local/go`路径下，所以现在我们必须将`bin`子文件夹添加到我们的`PATH`中，以及我们的GOPATH中的`bin`文件夹。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With -p we are telling bash to create all directories that are necessary. Now
    we need to append bin folder paths to our PATH, append the following lines at
    the end of your `~/.bashrc`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-p`我们告诉bash创建所有必要的目录。现在我们需要将bin文件夹路径添加到我们的PATH中，在您的`~/.bashrc`文件末尾添加以下行：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check that our `go/bin` directory is available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的`go/bin`目录是否可用：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Windows
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: To install Go in Windows, you will need administrator privileges. Open your
    favorite browser and navigate to `https://golang.org` . Once there click the **Download
    Go** button and select **Microsoft Windows** distribution. A `*.msi` file will
    start downloading.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows中安装Go，您需要管理员权限。打开您喜欢的浏览器并导航到`https://golang.org`。一旦到达那里，点击**下载Go**按钮并选择**Microsoft
    Windows**发行版。将开始下载一个`*.msi`文件。
- en: Execute the MSI installer by double clicking it. An installer will appear asking
    you to accept the **End User License Agreement** (**EULA**) and select a target
    folder for your installation. We will continue with the default path that in my
    case was `C:\Go`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击MSI安装程序来执行安装程序。安装程序将出现，要求您接受**最终用户许可协议**（**EULA**）并选择安装的目标文件夹。我们将继续使用默认路径，在我的情况下是`C:\Go`。
- en: Once the installation is finished you will have to add the **binary Go** folder,
    located in `C:\Go\bin` to your Path. For this, you must go to Control Panel and
    select **System** option. Once in System, select the **Advanced** tab and click
    the **Environment variables** button. Here you'll find a window with variables
    for your current user and system variables. In system variables, you'll find the
    **Path** variable. Click it and click the **Edit** button to open a text box.
    You can add your path by adding `;C:\Go/bin` at the end of the current line (note
    the semicolon at the beginning of the path). In recent Windows versions (Windows
    10) you will have a manager to add variables easily.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将需要将位于`C:\Go\bin`的**二进制Go**文件夹添加到你的Path中。为此，你必须转到控制面板并选择**系统**选项。一旦进入系统，选择**高级**选项卡并点击**环境变量**按钮。在这里，你会找到一个包含当前用户和系统变量的窗口。在系统变量中，你会找到**Path**变量。点击它并点击**编辑**按钮以打开一个文本框。你可以在当前行的末尾添加你的路径，添加`;C:\Go\bin`（注意路径开头的分号）。在最近的Windows版本（Windows
    10）中，你将有一个管理器来轻松添加变量。
- en: Mac OS X
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mac OS X
- en: In Mac OS X the installation process is very similar to Linux. Open your favorite
    browser and navigate to [https://golang.org](https://golang.org) and click the
    **Download Go**. From the list of possible distributions that appear, select **Apple
    OS X**. This will download a `*.pkg` file to your download folder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X中，安装过程与Linux非常相似。打开你喜欢的浏览器并导航到[https://golang.org](https://golang.org)，然后点击**下载Go**。从出现的可能分布列表中，选择**Apple
    OS X**。这将下载一个`*.pkg`文件到你的下载文件夹。
- en: 'A window will guide you through the installation process where you have to
    type your administrator password so that it can put Go binary files in `/usr/local/go/bin`
    folder with the proper permissions. Now, open **Terminal** to test the installation
    by typing this on it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个窗口将引导你完成安装过程，在这个过程中你需要输入管理员密码，以便它可以将Go二进制文件放入`/usr/local/go/bin`文件夹，并赋予适当的权限。现在，打开**终端**来测试安装，输入以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you see the installed version, everything was fine. If it doesn't work check
    that you have followed correctly every step or refer to the documentation at [https://golang.org](https://golang.org).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到了安装的版本，那么一切正常。如果它不起作用，请检查你是否正确地遵循了每个步骤，或者参考[https://golang.org](https://golang.org)上的文档。
- en: Setting the workspace - Linux and Apple OS X
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置工作空间 - Linux和Apple OS X
- en: Go will always work under the same workspace. This helps the compiler to find
    packages and libraries that you could be using. This workspace is commonly called
    **GOPATH**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go总是在同一个工作空间下工作。这有助于编译器找到你可能正在使用的包和库。这个工作空间通常被称为**GOPATH**。
- en: GOPATH has a very important role in your working environment while developing
    Go software. When you import a library in your code it will search for this library
    in your `$GOPATH/src`. The same when you install some Go apps, binaries will be
    stored in `$GOPATH/bin`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Go软件时，GOPATH在你的工作环境中扮演着非常重要的角色。当你代码中导入一个库时，它将在你的`$GOPATH/src`中搜索这个库。当你安装一些Go应用时，二进制文件将被存储在`$GOPATH/bin`中。
- en: 'At the same, all your source code must be stored in a valid route within `$GOPATH/src`
    folder. For example, I store my projects in GitHub and my username is *Sayden*
    so, for a project called **minimal-mesos-go-framework** I will have this folder
    structure like `$GOPATH/src/github.com/sayden/minimal-mesos-go-framework` which
    reflects the URI where this repo is stored at GitHub:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，所有你的源代码都必须存储在`$GOPATH/src`文件夹内的有效路径中。例如，我将我的项目存储在GitHub上，我的用户名是*Sayden*，所以对于一个名为**minimal-mesos-go-framework**的项目，我将有如下文件夹结构`$GOPATH/src/github.com/sayden/minimal-mesos-go-framework`，这反映了在GitHub上存储此仓库的URI：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `$HOME/go` path is going to be the destination of our `$GOPATH`. We have
    to set an environment variable with our `$GOPATH` pointing to this folder. To
    set the environment variable, open again the file `$HOME/.bashrc` with your favorite
    text editor and add the following line at the end of it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`$HOME/go`路径将是我们的`$GOPATH`的目的地。我们必须设置一个环境变量，将我们的`$GOPATH`指向这个文件夹。要设置环境变量，再次使用你喜欢的文本编辑器打开文件`$HOME/.bashrc`，并在其末尾添加以下行：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save the file and open a new terminal. To check that everything is working,
    just write an echo to the `$GOPATH` variable like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并打开一个新的终端。为了检查一切是否正常工作，只需向`$GOPATH`变量写入一个echo命令，如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the output of the preceding command points to your chosen Go path, everything
    is correct and you can continue to write your first program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一个命令的输出指向你选择的Go路径，那么一切正确，你可以继续编写你的第一个程序。
- en: Starting with Hello World
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Hello World开始
- en: 'This wouldn''t be a good book without a Hello World example. Our Hello World
    example can''t be simpler, open your favorite text editor and create a file called
    `main.go` within our `$GOPATH/src/[your_name]/hello_world` with the following
    content:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一本好书是不包含“Hello World”示例的。我们的“Hello World”示例非常简单，打开您喜欢的文本编辑器，在`$GOPATH/src/[your_name]/hello_world`下创建一个名为`main.go`的文件，并包含以下内容：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the file. To run our program, open the Terminal window of your operating
    system:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。要运行我们的程序，打开操作系统的终端窗口：
- en: In Linux, go to programs and find a program called **Terminal**.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中，转到程序，找到一个名为**终端**的程序。
- en: In Windows, hit Windows + R, type `cmd` without quotes on the new window and
    hit *Enter*.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows中，按Windows + R，在新窗口中输入不带引号的`cmd`，然后按*Enter*。
- en: In Mac OS X, hit Command + Space to open a spotlight search, type `terminal`
    without quotes. The terminal app must be highlighted so hit Enter.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac OS X中，按Command + Space打开spotlight搜索，输入不带引号的`terminal`。终端应用必须高亮，然后按Enter。
- en: 'Once we are in our terminal, navigate to the folder where we have created our
    `main.go` file. This should be under your `$GOPATH/src/[your_name]/hello_world`
    and execute it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入终端，导航到我们创建`main.go`文件的文件夹。这应该在您的`$GOPATH/src/[your_name]/hello_world`下，并执行它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That''s all. The `go run [file]` command will compile and execute our application
    but it won''t generate an executable file. If you want just to build it and get
    an executable file, you must build the app using the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了。`go run [file]`命令会编译并执行我们的应用程序，但不会生成可执行文件。如果你想只构建它并得到一个可执行文件，你必须使用以下命令来构建应用程序：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Nothing happens. But if you search in the current directory (`ls` command in
    Linux and Mac OS X; and `dir` in Windows), you''ll find an executable file with
    the name `hello_world`. We have given this name to the executable file when we
    wrote `-o hello_world` command while building. You can now execute this file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发生任何事情。但如果你在当前目录中搜索（Linux和Mac OS X中的`ls`命令；Windows中的`dir`命令），你会找到一个名为`hello_world`的可执行文件。我们在构建时使用`-o
    hello_world`命令给这个可执行文件命名。你现在可以执行这个文件：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And our message appeared! In Windows, you just need to type the name of the
    `.exe` file to get the same result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息出现了！在Windows中，你只需输入`.exe`文件名即可获得相同的结果。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `go run [my_main_file.go]` command will build and execute the app without
    intermediate files. The `go build -o [filename]` command will create an executable
    file that I can take anywhere and has no dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run [my_main_file.go]`命令会构建并执行应用程序，而不会生成中间文件。`go build -o [filename]`命令将创建一个可执行文件，我可以将其带到任何地方，并且没有依赖项。'
- en: Integrated Development Environment - IDE
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境 - IDE
- en: An **IDE** (**Integrated Development Environment**) is basically a user interface
    to help developers, code their programs by providing a set of tools to speed up
    common tasks during development process like compiling, building, or managing
    dependencies. The IDEs are powerful tools that take some time to master and the
    purpose of this book is not to explain them (an IDE like Eclipse has its own books).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDE**（集成开发环境）基本上是一个用户界面，帮助开发者通过提供一套工具来加速开发过程中的常见任务，如编译、构建或管理依赖项。IDE是强大的工具，需要一些时间来掌握，本书的目的不是解释它们（例如，Eclipse这样的IDE有自己的书籍）。'
- en: 'In Go, you have many options but there are only two that are fully oriented
    to Go development **LiteIDE** and **Intellij Gogland**. LiteIDE is not the most
    powerful though but Intellij has put lots of efforts to make Gogland a very nice
    editor with completion, debugging, refactoring, testing, visual coverage, inspections,
    etc. Common IDEs or text editors that have a Go plugin/integration are as following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你有许多选择，但只有两个完全针对Go开发的**LiteIDE**和**Intellij Gogland**。虽然LiteIDE不是最强大的，但IntelliJ已经投入了大量努力使Gogland成为一个非常好的编辑器，具有自动完成、调试、重构、测试、可视化覆盖、检查等功能。以下是一些常见的IDE或文本编辑器，它们具有Go插件/集成：
- en: IntelliJ Idea
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ Idea
- en: Sublime Text 2/3
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime Text 2/3
- en: Atom
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom
- en: Eclipse
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse
- en: 'But you can also find Go plugins for:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但你还可以找到Go插件：
- en: Vim
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vim
- en: Visual Studio and Visual Code
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio和Visual Code
- en: The IntelliJ Idea and Atom IDEs, for the time of this writing, has the support
    for debugging using a plugin called **Delve**. The IntelliJ Idea is bundled with
    the official Go plugin. In Atom you'll have to download a plugin called **Go-plus**
    and a debugger that you can find searching the word `Delve`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，IntelliJ Idea和Atom IDE支持使用名为**Delve**的插件进行调试。IntelliJ Idea捆绑了官方的Go插件。在Atom中，您需要下载一个名为**Go-plus**的插件和一个您可以通过搜索“Delve”找到的调试器。
- en: Types
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Types give the user the ability to store values in mnemonic names. All programming
    languages have types related with numbers (to store integers, negative numbers,
    or floating point for example) with characters (to store a single character) with
    strings (to store complete words) and so on. Go language has the common types
    found in most programming languages:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型给用户提供了使用助记名称存储值的能力。所有编程语言都有与数字相关的类型（例如存储整数、负数或浮点数），与字符（例如存储单个字符）相关的类型，与字符串（例如存储完整的单词）相关的类型等等。Go
    语言具有大多数编程语言中常见的类型：
- en: The `bool` keyword is for Boolean type which represents a `True` or `False`
    state.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool` 关键字用于布尔类型，它表示 `True` 或 `False` 状态。'
- en: 'Many numeric types being the most common:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多数值类型是最常见的：
- en: The `int` is a signed integer type, so int type represents a number from -2147483648
    to 2147483647 in 32 bits machines
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 是有符号整数类型，因此 int 类型在 32 位机器上表示从 -2147483648 到 2147483647 的数字。'
- en: The `byte` type represents a number from 0 to 255.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte` 类型表示从 0 到 255 的数字。'
- en: The `float32` and `float64` types are the set of all IEEE-754 64/-bit floating-point
    numbers respectively.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float32` 和 `float64` 类型分别是所有 IEEE-754 64 位/负位浮点数的集合。'
- en: You also have `signed int` type like `rune` which is an alias of `int32` type,
    a number that goes from -2147483648 to 2147483647 and `complex64` and `complex128`
    which are the set of all complex numbers with `float32`/ `float64` real and imaginary
    parts like *2.0i*.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还有 `signed int` 类型，如 `rune`，它是 `int32` 类型的别名，一个从 -2147483648 到 2147483647 的数字，以及
    `complex64` 和 `complex128`，它们是所有具有 `float32`/ `float64` 实部和虚部的复数集合，如 *2.0i*。
- en: The `string` keyword for string type represents an array of characters enclosed
    in quotes like `"golang"` or `"computer"`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 关键字用于字符串类型，表示用引号括起来的字符数组，如 `"golang"` 或 `"computer"`。'
- en: An `array` that is a numbered sequence of elements of a single type and a fixed
    size (more about arrays later in this chapter). A list of numbers or lists of
    words with a fixed size is considered arrays.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array` 是一个由单个类型的元素组成的编号序列，具有固定的大小（关于数组将在本章后面详细说明）。固定大小的数字列表或单词列表被认为是数组。'
- en: The `slice` type is a segment of an underlying array (more about this later
    in this chapter). This type is a bit confusing at the beginning because it seems
    like an array but we will see that actually, they are more powerful.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice` 类型是底层数组的片段（关于这一点将在本章后面详细说明）。这种类型在开始时可能有点令人困惑，因为它看起来像数组，但我们将看到实际上它们更强大。'
- en: The structures that are the objects that are composed of another objects or
    types.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构是由其他对象或类型组成的对象。
- en: The pointers (more about this later in this chapter)are like directions in the
    memory of our program (yes, like mailboxes that you don't know what's inside).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针（关于这一点将在本章后面详细说明）就像我们程序内存中的方向（是的，就像你不知道里面是什么的邮箱）。
- en: The functions are interesting (more about this later in this chapter). You can
    also define functions as variables and pass them to other functions (yes, a function
    that uses a function, did you like Inception movie?).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数很有趣（关于这一点将在本章后面详细说明）。你还可以将函数定义为变量，并将它们传递给其他函数（是的，一个使用函数的函数，你喜欢《盗梦空间》这部电影吗？）。
- en: The `interface` is incredibly important for the language as they provide many
    encapsulation and abstraction functionalities that we'll need often. We'll use
    interfaces extensively during the book and they are presented in greater detail
    later.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface` 对于语言来说非常重要，因为它们提供了我们经常需要的许多封装和抽象功能。我们将在本书中广泛使用接口，它们将在后面更详细地介绍。'
- en: The `map` types are unordered key-value structures. So for a given key, you
    have an associated value.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 类型是无序的键值结构。因此，对于给定的键，你有一个关联的值。'
- en: The channels are the communication primitive in Go for concurrency programs.
    We'll look on channels with more detail on Chapter 8, *Dealing with Go's CSP concurrency*.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道是 Go 语言中并发程序的通信原语。我们将在第 8 章 *处理 Go 的 CSP 并发* 中更详细地探讨通道。
- en: Variables and constants
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和常量
- en: 'Variables are spaces in computer''s memory to store values that can be modified
    during the execution of the program. Variables and constants have a type like
    the ones described in preceding text. Although, you don''t need to explicitly
    write the type of them (although you can do it). This property to avoid explicit
    type declaration is what is called **Inferred types**. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是计算机内存中的空间，用于存储在程序执行期间可以修改的值。变量和常量具有与前面文本中描述的类型相同。尽管如此，你不需要明确写出它们的类型（尽管你可以这样做）。这种避免显式类型声明的特性被称为
    **推断类型**。例如：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we are declaring a variable (with the keyword `var`) called `explicit`
    of string type. At the same time, we are defining the value to `Hello World!`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`explicit`的字符串类型变量（使用关键字`var`），并将其值定义为`Hello World!`。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But here we are doing exactly the same thing. We have avoided the `var` keyword
    and the `string` type declaration. Internally, Go's compiler will infer (guess)
    the type of the variable to a string type. This way you have to write much less
    code for each variable definition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们正在做完全相同的事情。我们避免了`var`关键字和`string`类型声明。内部，Go编译器将变量的类型推断为字符串类型。这样，你就不必为每个变量定义编写太多的代码。
- en: 'The following lines use the `reflect` package to gather information about a
    variable. We are using it to print the type of (the `TypeOf` variable in the code)
    of both variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用`reflect`包来收集有关变量的信息。我们使用它来打印两个变量的类型（代码中的`TypeOf`变量）：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run the program, the result is the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，结果如下：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we expected, the compiler has inferred the type of the implicit variable
    to string too. Both have written the expected output to the console.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所料，编译器也将隐式变量的类型推断为字符串。两者都将预期的输出写入控制台。
- en: Operators
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: The operators are used to perform arithmetic operations and make comparisons
    between many things. The following operators are reserved by Go language.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符用于执行算术运算并在许多事物之间进行比较。以下运算符由Go语言保留：
- en: '![Operators](img/00030.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![运算符](img/00030.jpeg)'
- en: 'Most commonly used operators are the arithmetic operators and comparators.
    Arithmetic operators are as following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的运算符是算术运算符和比较运算符。算术运算符如下：
- en: The `+` operator for sums
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`运算符用于求和'
- en: The `-` operator for subtractions
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`运算符用于减法'
- en: The `*` operator for multiplications
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`运算符用于乘法'
- en: The `/` operator for divisions
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`运算符用于除法'
- en: The `%` operator for division remainders
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`运算符用于除法余数'
- en: The `++` operator to add 1 to the current variable
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`++`运算符用于将当前变量的值加1'
- en: The `--` operator to subtract 1 to the current variable
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--`运算符用于将当前变量的值减1'
- en: 'On the other side, comparators are used to check the differences between two
    statements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，比较运算符用于检查两个语句之间的差异：
- en: The `==` operator to check if two values are equal
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`运算符用于检查两个值是否相等'
- en: The `!=` operator to check if two values are different
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=`运算符用于检查两个值是否不同'
- en: The `>` operator to check if left value is higher than right value
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`运算符用于检查左值是否大于右值'
- en: The `<` operator to check if left value is lower than right value
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`运算符用于检查左值是否小于右值'
- en: The `>=` operator to check if left value is higher or equal to right value
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=`运算符用于检查左值是否大于或等于右值'
- en: The `<=` operator to check if left value is lower or equal to right value
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=`运算符用于检查左值是否小于或等于右值'
- en: The `&&`operator to check if two values are `true`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`运算符用于检查两个值是否为`true`'
- en: You also have the shifters to perform a binary shift to left or right of a value
    and a negated operator to invert some value. We´ll use these operators a lot during
    the following chapters so don´t worry too much about them now, just keep in mind
    that you cannot set the name of any variable, field or function in your code like
    this operators.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有位移运算符，用于执行值的左移或右移二进制位移，以及取反运算符，用于取反某些值。我们将在接下来的章节中大量使用这些运算符，所以现在不必过于担心，只需记住，你不能像这些运算符一样在你的代码中设置任何变量、字段或函数的名称。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What's the inverted value of 10? What's the negated value of 10? -10? Incorrect..
    10 in binary code is `1010` so if we negate every number we will have `0101` or
    `101` which is the number 5.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 10的倒数是多少？10的相反数是多少？-10？不正确。10的二进制是`1010`，如果我们对每个数字取反，我们将得到`0101`或`101`，这是数字5。
- en: Flow control
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制
- en: Flow control is referred as the ability to decide which portion of code or how
    many times you execute some code on a condition. In Go, it is implemented using
    familiar imperative clauses like if, else, switch and for. The syntax is easy
    to grasp. Let´s review major flow control statements in Go.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制是指根据条件决定执行代码的哪个部分或执行多少次代码的能力。在Go中，它使用熟悉的命令式子句如if、else、switch和for来实现。语法易于理解。让我们回顾Go中的主要流程控制语句。
- en: The if... else statement
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if...else语句
- en: 'Go language, like most programming languages, has `if…else` conditional statement
    for flow control. The Syntax is similar to other languages but you don''t need
    to encapsulate the condition between parenthesis:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言，像大多数编程语言一样，有`if…else`条件语句用于流程控制。语法与其他语言类似，但不需要在括号中封装条件：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `else...if` condition works in a similar fashion, you don''t need parentheses
    either and they are declared as programmer would expect:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`else...if` 条件以类似的方式工作，你也不需要括号，并且它们被声明为程序员所期望的方式：'
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Go does not have ternary conditions like `condition ? true : false`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'Go 没有类似于 `condition ? true : false` 的三元条件。'
- en: The switch statement
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 语句
- en: 'The `switch` statement is also similar to most imperative languages. You take
    a variable and check possible values for it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句也类似于大多数命令式语言。你取一个变量并检查它的可能值：'
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The for…range statement
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for…range 语句
- en: The `_for_` loop is also similar than in common programming languages but you
    don't use parentheses either
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`_for_` 循环也与常见的编程语言类似，但你也不使用括号。'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you have probably imagined if you have computer science background, we infer
    an `int` variable defined as `0` and execute the code between the brackets while
    the condition (`i<=10`) is satisfied. Finally, for each execution, we added `1`
    to the value of `i`. This code will print the numbers from 0 to 10\. You also
    have a special syntax to iterate over arrays or slices which is `range`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具有计算机科学背景，你可能已经想象到了，我们推断出一个定义为 `0` 的 `int` 变量，并在条件 (`i<=10`) 满足的情况下执行括号内的代码。最后，对于每次执行，我们将
    `1` 添加到 `i` 的值上。这段代码将打印从 0 到 10 的数字。你还有一个特殊的语法来遍历数组或切片，即 `range`：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, the `fmt` (format) is a very common Go package that we will use extensively
    to give shape to the message that we will print in the console.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`fmt`（格式化）是一个非常常用的 Go 包，我们将广泛使用它来给我们在控制台打印的消息赋予形状。
- en: 'Regarding for, you can use the `range` keyword to retrieve every item in a
    collection like `my_array` and assign them to the value temporal variable. It
    will also give you an `index` variable to know the position of the value you''re
    retrieving. It''s equivalent to write the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 for，你可以使用 `range` 关键字来检索 `my_array` 这样的集合中的每个项目，并将它们分配给临时变量。它还会给你一个 `index`
    变量，以了解你正在检索的值的位臵。这相当于写出以下内容：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `len` method is used to know the length of a collection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 方法用于了解集合的长度。'
- en: If you execute this code, you'll see that the result is the same.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码，你会看到结果是相同的。
- en: Functions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: A function is a small portion of code that surrounds some action you want to
    perform and returns one or more values (or nothing). They are the main tool for
    developer to maintain structure, encapsulation, and code readability but also
    allow an experienced programmer to develop proper unit tests against his or her
    functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一小段代码，它围绕着你想要执行的操作，并返回一个或多个值（或无）。它们是开发者维护结构、封装和代码可读性的主要工具，同时也允许经验丰富的程序员对其函数进行适当的单元测试。
- en: 'Functions can be very simple or incredibly complex. Usually, you''ll find that
    simpler functions are also easier to maintain, test and debug. There is also a
    very good advice in computer science world that says: *A function must do just
    one thing, but it must do it damn well*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以是非常简单或极其复杂的。通常，你会发现简单的函数也更容易维护、测试和调试。在计算机科学领域还有一个非常好的建议：*一个函数必须只做一件事，但必须做得非常好*。
- en: What does a function look like?
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数看起来是什么样子？
- en: 'A function is a piece of code with its own variables and flow that doesn''t
    affect anything outside of the opening and close brackets but global package or
    program variables. Functions in Go has the following composition:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一段具有自己的变量和流程的代码，它不会影响括号内外（但全局包或程序变量）之外的内容。Go 中的函数具有以下组成：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following the previous definition, we could have the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的定义，我们可以有以下示例：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Functions can call other functions. For example, in our previous `hello` function,
    we are receiving a message argument of type string and we are calling a different
    function `fmt.Printf("Hello %s\n", message)` with our argument as parameter. Functions
    can also be used as parameters when calling other functions or be returned.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以调用其他函数。例如，在我们的上一个 `hello` 函数中，我们接收一个类型为字符串的消息参数，并调用一个不同的函数 `fmt.Printf("Hello
    %s\n", message)`，将我们的参数作为参数。函数也可以在调用其他函数时用作参数，或者被返回。
- en: It is very important to choose a good name for your function so that it is very
    clear what it is about without writing too many comments over it. This can look
    a bit trivial but choosing a good name is not so easy. A short name must show
    what the function does and let the reader imagine what error is it handling or
    if it's doing any kind of logging. Within your function, you want to do everything
    that a particular behavior need but also to control expected errors and wrapping
    them properly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的函数选择一个好的名字非常重要，这样它就可以在不写太多注释的情况下非常清楚地表达其功能。这看起来可能有点微不足道，但选择一个好的名字并不容易。一个简短的名字必须显示函数的功能，并让读者想象它处理的是哪种错误，或者它是否在进行某种类型的日志记录。在你的函数内部，你想要做的是满足特定行为所需的一切，同时也要控制预期的错误，并正确地封装它们。
- en: So, to write a function is more than simply throw a couple of lines that does
    what you need, that's why it is important to write a unit test, make them small
    and concise.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编写一个函数不仅仅是简单地写几行代码来完成你需要的功能，这就是为什么编写单元测试很重要的原因，让它们保持小而简洁。
- en: What is an anonymous function?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数是什么？
- en: 'An anonymous function is a function without a name. This is useful when you
    want to return a function from another function that doesn''t need a context or
    when you want to pass a function to a different function. For example, we will
    create a function that accepts one number and returns a function that accepts
    a second number that it adds it to the first one. The second function does not
    have a declarative name (as we have assigned it to a variable) that is why it
    is said to be anonymous:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是没有名字的函数。当你想从一个不需要上下文的函数中返回一个函数，或者你想将一个函数传递给另一个函数时，这很有用。例如，我们将创建一个接受一个数字并返回一个函数的函数，该函数接受第二个数字并将其加到第一个数字上。第二个函数没有声明性的名字（因为我们已经将其分配给了一个变量），这就是为什么它被称为匿名函数：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `add` variable points to an anonymous function that adds one to the specified
    parameter. As you can see, it can be used only for the scope its parent function
    `main` and cannot be called from anywhere else.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 变量指向一个匿名函数，该函数将指定的参数加一。正如你所看到的，它只能在父函数 `main` 的作用域内使用，不能在其他任何地方调用。'
- en: Anonymous functions are really powerful tools that we will use extensively on
    design patterns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是非常强大的工具，我们将在设计模式中广泛使用。
- en: Closures
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closures are something very similar to anonymous functions but even more powerful.
    The key difference between them is that an anonymous function has no context within
    itself and a closure has. Let''s rewrite the previous example to add an arbitrary
    number instead of one:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包与匿名函数非常相似，但功能更强大。它们之间的关键区别是匿名函数在其内部没有上下文，而闭包有。让我们重写之前的例子，以添加任意数字而不是一个：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `addN` variable points to a function that returns another function. But
    the returned function has the context of the `m` parameter within it. Every call
    to `addN` will create a new function with a fixed `m` value, so we can have main `addN`
    functions, each adding a different value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`addN` 变量指向一个返回另一个函数的函数。但返回的函数具有其内部的 `m` 参数的上下文。每次调用 `addN` 都会创建一个新的函数，具有固定的
    `m` 值，因此我们可以有多个 `addN` 主函数，每个函数增加不同的值。'
- en: This ability of closures is very useful to create libraries or deal with functions
    with unsupported types.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的这种能力对于创建库或处理不支持的数据类型的函数非常有用。
- en: Creating errors, handling errors and returning errors.
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建错误、处理错误和返回错误。
- en: 'Errors are extensively used in Go, probably thanks to its simplicity. To create
    an error simply make a call to `errors.New(string)` with the text you want to
    create on the error. For example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 错误在 Go 中被广泛使用，可能得益于其简单性。要创建一个错误，只需调用 `errors.New(string)` 并传入你想要创建的错误文本。例如：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we have seen before, we can return errors to a function. To handle an error
    you''ll see the following pattern extensively in Go code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以将错误返回给函数。在 Go 代码中，处理错误时你会广泛看到以下模式：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Function with undetermined number of parameters
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有不确定数量参数的函数
- en: 'Functions can be declared as *variadic*. This means that its number of arguments
    can vary. What this does is to provide an array to the scope of the function that
    contains the arguments that the function was called with. This is convenient if
    you don''t want to force the user to provide an array when using this function.
    For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以被声明为 *可变参数*。这意味着它的参数数量可以变化。这样做的作用是为函数的作用域提供一个数组，该数组包含函数被调用时使用的参数。如果你不希望用户在使用此函数时被迫提供一个数组，这很方便。例如：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we have a `sum` function that will return the sum of all its
    arguments but take a closer look at the `main` function where we call `sum`. As
    you can see now, first we call `sum` with three arguments and then with five arguments.
    For `sum` functions, it doesn't matter how many arguments you pass as it treats
    its arguments as an array all in all. So on our `sum` definition, we simply iterate
    over the array to add each number to the `result` integer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个`sum`函数，它将返回所有参数的总和，但请更仔细地看看我们调用`sum`的`main`函数。正如你所看到的，我们首先用三个参数调用`sum`，然后又用五个参数调用。对于`sum`函数来说，你传递多少个参数并不重要，因为它将其参数视为一个整体数组。因此，在我们的`sum`定义中，我们只是简单地遍历数组，将每个数字加到`result`整数上。
- en: Naming returned types
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型的命名
- en: Have you realized that we have given a name to the returned type? Usually, our
    declaration would be written as `func sum(args int) int` but you can also name
    the variable that you'll use within the function as a return value. Naming the
    variable in the return type would also zero-value it (in this case, an `int` will
    be initialized as zero). At the end, you just need to return the function (without
    value) and it will take the respective variable from the scope as returned value.
    This also makes easier to follow the mutation that the returning variable is suffering
    as well as to ensure that you aren't returning a mutated argument.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有意识到我们已经给返回类型起了一个名字？通常，我们的声明会被写成`func sum(args int) int`，但你也可以给函数内部用作返回值的变量命名。在返回类型中命名变量也会将其初始化为零值（在这种情况下，`int`将被初始化为零）。最后，你只需要返回函数（不带值），它将从作用域中获取相应的变量作为返回值。这也使得跟踪返回变量所遭受的修改变得更容易，以及确保你没有返回一个被修改的参数。
- en: Arrays, slices, and maps
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组、切片和映射
- en: Arrays are one of the most widely used types of computer programming. They are
    lists of other types that you can access by using their position on the list.
    The only downside of an array is that its size cannot be modified. Slices allow
    the use of arrays with variable size. The `maps` type will let us have a dictionary
    like structures in Go. Let's see how each work.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是计算机编程中最广泛使用的一种类型。它们是其他类型的列表，你可以通过使用列表中的位置来访问它们。数组的唯一缺点是它的大小不能被修改。切片允许使用可变大小的数组。`maps`类型将使我们能够在Go中拥有类似字典的结构。让我们看看每个是如何工作的。
- en: Arrays
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a numbered sequence of elements of a single type. You can store
    100 different unsigned integers in a unique variable, three strings or 400 `bool`
    values. Their size cannot be changed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个单一类型的元素编号序列。你可以在一个唯一的变量中存储100个不同的无符号整数，三个字符串或400个`bool`值。它们的大小不能改变。
- en: 'You must declare the length of the array on its creation as well as the type.
    You can also assign some value on creation. For example here you have 100 `int`
    values all with `0` as value:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在创建数组时声明其长度以及类型。你还可以在创建时分配一些值。例如，这里你有100个`int`值，它们的值都是`0`：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or an array of size 3 with `strings` already assigned:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个已分配`strings`的3大小数组：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here you have an array of 2 `bool` values that we initialize later:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个我们稍后初始化的2个`bool`值的数组：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Zero-initialization
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零初始化
- en: In our previous example, we have initialized an `array` of `bool` values of
    size `2`. We wouldn't need to assign `arr[1]` to `false` because of the nature
    of zero-initialization in the language. Go will initialize every value in a `bool`
    array to `false`. We will look deeper to zero-initialization later in this chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们已经初始化了一个大小为`2`的`bool`值数组。由于语言中零初始化的特性，我们不需要将`arr[1]`赋值为`false`。Go将初始化`bool`数组中的每个值都为`false`。我们将在本章后面更深入地探讨零初始化。
- en: Slices
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: 'Slices are similar to arrays, but their size can be altered on runtime. This
    is achieved, thanks to the underlying structure of a slice that is an array. So,
    like arrays, you have to specify the type of the slice and its size. So, use the
    following line to create a slice:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 切片与数组类似，但它们的大小可以在运行时改变。这是通过切片的底层结构实现的，该结构是一个数组。因此，就像数组一样，你必须指定切片的类型和大小。因此，使用以下行来创建一个切片：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This command has created an underlying array of ten elements. If we need to
    change the size of the slice by, for example, adding a new number, we would append
    the number to the slice:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个包含十个元素的底层数组。如果我们需要通过例如添加一个新数字来改变切片的大小，我们将数字追加到切片中：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The syntax of append is of the form ([array to append an item to], [item to
    append]) and returns the new slice, it does not modify the actual slice. This
    is also true to delete an item. For example, let''s delete the first item of the
    array as following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`的语法形式为（[要添加项的数组]，[要添加的项]）并返回新的切片，它不会修改实际的切片。删除项也是如此。例如，让我们按照以下方式删除数组中的第一个项：'
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Yes, like in arrays. But what about deleting the second item? We use the same
    syntax:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就像在数组中一样。但删除第二个项怎么办？我们使用相同的语法：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We take all elements from zero index (included) to the first index (not included)
    and each element from the second index (included) to the end of the array, effectively
    deleting the value at the second position in the slice (index 1 as we start counting
    with 0). As you can see, we use the undetermined arguments syntax as the second
    parameter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从零索引（包含）到第一个索引（不包含）的所有元素，以及从第二个索引（包含）到数组末尾的每个元素，实际上删除了切片中第二个位置的值（索引1，因为我们从0开始计数）。正如你所看到的，我们使用不确定参数语法作为第二个参数。
- en: Maps
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: 'Maps are like dictionaries--for each word, we have a definition but we can
    use any type as word or definition and they''ll never be ordered alphabetically.
    We can create maps of string that point to numbers, a string that points to `interfaces` and
    `structs` that point to `int` and `int` to `function`. You cannot use as key:
    slices, the functions, and maps. Finally, you create maps by using the keyword
    make and specifying the key type and the value type:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 映射就像字典一样--对于每个单词，我们都有一个定义，但我们可以使用任何类型作为单词或定义，并且它们永远不会按字母顺序排序。我们可以创建指向数字、指向`interfaces`和`structs`指向`int`以及`int`指向`function`的字符串映射。你不能使用切片、函数和映射作为键。最后，你通过使用关键字`make`并指定键类型和值类型来创建映射：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When parsing JSON content, you can also use them to get a `string[interface]`
    map:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析JSON内容时，你也可以使用它们来获取`string[interface]`映射：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `myJsonMap` variable is a map that will store the contents of JSON and that
    we will need to pass its pointer to the `Unmarshal` function. The `jsonData` variable
    declares an array of bytes with the typical content of a JSON object; we are using
    this as the mock object. Then, we unmarshal the contents of the JSON storing the
    result of the memory location of `myJsonMap` variable. After checking that the
    conversion was ok and the JSON byte array didn't have syntax mistakes, we can
    access the contents of the map in a JSON-like syntax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`myJsonMap`变量是一个将存储JSON内容并需要将其指针传递给`Unmarshal`函数的映射。`jsonData`变量声明了一个包含JSON对象典型内容的字节数组；我们使用这个作为模拟对象。然后，我们将JSON的内容解包到存储`myJsonMap`变量内存位置的映射中。在确认转换无误且JSON字节数组没有语法错误后，我们可以使用类似JSON的语法访问映射的内容。'
- en: Visibility
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性
- en: Visibility is the attribute of a function or a variable to be visible to different
    parts of the program. So a variable can be used only in the function that is declared,
    in the entire package or in the entire program.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性是函数或变量属性，使其对程序的不同部分可见。因此，一个变量只能在声明的函数、整个包或整个程序中使用。
- en: 'How can I set the visibility of a variable or function? Well, it can be confusing
    at the beginning but it cannot be simpler:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我该如何设置变量或函数的可见性？嗯，一开始可能会有些困惑，但操作实际上非常简单：
- en: Uppercase definitions are public (visible in the entire program).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写定义是公开的（在整个程序中可见）。
- en: Lowercase are private (not seen at the package level) and function definitions
    (variables within functions) are visible just in the scope of the function.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写是私有的（在包级别不可见）并且函数定义（函数内的变量）仅在函数的作用域内可见。
- en: 'Here you can see an example of a `public` function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到一个`public`函数的例子：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `Hello_world` is a global function (a function that is visible across
    the entire source code and to third party users of your code). So, if our package
    is called `hello`, we could call this function from outside of this package by
    using `hello.Hello_world()` method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Hello_world`是一个全局函数（在整个源代码和第三方用户代码中可见的函数）。所以，如果我们的包名为`hello`，我们可以通过使用`hello.Hello_world()`方法从包外部调用这个函数。
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we are in the `different_package` package. We have to import
    the package we want to use with the keyword import. The route then is the path
    within your `$GOPATH/src` that contains the package we are looking for. This path
    conveniently matches the URL of a GitHub account or any other **Concurrent Versions
    System**(**CVS**) repository.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们处于`different_package`包中。我们必须使用关键字`import`导入我们想要使用的包。路径是你的`$GOPATH/src`中的路径，它包含我们要查找的包。这个路径方便地与GitHub账户或其他任何**并发版本系统**(**CVS**)仓库的URL相匹配。
- en: Zero-initialization
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零初始化
- en: 'Zero-initialization is a source of confusion sometimes. They are default values
    for many types that are assigned even if you don''t provide a value for the definition.
    Following are the zero-initialization for various types:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 零初始化有时会引起混淆。对于许多类型，即使你没有为定义提供值，它们也会有默认值。以下是各种类型的零初始化：
- en: The `false` initialization for `bool` type.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`类型的`false`初始化。'
- en: Using `0` values for `int` type.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`int`类型使用`0`值。
- en: Using `0.0` for `float` type.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`float`类型使用`0.0`。
- en: Using `""` (empty strings) for `string` type.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`string`类型使用`""`（空字符串）。
- en: Using `nil` keyword for pointers, functions, interfaces, slices, channels and
    maps.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nil`关键字为指针、函数、接口、切片、通道和映射。
- en: Empty `struct` for structures without fields.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于没有字段的结构的空`struct`。
- en: Zero-initialized `struct` for structures with fields. The zero value of a structure
    is defined as the structure that has its fields initialized as zero value too.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于具有字段的结构的零初始化`struct`。结构的零值定义为所有字段都初始化为零值。
- en: Zero-initialization is important when programming in Go because you won't be
    able to return a `nil` value if you have to return an `int` type or a `struct`.
    Keep this in mind, for example, in functions where you have to return a `bool`
    value. Imagine that you want to know if a number is divisible by a different number
    but you pass `0` (zero) as the divisor.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言编程中，零初始化很重要，因为如果你必须返回`int`类型或`struct`，你将无法返回`nil`值。记住这一点，例如，在必须返回`bool`值的函数中。想象一下，你想知道一个数是否能被另一个数整除，但你传递了`0`（零）作为除数。
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this program is `false` but this is incorrect. A number divided
    by zero is an error, it''s not that 10 isn''t divisible by zero but that a number
    cannot be divided by zero by definition. Zero-initialization is making things
    awkward in this situation. So, how can we solve this error? Consider the following
    code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出是`false`，但这是不正确的。一个数除以零是一个错误，并不是说10不能被零整除，而是按照定义，一个数不能被零除。零初始化使这种情况变得尴尬。那么，我们如何解决这个问题呢？考虑以下代码：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're dividing `10` by `0` again but now the output of this function is `A number
    cannot be divided by zero`. Error captured, the program finished gracefully.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次将`10`除以`0`，但现在这个函数的输出是`一个数不能被零除`。错误被捕获，程序优雅地结束。
- en: Pointers and structures
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针和结构
- en: Pointers are the number one source of a headache of every C or C++ programmer.
    But they are one of the main tools to achieve high-performance code in non-garbage-collected
    languages. Fortunately for us, Go's pointers have achieved the best of both worlds
    by providing high-performance pointers with garbage-collector capabilities and
    easiness.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是每个C或C++程序员头痛的首要来源。但它们是实现非垃圾回收语言中高性能代码的主要工具之一。幸运的是，Go的指针通过提供具有垃圾回收功能的性能指针和易用性，实现了两者的最佳结合。
- en: On the other side for its detractors, Go lacks inheritance in favor of composition.
    Instead of talking about the objects that *are* in Go, your objects *have other *.
    So, instead of having a `car` structure that inherits the class `vehicle` (a car
    is a vehicle), you could have a `vehicle` structure that contains a `car` structure
    within.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它的批评者来说，Go语言没有继承，而是倾向于组合。与其谈论Go语言中的对象*是*什么，不如说你的对象*有*其他。因此，你不必有一个继承自`vehicle`类（汽车是一种车辆）的`car`结构，而可以有一个包含`car`结构的`vehicle`结构。
- en: What is a pointer? Why are they good?
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针是什么？为什么它们很好？
- en: Pointers are hated, loved, and very useful at the same time. To understand what
    a pointer is can be difficult so let's try with a real world explanation. As we
    mentioned earlier in this chapter, a pointer is a like a mailbox. Imagine a bunch
    of mailboxes in a building; all of them have the same size and shape but each
    refers to a different house within the building. Just because all mailboxes are
    the same size does not mean that each house will have the same size. We could
    even have a couple of houses joined, a house that was there but now has a license
    of commerce, or a house that is completely empty. So the pointers are the mailboxes,
    all of them of the same size and that refer to a house. The building is our memory
    and the houses are the types our pointers refer to and the memory they allocate.
    If you want to receive something in your house, it's far easier to simply send
    the address of your house (to send the pointer) instead of sending the entire
    house so that your package is deposited inside. But they have some drawbacks as
    if you send your address and your house (variable it refers to) disappears after
    sending, or its type owner change--you'll be in trouble.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 指针既受憎恨，又受喜爱，同时也非常有用。理解指针是什么可能很困难，所以让我们用一个现实世界的解释来尝试。正如我们在本章前面提到的，指针就像一个邮箱。想象一下一栋楼里的一堆邮箱；它们都有相同的大小和形状，但每个都指向楼内的不同房子。仅仅因为所有邮箱大小相同，并不意味着每个房子的大小都相同。我们甚至可以有两个房子相连，一个房子曾经在那里但现在有了商业许可证，或者一个完全空着的房子。所以，指针就像是邮箱，它们大小相同，但都指向一个房子。这栋楼是我们的内存，房子是我们指针指向的类型以及它们分配的内存。如果你想在你家里收到东西，简单地发送你房子的地址（发送指针）要比发送整个房子容易得多，这样你的包裹就可以存放在里面。但它们也有一些缺点，比如如果你发送了你的地址和你的房子（它所指向的变量），发送后你的房子（变量）消失了，或者它的类型所有者改变了——你将陷入麻烦。
- en: How is this useful? Imagine that somehow you have 4 GB of data in a variable
    and you need to pass it to a different function. Without a pointer, the entire
    variable is cloned to the scope of the function that is going to use it. So, you'll
    have 8 GB of memory occupied by using this variable twice that, hopefully, the
    second function isn't going to use in a different function again to raise this
    number even more.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用呢？想象一下，你有一个变量中有 4 GB 的数据，你需要将它传递给另一个函数。如果没有指针，整个变量将被克隆到将要使用它的函数的作用域中。所以，你会占用
    8 GB 的内存，使用这个变量两次，希望第二个函数不会再次在另一个函数中使用，以增加这个数字。
- en: You could use a pointer to pass a very small reference to this chunk to the
    first function so that just the small reference is cloned and you can keep your
    memory usage low.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用指针将一个非常小的引用传递给第一个函数，这样只需克隆这个小引用，你就可以保持内存使用量低。
- en: While this isn't the most academic nor exact explanation, it gives a good view
    of what a pointer is without explaining what a stack or a heap is or how they
    work in x86 architectures.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是最学术或最精确的解释，但它给出了一个很好的指针概念，而不必解释栈或堆是什么，或者它们在 x86 架构中是如何工作的。
- en: Pointers in Go are very limited compared with C or C++ pointers. You can't use
    pointer arithmetic nor can you create a pointer to reference an exact position
    in the stack.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的指针与 C 或 C++ 中的指针相比非常有限。你不能使用指针算术，也不能创建一个指针来引用堆栈中的确切位置。
- en: 'Pointers in Go can be declared like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的指针可以声明如下：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here `number := 5` code represents our 4 GB variable and `pointer_to_number`
    contains the reference (represented by an ampersand) to this variable. It''s the
    direction to the variable (the one that you put in the mailbox of this `house/type/variable`).
    Let''s print the variable `pointer_to_number` , which is a simple variable:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `number := 5` 代码代表我们的 4 GB 变量，`pointer_to_number` 包含对这个变量的引用（用 ampersand
    表示），这是指向变量（你放在这个“房子/类型/变量”邮箱里的那个）的方向。让我们打印变量 `pointer_to_number`，它是一个简单的变量：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What's that number? Well, the direction to our variable in memory. And how can
    I print the actual value of the house? Well, with an asterisk (`*)` we tell the
    compiler to take the value that the pointer is referencing, which is our 4 GB
    variable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那这个数字是什么？嗯，这是指向我们变量的内存方向。我怎样才能打印出房子的实际值呢？嗯，用星号（`*`）告诉编译器取指针所引用的值，也就是我们的 4 GB
    变量。
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Structs
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: A struct is an object in Go. It has some similarities with classes in OOP as
    they have fields. Structs can implement interfaces and declare methods. But, for
    example, in Go, there's not inheritance. Lack of inheritance looks limiting but
    in fact, *composition over inheritance* was a requirement of the language.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是 Go 中的一个对象。它们与面向对象中的类有一些相似之处，因为它们都有字段。结构体可以实现接口并声明方法。但在 Go 中，没有继承。缺乏继承看起来很有限，但实际上，*组合优于继承*
    是语言的要求。
- en: 'To declare a structure, you have to prefix its name with the keyword `type`
    and suffix with the keyword `struct` and then you declare any field or method
    between brackets, for example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个结构体，你必须在它的名字前加上关键字 `type`，并在其后加上关键字 `struct`，然后你可以在括号内声明任何字段或方法，例如：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this piece of code, we have declared a `Person` structure with three public
    fields (`Name`, `Age` , and `Hobbies`) and one private field (`id`, if you recall
    the *Visibility* section in this chapter, lowercase fields in Go refers to private
    fields are just visible within the same package). With this `struct`, we can now
    create as many instances of `Person` as we want. Now we will write a function
    called `GetFullName` that will give the composition of the name and the surname
    of the `struct` it belongs to:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们声明了一个具有三个公共字段（`Name`、`Age` 和 `Hobbies`）和一个私有字段（`id`，如果你还记得本章中的 *可见性*
    部分，Go 中的小写字段表示私有字段，仅在同一包内可见）的 `Person` 结构体。有了这个 `struct`，我们现在可以创建任意数量的 `Person`
    实例。现在我们将编写一个名为 `GetFullName` 的函数，该函数将给出结构体所属的姓名和姓氏的组合：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Methods are defined similarly to functions but in a slightly different way.
    There is a`(p *Person)` that refers to a pointer to the created instance of the
    `struct` (recall the *Pointers* section in this chapter). It's like using the
    keyword `this` in Java or `self` in Python when referring to the pointing object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义的方式与函数类似，但略有不同。有一个 `(p *Person)` 指向创建的 `struct` 实例的指针（回想一下本章中的 *指针* 部分）。这就像在
    Java 中使用关键字 `this` 或者在 Python 中使用 `self` 来引用指向的对象。
- en: Maybe you are thinking why does (`p *Person`) have the pointer operator to reflect
    that `p` is actually a pointer and not a value? This is because you can also pass
    Person by value by removing the pointer signature, in which case a copy of the
    value of Person is passed to the function. This has some implications, for example,
    any change that you make in p if you pass it by value won't be reflected in source
    `p`. But what about our `GetFullName()` method?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么 (`p *Person`) 有指针运算符来反映 `p` 实际上是一个指针而不是一个值？这是因为你也可以通过移除指针签名以值的方式传递
    `Person`。在这种情况下，将传递 `Person` 值的一个副本到函数中。这有一些影响，例如，如果你通过值传递修改了 `p`，那么这些更改不会反映在源
    `p` 上。但我们的 `GetFullName()` 方法呢？
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Its console output has no effect in appearance but a full copy was passed before
    evaluating the function. But if we modify `person` here, the source `p` won't
    be affected and the new `person` value will be available only on the scope of
    this function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其控制台输出在外观上没有影响，但在评估函数之前已经传递了一个完整的副本。但如果在这里修改 `person`，源 `p` 不会受到影响，新的 `person`
    值将只在这个函数的作用域内可用。
- en: On the `main` function, we create an instance of our structure called `p`. As
    you can see, we have used implicit notation to create the variable (the `:=` symbol).
    To set the fields, you have to refer to the name of the field, colon, the value,
    and the comma (don't forget the comma at the end!). To access the fields of the
    instantiated structure, we just refer to them by their name like `p.Name` or `p.Surname`.
    You use the same syntax to access the methods of the structure like `p.GetFullName()`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建了一个名为 `p` 的结构体实例。正如你所见，我们使用了隐式表示法来创建变量（`:=` 符号）。要设置字段，你必须引用字段名，冒号，值，然后是逗号（别忘了最后的逗号！）。要访问实例化结构体的字段，我们只需通过它们的名称来引用，如
    `p.Name` 或 `p.Surname`。你使用相同的语法来访问结构体的方法，如 `p.GetFullName()`。
- en: 'The output of this program is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出是：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Structures can also contain another structure (composition) and implement interface
    methods apart from their own but, what's an interface method?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体也可以包含另一个结构体（组合）并实现接口方法，除了它们自己的方法之外，但什么是接口方法呢？
- en: Interfaces
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are essential in object-oriented programming, in functional programming
    (`traits`) and, especially, in design patterns. Go's source code is full of interfaces
    everywhere because they provide the abstraction needed to deliver uncoupled code
    with the help of functions. As a programmer, you also need this type of abstraction
    when you write libraries but also when you write code that is going to be maintained
    in the future with new functionality.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在面向对象编程、函数式编程（特性）和，尤其是，在设计模式中是必不可少的。Go的源代码到处都是接口，因为它们提供了通过函数帮助实现解耦代码所需的抽象。作为程序员，当你编写库或编写将来需要添加新功能的代码时，你也需要这种类型的抽象。
- en: Interfaces are something difficult to grasp at the beginning but very easy once
    you have understood their behavior and provide very elegant solutions for common
    problems. We will use them extensively during this book so put special focus on
    this section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在开始时可能难以理解，但一旦你了解了它们的行为，就能提供非常优雅的解决方案来解决常见问题。在这本书中，我们将广泛使用它们，所以请特别关注这一部分。
- en: Interfaces - signing a contract
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口 - 签订合同
- en: An interface is something really simple but powerful. It's usually defined as
    a contract between the objects that implement it but this explanation isn't clear
    enough in my honest opinion for newcomers to the interface world.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接口实际上非常简单但功能强大。它通常被定义为实现它的对象之间的合同，但在我看来，这种解释对于初学者来说还不够清晰。
- en: A water-pipe is a contract too; whatever you pass through it must be a liquid.
    Anyone can use the pipe, and the pipe will transport whatever liquid you put in
    it (without knowing the content). The water-pipe is the interface that enforces
    that the users must pass liquids (and not something else).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 水管也是一种合同；无论你通过它传递什么，都必须是液体。任何人都可以使用管道，管道将运输你放入其中的任何液体（而不了解内容）。水管是强制用户必须传递液体（而不是其他东西）的接口。
- en: 'Let''s think about another example: a train. The railroads of a train are like
    an interface. A train must construct (implement) its width with a specified value
    so that it can enter the railroad but the railroad never knows exactly what it''s
    carrying (passengers or cargo). So for example, an interface of the railroad will
    have the following aspect:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再考虑另一个例子：火车。火车的轨道就像一个接口。火车必须用指定的值构建（实现）其宽度，以便它可以进入铁路，但铁路永远不会确切知道它携带的是什么（乘客或货物）。例如，铁路的接口将具有以下方面：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `RailroadWideChecker` is the type our trains must implement to provide
    information about their width. The trains will verify that the train isn''t too
    wide or too narrow to use its railroads:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`RailroadWideChecker`是我们火车必须实现的类型，以提供有关其宽度的信息。火车将验证火车不会太宽或太窄，无法使用其铁路：'
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Railroad` is implemented by an imaginary station object that contains
    the information about the width of the railroads in this station and that has
    a method to check whether a train fits the needs of the railroad with the `IsCorrectSizeTrain`
    method. The `IsCorrectSizeTrain` method receives an interface object which is
    a pointer to a train that implements this interface and returns a validation between
    the width of the train and the railroad:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Railroad`是通过一个包含有关该站铁路宽度信息的虚拟站对象实现的，并且有一个`IsCorrectSizeTrain`方法来检查火车是否符合铁路的需求。`IsCorrectSizeTrain`方法接收一个接口对象，它是指向实现此接口的火车的指针，并返回火车宽度和铁路宽度之间的验证：'
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we have created a passenger's train. It has a field to contain its width
    and implements our `CheckRailsWidth` interface method. This structure is considered
    to fulfill the needs of a `RailRoadWideChecker` interface (because it has an implementation
    of the methods that the interfaces ask for).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一列旅客火车。它有一个字段来包含其宽度，并实现了我们的`CheckRailsWidth`接口方法。这种结构被认为满足了`RailRoadWideChecker`接口的需求（因为它实现了接口所要求的方法）。
- en: So now, we'll create a railroad of `10` units wide and two trains--one of `10`
    units wide that fit the railroad size and another of `15` units that cannot use
    the railroad.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们将创建一个宽度为`10`个单位的铁路和两列火车——一列宽度为`10`个单位，适合铁路尺寸，另一列宽度为`15`个单位，无法使用铁路。
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s dissect this `main` function. First, we created a railroad object of
    `10` units called `railroad`. Then two trains, of `10` and `15` units'' width
    for passengers and cargo respectively. Then, we pass both objects to the railroad
    method that accepts interfaces of the `RailroadWideChecker` interface. The railroad
    itself does not know the width of each train separately (we''ll have a huge list
    of trains) but it has an interface that trains must implement so that it can ask
    for each width and returns a value telling you if a train can or cannot use of
    the railroads. Finally, the output of the call to `printf` function is the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析这个`main`函数。首先，我们创建了一个名为`railroad`的铁路对象，其长度为`10`个单位。然后创建了两个火车，一个是`10`个单位宽的客运火车，另一个是`15`个单位宽的货运火车。然后，我们将这两个对象传递给接受`RailroadWideChecker`接口的铁路方法。铁路本身并不知道每列火车的单独宽度（我们将有一个庞大的火车列表），但它有一个火车必须实现的接口，以便它可以询问每列火车的宽度，并返回一个值告诉您火车是否可以使用铁路。最后，`printf`函数调用的输出如下：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As I mentioned earlier, interfaces are so widely used during this book that
    it doesn't matter if it still looks confusing for the reader as they'll be plenty
    of examples during the book.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，接口在本书中被广泛使用，所以即使对于读者来说仍然看起来有些混乱，也没有关系，因为书中会有大量的示例。
- en: Testing and TDD
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和TDD
- en: When you write the first lines of some library, it's difficult to introduce
    many bugs. But once the source code gets bigger and bigger, it becomes easier
    to break things. The team grows and now many people are writing the same source
    code, new functionality is added on top of the code that you wrote at the beginning.
    And code stopped working by some modification in some function that now nobody
    can track down.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写某个库的第一行代码时，引入许多错误是困难的。但一旦源代码越来越大，破坏事物就变得更容易了。团队在增长，现在很多人在编写相同的源代码，新的功能被添加到您最初编写的代码之上。由于某个函数的修改，代码停止工作，而现在没有人能够追踪到这个问题。
- en: This is a common scenario in enterprises that testing tries to reduce (it doesn't
    completely solve it, it's not a holy grail). When you write unit tests during
    your development process, you can check whether some new feature is breaking something
    older or whether your current new feature is achieving everything expected in
    the requirements.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在企业中测试试图减少的常见场景（它并不完全解决这个问题，它不是圣杯）。当您在开发过程中编写单元测试时，您可以检查是否有一些新功能破坏了旧功能，或者您当前的新功能是否实现了所有预期的需求。
- en: Go has a powerful testing package that allows you also to work in a TDD environment
    quite easily. It is also very convenient to check the portions of your code without
    the need to write an entire main application that uses it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个强大的测试包，它还允许您在TDD环境中轻松工作。检查您的代码片段而不需要编写一个使用它的完整主应用程序也非常方便。
- en: The testing package
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试包
- en: Testing is very important in every programming language. Go creators knew it
    and decided to provide all libraries and packages needed for the test in the core
    package. You don't need any third-party library for testing or code coverage.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，测试都非常重要。Go语言的创造者深知这一点，并决定在核心包中提供所有必要的测试库和包。您不需要任何第三方库来进行测试或代码覆盖率。
- en: 'The package that allows for testing Go apps is called, conveniently, testing.
    We will create a small app that sums two numbers that we provide through the command
    line:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 允许测试Go应用程序的包被称为`testing`。我们将创建一个小应用程序，该程序通过命令行接收两个数字并将它们相加：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s execute our program in the terminal to get the sum:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中运行我们的程序来获取总和：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By the way, we're using the `strconv` package to convert strings to other types,
    in this case, to `int`. The method `Atoi` receives a string and returns an `int` and
    an `error` that, for simplicity, we are ignoring here (by using the underscore).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们正在使用`strconv`包将字符串转换为其他类型，在这种情况下，转换为`int`。`Atoi`方法接收一个字符串并返回一个`int`和一个`error`，为了简单起见，我们在这里忽略它（通过使用下划线）。
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can ignore variable returns by using the underscores if necessary, but usually,
    you don't want to ignore errors.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以通过使用下划线来忽略变量返回值，但通常您不想忽略错误。
- en: 'Ok, so let''s write a test that checks the correct result of the sum. We''re
    creating a new file called `main_test.go`. By convention, test files are named
    like the files they''re testing plus the `_test` suffix:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以让我们编写一个测试来检查求和的正确结果。我们正在创建一个名为`main_test.go`的新文件。按照惯例，测试文件的命名方式是它们要测试的文件名加上`_test`后缀：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Testing in Go is used by writing methods started with the prefix `Test`, a test
    name, and the injection of the `testing.T` pointer called `t`. Contrary to other
    languages, there are no asserts nor special syntax for testing in Go. You can
    use Go syntax to check for errors and you call `t` with information about the
    error in case it fails. If the code reaches the end of the `Test` function without
    arising errors, the function has passed the tests.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中进行测试是通过编写以`Test`前缀开头的方法、一个测试名称以及注入名为`t`的`testing.T`指针来实现的。与其它语言不同，Go中没有断言或特殊的测试语法。你可以使用Go语法来检查错误，并在失败的情况下通过`t`传递有关错误的信息。如果代码在`Test`函数的末尾没有出现错误，则该函数通过了测试。
- en: 'To run a test in Go, you must use the `go test -v` command (`-v` is to receive
    verbose output from the test) keyword, as following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Go中运行测试，你必须使用`go test -v`命令（`-v`是为了从测试中获得详细输出）关键字，如下所示：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our tests were correct. Let''s see what happens if we break things on purpose
    and we change the expected value of the test from `11` to `10`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试是正确的。让我们看看如果我们故意破坏某些东西，并将测试的预期值从`11`更改为`10`会发生什么：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The test has failed (as we expected). The testing package provides the information
    you set on the test. Let''s make it work again and check test coverage. Change
    the value of the variable `expected` from `10` to `11` again and run the command
    `go test -cover` to see code coverage:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败了（正如我们所预期的）。测试包提供了你在测试中设置的信息。让我们让它再次工作并检查测试覆盖率。将变量`expected`的值从`10`再次更改为`11`，然后运行命令`go
    test -cover`来查看代码覆盖率：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `-cover` options give us information about the code coverage for a given
    package. Unfortunately, it doesn't provide information about overall application
    coverage.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`-cover`选项为我们提供了关于给定包的代码覆盖率信息。不幸的是，它并不提供关于整体应用覆盖率的信息。'
- en: What is TDD?
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是TDD？
- en: TDD is the acronym for **Test Driven Development**. It consists of writing the
    tests first before writing the function (instead of what we did just before when
    we wrote the `sum` function first and then we wrote the `test` function).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是**测试驱动开发**的缩写。它包括在编写函数之前先编写测试（而不是我们在编写`sum`函数之前所做的那样）。
- en: TDD changes the way to write code and structure code so that it can be tested
    (a lot of code you can find in GitHub, even code that you have probably written
    in the past is probably very difficult, if not impossible, to test).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: TDD改变了编写代码和结构代码的方式，以便它可以被测试（你可以在GitHub上找到很多代码，甚至可能是你过去写的代码，可能非常难以测试，如果不是不可能的话）。
- en: 'So, how does it work? Let''s explain this with a real life example--imagine
    that you are in summer and you want to be refreshed somehow. You can build a pool,
    fill it with cold water, and jump into it. But in TDD terms, the steps will be:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？让我们用一个现实生活中的例子来解释这一点——想象一下你在夏天，你想以某种方式感到凉爽。你可以建一个泳池，装满冷水，然后跳进去。但在TDD的术语中，步骤将是：
- en: You jump into a place where the pool will be built (you write a test that you
    know it will fail).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你跳进一个将要建泳池的地方（你编写一个你知道会失败的测试）。
- en: It hurts... and you aren't cool either (yes... the test failed, as we predicted).
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 疼痛……而且你也不酷（是的……测试失败了，正如我们所预测的）。
- en: You build a pool and fill it with cold water (you code the functionality).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你建一个泳池并装满冷水（你编写功能代码）。
- en: You jump into the pool (you repeat the point 1 test again).
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你跳进了泳池（你再次重复了第1点测试）。
- en: You're cold now. Awesome! Object completed (test passed).
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在感觉冷了。太棒了！对象完成（测试通过）。
- en: Go to the fridge and take a beer to the pool. Drink. Double awesomeness (refactor
    the code).
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去冰箱拿一瓶啤酒到泳池边。喝。双倍酷（重构代码）。
- en: 'So let''s repeat the previous example but with a multiplication. First, we
    will write the declaration of the function that we''re going to test:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们重复之前的例子，但这次是乘法。首先，我们将编写将要测试的函数的声明：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now let''s write the test that will check the correctness of the previous function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一个测试，以检查之前函数的正确性：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And we test it through the command line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过命令行来测试它：
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Nice. Like in our pool example where the water wasn''t there yet, our function
    returns an incorrect value too. So now we have a function declaration (but isn''t
    defined yet) and the test that fails. Now we have to make the test pass by writing
    the function and executing the test to check:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。就像我们的泳池例子中水还没到那里一样，我们的函数返回了一个错误值。所以现在我们有一个函数声明（但尚未定义）和一个失败的测试。现在我们必须通过编写函数并执行测试来使测试通过：
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And we execute again our testing suite. After writing our code correctly, the
    test should pass so we can continue to the refractoring process:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Great! We have developed the `multiply` function following TDD. Now we must
    refactor our code but we cannot make it more simple or readable so the loop can
    be considered closed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: During this book, we will write many tests that define the functionality that
    we want to achieve in our patterns. TDD promotes encapsulation and abstraction
    (just like design patterns do).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, most of our examples were applications. An application is defined
    by its `main` function and package. But with Go, you can also create pure libraries.
    In libraries, the package need not be called main nor do you need the `main` function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: As libraries aren't applications, you cannot build a binary file with them and
    you need the `main` package that is going to use them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create an arithmetic library to perform common operations
    on integers: sums, subtractions, multiplications, and divisions. We''ll not get
    into many details about the implementation to focus on the particularities of
    Go''s libraries:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'First, we need a name for our library; we set this name by giving a name to
    the entire package. This means that every file in this folder must have this package
    name too and the entire group of files composes the library called **arithmetic**
    too in this case (because it only contains one package). This way, we won''t need
    to refer to the filenames for this library and to provide the library name and
    path will be enough to import and use it. We have defined a `Sum` function that
    takes as many arguments as you need and that will return an integer that, during
    the scope of the function, is going to be called `res`. This allows us to initialize
    to `0` the value we''re returning. We defined a package (not the `main` package
    but a library one) and called it `arithmetic`. As this is a library package, we
    can''t run it from the command line directly so we''ll have to create the `main`
    function for it or a unit test file. For simplicity , we''ll create a `main` function
    that runs some of the operations now but let''s finish the library first:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `Subtraction` code will return `0` if the number of arguments is less than
    zero and the subtraction of all its arguments if it has two arguments or more:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `Multiply` function works in a similar fashion. It returns `0` when arguments
    are less than two and the multiplication of all its arguments when it has two
    or more. Finally, the `Division` code changes a bit because it will return an
    error if you ask it to divided by zero:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So now we have our library finished, but we need a `main` function to use it
    as libraries cannot be converted to executable files directly. Our main function
    looks like the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We are performing an operation over every function that we have defined. Take
    a closer look at the `import` clause. It is taking the library we have written
    from its folder within `$GOPATH` that matches its URL in [https://bitbucket.org/](https://bitbucket.org/)
    . Then, to use every one of the functions that are defined within a library, you
    have to name the package name that the library has before each method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you realized that we called our functions with uppercase names? Because
    of the visibility rules we have seen before, exported functions in a package must
    have uppercase names or they won't be visible outside of the scope of the package.
    So, with this rule in mind, you cannot call a lowercase function or variable within
    a package and package calls will always be followed by uppercase names.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall, some naming conventions about libraries:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Each file in the same folder must contain the same package name. Files don't
    need to be named in any special way.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A folder represents a package name within a library. The folder name will be
    used on import paths and it doesn't need to reflect the package name (although
    it's recommended for the parent package).
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A library is one or many packages representing a tree that you import by the
    parent of all packages folder.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You call things within a library by their package name.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go get tool
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go get is a tool to get third party projects from CVS repositories. Instead
    of using the `git clone` command, you can use Go get to receive a series of added
    benefits. Let's write an example using CoreOS's **ETCD **project which is a famous
    distributed key-value store.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'CoreOS''s ETCD is hosted on GitHub at  [https://github.com/coreos/etcd.git](https://github.com/coreos/etcd.git).
    To download this project source code using the Go get tool, we must type in the
    Terminal it''s resulting import path that it will have in our GOPATH:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that we have just typed the most relevant information so that Go get figures
    out the rest. You'll get some output, depending on the state of the project, but
    after, while, it will disappear. But what did happen?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Go get has created a folder in `$GOPATH/src/github.com/coreos`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has cloned the project in that location, so now the source code of ETCD is
    available at `$GOPATH/src/github.com/coreos/etcd`.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go get has cloned any repository that ETCD could need.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has tried to install the project if it is not a library. This means, it has
    generated a binary file of ETCD and has put it in `$GOPATH/bin` folder.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By simply typing the `go get [project]` command, you''ll get all that material
    from a project in your system. Then in your Go apps, you can just use any library
    by importing the path within the source. So for the ETCD project, it will be:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It's very important that you get familiar with the use of the Go get tool and
    stop using `git clone` when you want a project from a Git repository. This will
    save you some headaches when trying to import a project that isn't contained within
    your GOPATH.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Managing JSON data
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON is the acronym for **JavaScript Object Notation** and, like the name implies,
    it''s natively JavaScript. It has become very popular and it''s the most used
    format for communication today. Go has very good support for JSON serialization/deserialization
    with the `JSON` package that does most of the dirty work for you. First of all,
    there are two concepts to learn when working with JSON:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '**Marshal**: When you marshal an instance of a structure or object, you are
    converting it to its JSON counterpart.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unmarshal**: When you are unmarshaling some data, in the form of an array
    of bytes, you are trying to convert some JSON-expected-data to a known struct
    or object. You can also *unmarshal* to a `map[string]interface{}` in a fast but
    not very safe way to interpret the data as we''ll see now.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an example of marshaling a string:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: First, we have defined a variable called `packt` to hold the contents of the
    `packt` string. Then, we have used the `json` library to use the `Marshal` command
    with our new variable. This will return a new `bytearray` with the JSON and a
    flag to provide and `boolOK` result for the operation. When we print the contents
    of the bytes array (previous casting to string) the expected value appears. Note
    that `packt` appeared actually between quotes as the JSON representation would
    be.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The encoding package
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you realized that we have imported the package `encoding/json`? Why is
    it prefixed with the word `encoding`? If you take a look at Go's source code to
    the `src/encoding` folder you'll find many interesting packages for encoding/decoding
    such as, XML, HEX, binary, or even CSV.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Now something a bit more complicated:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Conveniently, it also works pretty well with structures but what if I want
    to not use uppercase in the JSON data? You can define the output/input name of
    the JSON in the structure declaration:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We have not only lowercased the names of the keys, but we have even changed
    the name of the `Word` key to string.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough of marshalling, we will receive JSON data as an array of bytes, but
    the process is very similar with some changes:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The big difference here is that you have to allocate the space for the structure
    first (with a zero value) and the pass the reference to the method `Unmarshal`
    so that it tries to fill it. When you use `Unmarshal`, the first parameter is
    the array of bytes that contains the JSON information while the second parameter
    is the reference (that''s why we are using an ampersand) to the structure we want
    to fill. Finally, let''s use a generic `map[string]interface{}` method to hold
    the content of a JSON:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: What happened in the result? This is why we described the object as dangerous.
    You can point to a `nil` location when using this mode if you call a non-existing
    key in the JSON. Not only this, like in the example, it could also interpret a
    value as a `float64` when it is simply a `byte`, wasting a lot of memory.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: So remember to just use `map[string]interface{}` when you need dirty quick access
    to JSON data that is fairly simple and you have under control the type of scenarios
    described previously.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Go tools
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go comes with a series of useful tools to ease the development process every
    day. Also in the golang page of GitHub, there are some tools that are supported
    by the Go team but they are not part of the compiler.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Most of the projects use tools such as `gofmt` so that all the code base looks
    similar. Godoc helps us to find useful information in Go's documentation and the `goimport`
    command to auto-import the packages we are using. Let's see them.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The golint tool
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A linter analyzes source code to detect errors or improvements. The `golint`
    linter is available on [https://github.com/golang/lint](https://github.com/golang/lint) for
    installation (it doesn''t come bundled with the compiler). It is very easy to
    use and is integrated some IDEs to be run when you save a source code file (Atom
    or Sublime Text, for example). Do you remember the implicit/explicit code that
    we run when talking about variables? Let''s lint it:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `main.go:10:21:` command should omit the type string from the declaration
    of the `explicitString` variable; it will be inferred from the right-hand side.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: It is telling us that Go compiler will actually infer this type of a variable
    from the code and you don't need to declare its type. What about the `Train` type
    on the interface section?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `main.go:5:6:` type exported `Train` type should have a comment or remain
    not exported.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it's pointing us that a public type such as `Train` type must
    be commented so that users can read the generated documentation to know its behavior.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The gofmt tool
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `gofmt` tool comes bundled with the compiler that already has access to
    it. Its purpose is to provide a set of indentation, formatting, spacing and few
    other rules to achieve good-looking Go code. For example, let''s take the code
    of Hello World and make it a bit weirder by inserting spaces everywhere:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `gofmt` command prints it correctly again. What is more, we can use the
    `-w` flag to overwrite the original file:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: And now we'll have our file properly corrected.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: The godoc tool
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go documentation is pretty extended and verbose. You can find detailed information
    about any topic you want to achieve. The `godoc` tool also helps you access this
    documentation directly from the command line. For example, we can query the package
    `encoding/json`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can also use **grep**, a bash utility for Linux and Mac, to find specific
    information about some functionality. For example, we''ll use grep to look for
    text that mentions anything about parsing JSON files:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `Unmarshal` command parses the JSON encoded data and stores the result in
    the object being parsed.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that the `golint` command warns about is to use the beginning
    of a comment with the same name of the function it describes. This way, if you
    don't remember the name of the function that parses JSON, you can use `godoc`
    with `grep` and search for `parse` so the beginning of the line will always be
    the function name like in the example preceding the `Unmarshal` command.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The goimport tool
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `goimport` tool is a must have in Go. Sometimes you remember your packages
    so well that you don't need to search much to remember their API but it's more
    difficult to remember the project they belong to when doing the import. The `goimport`
    command helps you by searching your `$GOPATH` for occurrences of a package that
    you could be using to provide you with the project `import` line automatically.
    This is very useful if you configure your IDE to run `goimport` on save so that
    all used packages in the source file are imported automatically if you used them.
    It also works the other way around--if you delete the function you were using
    from a package and the package isn't being used anymore, it will remove the `import`
    line.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Contributing to Go open source projects in GitHub
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important thing to mention about Go packaging system is that it needs to
    have a proper folder structure within the GOPATH. This introduces a small problem
    when working with GitHub projects. We are used to forking a project, cloning our
    fork and start working before committing the pull-request to the original project.
    Wrong!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'When you fork a project, you create a new repository on GitHub within your
    username. If you clone this repository and start working with it, all new import
    references in the project will point to your repository instead of the original!
    Imagine the following case in the original repository:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, you make a fork and add a subfolder with a library called `a_library/my_library`
    that you want to use from the main package. The result is going to be the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now if you commit this line, the original repository that contains the code
    you have pushed will download this code anyways from your account again and it
    will use the references downloaded! Not the ones contained in the project!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the solution to this is simply to replace the `git clone` command with
    a `go get` pointing to the original library:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With this modification, you can work normally in the original code without fear
    as the references will stay correct. Once you are done you just have to commit
    and push to your remote.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This way, you can now access the GitHub web user interface and open the pull
    request without polluting the actual original code with references to your account.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After this first chapter, you must be familiar with the syntax of Go and some
    of the command-line tools that come bundled with the compiler. We have left apart
    concurrency capabilities for a later chapter as they are large and pretty complex
    to grasp at the beginning so that the reader learns the syntax of the language
    first, becomes familiar and confident with it, and then they can jump to understanding **Communicating
    Sequential Processes** (**CSP**) concurrency patterns and distributed applications.
    The next steps are to start with the creational design patterns.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，你必须熟悉 Go 语言的语法以及与编译器捆绑的一些命令行工具。我们将并发能力留到后面的章节，因为它们很大，而且一开始理解起来相当复杂，这样读者可以先学习语言的语法，熟悉并对其有信心，然后他们可以跳到理解**通信顺序过程**（**CSP**）并发模式和分布式应用。下一步是从创建型设计模式开始。
