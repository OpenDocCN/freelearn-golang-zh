<html><head></head><body>
<div class="book" title="Creating programs" id="1DOR01-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Accessing program arguments"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec106" class="calibre1"/>Accessing program arguments</h2></div></div></div><p class="calibre10">When a program is executed, the Go runtime makes all command-line arguments available as a slice via package variable <code class="email">os.Args</code>. For instance, when the following program is executed, it prints all command-line arguments passed to the program:</p><pre class="programlisting">package main 
import ( 
   "fmt" 
   "os" 
) 
 
func main() { 
   for _, arg := range os.Args { 
         fmt.Println(arg) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch06-args/hello.go</p><p class="calibre10">The following is the output of the program when it is invoked with the shown arguments:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go run hello.go hello world how are you?</strong></span>
<span class="strong"><strong class="calibre2">/var/folders/.../exe/hello</strong></span>
<span class="strong"><strong class="calibre2">hello</strong></span>
<span class="strong"><strong class="calibre2">world</strong></span>
<span class="strong"><strong class="calibre2">how</strong></span>
<span class="strong"><strong class="calibre2">are</strong></span>
<span class="strong"><strong class="calibre2">you?</strong></span>
</pre><p class="calibre10">Note that the command-line argument <code class="email">"hello world how are you?"</code>, placed after the program's name, is split as a space-delimited string. Position 0 in slice <code class="email">os.Args</code> holds the fully qualified name of the program's binary path. The rest of the slice stores each item in the string respectively.</p><p class="calibre10">The <code class="email">flag</code> package, from Go's standard library, uses this mechanism internally to provide processing of structured command-line arguments known as flags. In the Ohm's Law example listed earlier, the <code class="email">flag</code> package is used to parse several flags, as listed in the following source snippet (extracted from the full listing earlier):</p><pre class="programlisting">var ( 
   op string 
   v float64 
   r float64 
   i float64 
   p float64 
) 
 
func init() { 
   flag.Float64Var(&amp;v, "v", 0.0, "Voltage value (volt)") 
   flag.Float64Var(&amp;r, "r", 0.0, "Resistance value (ohms)") 
   flag.Float64Var(&amp;i, "i", 0.0, "Current value (amp)") 
   flag.Float64Var(&amp;p, "p", 0.0, "Electrical power (watt)") 
   flag.StringVar(&amp;op, "op", "V", "Command - one of { V | Vpi |"+   
    " R | Rvp | I | Ivp | P | Pir | Pvr }") 
} 
func main(){ 
  flag.Parse() 
  ... 
} 
</pre><p class="calibre10">The snippet shows function <code class="email">init</code> used to parse and initialize expected flags <code class="email">"v"</code>, <code class="email">"i"</code>, <code class="email">"p",</code> and <code class="email">"op"</code> (at runtime, each flag is prefixed with a minus sign). The initialization functions in package <code class="email">flag</code> sets up the expected type, the default value, a flag description, and where to store the parsed value for the flag. The flag package also supports the special flag "help", used to provide helpful hints about each flag.</p><p class="calibre10"><code class="email">flag.Parse()</code>, in the function <code class="email">main</code>, is used to start the process of parsing any flags provided as command-line. For instance, to calculate the current of a circuit with 12 volts and 300 ohms, the program takes three flags and produces the shown output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go run main.go -op I -v 12 -r 300</strong></span>
<span class="strong"><strong class="calibre2">I = 12.00 / 300.00 = 0.04 amps</strong></span>
</pre></div></div></body></html>