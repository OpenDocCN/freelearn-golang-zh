["```go\nmkdir -p $GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton \ncd $GOPATH/src/github.com/sayden/go-design-\npatterns/creational/singleton\n\n```", "```go\npackage singleton \n\ntype Singleton interface { \n    AddOne() int \n} \n\ntype singleton struct { \n    count int \n} \n\nvar instance *singleton \n\nfunc GetInstance() Singleton { \n    return nil \n} \nfunc (s *singleton) AddOne() int { \n    return 0 \n} \n\n```", "```go\npackage singleton \n\nimport \"testing\" \n\nfunc TestGetInstance(t *testing.T) { \n   counter1 := GetInstance() \n\n   if counter1 == nil { \n         //Test of acceptance criteria 1 failed \n         t.Error(\"expected pointer to Singleton after calling GetInstance(), not nil\") \n   } \n\n   expectedCounter := counter1 \n} \n\n```", "```go\ncurrentCount := counter1.AddOne() \nif currentCount != 1 { \n     t.Errorf(\"After calling for the first time to count, the count must be 1 but it is %d\\n\", currentCount) \n} \n\n```", "```go\ncounter2 := GetInstance() \nif counter2 != expectedCounter { \n    //Test 2 failed \n    t.Error(\"Expected same instance in counter2 but it got a different instance\") \n} \n\n```", "```go\ncurrentCount = counter2.AddOne() \nif currentCount != 2 { \n    t.Errorf(\"After calling 'AddOne' using the second counter, the current count must be 2 but was %d\\n\", currentCount) \n} \n\n```", "```go\n$ go test -v .\n=== RUN   TestGetInstance\n--- FAIL: TestGetInstance (0.00s)\n singleton_test.go:9: expected pointer to Singleton after calling GetInstance(), not nil\n singleton_test.go:15: After calling for the first time to count, the count must be 1 but it is 0\n singleton_test.go:27: After calling 'AddOne' using the second counter, the current count must be 2 but was 0\nFAIL\nexit status 1\nFAIL\n\n```", "```go\npackage creational \n\ntype singleton struct{ \n    count int \n} \n\nvar instance *singleton \n\nfunc GetInstance() *singleton { \n    if instance == nil { \n        instance = new(singleton) \n    }  \n    return instance \n} \n\nfunc (s *singleton) AddOne() int { \n    s.count++ \n    return s.count \n} \n\n```", "```go\n$ go test -v -run=GetInstance\n=== RUN   TestGetInstance\n--- PASS: TestGetInstance (0.00s)\nPASS\nok\n\n```", "```go\npackage creational \n\ntype BuildProcess interface { \n    SetWheels() BuildProcess \n    SetSeats() BuildProcess \n    SetStructure() BuildProcess \n    GetVehicle() VehicleProduct \n} \n\n```", "```go\ntype ManufacturingDirector struct {} \n\nfunc (f *ManufacturingDirector) Construct() { \n    //Implementation goes here \n} \n\nfunc (f *ManufacturingDirector) SetBuilder(b BuildProcess) { \n    //Implementation goes here \n} \n\n```", "```go\ntype VehicleProduct struct { \n    Wheels    int \n    Seats     int \n    Structure string \n} \n\n```", "```go\ntype CarBuilder struct {} \n\nfunc (c *CarBuilder) SetWheels() BuildProcess { \n    return nil \n} \n\nfunc (c *CarBuilder) SetSeats() BuildProcess { \n    return nil \n} \n\nfunc (c *CarBuilder) SetStructure() BuildProcess { \n    return nil \n} \n\nfunc (c *CarBuilder) Build() VehicleProduct { \n    return VehicleProduct{} \n} \n\n```", "```go\ntype BikeBuilder struct {} \n\nfunc (b *BikeBuilder) SetWheels() BuildProcess { \n    return nil \n} \n\nfunc (b *BikeBuilder) SetSeats() BuildProcess { \n    return nil \n} \n\nfunc (b *BikeBuilder) SetStructure() BuildProcess { \n    return nil \n} \n\nfunc (b *BikeBuilder) Build() VehicleProduct { \n    return VehicleProduct{} \n} \n\n```", "```go\npackage creational \n\nimport \"testing\" \n\nfunc TestBuilderPattern(t *testing.T) { \n    manufacturingComplex := ManufacturingDirector{} \n\n    carBuilder := &CarBuilder{} \n    manufacturingComplex.SetBuilder(carBuilder) \n    manufacturingComplex.Construct() \n\n    car := carBuilder.Build() \n\n    //code continues here... \n\n```", "```go\nif car.Wheels != 4 { \n    t.Errorf(\"Wheels on a car must be 4 and they were %d\\n\", car.Wheels) \n} \n\nif car.Structure != \"Car\" { \n    t.Errorf(\"Structure on a car must be 'Car' and was %s\\n\", car.Structure) \n} \n\nif car.Seats != 5 { \n    t.Errorf(\"Seats on a car must be 5 and they were %d\\n\", car.Seats) \n} \n\n```", "```go\n$ go test -v -run=TestBuilder .\n=== RUN   TestBuilderPattern\n--- FAIL: TestBuilderPattern (0.00s)\n builder_test.go:15: Wheels on a car must be 4 and they were 0\n builder_test.go:19: Structure on a car must be 'Car' and was\n builder_test.go:23: Seats on a car must be 5 and they were 0\nFAIL\n\n```", "```go\nbikeBuilder := &BikeBuilder{} \n\nmanufacturingComplex.SetBuilder(bikeBuilder) \nmanufacturingComplex.Construct() \n\nmotorbike := bikeBuilder.GetVehicle() \nmotorbike.Seats = 1 \n\nif motorbike.Wheels != 2 { \n    t.Errorf(\"Wheels on a motorbike must be 2 and they were %d\\n\", motorbike.Wheels) \n} \n\nif motorbike.Structure != \"Motorbike\" { \n    t.Errorf(\"Structure on a motorbike must be 'Motorbike' and was %s\\n\", motorbike.Structure) \n} \n\n```", "```go\n$ go test -v -run=Builder .\n=== RUN   TestBuilderPattern\n--- FAIL: TestBuilderPattern (0.00s)\n builder_test.go:15: Wheels on a car must be 4 and they were 0\n builder_test.go:19: Structure on a car must be 'Car' and was\n builder_test.go:23: Seats on a car must be 5 and they were 0\n builder_test.go:35: Wheels on a motorbike must be 2 and they were 0\n builder_test.go:39: Structure on a motorbike must be 'Motorbike' and was\nFAIL\n\n```", "```go\npackage creational \n\ntype ManufacturingDirector struct { \n    builder BuildProcess \n} \n\nfunc (f *ManufacturingDirector) SetBuilder(b BuildProcess) { \n    f.builder = b \n} \n\nfunc (f *ManufacturingDirector) Construct() { \n    f.builder.SetSeats().SetStructure().SetWheels() \n} \n\n```", "```go\ntype CarBuilder struct { \n    v VehicleProduct \n} \n\nfunc (c *CarBuilder) SetWheels() BuildProcess { \n    c.v.Wheels = 4 \n    return c \n} \n\nfunc (c *CarBuilder) SetSeats() BuildProcess { \n    c.v.Seats = 5 \n    return c \n} \n\nfunc (c *CarBuilder) SetStructure() BuildProcess { \n    c.v.Structure = \"Car\" \n    return c \n} \n\nfunc (c *CarBuilder) GetVehicle() VehicleProduct { \n    return c.v \n} \n\n```", "```go\ntype BikeBuilder struct { \n    v VehicleProduct \n} \n\nfunc (b *BikeBuilder) SetWheels() BuildProcess { \n    b.v.Wheels = 2 \n    return b \n} \n\nfunc (b *BikeBuilder) SetSeats() BuildProcess { \n    b.v.Seats = 2 \n    return b \n} \n\nfunc (b *BikeBuilder) SetStructure() BuildProcess { \n    b.v.Structure = \"Motorbike\" \n    return b \n} \n\nfunc (b *BikeBuilder) GetVehicle() VehicleProduct { \n    return b.v \n} \n\n```", "```go\n=== RUN   TestBuilderPattern\n--- PASS: TestBuilderPattern (0.00s)\nPASS\nok  _/home/mcastro/pers/go-design-patterns/creational 0.001s\n\n```", "```go\ntype BusBuilder struct { \n    v VehicleProduct \n} \n\nfunc (b *BusBuilder) SetWheels() BuildProcess { \n    b.v.Wheels = 4*2 \n    return b \n} \n\nfunc (b *BusBuilder) SetSeats() BuildProcess { \n    b.v.Seats = 30 \n    return b \n} \n\nfunc (b *BusBuilder) SetStructure() BuildProcess { \n    b.v.Structure = \"Bus\" \n    return b \n} \n\nfunc (b *BusBuilder) GetVehicle() VehicleProduct { \n    return b.v \n} \n\n```", "```go\ntype PaymentMethod interface { \n    Pay(amount float32) string \n} \n\n```", "```go\nconst ( \n    Cash      = 1 \n    DebitCard = 2 \n) \n\n```", "```go\nfunc GetPaymentMethod(m int) (PaymentMethod, error) { \n    return nil, errors.New(\"Not implemented yet\") \n} \n\n```", "```go\ntype CashPM struct{} \ntype DebitCardPM struct{} \n\nfunc (c *CashPM) Pay(amount float32) string { \n    return \"\" \n} \n\nfunc (c *DebitCardPM) Pay(amount float32) string { \n    return \"\" \n} \n\n```", "```go\npackage creational \n\nimport ( \n    \"strings\" \n    \"testing\" \n) \n\nfunc TestCreatePaymentMethodCash(t *testing.T) { \n    payment, err := GetPaymentMethod(Cash) \n    if err != nil { \n        t.Fatal(\"A payment method of type 'Cash' must exist\") \n    } \n\n    msg := payment.Pay(10.30) \n    if !strings.Contains(msg, \"paid using cash\") { \n        t.Error(\"The cash payment method message wasn't correct\") \n    } \n    t.Log(\"LOG:\", msg) \n} \n\n```", "```go\nfunc TestGetPaymentMethodDebitCard(t *testing.T) { \n    payment, err = GetPaymentMethod(Debit9Card) \n\n    if err != nil { \n        t.Error(\"A payment method of type 'DebitCard' must exist\")\n    } \n\n    msg = payment.Pay(22.30) \n\n    if !strings.Contains(msg, \"paid using debit card\") { \n        t.Error(\"The debit card payment method message wasn't correct\") \n    } \n\n    t.Log(\"LOG:\", msg) \n}\n```", "```go\n\nfunc TestGetPaymentMethodNonExistent(t *testing.T) { \n    payment, err = GetPaymentMethod(20) \n\n    if err == nil { \n        t.Error(\"A payment method with ID 20 must return an error\") \n    } \n    t.Log(\"LOG:\", err) \n}\n```", "```go\n$ go test -v -run=GetPaymentMethod .\n=== RUN   TestGetPaymentMethodCash\n--- FAIL: TestGetPaymentMethodCash (0.00s)\n factory_test.go:11: A payment method of type 'Cash' must exist\n=== RUN   TestGetPaymentMethodDebitCard\n--- FAIL: TestGetPaymentMethodDebitCard (0.00s)\n factory_test.go:24: A payment method of type 'DebitCard' must exist\n=== RUN   TestGetPaymentMethodNonExistent\n--- PASS: TestGetPaymentMethodNonExistent (0.00s)\n factory_test.go:38: LOG: Not implemented yet\nFAIL\nexit status 1\nFAIL\n\n```", "```go\npackage creational \n\nimport ( \n    \"errors\" \n    \"fmt\" \n) \n\ntype PaymentMethod interface { \n    Pay(amount float32) string \n} \n\nconst ( \n    Cash      = 1 \n    DebitCard = 2 \n) \n\ntype CashPM struct{} \ntype DebitCardPM struct{} \n\nfunc GetPaymentMethod(m int) (PaymentMethod, error) { \n    switch m { \n        case Cash: \n        return new(CashPM), nil \n        case DebitCard: \n        return new(DebitCardPM), nil \n        default: \n        return nil, errors.New(fmt.Sprintf(\"Payment method %d not recognized\\n\", m)) \n    } \n} \n\n```", "```go\n$go test -v -run=GetPaymentMethod .\n=== RUN   TestGetPaymentMethodCash\n--- FAIL: TestGetPaymentMethodCash (0.00s)\n factory_test.go:16: The cash payment method message wasn't correct\n factory_test.go:18: LOG:\n=== RUN   TestGetPaymentMethodDebitCard\n--- FAIL: TestGetPaymentMethodDebitCard (0.00s)\n factory_test.go:28: The debit card payment method message wasn't correct\n factory_test.go:30: LOG:\n=== RUN   TestGetPaymentMethodNonExistent\n--- PASS: TestGetPaymentMethodNonExistent (0.00s)\n factory_test.go:38: LOG: Payment method 20 not recognized\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype CashPM struct{} \ntype DebitCardPM struct{} \n\nfunc (c *CashPM) Pay(amount float32) string { \n     return fmt.Sprintf(\"%0.2f paid using cash\\n\", amount) \n} \n\nfunc (c *DebitCardPM) Pay(amount float32) string { \n     return fmt.Sprintf(\"%#0.2f paid using debit card\\n\", amount) \n} \n\n```", "```go\n$ go test -v -run=GetPaymentMethod .\n=== RUN   TestGetPaymentMethodCash\n--- PASS: TestGetPaymentMethodCash (0.00s)\n factory_test.go:18: LOG: 10.30 paid using cash\n=== RUN   TestGetPaymentMethodDebitCard\n--- PASS: TestGetPaymentMethodDebitCard (0.00s)\n factory_test.go:30: LOG: 22.30 paid using debit card\n=== RUN   TestGetPaymentMethodNonExistent\n--- PASS: TestGetPaymentMethodNonExistent (0.00s)\n factory_test.go:38: LOG: Payment method 20 not recognized\nPASS\nok\n\n```", "```go\n$ go test -run=GetPaymentMethod .\nok\n\n```", "```go\ntype CreditCardPM struct {} \n func (d *CreditCardPM) Pay(amount float32) string { \n   return fmt.Sprintf(\"%#0.2f paid using new credit card implementation\\n\", amount) \n} \n\n```", "```go\nfunc GetPaymentMethod(m int) (PaymentMethod, error) { \n    switch m { \n        case Cash: \n        return new(CashPM), nil \n        case DebitCard: \n        return new(CreditCardPM), nil \n        default: \n        return nil, errors.New(fmt.Sprintf(\"Payment method %d not recognized\\n\", m)) \n   } \n} \n\n```", "```go\n$ go test -v -run=GetPaymentMethod .\n=== RUN   TestGetPaymentMethodCash\n--- PASS: TestGetPaymentMethodCash (0.00s)\n factory_test.go:18: LOG: 10.30 paid using cash\n=== RUN   TestGetPaymentMethodDebitCard\n--- FAIL: TestGetPaymentMethodDebitCard (0.00s)\n factory_test.go:28: The debit card payment method message wasn't correct\n factory_test.go:30: LOG: 22.30 paid using new debit card implementation\n=== RUN   TestGetPaymentMethodNonExistent\n--- PASS: TestGetPaymentMethodNonExistent (0.00s)\n factory_test.go:38: LOG: Payment method 20 not recognized\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nreturn fmt.Sprintf(\"%#0.2f paid using debit card (new)\\n\", amount) \n\n```", "```go\n$ go test -v -run=GetPaymentMethod .\n=== RUN   TestGetPaymentMethodCash\n--- PASS: TestGetPaymentMethodCash (0.00s)\n factory_test.go:18: LOG: 10.30 paid using cash\n=== RUN   TestGetPaymentMethodDebitCard\n--- PASS: TestGetPaymentMethodDebitCard (0.00s)\n factory_test.go:30: LOG: 22.30 paid using debit card (new)\n=== RUN   TestGetPaymentMethodNonExistent\n--- PASS: TestGetPaymentMethodNonExistent (0.00s)\n factory_test.go:38: LOG: Payment method 20 not recognized\nPASS\nok\n\n```", "```go\npackage abstract_factory \n\ntype Vehicle interface { \n    NumWheels() int \n    NumSeats() int \n} \n\n```", "```go\n// Package abstract_factory file: car.go \npackage abstract_factory \n\ntype Car interface { \n    NumDoors() int \n} \n// Package abstract_factory file: motorbike.go \npackage abstract_factory \n\ntype Motorbike interface { \n    GetMotorbikeType() int \n} \n\n```", "```go\npackage abstract_factory \n\ntype VehicleFactory interface { \n    NewVehicle(v int) (Vehicle, error) \n} \n\n```", "```go\nconst ( \n    LuxuryCarType = 1 \n    FamilyCarType = 2 \n) \n\ntype CarFactory struct{} \nfunc (c *CarFactory) NewVehicle(v int) (Vehicle, error) { \n    switch v { \n        case LuxuryCarType: \n        return new(LuxuryCar), nil \n        case FamilyCarType: \n        return new(FamilyCar), nil \n        default: \n        return nil, errors.New(fmt.Sprintf(\"Vehicle of type %d not recognized\\n\", v)) \n    } \n} \n\n```", "```go\n//luxury_car.go \npackage abstract_factory \n\ntype LuxuryCar struct{} \n\nfunc (*LuxuryCar) NumDoors() int { \n    return 4 \n} \nfunc (*LuxuryCar) NumWheels() int { \n    return 4 \n} \nfunc (*LuxuryCar) NumSeats() int { \n    return 5 \n} \n\npackage abstract_factory \n\ntype FamilyCar struct{} \n\nfunc (*FamilyCar) NumDoors() int { \n    return 5 \n} \nfunc (*FamilyCar) NumWheels() int { \n    return 4 \n} \nfunc (*FamilyCar) NumSeats() int { \n    return 5 \n} \n\n```", "```go\nconst ( \n    SportMotorbikeType = 1 \n    CruiseMotorbikeType = 2 \n) \n\ntype MotorbikeFactory struct{} \n\nfunc (m *MotorbikeFactory) Build(v int) (Vehicle, error) { \n    switch v { \n        case SportMotorbikeType: \n        return new(SportMotorbike), nil \n        case CruiseMotorbikeType: \n        return new(CruiseMotorbike), nil \n        default: \n        return nil, errors.New(fmt.Sprintf(\"Vehicle of type %d not recognized\\n\", v)) \n    } \n} \n\n```", "```go\n//sport_motorbike.go \npackage abstract_factory \n\ntype SportMotorbike struct{} \n\nfunc (s *SportMotorbike) NumWheels() int { \n    return 2 \n} \nfunc (s *SportMotorbike) NumSeats() int { \n    return 1 \n} \nfunc (s *SportMotorbike) GetMotorbikeType() int { \n    return SportMotorbikeType \n} \n\n//cruise_motorbike.go \npackage abstract_factory \n\ntype CruiseMotorbike struct{} \n\nfunc (c *CruiseMotorbike) NumWheels() int { \n    return 2 \n} \nfunc (c *CruiseMotorbike) NumSeats() int { \n    return 2 \n} \nfunc (c *CruiseMotorbike) GetMotorbikeType() int { \n    return CruiseMotorbikeType \n} \n\n```", "```go\npackage abstract_factory \n\nimport ( \n    \"fmt\" \n    \"errors\" \n) \n\ntype VehicleFactory interface { \n    Build(v int) (Vehicle, error) \n} \n\nconst ( \n    CarFactoryType = 1 \n    MotorbikeFactoryType = 2 \n) \n\nfunc BuildFactory(f int) (VehicleFactory, error) { \n    switch f { \n        default: \n        return nil, errors.New(fmt.Sprintf(\"Factory with id %d not recognized\\n\", f)) \n    } \n}\n```", "```go\npackage abstract_factory \n\nimport \"testing\" \n\nfunc TestMotorbikeFactory(t *testing.T) { \n    motorbikeF, err := BuildFactory(MotorbikeFactoryType) \n    if err != nil { \n        t.Fatal(err) \n    } \n\n    motorbikeVehicle, err := motorbikeF.Build(SportMotorbikeType) \n    if err != nil { \n        t.Fatal(err) \n    } \n\n    t.Logf(\"Motorbike vehicle has %d wheels\\n\", motorbikeVehicle.NumWheels()) \n\n    sportBike, ok := motorbikeVehicle.(Motorbike) \n    if !ok { \n        t.Fatal(\"Struct assertion has failed\") \n    } \n    t.Logf(\"Sport motorbike has type %d\\n\", sportBike.GetMotorbikeType()) \n} \n\n```", "```go\nfunc TestCarFactory(t *testing.T) { \n    carF, err := BuildFactory(CarFactoryType) \n    if err != nil { \n        t.Fatal(err) \n    } \n\n    carVehicle, err := carF.Build(LuxuryCarType) \n    if err != nil { \n        t.Fatal(err) \n    } \n\n    t.Logf(\"Car vehicle has %d seats\\n\", carVehicle.NumWheels()) \n\n    luxuryCar, ok := carVehicle.(Car) \n    if !ok { \n        t.Fatal(\"Struct assertion has failed\") \n    } \n    t.Logf(\"Luxury car has %d doors.\\n\", luxuryCar.NumDoors()) \n} \n\n```", "```go\ngo test -v -run=Factory .\n=== RUN   TestMotorbikeFactory\n--- FAIL: TestMotorbikeFactory (0.00s)\n vehicle_factory_test.go:8: Factory with id 2 not recognized\n=== RUN   TestCarFactory\n--- FAIL: TestCarFactory (0.00s)\n vehicle_factory_test.go:28: Factory with id 1 not recognized\nFAIL\nexit status 1\nFAIL \n\n```", "```go\nfunc BuildFactory(f int) (VehicleFactory, error) { \n    switch f { \n        case CarFactoryType: \n        return new(CarFactory), nil \n        case MotorbikeFactoryType: \n        return new(MotorbikeFactory), nil \n        default: \n        return nil, errors.New(fmt.Sprintf(\"Factory with id %d not recognized\\n\", f)) \n    } \n} \n\n```", "```go\ngo test -v -run=Factory -cover .\n=== RUN   TestMotorbikeFactory\n--- PASS: TestMotorbikeFactory (0.00s)\n vehicle_factory_test.go:16: Motorbike vehicle has 2 wheels\n vehicle_factory_test.go:22: Sport motorbike has type 1\n=== RUN   TestCarFactory\n--- PASS: TestCarFactory (0.00s)\n vehicle_factory_test.go:36: Car vehicle has 4 seats\n vehicle_factory_test.go:42: Luxury car has 4 doors.\nPASS\ncoverage: 45.8% of statements\nok\n\n```", "```go\ntype ShirtCloner interface { \n    GetClone(s int) (ItemInfoGetter, error) \n} \n\nconst ( \n    White = 1 \n    Black = 2 \n    Blue  = 3 \n) \n\nfunc GetShirtsCloner() ShirtCloner { \n    return nil \n} \n\ntype ShirtsCache struct {} \nfunc (s *ShirtsCache)GetClone(s int) (ItemInfoGetter, error) { \n    return nil, errors.New(\"Not implemented yet\") \n} \n\n```", "```go\ntype ItemInfoGetter interface { \n    GetInfo() string \n} \n\ntype ShirtColor byte \n\ntype Shirt struct { \n    Price float32 \n    SKU   string \n    Color ShirtColor \n} \nfunc (s *Shirt) GetInfo()string { \n    return \"\" \n} \n\nfunc GetShirtsCloner() ShirtCloner { \n    return nil \n} \n\nvar whitePrototype *Shirt = &Shirt{ \n    Price: 15.00, \n    SKU:   \"empty\", \n    Color: White, \n} \n\nfunc (i *Shirt) GetPrice() float32 { \n    return i.Price \n} \n\n```", "```go\nfunc TestClone(t *testing.T) { \n    shirtCache := GetShirtsCloner() \n    if shirtCache == nil { \n        t.Fatal(\"Received cache was nil\") \n    } \n\n    item1, err := shirtCache.GetClone(White) \n    if err != nil { \n        t.Error(err) \n} \n\n//more code continues here... \n\n```", "```go\nif item1 == whitePrototype { \n    t.Error(\"item1 cannot be equal to the white prototype\"); \n} \n\n```", "```go\nshirt1, ok := item1.(*Shirt) \nif !ok { \n    t.Fatal(\"Type assertion for shirt1 couldn't be done successfully\") \n} \nshirt1.SKU = \"abbcc\" \n\nitem2, err := shirtCache.GetClone(White) \nif err != nil { \n    t.Fatal(err) \n} \n\nshirt2, ok := item2.(*Shirt) \nif !ok { \n    t.Fatal(\"Type assertion for shirt1 couldn't be done successfully\") \n} \n\nif shirt1.SKU == shirt2.SKU { \n    t.Error(\"SKU's of shirt1 and shirt2 must be different\") \n} \n\nif shirt1 == shirt2 { \n    t.Error(\"Shirt 1 cannot be equal to Shirt 2\") \n} \n\n```", "```go\nt.Logf(\"LOG: %s\", shirt1.GetInfo()) \nt.Logf(\"LOG: %s\", shirt2.GetInfo()) \n\n```", "```go\nt.Logf(\"LOG: The memory positions of the shirts are different %p != %p \\n\\n\", &shirt1, &shirt2) \n\n```", "```go\ngo test -run=TestClone . \n--- FAIL: TestClone (0.00s) \nprototype_test.go:10: Not implemented yet \nFAIL \nFAIL\n\n```", "```go\nvar whitePrototype *Shirt = &Shirt{ \n    Price: 15.00, \n    SKU:   \"empty\", \n    Color: White, \n} \n\nvar blackPrototype *Shirt = &Shirt{ \n    Price: 16.00, \n    SKU:   \"empty\", \n    Color: Black, \n} \n\nvar bluePrototype *Shirt = &Shirt{ \n    Price: 17.00, \n    SKU:   \"empty\", \n    Color: Blue, \n} \n\n```", "```go\ntype ShirtsCache struct {} \nfunc (s *ShirtsCache)GetClone(s int) (ItemInfoGetter, error) { \n    switch m { \n        case White: \n            newItem := *whitePrototype \n            return &newItem, nil \n        case Black: \n            newItem := *blackPrototype \n            return &newItem, nil \n        case Blue: \n            newItem := *bluePrototype \n            return &newItem, nil \n        default: \n            return nil, errors.New(\"Shirt model not recognized\") \n    } \n} \n\n```", "```go\ntype ShirtColor byte \n\ntype Shirt struct { \n    Price float32 \n    SKU   string \n    Color ShirtColor \n} \n\nfunc (s *Shirt) GetInfo() string { \n    return fmt.Sprintf(\"Shirt with SKU '%s' and Color id %d that costs %f\\n\", s.SKU, s.Color, s.Price) \n} \n\n```", "```go\ngo test -run=TestClone -v . \n=== RUN   TestClone \n--- PASS: TestClone (0.00s) \nprototype_test.go:41: LOG: Shirt with SKU 'abbcc' and Color id 1 that costs 15.000000 \nprototype_test.go:42: LOG: Shirt with SKU 'empty' and Color id 1 that costs 15.000000 \nprototype_test.go:44: LOG: The memory positions of the shirts are different 0xc42002c038 != 0xc42002c040  \n\nPASS \nok\n\n```"]