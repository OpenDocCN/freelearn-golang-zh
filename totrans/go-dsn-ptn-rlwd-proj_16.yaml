- en: Chapter 2. Creational Patterns - Singleton, Builder, Factory, Prototype, and
    Abstract Factory Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have defined two types of cars-luxury and family. The car Factory will have
    to return The first groups of design patterns that we are going to cover are the
    Creational patterns. As the name implies, it groups common practices for creating
    objects, so object creation is more encapsulated from the users that need those
    objects. Mainly, creational patterns try to give ready-to-use objects to users
    instead of asking for their creation, which, in some cases, could be complex,
    or which would couple your code with the concrete implementations of the functionality
    that should be defined in an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton design pattern - having a unique instance of a type in the entire
    program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever done interviews for software engineers? It's interesting that
    when you ask them about design patterns, more than 80% will mention **Singleton**
    design pattern. Why is that? Maybe it's because it is one of the most used design
    patterns out there or one of the easiest to grasp. We will start our journey on
    creational design patterns because of the latter reason.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Singleton pattern is easy to remember. As the name implies, it will provide
    you with a single instance of an object, and guarantee that there are no duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: At the first call to use the instance, it is created and then reused between
    all the parts in the application that need to use that particular behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll use the Singleton pattern in many different situations. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to use the same connection to a database to make every query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you open a **Secure Shell** (**SSH**) connection to a server to do a few
    tasks, and don't want to reopen the connection for each task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to limit the access to some variable or space, you use a Singleton
    as the door to this variable (we'll see in the following chapters that this is
    more achievable in Go using channels anyway)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to limit the number of calls to some places, you create a Singleton
    instance to make the calls in the accepted window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibilities are endless, and we have just mentioned some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a general guide, we consider using the Singleton pattern when the following
    rule applies:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a single, shared value, of some particular type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to restrict object creation of some type to a single unit along the
    entire program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example - a unique counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example of an object of which we must ensure that there is only one instance,
    we will write a counter that holds the number of times it has been called during
    program execution. It shouldn't matter how many instances we have of the counter,
    all of them must *count* the same value and it must be consistent between the
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some requirements and acceptance criteria to write the described
    single counter. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When no counter has been created before, a new one is created with the value
    0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a counter has already been created, return this instance that holds the actual
    count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we call the method `AddOne`, the count must be incremented by 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a scenario with three tests to check in our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go's implementation of this pattern is slightly different from what you'll find
    in pure object-oriented languages such as Java or C++, where you have static members.
    In Go, there's nothing like static members, but we have package scope to deliver
    a similar result.
  prefs: []
  type: TYPE_NORMAL
- en: To set up our project, we must create a new folder within our `$GOPATH/src`
    directory. The general rule as we mentioned in the [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!*, is to create a
    subfolder with the VCS provider (such as GitHub), the username, and the name of
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in my case, I use GitHub as my VCS and my username is *sayden,*
    so I will create the path `$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton`.
    The `go-design-patterns` instance in the path is the project name, the creational
    subfolder will also be our library name, and singleton the name of this particular
    package and subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file inside the singleton folder called `singleton.go` to also
    reflect the name of the package and write the following package declarations for
    the `singleton` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are following a TDD approach while writing the code, let''s code the
    tests that use the functions we have just declared. The tests are going to be
    defined by following the acceptance criteria that we have written earlier. By
    convention in test files, we must create a file with the same name as the file
    to test, suffixed with `_test.go`. Both must reside in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first test checks something obvious, but no less important, in complex
    applications. We actually receive something when we ask for an instance of the
    counter. We have to think of it as a Creational pattern--we delegate the creation
    of the object to an unknown package that could fail in the creation or retrieval
    of the object. We also store the current counter in the `expectedCounter` variable
    to make a comparison later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we take advantage of the zero-initialization feature of Go. Remember that
    integer types in Go cannot be nil and as we know, that this is the first call
    to the counter, and it is an integer type of variable, and we also know that it
    is zero-initialized. So after the first call to the `AddOne()` function, the value
    of the count must be 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test that checks the second condition proves that the `expectedConnection`
    variable is not different to the returned connection that we requested later.
    If they were different, the message `Singleton instances must be different` will
    cause the test to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last test is simply counting 1 again with the second instance. The previous
    result was 1, so now it must give us 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we have to do to finish our test part is to execute the tests
    to make sure that they are failing before implementation. If one of them doesn''t
    fail, it implies that we have done something wrong, and we have to reconsider
    that particular test. We must open the terminal and navigate to the path of the
    singleton package to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we have to implement the Singleton pattern. As we mentioned earlier,
    we''ll usually write a `static` method and instance to retrieve the Singleton
    instance in languages such as Java or C++. In Go, we don''t have the keyword `static`,
    but we can achieve the same result by using the scope of the package. First, we
    create a `struct` that contains the object which we want to guarantee to be a
    Singleton during the execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We must pay close attention to this piece of code. In languages such as Java
    or C++, the variable instance would be initialized to NULL at the beginning of
    the program. In Go, you can initialize a pointer to a struct as `nil`, but you
    cannot initialize a structure to `nil` (the equivalent of NULL). So the `var instance
    *singleton` line defines a pointer to a struct of type Singleton as nil, and the
    variable called `instance`.
  prefs: []
  type: TYPE_NORMAL
- en: We created a `GetInstance` method that checks if the instance has not been initialized
    already (`instance == nil`), and creates an instance in the space already allocated
    in the line `instance = new(singleton)`. Remember, when we use the keyword `new`,
    we are creating a pointer to an instance of the type between the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddOne` method will take the count of the variable instance, raise it by
    1, and return the current value of the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run now our unit tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A few words about the Singleton design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen a very simple example of the Singleton pattern, partially applied
    to some situation, that is, a simple counter. Just keep in mind that the Singleton
    pattern will give you the power to have a unique instance of some struct in your
    application and that no package can create any clone of this struct.
  prefs: []
  type: TYPE_NORMAL
- en: With Singleton, you are also hiding the complexity of creating the object, in
    case it requires some computation, and the pitfall of creating it every time you
    need an instance of it if all of them are similar. All this code writing, checking
    if the variable already exists, and storage, are encapsulated in the singleton
    and you won't need to repeat it everywhere if you use a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are learning the classic singleton implementation for single threaded
    context. We will see a concurrent singleton implementation when we reach the chapters
    about concurrency because this implementation is not thread safe!
  prefs: []
  type: TYPE_NORMAL
- en: Builder design pattern - reusing an algorithm to create many implementations
    of an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Talking about **Creational** design patterns, it looks pretty semantic to have
    a **Builder** design pattern. The Builder pattern helps us construct complex objects
    without directly instantiating their struct, or writing the logic they require.
    Imagine an object that could have dozens of fields that are more complex structs
    themselves. Now imagine that you have many objects with these characteristics,
    and you could have more. We don't want to write the logic to create all these
    objects in the package that just needs to use the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instance creation can be as simple as providing the opening and closing braces
    `{}` and leaving the instance with zero values, or as complex as an object that
    needs to make some API calls, check states, and create objects for its fields.
    You could also have an object that is composed of many objects, something that's
    really idiomatic in Go, as it doesn't support inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, you could be using the same technique to create many types
    of objects. For example, you'll use almost the same technique to build a car as
    you would build a bus, except that they'll be of different sizes and number of
    seats, so why don't we reuse the construction process? This is where the Builder
    pattern comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Builder design pattern tries to:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract complex creations so that object creation is separated from the object
    user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an object step by step by filling its fields and creating the embedded
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse the object creation algorithm between many objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example - vehicle manufacturing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Builder design pattern has been commonly described as the relationship between
    a director, a few Builders, and the product they build. Continuing with our example
    of the car, we'll create a vehicle Builder. The process (widely described as the
    algorithm) of creating a vehicle (the product) is more or less the same for every
    kind of vehicle--choose vehicle type, assemble the structure, place the wheels,
    and place the seats. If you think about it, you could build a car and a motorbike
    (two Builders) with this description, so we are reusing the description to create
    cars in manufacturing. The director is represented by the `ManufacturingDirector`
    type in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As far as we have described, we must dispose of a Builder of type `Car` and
    `Motorbike` and a unique director called `ManufacturingDirector` to take builders
    and construct products. So the requirements for a `Vehicle` builder example would
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: I must have a manufacturing type that constructs everything that a vehicle needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a car builder, the `VehicleProduct` with four wheels, five seats,
    and a structure defined as `Car` must be returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a motorbike builder, the `VehicleProduct` with two wheels, two seats,
    and a structure defined as `Motorbike` must be returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `VehicleProduct` built by any `BuildProcess` builder must be open to modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test for the vehicle builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the previous acceptance criteria, we will create a director variable,
    the `ManufacturingDirector` type, to use the build processes represented by the
    product builder variables for a car and motorbike. The director is the one in
    charge of construction of the objects, but the builders are the ones that return
    the actual vehicle. So our builder declaration will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding interface defines the steps that are necessary to build a vehicle.
    Every builder must implement this `interface` if they are to be used by the manufacturing.
    On every `Set` step, we return the same build process, so we can chain various
    steps together in the same statement, as we''ll see later. Finally, we''ll need
    a `GetVehicle` method to retrieve the `Vehicle` instance from the builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ManufacturingDirector` director variable is the one in charge of accepting
    the builders. It has a `Construct` method that will use the builder that is stored
    in `Manufacturing`, and will reproduce the required steps. The `SetBuilder` method
    will allow us to change the builder that is being used in the `Manufacturing`
    director:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The product is the final object that we want to retrieve while using the manufacturing.
    In this case, a vehicle is composed of wheels, seats, and a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first Builder is the `Car` builder. It must implement every method defined
    in the `BuildProcess` interface. This is where we''ll set the information for
    this particular builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Motorbike` structure must be the same as the `Car` structure, as they
    are all Builder implementations, but keep in mind that the process of building
    each can be very different. With this declaration of objects, we can create the
    following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start with the `Manufacturing` director and the `Car` Builder to fulfill
    the first two acceptance criteria. In the preceding code, we are creating our
    `Manufacturing` director that will be in charge of the creation of every vehicle
    during the test. After creating the `Manufacturing` director, we created a `CarBuilder`
    that we then passed to manufacturing by using the `SetBuilder` method. Once the
    `Manufacturing` director knows what it has to construct now, we can call the `Construct`
    method to create the `VehicleProduct` using `CarBuilder`. Finally, once we have
    all the pieces for our car, we call the `GetVehicle` method on `CarBuilder` to
    retrieve a `Car` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have written three small tests to check if the outcome is a car. We checked
    that the car has four wheels, the structure has the description `Car`, and the
    number of seats is five. We have enough data to execute the tests and make sure
    that they are failing so that we can consider them reliable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Now we will create tests for a `Motorbike` builder that covers the
    third and fourth acceptance criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a continuation of the car tests. As you can see, we reuse
    the previously created manufacturing to create the bike now by passing the `Motorbike` builder
    to it. Then we hit the `construct` button again to create the necessary parts,
    and call the builder `GetVehicle` method to retrieve the motorbike instance.
  prefs: []
  type: TYPE_NORMAL
- en: Take a quick look, because we have changed the default number of seats for this
    particular motorbike to 1\. What we want to show here is that even while having
    a builder, you must also be able to change the default information in the returned
    instance to fit some specific needs. As we set the wheels manually, we won't test
    this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Re-running the tests triggers the expected behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start implementing the manufacturing. As we said earlier (and as we
    set in our unit tests), the `Manufacturing` director must accept a builder and
    construct a vehicle using the provided builder. To recall, the `BuildProcess`
    interface will define the common steps needed to construct any vehicle and the
    `Manufacturing` director must accept builders and construct vehicles together
    with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ManufacturingDirector` needs a field to store the builder in use; this
    field will be called `builder`. The `SetBuilder` method will replace the stored
    builder with the one provided in the arguments. Finally, take a closer look at
    the `Construct` method. It takes the builder that has been stored and reproduces
    the `BuildProcess` method that will create a full vehicle of some unknown type.
    As you can see, we have used all the setting calls in the same line thanks to
    returning the `BuildProcess` interface on each of the calls. This way the code
    is more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you realized that the director entity in the Builder pattern is a clear
    candidate for a Singleton pattern too? In some scenarios, it could be critical
    that just an instance of the Director is available, and that is where you'll create
    a Singleton pattern for the Director of the Builder only. Design patterns composition
    is a very common technique and a very powerful one!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here is our first builder, the `car` builder. A builder will need to store a
    `VehicleProduct` object, which here we have named `v`. Then we set the specific
    needs that a car has in our business--four wheels, five seats, and a structure
    defined as `Car`. In the `GetVehicle` method, we just return the `VehicleProduct`
    stored within the Builder that must be already constructed by the `ManufacturingDirector` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Motorbike` Builder is the same as the `car` builder. We defined a motorbike
    to have two wheels, two seats, and a structure called `Motorbike`. It's very similar
    to the `car` object, but imagine that you want to differentiate between a sports
    motorbike (with only one seat) and a cruise motorbike (with two seats). You could
    simply create a new structure for sports motorbikes that implements the build
    process.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it's a repetitive pattern, but within the scope of every method
    of the `BuildProcess` interface, you could encapsulate as much complexity as you
    want such that the user need not know the details about the object creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the definition of all the objects, let''s run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done! Think how easy it could be to add new vehicles to the `ManufacturingDirector`
    director just create a new class encapsulating the data for the new vehicle. For
    example, let´s add a `BusBuilder` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That's all; your `ManufacturingDirector` would be ready to use the new product
    by following the Builder design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up the Builder design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Builder design pattern helps us maintain an unpredictable number of products
    by using a common construction algorithm that is used by the director. The construction
    process is always abstracted from the user of the product.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, having a defined construction pattern helps when a newcomer
    to our source code needs to add a new product to the *pipeline*. The `BuildProcess`
    interface specifies what he must comply to be part of the possible builders.
  prefs: []
  type: TYPE_NORMAL
- en: However, try to avoid the Builder pattern when you are not completely sure that
    the algorithm is going to be more or less stable because any small change in this
    interface will affect all your builders and it could be awkward if you add a new
    method that some of your builders need and others Builders do not.
  prefs: []
  type: TYPE_NORMAL
- en: Factory method - delegating the creation of different types of payments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory method pattern (or simply, Factory) is probably the second-best
    known and used design pattern in the industry. Its purpose is to abstract the
    user from the knowledge of the struct he needs to achieve for a specific purpose,
    such as retrieving some value, maybe from a web service or a database. The user
    only needs an interface that provides him this value. By delegating this decision
    to a Factory, this Factory can provide an interface that fits the user needs.
    It also eases the process of downgrading or upgrading of the implementation of
    the underlying type if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the Factory method design pattern, we gain an extra layer of encapsulation
    so that our program can grow in a controlled environment. With the Factory method,
    we delegate the creation of families of objects to a different package or object
    to abstract us from the knowledge of the pool of possible objects we could use.
    Imagine that you want to organize your holidays using a trip agency. You don't
    deal with hotels and traveling and you just tell the agency the destination you
    are interested in so that they provide you with everything you need. The trip
    agency represents a Factory of trips.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the previous description, the following objectives of the Factory Method
    design pattern must be clear to you:'
  prefs: []
  type: TYPE_NORMAL
- en: Delegating the creation of new instances of structures to a different part of
    the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working at the interface level instead of with concrete implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping families of objects to obtain a family object creator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example - a factory of payment methods for a shop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example, we are going to implement a payments method Factory, which
    is going to provide us with different ways of paying at a shop. In the beginning,
    we will have two methods of paying--cash and credit card. We'll also have an interface
    with the method, `Pay`, which every struct that wants to be used as a payment
    method must implement.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the previous description, the requirements for the acceptance criteria
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To have a common method for every payment method called `Pay`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to delegate the creation of payments methods to the Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to add more payment methods to the library by just adding it to the
    factory method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Factory method has a very simple structure; we just need to identify how
    many implementations of our interface we are storing, and then provide a method,
    `GetPaymentMethod`, where you can pass a type of payment as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines define the interface of the payment method. They define a
    way of making a payment at the shop. The Factory method will return instances
    of types that implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have to define the identified payment methods of the Factory as constants
    so that we can call and check the possible payment methods from outside of the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the function that will create the objects for us. It returns
    a pointer, which must have an object that implements the `PaymentMethod` interface,
    and an error if asked for a method which is not registered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To finish the declaration of the Factory, we create the two payment methods.
    As you can see, the `CashPM` and `DebitCardPM` structs implement the `PaymentMethod`
    interface by declaring a method, `Pay(amount float32) string`. The returned string
    will contain information about the payment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this declaration, we will start by writing the tests for the first acceptance
    criteria: to have a common method to retrieve objects that implement the `PaymentMethod`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll have to separate the tests among a few of the test functions. `GetPaymentMethod`
    is a common method to retrieve methods of payment. We use the constant `Cash`,
    which we have defined in the implementation file (if we were using this constant
    outside for the scope of the package, we would call it using the name of the package
    as the prefix, so the syntax would be `creational.Cash`). We also check that we
    have not received an error when asking for a payment method. Observe that if we
    receive the error when asking for a payment method, we call `t.Fatal` to stop
    the execution of the tests; if we called just `t.Error` like in the previous tests,
    we would have a problem in the next lines when trying to access the `Pay` method
    of a nil object, and our tests would crash execution. We continue by using the
    `Pay` method of the interface by passing 10.30 as the amount. The returned message
    will have to contain the text `paid using cash`. The `t.Log(string)` method is
    a special method in testing. This struct allows us to write some logs when we
    run the tests if we pass the `-v` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We repeat the same operation with the debit card method. We ask for the payment
    method defined with the constant `DebitCard,` and the returned message, when paying
    with debit card, must contain the `paid using debit card` string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we are going to test the situation when we request a payment method
    that doesn´t exist (represented by the number 20, which doesn't match any recognized
    constant in the Factory). We will check if an error message (any) is returned
    when asking for an unknown payment method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check whether all tests are failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, we can only see tests that return the `PaymentMethod`
    interfaces failing. In this case, we'll have to implement just a part of the code,
    and then test again before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with the `GetPaymentMethod` method. It must receive an integer
    that matches with one of the defined constants of the same file to know which
    implementation it should return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a plain switch to check the contents of the argument `m` (method). If
    it matches any of the known methods--cash or debit card, it returns a new instance
    of them. Otherwise, it will return a nil and an error indicating that the payment
    method has not been recognized. Now we can run our tests again to check the second
    part of the unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we do not get the errors saying it couldn''t find the type of payment methods.
    Instead, we receive a `message not correct` error when it tries to use any of
    the methods that it covers. We also got rid of the `Not implemented` message that
    was being returned when we asked for an unknown payment method. Let''s implement
    the structs now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We just get the amount, printing it in a nicely formatted message. With this
    implementation, the tests will all be passing now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see the `LOG`: messages? They aren''t errors, we just print some information
    that we receive when using the package under test. These messages can be omitted
    unless you pass the `-v` flag to the test command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading the Debitcard method to a new platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now imagine that your `DebitCard` payment method has changed for some reason,
    and you need a new struct for it. To achieve this scenario, you will only need
    to create the new struct and replace the old one when the user asks for the `DebitCard`
    payment method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our new type that will replace the `DebitCardPM` structure. The `CreditCardPM`
    implements the same `PaymentMethod` interface as the debit card. We haven''t deleted
    the previous one in case we need it in the future. The only difference lies in
    the returned message that now contains the information about the new type. We
    also have to modify the method to retrieve the payment methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The only modification is in the line where we create the new debit card that
    now points to the newly created struct. Let''s run the tests to see if everything
    is still correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh, oh! Something has gone wrong. The expected message when paying with a credit
    card does not match the returned message. Does it mean that our code isn''t correct?
    Generally speaking, yes, you shouldn''t modify your tests to make your program
    work. When defining tests, you should be also aware of not defining them too much
    because you could achieve some coupling in the tests that you didn''t have in
    your code. With the message restriction, we have a few grammatically correct possibilities
    for the message, so we''ll change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the tests again now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Everything is okay again. This was just a small example of how to write good
    unit tests, too. When we wanted to check that a debit card payment method returns
    a message that contains `paid using debit card` string, we were probably being
    a bit restrictive, and it would be better to check for those words separately
    or define a better formatting for the returned messages.
  prefs: []
  type: TYPE_NORMAL
- en: What we learned about the Factory method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Factory method pattern, we have learned how to group families of objects
    so that their implementation is outside of our scope. We have also learned what
    to do when we need to upgrade an implementation of a used structs. Finally, we
    have seen that tests must be written with care if you don't want to tie yourself
    to certain implementations that don't have anything to do with the tests directly.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory - a factory of factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning about the factory design pattern, where we grouped a family of
    related objects in our case payment methods, one can be quick to think--what if
    I group families of objects in a more structured hierarchy of families?
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Abstract Factory design pattern is a new layer of grouping to achieve a
    bigger (and more complex) composite object, which is used through its interfaces.
    The idea behind grouping objects in families and grouping families is to have
    big factories that can be interchangeable and can grow more easily. In the early
    stages of development, it is also easier to work with factories and abstract factories
    than to wait until all concrete implementations are done to start your code. Also,
    you won't write an Abstract Factory from the beginning unless you know that your
    object's inventory for a particular field is going to be very large and it could
    be easily grouped into families.
  prefs: []
  type: TYPE_NORMAL
- en: The objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grouping related families of objects is very convenient when your object number
    is growing so much that creating a unique point to get them all seems the only
    way to gain the flexibility of the runtime object creation. The following objectives
    of the Abstract Factory method must be clear to you:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a new layer of encapsulation for Factory methods that return a common
    interface for all factories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group common factories into a *super Factory* (also called a factory of factories)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vehicle factory example, again?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example, we are going to reuse the Factory we created in the Builder
    design pattern. We want to show the similarities to solve the same problem using
    a different approach so that you can see the strengths and weaknesses of each
    approach. This is going to show you the power of implicit interfaces in Go, as
    we won't have to touch almost anything. Finally, we are going to create a new
    Factory to create shipment orders.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the acceptance criteria for using the `Vehicle` object''s
    Factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: We must retrieve a `Vehicle` object using a factory returned by the abstract
    factory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vehicle must be a concrete implementation of a `Motorbike` or a `Car` that
    implements both interfaces (`Vehicle` and `Car` or `Vehicle` and `Motorbike`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is going to be a long example, so pay attention, please. We will have
    the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicle**: The interface that all objects in our factories must implement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motorbike**: An interface for motorbikes of the types sport (one seat) and
    cruise (two seats).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Car**: An interface for cars of types luxury (with four doors) and family
    (with five doors).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VehicleFactory**: An interface (the Abstract Factory) to retrieve factories
    that implement the `VehicleFactory` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motorbike** Factory: A factory that implements the `VehicleFactory` interface
    to return vehicle that implements the `Vehicle` and `Motorbike` interfaces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Car** Factory: Another factory that implements the `VehicleFactory` interface
    to return vehicles that implement the `Vehicle` and `Car` interfaces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For clarity, we are going to separate each entity into a different file. We
    will start with the `Vehicle` interface, which will be in the `vehicle.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Car` and `Motorbike` interfaces will be in the `car.go` and `motorbike.go`
    files, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one last interface, the one that each factory must implement. This
    will be in the `vehicle_factory.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we are going to declare the car factory. It must implement the `VehicleFactory`
    interface defined previously to return `Vehicles` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined two types of cars--luxury and family. The `car` Factory will
    have to return cars that implement the `Car` and the `Vehicle` interfaces, so
    we need two concrete implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for cars. Now we need the motorbike factory, which, like the car
    factory, must implement the `VehicleFactory` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For the motorbike Factory, we have also defined two types of motorbikes using
    the `const` keywords: `SportMotorbikeType` and `CruiseMotorbikeType`. We will
    switch over the `v` argument in the `Build` method to know which type shall be
    returned. Let''s write the two concrete motorbikes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, we need the abstract factory itself, which we will put in the previously
    created `vehicle_factory.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to write enough tests to make a reliable check as the scope of
    the book doesn''t cover 100% of the statements. It will be a good exercise for
    the reader to finish these tests. First, a `motorbike` Factory test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We use the package method, `BuildFactory` , to retrieve a motorbike Factory
    (passing the `MotorbikeFactory` ID in the parameters), and check if we get any
    error. Then, already with the motorbike factory, we ask for a vehicle of the type
    `SportMotorbikeType` and check for errors again. With the returned vehicle, we
    can ask for methods of the vehicle interface (`NumWheels` and `NumSeats`). We
    know that it is a motorbike, but we cannot ask for the type of motorbike without
    using the type assertion. We use the type assertion on the vehicle to retrieve
    the motorbike that the `motorbikeVehicle` represents in the code line `sportBike,
    found := motorbikeVehicle.(Motorbike)`, and we must check that the type we have
    received is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, now we have a motorbike instance, we can ask for the bike type by
    using the `GetMotorbikeType` method. Now we are going to write a test that checks
    the car factory in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use the `BuildFactory` method to retrieve a `Car` Factory by using
    the `CarFactoryType` in the parameters. With this factory, we want a car of the `Luxury`
    type so that it returns a `vehicle` instance. We again do the type assertion to
    point to a car instance so that we can ask for the number of doors using the `NumDoors`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Done. It can't recognize any factory as their implementation is still not done.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of every factory is already done for the sake of brevity.
    They are very similar to the Factory method with the only difference being that
    in the Factory method, we don''t use an instance of the Factory method because
    we use the package functions directly. The implementation of the `vehicle` Factory
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in any factory, we switched between the factory possibilities to return
    the one that was demanded. As we have already implemented all concrete vehicles,
    the tests must run too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'All of them passed. Take a close look and note that we have used the `-cover`
    flag when running the tests to return a coverage percentage of the package: 45.8%.
    What this tells us is that 45.8% of the lines are covered by the tests we have
    written, but 54.2% are still not under the tests. This is because we haven''t
    covered the cruise motorbike and the family car with the tests. If you write those
    tests, the result should rise to around 70.8%.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type assertion is also known as **casting** in other languages. When you have
    an interface instance, which is essentially a pointer to a struct, you just have
    access to the interface methods. With type assertion, you can tell the compiler
    the type of the pointed struct, so you can access the entire struct fields and
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: A few lines about the Abstract Factory method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned how to write a factory of factories that provides us with a
    very generic object of vehicle type. This pattern is commonly used in many applications
    and libraries, such as cross-platform GUI libraries. Think of a button, a generic
    object, and button factory that provides you with a factory for Microsoft Windows
    buttons while you have another factory for Mac OS X buttons. You don't want to
    deal with the implementation details of each platform, but you just want to implement
    the actions for some specific behavior raised by a button.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have seen the differences when approaching the same problem with two
    different solutions--the Abstract factory and the Builder pattern. As you have
    seen, with the Builder pattern, we had an unstructured list of objects (cars with
    motorbikes in the same factory). Also, we encouraged reusing the building algorithm
    in the Builder pattern. In the Abstract factory, we have a very structured list
    of vehicles (the factory for motorbikes and a factory for cars). We also didn't
    mix the creation of cars with motorbikes, providing more flexibility in the creation
    process. The Abstract factory and Builder patterns can both resolve the same problem,
    but your particular needs will help you find the slight differences that should
    lead you to take one solution or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last pattern we will see in this chapter is the **Prototype** pattern. Like
    all creational patterns, this too comes in handy when creating objects, and it
    is very common to see the Prototype pattern surrounded by more patterns.
  prefs: []
  type: TYPE_NORMAL
- en: While with the Builder pattern, we are dealing with repetitive building algorithms
    and with the factories we are simplifying the creation of many types of objects;
    with the Prototype pattern, we will use an already created instance of some type
    to clone it and complete it with the particular needs of each context. Let's see
    it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of the Prototype pattern is to have an object or a set of objects that
    is already created at compilation time, but which you can clone as many times
    as you want at runtime. This is useful, for example, as a default template for
    a user who has just registered with your webpage or a default pricing plan in
    some service. The key difference between this and a Builder pattern is that objects
    are cloned for the user instead of building them at runtime. You can also build
    a cache-like solution, storing information using a prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Objective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main objective for the Prototype design pattern is to avoid repetitive
    object creation. Imagine a default object composed of dozens of fields and embedded
    types. We don''t want to write everything needed by this type every time that
    we use the object, especially if we can mess it up by creating instances with
    different *foundations*:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintain a set of objects that will be cloned to create new instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a default value of some type to start working on top of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free CPU of complex object initialization to take more memory resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build a small component of an imaginary customized shirts shop that
    will have a few shirts with their default colors and prices. Each shirt will also
    have a **Stock Keeping Unit (SKU)**, a system to identify items stored at a specific
    location) that will need an update.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To achieve what is described in the example, we will use a prototype of shirts.
    Each time we need a new shirt we will take this prototype, clone it and work with
    it. In particular, those are the acceptance criteria for using the Prototype pattern
    design method in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: To have a shirt-cloner object and interface to ask for different types of shirts
    (white, black, and blue at 15.00, 16.00, and 17.00 dollars respectively)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you ask for a white shirt, a clone of the white shirt must be made, and
    the new instance must be different from the original one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SKU of the created object shouldn't affect new object creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An info method must give me all the information available on the instance fields,
    including the updated SKU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will need a `ShirtCloner` interface and an object that implements
    it. Also, we need a package-level function called `GetShirtsCloner` to retrieve
    a new instance of the cloner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need an object struct to clone, which implements an interface to retrieve
    the information of its fields. We will call the object `Shirt` and the `ItemInfoGetter`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you realized that the type called `ShirtColor` that we defined is just
    a `byte` type? Maybe you are wondering why we haven't simply used the byte `type`.
    We could, but this way we created an easily readable struct, which we can upgrade
    with some methods in the future if required. For example, we could write a `String()`
    method that returns the color in the string format (`White` for type 1, `Black`
    for type 2, and `Blue` for type 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code, we can already write our first tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We will cover the first case of our scenario, where we need a cloner object
    that we can use to ask for different shirt colors.
  prefs: []
  type: TYPE_NORMAL
- en: For the second case, we will take the original object (which we can access because
    we are in the scope of the package), and we will compare it with our `shirt1`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the third case. First, we will type assert `item1` to a shirt so that
    we can set an SKU. We will create a second shirt, also white, and we will type
    assert it too to check that the SKUs are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the fourth case, we log the info of the first and second shirts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be printing the memory positions of both shirts, so we make this assertion
    at a more physical level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we run the tests so we can check that it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We have to stop there so that the tests don't panic if we try to use a nil object
    that is returned by the `GetShirtsCloner` function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with the `GetClone` method. This method should return an item
    of the specified type and we have three type: white, black and blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'So now that we have the three prototypes to work over we can implement `GetClone(s
    int)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `Shirt` structure also needs a `GetInfo` implementation to print the contents
    of the instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s run the tests to see that everything is now working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the log, (remember to set the `-v` flag when running the tests) you can check
    that `shirt1` and `shirt2` have different SKUs. Also, we can see the memory positions
    of both objects. Take into account that the positions shown on your computer will
    probably be different.
  prefs: []
  type: TYPE_NORMAL
- en: What we learned about the Prototype design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Prototype pattern is a powerful tool to build caches and default objects.
    You have probably realized too that some patterns can overlap a bit, but they
    have small differences that make them more appropriate in some cases and not so
    much in others.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the five main creational design patterns commonly used in the software
    industry. Their purpose is to abstract the user from the creation of objects for
    complexity or maintainability purposes. They have been the foundation of thousands
    of applications and libraries since the 1990s, and most of the software we use
    today has many of these creational patterns under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth mentioning that these patterns are not thread-free. In a more advanced
    chapter, we will see concurrent programming in Go, and how to create some of the
    more critical design patterns using a concurrent approach.
  prefs: []
  type: TYPE_NORMAL
