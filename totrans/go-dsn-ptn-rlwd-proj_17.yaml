- en: Chapter 3. Structural Patterns - Composite, Adapter, and Bridge Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：结构模式 - 组合、适配器和桥接设计模式
- en: We are going to start our journey through the world of structural patterns.
    Structural patterns, as the name implies, help us to shape our applications with
    commonly used structures and relationships.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始探索结构模式的世界。正如其名所示，结构模式帮助我们使用常用的结构和关系来塑造我们的应用程序。
- en: The Go language, by nature, encourages use of composition almost exclusively
    by its lack of inheritance. Because of this, we have been using the **Composite**
    design pattern extensively until now, so let's start by defining the Composite
    design pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言由于其缺乏继承，本质上鼓励几乎完全使用组合。正因为如此，我们至今一直在广泛使用组合设计模式，所以让我们首先定义组合设计模式。
- en: Composite design pattern
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计模式
- en: The Composite design pattern favors composition (commonly defined as a *has
    a* relationship) over inheritance (an *is a* relationship). The c*omposition over
    inheritance* approach has been a source of discussions among engineers since the
    nineties. We will learn how to create object structures by using a *has a* approach.
    All in all, Go doesn't have inheritance because it doesn't need it!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式倾向于组合（通常定义为“有一个”关系）而不是继承（“是一个”关系）。自九十年代以来，“组合优于继承”的方法一直是工程师们讨论的来源。我们将学习如何通过使用“有一个”方法来创建对象结构。总的来说，Go
    语言没有继承，因为它不需要它！
- en: Description
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: 'In the Composite design pattern, you will create hierarchies and trees of objects.
    Objects have different objects with their own fields and methods inside them.
    This approach is very powerful and solves many problems of inheritance and multiple
    inheritances. For example, a typical inheritance problem is when you have an entity
    that inherits from two completely different classes, which have absolutely no
    relationship between them. Imagine an athlete who trains, and who is a swimmer who
    swims:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合设计模式中，你将创建对象层次结构和树。对象内部有不同的对象，它们有自己的字段和方法。这种方法非常强大，解决了许多继承和多继承的问题。例如，一个典型的继承问题是你有一个实体从两个完全不同的类继承，这两个类之间没有任何关系。想象一个既训练又游泳的运动员：
- en: The `Athlete` class has a `Train()` method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Athlete` 类有一个 `Train()` 方法'
- en: The `Swimmer` class has a `Swim()` method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swimmer` 类有一个 `Swim()` 方法'
- en: The `Swimmer` class inherits from the `Athlete` class, so it inherits its `Train`
    method and declares its own `Swim` method. You could also have a cyclist who is
    also an athlete, and declares a `Ride` method.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swimmer` 类从 `Athlete` 类继承，因此继承了它的 `Train()` 方法并声明了自己的 `Swim()` 方法。你也可以有一个既是运动员又是骑手的自行车手，并声明一个
    `Ride()` 方法。'
- en: 'But now imagine an animal that eats, like a dog that also barks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在想象一个像狗一样既能吃又能吠叫的动物：
- en: The `Cyclist` class has a `Ride()` method
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cyclist` 类有一个 `Ride()` 方法'
- en: The `Animal` class has `Eat()`, `Dog()`, and `Bark()` methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animal` 类有 `Eat()`、`Dog()` 和 `Bark()` 方法'
- en: Nothing fancy. You could also have a fish that is an animal, and yes, swims!
    So, how do you solve it? A fish cannot be a swimmer that also trains. Fish don't
    train (as far as I know!). You could make a `Swimmer` interface with a `Swim`
    method, and make the swimmer athlete and fish implement it. This would be the
    best approach, but you still would have to implement `swim` method twice, so code
    reusability would be affected. What about a triathlete? They are athletes who
    swim, run, and ride. With multiple inheritances, you could have a sort of solution,
    but that will become complex and not maintainable very soon.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么花哨的。你也可以有一个既是动物又会游泳的鱼！那么，你该如何解决这个问题呢？鱼不能既是游泳者又是训练者。据我所知，鱼不会训练！你可以创建一个带有
    `Swim()` 方法的 `Swimmer` 接口，并让游泳运动员和鱼实现它。这将是一个最佳方法，但你仍然需要两次实现 `swim` 方法，因此代码的可重用性会受到影响。那么铁人三项运动员呢？他们是既游泳又跑步又骑行的运动员。使用多继承，你可以有一种解决方案，但很快就会变得复杂且难以维护。
- en: Objectives
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: As you have probably imagined already, the objective of the composition is to
    avoid this type of hierarchy hell where the complexity of an application could
    grow too much, and the clarity of the code is affected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经想象到的，组合的目标是避免这种类型的高度层次地狱，应用程序的复杂性可能会变得过大，代码的清晰度受到影响。
- en: The swimmer and the fish
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游泳者和鱼
- en: We will solve the described problem of the athlete and the fish that swims in
    a very idiomatic Go way. With Go, we can use two types of composition--the **direct**
    composition and the **embedding** composition. We will first solve this problem
    by using direct composition which is having everything that is needed as fields
    within the struct.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以非常符合Go风格的编程方式解决描述的运动员和游泳的鱼的问题。使用Go，我们可以使用两种类型的组合——**直接**组合和**嵌入**组合。我们将首先通过使用直接组合来解决这个问题，即在结构体内部作为字段包含所需的所有内容。
- en: Requirements and acceptance criteria
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'Requirements are like the ones described previously. We''ll have an athlete
    and a swimmer. We will also have an animal and a fish. The `Swimmer` and the `Fish` methods
    must share the code. The athlete must train, and the animal must eat:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 需求与验收标准类似。我们将有一个运动员和一个泳者。我们还将有一个动物和一条鱼。`Swimmer`和`Fish`方法必须共享代码。运动员必须训练，动物必须进食：
- en: We must have an `Athlete` struct with a `Train` method
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个具有`Train`方法的`Athlete`结构
- en: We must have a `Swimmer` with a `Swim` method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个具有`Swim`方法的`Swimmer`
- en: We must have an `Animal` struct with an `Eat` method
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个具有`Eat`方法的`Animal`结构
- en: We must have a `Fish` struct with a `Swim` method that is shared with the `Swimmer`,
    and not have inheritance or hierarchy issues
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个具有与`Swimmer`共享的`Swim`方法的`Fish`结构，并且没有继承或层次问题
- en: Creating compositions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建组合
- en: The Composite design pattern is a pure structural pattern, and it doesn't have
    much to test apart from the structure itself. We won't write unit tests in this
    case, and we'll simply describe the ways to create those compositions in Go.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 复合设计模式是一个纯结构模式，除了结构本身之外，没有太多可以测试的内容。在这种情况下，我们不会编写单元测试，而只是描述在Go中创建这些组合的方法。
- en: 'First, we''ll start with the `Athlete` structure and its `Train` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`Athlete`结构和它的`Train`方法开始：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is pretty straightforward. Its `Train` method prints the
    word `Training` and a new line. We''ll create a composite swimmer that has an
    `Athlete` struct inside it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码相当简单。它的`Train`方法打印出单词`Training`和一行新内容。我们将创建一个包含`Athlete`结构的复合泳者：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `CompositeSwimmerA` type has a `MyAthlete` field of type `Athlete`. It
    also stores a `func()` type. Remember that in Go, functions are first-class citizens
    and they can be used as parameters, fields, or arguments just like any variable.
    So `CompositeSwimmerA` has a `MySwim` field that stores a **closure**, which takes
    no arguments and returns nothing. How can I assign a function to it? Well, let''s
    create a function that matches the `func()` signature (no arguments, no return):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositeSwimmerA`类型有一个类型为`Athlete`的`MyAthlete`字段。它还存储一个`func()`类型。记住，在Go中，函数是一等公民，它们可以用作参数、字段或参数，就像任何变量一样。所以`CompositeSwimmerA`有一个存储**闭包**的`MySwim`字段，该闭包不接受任何参数也不返回任何内容。我如何将它分配给它？好吧，让我们创建一个与`func()`签名匹配的函数（没有参数，没有返回）：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s all! The `Swim()` function takes no arguments and returns nothing,
    so it can be used as the `MySwim` field in the `CompositeSwimmerA` struct:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那就足够了！`Swim()`函数不接受任何参数也不返回任何内容，因此它可以作为`CompositeSwimmerA`结构中的`MySwim`字段使用：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we have a function called `Swim()`, we can assign it to the `MySwim`
    field. Note that the `Swim` type doesn't have the parenthesis that will execute
    its contents. This way we take the entire function and copy it to `MySwim` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有一个名为`Swim()`的函数，我们可以将其分配给`MySwim`字段。请注意，`Swim`类型没有执行其内容的括号。这样我们就取整个函数并将其复制到`MySwim`方法中。
- en: 'But wait. We haven''t passed any athlete to the `MyAthlete` field and we are
    using it! It''s going to fail! Let''s see what happens when we execute this snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等。我们没有将任何运动员传递给`MyAthlete`字段，并且正在使用它！这将会失败！让我们看看执行此代码片段会发生什么：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s weird, isn''t it? Not really because of the nature of zero-initialization
    in Go. If you don''t pass an `Athlete` struct to the `CompositeSwimmerA` type,
    the compiler will create one with its values zero-initialized, that is, an `Athlete`
    struct with its fields initialized to zero. Check out [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!* to recall zero-initialization
    if this seems confusing. Consider the `CompositeSwimmerA` struct code again:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这很奇怪，不是吗？其实并不是，因为这是Go中零初始化的特性。如果你没有将`Athlete`结构传递给`CompositeSwimmerA`类型，编译器将创建一个具有零初始化值的结构，即字段初始化为零的`Athlete`结构。查看[第1章](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第1章. 准备... 集合... 开始！")，*准备... 集合... 开始！*来回忆零初始化，如果这看起来很困惑。再次考虑`CompositeSwimmerA`结构代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have a pointer to a function stored in the `MySwim` field. We can assign
    the `Swim` function the same way, but with an extra step:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个指向存储在`MySwim`字段中的函数的指针。我们可以以相同的方式分配`Swim`函数，但需要额外的一步：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we need a variable that contains the function `Swim`. This is because
    a function doesn't have an address to pass it to the `CompositeSwimmerA` type.
    Then, to use this function within the struct, we have to make a two-step call.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个包含`Swim`函数的变量。这是因为函数没有地址可以传递给`CompositeSwimmerA`类型。然后，为了在结构体中使用这个函数，我们必须进行两步调用。
- en: 'What about our fish problem? With our `Swim` function, it is not a problem
    anymore. First, we create the `Animal` struct:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的鱼问题呢？有了我们的`Swim`函数，这不再是问题。首先，我们创建`Animal`结构体：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we''ll create a `Shark` object that embeds the `Animal` object:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个嵌入`Animal`对象的`Shark`对象：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wait a second! Where is the field name of the `Animal` type? Did you realize
    that I used the word *embed* in the previous paragraph? This is because, in Go,
    you can also embed objects within objects to make it look a lot like inheritance.
    That is, we won''t have to explicitly call the field name to have access to its
    fields and method because they''ll be part of us. So the following code will be
    perfectly okay:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！`Animal`类型的字段名在哪里？你意识到我在上一段中使用了*嵌入*这个词吗？这是因为，在Go中，你还可以在对象中嵌入对象，使其看起来非常像继承。也就是说，我们不需要显式地调用字段名来访问其字段和方法，因为它们将是我们的一部分。所以以下代码将完全没问题：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have an `Animal` type, which is zero-initialized and embedded. This
    is why I can call the `Eat` method of the `Animal` struct without creating it
    or using the intermediate field name. The output of this snippet is the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Animal`类型，它是零初始化并嵌入的。这就是为什么我可以调用`Animal`结构体的`Eat`方法，而无需创建它或使用中间字段名。这个代码片段的输出如下：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, there is a third method to use the Composite pattern. We could create
    a `Swimmer` interface with a `Swim` method and a `SwimmerImpl` type to embed it
    in the athlete swimmer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有第三种使用复合模式的方法。我们可以创建一个带有`Swim`方法的`Swimmer`接口和一个`SwimmerImpl`类型来在运动员游泳者中嵌入它。
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this method, you have more explicit control over object creation. The
    `Swimmer` field is embedded, but won''t be zero-initialized as it is a pointer
    to an interface. The correct use of this approach will be the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你对对象创建有更多的显式控制。`Swimmer`字段是嵌入的，但不会进行零初始化，因为它是一个接口的指针。正确使用这种方法的方式如下：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the output for `CompositeSwimmerB` is the following, as expected:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`CompositeSwimmerB`的输出正如预期的那样：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Which approach is better? Well, I have a personal preference, which shouldn't
    be considered the rule of thumb. In my opinion, the *interfaces* approach is the
    best for quite a few reasons, but mainly for explicitness. First of all, you are
    working with interfaces  which are preferred instead of structs. Second, you aren't
    leaving parts of your code to the zero-initialization feature of the compiler.
    It's a really powerful feature, but one that must be used with care, because it
    can lead to runtime problems which you'll find at compile time when working with
    interfaces. In different situations, zero-initialization will save you at runtime,
    in fact! But I prefer to work with interfaces as much as possible, so this is
    not actually one of the options.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？嗯，我有一个个人的偏好，但这不应该被视为一个规则。在我看来，*接口*方法由于很多原因，尤其是由于明确性，是最好的。首先，你正在使用接口而不是结构体。其次，你没有将代码的一部分留给编译器的零初始化功能。这是一个非常强大的功能，但必须谨慎使用，因为它可能导致运行时问题，这些问题你会在使用接口时在编译时发现。在不同的情境下，零初始化会在运行时为你节省时间！但我的偏好是尽可能多地使用接口，所以这实际上并不是一个选项。
- en: Binary Tree compositions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉树组合
- en: 'Another very common approach to the Composite pattern is when working with
    Binary Tree structures. In a Binary Tree, you need to store instances of itself
    in a field:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 复合模式的另一种非常常见的方法是在处理二叉树结构时。在二叉树中，你需要在一个字段中存储它自己的实例：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is some kind of recursive compositing, and, because of the nature of recursivity,
    we must use pointers so that the compiler knows how much memory it must reserve
    for this struct. Our `Tree` struct stored a `LeafValue` object for each instance
    and a new `Tree` in its `Right` and `Left` fields.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种递归复合，由于递归的性质，我们必须使用指针，这样编译器就知道为这个结构体保留多少内存。我们的`Tree`结构体为每个实例存储了一个`LeafValue`对象，并在其`Right`和`Left`字段中存储了一个新的`Tree`。
- en: 'With this structure, we could create an object like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，我们可以创建一个像这样的对象：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can print the contents of its deepest branch like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样打印其最深层的分支内容：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Composite pattern versus inheritance
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合模式与继承的比较
- en: 'When using the Composite design pattern in Go, you must be very careful not
    to confuse it with inheritance. For example, when you embed a `Parent` struct
    within a `Son` struct, like in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用组合设计模式时，你必须非常小心，不要将其与继承混淆。例如，当你将`Parent`结构体嵌入到`Son`结构体中时，如下例所示：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You cannot consider that the `Son` struct is also the `Parent` struct. What
    this means is that you cannot pass an instance of the `Son` struct to a function
    that is expecting a `Parent` struct like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能认为`Son`结构体也是`Parent`结构体。这意味着你不能将`Son`结构体的实例传递给期望`Parent`结构体的函数，如下所示：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you try to pass a `Son` instance to the `GetParentField` method, you will
    get the following error message:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将`Son`实例传递给`GetParentField`方法时，你会得到以下错误信息：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This, in fact, makes a lot of sense. What''s the solution for this? Well, you
    can simply composite the `Son`  struct with the parent without embedding so that
    you can access the `Parent` instance later:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这很有道理。这个问题的解决方案是什么？嗯，你可以简单地通过组合而不是内嵌的方式将`Son`结构体与父结构体组合起来，这样你就可以稍后访问`Parent`实例：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So now you could use the `P` field to pass it to the `GetParentField` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在你可以使用`P`字段将其传递给`GetParentField`方法：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Final words on the Composite pattern
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于组合模式的最后几句话
- en: At this point, you should be really comfortable using the Composite design pattern.
    It's a very idiomatic Go feature, and the switch from a pure object-oriented language
    is not very painful. The Composite design pattern makes our structures predictable
    but also allows us to create most of the design patterns as we will see in later
    chapters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该已经非常熟练地使用组合设计模式了。这是Go语言的一个非常地道的特性，从纯面向对象语言切换过来并不痛苦。组合设计模式使得我们的结构更加可预测，同时也允许我们创建大多数将在后续章节中看到的设计模式。
- en: Adapter design pattern
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: One of the most commonly used structural patterns is the **Adapter** pattern.
    Like in real life, where you have plug adapters and bolt adapters, in Go, an adapter
    will allow us to use something that wasn't built for a specific task at the beginning.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的结构型模式之一是**适配器**模式。就像在现实生活中，你有插头适配器和螺栓适配器一样，在Go中，适配器将允许我们使用最初并非为特定任务构建的东西。
- en: Description
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Adapter pattern is very useful when, for example, an interface gets outdated
    and it's not possible to replace it easily or fast. Instead, you create a new
    interface to deal with the current needs of your application, which, under the
    hood, uses implementations of the old interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当例如接口过时，无法轻松或快速替换时，适配器模式非常有用。相反，你可以创建一个新的接口来处理应用程序的当前需求，而实际上，它使用的是旧接口的实现。
- en: Adapter also helps us to maintain the *open/closed principle* in our apps, making
    them more predictable too. They also allow us to write code which uses some base
    that we can't modify.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器还帮助我们保持应用程序中的*开放/封闭原则*，使它们更加可预测。它们还允许我们编写使用某些无法修改的基类的代码。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The open/closed principle was first stated by Bertrand Meyer in his book *Object-Oriented
    Software Construction*. He stated that code should be open to new functionality,
    but closed to modifications. What does it mean? Well, it implies a few things.
    On one hand, we should try to write code that is extensible and not only one that
    works. At the same time, we should try not to modify the source code (yours or
    other people's) as much as we can, because we aren't always aware of the implications
    of this modification. Just keep in mind that extensibility in code is only possible
    through the use of design patterns and interface-oriented programming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/封闭原则最初由伯特兰·梅耶在他的书《面向对象软件构造》中提出。他提出，代码应该对新功能开放，但对修改封闭。这意味着什么？嗯，它暗示了几件事情。一方面，我们应该尝试编写可扩展的代码，而不仅仅是能工作的代码。同时，我们应该尽量少修改源代码（无论是你的还是别人的），因为我们并不总是意识到这种修改的后果。只需记住，代码的可扩展性只有通过使用设计模式和面向接口的编程才能实现。
- en: Objectives
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: The Adapter design pattern will help you fit the needs of two parts of the code
    that are incompatible at first. This is the key to being kept in mind when deciding
    if the Adapter pattern is a good design for your problem--two interfaces that
    are incompatible, but which must work together, are good candidates for an Adapter
    pattern (but they could also use the facade pattern, for example).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式将帮助您适应代码中最初不兼容的两个部分。这是决定适配器模式是否是您问题的良好设计的关键——两个最初不兼容但必须一起工作的接口是适配器模式的良好候选（但它们也可以使用外观模式，例如）。
- en: Using an incompatible interface with an Adapter object
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用适配器对象的不兼容接口
- en: For our example, we will have an old `Printer` interface and a new one. Users
    of the new interface don't expect the signature that the old one has, and we need
    an Adapter so that users can still use old implementations if necessary (to work
    with some legacy code, for example).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将有一个旧的 `Printer` 接口和一个新的接口。新接口的用户不会期望旧接口的签名，我们需要一个适配器，以便用户在必要时仍然可以使用旧实现（例如，与某些旧代码一起工作）。
- en: Requirements and acceptance criteria
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'Having an old interface called `LegacyPrinter` and a new one called `ModernPrinter`,
    create a structure that implements the `ModernPrinter` interface and can use the
    `LegacyPrinter` interface as described in the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `LegacyPrinter` 的旧接口和一个名为 `ModernPrinter` 的新接口，创建一个实现 `ModernPrinter`
    接口的结构，并且可以使用以下步骤中描述的 `LegacyPrinter` 接口：
- en: Create an Adapter object that implements the `ModernPrinter` interface.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现 `ModernPrinter` 接口的适配器对象。
- en: The new Adapter object must contain an instance of the `LegacyPrinter` interface.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的适配器对象必须包含 `LegacyPrinter` 接口的一个实例。
- en: When using `ModernPrinter`, it must call the `LegacyPrinter` interface under
    the hood, prefixing it with the text `Adapter`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 `ModernPrinter` 时，必须在底层调用 `LegacyPrinter` 接口，并在其前添加文本 `Adapter`。
- en: Unit testing our Printer adapter
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试我们的打印机适配器
- en: 'We will write the legacy code first, but we won''t test it as we should imagine
    that it isn''t our code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写旧代码，但我们将不会对其进行测试，因为我们应该想象它不是我们的代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The legacy interface called `LegacyPrinter` has a `Print` method that accepts
    a string and returns a message. Our `MyLegacyPrinter` struct implements the `LegacyPrinter` interface
    and modifies the passed string by prefixing the text `Legacy Printer:`. After
    modifying the text, the `MyLegacyPrinter` struct prints the text on the console,
    and then returns it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 旧接口 `LegacyPrinter` 有一个接受字符串并返回消息的 `Print` 方法。我们的 `MyLegacyPrinter` 结构体实现了 `LegacyPrinter`
    接口，并通过在文本前添加 `Legacy Printer:` 来修改传递的字符串。修改文本后，`MyLegacyPrinter` 结构体将在控制台上打印文本，然后返回它。
- en: 'Now we''ll declare the new interface that we''ll have to adapt:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将声明我们将要适配的新接口：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, the new `PrintStored` method doesn''t accept any string as an
    argument, because it will have to be stored in the implementers in advance. We
    will call our Adapter pattern''s `PrinterAdapter` interface:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，新的 `PrintStored` 方法不接受任何字符串作为参数，因为它必须事先存储在实现者中。我们将称我们的适配器模式的 `PrinterAdapter`
    接口为：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As mentioned earlier, the `PrinterAdapter` adapter must have a field to store
    the string to print. It must also have a field to store an instance of the `LegacyPrinter`
    adapter. So let''s write the unit tests:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`PrinterAdapter` 适配器必须有一个字段来存储要打印的字符串。它还必须有一个字段来存储 `LegacyPrinter` 适配器的一个实例。因此，让我们编写单元测试：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will use the message `Hello World!` for our adapter. When using this message
    with an instance of the `MyLegacyPrinter` struct, it prints the text `Legacy Printer:
    Hello World!`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将为适配器使用消息 `Hello World!`。当使用这个消息与 `MyLegacyPrinter` 结构体的一个实例时，它将打印文本 `Legacy
    Printer: Hello World!`：'
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We created an instance of the `PrinterAdapter` interface called `adapter`.
    We passed an instance of the `MyLegacyPrinter` struct as the `LegacyPrinter` field
    called `OldPrinter`. Also, we set the message we want to print in the `Msg` field:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `adapter` 的 `PrinterAdapter` 接口实例。我们将 `MyLegacyPrinter` 结构体的一个实例作为
    `LegacyPrinter` 字段 `OldPrinter` 传递。我们还设置了 `Msg` 字段中我们想要打印的消息：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we used the `PrintStored` method of the `ModernPrinter` interface; this
    method doesn''t accept any argument and must return the modified string. We know
    that the `MyLegacyPrinter` struct returns the passed string prefixed with the
    text `LegacyPrinter:`, and the adapter will prefix it with the text `Adapter:`
    So, in the end, we must have the text `Legacy Printer: Adapter: Hello World!\n`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们使用了`ModernPrinter`接口的`PrintStored`方法；这个方法不接受任何参数，必须返回修改后的字符串。我们知道`MyLegacyPrinter`结构返回的是带有文本`LegacyPrinter:`的前缀的传递字符串，适配器将使用文本`Adapter:`作为前缀。因此，最终我们必须有文本`Legacy
    Printer: Adapter: Hello World!\n`。'
- en: 'As we are storing an instance of an interface, we must also check that we handle
    the situation where the pointer is nil. This is done with the following test:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在存储一个接口的实例，我们还必须检查我们是否处理了指针为nil的情况。这是通过以下测试完成的：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we don''t pass an instance of the `LegacyPrinter` interface, the Adapter
    must ignore its adapt nature, and simply print and return the original message.
    Time to run our tests; consider the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有传递`LegacyPrinter`接口的实例，适配器必须忽略其适配特性，简单地打印并返回原始消息。现在是运行我们的测试的时候了；考虑以下情况：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementation
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'To make our single test pass, we must reuse the old `MyLegacyPrinter` that
    is stored in `PrinterAdapter` struct:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的单个测试通过，我们必须重用存储在`PrinterAdapter`结构体中的旧的`MyLegacyPrinter`：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `PrintStored` method, we check whether we actually have an instance of
    a `LegacyPrinter`. In this case, we compose a new string with the stored message
    and the `Adapter` prefix to store it in the returning variable (called `newMsg`).
    Then we use the pointer to the `MyLegacyPrinter` struct to print the composed
    message using the `LegacyPrinter` interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PrintStored`方法中，我们检查是否实际上有一个`LegacyPrinter`的实例。在这种情况下，我们使用存储的消息和`Adapter`前缀组合成一个新的字符串，并将其存储在返回变量（称为`newMsg`）中。然后我们使用指向`MyLegacyPrinter`结构的指针，使用`LegacyPrinter`接口打印组合的消息。
- en: 'In case there is no `LegacyPrinter` instance stored in the `OldPrinter` field,
    we simply assign the stored message to the returning variable `newMsg` and return
    the method. This should be enough to pass our tests:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`OldPrinter`字段中没有存储`LegacyPrinter`实例，我们只需将存储的消息赋值给返回变量`newMsg`并返回方法。这应该足以通过我们的测试：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Perfect! Now we can still use the old `LegacyPrinter` interface by using this
    `Adapter` while we use the `ModernPrinter` interface for future implementations.
    Just keep in mind that the Adapter pattern must ideally just provide the way to
    use the old `LegacyPrinter` and nothing else. This way, its scope will be more
    encapsulated and more maintainable in the future.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们可以在使用`ModernPrinter`接口进行未来实现的同时，仍然使用旧的`LegacyPrinter`接口通过这个`Adapter`。只需记住，适配器模式理想上只应提供使用旧的`LegacyPrinter`的方式，而不做其他事情。这样，它的作用域将更加封装，未来的可维护性也会更高。
- en: Examples of the Adapter pattern in Go's source code
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go源代码中适配器模式的示例
- en: 'You can find Adapter implementations at many places in the Go language''s source
    code. The famous `http.Handler` interface has a very interesting adapter implementation.
    A very simple, `Hello World` server in Go is usually done like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Go语言源代码的许多地方找到适配器实现。著名的`http.Handler`接口有一个非常有趣的适配器实现。一个简单的Go语言`Hello World`服务器通常是这样实现的：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The HTTP package has a function called `Handle` (like a `static` method in
    Java) that accepts two parameters--a string to represent the route and a `Handler`
    interface. The `Handler` interface is like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP包有一个名为`Handle`的函数（类似于Java中的`static`方法），它接受两个参数——一个表示路由的字符串和一个`Handler`接口。`Handler`接口如下：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to implement a `ServeHTTP` method that the server side of an HTTP connection
    will use to execute its context. But there is also a function `HandlerFunc` that
    allows you to define some endpoint behavior:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个`ServeHTTP`方法，该方法是HTTP连接的客户端用来执行其上下文的。但还有一个名为`HandlerFunc`的函数，它允许你定义一些端点行为：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `HandleFunc` function is actually part of an adapter for using functions
    directly as `ServeHTTP` implementations. Read the last sentence slowly again--can
    you guess how it is done?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleFunc`函数实际上是用于直接将函数用作`ServeHTTP`实现的适配器的一部分。再次慢慢阅读最后一句——你能猜到它是如何实现的吗？'
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can define a type that is a function in the same way that we define a struct.
    We make this function-type to implement the `ServeHTTP` method. Finally, from
    the `ServeHTTP` function, we call the receiver itself `f(w, r)`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个类型，就像我们定义结构体一样。我们使这个函数类型来实现`ServeHTTP`方法。最后，从`ServeHTTP`函数中，我们调用接收器本身`f(w,
    r)`。
- en: You have to think about the implicit interface implementation of Go. When we
    define a function like `func(ResponseWriter, *Request)`, it is implicitly being
    recognized as `HandlerFunc`. And because the `HandleFunc` function implements
    the `Handler` interface, our function implements the `Handler` interface implicitly
    too. Does this sound familiar to you? If *A = B* and *B = C*, then *A = C*. Implicit
    implementation gives a lot of flexibility and power to Go, but you must also be
    careful, because you don't know if a method or function could be implementing
    some interface that could provoke undesirable behaviors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须考虑 Go 的隐式接口实现。当我们定义一个像 `func(ResponseWriter, *Request)` 这样的函数时，它隐式地被识别为 `HandlerFunc`。因为
    `HandleFunc` 函数实现了 `Handler` 接口，所以我们的函数也隐式地实现了 `Handler` 接口。这听起来熟悉吗？如果 *A = B*
    和 *B = C*，那么 *A = C*。隐式实现给 Go 带来了很多灵活性和强大的功能，但你必须也要小心，因为你不知道一个方法或函数是否在实现一个可能会引起不良行为的接口。
- en: 'We can find more examples in Go''s source code. The `io` package has another
    powerful example with the use of pipes. A pipe in Linux is a flow mechanism that
    takes something on the input and outputs something else on the output. The `io`
    package has two interfaces, which are used everywhere in Go''s source code--the `io.Reader`
    and the `io.Writer` interface:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Go 的源代码中找到更多例子。`io` 包使用管道的另一个强大例子。Linux 中的管道是一种流机制，它从输入获取一些内容，并在输出输出其他内容。`io`
    包有两个接口，这些接口在 Go 的源代码中到处使用——`io.Reader` 和 `io.Writer` 接口：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We use `io.Reader` everywhere, for example, when you open a file using `os.OpenFile`,
    it returns a file, which, in fact, implements the `io.Reader` interface. Why is
    it useful? Imagine that you write a `Counter` struct that counts from the number
    you provide to zero:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到处都使用 `io.Reader`，例如，当你使用 `os.OpenFile` 打开一个文件时，它返回一个文件，实际上实现了 `io.Reader`
    接口。为什么它有用呢？想象一下你写一个 `Counter` 结构体，它从你提供的数字开始计数到零：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you provide the number 3 to this small snippet, it will print the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向这个小片段提供数字 3，它将打印以下内容：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Well, not really impressive! What if I want to write to a file instead of printing?
    We can implement this method too. What if I want to print to a file and to the
    console? Well, we can implement this method too. We must modularize it a bit more
    by using the `io.Writer` interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不太令人印象深刻！如果我想写入文件而不是打印怎么办？我们也可以实现这个方法。如果我想将打印输出到文件和控制台怎么办？嗯，我们也可以实现这个方法。我们必须通过使用
    `io.Writer` 接口来进一步模块化它：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we provide an `io.Writer` in the `Writer` field. This way, we could create
    the counter like this: `c := Counter{os.Stdout}`, and we will get a console `Writer`.
    But wait a second, we haven't solved the issue where we wanted to take the count
    to many `Writer` consoles. But we can write a new `Adapter` with an `io.Writer`
    and, using a `Pipe()` to connect a reader with a writer, we can read on the opposite
    extreme. This way, you can solve the issue where these two interfaces, `Reader`
    and `Writer`, which are incompatible, can be used together.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们提供一个 `io.Writer` 到 `Writer` 字段。这样，我们可以创建计数器，例如：`c := Counter{os.Stdout}`，我们将会得到一个控制台
    `Writer`。但是等等，我们还没有解决我们想要将计数传递到多个 `Writer` 控制台的问题。但是我们可以写一个新的 `Adapter`，带有 `io.Writer`，并使用
    `Pipe()` 连接一个读取器和一个写入器，我们可以在相反的极端读取。这样，你可以解决这两个接口，`Reader` 和 `Writer`，不兼容的问题，使它们可以一起使用。
- en: 'In fact, we don''t need to write the Adapter--the Go''s `io` library has one
    for us in `io.Pipe()`. The pipe will allow us to convert a `Reader` to a `Writer`
    interface. The `io.Pipe()` method will provide us a `Writer` (the entrance of
    the pipe) and a `Reader` (the exit) to play with. So let''s create a pipe, and
    assign the provided writer to the `Counter` of the preceding example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要编写 Adapter——Go 的 `io` 库在 `io.Pipe()` 中为我们提供了一个。管道将允许我们将 `Reader` 转换为
    `Writer` 接口。`io.Pipe()` 方法将为我们提供一个 `Writer`（管道的入口）和一个 `Reader`（出口）来操作。所以让我们创建一个管道，并将提供的写入器分配给前面例子中的
    `Counter`：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we have a `Reader` interface where we previously had a `Writer`. Where can
    we use the `Reader`? The `io.TeeReader` function helps us to copy the stream of
    data from a `Reader` interface to the `Writer` interface and, it returns a new
    `Reader` that you can still use to stream data again to a second writer. So we
    will stream the data from the same reader to two writers--the `file` and the `Stdout`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 `Reader` 接口，之前我们有 `Writer`。我们可以在哪里使用 `Reader`？`io.TeeReader` 函数帮助我们从一个
    `Reader` 接口复制数据流到 `Writer` 接口，并且它返回一个新的 `Reader`，你仍然可以使用它再次将数据流到一个第二个写入器。所以我们将数据从同一个读取器流到两个写入器——文件和
    `Stdout`。
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So now we know that we are writing to a file that we have passed to the `TeeReader`
    function. We still need to print to the console. The `io.Copy` adapter can be
    used like `TeeReader`--it takes a reader and writes its contents to a writer:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道我们正在写入传递给`TeeReader`函数的文件。我们仍然需要打印到控制台。`io.Copy`适配器可以像`TeeReader`一样使用--它接受一个读取器并将内容写入一个写入器：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have to launch the `Copy` function in a different Go routine so that the
    writes are performed concurrently, and one read/write doesn''t block a different
    read/write. Let''s modify the `counter` variable to make it count till 5 again:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在不同的Go协程中启动`Copy`函数，以便并发执行写入，一个读写操作不会阻塞另一个读写操作。让我们修改`counter`变量，使其再次计数到5：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this modification to the code, we get the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码的此修改，我们得到以下输出：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Okay, the count has been printed on the console. What about the file?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，计数已经打印在控制台上了。文件呢？
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Awesome! By using the `io.Pipe()` adapter provided in the Go native library,
    we have uncoupled our counter from its output, and we have adapted a `Writer`
    interface to a `Reader` one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过使用Go原生库中提供的`io.Pipe()`适配器，我们已经将计数器与其输出解耦，并将`Writer`接口适配到`Reader`接口。
- en: What the Go source code tells us about the Adapter pattern
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go源代码告诉我们关于适配器模式的信息
- en: With the Adapter design pattern, you have learned a quick way to achieve the
    open/close principle in your applications. Instead of modifying your old source
    code (something which could not be possible in some situations), you have created
    a way to use the old functionality with a new signature.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器设计模式，你已经学会了一种快速实现应用程序中开闭原则的方法。而不是修改你的旧源代码（在某些情况下可能不可能做到），你创建了一种使用旧功能以新签名的方式。
- en: Bridge design pattern
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接设计模式
- en: 'The **Bridge** pattern is a design with a slightly cryptic definition from
    the original *Gang of Four* book. It decouples an abstraction from its implementation
    so that the two can vary independently. This cryptic explanation just means that
    you could even decouple the most basic form of functionality: decouple an object
    from what it does.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**桥接**模式是从原始的《设计模式：可复用面向对象软件的基础》书中来的一个定义稍显晦涩的设计。它将抽象与其实现解耦，以便两者可以独立变化。这种晦涩的解释只是意味着你甚至可以解耦最基本的功能形式：将对象与其所执行的事情解耦。'
- en: Description
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Bridge pattern tries to decouple things as usual with design patterns. It
    decouples abstraction (an object) from its implementation (the thing that the
    object does). This way, we can change what an object does as much as we want.
    It also allows us to change the abstracted object while reusing the same implementation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式试图像通常的设计模式一样解耦事物。它将抽象（一个对象）与其实现（对象所执行的事情）解耦。这样，我们可以根据需要尽可能多地改变对象的行为。它还允许我们在重用相同实现的同时改变抽象对象。
- en: Objectives
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: The objective of the Bridge pattern is to bring flexibility to a struct that
    change often. Knowing the inputs and outputs of a method, it allows us to change
    code without knowing too much about it and leaving the freedom for both sides
    to be modified more easily.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式的目标是为经常变化的结构提供灵活性。了解方法输入和输出，它允许我们在不了解太多的情况下更改代码，并为双方提供更容易修改的自由。
- en: Two printers and two ways of printing for each
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两个打印机和每种打印方式
- en: For our example, we will go to a console printer abstraction to keep it simple.
    We will have two implementations. The first will write to the console. Having
    learned about the `io.Writer` interface in the previous section, we will make
    the second write to an `io.Writer` interface to provide more flexibility to the
    solution. We will also have two abstracted object users of the implementations--a
    `Normal` object, which will use each implementation in a straightforward manner,
    and a `Packt` implementation, which will append the sentence `Message from Packt:`
    to the printing message.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用控制台打印抽象来保持简单。我们将有两个实现。第一个将写入控制台。在上一节学习了`io.Writer`接口后，我们将使第二个实现写入`io.Writer`接口，以提供更多灵活性。我们还将有两个使用这些实现的抽象对象用户--一个`Normal`对象，它将以直接的方式使用每个实现，以及一个`Packt`实现，它将在打印消息中附加句子`Message
    from Packt:`。
- en: At the end of this section, we will have two abstraction objects, which have
    two different implementations of their functionality. So, actually, we will have
    2² possible combinations of object functionality.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的结尾，我们将有两个抽象对象，它们具有其功能的不同实现。所以，实际上，我们将有2²种可能的组合对象功能。
- en: Requirements and acceptance criteria
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'As we mentioned previously, we will have two objects (`Packt` and `Normal`
    printer) and two implementations (`PrinterImpl1` and `PrinterImpl2`) that we will
    join by using the Bridge design pattern. More or less, we will have the following
    requirements and acceptance criteria:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: A `PrinterAPI` that accepts a message to print
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the API that simply prints the message to the console
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the API that prints to an `io.Writer` interface
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Printer` abstraction with a `Print` method to implement in printing types
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `normal` printer object, which will implement the `Printer` and the `PrinterAPI`
    interface
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `normal` printer will forward the message directly to the implementation
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Packt` printer, which will implement the `Printer` abstraction and the `PrinterAPI`
    interface
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Packt` printer will append the message `Message from Packt:` to all prints
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing the Bridge pattern
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with *acceptance criteria 1*, the `PrinterAPI` interface. Implementers
    of this interface must provide a `PrintMessage(string)` method that will print
    the message passed as an argument:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will pass to *acceptance criteria 2* with an implementation of the previous
    API:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our `PrinterImpl1` is a type that implements the `PrinterAPI` interface by
    providing an implementation of the `PrintMessage` method. The `PrintMessage` method
    is not implemented yet, and returns an error. This is enough to write our first
    unit test to cover `PrinterImpl1`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In our test to cover `PrintAPI1`, we created an instance of `PrinterImpl1`
    type. Then we used its `PrintMessage` method to print the message `Hello` to the
    console. As we have no implementation yet, it must return the error srring `Not
    implemented yet`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Okay. Now we have to write the second API test that will work with an `io.Writer`
    interface:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, our `PrinterImpl2` struct stores an `io.Writer` implementer.
    Also, our `PrintMessage` method follows the `PrinterAPI` interface.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are familiar with the `io.Writer` interface, we are going to make
    a test object that implements this interface, and stores whatever is written to
    it in a local field. This will help us check the contents that are being sent
    through the writer:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In our test object, we checked that the content isn''t empty before writing
    it to the local field. If it''s empty, we return the error, and if not, we write
    the contents of `p` in the `Msg` field. We will use this small struct in the following
    tests for the second API:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s stop for a second here. We create an instance of `PrinterImpl2` called
    `api2` in the first line of the preceding code. We haven''t passed any instance
    of `io.Writer` on purpose, so we also checked that we actually receive an error
    first. Then we try to use its `PrintMessage` method, but we must get an error
    because it doesn''t have any `io.Writer` instance stored in the `Writer` field.
    The error must be `You need to pass an io.Writer to PrinterImpl2`, and we implicitly
    check the contents of the error. Let''s continue with the test:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For the second part of this unit test, we use an instance of the `TestWriter`
    object as an `io.Writer` interface, `testWriter`. We passed the message `Hello`
    to `api2`, and checked whether we receive any error. Then, we check the contents
    of the `testWriter.Msg` field--remember that we have written an `io.Writer` interface
    that stored any bytes passed to its `Write` method in the `Msg` field. If everything
    is correct, the message should contain the word `Hello`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Those were our tests for `PrinterImpl2`. As we don''t have any implementations
    yet, we should get a few errors when running this test:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: At least one test passes--the one that checks that an error message (any) is
    being returned when using the `PrintMessage` without `io.Writer` being stored.
    Everything else fails, as expected at this stage.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a printer abstraction for objects that can use `PrinterAPI` implementers.
    We will define this as the `PrinterAbstraction` interface with a `Print` method.
    This covers the *acceptance criteria 4*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For *acceptance criteria 5*, we need a normal printer. A `Printer` abstraction
    will need a field to store a `PrinterAPI`. So our the `NormalPrinter` could look
    like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is enough to write a unit test for the `Print()` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first part of the test checks that the `Print()` method isn't implemented
    yet when using `PrinterImpl1 PrinterAPI` interface. The message we'll use along
    this test is `Hello io.Writer`. With the `PrinterImpl1,` we don't have an easy
    way to check the contents of the message, as we print directly to the console.
    Checking, in this case, is visual, so we can check *acceptance criteria 6:*
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The second part of `NormalPrinter` tests uses `PrinterImpl2`, the one that needs
    an `io.Writer` interface implementer. We reuse our `TestWriter` struct here to
    check the contents of the message. So, in short, we want a `NormalPrinter` struct
    that accepts a `Msg` of type string and a Printer of type `PrinterAPI`. At this
    point, if I use the `Print` method, I shouldn't get any error, and the `Msg` field
    on `TestWriter` must contain the message we passed to `NormalPrinter` on its initialization.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the tests:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There is a trick to quickly check the validity of a unit test--the number of
    times we called `t.Error` or `t.Errorf` must match the number of messages of error
    on the console and the lines where they were produced. In the preceding test results,
    there are three errors at *lines 72*, *85*, and *89*, which exactly match the
    checks we wrote.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PacktPrinter` struct will have a very similar definition to `NormalPrinter`
    at this point:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This covers *acceptance criteria 7*. And we can almost copy and paste the contents
    of the previous test with a few changes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What have we changed here? Now we have `passedMessage`, which represents the
    message we are passing to `PackPrinter`. We also have an expected message that
    contains the prefixed message from `Packt`. If you remember *acceptance criteria
    8*, this abstraction must prefix the text `Message from Packt:` to any message
    that is passed to it, and, at the same time, it must be able to use any implementation
    of a `PrinterAPI` interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The second change is that we actually create `PacktPrinter` structs instead
    of the `NormalPrinter` structs; everything else is the same:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Three checks, three errors. All tests have been covered, and we can finally
    move on to the implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start implementing in the same order that we created our tests, first
    with the `PrinterImpl1` definition:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Our first API takes the message `msg` and prints it to the console. In the
    case of an empty string, nothing will be printed. This is enough to pass the first
    test:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can see the `Hello` message in the second line of the output of the test,
    just after the `RUN` message.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PrinterImpl2` struct isn''t very complex either. The difference is that
    instead of printing to the console, we are going to write on an `io.Writer` interface,
    which must be stored in the struct:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As defined in our tests, we checked the contents of the `Writer` field first
    and returned the expected error message `**You need to pass an io.Writer to PrinterImpl2**`
    , if nothing is stored. This is the message we''ll check later in the test. Then,
    the `fmt.Fprintf` method takes an `io.Writer` interface as the first field and
    a message formatted as the rest, so we simply forward the contents of the `msg`
    argument to the `io.Writer` provided:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we''ll continue with the normal printer. This printer must simply forward
    the message to the `PrinterAPI` interface stored without any modification. In
    our test, we are using two implementations of `PrinterAPI`--one that prints to
    the console and one that writes to an `io.Writer` interface:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We returned nil as no error has occurred. This should be enough to pass the
    unit tests:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding output, you can see the `Hello io.Writer` message that the `PrinterImpl1` struct
    writes to `stdout`. We can consider this check as having passed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `PackPrinter` method is similar to `NormalPrinter`, but just prefixes
    every message with the text `Message from Packt:` :'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Like in the `NormalPrinter` method, we accepted a `Msg` string and a `PrinterAPI`
    implementation in the `Printer` field. Then we used the `fmt.Sprintf` method to
    compose a new string with the text `Message from Packt:` and the provided message.
    We took the composed text and passed it to the `PrintMessage` method of `PrinterAPI`
    stored in the `Printer` field of the `PacktPrinter` struct:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Again, you can see the results of using `PrinterImpl1` for writing to `stdout`
    with the text `Message from Packt: Hello io.Writer`. This last test should cover
    all of our code in the Bridge pattern. As you have seen previously, you can check
    the coverage by using the `-cover` flag:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Wow! 100% coverage-this looks good. However, this doesn't mean that the code
    is perfect. We haven't checked that the contents of the messages weren't empty,
    maybe something that should be avoided, but it isn't a part of our requirements,
    which is also an important point. Just because some feature isn't in the requirements
    or the acceptance criteria doesn't mean that it shouldn't be covered.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Reuse everything with the Bridge pattern
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Bridge pattern, we have learned how to uncouple an object and its implementation
    for the `PrintMessage` method. This way, we can reuse its abstractions as well
    as its implementations. We can swap the printer abstractions as well as the printer
    APIs as much as we want without affecting the user code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We have also tried to keep things as simple as possible, but I'm sure that you
    have realized that all implementations of the `PrinterAPI` interface could have
    been created using a factory. This would be very natural, and you could find many
    implementations that have followed this approach. However, we shouldn't get into
    over-engineering, but should analyze each problem to make a precise design of
    its needs and finds the best way to create a reusable, maintainable, and *readable*
    source code. Readable code is commonly forgotten, but a robust and uncoupled source
    code is useless if nobody can understand it to maintain it. It's like a book of
    the tenth century--it could be a precious story but pretty frustrating if we have
    difficulty understanding its grammar.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the power of composition in this chapter and many of the ways that
    Go takes advantage of it by its own nature. We have seen that the Adapter pattern
    can help us make two incompatible interfaces work together by using an `Adapter`
    object in between. At the same time, we have seen some real-life examples in Go's
    source code, where the creators of the language used this design pattern to improve
    the possibilities of some particular piece of the standard library. Finally, we
    have seen the Bridge pattern and its possibilities, allowing us to create swapping
    structures with complete reusability between objects and their implementations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have used the Composite design pattern throughout the chapter, not
    only when explaining it. We have mentioned it earlier but design patterns make
    use of each other very frequently. We have used pure composition instead of embedding
    to increase readability, but, as you have learned, you can use both interchangeably
    according to your needs. We will keep using the Composite pattern in the following
    chapters, as it is the foundation for building relationships in the Go programming
    language.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在整章中使用了组合设计模式，不仅是在解释它的时候。我们之前也提到过，设计模式之间经常相互使用。我们使用纯组合而非内嵌来提高可读性，但正如你所学的，你可以根据需要相互交替使用。在接下来的章节中，我们将继续使用组合模式，因为它是构建
    Go 编程语言中关系的基础。
