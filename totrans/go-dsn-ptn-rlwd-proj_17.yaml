- en: Chapter 3. Structural Patterns - Composite, Adapter, and Bridge Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start our journey through the world of structural patterns.
    Structural patterns, as the name implies, help us to shape our applications with
    commonly used structures and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: The Go language, by nature, encourages use of composition almost exclusively
    by its lack of inheritance. Because of this, we have been using the **Composite**
    design pattern extensively until now, so let's start by defining the Composite
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Composite design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Composite design pattern favors composition (commonly defined as a *has
    a* relationship) over inheritance (an *is a* relationship). The c*omposition over
    inheritance* approach has been a source of discussions among engineers since the
    nineties. We will learn how to create object structures by using a *has a* approach.
    All in all, Go doesn't have inheritance because it doesn't need it!
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Composite design pattern, you will create hierarchies and trees of objects.
    Objects have different objects with their own fields and methods inside them.
    This approach is very powerful and solves many problems of inheritance and multiple
    inheritances. For example, a typical inheritance problem is when you have an entity
    that inherits from two completely different classes, which have absolutely no
    relationship between them. Imagine an athlete who trains, and who is a swimmer who
    swims:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Athlete` class has a `Train()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Swimmer` class has a `Swim()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Swimmer` class inherits from the `Athlete` class, so it inherits its `Train`
    method and declares its own `Swim` method. You could also have a cyclist who is
    also an athlete, and declares a `Ride` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now imagine an animal that eats, like a dog that also barks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cyclist` class has a `Ride()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Animal` class has `Eat()`, `Dog()`, and `Bark()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing fancy. You could also have a fish that is an animal, and yes, swims!
    So, how do you solve it? A fish cannot be a swimmer that also trains. Fish don't
    train (as far as I know!). You could make a `Swimmer` interface with a `Swim`
    method, and make the swimmer athlete and fish implement it. This would be the
    best approach, but you still would have to implement `swim` method twice, so code
    reusability would be affected. What about a triathlete? They are athletes who
    swim, run, and ride. With multiple inheritances, you could have a sort of solution,
    but that will become complex and not maintainable very soon.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have probably imagined already, the objective of the composition is to
    avoid this type of hierarchy hell where the complexity of an application could
    grow too much, and the clarity of the code is affected.
  prefs: []
  type: TYPE_NORMAL
- en: The swimmer and the fish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will solve the described problem of the athlete and the fish that swims in
    a very idiomatic Go way. With Go, we can use two types of composition--the **direct**
    composition and the **embedding** composition. We will first solve this problem
    by using direct composition which is having everything that is needed as fields
    within the struct.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Requirements are like the ones described previously. We''ll have an athlete
    and a swimmer. We will also have an animal and a fish. The `Swimmer` and the `Fish` methods
    must share the code. The athlete must train, and the animal must eat:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have an `Athlete` struct with a `Train` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a `Swimmer` with a `Swim` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have an `Animal` struct with an `Eat` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a `Fish` struct with a `Swim` method that is shared with the `Swimmer`,
    and not have inheritance or hierarchy issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating compositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Composite design pattern is a pure structural pattern, and it doesn't have
    much to test apart from the structure itself. We won't write unit tests in this
    case, and we'll simply describe the ways to create those compositions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll start with the `Athlete` structure and its `Train` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is pretty straightforward. Its `Train` method prints the
    word `Training` and a new line. We''ll create a composite swimmer that has an
    `Athlete` struct inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CompositeSwimmerA` type has a `MyAthlete` field of type `Athlete`. It
    also stores a `func()` type. Remember that in Go, functions are first-class citizens
    and they can be used as parameters, fields, or arguments just like any variable.
    So `CompositeSwimmerA` has a `MySwim` field that stores a **closure**, which takes
    no arguments and returns nothing. How can I assign a function to it? Well, let''s
    create a function that matches the `func()` signature (no arguments, no return):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! The `Swim()` function takes no arguments and returns nothing,
    so it can be used as the `MySwim` field in the `CompositeSwimmerA` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because we have a function called `Swim()`, we can assign it to the `MySwim`
    field. Note that the `Swim` type doesn't have the parenthesis that will execute
    its contents. This way we take the entire function and copy it to `MySwim` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait. We haven''t passed any athlete to the `MyAthlete` field and we are
    using it! It''s going to fail! Let''s see what happens when we execute this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s weird, isn''t it? Not really because of the nature of zero-initialization
    in Go. If you don''t pass an `Athlete` struct to the `CompositeSwimmerA` type,
    the compiler will create one with its values zero-initialized, that is, an `Athlete`
    struct with its fields initialized to zero. Check out [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!* to recall zero-initialization
    if this seems confusing. Consider the `CompositeSwimmerA` struct code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a pointer to a function stored in the `MySwim` field. We can assign
    the `Swim` function the same way, but with an extra step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we need a variable that contains the function `Swim`. This is because
    a function doesn't have an address to pass it to the `CompositeSwimmerA` type.
    Then, to use this function within the struct, we have to make a two-step call.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about our fish problem? With our `Swim` function, it is not a problem
    anymore. First, we create the `Animal` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll create a `Shark` object that embeds the `Animal` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a second! Where is the field name of the `Animal` type? Did you realize
    that I used the word *embed* in the previous paragraph? This is because, in Go,
    you can also embed objects within objects to make it look a lot like inheritance.
    That is, we won''t have to explicitly call the field name to have access to its
    fields and method because they''ll be part of us. So the following code will be
    perfectly okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an `Animal` type, which is zero-initialized and embedded. This
    is why I can call the `Eat` method of the `Animal` struct without creating it
    or using the intermediate field name. The output of this snippet is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a third method to use the Composite pattern. We could create
    a `Swimmer` interface with a `Swim` method and a `SwimmerImpl` type to embed it
    in the athlete swimmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, you have more explicit control over object creation. The
    `Swimmer` field is embedded, but won''t be zero-initialized as it is a pointer
    to an interface. The correct use of this approach will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output for `CompositeSwimmerB` is the following, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Which approach is better? Well, I have a personal preference, which shouldn't
    be considered the rule of thumb. In my opinion, the *interfaces* approach is the
    best for quite a few reasons, but mainly for explicitness. First of all, you are
    working with interfaces  which are preferred instead of structs. Second, you aren't
    leaving parts of your code to the zero-initialization feature of the compiler.
    It's a really powerful feature, but one that must be used with care, because it
    can lead to runtime problems which you'll find at compile time when working with
    interfaces. In different situations, zero-initialization will save you at runtime,
    in fact! But I prefer to work with interfaces as much as possible, so this is
    not actually one of the options.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Tree compositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another very common approach to the Composite pattern is when working with
    Binary Tree structures. In a Binary Tree, you need to store instances of itself
    in a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is some kind of recursive compositing, and, because of the nature of recursivity,
    we must use pointers so that the compiler knows how much memory it must reserve
    for this struct. Our `Tree` struct stored a `LeafValue` object for each instance
    and a new `Tree` in its `Right` and `Left` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this structure, we could create an object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the contents of its deepest branch like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Composite pattern versus inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the Composite design pattern in Go, you must be very careful not
    to confuse it with inheritance. For example, when you embed a `Parent` struct
    within a `Son` struct, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot consider that the `Son` struct is also the `Parent` struct. What
    this means is that you cannot pass an instance of the `Son` struct to a function
    that is expecting a `Parent` struct like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you try to pass a `Son` instance to the `GetParentField` method, you will
    get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This, in fact, makes a lot of sense. What''s the solution for this? Well, you
    can simply composite the `Son`  struct with the parent without embedding so that
    you can access the `Parent` instance later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So now you could use the `P` field to pass it to the `GetParentField` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Final words on the Composite pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you should be really comfortable using the Composite design pattern.
    It's a very idiomatic Go feature, and the switch from a pure object-oriented language
    is not very painful. The Composite design pattern makes our structures predictable
    but also allows us to create most of the design patterns as we will see in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most commonly used structural patterns is the **Adapter** pattern.
    Like in real life, where you have plug adapters and bolt adapters, in Go, an adapter
    will allow us to use something that wasn't built for a specific task at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Adapter pattern is very useful when, for example, an interface gets outdated
    and it's not possible to replace it easily or fast. Instead, you create a new
    interface to deal with the current needs of your application, which, under the
    hood, uses implementations of the old interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter also helps us to maintain the *open/closed principle* in our apps, making
    them more predictable too. They also allow us to write code which uses some base
    that we can't modify.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The open/closed principle was first stated by Bertrand Meyer in his book *Object-Oriented
    Software Construction*. He stated that code should be open to new functionality,
    but closed to modifications. What does it mean? Well, it implies a few things.
    On one hand, we should try to write code that is extensible and not only one that
    works. At the same time, we should try not to modify the source code (yours or
    other people's) as much as we can, because we aren't always aware of the implications
    of this modification. Just keep in mind that extensibility in code is only possible
    through the use of design patterns and interface-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Adapter design pattern will help you fit the needs of two parts of the code
    that are incompatible at first. This is the key to being kept in mind when deciding
    if the Adapter pattern is a good design for your problem--two interfaces that
    are incompatible, but which must work together, are good candidates for an Adapter
    pattern (but they could also use the facade pattern, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Using an incompatible interface with an Adapter object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example, we will have an old `Printer` interface and a new one. Users
    of the new interface don't expect the signature that the old one has, and we need
    an Adapter so that users can still use old implementations if necessary (to work
    with some legacy code, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having an old interface called `LegacyPrinter` and a new one called `ModernPrinter`,
    create a structure that implements the `ModernPrinter` interface and can use the
    `LegacyPrinter` interface as described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Adapter object that implements the `ModernPrinter` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new Adapter object must contain an instance of the `LegacyPrinter` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using `ModernPrinter`, it must call the `LegacyPrinter` interface under
    the hood, prefixing it with the text `Adapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit testing our Printer adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write the legacy code first, but we won''t test it as we should imagine
    that it isn''t our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The legacy interface called `LegacyPrinter` has a `Print` method that accepts
    a string and returns a message. Our `MyLegacyPrinter` struct implements the `LegacyPrinter` interface
    and modifies the passed string by prefixing the text `Legacy Printer:`. After
    modifying the text, the `MyLegacyPrinter` struct prints the text on the console,
    and then returns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll declare the new interface that we''ll have to adapt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the new `PrintStored` method doesn''t accept any string as an
    argument, because it will have to be stored in the implementers in advance. We
    will call our Adapter pattern''s `PrinterAdapter` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, the `PrinterAdapter` adapter must have a field to store
    the string to print. It must also have a field to store an instance of the `LegacyPrinter`
    adapter. So let''s write the unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the message `Hello World!` for our adapter. When using this message
    with an instance of the `MyLegacyPrinter` struct, it prints the text `Legacy Printer:
    Hello World!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We created an instance of the `PrinterAdapter` interface called `adapter`.
    We passed an instance of the `MyLegacyPrinter` struct as the `LegacyPrinter` field
    called `OldPrinter`. Also, we set the message we want to print in the `Msg` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we used the `PrintStored` method of the `ModernPrinter` interface; this
    method doesn''t accept any argument and must return the modified string. We know
    that the `MyLegacyPrinter` struct returns the passed string prefixed with the
    text `LegacyPrinter:`, and the adapter will prefix it with the text `Adapter:`
    So, in the end, we must have the text `Legacy Printer: Adapter: Hello World!\n`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are storing an instance of an interface, we must also check that we handle
    the situation where the pointer is nil. This is done with the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t pass an instance of the `LegacyPrinter` interface, the Adapter
    must ignore its adapt nature, and simply print and return the original message.
    Time to run our tests; consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make our single test pass, we must reuse the old `MyLegacyPrinter` that
    is stored in `PrinterAdapter` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `PrintStored` method, we check whether we actually have an instance of
    a `LegacyPrinter`. In this case, we compose a new string with the stored message
    and the `Adapter` prefix to store it in the returning variable (called `newMsg`).
    Then we use the pointer to the `MyLegacyPrinter` struct to print the composed
    message using the `LegacyPrinter` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case there is no `LegacyPrinter` instance stored in the `OldPrinter` field,
    we simply assign the stored message to the returning variable `newMsg` and return
    the method. This should be enough to pass our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now we can still use the old `LegacyPrinter` interface by using this
    `Adapter` while we use the `ModernPrinter` interface for future implementations.
    Just keep in mind that the Adapter pattern must ideally just provide the way to
    use the old `LegacyPrinter` and nothing else. This way, its scope will be more
    encapsulated and more maintainable in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the Adapter pattern in Go's source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find Adapter implementations at many places in the Go language''s source
    code. The famous `http.Handler` interface has a very interesting adapter implementation.
    A very simple, `Hello World` server in Go is usually done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP package has a function called `Handle` (like a `static` method in
    Java) that accepts two parameters--a string to represent the route and a `Handler`
    interface. The `Handler` interface is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to implement a `ServeHTTP` method that the server side of an HTTP connection
    will use to execute its context. But there is also a function `HandlerFunc` that
    allows you to define some endpoint behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `HandleFunc` function is actually part of an adapter for using functions
    directly as `ServeHTTP` implementations. Read the last sentence slowly again--can
    you guess how it is done?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can define a type that is a function in the same way that we define a struct.
    We make this function-type to implement the `ServeHTTP` method. Finally, from
    the `ServeHTTP` function, we call the receiver itself `f(w, r)`.
  prefs: []
  type: TYPE_NORMAL
- en: You have to think about the implicit interface implementation of Go. When we
    define a function like `func(ResponseWriter, *Request)`, it is implicitly being
    recognized as `HandlerFunc`. And because the `HandleFunc` function implements
    the `Handler` interface, our function implements the `Handler` interface implicitly
    too. Does this sound familiar to you? If *A = B* and *B = C*, then *A = C*. Implicit
    implementation gives a lot of flexibility and power to Go, but you must also be
    careful, because you don't know if a method or function could be implementing
    some interface that could provoke undesirable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find more examples in Go''s source code. The `io` package has another
    powerful example with the use of pipes. A pipe in Linux is a flow mechanism that
    takes something on the input and outputs something else on the output. The `io`
    package has two interfaces, which are used everywhere in Go''s source code--the `io.Reader`
    and the `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `io.Reader` everywhere, for example, when you open a file using `os.OpenFile`,
    it returns a file, which, in fact, implements the `io.Reader` interface. Why is
    it useful? Imagine that you write a `Counter` struct that counts from the number
    you provide to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you provide the number 3 to this small snippet, it will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, not really impressive! What if I want to write to a file instead of printing?
    We can implement this method too. What if I want to print to a file and to the
    console? Well, we can implement this method too. We must modularize it a bit more
    by using the `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now we provide an `io.Writer` in the `Writer` field. This way, we could create
    the counter like this: `c := Counter{os.Stdout}`, and we will get a console `Writer`.
    But wait a second, we haven't solved the issue where we wanted to take the count
    to many `Writer` consoles. But we can write a new `Adapter` with an `io.Writer`
    and, using a `Pipe()` to connect a reader with a writer, we can read on the opposite
    extreme. This way, you can solve the issue where these two interfaces, `Reader`
    and `Writer`, which are incompatible, can be used together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we don''t need to write the Adapter--the Go''s `io` library has one
    for us in `io.Pipe()`. The pipe will allow us to convert a `Reader` to a `Writer`
    interface. The `io.Pipe()` method will provide us a `Writer` (the entrance of
    the pipe) and a `Reader` (the exit) to play with. So let''s create a pipe, and
    assign the provided writer to the `Counter` of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `Reader` interface where we previously had a `Writer`. Where can
    we use the `Reader`? The `io.TeeReader` function helps us to copy the stream of
    data from a `Reader` interface to the `Writer` interface and, it returns a new
    `Reader` that you can still use to stream data again to a second writer. So we
    will stream the data from the same reader to two writers--the `file` and the `Stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we know that we are writing to a file that we have passed to the `TeeReader`
    function. We still need to print to the console. The `io.Copy` adapter can be
    used like `TeeReader`--it takes a reader and writes its contents to a writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to launch the `Copy` function in a different Go routine so that the
    writes are performed concurrently, and one read/write doesn''t block a different
    read/write. Let''s modify the `counter` variable to make it count till 5 again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this modification to the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Okay, the count has been printed on the console. What about the file?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! By using the `io.Pipe()` adapter provided in the Go native library,
    we have uncoupled our counter from its output, and we have adapted a `Writer`
    interface to a `Reader` one.
  prefs: []
  type: TYPE_NORMAL
- en: What the Go source code tells us about the Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Adapter design pattern, you have learned a quick way to achieve the
    open/close principle in your applications. Instead of modifying your old source
    code (something which could not be possible in some situations), you have created
    a way to use the old functionality with a new signature.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Bridge** pattern is a design with a slightly cryptic definition from
    the original *Gang of Four* book. It decouples an abstraction from its implementation
    so that the two can vary independently. This cryptic explanation just means that
    you could even decouple the most basic form of functionality: decouple an object
    from what it does.'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bridge pattern tries to decouple things as usual with design patterns. It
    decouples abstraction (an object) from its implementation (the thing that the
    object does). This way, we can change what an object does as much as we want.
    It also allows us to change the abstracted object while reusing the same implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The objective of the Bridge pattern is to bring flexibility to a struct that
    change often. Knowing the inputs and outputs of a method, it allows us to change
    code without knowing too much about it and leaving the freedom for both sides
    to be modified more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Two printers and two ways of printing for each
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example, we will go to a console printer abstraction to keep it simple.
    We will have two implementations. The first will write to the console. Having
    learned about the `io.Writer` interface in the previous section, we will make
    the second write to an `io.Writer` interface to provide more flexibility to the
    solution. We will also have two abstracted object users of the implementations--a
    `Normal` object, which will use each implementation in a straightforward manner,
    and a `Packt` implementation, which will append the sentence `Message from Packt:`
    to the printing message.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this section, we will have two abstraction objects, which have
    two different implementations of their functionality. So, actually, we will have
    2² possible combinations of object functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, we will have two objects (`Packt` and `Normal`
    printer) and two implementations (`PrinterImpl1` and `PrinterImpl2`) that we will
    join by using the Bridge design pattern. More or less, we will have the following
    requirements and acceptance criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: A `PrinterAPI` that accepts a message to print
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the API that simply prints the message to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the API that prints to an `io.Writer` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Printer` abstraction with a `Print` method to implement in printing types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `normal` printer object, which will implement the `Printer` and the `PrinterAPI`
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `normal` printer will forward the message directly to the implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Packt` printer, which will implement the `Printer` abstraction and the `PrinterAPI`
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Packt` printer will append the message `Message from Packt:` to all prints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing the Bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with *acceptance criteria 1*, the `PrinterAPI` interface. Implementers
    of this interface must provide a `PrintMessage(string)` method that will print
    the message passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will pass to *acceptance criteria 2* with an implementation of the previous
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `PrinterImpl1` is a type that implements the `PrinterAPI` interface by
    providing an implementation of the `PrintMessage` method. The `PrintMessage` method
    is not implemented yet, and returns an error. This is enough to write our first
    unit test to cover `PrinterImpl1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test to cover `PrintAPI1`, we created an instance of `PrinterImpl1`
    type. Then we used its `PrintMessage` method to print the message `Hello` to the
    console. As we have no implementation yet, it must return the error srring `Not
    implemented yet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. Now we have to write the second API test that will work with an `io.Writer`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `PrinterImpl2` struct stores an `io.Writer` implementer.
    Also, our `PrintMessage` method follows the `PrinterAPI` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are familiar with the `io.Writer` interface, we are going to make
    a test object that implements this interface, and stores whatever is written to
    it in a local field. This will help us check the contents that are being sent
    through the writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test object, we checked that the content isn''t empty before writing
    it to the local field. If it''s empty, we return the error, and if not, we write
    the contents of `p` in the `Msg` field. We will use this small struct in the following
    tests for the second API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s stop for a second here. We create an instance of `PrinterImpl2` called
    `api2` in the first line of the preceding code. We haven''t passed any instance
    of `io.Writer` on purpose, so we also checked that we actually receive an error
    first. Then we try to use its `PrintMessage` method, but we must get an error
    because it doesn''t have any `io.Writer` instance stored in the `Writer` field.
    The error must be `You need to pass an io.Writer to PrinterImpl2`, and we implicitly
    check the contents of the error. Let''s continue with the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For the second part of this unit test, we use an instance of the `TestWriter`
    object as an `io.Writer` interface, `testWriter`. We passed the message `Hello`
    to `api2`, and checked whether we receive any error. Then, we check the contents
    of the `testWriter.Msg` field--remember that we have written an `io.Writer` interface
    that stored any bytes passed to its `Write` method in the `Msg` field. If everything
    is correct, the message should contain the word `Hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those were our tests for `PrinterImpl2`. As we don''t have any implementations
    yet, we should get a few errors when running this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: At least one test passes--the one that checks that an error message (any) is
    being returned when using the `PrintMessage` without `io.Writer` being stored.
    Everything else fails, as expected at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a printer abstraction for objects that can use `PrinterAPI` implementers.
    We will define this as the `PrinterAbstraction` interface with a `Print` method.
    This covers the *acceptance criteria 4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For *acceptance criteria 5*, we need a normal printer. A `Printer` abstraction
    will need a field to store a `PrinterAPI`. So our the `NormalPrinter` could look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to write a unit test for the `Print()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the test checks that the `Print()` method isn't implemented
    yet when using `PrinterImpl1 PrinterAPI` interface. The message we'll use along
    this test is `Hello io.Writer`. With the `PrinterImpl1,` we don't have an easy
    way to check the contents of the message, as we print directly to the console.
    Checking, in this case, is visual, so we can check *acceptance criteria 6:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The second part of `NormalPrinter` tests uses `PrinterImpl2`, the one that needs
    an `io.Writer` interface implementer. We reuse our `TestWriter` struct here to
    check the contents of the message. So, in short, we want a `NormalPrinter` struct
    that accepts a `Msg` of type string and a Printer of type `PrinterAPI`. At this
    point, if I use the `Print` method, I shouldn't get any error, and the `Msg` field
    on `TestWriter` must contain the message we passed to `NormalPrinter` on its initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There is a trick to quickly check the validity of a unit test--the number of
    times we called `t.Error` or `t.Errorf` must match the number of messages of error
    on the console and the lines where they were produced. In the preceding test results,
    there are three errors at *lines 72*, *85*, and *89*, which exactly match the
    checks we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PacktPrinter` struct will have a very similar definition to `NormalPrinter`
    at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This covers *acceptance criteria 7*. And we can almost copy and paste the contents
    of the previous test with a few changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: What have we changed here? Now we have `passedMessage`, which represents the
    message we are passing to `PackPrinter`. We also have an expected message that
    contains the prefixed message from `Packt`. If you remember *acceptance criteria
    8*, this abstraction must prefix the text `Message from Packt:` to any message
    that is passed to it, and, at the same time, it must be able to use any implementation
    of a `PrinterAPI` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second change is that we actually create `PacktPrinter` structs instead
    of the `NormalPrinter` structs; everything else is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Three checks, three errors. All tests have been covered, and we can finally
    move on to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start implementing in the same order that we created our tests, first
    with the `PrinterImpl1` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first API takes the message `msg` and prints it to the console. In the
    case of an empty string, nothing will be printed. This is enough to pass the first
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `Hello` message in the second line of the output of the test,
    just after the `RUN` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PrinterImpl2` struct isn''t very complex either. The difference is that
    instead of printing to the console, we are going to write on an `io.Writer` interface,
    which must be stored in the struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As defined in our tests, we checked the contents of the `Writer` field first
    and returned the expected error message `**You need to pass an io.Writer to PrinterImpl2**`
    , if nothing is stored. This is the message we''ll check later in the test. Then,
    the `fmt.Fprintf` method takes an `io.Writer` interface as the first field and
    a message formatted as the rest, so we simply forward the contents of the `msg`
    argument to the `io.Writer` provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll continue with the normal printer. This printer must simply forward
    the message to the `PrinterAPI` interface stored without any modification. In
    our test, we are using two implementations of `PrinterAPI`--one that prints to
    the console and one that writes to an `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We returned nil as no error has occurred. This should be enough to pass the
    unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, you can see the `Hello io.Writer` message that the `PrinterImpl1` struct
    writes to `stdout`. We can consider this check as having passed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `PackPrinter` method is similar to `NormalPrinter`, but just prefixes
    every message with the text `Message from Packt:` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in the `NormalPrinter` method, we accepted a `Msg` string and a `PrinterAPI`
    implementation in the `Printer` field. Then we used the `fmt.Sprintf` method to
    compose a new string with the text `Message from Packt:` and the provided message.
    We took the composed text and passed it to the `PrintMessage` method of `PrinterAPI`
    stored in the `Printer` field of the `PacktPrinter` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can see the results of using `PrinterImpl1` for writing to `stdout`
    with the text `Message from Packt: Hello io.Writer`. This last test should cover
    all of our code in the Bridge pattern. As you have seen previously, you can check
    the coverage by using the `-cover` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Wow! 100% coverage-this looks good. However, this doesn't mean that the code
    is perfect. We haven't checked that the contents of the messages weren't empty,
    maybe something that should be avoided, but it isn't a part of our requirements,
    which is also an important point. Just because some feature isn't in the requirements
    or the acceptance criteria doesn't mean that it shouldn't be covered.
  prefs: []
  type: TYPE_NORMAL
- en: Reuse everything with the Bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Bridge pattern, we have learned how to uncouple an object and its implementation
    for the `PrintMessage` method. This way, we can reuse its abstractions as well
    as its implementations. We can swap the printer abstractions as well as the printer
    APIs as much as we want without affecting the user code.
  prefs: []
  type: TYPE_NORMAL
- en: We have also tried to keep things as simple as possible, but I'm sure that you
    have realized that all implementations of the `PrinterAPI` interface could have
    been created using a factory. This would be very natural, and you could find many
    implementations that have followed this approach. However, we shouldn't get into
    over-engineering, but should analyze each problem to make a precise design of
    its needs and finds the best way to create a reusable, maintainable, and *readable*
    source code. Readable code is commonly forgotten, but a robust and uncoupled source
    code is useless if nobody can understand it to maintain it. It's like a book of
    the tenth century--it could be a precious story but pretty frustrating if we have
    difficulty understanding its grammar.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the power of composition in this chapter and many of the ways that
    Go takes advantage of it by its own nature. We have seen that the Adapter pattern
    can help us make two incompatible interfaces work together by using an `Adapter`
    object in between. At the same time, we have seen some real-life examples in Go's
    source code, where the creators of the language used this design pattern to improve
    the possibilities of some particular piece of the standard library. Finally, we
    have seen the Bridge pattern and its possibilities, allowing us to create swapping
    structures with complete reusability between objects and their implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have used the Composite design pattern throughout the chapter, not
    only when explaining it. We have mentioned it earlier but design patterns make
    use of each other very frequently. We have used pure composition instead of embedding
    to increase readability, but, as you have learned, you can use both interchangeably
    according to your needs. We will keep using the Composite pattern in the following
    chapters, as it is the foundation for building relationships in the Go programming
    language.
  prefs: []
  type: TYPE_NORMAL
