- en: Slice initialization
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片初始化
- en: A slice is represented by the type system as a value (the next section explores
    the internal representation of a slice). However, unlike the array type, an uninitialized
    slice has a zero value of *nil*, which means any attempt to access elements of
    an uninitialized slice will cause a program to panic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 切片在类型系统中表示为一个值（下一节将探讨切片的内部表示）。然而，与数组类型不同，未初始化的切片具有零值 *nil*，这意味着尝试访问未初始化切片的元素将导致程序崩溃。
- en: 'One of the simplest ways to initialize a slice is with a composite literal
    value using the following format (similar to an array):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化切片的最简单方法之一是使用复合字面量值，格式如下（类似于数组）：
- en: '*<slice_type>{<comma-separated list of element values>}*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*<slice_type>{<逗号分隔的元素值列表>}*'
- en: 'The literal value for a slice is composed of the slice type followed by a set
    of comma-separated values, enclosed in curly brackets, that are assigned to the
    elements of the slice. The following code snippet illustrates several slice variables
    initialized with composite literal values:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的字面量值由切片类型后跟一系列用逗号分隔的值组成，这些值被分配给切片的元素。以下代码片段展示了几个使用复合字面量值初始化的切片变量：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch07/sliceinit.go
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/sliceinit.go
- en: As mentioned, the composite literal value of a slice is expressed using a similar
    form as the array. However, the number of elements provided in the literal is
    not bounded by a fixed size. This implies that the literal can be as large as
    needed. Under the cover though, Go creates and manages an array of appropriate
    size to store the values expressed in the literal.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，切片的复合字面量值使用与数组类似的形式表示。然而，字面量中提供的元素数量不受固定大小的限制。这意味着字面量可以大如所需。然而，在幕后，Go 会创建并管理一个适当大小的数组来存储字面量中表达的所有值。
