["```go\ntype UserFinder interface { \n  FindUser(id int32) (User, error) \n} \n\n```", "```go\ntype User struct { \n  ID int32 \n} \n\n```", "```go\ntype UserList []User \n\n```", "```go\ntype UserListProxy struct { \n  SomeDatabase UserList \n  StackCache UserList \n  StackCapacity int \n  DidDidLastSearchUsedCache bool \n} \n\nfunc (u *UserListProxy) FindUser(id int32) (User, error) { \n  return User{}, errors.New(\"Not implemented yet\") \n} \n\n```", "```go\nimport ( \n   \"math/rand\" \n   \"testing\" \n) \n\nfunc Test_UserListProxy(t *testing.T) { \n  someDatabase := UserList{} \n\n  rand.Seed(2342342) \n  for i := 0; i < 1000000; i++ { \n    n := rand.Int31() \n    someDatabase = append(someDatabase, User{ID: n}) \n  } \n\n```", "```go\nproxy := UserListProxy{ \n  SomeDatabase:  &someDatabase, \n  StackCapacity:  2, \n  StackCache: UserList{}, \n} \n\n```", "```go\nknownIDs := [3]int32 {someDatabase[3].ID, someDatabase[4].ID,someDatabase[5].ID} \n\n```", "```go\nt.Run(\"FindUser - Empty cache\", func(t *testing.T) { \n  user, err := proxy.FindUser(knownIDs[0]) \n  if err != nil { \n    t.Fatal(err) \n  } \n\nFindUser - Empty cache. Then we define our closure. First it tries to find a user with a known ID, and checks for errors. As the description implies, the cache is empty at this point, and the user will have to be retrieved from the someDatabase array:\n```", "```go\n  if user.ID != knownIDs[0] { \n    t.Error(\"Returned user name doesn't match with expected\") \n  } \n\n  if len(proxy.StackCache) != 1 { \n    t.Error(\"After one successful search in an empty cache, the size of it must be one\") \n  } \n\n  if proxy.DidLastSearchUsedCache { \n    t.Error(\"No user can be returned from an empty cache\") \n  } \n} \n\n```", "```go\nt.Run(\"FindUser - One user, ask for the same user\", func(t *testing.T) { \n  user, err := proxy.FindUser(knownIDs[0]) \n  if err != nil { \n    t.Fatal(err) \n  } \n\n  if user.ID != knownIDs[0] { \n    t.Error(\"Returned user name doesn't match with expected\") \n  } \n\n  if len(proxy.StackCache) != 1 { \n    t.Error(\"Cache must not grow if we asked for an object that is stored on it\") \n  } \n\n  if !proxy.DidLastSearchUsedCache { \n    t.Error(\"The user should have been returned from the cache\") \n  } \n}) \n\n```", "```go\nuser1, err := proxy.FindUser(knownIDs[0]) \nif err != nil { \n  t.Fatal(err) \n} \n\nuser2, _ := proxy.FindUser(knownIDs[1]) \nif proxy.DidLastSearchUsedCache { \n  t.Error(\"The user wasn't stored on the proxy cache yet\") \n} \n\nuser3, _ := proxy.FindUser(knownIDs[2]) \nif proxy.DidLastSearchUsedCache { \n  t.Error(\"The user wasn't stored on the proxy cache yet\") \n} \n\n```", "```go\nfor i := 0; i < len(proxy.StackCache); i++ { \n  if proxy.StackCache[i].ID == user1.ID { \n    t.Error(\"User that should be gone was found\") \n  } \n} \n\nif len(proxy.StackCache) != 2 { \n  t.Error(\"After inserting 3 users the cache should not grow\" + \n\" more than to two\") \n} \n\n```", "```go\n  for _, v := range proxy.StackCache { \n    if v != user2 && v != user3 { \n      t.Error(\"A non expected user was found on the cache\") \n    } \n  } \n} \n\n```", "```go\n$ go test -v .\n=== RUN   Test_UserListProxy\n=== RUN   Test_UserListProxy/FindUser_-_Empty_cache\n=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user\n=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack\n--- FAIL: Test_UserListProxy (0.06s)\n --- FAIL: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)\n proxy_test.go:28: Not implemented yet\n --- FAIL: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)\n proxy_test.go:47: Not implemented yet\n --- FAIL: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)\n proxy_test.go:66: Not implemented yet\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype UserList []User \n\nfunc (t *UserList) FindUser(id int32) (User, error) { \n  for i := 0; i < len(*t); i++ { \n    if (*t)[i].ID == id { \n      return (*t)[i], nil \n    } \n  } \n  return User{}, fmt.Errorf(\"User %s could not be found\\n\", id) \n} \n\n```", "```go\nfunc (u *UserListProxy) FindUser(id int32) (User, error) { \n  user, err := u.StackCache.FindUser(id) \n  if err == nil { \n    fmt.Println(\"Returning user from cache\") \n    u.DidLastSearchUsedCache = true \n    return user, nil \n  } \n\n```", "```go\n  user, err = u.SomeDatabase.FindUser(id) \n  if err != nil { \n    return User{}, err \n  } \n\n```", "```go\nfunc (u *UserListProxy) addUserToStack(user User) { \n  if len(u.StackCache) >= u.StackCapacity { \n    u.StackCache = append(u.StackCache[1:], user) \n  } \n  else { \n    u.StackCache.addUser(user) \n  } \n} \n\nfunc (t *UserList) addUser(newUser User) { \n  *t = append(*t, newUser) \n} \n\n```", "```go\nu.addUserToStack(user) \n\n```", "```go\n  fmt.Println(\"Returning user from database\") \n  u.DidLastSearchUsedCache = false \n  return user, nil \n} \n\n```", "```go\n$ go test -v .\n=== RUN   Test_UserListProxy\n=== RUN   Test_UserListProxy/FindUser_-_Empty_cache\nReturning user from database\n=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user\nReturning user from cache\n=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack\nReturning user from cache\nReturning user from database\nReturning user from database\n--- PASS: Test_UserListProxy (0.09s) \n--- PASS: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)\n--- PASS: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)\n--- PASS: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)\nPASS\nok\n\n```", "```go\ntype IngredientAdd interface { \n  AddIngredient() (string, error) \n} \n\n```", "```go\ntype PizzaDecorator struct{ \n  Ingredient IngredientAdd \n} \n\nfunc (p *PizzaDecorator) AddIngredient() (string, error) { \n  return \"\", errors.New(\"Not implemented yet\") \n} \n\n```", "```go\ntype Meat struct { \n  Ingredient IngredientAdd \n} \n\nfunc (m *Meat) AddIngredient() (string, error) { \n  return \"\", errors.New(\"Not implemented yet\") \n} \n\n```", "```go\ntype Onion struct { \n  Ingredient IngredientAdd \n} \n\nfunc (o *Onion) AddIngredient() (string, error) { \n  return \"\", errors.New(\"Not implemented yet\") \n}  \n\n```", "```go\nfunc TestPizzaDecorator_AddIngredient(t *testing.T) { \n  pizza := &PizzaDecorator{} \n  pizzaResult, _ := pizza.AddIngredient() \n  expectedText := \"Pizza with the following ingredients:\" \n  if !strings.Contains(pizzaResult, expectedText) { \n    t.Errorf(\"When calling the add ingredient of the pizza decorator it must return the text %sthe expected text, not '%s'\", pizzaResult, expectedText) \n  } \n} \n\n```", "```go\n$ go test -v -run=TestPizzaDecorator .\n=== RUN   TestPizzaDecorator_AddIngredient\n--- FAIL: TestPizzaDecorator_AddIngredient (0.00s)\ndecorator_test.go:29: Not implemented yet\ndecorator_test.go:34: When the the AddIngredient method of the pizza decorator object is called, it must return the text\nPizza with the following ingredients:\nFAIL\nexit status 1\nFAIL \n\n```", "```go\nfunc TestOnion_AddIngredient(t *testing.T) { \n  onion := &Onion{} \n  onionResult, err := onion.AddIngredient() \n  if err == nil { \n    t.Errorf(\"When calling AddIngredient on the onion decorator without\" + \"an IngredientAdd on its Ingredient field must return an error, not a string with '%s'\", onionResult) \n  } \n\n```", "```go\n  onion = &Onion{&PizzaDecorator{}} \n  onionResult, err = onion.AddIngredient() \n\n  if err != nil { \n    t.Error(err) \n  } \n  if !strings.Contains(onionResult, \"onion\") { \n    t.Errorf(\"When calling the add ingredient of the onion decorator it\" + \"must return a text with the word 'onion', not '%s'\", onionResult) \n  } \n} \n\n```", "```go\n$ go test -v -run=TestOnion_AddIngredient .\n=== RUN   TestOnion_AddIngredient\n--- FAIL: TestOnion_AddIngredient (0.00s)\ndecorator_test.go:48: Not implemented yet\ndecorator_test.go:52: When calling the add ingredient of the onion decorator it must return a text with the word 'onion', not ''\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc TestMeat_AddIngredient(t *testing.T) { \n  meat := &Meat{} \n  meatResult, err := meat.AddIngredient() \n  if err == nil { \n    t.Errorf(\"When calling AddIngredient on the meat decorator without\" + \"an IngredientAdd in its Ingredient field must return an error,\" + \"not a string with '%s'\", meatResult) \n  } \n\n  meat = &Meat{&PizzaDecorator{}} \n  meatResult, err = meat.AddIngredient() \n  if err != nil { \n    t.Error(err) \n  } \n\n  if !strings.Contains(meatResult, \"meat\") { \n    t.Errorf(\"When calling the add ingredient of the meat decorator it\" + \"must return a text with the word 'meat', not '%s'\", meatResult) \n  } \n} \n\n```", "```go\ngo test -v -run=TestMeat_AddIngredient .\n=== RUN   TestMeat_AddIngredient\n--- FAIL: TestMeat_AddIngredient (0.00s)\ndecorator_test.go:68: Not implemented yet\ndecorator_test.go:72: When calling the add ingredient of the meat decorator it must return a text with the word 'meat', not ''\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc TestPizzaDecorator_FullStack(t *testing.T) { \n  pizza := &Onion{&Meat{&PizzaDecorator{}}} \n  pizzaResult, err := pizza.AddIngredient() \n  if err != nil { \n    t.Error(err) \n  } \n\n  expectedText := \"Pizza with the following ingredients: meat, onion\" \n  if !strings.Contains(pizzaResult, expectedText){ \n    t.Errorf(\"When asking for a pizza with onion and meat the returned \" + \"string must contain the text '%s' but '%s' didn't have it\", expectedText,pizzaResult) \n  } \n\n  t.Log(pizzaResult) \n} \n\n```", "```go\ngo test -v -run=TestPizzaDecorator_FullStack .\n=== RUN   TestPizzaDecorator_FullStack\n--- FAIL: TestPizzaDecorator_FullStack (0.\ndecorator_test.go:80: Not implemented yet\ndecorator_test.go:87: When asking for a pizza with onion and meat the returned string must contain the text 'Pizza with the following ingredients: meat, onion' but '' didn't have it\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype PizzaDecorator struct { \n  Ingredient IngredientAdd \n} \n\nfunc (p *PizzaDecorator) AddIngredient() (string, error) { \n  return \"Pizza with the following ingredients:\", nil \n} \n\n```", "```go\ngo test -v -run=TestPizzaDecorator_Add .\n=== RUN   TestPizzaDecorator_AddIngredient\n--- PASS: TestPizzaDecorator_AddIngredient (0.00s)\nPASS\nok\n\n```", "```go\ntype Onion struct { \n  Ingredient IngredientAdd \n} \n\nfunc (o *Onion) AddIngredient() (string, error) { \n  if o.Ingredient == nil { \n    return \"\", errors.New(\"An IngredientAdd is needed in the Ingredient field of the Onion\") \n  } \n  s, err := o.Ingredient.AddIngredient() \n  if err != nil { \n    return \"\", err \n  } \n  return fmt.Sprintf(\"%s %s,\", s, \"onion\"), nil \n} \n\n```", "```go\ngo test -v -run=TestOnion_AddIngredient .\n=== RUN   TestOnion_AddIngredient\n--- PASS: TestOnion_AddIngredient (0.00s)\nPASS\nok\n\n```", "```go\ntype Meat struct { \n  Ingredient IngredientAdd \n} \n\nfunc (m *Meat) AddIngredient() (string, error) { \n  if m.Ingredient == nil { \n    return \"\", errors.New(\"An IngredientAdd is needed in the Ingredient field of the Meat\") \n  } \n  s, err := m.Ingredient.AddIngredient() \n  if err != nil { \n    return \"\", err \n  } \n  return fmt.Sprintf(\"%s %s,\", s, \"meat\"), nil \n} \n\n```", "```go\ngo test -v -run=TestMeat_AddIngredient .\n=== RUN   TestMeat_AddIngredient\n--- PASS: TestMeat_AddIngredient (0.00s)\nPASS\nok\n\n```", "```go\ngo test -v -run=TestPizzaDecorator_FullStack .\n=== RUN   TestPizzaDecorator_FullStack\n--- PASS: TestPizzaDecorator_FullStack (0.00s)\ndecorator_test.go:92: Pizza with the following ingredients: meat, onion,\nPASS\nok\n\n```", "```go\ntype MyServer struct{} \n\nfunc (m *MyServer) ServeHTTP(w http.ResponseWriter, r *http.Request) { \n  fmt.Fprintln(w, \"Hello Decorator!\") \n} \n\n```", "```go\nfunc main() { \n  http.Handle(\"/\", &MyServer{}) \n\n  log.Fatal(http.ListenAndServe(\":8080\", nil)) \n} \n\n```", "```go\n$ curl http://localhost:8080\nHello Decorator!\n\n```", "```go\ntype LoggerServer struct { \n  Handler   http.Handler \n  LogWriter io.Writer \n} \n\nfunc (s *LoggerServer) ServeHTTP(w http.ResponseWriter, r *http.Request) { \n  fmt.Fprintf(s.LogWriter, \"Request URI: %s\\n\", r.RequestURI) \n  fmt.Fprintf(s.LogWriter, \"Host: %s\\n\", r.Host) \n  fmt.Fprintf(s.LogWriter, \"Content Length: %d\\n\",  \nr.ContentLength) \n  fmt.Fprintf(s.LogWriter, \"Method: %s\\n\", r.Method)fmt.Fprintf(s.LogWriter, \"--------------------------------\\n\") \n\n  s.Handler.ServeHTTP(w, r) \n} \n\n```", "```go\nfunc main() { \n  http.Handle(\"/\", &LoggerServer{ \n    LogWriter:os.Stdout, \n    Handler:&MyServer{}, \n  }) \n\n  log.Fatal(http.ListenAndServe(\":8080\", nil)) \n} \n\n```", "```go\n$ curl http://localhost:8080\nHello Decorator!\n\n```", "```go\n$ go run server_decorator.go\nRequest URI: /\nHost: localhost:8080\nContent Length: 0\nMethod: GET\n\n```", "```go\ntype BasicAuthMiddleware struct { \n  Handler  http.Handler \n  User     string \n  Password string \n} \n\n```", "```go\nfunc (s *BasicAuthMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) { \n  user, pass, ok := r.BasicAuth() \n\n  if ok { \n    if user == s.User && pass == s.Password { \n      s.Handler.ServeHTTP(w, r) \n    } \n    else { \n      fmt.Fprintf(w, \"User or password incorrect\\n\") \n    } \n  } \n  else { \n    fmt.Fprintln(w, \"Error trying to retrieve data from Basic auth\") \n  } \n} \n\n```", "```go\nfunc main() { \n  fmt.Println(\"Enter the type number of server you want to launch from the  following:\") \n  fmt.Println(\"1.- Plain server\") \n  fmt.Println(\"2.- Server with logging\") \n  fmt.Println(\"3.- Server with logging and authentication\") \n\n  var selection int \n  fmt.Fscanf(os.Stdin, \"%d\", &selection) \n} \n\n```", "```go\n   switch selection { \n   case 1: \n     mySuperServer = new(MyServer) \n   case 2: \n     mySuperServer = &LoggerMiddleware{ \n       Handler:   new(MyServer), \n       LogWriter: os.Stdout, \n     } \n   case 3: \n     var user, password string \n\n     fmt.Println(\"Enter user and password separated by a space\") \n     fmt.Fscanf(os.Stdin, \"%s %s\", &user, &password) \n\n     mySuperServer = &LoggerMiddleware{ \n     Handler: &SimpleAuthMiddleware{ \n       Handler:  new(MyServer), \n       User:     user, \n       Password: password, \n     }, \n     LogWriter: os.Stdout, \n   } \n   default: \n   mySuperServer = new(MyServer) \n } \n\n```", "```go\nhttp.Handle(\"/\", mySuperServer) \nlog.Fatal(http.ListenAndServe(\":8080\", nil)) \n\n```", "```go\n$go run server_decorator.go \nEnter the server type number you want to launch from the following: \n1.- Plain server \n2.- Server with logging \n3.- Server with logging and authentication \n\nEnter user and password separated by a space \nmario castro\n\n```", "```go\n$ curl http://localhost:8080\nError trying to retrieve data from Basic auth\n\n```", "```go\n$ curl -u no:correct http://localhost:8080\nUser or password incorrect\n\n```", "```go\nRequest URI: /\nHost: localhost:8080\nContent Length: 0\nMethod: GET\n\n```", "```go\n$ curl -u packt:publishing http://localhost:8080\nHello Decorator!\n\n```", "```go\ntype MyPrinter struct{} \nfunc(m *MyPrinter)Print(){ \n  println(\"Hello\") \n} \n\n```", "```go\ntype Printer interface { \n  Print() \n} \n\n```", "```go\ntype CurrentWeatherDataRetriever interface { \n  GetByCityAndCountryCode(city, countryCode string) (Weather, error) \n  GetByGeoCoordinates(lat, lon float32) (Weather, error) \n} \n\n```", "```go\ntype Weather struct { \n  ID   int    `json:\"id\"` \n  Name string `json:\"name\"` \n  Cod  int    `json:\"cod\"` \n  Coord struct { \n    Lon float32 `json:\"lon\"` \n    Lat float32 `json:\"lat\"` \n  } `json:\"coord\"`  \n\n  Weather []struct { \n    Id          int    `json:\"id\"` \n    Main        string `json:\"main\"` \n    Description string `json:\"description\"` \n    Icon        string `json:\"icon\"` \n  } `json:\"weather\"` \n\n  Base string `json:\"base\"` \n  Main struct { \n    Temp     float32 `json:\"temp\"` \n    Pressure float32 `json:\"pressure\"` \n    Humidity float32 `json:\"humidity\"` \n    TempMin  float32 `json:\"temp_min\"` \n    TempMax  float32 `json:\"temp_max\"` \n  } `json:\"main\"` \n\n  Wind struct { \n    Speed float32 `json:\"speed\"` \n    Deg   float32 `json:\"deg\"` \n  } `json:\"wind\"` \n\n  Clouds struct { \n    All int `json:\"all\"` \n  } `json:\"clouds\"` \n\n  Rain struct { \n    ThreeHours float32 `json:\"3h\"` \n  } `json:\"rain\"` \n\n  Dt  uint32 `json:\"dt\"` \n  Sys struct { \n    Type    int     `json:\"type\"` \n    ID      int     `json:\"id\"` \n    Message float32 `json:\"message\"` \n    Country string  `json:\"country\"` \n    Sunrise int     `json:\"sunrise\"` \n    Sunset  int     `json:\"sunset\"` \n  }`json:\"sys\"` \n} \n\n```", "```go\n`json:\"something,omitempty\" \n\n```", "```go\ntype CurrentWeatherData struct { \n  APIkey string \n} \n\n```", "```go\n func getMockData() io.Reader { \n  response := `{\n    \"coord\":{\"lon\":-3.7,\"lat\":40.42},\"weather : [{\"id\":803,\"main\":\"Clouds\",\"description\":\"broken clouds\",\"icon\":\"04n\"}],\"base\":\"stations\",\"main\":{\"temp\":303.56,\"pressure\":1016.46,\"humidity\":26.8,\"temp_min\":300.95,\"temp_max\":305.93},\"wind\":{\"speed\":3.17,\"deg\":151.001},\"rain\":{\"3h\":0.0075},\"clouds\":{\"all\":68},\"dt\":1471295823,\"sys\":{\"type\":3,\"id\":1442829648,\"message\":0.0278,\"country\":\"ES\",\"sunrise\":1471238808,\"sunset\":1471288232},\"id\":3117735,\"name\":\"Madrid\",\"cod\":200}` \n\n  r := bytes.NewReader([]byte(response)) \n  return r \n} \n\n```", "```go\nfunc TestOpenWeatherMap_responseParser(t *testing.T) { \n  r := getMockData() \n  openWeatherMap := CurrentWeatherData{APIkey: \"\"} \n\n  weather, err := openWeatherMap.responseParser(r) \n  if err != nil { \n    t.Fatal(err) \n  } \n\n  if weather.ID != 3117735 { \n    t.Errorf(\"Madrid id is 3117735, not %d\\n\", weather.ID) \n  } \n} \n\n```", "```go\nfunc (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error) { \n  return nil, fmt.Errorf(\"Not implemented yet\") \n} \n\n```", "```go\ngo test -v -run=responseParser .\n=== RUN   TestOpenWeatherMap_responseParser\n--- FAIL: TestOpenWeatherMap_responseParser (0.00s)\n facade_test.go:72: Not implemented yet\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error) { \n  w := new(Weather) \n  err := json.NewDecoder(body).Decode(w) \n  if err != nil { \n    return nil, err \n  } \n\n  return w, nil \n} \n\n```", "```go\ngo test -v -run=responseParser . \n=== RUN   TestOpenWeatherMap_responseParser \n--- PASS: TestOpenWeatherMap_responseParser (0.00s) \nPASS \nok\n\n```", "```go\nfunc (c *CurrentWeatherData) GetByGeoCoordinates(lat, lon float32) (weather *Weather, err error) { \n  return c.doRequest( \n  fmt.Sprintf(\"http://api.openweathermap.org/data/2.5/weather q=%s,%s&APPID=%s\", lat, lon, c.APIkey)) \n} \n\nfunc (c *CurrentWeatherData) GetByCityAndCountryCode(city, countryCode string) (weather *Weather, err error) { \n  return c.doRequest(   \n  fmt.Sprintf(\"http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s\", city, countryCode, c.APIkey) ) \n} \n\n```", "```go\nfmt.Sprintf(\"http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s\", city, countryCode, c.APIkey) \n\n```", "```go\nfunc (o *CurrentWeatherData) doRequest(uri string) (weather *Weather, err error) { \n  client := &http.Client{} \n  req, err := http.NewRequest(\"GET\", uri, nil) \n  if err != nil { \n    return \n  } \n  req.Header.Set(\"Content-Type\", \"application/json\") \n\n```", "```go\nresp, err := client.Do(req) \nif err != nil { \n  return \n} \n\nif resp.StatusCode != 200 { \n  byt, errMsg := ioutil.ReadAll(resp.Body) \n  if errMsg == nil { \n    errMsg = fmt.Errorf(\"%s\", string(byt)) \n  } \n  err = fmt.Errorf(\"Status code was %d, aborting. Error message was:\\n%s\\n\",resp.StatusCode, errMsg) \n\n  return \n} \n\n```", "```go\n  weather, err = o.responseParser(resp.Body) \n  resp.Body.Close() \n\n  return \n} \n\n```", "```go\n  weatherMap := CurrentWeatherData{*apiKey} \n\n  weather, err := weatherMap.GetByCityAndCountryCode(\"Madrid\", \"ES\") \n  if err != nil { \n    t.Fatal(err) \n  } \n\n  fmt.Printf(\"Temperature in Madrid is %f celsius\\n\", weather.Main.Temp-273.15) \n\n```", "```go\n$ Temperature in Madrid is 30.600006 celsius\n\n```", "```go\ntype Team struct { \n  ID             uint64 \n  Name           string \n  Shield         []byte \n  Players        []Player \n  HistoricalData []HistoricalData \n} \n\n```", "```go\nconst ( \n  TEAM_A = iota \n  TEAM_B \n) \n\n```", "```go\ntype Player struct { \n  Name    string \n  Surname string \n  PreviousTeam uint64 \n  Photo   []byte \n} \n\ntype HistoricalData struct { \n  Year          uint8 \n  LeagueResults []Match \n} \n\n```", "```go\ntype Match struct { \n  Date          time.Time \n  VisitorID     uint64 \n  LocalID       uint64 \n  LocalScore    byte \n  VisitorScore  byte \n  LocalShoots   uint16 \n  VisitorShoots uint16 \n} \n\n```", "```go\ntype teamFlyweightFactory struct { \n  createdTeams map[string]*Team \n} \n\nfunc (t *teamFlyweightFactory) GetTeam(name string) *Team { \n  return nil \n} \n\nfunc (t *teamFlyweightFactory) GetNumberOfObjects() int { \n  return 0 \n} \n\n```", "```go\nfunc TestTeamFlyweightFactory_GetTeam(t *testing.T) { \n  factory := teamFlyweightFactory{} \n\nteamA1 := factory.GetTeam(TEAM_A) \n  if teamA1 == nil { \n    t.Error(\"The pointer to the TEAM_A was nil\") \n  } \n\n  teamA2 := factory.GetTeam(TEAM_A) \n  if teamA2 == nil { \n    t.Error(\"The pointer to the TEAM_A was nil\") \n  } \n\n  if teamA1 != teamA2 { \n    t.Error(\"TEAM_A pointers weren't the same\") \n  } \n\n  if factory.GetNumberOfObjects() != 1 { \n    t.Errorf(\"The number of objects created was not 1: %d\\n\", factory.GetNumberOfObjects()) \n  } \n} \n\n```", "```go\n$ go test -v -run=GetTeam .\n=== RUN   TestTeamFlyweightFactory_GetTeam\n--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)\nflyweight_test.go:11: The pointer to the TEAM_A was nil\nflyweight_test.go:21: The pointer to the TEAM_A was nil\nflyweight_test.go:31: The number of objects created was not 1: 0\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc (t *teamFlyweightFactory) GetTeam(teamID int) *Team { \n  if t.createdTeams[teamID] != nil { \n    return t.createdTeams[teamID] \n  } \n\n  team := getTeamFactory(teamID) \n  t.createdTeams[teamID] = &team \n\n  return t.createdTeams[teamID] \n} \n\n```", "```go\nfunc getTeamFactory(team int) Team { \n  switch team { \n    case TEAM_B: \n    return Team{ \n      ID:   2, \n      Name: TEAM_B, \n    } \n    default: \n    return Team{ \n      ID:   1, \n      Name: TEAM_A, \n    } \n  } \n} \n\n```", "```go\nfunc (t *teamFlyweightFactory) GetNumberOfObjects() int { \n  return len(t.createdTeams) \n} \n\n```", "```go\n$ go test -v -run=GetTeam . \n=== RUN   TestTeamFlyweightFactory_GetTeam \n--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s) \npanic: assignment to entry in nil map [recovered] \n        panic: assignment to entry in nil map \n\ngoroutine 5 [running]: \npanic(0x530900, 0xc0820025c0) \n        /home/mcastro/Go/src/runtime/panic.go:481 +0x3f4 \ntesting.tRunner.func1(0xc082068120) \n        /home/mcastro/Go/src/testing/testing.go:467 +0x199 \npanic(0x530900, 0xc0820025c0) \n        /home/mcastro/Go/src/runtime/panic.go:443 +0x4f7 \n/home/mcastro/go-design-patterns/structural/flyweight.(*teamFlyweightFactory).GetTeam(0xc08202fec0, 0x0, 0x0) \n        /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight.go:71 +0x159 \n/home/mcastro/go-design-patterns/structural/flyweight.TestTeamFlyweightFactory_GetTeam(0xc082068120) \n        /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight_test.go:9 +0x61 \ntesting.tRunner(0xc082068120, 0x666580) \n        /home/mcastro/Go/src/testing/testing.go:473 +0x9f \ncreated by testing.RunTests \n        /home/mcastro/Go/src/testing/testing.go:582 +0x899 \nexit status 2 \nFAIL\n\n```", "```go\nt.createdTeams[teamName] = &team \n\n```", "```go\nfactory := teamFlyweightFactory{ \n  createdTeams: make(map[int]*Team,0), \n} \n\n```", "```go\nfunc NewTeamFactory() teamFlyweightFactory { \n  return teamFlyweightFactory{ \n    createdTeams: make(map[int]*Team), \n  } \n} \n\n```", "```go\nfunc TestTeamFlyweightFactory_GetTeam(t *testing.T) { \n  factory := NewTeamFactory() \n  ... \n} \n\n```", "```go\n$ go test -v -run=GetTeam .\n=== RUN   TestTeamFlyweightFactory_GetTeam\n--- PASS: TestTeamFlyweightFactory_GetTeam (0.00s)\nPASS\nok \n\n```", "```go\nfunc Test_HighVolume(t *testing.T) { \n  factory := NewTeamFactory() \n\n  teams := make([]*Team, 500000*2) \n  for i := 0; i < 500000; i++ { \n  teams[i] = factory.GetTeam(TEAM_A) \n} \n\nfor i := 500000; i < 2*500000; i++ { \n  teams[i] = factory.GetTeam(TEAM_B) \n} \n\nif factory.GetNumberOfObjects() != 2 { \n  t.Errorf(\"The number of objects created was not 2: %d\\n\",factory.GetNumberOfObjects()) \n  } \n} \n\n```", "```go\n$ go test -v -run=Volume . \n=== RUN   Test_HighVolume \n--- PASS: Test_HighVolume (0.04s) \nPASS \nok\n\n```", "```go\nfor i:=0; i<3; i++ { \n  fmt.Printf(\"Pointer %d points to %p and is located in %p\\n\", i, teams[i], &teams[i]) \n} \n\n```", "```go\nPointer 0 points to 0xc082846000 and is located in 0xc082076000\nPointer 1 points to 0xc082846000 and is located in 0xc082076008\nPointer 2 points to 0xc082846000 and is located in 0xc082076010\n\n```"]