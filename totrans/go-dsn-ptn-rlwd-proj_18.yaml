- en: Chapter 4. Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 结构型模式 - 代理、外观、装饰器和享元设计模式
- en: With this chapter, we will finish with the Structural patterns. We have left
    some of the most complex ones till the end so that you get more used to the mechanics
    of design patterns, and the features of Go language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们将完成结构型模式的学习。我们留了一些最复杂的模式到后面，这样你可以更习惯设计模式的机制，以及Go语言的特点。
- en: In this chapter, we will work at writing a cache to access a database, a library
    to gather weather data, a server with runtime middleware, and discuss a way to
    save memory by saving shareable states between the types values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个用于访问数据库的缓存、一个收集天气数据的库、一个具有运行时中间件的服务器，并讨论一种通过在类型值之间保存可共享状态来节省内存的方法。
- en: Proxy design pattern
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理设计模式
- en: We'll start the final chapter on structural patterns with the Proxy pattern.
    It's a simple pattern that provides interesting features and possibilities with
    very little effort.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以代理模式开始结构型模式的最后一章。这是一个简单的模式，只需付出很少的努力就能提供有趣的功能和可能性。
- en: Description
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Proxy pattern usually wraps an object to hide some of its characteristics.
    These characteristics could be the fact that it is a remote object (remote proxy),
    a very heavy object such as a very big image or the dump of a terabyte database
    (virtual proxy), or a restricted access object (protection proxy).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式通常封装一个对象以隐藏其一些特性。这些特性可能包括它是一个远程对象（远程代理）、一个非常重的对象，如非常大的图像或兆字节的数据库转储（虚拟代理），或者一个受限访问的对象（保护代理）。
- en: Objectives
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The possibilities of the Proxy pattern are many, but in general, they all try
    to provide the same following functionalities:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的可能性很多，但总的来说，它们都试图提供以下相同的功能：
- en: Hide an object behind the proxy so the features can be hidden, restricted, and
    so on
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代理后面隐藏一个对象，以便可以隐藏、限制等功能。
- en: Provide a new abstraction layer that is easy to work with, and can be changed
    easily
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个易于工作的新抽象层，并且可以轻松更改。
- en: Example
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: For our example, we are going to create a remote proxy, which is going to be
    a cache of objects before accessing a database. Let's imagine that we have a database
    with many users, but instead of accessing the database each time we want information
    about a user, we will have a **First In First Out** (**FIFO**) stack of users
    in a Proxy pattern (FIFO is a way of saying that when the cache needs to be emptied,
    it will delete the first object that entered first).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将创建一个远程代理，它将成为访问数据库前的对象缓存。让我们想象我们有一个包含许多用户的数据库，但每次我们想要获取用户信息时，我们不会直接访问数据库，而是将用户信息存储在一个代理模式中的**先进先出**（**FIFO**）堆栈中（FIFO是一种表示当缓存需要清空时，它将删除最先进入的第一个对象的方式）。
- en: Acceptance criteria
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'We will wrap an imaginary database, represented by a slice, with our Proxy
    pattern. Then, the pattern will have to stick to the following acceptance criteria:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的代理模式封装一个虚拟的数据库，用一个切片表示，然后该模式必须遵守以下接受标准：
- en: All accesse to the database of users will be done through the Proxy type.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有对用户数据库的访问都将通过代理类型进行。
- en: A stack of `n` number of recent users will be kept in the Proxy.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`n`个最近用户堆叠保存在代理中。
- en: If a user already exists in the stack, it won't query the database, and will
    return the stored one
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户已经在堆叠中存在，它将不会查询数据库，而是返回存储的记录。
- en: If the queried user doesn't exist in the stack, it will query the database,
    remove the oldest user in the stack if it's full, store the new one, and return
    it.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果查询的用户不在堆栈中，它将查询数据库，如果堆栈已满，则删除最旧的用户，存储新的用户，并返回它。
- en: Unit test
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Since version 1.7 of Go, we can embed tests within tests by using closures so
    we can group them in a more human-readable way, and reduce the number of `Test_`
    functions. Refer to [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!") , *Ready... Steady... Go!* to learn how to
    install the new version of Go if your current version is older than version 1.7.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自Go 1.7版本以来，我们可以通过使用闭包在测试中嵌入测试，这样我们可以以更易于阅读的方式对它们进行分组，并减少`Test_`函数的数量。请参阅[第1章](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第1章. 准备... 稳定... 开始！")，*准备... 稳定... 开始！*了解如果当前版本低于1.7版本，如何安装Go的新版本。
- en: 'The types for this pattern will be the proxy user and user list structs as
    well as a `UserFinder` interface that the database and the Proxy will implement.
    This is key because the Proxy must implement the same interfaces as the features
    of the type it tries to wrap:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的类型将是代理用户和用户列表结构以及数据库和 Proxy 将实现的 `UserFinder` 接口。这是关键，因为代理必须实现与它试图包装的类型相同的接口：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `UserFinder` is the interface that the database and the Proxy implement.
    The `User` is a type with a member called `ID`, which is `int32` type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserFinder` 是数据库和 Proxy 实现的接口。`User` 是一个具有名为 `ID` 的成员的类型，其类型为 `int32`：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, the `UserList` is a type of a slice of users. Consider the following
    syntax for that:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`UserList` 是用户切片的类型。考虑以下语法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are asking why we aren't using a slice of users directly, the answer
    is that by declaring a sequence of users this way, we can implement the `UserFinder`
    interface but with a slice, we can't.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问为什么我们不直接使用用户切片，答案是：通过这种方式声明用户序列，我们可以实现 `UserFinder` 接口，但如果我们使用切片，则不能。
- en: Finally, the Proxy type, called `UserListProxy` will be composed of a `UserList`
    slice, which will be our database representation. The `StackCache` members which
    will also be of `UserList` type for simplicity, `StackCapacity` to give our stack
    the size we want.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Proxy` 类型，称为 `UserListProxy`，将由 `UserList` 切片组成，这将是我们的数据库表示。`StackCache`
    成员也将是 `UserList` 类型，为了简单起见，`StackCapacity` 将给我们的栈赋予我们想要的大小。
- en: 'We will cheat a bit for the purpose of this tutorial and declare a Boolean
    state on a field called `DidDidLastSearchUsedCache` that will hold if the last
    performed search has used the cache, or has accessed the database:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本教程的目的，我们将稍微作弊一下，在名为 `DidDidLastSearchUsedCache` 的字段上声明一个布尔状态，该状态将保留最后一次执行搜索是否使用了缓存，或者是否访问了数据库：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UserListProxy` type will cache a maximum of `StackCapacity` users, and
    rotate the cache if it reaches this limit. The `StackCache` members will be populated
    from objects from `SomeDatabase` type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserListProxy` 类型将缓存最多 `StackCapacity` 个用户，并在达到此限制时旋转缓存。`StackCache` 成员将从
    `SomeDatabase` 类型的对象中填充。'
- en: 'The first test is called `TestUserListProxy`, and is listed next:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次测试被称为 `TestUserListProxy`，并列在下面：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding test creates a user list of 1 million users with random names.
    To do so, we feed the random number generator by calling the `Seed()` function
    with some constant seed so our randomized results are also constant; and the user
    IDs are generated from it. It might have some duplicates, but it serves our purpose.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试创建了一个包含一百万个随机名称的用户列表。为此，我们通过调用带有某些常量种子的 `Seed()` 函数来喂养随机数生成器，这样我们的随机结果也是恒定的；用户
    ID 就是根据这个生成的。可能会有一些重复，但这满足了我们的目的。
- en: 'Next, we need a proxy with a reference to `someDatabase`, which we have just
    created:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个具有对 `someDatabase` 的引用的代理，这是我们刚刚创建的：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, we have a `proxy` object composed of a mock database with 1 million
    users, and a cache implemented as a FIFO stack with a size of 2\. Now we will
    get three random IDs from `someDatabase` to use in our stack:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个由一百万个用户组成的模拟数据库和一个大小为 2 的 FIFO 栈组成的 `proxy` 对象。现在我们将从 `someDatabase`
    中获取三个随机 ID，用于我们的栈：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We took the fourth, fifth, and sixth IDs from the slice (remember that arrays
    and slices start with 0, so the index 3 is actually the fourth position in the
    slice).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从切片中取了第四、第五和第六个 ID（记住，数组和切片从 0 开始，所以索引 3 实际上是切片中的第四个位置）。
- en: 'This is going to be our starting point before launching the embedded tests.
    To create an embedded test, we have to call the `Run` method of the `testing.T`
    pointer, with a description and a closure with the `func(t *testing.T)` signature:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是启动嵌入式测试之前的起点。为了创建一个嵌入式测试，我们必须调用 `testing.T` 指针的 `Run` 方法，并带有描述和具有 `func(t
    *testing.T)` 签名的闭包：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, we check whether the returned user has the same ID as that of the expected
    user at index 0 of the `knownIDs` slice, and that the proxy cache now has a size
    of 1\. The state of the member `DidLastSearchUsedCache` proxy must not be `true`,
    or we will not pass the test. Remember, this member tells us whether the last
    search has been retrieved from the slice that represents a database, or from the
    cache.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查返回的用户是否与 `knownIDs` 切片索引 0 处的预期用户 ID 相同，并且代理缓存现在的大小为 1。代理成员 `DidLastSearchUsedCache`
    的状态必须不是 `true`，否则我们将不会通过测试。记住，这个成员告诉我们最后一次搜索是否是从表示数据库的切片中检索的，还是从缓存中检索的。
- en: 'The second embedded test for the Proxy pattern is to ask for the same user
    as before, which must now be returned from the cache. It''s very similar to the
    previous test, but now we have to check if the user is returned from the cache:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的第二个嵌入式测试是请求之前相同的用户，现在必须从缓存中返回。这与之前的测试非常相似，但现在我们必须检查用户是否是从缓存中返回的：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, again we ask for the first known ID. The proxy cache must maintain a size
    of 1 after this search, and the `DidLastSearchUsedCache` member must be true this
    time, or the test will fail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们再次请求第一个已知的 ID。在这次搜索之后，代理缓存必须保持大小为 1，而这次 `DidLastSearchUsedCache` 成员必须是
    true，否则测试将失败。
- en: 'The last test will overflow the `StackCache` array on the `proxy` type. We
    will search for two new users that our `proxy` type will have to retrieve from
    the database. Our stack has a size of 2, so it will have to remove the first user
    to allocate space for the second and third users:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试将使 `proxy` 类型的 `StackCache` 数组溢出。我们将搜索两个新的用户，我们的 `proxy` 类型将不得不从数据库中检索这些用户。我们的栈大小为
    2，因此它必须删除第一个用户以为第二个和第三个用户分配空间：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have retrieved the first three users. We aren't checking for errors because
    that was the purpose of the previous tests. This is important to recall that there
    is no need to over-test your code. If there is any error here, it will arise in
    the previous tests. Also, we have checked that the `user2` and `user3` queries
    do not use the cache; they shouldn't be stored there yet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检索了前三个用户。我们不会检查错误，因为这是之前测试的目的。重要的是要记住，没有必要过度测试你的代码。如果这里有任何错误，它将在之前的测试中出现。此外，我们已经检查了
    `user2` 和 `user3` 查询没有使用缓存；它们还不应该被存储在那里。
- en: 'Now we are going to look for the `user1` query in the Proxy. It shouldn''t
    exist, as the stack has a size of 2, and `user1` was the first to enter, hence,
    the first to go out:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在代理中查找 `user1` 查询。它不应该存在，因为栈的大小为 2，而 `user1` 是第一个进入的，因此也是第一个出去的：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It doesn't matter if we ask for a thousand users; our cache can't be bigger
    than our configured size.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们请求多少用户，我们的缓存大小都不会超过我们配置的大小。
- en: 'Finally, we are going to again range over the users stored in the cache, and
    compare them with the last two we queried. This way, we will check that just those
    users are stored in the cache. Both must be found on it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将再次遍历存储在缓存中的用户，并将它们与最后查询的两个用户进行比较。这样，我们将检查只有那些用户被存储在缓存中。两者都必须在上面找到：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the tests now should give some errors, as usual. Let''s run them now:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试应该会给出一些错误，就像往常一样。我们现在就运行它们：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, let's implement the `FindUser` method to act as our Proxy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现 `FindUser` 方法以作为我们的代理。
- en: Implementation
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In our Proxy, the `FindUser` method will search for a specified ID in the cache
    list. If it finds it, it will return the ID. If not, it will search in the database.
    Finally, if it's not in the database list, it will return an error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代理中，`FindUser` 方法将在缓存列表中搜索指定的 ID。如果找到了，它将返回该 ID。如果没有找到，它将在数据库中搜索。最后，如果它不在数据库列表中，它将返回一个错误。
- en: 'If you remember, our Proxy pattern is composed of two `UserList` types (one
    of them a pointer), which are actually slices of `User` type. We will implement
    a `FindUser` method in `User` type too, which, by the way, has the same signature
    as the `UserFinder` interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们的代理模式由两种 `UserList` 类型（其中一个是指针）组成，实际上它们是 `User` 类型的切片。我们将在 `User` 类型中实现一个
    `FindUser` 方法，顺便说一下，它的签名与 `UserFinder` 接口相同：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `FindUser` method in the `UserList` slice will iterate over the list to
    try and find a user with the same ID as the `id` argument, or return an error
    if it can't find it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserList` 切片中的 `FindUser` 方法将会遍历列表以尝试找到与 `id` 参数相同的用户，如果找不到，则返回错误。'
- en: You may be wondering why the pointer `t` is between parentheses. This is to
    dereference the underlying array before accessing its indexes. Without it, you'll
    have a compilation error, because the compiler tries to search the index before
    dereferencing the pointer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么指针 `t` 在括号之间。这是在访问其索引之前取消引用底层数组。没有它，你将遇到编译错误，因为编译器试图在取消引用指针之前搜索索引。
- en: 'So, the first part of the proxy `FindUser` method can be written as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代理 `FindUser` 方法的第一部分可以写成如下：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the preceding method to search for a user in the `StackCache` member.
    The error will be nil if it can find it, so we check this to print a message to
    the console, change the state of `DidLastSearchUsedCache` to `true` so that the
    test can check whether the user was retrieved from cache, and finally, return
    the user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的方法在`StackCache`成员中搜索用户。如果找到，错误将为nil，因此我们检查这一点以向控制台打印消息，将`DidLastSearchUsedCache`的状态更改为`true`，以便测试可以检查用户是否从缓存中检索，最后返回用户。
- en: 'So, if the error was not nil, it means that it couldn''t find the user in the
    stack. So, the next step is to search in the database:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果错误不为nil，这意味着它无法在栈中找到用户。所以下一步是搜索数据库：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can reuse the `FindUser` method we wrote for `UserList` database in this
    case, because both have the same type for the purpose of this example. Again,
    it searches the user in the database represented  by the `UserList` slice, but
    in this case, if the user isn't found, it returns the error generated in `UserList`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以重用我们为`UserList`数据库编写的`FindUser`方法，因为在这个示例中，两者具有相同的类型。再次强调，它会在`UserList`切片表示的数据库中搜索用户，但在这个例子中，如果找不到用户，它将返回`UserList`中生成的错误。
- en: 'When the user is found (`err` is nil), we have to add the user to the stack.
    For this purpose, we write a dedicated private method that receives a pointer
    of type `UserListProxy`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到用户（`err`为nil）时，我们必须将用户添加到栈中。为此，我们编写了一个专门的私有方法，该方法接收一个类型为`UserListProxy`的指针：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `addUserToStack` method takes the user argument, and adds it to the stack
    in place. If the stack is full, it removes the first element in it before adding.
    We have also written an `addUser` method to `UserList` to help us in this. So,
    now in `FindUser` method, we just have to add one line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`addUserToStack`方法接受用户参数，并将其就地添加到栈中。如果栈已满，则在添加之前会移除其中的第一个元素。我们为此还编写了一个`addUser`方法来帮助。因此，现在在`FindUser`方法中，我们只需添加一行：'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This adds the new user to the stack, removing the last if necessary.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将新用户添加到栈中，如果需要，则移除最后一个。
- en: 'Finally, we just have to return the new user of the stack, and set the appropriate
    value on `DidLastSearchUsedCache` variable. We also write a message to the console
    to help in the testing process:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需返回栈中的新用户，并在`DidLastSearchUsedCache`变量上设置适当的值。我们还向控制台写入一条消息，以帮助测试过程：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this, we have enough to pass our tests:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了足够的测试通过：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see in the preceding messages that our Proxy has worked flawlessly.
    It has returned the first search from the database. Then, when we search for the
    same user again, it uses the cache. Finally, we made a new test that calls three
    different users and we can observe, by looking at the console output, that just
    the first was returned from the cache and that the other two were fetched from
    the database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从前面的消息中看到，我们的代理工作得非常完美。它从数据库中返回了第一次搜索结果。然后，当我们再次搜索同一用户时，它使用缓存。最后，我们创建了一个新的测试，调用三个不同的用户，并且我们可以通过查看控制台输出观察到，只有第一个是从缓存中返回的，而其他两个是从数据库中检索的。
- en: Proxying around actions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理操作
- en: Wrap proxies around types that need some intermediate action, like giving authorization
    to the user or providing access to a database, like in our example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将代理包装在需要一些中间操作的类型周围，例如向用户提供授权或提供数据库访问，就像在我们的例子中一样。
- en: Our example is a good way to separate application needs from database needs.
    If our application accesses the database too much, a solution for this is not
    in your database. Remember that the Proxy uses the same interface as the type
    it wraps, and, for the user, there shouldn't be any difference between the two.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子是一个很好的方法，可以将应用程序需求与数据库需求分开。如果我们的应用程序过多地访问数据库，解决方案不在于你的数据库。记住，代理使用与它包装的类型相同的接口，对于用户来说，两者之间不应该有任何区别。
- en: Decorator design pattern
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: We'll continue this chapter with the big brother of the Proxy pattern, and maybe,
    one of the most powerful design patterns of all. The **Decorator** pattern is
    pretty simple, but, for instance, it provides a lot of benefits when working with
    legacy code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续本章，介绍代理模式的“大哥”，也许是最强大的设计模式之一。**装饰器**模式相当简单，但例如，当与遗留代码一起工作时，它提供了很多好处。
- en: Description
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Decorator design pattern allows you to decorate an already existing type
    with more functional features without actually touching it. How is it possible?
    Well, it uses an approach similar to *matryoshka dolls*, where you have a small
    doll that you can put inside a doll of the same shape but bigger, and so on and
    so forth.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者设计模式允许你在不实际接触现有类型的情况下，为其添加更多功能特性。这是如何实现的呢？嗯，它使用了一种类似于 *套娃* 的方法，你有一个小娃娃可以放在形状相同但更大的娃娃里面，以此类推。
- en: The Decorator type implements the same interface of the type it decorates, and
    stores an instance of that type in its members. This way, you can stack as many
    decorators (dolls) as you want by simply storing the old decorator in a field
    of the new one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者类型实现了被装饰类型的相同接口，并在其成员中存储该类型的实例。这样，你可以通过简单地存储旧装饰者在新装饰者的字段中，来堆叠尽可能多的装饰者（娃娃）。
- en: Objectives
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: When you think about extending legacy code without the risk of breaking something,
    you should think of the Decorator pattern first. It's a really powerful approach
    to deal with this particular problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑在不破坏任何东西的风险下扩展遗留代码时，你应该首先想到装饰者模式。这是一种处理这个特定问题的非常强大的方法。
- en: A different field where the Decorator is very powerful may not be so obvious
    though it reveals itself when creating types with lots of features based on user
    inputs, preferences, or similar inputs. Like in a Swiss knife, you have a base
    type (the frame of the knife), and from there you unfold its functionalities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式非常强大的另一个不同领域可能并不明显，尽管在创建基于用户输入、偏好或类似输入的具有许多功能类型时，它会显现出来。就像瑞士军刀一样，你有一个基础类型（刀的框架），然后从这里展开其功能。
- en: 'So, precisely when are we going to use the Decorator pattern? Answer to this
    question:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们究竟在什么时候会使用装饰者模式呢？回答这个问题：
- en: When you need to add functionality to some code that you don't have access to,
    or you don't want to modify to avoid a negative effect on the code, and follow
    the open/close principle (like legacy code)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要向某些代码添加功能，而你无法访问这些代码，或者你不想修改以避免对代码产生负面影响，并遵循开闭原则（如遗留代码）
- en: When you want the functionality of an object to be created or altered dynamically,
    and the number of features is unknown and could grow fast
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想动态创建或修改对象的功能，而功能数量未知且可能快速增长时
- en: Example
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: In our example, we will prepare a `Pizza` type, where the core is the pizza
    and the ingredients are the decorating types. We will have a couple of ingredients
    for our pizza-onion and meat.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将准备一个 `Pizza` 类型，其中核心是披萨，成分是装饰类型。我们将为我们的披萨添加一些成分——洋葱和肉。
- en: Acceptance criteria
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'The acceptance criteria for a Decorator pattern is to have a common interface
    and a core type, the one that all layers will be built over:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式的接受标准是拥有一个公共接口和一个核心类型，即所有层都将构建在其上的类型：
- en: We must have the main interface that all decorators will implement. This interface
    will be called `IngredientAdd`, and it will have the `AddIngredient() string`
    method.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个所有装饰者都将实现的主体接口。这个接口将被称为 `IngredientAdd`，它将有一个 `AddIngredient() string`
    方法。
- en: We must have a core `PizzaDecorator` type (the decorator) that we will add ingredients
    to.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个核心 `PizzaDecorator` 类型（装饰者），我们将向其中添加成分。
- en: We must have an ingredient "onion"  implementing the same `IngredientAdd` interface
    that will add the string `onion` to the returned pizza.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个名为 "onion" 的成分实现相同的 `IngredientAdd` 接口，该接口将字符串 `onion` 添加到返回的披萨中。
- en: We must have a ingredient "meat" implementing the `IngredientAdd` interface
    that will add the string `meat` to the returned pizza.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个成分 "meat" 实现了 `IngredientAdd` 接口，该接口将字符串 `meat` 添加到返回的披萨中。
- en: 'When calling `AddIngredient` method on the top object, it must return a fully
    decorated `pizza` with the text `Pizza with the following ingredients: meat, onion`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在顶层对象上调用 `AddIngredient` 方法时，它必须返回一个完全装饰的 `pizza`，文本为 `包含以下成分的披萨：meat, onion`。
- en: Unit test
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To launch our unit tests, we must first create the basic structures described
    in accordance with the acceptance criteria. To begin with, the interface that
    all decorating types must implement is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动我们的单元测试，我们必须首先创建符合接受标准的基结构。首先，所有装饰类型必须实现的接口如下：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code defines the `PizzaDecorator` type, which must have `IngredientAdd`
    inside, and which implements `IngredientAdd` too:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了 `PizzaDecorator` 类型，它必须包含 `IngredientAdd`，并且也实现了 `IngredientAdd`：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The definition of the `Meat` type will be very similar to that of the  `PizzaDecorator` structure:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meat` 类型的定义将非常类似于 `PizzaDecorator` 结构体的定义：'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we define the `Onion` struct in a similar fashion:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以类似的方式定义 `Onion` 结构体：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is enough to implement the first unit test, and to allow the compiler
    to run them without any compiling errors:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够实现第一个单元测试，并允许编译器在没有编译错误的情况下运行它们：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now it must compile without problems, so we can check that the test fails:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它必须无问题地编译，因此我们可以检查测试是否失败：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our first test is done, and we can see that the `PizzaDecorator` struct isn''t
    returning anything yet, that''s why it fails. We can now move on to the `Onion`
    type. The test of the `Onion` type is quite similar to that of the `Pizza` decorator,
    but we must also make sure that we actually add the ingredient to the `IngredientAdd` method
    and not to a nil pointer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测试已经完成，我们可以看到 `PizzaDecorator` 结构体还没有返回任何内容，这就是为什么它失败了。现在我们可以继续到 `Onion`
    类型。`Onion` 类型的测试与 `Pizza` 装饰器的测试非常相似，但我们还必须确保我们实际上是将配料添加到 `IngredientAdd` 方法中，而不是一个空指针：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first half of the preceding test examines the returning error when no `IngredientAdd` method
    is passed to the `Onion` struct initializer. As no pizza is available to add the
    ingredient, an error must be returned:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个测试的前半部分检查了在将没有任何 `IngredientAdd` 方法传递给 `Onion` 结构体初始化器时返回的错误。由于没有披萨可以添加配料，必须返回一个错误：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second part of the `Onion` type test actually passes `PizzaDecorator` structure
    to the initializer. Then, we check whether no error is being returned, and also
    whether the returning string contains the word `onion` in it. This way, we can
    ensure that onion has been added to the pizza.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Onion` 类型测试的第二部分实际上将 `PizzaDecorator` 结构体传递给初始化器。然后，我们检查没有返回错误，并且返回的字符串中是否包含单词
    `onion`。这样，我们可以确保洋葱已经添加到披萨中。'
- en: 'Finally for the `Onion` type, the console output of this test with our current
    implementation will be the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `Onion` 类型，这个测试的当前实现下的控制台输出将是以下内容：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `meat` ingredient is exactly the same, but we change the type to meat instead
    of onion:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`meat` 配料完全相同，但我们将其类型改为肉而不是洋葱：'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, the result of the tests will be similar:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试的结果将是类似的：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we must check the full stack test. Creating a pizza with onion and
    meat must return the text `Pizza with the following ingredients: meat, onion`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们必须检查完整的堆栈测试。用洋葱和肉制作披萨必须返回文本 `Pizza with the following ingredients: meat,
    onion`：'
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our test creates a variable called `pizza` which, like the m*atryoshka dolls*,
    embeds types of the `IngredientAdd` method in several levels. Calling the `AddIngredient`
    method executes the method at the "onion" level, which executes the "meat" one,
    which, finally, executes that of the `PizzaDecorator` struct. After checking that
    no error had been returned, we check whether the returned text follows the needs
    of the *acceptance criteria 5*. The tests are run with the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试创建了一个名为 `pizza` 的变量，它就像套娃一样，嵌套了 `IngredientAdd` 方法的类型在几个层级中。调用 `AddIngredient`
    方法将执行 "onion" 层的方法，然后执行 "meat" 层的方法，最后执行 `PizzaDecorator` 结构体的方法。在确认没有返回错误后，我们检查返回的文本是否符合
    *验收标准 5* 的需求。测试使用以下命令运行：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: From the preceding output, we can see that the tests now return an empty string
    for our decorated type. This is, of course, because no implementation has been
    done yet. This was the last test to check the fully decorated implementation.
    Let's look closely at the implementation then.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到，现在测试为我们的装饰类型返回了一个空字符串。这当然是因为还没有进行任何实现。这是最后一个测试，用于检查完全装饰的实现。那么，让我们仔细看看实现。
- en: Implementation
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We are going to start implementing the `PizzaDecorator` type. Its role is to
    provide the initial text of the full pizza:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始实现 `PizzaDecorator` 类型。它的作用是提供完整披萨的初始文本：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A single line change on the return of the `AddIngredient` method was enough
    to pass the test:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AddIngredient` 方法的返回值上做单行更改就足以通过测试：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Moving on to the `Onion` struct implementation, we must take the beginning
    of our `IngredientAdd` returned string, and add the word `onion` at the end of
    it in order to get a composed pizza in return:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `Onion` 结构体的实现，我们必须取 `IngredientAdd` 返回字符串的开头，并在其末尾添加单词 `onion`，以便返回一个组合披萨：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Checking that we actually have a pointer to `IngredientAdd` first, we use the
    contents of the inner `IngredientAdd`, and check it for errors. If no errors occur,
    we receive a new string composed of this content, a space, and the word `onion`
    (and no errors). Looks good enough to run the tests:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查我们确实有一个指向`IngredientAdd`的指针，我们使用内部`IngredientAdd`的内容，并检查是否有错误。如果没有错误发生，我们将收到一个由这个内容、一个空格和单词`onion`（以及没有错误）组成的新字符串。看起来足够好，可以运行测试：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implementation of the `Meat` struct is very similar:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meat`结构的实现非常相似：'
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And here goes their test execution:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它们的测试执行：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Okay. So, now all the pieces are to be tested separately. If everything is
    okay, the test of the *full stacked* solution must be passing smoothly:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，现在所有组件都需要单独测试。如果一切正常，*完整堆叠*解决方案的测试必须顺利通过：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Awesome! With the Decorator pattern, we could keep stacking `IngredientAdds`
    which call their inner pointer to add functionality to `PizzaDecorator`. We aren't
    touching the core type either, nor modifying or implementing new things. All the
    new features are implemented by an external type.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！使用装饰者模式，我们可以连续堆叠`IngredientAdds`，这些`IngredientAdds`会调用它们的内部指针来向`PizzaDecorator`添加功能。我们也没有触及核心类型，也没有修改或实现新事物。所有的新功能都是由外部类型实现的。
- en: A real-life example - server middleware
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实生活中的例子 - 服务器中间件
- en: By now, you should have understood how the Decorator pattern works. Now we can
    try a more advanced example using the small HTTP server that we designed in the
    Adapter pattern section. You learned that an HTTP server can be created by using
    the `http` package, and implementing the `http.Handler` interface. This interface
    has only one method called `ServeHTTP(http.ResponseWriter, http.Request)`. Can
    we use the Decorator pattern to add more functionality to a server? Of course!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经理解了装饰者模式的工作原理。现在我们可以尝试一个更高级的例子，使用我们在适配器模式部分设计的HTTP小服务器。你了解到可以通过使用`http`包并实现`http.Handler`接口来创建HTTP服务器。这个接口只有一个方法，叫做`ServeHTTP(http.ResponseWriter,
    http.Request)`。我们能否使用装饰者模式向服务器添加更多功能？当然可以！
- en: We will add a couple of pieces to this server. First, we are going to log every
    connection made to it to the `io.Writer` interface (for the sake of simplicity,
    we'll use the `io.Writer` implementation of the `os.Stdout` interface so that
    it outputs to the console). The second piece will add basic HTTP authentication
    to every request made to the server. If the authentication passes, a `Hello Decorator!` message
    will appear. Finally, the user will be able to select the number of decoration
    items that he/she wants in the server, and the server will be structured and created
    at runtime.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向这个服务器添加几个组件。首先，我们将记录所有连接到它的连接到`io.Writer`接口（为了简单起见，我们将使用`os.Stdout`接口的`io.Writer`实现，以便输出到控制台）。第二个组件将为服务器发出的每个请求添加基本的HTTP身份验证。如果身份验证通过，将显示`Hello
    Decorator!`消息。最后，用户将能够选择在服务器中想要的装饰项目数量，服务器将在运行时进行结构和创建。
- en: Starting with the common interface, http.Handler
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从通用接口开始，http.Handler
- en: 'We already have the common interface that we will decorate using nested types.
    We first need to create our core type, which is going to be the `Handler` that
    returns the sentence `Hello Decorator!`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了将要使用嵌套类型进行装饰的通用接口。我们首先需要创建我们的核心类型，它将是一个返回句子`Hello Decorator!`的`Handler`：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This handler can be attributed to the `http.Handle` method to define our first
    endpoint. Let''s check this now by creating the package''s `main` function, and
    sending a `GET` request to it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理器可以被分配给`http.Handle`方法来定义我们的第一个端点。现在让我们通过创建包的`main`函数并向它发送`GET`请求来检查这一点：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Execute the server using the Terminal to execute the  `**go run main.go**`
    command. Then, open a new Terminal to make the `GET` request. We''ll use the `curl`
    command to make our requests:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用终端执行服务器，运行`**go run main.go**`命令。然后，打开一个新的终端来发起`GET`请求。我们将使用`curl`命令来发起请求：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We have crossed the first milestone of our decorated server. The next step
    is to decorate it with logging capabilities. To do so, we must implement the `http.Handler`
    interface, in a new type, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了装饰服务器的第一里程碑。下一步是为它添加日志功能。为此，我们必须在一个新类型中实现`http.Handler`接口，如下所示：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We call this type `LoggerServer`. As you can see, it stores not only a `Handler`,
    but also `io.Writer` to write the output of the log. Our implementation of the
    `ServeHTTP` method prints the request URI, the host, the content length, and the
    used method `io.Writer`. Once printing is finished, it calls the `ServeHTTP` function
    of its inner `Handler` field.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种类型为 `LoggerServer`。正如你所见，它不仅存储了一个 `Handler`，还存储了一个 `io.Writer` 来写入日志的输出。我们实现的
    `ServeHTTP` 方法打印请求 URI、主机、内容长度和使用的 `io.Writer` 方法。打印完成后，它调用其内部 `Handler` 字段的 `ServeHTTP`
    函数。
- en: 'We can decorate `MyServer` with this `LoggerMiddleware`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个 `LoggerMiddleware` 装饰 `MyServer`：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now run the `**curl **`  command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `**curl**` 命令：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our **curl** command returns the same message, but if you look at the Terminal
    where you have run the Go application, you can see the logging:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 **curl** 命令返回相同的信息，但如果你查看运行 Go 应用的终端，你可以看到日志：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have decorated `MyServer` with logging capabilities without actually modifying
    it. Can we do the same with authentication? Of course! After logging the request,
    we will authenticate it by using **HTTP Basic Authentication** as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实际上没有修改它的情况下，用日志功能装饰了 `MyServer`。我们能否用身份验证做到同样的事情？当然可以！在记录请求后，我们将通过以下方式使用
    **HTTP Basic Authentication** 进行身份验证：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The **BasicAuthMiddleware** middleware stores three fields--a handler to decorate
    like in the previous middlewares, a user, and a password, which will be the only
    authorization to access the contents on the server. The implementation of the
    `decorating` method will proceed as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**BasicAuthMiddleware** 中间件存储了三个字段——一个用于装饰的处理程序，就像之前的中间件一样，一个用户和一个密码，这些将作为访问服务器上内容的唯一授权。`decorating`
    方法的实现将按以下步骤进行：'
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding implementation, we use the `BasicAuth` method from `http.Request`
    to automatically retrieve the user and password from the request, plus an `ok/ko`
    from the parsing action. Then we check whether the parsing is correct (returning
    a message to the requester if incorrect, and finishing the request). If no problems
    have been detected during parsing, we check whether the username and the password
    match with the ones stored in `BasicAuthMiddleware`. If the credentials are valid,
    we shall call the decorated type (our server), but if the credentials aren't valid,
    we receive the `User or password incorrect` message in return, and the request
    is finished.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们使用 `http.Request` 中的 `BasicAuth` 方法自动从请求中检索用户和密码，以及解析动作的 `ok/ko`。然后我们检查解析是否正确（如果错误，向请求者返回消息，并完成请求）。如果没有检测到任何问题，我们检查用户名和密码是否与存储在
    `BasicAuthMiddleware` 中的匹配。如果凭据有效，我们将调用装饰的类型（我们的服务器），但如果凭据无效，我们将收到“用户名或密码错误”的消息，并完成请求。
- en: 'Now, we need to provide the user with a way to choose among different types
    of servers. We will retrieve user input data in the main function. We''ll have
    three options to choose from:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为用户提供一种方式来选择不同类型的服务器。我们将在主函数中检索用户输入数据。我们将有三个选项可供选择：
- en: Simple server
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单服务器
- en: Server with logging
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带日志的服务器
- en: Server with logging and authentication
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带日志和身份验证的服务器
- en: 'We have to use the `Fscanf` function to retrieve input from the user:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `Fscanf` 函数从用户那里获取输入：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `Fscanf` function needs an `io.Reader`  implementor as the first argument
    (which is going to be the input in the console), and it takes the server selected
    by the user from it. We'll pass `os.Stdin` as the `io.Reader` interface to retrieve
    user input. Then, we'll write the type of data it is going to parse. The `%d` specifier
    refers to an integer number. Finally, we'll write memory direction to store the
    parsed input, in this case, the memory position of the `selection` variable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fscanf` 函数需要一个 `io.Reader` 实现者作为第一个参数（这将是控制台中的输入），它从用户选择的服务器中获取服务器。我们将传递 `os.Stdin`
    作为 `io.Reader` 接口以检索用户输入。然后，我们将写入要解析的数据类型。`%d` 说明符指的是一个整数。最后，我们将写入存储解析输入的内存方向，在这种情况下，是
    `selection` 变量的内存位置。'
- en: 'Once the user selects an option, we can take the basic server and decorate
    it at runtime, switching over to the selected option:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了选项，我们可以在运行时装饰基本服务器，切换到所选选项：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first option will be handled by the default `switch` option--a plain `MyServer`.
    In the case of the second option, we decorate a plain server with logging. The
    third Option is a bit more developed--we ask the user for a username and a password
    using `Fscanf` again. Note that you can scan more than one input, as we are doing
    to retrieve the user and the password. Then, we take the basic server, decorate
    it with authentication, and finally, with logging.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项将由默认的`switch`选项处理--一个普通的`MyServer`。在第二个选项的情况下，我们使用日志装饰一个普通服务器。第三个选项更复杂一些--我们再次使用`Fscanf`请求用户输入用户名和密码。请注意，你可以扫描多个输入，正如我们这样做来获取用户名和密码。然后，我们取基本服务器，用身份验证装饰它，最后，用日志装饰。
- en: If you follow the indentation of the nested types of option three, the request
    passes through the logger, then the authentication middleware, and finally, the `MyServer`
    argument if everything is okay. The requests will follow the same route.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循选项三嵌套类型的缩进，请求将通过记录器，然后是身份验证中间件，最后，如果一切正常，将通过`MyServer`参数。请求将遵循相同的路径。
- en: 'The end of the main function takes the decorated handler, and launches the
    server on the `8080` port:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数的末尾获取装饰后的处理程序，并在`8080`端口启动服务器：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So, let''s launch the server with the third option:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们使用第三个选项来启动服务器：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will first test the plain server by choosing the first option. Run the server
    with the command **go run server_decorator.go**, and select the first option.
    Then, in a different Terminal, run the basic request with curl, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过选择第一个选项来测试普通服务器。使用命令**go run server_decorator.go**运行服务器，并选择第一个选项。然后，在另一个终端中，使用curl运行基本请求，如下所示：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Uh, oh! It doesn''t give us access. We haven''t passed any user and password,
    so it tells us that we cannot continue. Let''s try with some random user and password:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！它没有给我们权限。我们没有传递任何用户名和密码，所以它告诉我们无法继续。让我们尝试使用一些随机的用户名和密码：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'No access! We can also check in the Terminal where we launched the server and
    where every request is being logged:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 没有权限！我们也可以检查在终端中启动服务器的地方以及每个请求被记录的地方：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, enter the correct username and password:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输入正确的用户名和密码：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here we are! Our request has also been logged, and the server has granted access
    to us. Now we can improve our server as much as we want by writing more middlewares
    to decorate the server's functionality.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到了！我们的请求也被记录了，服务器也授予了我们权限。现在我们可以通过编写更多的中间件来装饰服务器的功能，尽可能多地改进我们的服务器。
- en: A few words about Go's structural typing
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Go的结构化类型的一些话
- en: Go has a feature that most people dislike at the beginning--structural typing.
    This is when your structure defines your type without explicitly writing it. For
    example, when you implement an interface, you don't have to write explicitly that
    you are actually implementing it, contrary to languages such as Java where you
    have to write the keyword `implements`. If your method follows the signature of
    the interface, you are actually implementing the interface. This can also lead
    to accidental implementations of interface, something that could provoke an impossible-to-track
    mistake, but that is very unlikely.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个大多数人一开始都不喜欢的特性--结构化类型。这是当你的结构定义了你的类型而不需要明确写出它的时候。例如，当你实现一个接口时，你不需要明确写出你实际上正在实现它，与Java等语言不同，在这些语言中你必须写出关键字`implements`。如果你的方法遵循接口的签名，你实际上就是在实现接口。这也可能导致意外实现接口，这可能会引起难以追踪的错误，但这种情况非常不可能。
- en: 'However, structural typing also allows you to define an interface after defining
    their implementers. Imagine a `MyPrinter` struct as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结构化类型也允许你在定义实现者之后定义接口。想象一下以下`MyPrinter`结构体：
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Imagine we have been working with the `MyPrinter` type for few months now,
    but it didn''t implement any interface, so it can''t be a possible candidate for
    a Decorator pattern, or maybe it can? What if we wrote an interface that matches
    its `Print` method after a few months? Consider the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们已经与`MyPrinter`类型工作了数月，但它没有实现任何接口，所以它不可能是一个装饰器模式的可能候选者，或者也许它可以？如果我们几个月后编写了一个与它的`Print`方法匹配的接口呢？考虑以下代码片段：
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It actually implements the `Printer` interface, and we can use it to create
    a Decorator solution.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它实现了`Printer`接口，我们可以用它来创建一个装饰器解决方案。
- en: Structural typing allows a lot of flexibility when writing programs. If you
    don't know whether a type should be a part of an interface or not, you can leave
    it and add the interface later, when you are completely sure about it. This way,
    you can decorate types very easily and with little modification in your source
    code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型在编写程序时提供了很大的灵活性。如果你不确定一个类型是否应该是接口的一部分，你可以先将其留出，并在你完全确定后再添加接口。这样，你可以非常容易地装饰类型，并且对源代码的修改很小。
- en: Summarizing the Decorator design pattern - Proxy versus Decorator
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结装饰器设计模式 - 代理与装饰器
- en: You might be wondering, what's the difference between the Decorator pattern
    and the Proxy pattern? In the Decorator pattern, we decorate a type dynamically.
    This means that the decoration may or may not be there, or it may be composed
    of one or many types. If you remember, the Proxy pattern wraps a type in a similar
    fashion, but it does so at compile time and it's more like a way to access some
    type.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，装饰器模式和代理模式有什么区别？在装饰器模式中，我们动态地装饰一个类型。这意味着装饰可能存在也可能不存在，或者它可能由一个或多个类型组成。如果你记得，代理模式以类似的方式封装类型，但它是在编译时进行的，更像是一种访问某些类型的方式。
- en: At the same time, a decorator might implement the entire interface that the
    type it decorates also implements **or not**. So you can have an interface with
    10 methods and a decorator that just implements one of them and it will still
    be valid. A call on a method not implemented by the decorator will be passed to
    the decorated type. This is a very powerful feature but also very prone to undesired
    behaviors at runtime if you forget to implement any interface method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，装饰器可能实现被装饰类型所实现的整个接口，也可能不实现。因此，你可以有一个包含10个方法的接口和一个只实现其中之一的方法的装饰器，它仍然有效。对装饰器未实现的方法的调用将被传递给被装饰的类型。这是一个非常强大的功能，但如果你忘记实现任何接口方法，在运行时可能会出现不期望的行为。
- en: In this aspect, you may think that the Proxy pattern is less flexible, and it
    is. But the Decorator pattern is weaker, as you could have errors at runtime,
    which you can avoid at compile time by using the Proxy pattern. Just keep in mind
    that the Decorator is commonly used when you want to add functionality to an object
    at runtime, like in our web server. It's a compromise between what you need and
    what you want to sacrifice to achieve it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方面，你可能认为代理模式不太灵活，确实如此。但装饰器模式较弱，因为你可能会在运行时遇到错误，而通过使用代理模式，你可以在编译时避免这些错误。只需记住，装饰器通常用于在运行时向对象添加功能，比如在我们的Web服务器中。这是在需求和为了实现它而愿意牺牲的东西之间的折衷。
- en: Facade design pattern
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观设计模式
- en: The next pattern we'll see in this chapter is the Facade pattern. When we discussed
    the Proxy pattern, you got to know that it was a way to wrap an type to hide some
    of its features of complexity from the user. Imagine that we group many proxies
    in a single point such as a file or a library. This could be a Facade pattern.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要看到的下一个模式是外观模式。当我们讨论代理模式时，你已经了解到它是一种封装类型以隐藏其部分复杂特性的方法。想象一下，我们将许多代理组合在一个单独的点，比如一个文件或一个库。这可以被视为一个外观模式。
- en: Description
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: A facade, in architectural terms, is the front wall that hides the rooms and
    corridors of a building. It protects its inhabitants from cold and rain, and provides
    them privacy. It orders and divides the dwellings.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在建筑术语中，外观是隐藏建筑房间和走廊的前墙。它保护其居民免受寒冷和雨水的侵袭，并为他们提供隐私。它组织和划分住宅。
- en: The Facade design pattern does the same, but in our code. It shields the code
    from unwanted access, orders some calls, and hides the complexity scope from the
    user.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 外观设计模式在代码中做的是同样的事情。它保护代码免受不想要的访问，组织一些调用，并从用户那里隐藏复杂性范围。
- en: Objectives
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: You use Facade when you want to hide the complexity of some tasks, especially
    when most of them share utilities (such as authentication in an API). A library
    is a form of facade, where someone has to provide some methods for a developer
    to do certain things in a friendly way. This way, if a developer needs to use
    your library, he doesn't need to know all the inner tasks to retrieve the result
    he/she wants.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想隐藏某些任务的复杂性时，你会使用外观模式，尤其是当这些任务大多数共享一些实用工具（如API中的认证）时。库是一种外观形式，其中有人必须为开发者提供一些方法，以便以友好的方式完成某些事情。这样，如果开发者需要使用你的库，他/她不需要知道所有内部任务来获取他/她想要的结果。
- en: 'So, you use the Facade design pattern in the following scenarios:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你会在以下场景中使用外观设计模式：
- en: When you want to decrease the complexity of some parts of our code. You hide
    that complexity behind the facade by providing a more easy-to-use method.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要降低我们代码中某些部分的复杂性时。你通过提供一个更易于使用的方法来隐藏这种复杂性。
- en: When you want to group actions that are cross-related in a single place.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要在一个地方组合相关的操作时。
- en: When you want to build a library so that others can use your products without
    worrying about how it all works.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要构建一个库，以便其他人可以使用你的产品而无需担心它是如何工作的。
- en: Example
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: As an example, we are going to take the first steps toward writing our own library
    that accesses `OpenWeatherMaps` service. In case you are not familiar with `OpenWeatherMap`
    service, it is an HTTP service that provides you with live information about weather,
    as well as historical data on it. The **HTTP REST** API is very easy to use, and
    will be a good example on how to create a Facade pattern for hiding the complexity
    of the network connections behind the REST service.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以为例，我们将迈出编写我们自己的库的第一步，该库可以访问 `OpenWeatherMaps` 服务。如果你不熟悉 `OpenWeatherMap` 服务，它是一个提供实时天气信息以及历史数据的
    HTTP 服务。**HTTP REST** API 非常易于使用，并将是一个很好的示例，说明如何创建一个外观模式来隐藏 REST 服务背后的网络连接复杂性。
- en: Acceptance criteria
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'The `OpenWeatherMap` API gives lots of information, so we are going to focus
    on getting live weather data in one city in some geo-located place by using its
    latitude and longitude values. The following are the requirements and acceptance
    criteria for this design pattern:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenWeatherMap` API 提供了大量信息，因此我们将专注于通过使用其纬度和经度值来获取某个地理位置上的一个城市的实时天气数据。以下是这个设计模式的必要条件和验收标准：'
- en: Provide a single type to access the data. All information retrieved from `OpenWeatherMap` service
    will pass through it.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个单一的类型来访问数据。从 `OpenWeatherMap` 服务检索的所有信息都将通过它传递。
- en: Create a way to get the weather data for some city of some country.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一种获取某个国家某个城市天气数据的方法。
- en: Create a way to get the weather data for some latitude and longitude position.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一种获取某个纬度和经度位置天气数据的方法。
- en: Only second and thrird point must be visible outside of the package; everything
    else must be hidden (including all connection-related data).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有第二点和第三点必须在外部包中可见；其他所有内容都必须隐藏（包括所有连接相关数据）。
- en: Unit test
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To start with our API Facade, we will need an interface with the methods asked
    in *acceptance criteria 2* and *acceptance criteria 3*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的 API 外观，我们需要一个具有 *验收标准 2* 和 *验收标准 3* 中要求的方法的接口：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We will call *acceptance criteria 2* `GetByCityAndCountryCode`; we will also
    need a city name and a country code in the string format. A country code is a
    two-character code, which represents the **International Organization for Standardization**
    (**ISO**) name of world countries. It returns a `Weather` value, which we will
    define later, and an error if something goes wrong.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 *验收标准 2* 命名为 `GetByCityAndCountryCode`；我们还需要一个城市名称和一个字符串格式的国家代码。国家代码是两个字符的代码，代表世界国家的
    **国际标准化组织** (**ISO**) 名称。它返回一个 `Weather` 值，我们将在稍后定义，如果出现问题，它将返回一个错误。
- en: '*Acceptance criteria 3* will be called `GetByGeoCoordinates`, and will need
    latitude and longitude values in the `float32` format. It will also return a `Weather`
    value and an error. The `Weather` value is going to be defined according to the
    returned JSON that the `OpenWeatherMap` API works with. You can find the description
    of this JSON at the webpage [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*验收标准 3* 将被命名为 `GetByGeoCoordinates`，它需要 `float32` 格式的纬度和经度值。它还将返回一个 `Weather`
    值和一个错误。`Weather` 值将根据 `OpenWeatherMap` API 返回的 JSON 定义。你可以在网页 [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON)
    上找到这个 JSON 的描述。'
- en: 'If you look at the JSON definition, it has the following type:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 JSON 定义，它具有以下类型：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It''s quite a long struct, but we have everything that a response could include.
    The struct is called `Weather`, as it is composed of an ID, a name and a Code
    (`Cod`), and a few anonymous structs, which are: `Coord`, `Weather`, `Base`, `Main`,
    `Wind`, `Clouds`, `Rain`, `Dt`, and `Sys`. We could write these anonymous structs
    outside of the `Weather` struct by giving them a name, but it would only be useful
    if we have to work with them separately.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的结构体，但我们包含了响应可能包含的一切。这个结构体被称为`Weather`，因为它由一个ID、一个名称和一个代码（`Cod`）以及几个匿名结构体组成，这些结构体是：`Coord`、`Weather`、`Base`、`Main`、`Wind`、`Clouds`、`Rain`、`Dt`和`Sys`。我们可以通过给它们一个名字将这两个匿名结构体写在外部的`Weather`结构体之外，但只有在我们需要单独处理它们时才有用。
- en: After every member and struct within our `Weather` struct, you can find a ``
    `json:"something"` `` line. This comes in handy when differentiating between the
    JSON key name and your member name. If the JSON key is `something`, we aren't
    forced to call our member `something`. For example, our ID member will be called
    `id` in the JSON response.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Weather`结构体中的每个成员和结构体之后，你都可以找到一个` `` `json:"something"` `` `行。这在区分JSON键名和你的成员名时很有用。如果JSON键是`something`，我们不必强迫我们的成员被称为`something`。例如，我们的ID成员在JSON响应中将被称为`id`。
- en: 'Why don''t we give the name of the JSON keys to our types? Well, if your fields
    in your type are lowercase, the `encoding/json` package won''t parse them correctly.
    Also, that last annotation provides us a certain flexibility, not only in terms
    of changing the members'' names, but also of omitting some key if we don''t need
    it, with the following signature:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不给我们类型中的JSON键命名呢？好吧，如果你的类型字段是小写的，`encoding/json`包将无法正确解析它们。此外，最后一个注解为我们提供了一定的灵活性，不仅在于更改成员的名称，还在于如果我们不需要某些键，我们可以省略它们，以下是其签名：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With `omitempty` at the end, the parse won't fail if this key is not present
    in the bytes representation of the JSON key.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾加上`omitempty`，如果这个键不在JSON键的字节表示中，解析不会失败。
- en: 'Okay, our acceptance criteria 1 ask for a single point of access to the API.
    This is going to be called `CurrentWeatherData`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的验收标准1要求API的单一点访问。这将被称为`CurrentWeatherData`：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `CurrentWeatherData` type has an API key as public member to work. This
    is because you have to be a registered user in `OpenWeatherMap` to enjoy their
    services. Refer to the `OpenWeatherMap` API's webpage for documentation on how
    to get an API key. We won't need it in our example, because we aren't going to
    do integration tests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentWeatherData`类型有一个作为公共成员的API密钥来工作。这是因为你必须成为`OpenWeatherMap`的注册用户才能享受他们的服务。请参阅`OpenWeatherMap`
    API的网页以获取有关如何获取API密钥的文档。在我们的示例中我们不需要它，因为我们不会进行集成测试。'
- en: 'We need mock data so that we can write a `mock` function to retrieve the data.
    When sending an HTTP request, the response is contained in a member called body
    in the form of an `io.Reader`. We have already worked with types that implement
    the `io.Reader` interface, so this should look familiar to you. Our `mock` function
    appears like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要模拟数据，以便我们可以编写一个`mock`函数来检索数据。在发送HTTP请求时，响应以`io.Reader`形式包含在一个名为`body`的成员中。我们已经与实现了`io.Reader`接口的类型一起工作过，所以这应该对你来说很熟悉。我们的`mock`函数看起来是这样的：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This preceding mocked data was produced by making a request to `OpenWeatherMap`
    using an API key. The `response` variable is a string containing a JSON response.
    Take a close look at the grave accent (`` ` ``) used to open and close the string.
    This way, you can use as many quotes as you want without any problem.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟数据是通过使用API密钥向`OpenWeatherMap`发出请求生成的。`response`变量是一个包含JSON响应的字符串。仔细观察用来打开和关闭字符串的重音符（``
    ` ``）。这样，你可以使用任意多的引号而不会出现任何问题。
- en: Further on, we use a special function in the bytes package called `NewReader`,
    which accepts an slice of bytes (which we create by converting the type from string),
    and returns an `io.Reader` implementor with the contents of the slice. This is
    perfect to mimic the `Body` member of an HTTP response.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们在bytes包中使用了一个特殊函数`NewReader`，它接受一个字节数组（我们通过将类型从字符串转换创建），并返回一个包含数组内容的`io.Reader`实现者。这完美地模仿了HTTP响应的`Body`成员。
- en: 'We will write a test to try `response parser`. Both methods return the same
    type, so we can use the same `JSON parser` for both:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个测试来尝试`response parser`。两种方法返回相同类型，所以我们可以为两者使用相同的`JSON parser`：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding test, we first asked for some mock data, which we store in
    the variable `r`. Later, we created a type of `CurrentWeatherData`, which we called
    `openWeatherMap`. Finally, we asked for a weather value for the provided `io.Reader` interface
    that we store in the variable `weather`. After checking for errors, we make sure
    that the ID is the same as the one stored in the mock data that we got from the
    `getMockData` method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们首先请求了一些模拟数据，我们将其存储在变量 `r` 中。后来，我们创建了一个名为 `openWeatherMap` 的 `CurrentWeatherData`
    类型。最后，我们为提供的 `io.Reader` 接口请求了天气值，我们将其存储在变量 `weather` 中。在检查错误后，我们确保 ID 与我们从 `getMockData`
    方法获得的模拟数据中的 ID 相同。
- en: 'We have to declare the `responseParser` method before running tests, or the
    code won''t compile:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，我们必须声明 `responseParser` 方法，否则代码将无法编译：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With all the aforementioned, we can run this test:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有上述内容的基础上，我们可以运行这个测试：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Okay. We won't write more tests, because the rest would be merely integration
    tests, which are outside of the scope of explanation of a structural pattern,
    and will force us to have an API key as well as an Internet connection. If you
    want to see what the integration tests look like for this example, refer to the
    code that comes bundled with the book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们不会编写更多的测试，因为剩下的将仅仅是集成测试，这超出了结构模式解释的范围，并且将迫使我们拥有一个 API 密钥以及互联网连接。如果你想看到这个示例的集成测试是什么样的，请参考书中附带的相关代码。
- en: Implementation
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'First of all, we are going to implement the parser that our methods will use
    to parse the JSON response from the `OpenWeatherMap` REST API:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现我们的方法将使用的解析器，以解析来自 `OpenWeatherMap` REST API 的 JSON 响应：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And this should be enough to pass the test by now:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该足以通过测试：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'At least we have our parser well tested. Let''s structure our code to look
    like a library. First, we will create the methods to retrieve the weather of a
    city by its name and its country code, and the method that uses its latitude and
    longitude:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们的解析器已经得到了很好的测试。让我们将代码结构化，使其看起来像是一个库。首先，我们将创建通过城市名称和国家代码获取城市天气的方法，以及使用其纬度和经度的方法：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: A piece of cake? Of course! Everything must be as easy as possible, and it is
    a sign of a good job. The complexity in this facade is to create connections to
    the `OpenWeatherMap` API, and control the possible errors. This problem is shared
    between all the Facade methods in our example, so we don't need to write more
    than one API call right now.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一件小菜一碟？当然！一切必须尽可能简单，这是好工作的标志。在这个外观背后的复杂性是创建到 `OpenWeatherMap` API 的连接和控制可能的错误。这个问题在我们示例的所有
    Facade 方法之间是共享的，所以我们现在不需要编写超过一个 API 调用。
- en: 'What we do is pass the URL that the REST API needs in order to return the information
    we desire. This is achieved by the `fmt.Sprintf` function, which formats the strings
    in each case. For example, to gather the data using a city name and a country
    code, we use the following string:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是传递 REST API 需要的 URL 以返回我们所需的信息。这是通过 `fmt.Sprintf` 函数实现的，它为每种情况格式化字符串。例如，要使用城市名称和国家代码收集数据，我们使用以下字符串：
- en: '[PRE71]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This takes the pre-formatted string [https://openweathermap.org/api](https://openweathermap.org/api)
    and formats it by replacing each `%s` specifier with the city, the `countryCode`
    that we introduced in the arguments, and the API key member of the `CurrentWeatherData`
    type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用预先格式化的字符串 [https://openweathermap.org/api](https://openweathermap.org/api)
    并通过将每个 `%s` 指示符替换为城市、我们在参数中引入的 `countryCode` 以及 `CurrentWeatherData` 类型的 API key
    成员来格式化它。
- en: But, we haven't set any API key! Yes, because this is a library, and the users
    of the library will have to use their own API keys. We are hiding the complexity
    of creating the URIs, and handling the errors.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们还没有设置任何 API 密钥！是的，因为这是一个库，库的用户将必须使用他们自己的 API 密钥。我们正在隐藏创建 URI 和处理错误的复杂性。
- en: 'Finally, the `doRequest` function is a big fish, so we will see it in detail,
    step by step:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`doRequest` 函数是一个大问题，所以我们将逐步详细地查看它：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: First, the signature tells us that the `doRequest` method accepts a URI string,
    and returns a pointer to the `Weather` variable and an error. We start by creating
    an `http.Client` class, which will make the requests. Then, we create a request
    object, which will use the `GET` method, as described in the `OpenWeatherMap`
    webpage, and the URI we passed. If we were to use a different method, or more
    than one, they would have to be brought about by arguments in the signature. Nevertheless,
    we will use just the `GET` method, so we could hardcode it there.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，签名告诉我们`doRequest`方法接受一个URI字符串，并返回指向`Weather`变量的指针和一个错误。我们首先创建一个`http.Client`类，它将发起请求。然后，我们创建一个请求对象，它将使用`GET`方法，正如`OpenWeatherMap`网页上所描述的，以及我们传递的URI。如果我们使用不同的方法，或者使用多个方法，它们必须通过签名中的参数来实现。然而，我们将只使用`GET`方法，所以我们可以在那里硬编码它。
- en: 'Then, we check whether the request object has been created successfully, and
    set a header that says that the content type is a JSON:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查请求对象是否已成功创建，并设置一个表示内容类型为JSON的头部：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Then we make the request, and check for errors. Because we have given names
    to our return types, if any error occurs, we just have to return the function,
    and Go will return the variable `err` and the variable `weather` in the state
    they were in at that precise moment.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们发起请求，并检查是否有错误。因为我们已经为返回类型命名了，如果发生任何错误，我们只需返回函数，Go将返回变量`err`和变量`weather`在那一刻的状态。
- en: 'We check the status code of the response, as we only accept 200 as a good response.
    If 200 isn''t returned, we will create an error message with the contents of the
    body and the status code returned:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查响应的状态码，因为我们只接受200作为良好的响应。如果返回的不是200，我们将创建一个包含正文内容和返回状态码的错误消息：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Finally, if everything goes well, we use the `responseParser` function we wrote
    earlier to parse the contents of Body, which is an `io.Reader` interface. Maybe
    you are wondering why we aren't controlling `err` from the `response parser` method.
    It's funny, because we are actually controlling it. `responseParser` and `doRequest`
    have the same return signature. Both return a `Weather` pointer and an error (if
    any), so we can return directly whatever the result was.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，我们使用我们之前编写的`responseParser`函数来解析Body的内容，它是一个`io.Reader`接口。你可能想知道为什么我们不是从`response
    parser`方法中控制`err`。这很有趣，因为我们实际上是在控制它。`responseParser`和`doRequest`有相同的返回签名。两者都返回一个`Weather`指针和一个错误（如果有），所以我们可以直接返回任何结果。
- en: Library created with the Facade pattern
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外观模式创建的库
- en: 'We have the first milestone for a library for the `OpenWeatherMap` API using
    the facade pattern. We have hidden the complexity of accessing the `OpenWeatherMap`
    REST API in the `doRequest` and `responseParser` functions, and the users of our
    library have an easy-to-use syntax to query the API. For example, to retrieve
    the weather for Madrid, Spain, a user will only have to introduce arguments and
    an API key at the beginning:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用外观模式为`OpenWeatherMap` API创建了一个库的第一个里程碑。我们已经将访问`OpenWeatherMap` REST API的复杂性隐藏在`doRequest`和`responseParser`函数中，我们的库用户有一个易于使用的语法来查询API。例如，要检索西班牙马德里的天气，用户只需在开始时输入参数和一个API密钥：
- en: '[PRE75]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The console output for the weather in Madrid at the moment of writing this
    chapter is the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 编写此章节时马德里天气的控制台输出如下：
- en: '[PRE76]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A typical summer day!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的夏日！
- en: Flyweight design pattern
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元设计模式
- en: Our next pattern is the **Flyweight** design pattern. It's very commonly used
    in computer graphics and the video game industry, but not so much in enterprise
    applications.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个模式是**享元**设计模式。它在计算机图形和视频游戏行业中非常常用，但在企业应用中并不那么常见。
- en: Description
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: Flyweight is a pattern which allows sharing the state of a heavy object between
    many instances of some type. Imagine that you have to create and store too many
    objects of some heavy type that are fundamentally equal. You'll run out of memory
    pretty quickly. This problem can be easily solved with the Flyweight pattern,
    with additional help of the Factory pattern. The factory is usually in charge
    of encapsulating object creation, as we saw previously.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 享元是一种模式，它允许在许多实例之间共享重型对象的某些类型的状态。想象一下，你必须创建和存储太多本质上相同的一些重型对象。你很快就会耗尽内存。这个问题可以通过享元模式以及工厂模式的额外帮助轻松解决。工厂通常负责封装对象创建，正如我们之前所看到的。
- en: Objectives
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: Thanks to the Flyweight pattern, we can share all possible states of objects
    in a single common object, and thus minimize object creation by using pointers
    to already created objects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了享元模式，我们可以在单个公共对象中共享所有可能的对象状态，从而通过使用指向已创建对象的指针来最小化对象创建。
- en: Example
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: To give an example, we are going to simulate something that you find on betting
    webpages. Imagine the final match of the European championship, which is viewed
    by millions of people across the continent. Now imagine that we own a betting
    webpage, where we provide historical information about every team in Europe. This
    is plenty of information, which is usually stored in some distributed database,
    and each team has, literally, megabytes of information about their players, matches,
    championships, and so on.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们将模拟你在投注网页上找到的东西。想象一下欧洲锦标赛的决赛，整个大陆有成千上万的人观看。现在想象一下我们拥有一个投注网页，我们提供关于欧洲每个团队的历史信息。这是大量的信息，通常存储在一些分布式数据库中，每个团队都有关于他们的球员、比赛、锦标赛等等的数兆字节信息。
- en: If a million users access information about a team and a new instance of the
    information is created for each user querying for historical data, we will run
    out of memory in the blink of an eye. With our Proxy solution, we could make a
    cache of the *n* most recent searches to speed up queries, but if we return a
    clone for every team, we will still get short on memory (but faster thanks to
    our cache). Funny, right?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一百万用户访问关于一个团队的信息，并且为每个查询历史数据的用户创建一个新的信息实例，我们将在一瞬间耗尽内存。有了我们的代理解决方案，我们可以缓存最近的
    *n* 次搜索以加快查询速度，但如果我们为每个团队返回一个克隆，我们仍然会内存不足（但得益于我们的缓存会更快）。有趣，对吧？
- en: Instead, we will store each team's information just once, and we will deliver
    references to them to the users. So, if we face a million users trying to access
    information about a match, we will actually just have two teams in memory with
    a million pointers to the same memory direction.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将只存储每个团队的信息一次，并将向用户交付它们的引用。因此，如果我们面临一百万用户试图访问关于比赛的信息，实际上我们只有两个团队在内存中，并且有一百万个指向相同内存方向的指针。
- en: Acceptance criteria
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'The acceptance criteria for a Flyweight pattern must always reduce the amount
    of memory that is used, and must be focused primarily on this objective:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式的接受标准必须始终减少使用的内存量，并且必须主要关注这个目标：
- en: We will create a `Team` struct with some basic information such as the team's
    name, players, historical results, and an image depicting their shield.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个包含一些基本信息（如团队名称、球员、历史结果和描述他们盾牌的图像）的 `Team` 结构体。
- en: We must ensure correct team creation (note the word *creation* here, candidate
    for a creational pattern), and not having duplicates.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保正确创建团队（注意这里的词 *creation*，是创建模式的候选词），并且没有重复。
- en: When creating the same team twice, we must have two pointers pointing to the
    same memory address.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两次创建相同的团队时，我们必须有两个指针指向相同的内存地址。
- en: Basic structs and tests
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本结构体和测试
- en: 'Our `Team` struct will contain other structs inside, so a total of four structs
    will be created. The `Team` struct has the following signature:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Team` 结构体将包含其他结构体，因此总共将创建四个结构体。`Team` 结构体具有以下签名：
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Each team has an ID, a name, some image in an slice of bytes representing the
    team''s shield, a slice of players, and a slice of historical data. This way,
    we will have two teams'' ID:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队都有一个 ID、一个名称、一些表示团队盾牌的字节切片中的图像、一个玩家切片和一个历史数据切片。这样，我们将有两个团队的 ID：
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We declare two constants by using the `const` and `iota` keywords. The `const` keyword
    simply declares that the following declarations are constants. `iota` is a untyped
    integer that automatically increments its value for each new constant between
    the parentheses. The `iota` value starts to reset to 0 when we declare `TEAM_A`,
    so `TEAM_A` is equal to 0\. On the `TEAM_B` variable, `iota` is incremented by
    one so `TEAM_B` is equal to 1\. The `iota` assignment is an elegant way to save
    typing when declaring constant values that doesn't need specific value (like the *Pi*
    constant on the `math` package).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `const` 和 `iota` 关键字声明了两个常量。`const` 关键字简单地声明以下声明是常量。`iota` 是一个无类型的整数，它会在括号中的每个新常量之间自动增加其值。当我们声明
    `TEAM_A` 时，`iota` 的值会重置为 0，因此 `TEAM_A` 等于 0。在 `TEAM_B` 变量上，`iota` 增加了一个，所以 `TEAM_B`
    等于 1。`iota` 赋值是声明不需要特定值（如 `math` 包中的 *Pi* 常量）的常量值时的简洁方式。
- en: 'Our `Player` and `HistoricalData` are the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Player` 和 `HistoricalData` 如下：
- en: '[PRE79]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you can see, we also need a `Match` struct, which is stored within `HistoricalData` struct.
    A `Match` struct, in this context, represents the historical result of a match:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们还需要一个`Match`结构体，它存储在`HistoricalData`结构体中。在这个上下文中，`Match`结构体代表比赛的记录结果：
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is enough to represent a team, and to fulfill *Acceptance Criteria 1*.
    You have probably guessed that there is a lot of information on each team, as
    some of the European teams have existed for more than 100 years.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以表示一个团队，并满足*验收标准1*。你可能已经猜到，每个团队都有很多信息，因为一些欧洲团队已经存在了100多年。
- en: 'For *Acceptance Criteria 2,* the word *creation* should give us some clue about
    how to approach this problem. We will build a factory to create and store our
    teams. Our Factory will consist of a map of years, including pointers to `Teams`
    as values, and a `GetTeam` function. Using a map will boost the team search if
    we know their names in advance. We will also dispose of a method to return the
    number of created objects, which will be called the `GetNumberOfObjects` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*验收标准2*，单词*创建*应该给我们一些关于如何解决这个问题的一些线索。我们将构建一个工厂来创建和存储我们的团队。我们的工厂将包括一个年份的映射，其中包含指向`Teams`的指针作为值，以及一个`GetTeam`函数。如果我们事先知道他们的名字，使用映射将提高团队搜索的效率。我们还将提供一个方法来返回创建的对象数量，这个方法将被称为`GetNumberOfObjects`方法：
- en: '[PRE81]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is enough to write our first unit test:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以编写我们的第一个单元测试：
- en: '[PRE82]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In our test, we verify all the acceptance criteria. First we create a factory,
    and then ask for a pointer of `TEAM_A`. This pointer cannot be `nil`, or the test
    will fail.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们验证所有验收标准。首先我们创建一个工厂，然后请求`TEAM_A`的指针。这个指针不能为`nil`，否则测试将失败。
- en: Then we call for a second pointer to the same team. This pointer can't be nil
    either, and it should point to the same memory address as the previous one so
    we know that it has not allocated a new memory.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用指向同一团队的第二个指针。这个指针也不能为空，它应该指向与上一个指针相同的内存地址，这样我们才知道它没有分配新的内存。
- en: 'Finally, we should check whether the number of created teams is only one, because
    we have asked for the same team twice. We have two pointers but just one instance
    of the team. Let''s run the tests:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该检查创建的团队数量是否只有一个，因为我们请求了同一个团队两次。我们有两个指针，但只有一个团队的实例。让我们运行测试：
- en: '[PRE83]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Well, it failed. Both pointers were nil and it has not created any object. Interestingly,
    the function that compares the two pointers doesn't fail; all in all, nil equals
    nil.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它失败了。两个指针都是`nil`，它没有创建任何对象。有趣的是，比较两个指针的函数并没有失败；总的来说，`nil`等于`nil`。
- en: Implementation
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现方式
- en: 'Our `GetTeam` method will need to scan the `map` field called `createdTeams`
    to make sure the queried team is already created, and return it if so. If the
    team wasn''t created, it will have to create it and store it in the map before
    returning:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GetTeam`方法需要扫描名为`createdTeams`的`map`字段，以确保查询的团队已经创建，如果已经创建，则返回它。如果团队尚未创建，它必须在返回之前创建它并将其存储在映射中：
- en: '[PRE84]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding code is very simple. If the parameter name exists in the `createdTeams`
    map, return the pointer. Otherwise, call a factory for team creation. This is
    interesting enough to stop for a second and analyze. When you use the Flyweight
    pattern, it is very common to have a Flyweight factory, which uses other types
    of creational patterns to retrieve the objects it needs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常简单。如果参数名称存在于`createdTeams`映射中，则返回指针。否则，调用工厂进行团队创建。这足以让我们停下来分析一下。当你使用Flyweight模式时，非常常见的是有一个Flyweight工厂，它使用其他类型的创建模式来检索它需要的对象。
- en: 'So, the `getTeamFactory` method will give us the team we are looking for, we
    will store it in the map, and return it. The team factory will be able to create
    the two teams: `TEAM_A` and `TEAM_B`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`getTeamFactory`方法将给我们我们正在寻找的团队，我们将它在映射中存储，并返回它。团队工厂将能够创建两个团队：`TEAM_A`和`TEAM_B`：
- en: '[PRE85]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We are simplifying the objects'' content so that we can focus on the Flyweight
    pattern''s implementation. Okay, so we just have to define the function to retrieve
    the number of objects created, which is done as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简化了对象的内容，以便我们可以专注于Flyweight模式的实现。好吧，所以我们只需要定义一个函数来检索创建的对象数量，如下所示：
- en: '[PRE86]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This was pretty easy. The `len` function returns the number of elements in
    an array or slice, the number of characters in a `string`, and so on. It seems
    that everything is done, and we can launch our tests again:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。`len`函数返回数组或切片中的元素数量，字符串中的字符数量等等。看起来一切都已经完成，我们可以再次启动测试：
- en: '[PRE87]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Panic! Have we forgotten something? By reading the stack trace on the panic
    message, we can see some addresses, some files, and it seems that the `GetTeam`
    method is trying to assign an entry to a nil map on *line 71* of the `flyweight.go`
    file. Let''s look at *line 71* closely (remember, if you are writing code while
    following this tutorial, that the error will probably be in a different line so
    look closely at your own stark trace):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Okay, this line is on the `GetTeam` method, and, when the method passes through
    here, it means that it had not found the team on the map-it has created it (the
    variable team), and is trying to assign it to the map. But the map is nil, because
    we haven''t initialized it when creating the factory. This has a quick solution.
    In our test, initialize the map where we have created the factory:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'I''m sure you have seen the problem here already. If we don''t have access
    to the package, we can initialize the variable. Well, we can make the variable
    public, and that''s all. But this would involve every implementer necessarily
    knowing that they have to initialize the map, and its signature is neither convenient,
    or elegant. Instead, we are going to create a simple factory builder to do it
    for us. This is a very common approach in Go:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'So now, in the test, we replace the factory creation with a call to this function:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And we run the test again:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Perfect! Let''s improve the test by adding a second test, just to ensure that
    everything will be running as expected with more volume. We are going to create
    a million calls to the team creation, representing a million calls from users.
    Then, we will simply check that the number of teams created is only two:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In this test, we retrieve `TEAM_A` and `TEAM_B` 500,000 times each to reach
    a million users. Then, we make sure that just two objects were created:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Perfect! We can even check where the pointers are pointing to, and where they
    are located. We will check with the first three as an example. Add these lines
    at the end of the last test, and run it again:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In the preceding test, we use the `Printf` method to print information about
    pointers. The `%p` flag gives you the memory location of the object that the pointer
    is pointing to. If you reference the pointer by passing the `&` symbol, it will
    give you the direction of the pointer itself.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test again with the same command; you will see three new lines in the
    output with information similar to the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: What it tells us is that the first three positions in the map point to the same
    location, but that we actually have three different pointers, which are, effectively,
    much lighter than our team object.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between Singleton and Flyweight then?
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, the difference is subtle but it's just there. With the Singleton pattern,
    we ensure that the same type is created only once. Also, the Singleton pattern
    is a Creational pattern. With Flyweight, which is a Structural pattern, we aren't
    worried about how the objects are created, but about how to structure a type to
    contain heavy information in a light way. The structure we are talking about is
    the `map[int]*Team` structure in our example. Here, we really didn't care about
    how we created the object; we have simply written an uncomplicated the `getTeamFactory` method
    for it. We gave major importance to having a light structure to hold a shareable
    object (or objects), in this case, the map.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen several patterns to organize code structures. Structural patterns
    are concerned about how to create objects, or how they do their business (we'll
    see this in the behavioral patterns).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Don't feel confused about mixing several patterns. You could end up mixing six
    or seven quite easily if you strictly follow the objectives of each one. Just
    keep in mind that over-engineering is as bad as no engineering at all. I remember
    prototyping a load balancer one evening, and after two hours of crazy over-engineered
    code, I had such a mess in my head that I preferred to start all over again.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see behavioral patterns. They are a bit more complex,
    and they often use Structural and Creational patterns for their objectives, but
    I'm sure that the reader will find them quite challenging and interesting.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
