- en: Chapter 4. Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design
    Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we will finish with the Structural patterns. We have left
    some of the most complex ones till the end so that you get more used to the mechanics
    of design patterns, and the features of Go language.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will work at writing a cache to access a database, a library
    to gather weather data, a server with runtime middleware, and discuss a way to
    save memory by saving shareable states between the types values.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start the final chapter on structural patterns with the Proxy pattern.
    It's a simple pattern that provides interesting features and possibilities with
    very little effort.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Proxy pattern usually wraps an object to hide some of its characteristics.
    These characteristics could be the fact that it is a remote object (remote proxy),
    a very heavy object such as a very big image or the dump of a terabyte database
    (virtual proxy), or a restricted access object (protection proxy).
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The possibilities of the Proxy pattern are many, but in general, they all try
    to provide the same following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Hide an object behind the proxy so the features can be hidden, restricted, and
    so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a new abstraction layer that is easy to work with, and can be changed
    easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example, we are going to create a remote proxy, which is going to be
    a cache of objects before accessing a database. Let's imagine that we have a database
    with many users, but instead of accessing the database each time we want information
    about a user, we will have a **First In First Out** (**FIFO**) stack of users
    in a Proxy pattern (FIFO is a way of saying that when the cache needs to be emptied,
    it will delete the first object that entered first).
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will wrap an imaginary database, represented by a slice, with our Proxy
    pattern. Then, the pattern will have to stick to the following acceptance criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: All accesse to the database of users will be done through the Proxy type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stack of `n` number of recent users will be kept in the Proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a user already exists in the stack, it won't query the database, and will
    return the stored one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the queried user doesn't exist in the stack, it will query the database,
    remove the oldest user in the stack if it's full, store the new one, and return
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since version 1.7 of Go, we can embed tests within tests by using closures so
    we can group them in a more human-readable way, and reduce the number of `Test_`
    functions. Refer to [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!") , *Ready... Steady... Go!* to learn how to
    install the new version of Go if your current version is older than version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types for this pattern will be the proxy user and user list structs as
    well as a `UserFinder` interface that the database and the Proxy will implement.
    This is key because the Proxy must implement the same interfaces as the features
    of the type it tries to wrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserFinder` is the interface that the database and the Proxy implement.
    The `User` is a type with a member called `ID`, which is `int32` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `UserList` is a type of a slice of users. Consider the following
    syntax for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you are asking why we aren't using a slice of users directly, the answer
    is that by declaring a sequence of users this way, we can implement the `UserFinder`
    interface but with a slice, we can't.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Proxy type, called `UserListProxy` will be composed of a `UserList`
    slice, which will be our database representation. The `StackCache` members which
    will also be of `UserList` type for simplicity, `StackCapacity` to give our stack
    the size we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cheat a bit for the purpose of this tutorial and declare a Boolean
    state on a field called `DidDidLastSearchUsedCache` that will hold if the last
    performed search has used the cache, or has accessed the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `UserListProxy` type will cache a maximum of `StackCapacity` users, and
    rotate the cache if it reaches this limit. The `StackCache` members will be populated
    from objects from `SomeDatabase` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test is called `TestUserListProxy`, and is listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test creates a user list of 1 million users with random names.
    To do so, we feed the random number generator by calling the `Seed()` function
    with some constant seed so our randomized results are also constant; and the user
    IDs are generated from it. It might have some duplicates, but it serves our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a proxy with a reference to `someDatabase`, which we have just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have a `proxy` object composed of a mock database with 1 million
    users, and a cache implemented as a FIFO stack with a size of 2\. Now we will
    get three random IDs from `someDatabase` to use in our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We took the fourth, fifth, and sixth IDs from the slice (remember that arrays
    and slices start with 0, so the index 3 is actually the fourth position in the
    slice).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is going to be our starting point before launching the embedded tests.
    To create an embedded test, we have to call the `Run` method of the `testing.T`
    pointer, with a description and a closure with the `func(t *testing.T)` signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we check whether the returned user has the same ID as that of the expected
    user at index 0 of the `knownIDs` slice, and that the proxy cache now has a size
    of 1\. The state of the member `DidLastSearchUsedCache` proxy must not be `true`,
    or we will not pass the test. Remember, this member tells us whether the last
    search has been retrieved from the slice that represents a database, or from the
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second embedded test for the Proxy pattern is to ask for the same user
    as before, which must now be returned from the cache. It''s very similar to the
    previous test, but now we have to check if the user is returned from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, again we ask for the first known ID. The proxy cache must maintain a size
    of 1 after this search, and the `DidLastSearchUsedCache` member must be true this
    time, or the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last test will overflow the `StackCache` array on the `proxy` type. We
    will search for two new users that our `proxy` type will have to retrieve from
    the database. Our stack has a size of 2, so it will have to remove the first user
    to allocate space for the second and third users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have retrieved the first three users. We aren't checking for errors because
    that was the purpose of the previous tests. This is important to recall that there
    is no need to over-test your code. If there is any error here, it will arise in
    the previous tests. Also, we have checked that the `user2` and `user3` queries
    do not use the cache; they shouldn't be stored there yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to look for the `user1` query in the Proxy. It shouldn''t
    exist, as the stack has a size of 2, and `user1` was the first to enter, hence,
    the first to go out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't matter if we ask for a thousand users; our cache can't be bigger
    than our configured size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to again range over the users stored in the cache, and
    compare them with the last two we queried. This way, we will check that just those
    users are stored in the cache. Both must be found on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the tests now should give some errors, as usual. Let''s run them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, let's implement the `FindUser` method to act as our Proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our Proxy, the `FindUser` method will search for a specified ID in the cache
    list. If it finds it, it will return the ID. If not, it will search in the database.
    Finally, if it's not in the database list, it will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, our Proxy pattern is composed of two `UserList` types (one
    of them a pointer), which are actually slices of `User` type. We will implement
    a `FindUser` method in `User` type too, which, by the way, has the same signature
    as the `UserFinder` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `FindUser` method in the `UserList` slice will iterate over the list to
    try and find a user with the same ID as the `id` argument, or return an error
    if it can't find it.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the pointer `t` is between parentheses. This is to
    dereference the underlying array before accessing its indexes. Without it, you'll
    have a compilation error, because the compiler tries to search the index before
    dereferencing the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first part of the proxy `FindUser` method can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use the preceding method to search for a user in the `StackCache` member.
    The error will be nil if it can find it, so we check this to print a message to
    the console, change the state of `DidLastSearchUsedCache` to `true` so that the
    test can check whether the user was retrieved from cache, and finally, return
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if the error was not nil, it means that it couldn''t find the user in the
    stack. So, the next step is to search in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can reuse the `FindUser` method we wrote for `UserList` database in this
    case, because both have the same type for the purpose of this example. Again,
    it searches the user in the database represented  by the `UserList` slice, but
    in this case, if the user isn't found, it returns the error generated in `UserList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user is found (`err` is nil), we have to add the user to the stack.
    For this purpose, we write a dedicated private method that receives a pointer
    of type `UserListProxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addUserToStack` method takes the user argument, and adds it to the stack
    in place. If the stack is full, it removes the first element in it before adding.
    We have also written an `addUser` method to `UserList` to help us in this. So,
    now in `FindUser` method, we just have to add one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This adds the new user to the stack, removing the last if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we just have to return the new user of the stack, and set the appropriate
    value on `DidLastSearchUsedCache` variable. We also write a message to the console
    to help in the testing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have enough to pass our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding messages that our Proxy has worked flawlessly.
    It has returned the first search from the database. Then, when we search for the
    same user again, it uses the cache. Finally, we made a new test that calls three
    different users and we can observe, by looking at the console output, that just
    the first was returned from the cache and that the other two were fetched from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying around actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wrap proxies around types that need some intermediate action, like giving authorization
    to the user or providing access to a database, like in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Our example is a good way to separate application needs from database needs.
    If our application accesses the database too much, a solution for this is not
    in your database. Remember that the Proxy uses the same interface as the type
    it wraps, and, for the user, there shouldn't be any difference between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll continue this chapter with the big brother of the Proxy pattern, and maybe,
    one of the most powerful design patterns of all. The **Decorator** pattern is
    pretty simple, but, for instance, it provides a lot of benefits when working with
    legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator design pattern allows you to decorate an already existing type
    with more functional features without actually touching it. How is it possible?
    Well, it uses an approach similar to *matryoshka dolls*, where you have a small
    doll that you can put inside a doll of the same shape but bigger, and so on and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator type implements the same interface of the type it decorates, and
    stores an instance of that type in its members. This way, you can stack as many
    decorators (dolls) as you want by simply storing the old decorator in a field
    of the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you think about extending legacy code without the risk of breaking something,
    you should think of the Decorator pattern first. It's a really powerful approach
    to deal with this particular problem.
  prefs: []
  type: TYPE_NORMAL
- en: A different field where the Decorator is very powerful may not be so obvious
    though it reveals itself when creating types with lots of features based on user
    inputs, preferences, or similar inputs. Like in a Swiss knife, you have a base
    type (the frame of the knife), and from there you unfold its functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, precisely when are we going to use the Decorator pattern? Answer to this
    question:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to add functionality to some code that you don't have access to,
    or you don't want to modify to avoid a negative effect on the code, and follow
    the open/close principle (like legacy code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want the functionality of an object to be created or altered dynamically,
    and the number of features is unknown and could grow fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we will prepare a `Pizza` type, where the core is the pizza
    and the ingredients are the decorating types. We will have a couple of ingredients
    for our pizza-onion and meat.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The acceptance criteria for a Decorator pattern is to have a common interface
    and a core type, the one that all layers will be built over:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have the main interface that all decorators will implement. This interface
    will be called `IngredientAdd`, and it will have the `AddIngredient() string`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a core `PizzaDecorator` type (the decorator) that we will add ingredients
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have an ingredient "onion"  implementing the same `IngredientAdd` interface
    that will add the string `onion` to the returned pizza.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a ingredient "meat" implementing the `IngredientAdd` interface
    that will add the string `meat` to the returned pizza.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When calling `AddIngredient` method on the top object, it must return a fully
    decorated `pizza` with the text `Pizza with the following ingredients: meat, onion`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To launch our unit tests, we must first create the basic structures described
    in accordance with the acceptance criteria. To begin with, the interface that
    all decorating types must implement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code defines the `PizzaDecorator` type, which must have `IngredientAdd`
    inside, and which implements `IngredientAdd` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `Meat` type will be very similar to that of the  `PizzaDecorator` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define the `Onion` struct in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to implement the first unit test, and to allow the compiler
    to run them without any compiling errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it must compile without problems, so we can check that the test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first test is done, and we can see that the `PizzaDecorator` struct isn''t
    returning anything yet, that''s why it fails. We can now move on to the `Onion`
    type. The test of the `Onion` type is quite similar to that of the `Pizza` decorator,
    but we must also make sure that we actually add the ingredient to the `IngredientAdd` method
    and not to a nil pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first half of the preceding test examines the returning error when no `IngredientAdd` method
    is passed to the `Onion` struct initializer. As no pizza is available to add the
    ingredient, an error must be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The second part of the `Onion` type test actually passes `PizzaDecorator` structure
    to the initializer. Then, we check whether no error is being returned, and also
    whether the returning string contains the word `onion` in it. This way, we can
    ensure that onion has been added to the pizza.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally for the `Onion` type, the console output of this test with our current
    implementation will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `meat` ingredient is exactly the same, but we change the type to meat instead
    of onion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the result of the tests will be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must check the full stack test. Creating a pizza with onion and
    meat must return the text `Pizza with the following ingredients: meat, onion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test creates a variable called `pizza` which, like the m*atryoshka dolls*,
    embeds types of the `IngredientAdd` method in several levels. Calling the `AddIngredient`
    method executes the method at the "onion" level, which executes the "meat" one,
    which, finally, executes that of the `PizzaDecorator` struct. After checking that
    no error had been returned, we check whether the returned text follows the needs
    of the *acceptance criteria 5*. The tests are run with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that the tests now return an empty string
    for our decorated type. This is, of course, because no implementation has been
    done yet. This was the last test to check the fully decorated implementation.
    Let's look closely at the implementation then.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start implementing the `PizzaDecorator` type. Its role is to
    provide the initial text of the full pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A single line change on the return of the `AddIngredient` method was enough
    to pass the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the `Onion` struct implementation, we must take the beginning
    of our `IngredientAdd` returned string, and add the word `onion` at the end of
    it in order to get a composed pizza in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking that we actually have a pointer to `IngredientAdd` first, we use the
    contents of the inner `IngredientAdd`, and check it for errors. If no errors occur,
    we receive a new string composed of this content, a space, and the word `onion`
    (and no errors). Looks good enough to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementation of the `Meat` struct is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And here goes their test execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. So, now all the pieces are to be tested separately. If everything is
    okay, the test of the *full stacked* solution must be passing smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! With the Decorator pattern, we could keep stacking `IngredientAdds`
    which call their inner pointer to add functionality to `PizzaDecorator`. We aren't
    touching the core type either, nor modifying or implementing new things. All the
    new features are implemented by an external type.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example - server middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should have understood how the Decorator pattern works. Now we can
    try a more advanced example using the small HTTP server that we designed in the
    Adapter pattern section. You learned that an HTTP server can be created by using
    the `http` package, and implementing the `http.Handler` interface. This interface
    has only one method called `ServeHTTP(http.ResponseWriter, http.Request)`. Can
    we use the Decorator pattern to add more functionality to a server? Of course!
  prefs: []
  type: TYPE_NORMAL
- en: We will add a couple of pieces to this server. First, we are going to log every
    connection made to it to the `io.Writer` interface (for the sake of simplicity,
    we'll use the `io.Writer` implementation of the `os.Stdout` interface so that
    it outputs to the console). The second piece will add basic HTTP authentication
    to every request made to the server. If the authentication passes, a `Hello Decorator!` message
    will appear. Finally, the user will be able to select the number of decoration
    items that he/she wants in the server, and the server will be structured and created
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the common interface, http.Handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already have the common interface that we will decorate using nested types.
    We first need to create our core type, which is going to be the `Handler` that
    returns the sentence `Hello Decorator!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler can be attributed to the `http.Handle` method to define our first
    endpoint. Let''s check this now by creating the package''s `main` function, and
    sending a `GET` request to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the server using the Terminal to execute the  `**go run main.go**`
    command. Then, open a new Terminal to make the `GET` request. We''ll use the `curl`
    command to make our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We have crossed the first milestone of our decorated server. The next step
    is to decorate it with logging capabilities. To do so, we must implement the `http.Handler`
    interface, in a new type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We call this type `LoggerServer`. As you can see, it stores not only a `Handler`,
    but also `io.Writer` to write the output of the log. Our implementation of the
    `ServeHTTP` method prints the request URI, the host, the content length, and the
    used method `io.Writer`. Once printing is finished, it calls the `ServeHTTP` function
    of its inner `Handler` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decorate `MyServer` with this `LoggerMiddleware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the `**curl **`  command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Our **curl** command returns the same message, but if you look at the Terminal
    where you have run the Go application, you can see the logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We have decorated `MyServer` with logging capabilities without actually modifying
    it. Can we do the same with authentication? Of course! After logging the request,
    we will authenticate it by using **HTTP Basic Authentication** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The **BasicAuthMiddleware** middleware stores three fields--a handler to decorate
    like in the previous middlewares, a user, and a password, which will be the only
    authorization to access the contents on the server. The implementation of the
    `decorating` method will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implementation, we use the `BasicAuth` method from `http.Request`
    to automatically retrieve the user and password from the request, plus an `ok/ko`
    from the parsing action. Then we check whether the parsing is correct (returning
    a message to the requester if incorrect, and finishing the request). If no problems
    have been detected during parsing, we check whether the username and the password
    match with the ones stored in `BasicAuthMiddleware`. If the credentials are valid,
    we shall call the decorated type (our server), but if the credentials aren't valid,
    we receive the `User or password incorrect` message in return, and the request
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to provide the user with a way to choose among different types
    of servers. We will retrieve user input data in the main function. We''ll have
    three options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging and authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to use the `Fscanf` function to retrieve input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `Fscanf` function needs an `io.Reader`  implementor as the first argument
    (which is going to be the input in the console), and it takes the server selected
    by the user from it. We'll pass `os.Stdin` as the `io.Reader` interface to retrieve
    user input. Then, we'll write the type of data it is going to parse. The `%d` specifier
    refers to an integer number. Finally, we'll write memory direction to store the
    parsed input, in this case, the memory position of the `selection` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user selects an option, we can take the basic server and decorate
    it at runtime, switching over to the selected option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first option will be handled by the default `switch` option--a plain `MyServer`.
    In the case of the second option, we decorate a plain server with logging. The
    third Option is a bit more developed--we ask the user for a username and a password
    using `Fscanf` again. Note that you can scan more than one input, as we are doing
    to retrieve the user and the password. Then, we take the basic server, decorate
    it with authentication, and finally, with logging.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the indentation of the nested types of option three, the request
    passes through the logger, then the authentication middleware, and finally, the `MyServer`
    argument if everything is okay. The requests will follow the same route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end of the main function takes the decorated handler, and launches the
    server on the `8080` port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s launch the server with the third option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first test the plain server by choosing the first option. Run the server
    with the command **go run server_decorator.go**, and select the first option.
    Then, in a different Terminal, run the basic request with curl, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh, oh! It doesn''t give us access. We haven''t passed any user and password,
    so it tells us that we cannot continue. Let''s try with some random user and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'No access! We can also check in the Terminal where we launched the server and
    where every request is being logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enter the correct username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here we are! Our request has also been logged, and the server has granted access
    to us. Now we can improve our server as much as we want by writing more middlewares
    to decorate the server's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A few words about Go's structural typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go has a feature that most people dislike at the beginning--structural typing.
    This is when your structure defines your type without explicitly writing it. For
    example, when you implement an interface, you don't have to write explicitly that
    you are actually implementing it, contrary to languages such as Java where you
    have to write the keyword `implements`. If your method follows the signature of
    the interface, you are actually implementing the interface. This can also lead
    to accidental implementations of interface, something that could provoke an impossible-to-track
    mistake, but that is very unlikely.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, structural typing also allows you to define an interface after defining
    their implementers. Imagine a `MyPrinter` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine we have been working with the `MyPrinter` type for few months now,
    but it didn''t implement any interface, so it can''t be a possible candidate for
    a Decorator pattern, or maybe it can? What if we wrote an interface that matches
    its `Print` method after a few months? Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It actually implements the `Printer` interface, and we can use it to create
    a Decorator solution.
  prefs: []
  type: TYPE_NORMAL
- en: Structural typing allows a lot of flexibility when writing programs. If you
    don't know whether a type should be a part of an interface or not, you can leave
    it and add the interface later, when you are completely sure about it. This way,
    you can decorate types very easily and with little modification in your source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the Decorator design pattern - Proxy versus Decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be wondering, what's the difference between the Decorator pattern
    and the Proxy pattern? In the Decorator pattern, we decorate a type dynamically.
    This means that the decoration may or may not be there, or it may be composed
    of one or many types. If you remember, the Proxy pattern wraps a type in a similar
    fashion, but it does so at compile time and it's more like a way to access some
    type.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, a decorator might implement the entire interface that the
    type it decorates also implements **or not**. So you can have an interface with
    10 methods and a decorator that just implements one of them and it will still
    be valid. A call on a method not implemented by the decorator will be passed to
    the decorated type. This is a very powerful feature but also very prone to undesired
    behaviors at runtime if you forget to implement any interface method.
  prefs: []
  type: TYPE_NORMAL
- en: In this aspect, you may think that the Proxy pattern is less flexible, and it
    is. But the Decorator pattern is weaker, as you could have errors at runtime,
    which you can avoid at compile time by using the Proxy pattern. Just keep in mind
    that the Decorator is commonly used when you want to add functionality to an object
    at runtime, like in our web server. It's a compromise between what you need and
    what you want to sacrifice to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: Facade design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next pattern we'll see in this chapter is the Facade pattern. When we discussed
    the Proxy pattern, you got to know that it was a way to wrap an type to hide some
    of its features of complexity from the user. Imagine that we group many proxies
    in a single point such as a file or a library. This could be a Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A facade, in architectural terms, is the front wall that hides the rooms and
    corridors of a building. It protects its inhabitants from cold and rain, and provides
    them privacy. It orders and divides the dwellings.
  prefs: []
  type: TYPE_NORMAL
- en: The Facade design pattern does the same, but in our code. It shields the code
    from unwanted access, orders some calls, and hides the complexity scope from the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use Facade when you want to hide the complexity of some tasks, especially
    when most of them share utilities (such as authentication in an API). A library
    is a form of facade, where someone has to provide some methods for a developer
    to do certain things in a friendly way. This way, if a developer needs to use
    your library, he doesn't need to know all the inner tasks to retrieve the result
    he/she wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you use the Facade design pattern in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to decrease the complexity of some parts of our code. You hide
    that complexity behind the facade by providing a more easy-to-use method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to group actions that are cross-related in a single place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to build a library so that others can use your products without
    worrying about how it all works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example, we are going to take the first steps toward writing our own library
    that accesses `OpenWeatherMaps` service. In case you are not familiar with `OpenWeatherMap`
    service, it is an HTTP service that provides you with live information about weather,
    as well as historical data on it. The **HTTP REST** API is very easy to use, and
    will be a good example on how to create a Facade pattern for hiding the complexity
    of the network connections behind the REST service.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OpenWeatherMap` API gives lots of information, so we are going to focus
    on getting live weather data in one city in some geo-located place by using its
    latitude and longitude values. The following are the requirements and acceptance
    criteria for this design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a single type to access the data. All information retrieved from `OpenWeatherMap` service
    will pass through it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a way to get the weather data for some city of some country.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a way to get the weather data for some latitude and longitude position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only second and thrird point must be visible outside of the package; everything
    else must be hidden (including all connection-related data).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with our API Facade, we will need an interface with the methods asked
    in *acceptance criteria 2* and *acceptance criteria 3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We will call *acceptance criteria 2* `GetByCityAndCountryCode`; we will also
    need a city name and a country code in the string format. A country code is a
    two-character code, which represents the **International Organization for Standardization**
    (**ISO**) name of world countries. It returns a `Weather` value, which we will
    define later, and an error if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '*Acceptance criteria 3* will be called `GetByGeoCoordinates`, and will need
    latitude and longitude values in the `float32` format. It will also return a `Weather`
    value and an error. The `Weather` value is going to be defined according to the
    returned JSON that the `OpenWeatherMap` API works with. You can find the description
    of this JSON at the webpage [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the JSON definition, it has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite a long struct, but we have everything that a response could include.
    The struct is called `Weather`, as it is composed of an ID, a name and a Code
    (`Cod`), and a few anonymous structs, which are: `Coord`, `Weather`, `Base`, `Main`,
    `Wind`, `Clouds`, `Rain`, `Dt`, and `Sys`. We could write these anonymous structs
    outside of the `Weather` struct by giving them a name, but it would only be useful
    if we have to work with them separately.'
  prefs: []
  type: TYPE_NORMAL
- en: After every member and struct within our `Weather` struct, you can find a ``
    `json:"something"` `` line. This comes in handy when differentiating between the
    JSON key name and your member name. If the JSON key is `something`, we aren't
    forced to call our member `something`. For example, our ID member will be called
    `id` in the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why don''t we give the name of the JSON keys to our types? Well, if your fields
    in your type are lowercase, the `encoding/json` package won''t parse them correctly.
    Also, that last annotation provides us a certain flexibility, not only in terms
    of changing the members'' names, but also of omitting some key if we don''t need
    it, with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With `omitempty` at the end, the parse won't fail if this key is not present
    in the bytes representation of the JSON key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, our acceptance criteria 1 ask for a single point of access to the API.
    This is going to be called `CurrentWeatherData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `CurrentWeatherData` type has an API key as public member to work. This
    is because you have to be a registered user in `OpenWeatherMap` to enjoy their
    services. Refer to the `OpenWeatherMap` API's webpage for documentation on how
    to get an API key. We won't need it in our example, because we aren't going to
    do integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need mock data so that we can write a `mock` function to retrieve the data.
    When sending an HTTP request, the response is contained in a member called body
    in the form of an `io.Reader`. We have already worked with types that implement
    the `io.Reader` interface, so this should look familiar to you. Our `mock` function
    appears like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This preceding mocked data was produced by making a request to `OpenWeatherMap`
    using an API key. The `response` variable is a string containing a JSON response.
    Take a close look at the grave accent (`` ` ``) used to open and close the string.
    This way, you can use as many quotes as you want without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: Further on, we use a special function in the bytes package called `NewReader`,
    which accepts an slice of bytes (which we create by converting the type from string),
    and returns an `io.Reader` implementor with the contents of the slice. This is
    perfect to mimic the `Body` member of an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a test to try `response parser`. Both methods return the same
    type, so we can use the same `JSON parser` for both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we first asked for some mock data, which we store in
    the variable `r`. Later, we created a type of `CurrentWeatherData`, which we called
    `openWeatherMap`. Finally, we asked for a weather value for the provided `io.Reader` interface
    that we store in the variable `weather`. After checking for errors, we make sure
    that the ID is the same as the one stored in the mock data that we got from the
    `getMockData` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to declare the `responseParser` method before running tests, or the
    code won''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the aforementioned, we can run this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Okay. We won't write more tests, because the rest would be merely integration
    tests, which are outside of the scope of explanation of a structural pattern,
    and will force us to have an API key as well as an Internet connection. If you
    want to see what the integration tests look like for this example, refer to the
    code that comes bundled with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we are going to implement the parser that our methods will use
    to parse the JSON response from the `OpenWeatherMap` REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And this should be enough to pass the test by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'At least we have our parser well tested. Let''s structure our code to look
    like a library. First, we will create the methods to retrieve the weather of a
    city by its name and its country code, and the method that uses its latitude and
    longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: A piece of cake? Of course! Everything must be as easy as possible, and it is
    a sign of a good job. The complexity in this facade is to create connections to
    the `OpenWeatherMap` API, and control the possible errors. This problem is shared
    between all the Facade methods in our example, so we don't need to write more
    than one API call right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we do is pass the URL that the REST API needs in order to return the information
    we desire. This is achieved by the `fmt.Sprintf` function, which formats the strings
    in each case. For example, to gather the data using a city name and a country
    code, we use the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This takes the pre-formatted string [https://openweathermap.org/api](https://openweathermap.org/api)
    and formats it by replacing each `%s` specifier with the city, the `countryCode`
    that we introduced in the arguments, and the API key member of the `CurrentWeatherData`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: But, we haven't set any API key! Yes, because this is a library, and the users
    of the library will have to use their own API keys. We are hiding the complexity
    of creating the URIs, and handling the errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `doRequest` function is a big fish, so we will see it in detail,
    step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: First, the signature tells us that the `doRequest` method accepts a URI string,
    and returns a pointer to the `Weather` variable and an error. We start by creating
    an `http.Client` class, which will make the requests. Then, we create a request
    object, which will use the `GET` method, as described in the `OpenWeatherMap`
    webpage, and the URI we passed. If we were to use a different method, or more
    than one, they would have to be brought about by arguments in the signature. Nevertheless,
    we will use just the `GET` method, so we could hardcode it there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we check whether the request object has been created successfully, and
    set a header that says that the content type is a JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Then we make the request, and check for errors. Because we have given names
    to our return types, if any error occurs, we just have to return the function,
    and Go will return the variable `err` and the variable `weather` in the state
    they were in at that precise moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We check the status code of the response, as we only accept 200 as a good response.
    If 200 isn''t returned, we will create an error message with the contents of the
    body and the status code returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if everything goes well, we use the `responseParser` function we wrote
    earlier to parse the contents of Body, which is an `io.Reader` interface. Maybe
    you are wondering why we aren't controlling `err` from the `response parser` method.
    It's funny, because we are actually controlling it. `responseParser` and `doRequest`
    have the same return signature. Both return a `Weather` pointer and an error (if
    any), so we can return directly whatever the result was.
  prefs: []
  type: TYPE_NORMAL
- en: Library created with the Facade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the first milestone for a library for the `OpenWeatherMap` API using
    the facade pattern. We have hidden the complexity of accessing the `OpenWeatherMap`
    REST API in the `doRequest` and `responseParser` functions, and the users of our
    library have an easy-to-use syntax to query the API. For example, to retrieve
    the weather for Madrid, Spain, a user will only have to introduce arguments and
    an API key at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output for the weather in Madrid at the moment of writing this
    chapter is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: A typical summer day!
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next pattern is the **Flyweight** design pattern. It's very commonly used
    in computer graphics and the video game industry, but not so much in enterprise
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flyweight is a pattern which allows sharing the state of a heavy object between
    many instances of some type. Imagine that you have to create and store too many
    objects of some heavy type that are fundamentally equal. You'll run out of memory
    pretty quickly. This problem can be easily solved with the Flyweight pattern,
    with additional help of the Factory pattern. The factory is usually in charge
    of encapsulating object creation, as we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to the Flyweight pattern, we can share all possible states of objects
    in a single common object, and thus minimize object creation by using pointers
    to already created objects.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To give an example, we are going to simulate something that you find on betting
    webpages. Imagine the final match of the European championship, which is viewed
    by millions of people across the continent. Now imagine that we own a betting
    webpage, where we provide historical information about every team in Europe. This
    is plenty of information, which is usually stored in some distributed database,
    and each team has, literally, megabytes of information about their players, matches,
    championships, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If a million users access information about a team and a new instance of the
    information is created for each user querying for historical data, we will run
    out of memory in the blink of an eye. With our Proxy solution, we could make a
    cache of the *n* most recent searches to speed up queries, but if we return a
    clone for every team, we will still get short on memory (but faster thanks to
    our cache). Funny, right?
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we will store each team's information just once, and we will deliver
    references to them to the users. So, if we face a million users trying to access
    information about a match, we will actually just have two teams in memory with
    a million pointers to the same memory direction.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The acceptance criteria for a Flyweight pattern must always reduce the amount
    of memory that is used, and must be focused primarily on this objective:'
  prefs: []
  type: TYPE_NORMAL
- en: We will create a `Team` struct with some basic information such as the team's
    name, players, historical results, and an image depicting their shield.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must ensure correct team creation (note the word *creation* here, candidate
    for a creational pattern), and not having duplicates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating the same team twice, we must have two pointers pointing to the
    same memory address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basic structs and tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `Team` struct will contain other structs inside, so a total of four structs
    will be created. The `Team` struct has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Each team has an ID, a name, some image in an slice of bytes representing the
    team''s shield, a slice of players, and a slice of historical data. This way,
    we will have two teams'' ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We declare two constants by using the `const` and `iota` keywords. The `const` keyword
    simply declares that the following declarations are constants. `iota` is a untyped
    integer that automatically increments its value for each new constant between
    the parentheses. The `iota` value starts to reset to 0 when we declare `TEAM_A`,
    so `TEAM_A` is equal to 0\. On the `TEAM_B` variable, `iota` is incremented by
    one so `TEAM_B` is equal to 1\. The `iota` assignment is an elegant way to save
    typing when declaring constant values that doesn't need specific value (like the *Pi*
    constant on the `math` package).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Player` and `HistoricalData` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we also need a `Match` struct, which is stored within `HistoricalData` struct.
    A `Match` struct, in this context, represents the historical result of a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This is enough to represent a team, and to fulfill *Acceptance Criteria 1*.
    You have probably guessed that there is a lot of information on each team, as
    some of the European teams have existed for more than 100 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Acceptance Criteria 2,* the word *creation* should give us some clue about
    how to approach this problem. We will build a factory to create and store our
    teams. Our Factory will consist of a map of years, including pointers to `Teams`
    as values, and a `GetTeam` function. Using a map will boost the team search if
    we know their names in advance. We will also dispose of a method to return the
    number of created objects, which will be called the `GetNumberOfObjects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to write our first unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In our test, we verify all the acceptance criteria. First we create a factory,
    and then ask for a pointer of `TEAM_A`. This pointer cannot be `nil`, or the test
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Then we call for a second pointer to the same team. This pointer can't be nil
    either, and it should point to the same memory address as the previous one so
    we know that it has not allocated a new memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should check whether the number of created teams is only one, because
    we have asked for the same team twice. We have two pointers but just one instance
    of the team. Let''s run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Well, it failed. Both pointers were nil and it has not created any object. Interestingly,
    the function that compares the two pointers doesn't fail; all in all, nil equals
    nil.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `GetTeam` method will need to scan the `map` field called `createdTeams`
    to make sure the queried team is already created, and return it if so. If the
    team wasn''t created, it will have to create it and store it in the map before
    returning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very simple. If the parameter name exists in the `createdTeams`
    map, return the pointer. Otherwise, call a factory for team creation. This is
    interesting enough to stop for a second and analyze. When you use the Flyweight
    pattern, it is very common to have a Flyweight factory, which uses other types
    of creational patterns to retrieve the objects it needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `getTeamFactory` method will give us the team we are looking for, we
    will store it in the map, and return it. The team factory will be able to create
    the two teams: `TEAM_A` and `TEAM_B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We are simplifying the objects'' content so that we can focus on the Flyweight
    pattern''s implementation. Okay, so we just have to define the function to retrieve
    the number of objects created, which is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This was pretty easy. The `len` function returns the number of elements in
    an array or slice, the number of characters in a `string`, and so on. It seems
    that everything is done, and we can launch our tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Panic! Have we forgotten something? By reading the stack trace on the panic
    message, we can see some addresses, some files, and it seems that the `GetTeam`
    method is trying to assign an entry to a nil map on *line 71* of the `flyweight.go`
    file. Let''s look at *line 71* closely (remember, if you are writing code while
    following this tutorial, that the error will probably be in a different line so
    look closely at your own stark trace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this line is on the `GetTeam` method, and, when the method passes through
    here, it means that it had not found the team on the map-it has created it (the
    variable team), and is trying to assign it to the map. But the map is nil, because
    we haven''t initialized it when creating the factory. This has a quick solution.
    In our test, initialize the map where we have created the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m sure you have seen the problem here already. If we don''t have access
    to the package, we can initialize the variable. Well, we can make the variable
    public, and that''s all. But this would involve every implementer necessarily
    knowing that they have to initialize the map, and its signature is neither convenient,
    or elegant. Instead, we are going to create a simple factory builder to do it
    for us. This is a very common approach in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, in the test, we replace the factory creation with a call to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And we run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Let''s improve the test by adding a second test, just to ensure that
    everything will be running as expected with more volume. We are going to create
    a million calls to the team creation, representing a million calls from users.
    Then, we will simply check that the number of teams created is only two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we retrieve `TEAM_A` and `TEAM_B` 500,000 times each to reach
    a million users. Then, we make sure that just two objects were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! We can even check where the pointers are pointing to, and where they
    are located. We will check with the first three as an example. Add these lines
    at the end of the last test, and run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we use the `Printf` method to print information about
    pointers. The `%p` flag gives you the memory location of the object that the pointer
    is pointing to. If you reference the pointer by passing the `&` symbol, it will
    give you the direction of the pointer itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test again with the same command; you will see three new lines in the
    output with information similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: What it tells us is that the first three positions in the map point to the same
    location, but that we actually have three different pointers, which are, effectively,
    much lighter than our team object.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between Singleton and Flyweight then?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, the difference is subtle but it's just there. With the Singleton pattern,
    we ensure that the same type is created only once. Also, the Singleton pattern
    is a Creational pattern. With Flyweight, which is a Structural pattern, we aren't
    worried about how the objects are created, but about how to structure a type to
    contain heavy information in a light way. The structure we are talking about is
    the `map[int]*Team` structure in our example. Here, we really didn't care about
    how we created the object; we have simply written an uncomplicated the `getTeamFactory` method
    for it. We gave major importance to having a light structure to hold a shareable
    object (or objects), in this case, the map.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen several patterns to organize code structures. Structural patterns
    are concerned about how to create objects, or how they do their business (we'll
    see this in the behavioral patterns).
  prefs: []
  type: TYPE_NORMAL
- en: Don't feel confused about mixing several patterns. You could end up mixing six
    or seven quite easily if you strictly follow the objectives of each one. Just
    keep in mind that over-engineering is as bad as no engineering at all. I remember
    prototyping a load balancer one evening, and after two hours of crazy over-engineered
    code, I had such a mess in my head that I preferred to start all over again.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see behavioral patterns. They are a bit more complex,
    and they often use Structural and Creational patterns for their objectives, but
    I'm sure that the reader will find them quite challenging and interesting.
  prefs: []
  type: TYPE_NORMAL
