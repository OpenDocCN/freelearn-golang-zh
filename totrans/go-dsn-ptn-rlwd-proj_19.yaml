- en: Chapter 5. Behavioral Patterns - Strategy, Chain of Responsibility, and Command
    Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。行为模式 - 策略、责任链和命令设计模式
- en: The last group of common patterns we are going to see are the behavioral patterns.
    Now, we aren't going to define structures or encapsulate object creation but we
    are going to deal with behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的最后一组常见模式是行为模式。现在，我们不会定义结构或封装对象创建，而是将处理行为。
- en: What's to deal with in behavior patterns? Well, now we will encapsulate behaviors,
    for example, algorithms in the Strategy pattern or executions in the command pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为模式中我们需要处理什么？好吧，现在我们将使用策略模式封装行为，例如算法或命令模式中的执行。
- en: Correct Behavior design is the last step after knowing how to deal with object
    creation and structures. Defining the behavior correctly is the last step of good
    software design because, all in all, good software design lets us improve algorithms
    and fix errors easily while the best algorithm implementation will not save us
    from bad software design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的行为设计是在了解如何处理对象创建和结构之后的最后一步。正确定义行为是良好软件设计的最后一步，因为总的来说，良好的软件设计让我们能够轻松地改进算法和修复错误，而最佳的算法实现并不能拯救我们免受糟糕的软件设计的影响。
- en: Strategy design pattern
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Strategy pattern is probably the easiest to understand of the Behavioral
    patterns. We have used it a few times while developing the previous patterns but
    without stopping to talk about it. Now we will.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式可能是行为模式中最容易理解的一个。我们在开发前几个模式时已经使用过它几次，但没有停下来讨论它。现在我们将。
- en: Description
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Strategy pattern uses different algorithms to achieve some specific functionality.
    These algorithms are hidden behind an interface and, of course, they must be interchangeable.
    All algorithms achieve the same functionality in a different way. For example,
    we could have a `Sort` interface and few sorting algorithms. The result is the
    same, some list is sorted, but we could have used quick sort, merge sort, and
    so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式使用不同的算法来实现一些特定的功能。这些算法隐藏在接口后面，当然，它们必须是可互换的。所有算法都以不同的方式实现相同的功能。例如，我们可以有一个
    `Sort` 接口和几种排序算法。结果是相同的，某个列表被排序了，但我们可能使用了快速排序、归并排序等等。
- en: Can you guess when we used a Strategy pattern in the previous chapters? Three,
    two, one... Well, we heavily used the strategy pattern when we used the `io.Writer`
    interface. The `io.Writer` interface defines a strategy to write, and the functionality
    is always the same--to write something. We could write it to the standard out,
    to some file or to a user-defined type, but we do the same thing at the end--to
    write. We just change the strategy to write (in this case, we change the place
    where we write).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到我们在前几章什么时候使用了策略模式吗？三，二，一... 好吧，当我们使用 `io.Writer` 接口时，我们大量使用了策略模式。`io.Writer`
    接口定义了一种写入策略，其功能始终相同——写入某些内容。我们可以将其写入标准输出、某个文件或用户定义的类型，但最终我们做的都是同一件事——写入。我们只是改变了写入的策略（在这种情况下，我们改变了写入的位置）。
- en: Objectives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objectives of the Strategy pattern are really clear. The pattern should
    do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的目标非常明确。该模式应该做到以下几点：
- en: Provide a few algorithms to achieve some specific functionality
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些算法以实现某些特定的功能
- en: All types achieve the same functionality in a different way but the client of
    the strategy isn't affected
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型都以不同的方式实现相同的功能，但策略模式的客户端不受影响
- en: The problem is that this definition covers a huge spectrum of possibilities.
    This is because Strategy pattern is actually used for a variety of scenarios and
    many software engineering solutions come with some kind of strategy within. Therefore
    it's better to see it in action with a real example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个定义涵盖了巨大的可能性范围。这是因为策略模式实际上用于各种场景，许多软件工程解决方案都包含某种策略。因此，最好通过一个真实示例来观察它的实际应用。
- en: Rendering images or text
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染图像或文本
- en: We are going to do something different for this example. Instead of printing
    text on the console only, we are also going to paint objects on a file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将做一些不同的事情。我们不仅要在控制台上打印文本，还要在文件上绘制对象。
- en: 'In this case, we will have two strategies: console and file. But the user of
    the library won''t have to deal with the complexity behind them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有两种策略：控制台和文件。但库的用户不需要处理它们背后的复杂性。
- en: 'The key feature is that the "caller" doesn´t know how the underlying library
    is working and he just knows the information available on the defined strategy.
    This is nicely seen on the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关键特性是“调用者”不知道底层库是如何工作的，他只知道定义的策略上可用的信息。这在上面的图中可以很好地看到：
- en: '![Rendering images or text](img/00031.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![渲染图像或文本](img/00031.jpeg)'
- en: In this diagram, we have chosen to print to console but we won´t deal with the
    **ConsoleStrategy** type directly, we´ll always use an interface that represents
    it. The **ConsoleStrategy** type will hide the implementation details of printing
    to console to caller in `main` function. **FileStrategy** hides its implementation details
    as well as any future strategy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们选择了打印到控制台，但我们不会直接处理**ConsoleStrategy**类型，我们总是使用代表它的接口。**ConsoleStrategy**类型将隐藏打印到控制台的实施细节，在`main`函数中的调用者。**FileStrategy**也隐藏了其实现细节以及任何未来的策略。
- en: Acceptance criteria
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'A strategy must have a very clear objective and we will have two ways to achieve
    it. Our objectives will be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个策略必须有一个非常明确的目标，我们将有两种方式来实现它。我们的目标如下：
- en: Provide a way to show to the user an object (a square) in text or image
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种方式向用户展示一个对象（一个正方形）是文本还是图像
- en: The user must choose between image or text when launching the app
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在启动应用程序时必须在图像或文本之间进行选择
- en: The app must be able to add more visualization strategies (audio, for example)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须能够添加更多的可视化策略（例如音频）
- en: If the user selects text, the word *Square* must be printed in the console
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择文本，必须在控制台上打印单词*Square*
- en: If the user selects image, an image of a white square on a black background
    will be printed on a file
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择图像，将在文件上打印一个白色正方形在黑色背景上的图像
- en: Implementation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We aren''t going to write tests for this example as it will be quite complicated
    to check that an image has appeared on the screen (although not impossible by
    using **OpenCV**, an impressive library for computer vision). We will start directly
    by defining our strategy interface that each printing strategy must implement
    (in our case, the file and console types):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为这个示例编写测试，因为这将是相当复杂的，检查屏幕上是否出现了图像（尽管使用**OpenCV**，一个令人印象深刻的计算机视觉库，并非不可能）。我们将直接定义我们的策略接口，每个打印策略都必须实现（在我们的情况下，文件和控制台类型）：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s all. Our strategy defines a simple `Print()` method that returns an
    `error` (the error-returning type is mandatory when dealing with files, for example).
    The types that needs to implement `PrintStrategy` will be called `ConsoleSquare`
    and a `ImageSquare` type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部。我们的策略定义了一个简单的`Print()`方法，该方法返回一个`error`（在处理文件等时，返回错误类型是强制性的）。需要实现`PrintStrategy`的类型将被称为`ConsoleSquare`和`ImageSquare`类型：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ConsoleSquare` struct doesn''t need any inner field because it will always
    print the word `Square` to the console. The `ImageSquare` struct will store a
    field for the destination of the image file where we will print the square. We
    will start with the implementation of the `ConsoleSquare` type as it is the simplest:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleSquare`结构不需要任何内部字段，因为它总是会打印单词`Square`到控制台。`ImageSquare`结构将存储一个用于打印正方形的图像文件的目标字段。我们将从`ConsoleSquare`类型的实现开始，因为它是最简单的：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Very easy, but the image is more complex. We won''t spend too much time in
    explaining in detail how the `image` package works because the code is easily
    understandable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，但图像更复杂。我们不会花太多时间详细解释`image`包是如何工作的，因为代码很容易理解：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, here is a short explanation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个简短的说明：
- en: We define a size for the image (`width` and `height` variables) of 800 pixels
    of width and 600 pixels of height. Those are going to be the size limits of our
    image and anything that we write outside of that size won't be visible.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个图像的大小（`width`和`height`变量）为800像素宽和600像素高。这些将成为我们图像的大小限制，任何超出这个范围的书写将不可见。
- en: The `origin` variable stores an `image.Point`, a type to represent a position
    in any two-dimensional space. We set the position of this point at *(0, 0)*, the
    upper-left corner of the image.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`origin`变量存储一个`image.Point`，这是一个表示任何二维空间中位置的类型。我们将这个点的位置设置为*(0, 0)*，即图像的左上角。'
- en: We need a bitmap that will represent our background, here we called it `bgImage`.
    We have a very handy function in the image package to create the `image.RGBA`
    types called `image.NewRGBA`. We need to pass a rectangle to this function so
    that it knows the bounds of the image. A rectangle is represented by two `image.Point`
    types--its upper left corner point (the `Min` field) and its lower right corner
    point (the `Max` field). We use `origin` as the upper-left and a new point with
    the values of `width` and `height` as the lower-right point.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个代表我们背景的位图，这里我们称之为 `bgImage`。在图像包中有一个非常方便的函数来创建 `image.RGBA` 类型，称为 `image.NewRGBA`。我们需要传递一个矩形给这个函数，这样它就知道图像的边界。一个矩形由两个
    `image.Point` 类型表示--其上左角点（`Min` 字段）和其下右角点（`Max` 字段）。我们使用 `origin` 作为上左角，并使用具有
    `width` 和 `height` 值的新点作为下右角点。
- en: The image will have a gray background color (`bgColor`). This is done by instancing
    a type of `image.Uniform`, which represents a uniform color (hence the name).
    The `image.Uniform` type needs an instance of a `color.Color` interface. A `color.Color`
    type is any type that implements the `RGBA() (r, g, b, a uint32)`  method to return
    a `uint32` value for red, green, blue, and alpha colors (RGBA). Alpha is a value
    for the transparency of a pixel. The `color` package conveniently provides a type
    called `color.RGBA` for this purpose (in case we don't need to implement our own,
    which is our case).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像将具有灰色背景颜色（`bgColor`）。这是通过实例化一个表示均匀颜色的 `image.Uniform` 类型来完成的（因此得名）。`image.Uniform`
    类型需要一个实现 `RGBA() (r, g, b, a uint32)` 方法的 `color.Color` 接口实例。`color.Color` 类型是任何实现该方法的类型，该方法返回红色、绿色、蓝色和透明度颜色的
    `uint32` 值（RGBA）。Alpha 是像素透明度的值。`color` 包方便地提供了一个名为 `color.RGBA` 的类型用于此目的（以防我们不需要实现自己的，即我们的情况）。
- en: When storing an image in certain formats, we have to specify the quality of
    the image. It will affect not only the quality but the size of the file, of course.
    Here, it is defined as 75; 100 is the maximum quality possible that we can set.
    As you can see, we are using the `jpeg` package here to set the value of a type
    called `Options` that simply stores the value of the quality, it doesn't have
    more values to apply.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当以某些格式存储图像时，我们必须指定图像的质量。它不仅会影响质量，当然也会影响文件的大小。在这里，它被定义为75；100是我们能设置的最大质量。如您所见，我们在这里使用
    `jpeg` 包来设置一个名为 `Options` 的类型的值，它简单地存储质量值，没有更多要应用的价值。
- en: Finally, the `draw.Print` function writes the pixels on the supplied image (`bgImage`)
    with the characteristics that we have defined on the bounds defined by the same
    image. The first argument of the `draw.Print` method takes the destination image,
    where we used `bgImage`. The second argument is the bounds of the object to draw
    in the destination image, we used the same bounds of the image but we could use
    any other if we wanted a smaller rectangle. The third argument is the color to
    use to colorize the bounds. The `Origin` variable is used to tell where the upper-left
    corner of the bound must be placed. In this case, the bounds are the same size
    as the image so we need to set it to the origin. The last argument specified is
    the operation type; just leave it in the `draw.Src` argument.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`draw.Print` 函数将具有我们定义在相同图像边界上的特性的像素写入提供的图像（`bgImage`）。`draw.Print` 方法的第一个参数是目标图像，我们使用了
    `bgImage`。第二个参数是要在目标图像中绘制的对象的边界，我们使用了图像的相同边界，但如果我们想要一个更小的矩形，我们也可以使用任何其他边界。第三个参数是用来着色边界的颜色。`Origin`
    变量用于指定边界的左上角必须放置的位置。在这种情况下，边界的大小与图像相同，因此我们需要将其设置为原点。最后一个指定的参数是操作类型；只需将其保留在 `draw.Src`
    参数中即可。
- en: 'Now we have to draw the square. The operation is essentially the same as to
    draw the background but, in this case, we are drawing a square over the previously
    drawn `bgImage`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须绘制一个正方形。这个操作本质上与绘制背景相同，但在这个情况下，我们是在之前绘制的 `bgImage` 上绘制一个正方形：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The square will be of 200*200 pixels of red color. When using the method `Add`,
    the `Rect` type origin is translated to the supplied point; this is to center
    the square on the image. We create an image with the square `Rect` and call the
    `Print` function on the `bgImage` image again to draw the red square over it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形将是一个200*200像素的红色。当使用 `Add` 方法时，`Rect` 类型的原点会被转换到提供的点；这是为了在图像上居中正方形。我们创建了一个带有正方形
    `Rect` 的图像，并在 `bgImage` 图像上再次调用 `Print` 函数来在其上绘制红色正方形：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we will create a file to store the contents of the image. The file
    will be stored in the path supplied in the `DestinationFilePath` field of the
    `ImageSquare` struct. To create a file, we use `os.Create` that returns the `*os.File`.
    As with every file, it must be closed after using it so don't forget to use the
    `defer` keyword to ensure that you close it when the method finishes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个文件来存储图像的内容。该文件将存储在`ImageSquare`结构体的`DestinationFilePath`字段提供的路径中。为了创建一个文件，我们使用`os.Create`，它返回`*os.File`。与每个文件一样，使用后必须关闭，所以不要忘记使用`defer`关键字来确保在方法结束时关闭它。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To defer, or not to defer?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟执行，还是不延迟执行？
- en: Some people ask why the use of `defer` at all? Wouldn't it be the same to simply
    write it without `defer` at the end of the function? Well, actually not. If any
    error occurs during the method execution and you return this error, the `Close`
    method won't be executed if it's at the end of the function. You can close the
    file before returning but you'll have to do it in every error check. With `defer,`
    you don't have to worry about this because the deferred function is executed always
    (with or without error). This way, we ensure that the file is closed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人问为什么一定要使用`defer`？直接在函数末尾不使用`defer`不是一样吗？实际上不是。如果在方法执行过程中发生错误并返回这个错误，如果它在函数的末尾，`Close`方法将不会执行。你可以在返回之前关闭文件，但你必须在每个错误检查中这样做。使用`defer`，你不必担心这个问题，因为延迟函数总是执行（无论是否有错误）。这样，我们确保文件被关闭。
- en: 'To parse the arguments, we''ll use the `flag` package. We have used it before
    but let''s recall its usage. A flag is a command that the user can pass when executing
    our app. We can define a flag by using the `flag.[type]` methods defined in the
    `flag` package. We want to read the output that the user wants to use from the
    console. This flag will be called `output`. A flag can have a default value; in
    this case, it will have the value `console` that will be used when printing to
    console. So, if the user executes the program without arguments, it prints to
    console:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析参数，我们将使用`flag`包。我们之前已经使用过它，但让我们回顾一下它的用法。标志是一个用户在执行我们的应用程序时可以传递的命令。我们可以通过使用`flag`包中定义的`flag.[type]`方法来定义一个标志。我们希望从控制台读取用户想要使用的输出。这个标志将被称为`output`。一个标志可以有一个默认值；在这种情况下，它将具有用于打印到控制台的值`console`。所以，如果用户在没有参数的情况下执行程序，它将打印到控制台：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our final step is to write the main function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的步骤是编写主函数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember that the first thing to do in the main when using flags is to parse
    them using the `flag.Parse()` method! It''s very common to forget this step:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用标志时，在主函数中首先要做的是使用`flag.Parse()`方法来解析它们！忘记这一步是非常常见的：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We define a variable for the strategy that the user has chosen, called `activeStrategy`.
    But check that the `activeStrategy` variable has the `PrintStrategy` type so it
    can be populated with any implementation of the `PrintStrategy` variable. We will
    set `activeStrategy` to a new instance of `TextSquare` when the user writes the 
    `**--output=console**`  command and an `ImageSquare` when we write the  `**--output=image**`
    command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个变量来存储用户选择的策略，称为`activeStrategy`。但检查一下`activeStrategy`变量是否具有`PrintStrategy`类型，以便它可以填充任何`PrintStrategy`变量的实现。当用户写入`**--output=console**`命令时，我们将`activeStrategy`设置为`TextSquare`的新实例，当我们写入`**--output=image**`命令时，它将是一个`ImageSquare`。
- en: 'Finally, here is the design pattern execution:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是设计模式执行：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `activeStrategy` variable is a type implementing `PrintStrategy` and either
    the `TextSquare` or `ImageSquare` classes. The user will choose at runtime which
    strategy he wants to use for each particular case. Also, we could have written
    a factory method pattern to create strategies, so that the strategy creation will
    also be uncoupled from the main function and abstracted in a different independent
    package. Think about it: if we have the strategy creation in a different package,
    it will also allow us to use this project as a library and not only as a standalone
    app.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`activeStrategy`变量是一个实现`PrintStrategy`类型的类型，或者是`TextSquare`或`ImageSquare`类。用户将在运行时选择他想要为每个特定情况使用的策略。此外，我们还可以编写一个工厂方法模式来创建策略，这样策略的创建也将与主函数解耦，并在不同的独立包中抽象化。想想看：如果我们把策略创建放在不同的包中，这也将允许我们把这个项目作为一个库来使用，而不仅仅是一个独立的程序。
- en: 'Now we will execute both strategies; the `TextSquare` instance will give us
    a square by printing the word `Square` on the console:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行这两个策略；`TextSquare`实例将在控制台上打印单词`Square`来给我们一个正方形：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It has worked as expected. Recalling how flags work, we have to use the `--` (double
    dash) and the defined flag, `output` in our case. Then you have two options--using
    `=` (equals) and immediately writing the value for the flag or writing `<space>`
    and the value for the flag. In this case, we have defined the default value of
    output to the console so the following three executions are equivalent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作。回忆一下标志的工作方式，我们必须使用`--`（双横线）和定义的标志，在我们的例子中是`output`。然后你有两个选项--使用`=`（等于）并立即为标志写入值，或者写入`<space>`和标志的值。在这种情况下，我们已将输出默认值定义为控制台，所以以下三个执行是等效的：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have to try the file strategy. As defined before, the file strategy
    will print a red square to a file as an image with dark gray background:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须尝试文件策略。如前所述，文件策略将以深灰色背景将红色方块打印到文件中，作为一个图像：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Nothing happened? But everything worked correctly. This is actually bad practice.
    Users must always have some sort of feedback when using your app or your library.
    Also, if they are using your code as a library, maybe they have a specific format
    for output so it won't be nice to directly print to the console. We will solve
    this issue later. Right now, open the folder `/tmp` with your favourite file explorer
    and you will see a file called `image.jpg` with our red square in a dark grey
    background.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发生任何事情？但实际上一切工作正常。这实际上是一种不好的做法。用户在使用你的应用程序或库时必须始终有一些形式的反馈。此外，如果他们使用你的代码作为库，他们可能有一个特定的输出格式，所以直接打印到控制台可能不是很好。我们将在稍后解决这个问题。现在，使用你最喜欢的文件浏览器打开文件夹`/tmp`，你会看到一个名为`image.jpg`的文件，其中包含我们的红色方块，背景为深灰色。
- en: Solving small issues in our library
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决我们库中的小问题
- en: 'We have a few issues in our code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码中存在一些问题：
- en: It cannot be used as a library. We have critical code written in the `main`
    package (strategy creation).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能作为一个库使用。我们在`main`包中编写了关键代码（策略创建）。
- en: '**Solution**: Abstract to two different packages the strategy creation from
    the command-line application.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：将命令行应用程序的策略创建抽象为两个不同的包。'
- en: None of the strategies are doing any logging to file or console. We must provide
    a way to read some logs that an external user can integrate in their logging strategies
    or formats.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何策略正在对文件或控制台进行任何日志记录。我们必须提供一个方式，让外部用户可以将其集成到他们的日志策略或格式中。
- en: '**Solution**: Inject an `io.Writer` interface as dependency to act as a logging
    sink.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：注入一个`io.Writer`接口作为依赖项，以充当日志接收器。'
- en: Our `TextSquare` class is always writing to the console (an implementer of the `io.Writer`
    interface) and the `ImageSquare` is always writing to file (another implementer
    of the `io.Writer` interface). This is too coupled.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`TextSquare`类总是写入控制台（`io.Writer`接口的一个实现）和`ImageSquare`总是写入文件（`io.Writer`接口的另一个实现）。这太耦合了。
- en: '**Solution**: Inject an `io.Writer` interface so that the `TextSquare` and
    `ImageSquare` can write to any of the `io.Writer` implementations that are available
    (file and console, but also bytes buffer, binary encoders, `JSON` handlers...
    dozens of packages).'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：注入一个`io.Writer`接口，以便`TextSquare`和`ImageSquare`可以写入任何可用的`io.Writer`实现（文件和控制台，但还包括字节缓冲区、二进制编码器、`JSON`处理器……数十个包）。'
- en: 'So, to use it as a library and solve the first issue, we will follow a common
    approach in Go file structures for apps and libraries. First, we will place our
    main package and function outside of the root package; in this case, in a folder
    called `cli`. It is also common to call this folder `cmd` or even `app`. Then,
    we will place our `PrintStrategy` interface in the root package, which now will
    be called the `strategy` package. Finally, we will create a `shapes` package in
    a folder with the same name where we will put both text and image strategies.
    So, our file structure will be like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将其作为库使用并解决第一个问题，我们将遵循Go文件结构中用于应用程序和库的常见方法。首先，我们将我们的主包和函数放在根包之外；在这种情况下，在一个名为`cli`的文件夹中。通常也把这个文件夹称为`cmd`或甚至`app`。然后，我们将我们的`PrintStrategy`接口放在根包中，现在它将被称为`strategy`包。最后，我们将在一个具有相同名称的文件夹中创建一个`shapes`包，我们将把文本和图像策略都放在这个文件夹中。因此，我们的文件结构将如下所示：
- en: '**Root package**: strategy'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根包**: strategy'
- en: 'File: `print_strategy.go`'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件：`print_strategy.go`
- en: '**SubPackage**: shapes'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子包**: shapes'
- en: 'Files: `image.go`, `text.go`, `factory.go`'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件：`image.go`，`text.go`，`factory.go`
- en: '**SubPackage**: cli'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子包**: cli'
- en: 'File: `main.go`'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件：`main.go`
- en: 'We are going to modify our interface a bit to fit the needs we have written
    previously:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的接口以适应我们之前写下的需求：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have added the `SetLog(io.Writer)` method to add a logger strategy to our
    types; this is to provide feedback to users. Also, it has a `SetWriter` method
    to set the `io.Writer` strategy. This interface is going to be located on the
    root package in the `print_strategy.go` file. So the final schema looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `SetLog(io.Writer)` 方法来为我们的类型添加日志策略；这是为了向用户提供反馈。此外，它还有一个 `SetWriter` 方法来设置
    `io.Writer` 策略。这个接口将位于根包的 `print_strategy.go` 文件中。所以最终的架构看起来像这样：
- en: '![Solving small issues in our library](img/00032.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![解决我们库中的小问题](img/00032.jpeg)'
- en: 'Both the `TextSquare` and `ImageSquare` strategies have to satisfy the `SetLog`
    and `SetWriter` methods which simply store some object on their fields so, instead
    of implementing the same twice, we can create a struct that implements them and
    embed this struct in the strategies. By the way, this would be the composite pattern
    we have seen previously:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextSquare` 和 `ImageSquare` 策略都必须满足 `SetLog` 和 `SetWriter` 方法，这些方法只是简单地在其字段上存储一些对象，因此，为了避免重复实现，我们可以创建一个实现这些方法的结构体，并将这个结构体内嵌在策略中。顺便说一句，这正是我们之前看到的组合模式：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So now each strategy must have the `PrintOutput` struct embedded if we want
    to modify their `Writer` and `logger` fields.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在如果我们要修改它们的 `Writer` 和 `logger` 字段，每个策略都必须内嵌 `PrintOutput` 结构体。
- en: 'We also need to modify our strategy implementation. The `TextSquare` struct now
    needs a field to store the output `io.Writer` (the place where it is going to
    write instead of writing always to the console) and the `log` writer. These two
    fields can be provided by embedding the `PrintOutput` struct. The `TextSquare` struct
    is also stored in the file `text.go` within the shapes package. So, the struct
    is now like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的策略实现。`TextSquare` 结构体现在需要一个字段来存储输出 `io.Writer`（它将要写入的地方，而不是总是写入控制台）和日志写入器。这两个字段可以通过内嵌
    `PrintOutput` 结构体来提供。`TextSquare` 结构体也存储在 `shapes` 包内的 `text.go` 文件中。所以，结构体现在是这样的：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So now the `Print()` method is slightly different because, instead of writing
    directly to the console by using the `println` function, we have to write whichever
    `io.Writer` is stored in the `Writer` field:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在 `Print()` 方法略有不同，因为我们不再直接使用 `println` 函数将内容写入控制台，而是必须写入存储在 `Writer` 字段中的任何
    `io.Writer`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `bytes.NewReader` is a very useful function that takes an array of bytes
    and converts them to an `io.Reader` interface. We need an `io.Reader` interface
    to use the `io.Copy` function. The `io.Copy` function is also incredibly useful
    as it takes an `io.Reader` (as the second parameter) and pipes it to an `io.Writer`
    (its first parameter). So, we won''t return an error in any case. However, it''s
    easier to do so using directly the `Write` method of `t.Writer`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes.NewReader` 是一个非常有用的函数，它接受一个字节数组并将它们转换为 `io.Reader` 接口。我们需要 `io.Reader`
    接口来使用 `io.Copy` 函数。`io.Copy` 函数也非常有用，因为它接受一个 `io.Reader`（作为第二个参数）并将其管道传输到 `io.Writer`（它的第一个参数）。所以，在任何情况下我们都不会返回错误。然而，直接使用
    `t.Writer` 的 `Write` 方法来做会更简单：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can use whichever method you like more. Usually, you will use the `Write`
    method but it's nice to know the `bytes.NewReader` function too.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你喜欢的任何方法。通常，你会使用 `Write` 方法，但了解 `bytes.NewReader` 函数也很好。
- en: Did you realize that when we use `t.Writer`, we are actually accessing `PrintOutput.Writer`?
    The `TextSquare` type has a `Writer` field because the `PrintOutput` struct has
    it and it's embedded on the `TextSquare` struct.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到，当我们使用 `t.Writer` 时，实际上是在访问 `PrintOutput.Writer`？`TextSquare` 类型有一个 `Writer`
    字段，因为 `PrintOutput` 结构体有这个字段，并且它被内嵌在 `TextSquare` 结构体中。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Embedding is not inheritance. We have embedded the `PrintOutput` struct on
    the `TextSquare` struct. Now we can access `PrintOutput` fields as if they were
    in `TextSquare` fields. This feels a bit like inheritance but there is a very
    important difference here: `TextSquare` is not a `PrintOutput` value but it has
    a `PrintOutput` in its composition. What does it mean? That if you have a function
    that expects a `PrintOutput`, you cannot a pass `TextSquare` just because it has
    a `PrintOutput` embedded.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内嵌不是继承。我们在 `TextSquare` 结构体上内嵌了 `PrintOutput` 结构体。现在我们可以像访问 `TextSquare` 字段一样访问
    `PrintOutput` 字段。这感觉有点像继承，但这里有一个非常重要的区别：`TextSquare` 不是一个 `PrintOutput` 值，但它在其组合中有一个
    `PrintOutput`。这意味着如果你有一个期望 `PrintOutput` 的函数，你不能仅仅因为 `TextSquare` 内嵌了 `PrintOutput`
    就传递 `TextSquare`。
- en: But, if you have a function that accepts an interface that `PrintOutput` implements,
    you can pass `TextSquare` if it has a `PrintOutput` embedded. This is what we
    are doing in our example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你有一个接受 `PrintOutput` 实现的接口的函数，你可以传递 `TextSquare` 如果它内嵌了 `PrintOutput`。这正是我们在我们的例子中所做的。
- en: 'The `ImageSquare` struct is now like the `TextSquare`, with a `PrintOutput`
    embedded:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageSquare`结构现在就像`TextSquare`一样，内嵌了`PrintOutput`：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Print` method also needs to be modified. Now, we aren''t creating a file
    from the `Print` method, as it was breaking the single responsibility principle.
    A file implements an `io.Writer` so we will open the file outside of the `ImageSquare`
    struct and inject it on the `Writer` field. So, we just need to modify the end
    of the `Print()` method where we wrote to the file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print`方法也需要修改。现在，我们不再从`Print`方法创建文件，因为这破坏了单一责任原则。文件实现了`io.Writer`接口，所以我们将文件在外部打开，并将其注入到`Writer`字段。所以，我们只需要修改`Print()`方法的末尾，我们之前是写入文件的：'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you check our previous implementation, after using `draw`, you can see that
    we used the `Print` method, we created a file with `os.Create` and passed it to
    the `jpeg.Encode` function. We have deleted this part about creating the file
    and we have replaced it with a check looking for a `Writer` in the fields (`if
    i.Writer != nil`). Then, on `jpeg.Encode` we can replace the file value we were
    using previously with the content of the `i.Writer` field. Finally, we are using
    `io.Copy` again to log some message to the `LogWriter` if a logging strategy is
    provided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查我们的前一个实现，在`draw`之后，你可以看到我们使用了`Print`方法，我们使用`os.Create`创建了一个文件，并将其传递给`jpeg.Encode`函数。我们已经删除了这部分关于创建文件的内容，并用一个检查替换了它，检查字段中的`Writer`（`if
    i.Writer != nil`）。然后，在`jpeg.Encode`中，我们可以用`i.Writer`字段的内容替换我们之前使用的文件值。最后，如果我们提供了日志策略，我们再次使用`io.Copy`来记录一些消息到`LogWriter`。
- en: 'We also have to abstract the knowledge needed from the user to create instances
    of implementors of the `PrintStrategy` for which we are going to use a Factory
    method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须抽象出用户创建`PrintStrategy`实现实例所需的知识，我们将使用工厂方法：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have two constants, one of each of our strategies: `TEXT_STRATEGY` and `IMAGE_STRATEGY`.
    Those are the constants that must be provided to the factory to retrieve each
    square drawer strategy. Our factory method receives an argument `s`, which is
    a string with one of the previous constants.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个常量，每个策略都有一个：`TEXT_STRATEGY`和`IMAGE_STRATEGY`。这些是必须提供给工厂以检索每个方框绘制策略的常量。我们的工厂方法接收一个参数`s`，它是一个包含之前常量之一的字符串。
- en: Each strategy has a `PrintOutput` type embedded with a default logger to `stdout`
    but you can override it later by using the `SetLog(io.Writer)` methods. This approach
    could be considered a Factory of prototypes. If it is not a recognized strategy,
    a proper message error will be returned.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个策略都有一个`PrintOutput`类型内嵌，默认将日志输出到`stdout`，但你可以稍后通过使用`SetLog(io.Writer)`方法来覆盖它。这种方法可以被认为是一个原型的工厂。如果不是已识别的策略，将返回适当的错误信息。
- en: 'What we have now is a library. We have all the functionality we need between
    the `strategy` and `shapes` packages. Now we will write the `main` package and
    function in a new folder called `cli`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个库。我们在`strategy`和`shapes`包之间拥有所需的所有功能。现在我们将编写一个名为`main`的包和函数，在一个名为`cli`的新文件夹中：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, like before, the `main` function starts by parsing the input arguments
    on the console to gather the chosen strategy. We can use the variable output now
    to create a strategy without Factory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，就像之前一样，`main`函数首先解析控制台上的输入参数以收集所选策略。现在我们可以使用变量output来创建一个策略，而不需要Factory：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we will implement the business needs by using our library. For the purpose
    of the `TextStrategy`, we want to write, for example, to `stdout`. For the purpose
    of the image, we will write to `/tmp/image.jpg`. Just like before. So, following
    the previous statements, we can write:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过使用我们的库来实现业务需求。对于`TextStrategy`的目的，我们希望写入，例如，到`stdout`。对于图像的目的，我们将写入到`/tmp/image.jpg`。就像之前一样。所以，根据之前的声明，我们可以写入：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the case of `TEXT_STRATEGY`, we use `SetWriter` to set the `io.Writer` to
    `os.Stdout`. In the case of `IMAGE_STRATEGY`, we create an image in any of our
    folders and pass the file variable to the `SetWriter` method. Remember that `os.File`
    implements the `io.Reader` and `io.Writer` interfaces, so it''s perfectly legal
    to pass it as an `io.Writer` to the `SetWriter` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TEXT_STRATEGY`的情况下，我们使用`SetWriter`来设置`io.Writer`为`os.Stdout`。在`IMAGE_STRATEGY`的情况下，我们在我们的任何一个文件夹中创建一个图像，并将文件变量传递给`SetWriter`方法。记住，`os.File`实现了`io.Reader`和`io.Writer`接口，所以将其作为`io.Writer`传递给`SetWriter`方法是完全合法的：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we call the `Print` method of whichever strategy was chosen by the
    user and check for possible errors. Let''s try the program now:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用用户选择的策略的`Print`方法，并检查可能的错误。现在让我们尝试运行这个程序：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It has worked as expected. What about the image strategy?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作。那么图像策略呢？
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we check in `/tmp/image.jpg`, we can find our red square on the dark background.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `/tmp/image.jpg` 中进行检查，我们可以在暗色背景上找到我们的红色方块。
- en: Final words on the Strategy pattern
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于策略模式的最后几句话
- en: We have learned a powerful way to encapsulate algorithms in different structs.
    We have also used embedding instead of inheritance to provide cross-functionality
    between types, which will come in handy very often in our apps. You'll find yourself
    combining strategies here and there as we have seen in the second example, where
    we have strategies for logging and writing by using the `io.Writer` interface,
    a strategy for byte-streaming operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了一种强大的方法来封装不同的结构体中的算法。我们还使用了嵌入而不是继承来在类型之间提供跨功能性，这在我们的应用中会非常实用。你会发现自己在各个地方结合策略，就像我们在第二个例子中看到的那样，在那里我们使用了通过使用
    `io.Writer` 接口进行日志记录和写入的策略，以及一个用于字节流操作的策略。
- en: Chain of responsibility design pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链设计模式
- en: Our next pattern is called **chain of responsibility**. As its name implies,
    it consists of a chain and, in our case, each link of the chain follows the single
    responsibility principle.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个模式被称为**责任链**。正如其名所示，它由一个链组成，在我们的情况下，链中的每个链接都遵循单一职责原则。
- en: Description
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The single responsibility principle implies that a type, function, method, or
    any similar abstraction must have one single responsibility only and it must do
    it quite well. This way, we can apply many functions that achieve one specific
    thing each to some struct, slice, map, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则意味着一个类型、函数、方法或任何类似的抽象必须只有一个单一职责，并且它必须做得相当好。这样，我们可以将许多实现一个特定功能的函数应用到结构体、切片、映射等中。
- en: When we apply many of these abstractions in a logical way very often, we can
    chain them to execute in order such as, for example, a logging chain.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们非常频繁地以逻辑方式应用许多这些抽象时，我们可以将它们链在一起按顺序执行，例如，例如，一个日志链。
- en: A logging chain is a set of types that logs the output of some program to more
    than one `io.Writer` interface. We could have a type that logs to the console,
    a type that logs to a file, and a type that logs to a remote server. You can make
    three calls every time you want to do some logging, but it's more elegant to make
    only one and provoke a chain reaction.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录链是一组类型，它将某些程序的输出记录到多个 `io.Writer` 接口。我们可以有一个记录到控制台的类型，一个记录到文件的类型，以及一个记录到远程服务器的类型。每次你想进行一些日志记录时，你可以调用三个类型，但只调用一个并引发连锁反应会更优雅。
- en: But also, we could have a chain of checks and, in case one of them fails, break
    the chain and return something. This is the authentication and authorization middleware
    works.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也可以有一个检查链，如果其中一个检查失败，就断开链并返回一些内容。这就是身份验证和授权中间件的工作方式。
- en: Objectives
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objective of the chain of responsibility is to provide to the developer
    a way to chain actions at runtime. The actions are chained to each other and each
    link will execute some action and pass the request to the next link (or not).
    The following are the objectives followed by this pattern:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式的目标是为开发者提供一种在运行时链式执行操作的方法。操作被链在一起，每个链接将执行一些操作并将请求传递给下一个链接（或不会传递）。以下是这个模式遵循的目标：
- en: Dynamically chain the actions at runtime based on some input
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据某些输入在运行时动态链式执行操作
- en: Pass a request through a chain of processors until one of them can process it,
    in which case the chain could be stopped
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求通过处理器链传递，直到其中一个可以处理它，在这种情况下，链可以停止
- en: A multi-logger chain
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多日志记录器链
- en: 'We are going to develop a multi-logger solution that we can chain in the way
    we want. We will use two different console loggers and one general-purpose logger:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发一个多日志记录器解决方案，我们可以按我们想要的方式链式使用。我们将使用两个不同的控制台日志记录器和一个是通用日志记录器：
- en: We need a simple logger that logs the text of a request with a prefix *First
    logger* and passes it to the next link in the chain.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个简单的日志记录器，它带有前缀 *First logger* 记录请求的文本，并将其传递给链中的下一个链接。
- en: A second logger will write on the console if the incoming text has the word
    `hello` and pass the request to a third logger. But, if not, the chain will be
    broken and it will return immediately.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个日志记录器将在传入的文本包含单词 `hello` 时写入控制台，并将请求传递给第三个日志记录器。但是，如果没有，链将被断开，并且它将立即返回。
- en: A third logger type is a general purpose logger called `WriterLogger` that uses
    an `io.Writer` interface to log.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个日志记录器类型是一个通用日志记录器，称为 `WriterLogger`，它使用 `io.Writer` 接口进行日志记录。
- en: A concrete implementation of the `WriterLogger` writes to a file and represents
    the third link in the chain.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WriterLogger` 的具体实现将写入文件，并代表链中的第三个链接。'
- en: 'The implementation of these steps is described in the following figure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤的实现描述如下图所示：
- en: '![A multi-logger chain](img/00033.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![多日志记录器链](img/00033.jpeg)'
- en: Unit test
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The very first thing to do for the chain is, as usual, to define the interface.
    A chain of responsibility interface will usually have, at least, a  `Next()` method.
    The `Next()` method is the one that executes the next link in the chain, of course:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链的第一个要做的，就像往常一样，是定义接口。责任链接口通常至少有一个 `Next()` 方法。`Next()` 方法当然是执行链中下一个链接的方法：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Next` method on our example''s interface takes the message we want to
    log and passes it to the following link in the chain. As written in the acceptance
    criteria, we need three loggers:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例接口上的 `Next` 方法接受我们想要记录的消息，并将其传递给链中的下一个链接。正如接受标准所写，我们需要三个记录器：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `FirstLogger` and `SecondLogger` types have exactly the same structure--both
    implement `ChainLogger` and have a `NextChain` field that points to the next `ChainLogger`.
    The `WriterLogger` type is equal to the `FirstLogger` and `SecondLogger` types
    but also has a field to write its data to, so you can pass any `io.Writer` interface
    to it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstLogger` 和 `SecondLogger` 类型结构完全相同--两者都实现了 `ChainLogger` 并有一个指向下一个 `ChainLogger`
    的 `NextChain` 字段。`WriterLogger` 类型与 `FirstLogger` 和 `SecondLogger` 类型相同，但还有一个字段用于写入其数据，因此你可以向它传递任何
    `io.Writer` 接口。'
- en: 'As we have done before, we''ll implement an `io.Writer` struct to use in our
    testing. In our test file, we define the following struct:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们将实现一个 `io.Writer` 结构体以用于我们的测试。在我们的测试文件中，我们定义以下结构体：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will pass an instance of the `myTestWriter` struct to `WriterLogger` so we
    can track what's being logged on testing. The `myTestWriter` class implements
    the common `Write([]byte) (int, error)` method from the `io.Writer` interface.
    Remember, if it has the `Write` method, it can be used as `io.Writer`. The `Write`
    method simply stored the string argument to the `receivedMessage` field so we
    can check later its value on tests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递一个 `myTestWriter` 结构体实例到 `WriterLogger`，这样我们就可以跟踪测试中记录的内容。`myTestWriter`
    类实现了来自 `io.Writer` 接口的通用 `Write([]byte) (int, error)` 方法。记住，如果它有 `Write` 方法，则它可以作为
    `io.Writer` 使用。`Write` 方法简单地将字符串参数存储到 `receivedMessage` 字段中，这样我们就可以在测试中检查其值。
- en: 'This is the beginning of the first test function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个测试函数的开始：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's describe these few lines a bit as they are quite important. We create
    a variable with a default `myTestWriter` type that we'll use as an `io.Writer` interface
    in the last link of our chain. Then we create the last piece of the link chain,
    the `writerLogger` interface. When implementing the chain, you usually start with
    the last piece on the link and, in our case, it is a `WriterLogger`. The `WriterLogger`
    writes to an `io.Writer` so we pass `myWriter` as `io.Writer` interface.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细描述这几行，因为它们相当重要。我们创建了一个具有默认 `myTestWriter` 类型的变量，我们将将其用作链中最后一个链接的 `io.Writer`
    接口。然后我们创建了链接链的最后一部分，即 `writerLogger` 接口。在实现链时，你通常从链的最后一部分开始，在我们的情况下，它是一个 `WriterLogger`。`WriterLogger`
    将数据写入 `io.Writer`，所以我们传递 `myWriter` 作为 `io.Writer` 接口。
- en: Then we have created a `SecondLogger`, the middle link in our chain, with a
    pointer to the `writerLogger`. As we mentioned before, `SecondLogger` just logs
    and passes the message in case it contains the word `hello`. In a production app,
    it could be an error-only logger.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个 `SecondLogger`，它是我们链中的中间链接，并指向 `writerLogger`。正如我们之前提到的，`SecondLogger`
    仅在消息包含单词 `hello` 时记录并传递消息。在生产应用程序中，它可能是一个仅记录错误的记录器。
- en: 'Finally, the first link in the chain has the variable name chain. It points
    to the second logger. So, to resume, our chain looks like this: `FirstLogger`
    | `SecondLogger` | `WriterLogger`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，链中的第一个链接具有变量名链，它指向第二个记录器。所以，总结一下，我们的链看起来是这样的：`FirstLogger` | `SecondLogger`
    | `WriterLogger`。
- en: 'This is going to be our default setup for our tests:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的测试默认设置：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Continuing with Go 1.7 or later testing signatures, we define an inner test
    with the following description: *three loggers, two of them write to console,
    the second only if it finds the word ''hello'', the third writes to some variable
    if the second found ''hello''*. It''s quite descriptive and very easy to understand
    if someone else has to maintain this code.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 Go 1.7 或更高版本的测试签名，我们定义一个内部测试，其描述如下：*三个日志记录器，其中两个写入控制台，第二个仅在找到单词 'hello'
    时写入，第三个在第二个找到 'hello' 时写入某个变量*。这相当详细，如果其他人需要维护此代码，则非常容易理解。
- en: First, we use a message on the `Next` method that will not reach the third link
    in the chain as it doesn't contain the word `hello`. We check the contents of
    the `receivedMessage` variable, that by default is empty, to see if it has changed
    because it shouldn't.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`Next`方法上使用一条消息，这条消息不会达到链中的第三个链接，因为它不包含单词`hello`。我们检查`receivedMessage`变量的内容，默认情况下它是空的，以查看它是否已更改，因为它不应该改变。
- en: Next, we use the chain variable again, our first link in the chain, and pass
    the message `"Hello\n"`. According to the description of the test, it should log
    using `FirstLogger`, then in `SecondLogger` and finally in `WriterLogger` because
    it contains the word `hello` and the `SecondLogger` will let it pass.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用链变量，它是链中的第一个链接，并传递消息`"Hello\n"`。根据测试的描述，它应该使用`FirstLogger`记录，然后在`SecondLogger`中记录，最后在`WriterLogger`中记录，因为它包含单词`hello`，而`SecondLogger`会允许它通过。
- en: 'The test checks that `myWriter`, the last link in the chain that stored the
    past message in a variable called `receivedMessage`, has the word that we passed
    first in the chain: hello. Let''s run it so it fails:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检查`myWriter`，链中的最后一个链接，它在名为`receivedMessage`的变量中存储了过去的消息，是否包含我们在链中传递的第一个单词：hello。让我们运行它，看看它是否会失败：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The test passed for the first check of the test and didn''t for the second
    check. Well... ideally no check should pass before any implementation is done.
    Remember that in test-driven development, tests must fail on the first launch
    because the code they are testing isn''t implemented yet. Go zero-initialization
    misleads us with this passed check on the test. We can solve this in two ways:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在第一次检查中通过了，但在第二次检查中没有通过。嗯……理想情况下，在完成任何实现之前，不应该有任何检查通过。记住，在测试驱动开发中，测试必须在第一次启动时失败，因为它们测试的代码尚未实现。零初始化错误会误导我们，因为测试通过了这个检查。我们可以用两种方式解决这个问题：
- en: 'Making the signature of the `ChainLogger` to return an error: `Next(string)`
    error. This way, we would break the chain returning an error. This is a much more
    convenient way in general, but it will introduce quite a lot of boilerplate right
    now.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ChainLogger`的签名改为返回一个错误：`Next(string)`错误。这样，我们就会在返回错误时断开链。这在一般情况下是一个更方便的方法，但会引入相当多的模板代码。
- en: Changing the `receivedMessage` field to a pointer. A default value of a pointer
    is nil, instead of an empty string.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`receivedMessage`字段更改为指针。指针的默认值是nil，而不是空字符串。
- en: 'We will use the second option now, as it''s much simpler and quite effective
    too. So let''s change the signature of the `myTestWriter` struct to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用第二种选项，因为它更简单，也很有效。所以让我们将`myTestWriter`结构的签名更改为以下内容：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Check that the type of `receivedMessage` has the asterisk (`*`) now to indicate
    that it's a pointer to a string. The `Write` function needed to change too. Now
    we have to check the contents of the `receivedMessage` field because, as every
    pointer, it's initialized to nil. Then we have to store the message in a variable
    first, so we can take the address in the next line on the assignment `(m.receivedMessage
    = &tempMessage)`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`receivedMessage`的类型现在带有星号（`*`），以表示它是一个指向字符串的指针。`Write`函数也需要更改。现在我们必须检查`receivedMessage`字段的值，因为，作为每个指针，它被初始化为nil。然后我们必须首先将消息存储在一个变量中，这样我们就可以在下一行的赋值`(m.receivedMessage
    = &tempMessage)`中获取地址。
- en: 'So now our test code should change a bit too:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的测试代码也需要做一些改变：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we are checking that `myWriter.receivedMessage` is actually `nil`, so no
    content has been written for sure on the variable. Also, we have to change the
    second if to check first that the member isn''t nil before checking its contents
    or it can throw a panic on test. Let''s test it again:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在检查`myWriter.receivedMessage`实际上是`nil`，所以肯定没有在这个变量上写入任何内容。此外，我们必须将第二个if更改为首先检查成员是否为nil，然后再检查其内容，否则它可能会在测试中抛出panic。让我们再次测试它：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It fails again and, again, the first half of the test passes correctly without
    implemented code. So what should we do now? We have change the signature of the `myWriter`
    type to make the test fail in both checks and, again, just fail in the second.
    Well, in this case we can pass this small issue. When writing tests, we must be
    very careful to not get too crazy about them; unit tests are tools to help us
    write and maintain code, but our target is to write functionality, not tests.
    This is important to keep in mind as you can get really crazy engineering unit
    tests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次失败了，而且测试的前半部分仍然正确地通过了，没有实现代码。那么我们现在应该怎么做？我们需要更改 `myWriter` 类型的签名，以便在两个检查中使测试失败，并且在第二次检查中再次失败。在这种情况下，我们可以忽略这个小问题。在编写测试时，我们必须非常小心，不要对它们过于着迷；单元测试是帮助我们编写和维护代码的工具，但我们的目标是编写功能，而不是测试。这一点很重要，因为你可以编写出非常疯狂的单元测试。
- en: Implementation
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Now we have to implement the first, second, and third loggers called `FirstLogger`,
    `SecondLogger`, and `WriterLogger` respectively. The `FirstLogger` logger is the
    easiest one as described in the first acceptance criterion: *We need a simple
    logger that logs the text of a request with a prefix First logger: and passes
    it to the next link in the chain*. So let''s do it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们必须实现第一个、第二个和第三个日志记录器，分别称为 `FirstLogger`、`SecondLogger` 和 `WriterLogger`。根据第一项验收标准，`FirstLogger`
    日志记录器是最简单的一个：*我们需要一个简单的日志记录器，它使用前缀 First logger: 记录请求的文本，并将其传递给链中的下一个链接*。所以让我们来做这件事：'
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The implementation is quite easy. Using the `fmt.Printf` method to format and
    print the incoming string, we appended the text `First Logger:` text. Then, we
    check that the `NextChain` type has actually some content and pass the control
    to it by calling its `Next(string)` method. The test shouldn''t pass yet so we''ll
    continue with the `SecondLogger` logger:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单。使用 `fmt.Printf` 方法格式化和打印传入的字符串，我们追加文本 `First Logger:`。然后，我们检查 `NextChain`
    类型实际上有一些内容，并通过调用其 `Next(string)` 方法将其传递给控制。测试不应该通过，所以我们将继续使用 `SecondLogger` 日志记录器：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As mentioned in the second acceptance criterion, the `SecondLogger` description
    is: *A second logger will write on the console if the incoming text has the word
    "hello" and pass the request to a third logger*. First of all, it checks whether
    the incoming text contains the text `hello`. If it''s true, it prints the message
    to the console, appending the text `Second logger:` and passes the message to
    the next link in the chain (check previous instance that a third link exists).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如第二项验收标准所述，`SecondLogger` 的描述是：*第二个日志记录器将在传入文本包含单词 "hello" 时写入控制台，并将请求传递给第三个日志记录器*。首先，它检查传入的文本是否包含文本
    `hello`。如果是真的，它将消息打印到控制台，并追加文本 `Second logger:`，然后将消息传递给链中的下一个链接（检查前面的实例，是否存在第三个链接）。
- en: But if it doesn't contain the text `hello`, the chain is broken and it prints
    the message `Finishing in second logging`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果它不包含文本 `hello`，链就会被打破，并打印出消息 `Finishing in second logging`。
- en: 'We''ll finalize with the `WriterLogger` type:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以 `WriterLogger` 类型来最终确定：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `WriterLogger` struct's `Next` method checks that there is an existing `io.Writer`
    interface stored in the `Writer` member and writes there the incoming message
    appending the text `WriterLogger:` to it. Then, like the previous links, check
    that there are more links to pass the message.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriterLogger` 结构体的 `Next` 方法检查 `Writer` 成员中是否存储了现有的 `io.Writer` 接口，并将传入的消息写入其中，并在其后面追加文本
    `WriterLogger:`。然后，就像之前的链接一样，检查是否有更多的链接来传递消息。'
- en: 'Now the tests will pass successfully:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试将成功通过：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first half of the test prints two messages--the `First logger:` message
    that breaks the chain, which is the expected message for the `FirstLogger`. But
    it halts in the `SecondLogger` because no `hello` word has been found on the incoming
    message; that's why it prints the `Finishing in second logging` string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的前半部分打印出两条消息--`First logger:` 消息打破了链，这是为 `FirstLogger` 预期的消息。但是它在 `SecondLogger`
    中停止了，因为没有在传入的消息中找到 `hello` 这个单词；这就是为什么它会打印出 `Finishing in second logging` 字符串。
- en: The second half of the test receives the message `Hello`. So the `FirstLogger`
    prints and the `SecondLogger` prints too. The third logger doesn't print to console
    at all but to our `myWriter.receivedMessage` line defined in the test.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的后半部分接收到的消息是 `Hello`。所以 `FirstLogger` 打印，`SecondLogger` 也打印。第三个日志记录器根本不打印到控制台，而是打印到测试中定义的
    `myWriter.receivedMessage` 行。
- en: What about a closure?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么闭包呢？
- en: 'Sometimes it can be useful to define an even more flexible link in the chain
    for quick debugging. We can use closures for this so that the link functionality
    is defined by the caller. What does a closure link look like? Similar to the `WriterLogger`
    logger:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时定义一个更灵活的链链接以进行快速调试可能很有用。我们可以使用闭包来做到这一点，这样链接功能就由调用者定义。闭包链接看起来是什么样子？类似于 `WriterLogger`
    记录器：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ClosureChain` type has a `NextChain`, as usual, and a `Closure` member.
    Look at the signature of the `Closure: func(string)`. This means it is a function
    that takes a `string` and returns nothing.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClosureChain` 类型具有 `NextChain`，就像往常一样，以及一个 `Closure` 成员。看看 `Closure` 的签名：`func(string)`。这意味着它是一个接受
    `string` 并不返回任何内容的函数。'
- en: The `Next(string)` method for `ClosureChain` checks that the `Closure` member
    is stored and executes it with the incoming string. As usual, the link checks
    for more links to pass the message as every link in the chain.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClosureChain` 类的 `Next(string)` 方法检查 `Closure` 成员是否已存储，并使用传入的字符串执行它。像往常一样，链接检查是否有更多链接以传递消息，因为链中的每个链接都会传递消息。'
- en: 'So, how do we use it now? We''ll define a new test to show its functionality:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何现在使用它呢？我们将定义一个新的测试来展示其功能：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The description of this test makes it clear: `"2 loggers, second uses the closure
    implementation".` We simply use two `ChainLogger` implementations and we use the
    `closureLogger` in the second link. We have created a new `myTestWriter` to store
    the contents of the message. When defining the `ClosureChain`, we defined an anonymous
    function directly on the `Closure` member when creating `closureLogger`. It prints
    `"My closure logger! Message: %s\n" with the incoming message replacing "%s"`.
    Then, we store the incoming message on `myWriter`, to check later.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '这个测试的描述使它很清楚：“2个记录器，第二个使用闭包实现”。我们简单地使用两个 `ChainLogger` 实现，并在第二个链接中使用 `closureLogger`。我们创建了一个新的
    `myTestWriter` 来存储消息的内容。在定义 `ClosureChain` 时，我们在创建 `closureLogger` 时直接在 `Closure`
    成员上定义了一个匿名函数。它打印 `"My closure logger! Message: %s\n"`，并用传入的消息替换 "%s"。然后，我们将传入的消息存储在
    `myWriter` 上，以便稍后检查。'
- en: After defining this new link, we use the third link from the previous test,
    add the closure as the fourth link, and passed the message `Hello closure logger`.
    We use the word `Hello` at the beginning so that we ensure that the message will
    pass the `SecondLogger`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义这个新链接后，我们使用上一个测试中的第三个链接，将闭包作为第四个链接添加，并传递消息 `Hello closure logger`。我们在消息的开头使用
    `Hello` 这个词，以确保消息会通过 `SecondLogger`。
- en: 'Finally, the contents of `myWriter.receivedMessage` must contain the pased
    text: `Hello closure logger`. This is quite a flexible approach with one drawback:
    when defining a closure like this, we cannot test its contents in a very elegant
    way. Let''s run the tests again:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`myWriter.receivedMessage` 的内容必须包含传递的文本：`Hello closure logger`。这是一个相当灵活的方法，但有一个缺点：在定义这样的闭包时，我们无法以非常优雅的方式测试其内容。让我们再次运行测试：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look at the third `RUN`: the message passes correctly through the first, second,
    and third links to arrive at the closure that prints the expected  `My closure
    logger! Message: Hello closure logger` message.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '看看第三个 `RUN`：消息正确地通过了第一个、第二个和第三个链接，到达了打印预期 `My closure logger! Message: Hello
    closure logger` 消息的闭包。'
- en: It's very useful to add a closure method implementation to some interfaces as
    it provides quite a lot of flexibility when using the library. You can find this
    approach very often in Go code, being the most known the one of package `net/http`.
    The `HandleFunc` function which we used previously in the structural patterns
    to define a handler for an HTTP request.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些接口中添加闭包方法实现非常有用，因为它在使用库时提供了相当多的灵活性。你可以在 Go 代码中经常找到这种方法，其中最著名的是 `net/http`
    包。我们之前在结构模式中使用 `HandleFunc` 函数定义 HTTP 请求的处理程序。
- en: Putting it together
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合起来
- en: We learned a powerful tool to achieve dynamic processing of actions and state
    handling. The Chain of responsibility pattern is widely used, also to create **Finite
    State Machines** (**FSM**). It is also used interchangeably with the Decorator
    pattern with the difference that when you decorate, you change the structure of
    an object while with the chain you define a behavior for each link in the chain
    that can break it too.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了一个强大的工具，用于实现动作的动态处理和状态管理。责任链模式被广泛使用，也用于创建**有限状态机**（**FSM**）。它也可以与装饰器模式互换使用，区别在于当你装饰时，你改变了对象的结构，而当你使用链时，你为链中的每个链接定义了一个行为，这也可以中断链。
- en: Command design pattern
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: To finish with this chapter, we will see also the **Command** pattern--a tiny
    design pattern but still frequently used. You need a way to connect types that
    are really unrelated? So design a Command for them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我们还将看到**命令**模式——这是一个微小的设计模式，但仍然经常使用。你需要一种方法来连接真正无关的类型？那么为它们设计一个命令。
- en: Description
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Command design pattern is quite similar to the Strategy design pattern but
    with key differences. While in the strategy pattern we focus on changing algorithms,
    in the Command pattern, we focus on the invocation of something or on the abstraction
    of some type.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式与策略设计模式非常相似，但有一些关键的区别。在策略模式中，我们关注算法的更改，而在命令模式中，我们关注对某物或某些类型的抽象或调用。
- en: A Command pattern is commonly seen as a container. You put something like the
    info for user interaction on a UI that could be `click on login` and pass it as
    a command. You don't need to have the complexity related to the `click on login`
    action in the command but simply the action itself.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式通常被视为一个容器。你可以在UI上放置用户交互的信息，比如“点击登录”，并将其作为命令传递。你不需要在命令中包含与“点击登录”操作相关的复杂性，只需操作本身即可。
- en: An example for the organic world would be a box for a delivery company. We can
    put anything on it but, as a delivery company, we are interested in managing the
    box instead of its contents directly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有机世界的例子可以是快递公司的盒子。我们可以把它放在上面，但作为一个快递公司，我们对其内容的直接管理不如对盒子的管理感兴趣。
- en: The command pattern will be used heavily when dealing with channels. With channels
    you can send any message through it but, if we need a response from the receiving
    side of the channel, a common approach is to create a command that has a second,
    response channel attached where we are listening.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理通道时，将大量使用命令模式。通过通道，你可以发送任何消息，但如果我们需要从通道的接收端获取响应，一个常见的做法是创建一个带有附加的响应通道的命令，我们在那里监听。
- en: Similarly, a good example would be a multi-player video game, where every stroke
    of each user can be sent as commands to the rest of the users through the network.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个很好的例子是多玩家视频游戏，其中每个用户的每个操作都可以作为命令通过网络发送给其他用户。
- en: Objectives
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'When using the Command design pattern, we are trying to encapsulate some sort
    of action or information in a light package that must be processed somewhere else.
    It''s similar to the Strategy pattern but, in fact, a Command could trigger a
    preconfigured Strategy somewhere else, so they are not the same. The following
    are the objectives for this design pattern:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用命令设计模式时，我们试图将某种动作或信息封装在一个轻量级的包装中，该包装必须在其他地方进行处理。它与策略模式类似，但实际上，命令可以在其他地方触发预配置的策略，因此它们并不相同。以下是该设计模式的目标：
- en: Put some information into a box. Just the receiver will open the box and know
    its contents.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一些信息放入一个盒子中。只有接收者会打开盒子并知道其内容。
- en: Delegate some action somewhere else.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将某些操作委托到其他地方。
- en: 'The behavior is also explained in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 行为也在以下图中得到解释：
- en: '![Objectives](img/00034.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![目标](img/00034.jpeg)'
- en: There we have a **Command** interface with a **Get() interface{}** method. We
    have a type **A** and a type **B**. The idea is that **A** and **B** implement
    the **Command** interface to return themselves as an `interface{}`. As now they
    implement **Command**, they can be used in a **Command handler** which doesn't
    care very much about the underlying type. Now **A** and **B** can travel through
    functions that handles commands or store Commands freely. But **B** handler can
    take an object from any **Command** handler to "unwrap" it and take its **B**
    content as well as **A** command handler with its `A` content.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个**命令**接口，其中包含一个**Get() interface{}**方法。我们有类型**A**和类型**B**。想法是**A**和**B**实现**命令**接口以返回自身作为`interface{}`。既然它们实现了**命令**，它们就可以在**命令处理器**中使用，而处理器并不关心底层类型。现在**A**和**B**可以穿越处理命令的函数或自由存储命令。但是**B**处理器可以从任何**命令处理器**中取一个对象来“解包”它，并获取其**B**内容以及带有其`A`内容的**A**命令处理器。
- en: We put the information in a box (the **Command**) and delegate what to do with
    it to the handlers of Commands.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将信息放入一个盒子（**命令**）中，并将处理它的任务委托给命令处理器。
- en: A simple queue
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的队列
- en: Our first example is going to be pretty small. We will put some information
    into a Command implementer and we will have a queue. We will create many instances
    of a type implementing a Command pattern and we will pass them to a queue that
    will store the commands until three of them are in the queue, at which time it
    will process them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例将会相当简单。我们将把一些信息放入一个命令实现者中，并拥有一个队列。我们将创建许多实现命令模式的类型的实例，并将它们传递给一个队列，该队列将存储命令，直到队列中有三个命令，此时它将处理它们。
- en: Acceptance criteria
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'So the ideal acceptance criteria to understand well the implications of the
    Command should reflect somehow the creation of a box that can accept unrelated
    types and the execution of the Command itself:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理想的验收标准应该以某种方式反映创建一个可以接受无关类型的盒子和执行命令本身的影响：
- en: We need a constructor of console printing commands. When using this constructor
    with a `string`, it will return a command that will print it. In this case, the
    handler is inside the command that acts as a box and as a handler.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个控制台打印命令的构造函数。当使用这个构造函数与一个 `string` 时，它将返回一个将打印它的命令。在这种情况下，处理程序位于作为盒子和处理器的命令中。
- en: We need a data structure that stores incoming commands in a queue and prints
    them once the queue reaches the length of three.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个数据结构，用于在队列中存储传入的命令，并在队列长度达到三个时打印它们。
- en: Implementation
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现方式
- en: 'This pattern is quite simple and we will write a few different examples so
    we''ll implement the library directly to keep things light and short. The classical
    Command design pattern usually has a common type structure with an `Execute` method.
    We are also going to use this structure as it''s quite flexible and simple:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式相当简单，我们将编写几个不同的示例，因此我们将直接实现库以保持内容简洁和简短。经典的命令设计模式通常有一个带有 `Execute` 方法的公共类型结构。我们也将使用这种结构，因为它相当灵活且简单：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is generic enough to fill a lot of unrelated types! Think about it--we
    are going to create a type that prints to console when using the `Execute()` method
    but it could print a number or launch a rocket as well! The key here is to focus
    on invocations because the handlers are also in Command. So we need some type
    implementing this interface and printing to the console some sort of message:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够通用，可以填充许多无关类型！想想看——我们将创建一个类型，当使用 `Execute()` 方法时，它将打印到控制台，但它也可以打印一个数字或发射火箭！关键在于关注调用，因为处理程序也在命令中。因此，我们需要一些实现此接口并打印某种消息的类型：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ConsoleOutput` type implements the `Command` interface and prints to the
    console the member called `message`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleOutput` 类型实现了 `Command` 接口，并将成员 `message` 打印到控制台。'
- en: 'As defined in the first acceptance criterion, we need a `Command` constructor
    that accepts a message string and returns the `Command` interface. It will have
    the signature `func CreateCommand(s string) Command`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一项验收标准所述，我们需要一个 `Command` 构造函数，它接受一个消息字符串并返回 `Command` 接口。它的签名是 `func CreateCommand(s
    string) Command`：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the command `queue`, we''ll define a very simple type called `CommandQueue`
    to store in a queue any type implementing the `Command` interface:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令 `queue`，我们将定义一个非常简单的类型 `CommandQueue`，用于在队列中存储实现 `Command` 接口的任何类型：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `CommandQueue` type stores an array of the `Commands` interface. When the
    queue array reaches three items, it executes all the commands stored in the queue
    field. If it hasn't reached the required length yet, it just stores the command.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandQueue` 类型存储了一个 `Commands` 接口数组的引用。当队列数组达到三个项目时，它将执行队列字段中存储的所有命令。如果还没有达到所需的长度，它只是存储该命令。'
- en: 'We will create five commands, enough to trigger the command queue mechanism,
    and add them to the queue. Each time a command is created, the message `Creating
    command` will be printed to the console. When we create the third command, the
    automatic command executor will be launched, printing the first three messages.
    We create and add two commands more, but because we haven''t reached the third
    command again, they won''t be printed and just the `Creating command` messages
    will be printed:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建五个命令，足以触发命令队列机制，并将它们添加到队列中。每次创建一个命令时，控制台将打印出消息 `Creating command`。当我们创建第三个命令时，自动命令执行器将被启动，打印出前三个消息。我们再创建并添加两个命令，但由于我们没有再次达到第三个命令，它们不会被打印，只会打印出
    `Creating command` 消息：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s run the `main` program. Our definition said that the commands are processed
    once every three messages and we will create a total of five messages. The first
    three messages must be printed but not the fourth and fifth because we didn''t
    reach a sixth message to trigger the command processing:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`main`程序。我们的定义说明命令每处理三条消息一次，我们将创建总共五条消息。前三条消息必须打印，但第四和第五条消息不打印，因为我们没有达到第六条消息来触发命令处理：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the fourth and fifth messages aren't printed, as expected, but
    we know that the commands were created and stored on the array. They just weren't
    processed because the queue was waiting for one command more to trigger the processor.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第四和第五条消息没有按预期打印，但我们知道命令已经被创建并存储在数组中。它们只是没有被处理，因为队列正在等待一个额外的命令来触发处理器。
- en: More examples
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多示例
- en: The previous example shows how to use a Command handler that executes the content
    of the command. But a common way to use a Command pattern is to delegate the information,
    instead of the execution, to a different object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了如何使用一个命令处理器来执行命令的内容。但使用命令模式的一种常见方式是将信息委托给不同的对象，而不是执行。
- en: 'For example, instead of printing to the console, we will create a command that
    extracts information:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不会打印到控制台，而是创建一个提取信息的命令：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this case, our `Command` interface will have a method named `Info` that
    will retrieve some information from its implementor. We will create two implementations;
    one will return the time passed since the creation of the command to its execution:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的`Command`接口将有一个名为`Info`的方法，它将从其实现者那里检索一些信息。我们将创建两个实现；一个将返回命令创建到执行之间经过的时间：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `time.Since` function returns the time elapsed since the time stored in
    the provided parameter. We returned the string representation of the passed time
    by calling the `String()` method on the `time.Time` type. The second implementation
    of our new `Command` will return the message `Hello World!`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Since`函数返回从提供的参数存储的时间开始经过的时间。我们通过在`time.Time`类型上调用`String()`方法来返回经过时间的字符串表示。我们新的`Command`的第二个实现将返回消息`Hello
    World!`：'
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And our `main` function will simply create an instance of each type, then waits
    for a second and print the info returned from each `Command`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数将简单地创建每种类型的实例，然后等待一秒钟，并打印每个`Command`返回的信息：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `time.Sleep` function stops the execution of the current goroutine for the
    specified period (a second). So, to recall--the `timeCommand` variable stores
    the time when the program was started and its `Info()` method returns a string
    representation of the time that passed since we give a value to the type to the
    moment were we called the `Info()` method on it. The `helloCommand` variable returns
    the message `Hello World!` when we call its `Info()` method. Here we haven't implemented
    a `Command` handler again to keep things simple but we can consider the console
    as the handler because we can only print ASCII characters on it like the ones
    retrieved by the `Info()` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Sleep`函数使当前goroutine的执行停止指定的时间（一秒）。所以，回想一下——`timeCommand`变量存储了程序开始的时间，它的`Info()`方法返回自我们给该类型赋值以来经过时间的字符串表示。`helloCommand`变量在调用其`Info()`方法时返回消息`Hello
    World!`。在这里，我们没有再次实现`Command`处理器以保持简单，但我们可以将控制台视为处理器，因为我们只能打印ASCII字符，就像通过`Info()`方法检索到的那些字符一样。'
- en: 'Let''s run the `main` function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`main`函数：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here we are. In this case, we retrieve some information by using the Command
    pattern. One type stores `time` information while the other stores nothing and
    it simply returns the same simple string. Each time we run the `main` function
    will return a different elapsed time, so don't worry if the time doesn't match
    with the one in the example.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们到了。在这种情况下，我们通过使用命令模式来检索一些信息。一种类型存储`时间`信息，而另一种则不存储任何信息，它简单地返回相同的简单字符串。每次运行`main`函数都会返回不同的已过时间，所以如果时间与示例中的时间不匹配，请不要担心。
- en: Chain of responsibility of commands
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令的责任链
- en: Do you remember the chain of responsibility design pattern? We were passing
    a `string` message between links to print its contents. But we could be using
    the previous Command to retrieve information for logging to the console. We'll
    mainly reuse the code that we have written already.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得责任链设计模式吗？我们是在链接之间传递一个`字符串`消息以打印其内容。但我们可以使用之前的命令来检索信息以记录到控制台。我们将主要重用我们已经编写的代码。
- en: 'The `Command` interface will be from the type interface that returns a `string`
    from the previous example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command`接口将来自返回字符串的先前示例中的类型接口：'
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will use the `Command` implementation of the `TimePassed` type too:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`TimePassed`类型的`Command`实现：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember that this type returns the elapsed time from the object creation on
    its `Info() string` method. We also need the `ChainLogger` interface from the
    *Chain of responsibility design pattern* section of this chapter but, this time,
    it will pass Commands on its `Next` method instead of `string`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个类型在其`Info()`字符串方法中返回对象创建的经过时间。我们还需要从本章的*责任链设计模式*部分获取`ChainLogger`接口，但这次它将在其`Next`方法中传递命令而不是字符串：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We''ll use just the same type for two links in the chain for simplicity. This
    link is very similar to the `FirstLogger` type from the chain of responsibility
    example, but this time it will append the message `Elapsed time from creation:`
    and it will wait 1 second before printing. We''ll call it `Logger` instead of
    `FirstLogger`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将使用相同的类型来表示链中的两个链路。这个链路非常类似于责任链模式示例中的`FirstLogger`类型，但这次它将附加消息`Elapsed
    time from creation:`并在打印之前等待1秒钟。我们将称之为`Logger`而不是`FirstLogger`：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we need a `main` function to execute the chain that takes `Command`
    pointers:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`main`函数来执行接受`Command`指针的链。
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Line by line, we create a variable called `second` with a pointer to a `Logger`;
    this is going to be the second link in our chain. Then we create a variable called
    `first`, that will be the first link in the chain. The first link points to the
    `second` variable, the second link in the chain.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 行行分析，我们创建了一个名为`second`的变量，它指向一个`Logger`；这将是我们链中的第二个链路。然后我们创建了一个名为`first`的变量，它将是链中的第一个链路。第一个链路指向`second`变量，即链中的第二个链路。
- en: Then, we create an instance of `TimePassed` to use it as the `Command` type.
    The start time of this command is the execution time (the `time.Now()` method
    returns the time in the moment of the execution).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`TimePassed`的实例来使用它作为`Command`类型。这个命令的起始时间是执行时间（`time.Now()`方法返回执行时刻的时间）。
- en: 'Finally, we pass the `Command` interface to the chain on the `first.Next(command)`
    statement. The output of this program is the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`first.Next(command)`语句中将`Command`接口传递给链。这个程序的输出如下：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The resulting output is reflected in the following diagram: The command with
    the time field is pushed to the first link that knows how to execute Commands
    of any type. Then it passes the Command to the second link that also knows how
    to execute Commands:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出反映在以下图中：具有时间字段的命令被推送到第一个知道如何执行任何类型命令的链路。然后它将命令传递给第二个也知道如何执行命令的链路：
- en: This approach hides the complexity behind each `Command` execution from the
    Command handlers on each link. The functionality hidden behind a Command can be
    simple or incredibly complex but the idea here is to reuse the handler to manage
    many types of unrelated implementations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法隐藏了每个`Command`执行背后的复杂性，使其从每个链路上的命令处理器中隐藏。一个命令背后隐藏的功能可以是简单的，也可以是极其复杂的，但这里的想法是重用处理器来管理许多不同类型的无关实现。
- en: Rounding-up the Command pattern up
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结命令模式
- en: Command is a very tiny design pattern; its functionality is quite easy to understand
    but it's widely used for its simplicity. It looks very similar to the Strategy
    pattern but remember that Strategy is about having many algorithms to achieve
    some specific task, but all of them achieve the same task. In the Command pattern,
    you have many tasks to execute, and not all of them need to be equal.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是一个非常小的设计模式；它的功能很容易理解，但因其简单性而被广泛使用。它看起来非常类似于策略模式，但请记住，策略模式是关于拥有许多算法来完成某些特定任务，但所有这些算法都完成相同的任务。在命令模式中，你有许多任务要执行，而且并非所有任务都需要相等。
- en: So, in short, the Command pattern is about execution encapsulation and delegation
    so that just the receiver or receivers trigger that execution.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，命令模式是关于执行封装和委托，以便只有接收者或接收者触发执行。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have taken our first steps in the Behavioral patterns. The objective of this
    chapter was to introduce the reader to the concept of algorithm and execution
    encapsulation using proper interfaces and structures. With the strategy, we have
    encapsulated algorithms, with the chain of responsibility handlers and with the
    Command design pattern executions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在行为模式中迈出了第一步。本章的目标是向读者介绍算法和执行封装的概念，使用适当的接口和结构。通过策略，我们封装了算法，通过责任链处理器和命令设计模式执行。
- en: Now, with the knowledge we have acquired about the strategy pattern, we can
    uncouple heavily our applications from their algorithms, just for testing, this
    is a very useful feature to inject mocks in different types that would be almost
    impossible to test. But also for anything that could need different approaches
    based on some context (such as shorting a list; some algorithms perform better
    depending on the distribution of the list).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们掌握了关于策略模式的知识，我们可以将我们的应用程序与其算法解耦，仅用于测试，这是一个非常有用的功能，可以在不同类型中注入模拟，这在几乎不可能进行测试的情况下几乎是不可能的。但这也适用于任何可能需要根据某些上下文采取不同方法的情况（例如，缩短列表；某些算法的性能取决于列表的分布）。
- en: The Chain of Responsibility pattern opens the door of middleware of any type
    and plugin-like libraries to improve the functionality of some part. Many open
    source projects uses a Chain of Responsibility to handler HTTP requests and responses
    to extract information to the end user (such as cookies info) or check authentication
    details (I'll let you pass to the next link only if I have you on my database).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式为任何类型的中间件和插件式库打开了大门，以提升某些部分的功能。许多开源项目使用责任链来处理HTTP请求和响应，以便提取信息传递给最终用户（例如，cookie信息）或检查认证细节（只有在我数据库中有你的记录时，我才会让你通过到下一个链接）。
- en: Finally, the Command pattern is the most common pattern for UI handling but
    also very useful in many other scenarios where we need some type of handling between
    many unrelated types that are travelling through the code (such as a message passed
    through a channel).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，命令模式是处理UI的最常见模式，但在许多其他场景中也非常有用，在这些场景中，我们需要在许多无关的类型之间进行某种类型的处理（例如，通过通道传递的消息）。
