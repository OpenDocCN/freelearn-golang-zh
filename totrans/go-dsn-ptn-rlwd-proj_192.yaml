- en: Declaring named struct types
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明命名结构体类型
- en: 'Attempting to reuse struct types can get unwieldy fast. For instance, having
    to write `struct { name string; address struct { street string; city string; state
    string; postal string }}` to express a struct type, every time it is needed, would
    not scale, would be error prone, and would make for grumpy Go developers. Luckily,
    the proper idiom to fix this is to use named types, as illustrated in the following
    source code snippet:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重用结构体类型可能会很快变得难以控制。例如，每次需要表达结构体类型时，都必须编写 `struct { name string; address struct
    { street string; city string; state string; postal string }}`，这不会扩展，容易出错，并且会让
    Go 开发者感到沮丧。幸运的是，修复这个问题的正确习惯用法是使用命名类型，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch07/structtype_dec.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structtype_dec.go
- en: The previous example binds struct type definitions to the identifiers person
    and address. This allows the struct types to be reused in different contexts without
    the need to carry around the long form of the type definitions. You can refer
    to [Chapter 4](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 4. Data Types"), *Data Types*, to learn more about named types.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将结构体类型定义绑定到标识符 person 和 address。这允许在不需要携带类型定义的长形式的情况下，在不同的上下文中重用结构体类型。您可以参考[第4章](part0027_split_000.html#PNV61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第4章。数据类型")，*数据类型*，了解更多关于命名类型的信息。
