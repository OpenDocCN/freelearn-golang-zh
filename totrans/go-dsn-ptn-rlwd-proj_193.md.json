["```go\ndiameter and the name, are embedded as anonymous fields in the planet type:\n```", "```go\ntype diameter int \n\ntype name struct { \n   long   string \n   short  string \n   symbol rune \n} \n\ntype planet struct { \n   diameter \n   name \n   desc string \n} \n\nfunc main() { \n   earth := planet{ \n         diameter: 7926, \n         name: name{ \n               long:   \"Earth\", \n               short:  \"E\", \n               symbol: '\\u2641', \n         }, \n         desc: \"Third rock from the Sun\", \n   } \n   ... \n} \n\nplanet struct. Notice the names of the embedded types become the field identifiers in the composite literal value for the struct.\n```", "```go\nfunc main(){ \n   jupiter := planet{} \n   jupiter.diameter = 88846 \n   jupiter.name.long = \"Jupiter\" \n   jupiter.name.short = \"J\" \n   jupiter.name.symbol = '\\u2643' \n   jupiter.desc = \"A ball of gas\" \n   ... \n} \n\n```", "```go\nfunc main() {\n...\nsaturn := planet{}\nsaturn.diameter = 120536\nsaturn.long = \"Saturn\"\nsaturn.short = \"S\"\nsaturn.symbol = '\\u2644'\nsaturn.desc = \"Slow mover\"\n...\n}\nname by omitting it from the selector expression. The values of the fields long, short, and symbol come from embedded type name. Again, this will only work if the promotion does not cause any identifier clashes. In case of ambiguity, the fully qualified selector expression can be used.\n```"]