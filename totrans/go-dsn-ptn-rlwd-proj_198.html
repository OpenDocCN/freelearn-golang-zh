<html><head></head><body>
<div class="book" title="Chapter&#xA0;8.&#xA0;Methods, Interfaces, and Objects" id="1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Go methods"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec52" class="calibre1"/>Go methods</h1></div></div></div><p class="calibre10">A Go function can be defined with a scope narrowed to that of a specific type. When a function is scoped to a type, or attached to the type, it is known as a <span class="strong"><em class="calibre11">method</em></span>. A method is defined just like any other Go function. However, its definition includes a <span class="strong"><em class="calibre11">method receiver</em></span>, which is an extra parameter placed before the method's name, used to specify the host type to which the method is attached.</p><p class="calibre10">To better illustrate this concept, the following figure highlights the different parts involved in defining a method. It shows the <code class="email">quart</code> method attached to the <code class="email">type gallon</code> based receiver via the <code class="email">g gallon</code> receiver parameter:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Go methods" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">As mentioned, a method has the scope of a type. Therefore, it can only be accessed via a declared value (concrete or pointer) of the attached type using <span class="strong"><em class="calibre11">dot notation</em></span>. The following program shows how the declared method <code class="email">quart</code> is accessed using this notation:</p><pre class="programlisting">package main 
import "fmt" 
 
type gallon float64 
 
func (g gallon) quart() float64 { 
   return float64(g * 4) 
} 
func main(){ 
    gal := gallon(5) 
    fmt.Println(gal.quart()) 
} 
</pre><p class="calibre10">golang.fyi/ch08/method_basic.go</p><p class="calibre10">In the previous example, the <code class="email">gal</code> variable is initialized as the <code class="email">gallon</code> type. Therefore, the <code class="email">quart</code> method can be accessed using <code class="email">gal.quart()</code>.</p><p class="calibre10">At runtime, the receiver parameter provides access to the value assigned to the base type of the method. In the example, the <code class="email">quart</code> method receives the <code class="email">g</code> parameter, which passes in a copy of the value for the declared type. So when the <code class="email">gal</code> variable is initialized with a value of <code class="email">5</code>, a call to <code class="email">gal.quart()</code> sets the receiver parameter <code class="email">g</code> to <code class="email">5</code>. So the following would then print a value of <code class="email">20</code>:</p><pre class="programlisting">func main(){ 
    gal := gallon(5) 
    fmt.Println(gal.quart()) 
} 
</pre><p class="calibre10">It is important to note that the base type for method receivers cannot be a pointer (nor an interface). For instance, the following will not compile:</p><pre class="programlisting">type gallon *float64    
func (g gallon) quart() float64 {
  return float64(g * 4)
}
</pre><p class="calibre10">The following shows a lengthier version of the source that implements a more general liquid volume conversion program. Each volumetric type receives its respective methods to expose behaviors attributed to that type:</p><pre class="programlisting">package main 
import "fmt" 
 
type ounce float64 
func (o ounce) cup() cup { 
   return cup(o * 0.1250) 
} 
 
type cup float64 
func (c cup) quart() quart { 
   return quart(c * 0.25) 
} 
func (c cup) ounce() ounce { 
   return ounce(c * 8.0) 
} 
 
type quart float64 
func (q quart) gallon() gallon { 
   return gallon(q * 0.25) 
} 
func (q quart) cup() cup { 
   return cup(q * 4.0) 
} 
 
type gallon float64 
func (g gallon) quart() quart { 
   return quart(g * 4) 
} 
 
func main() { 
    gal := gallon(5) 
    fmt.Printf("%.2f gallons = %.2f quarts\n", gal, gal.quart()) 
    ozs := gal.quart().cup().ounce() 
    fmt.Printf("%.2f gallons = %.2f ounces\n", gal, ozs) 
} 
</pre><p class="calibre10">github.com/vladimirvivien/learning-go/ch08/methods.go</p><p class="calibre10">For instance, converting <code class="email">5</code> gallons to ounces can be done by invoking the proper conversion methods on a given value, as follows:</p><pre class="programlisting">gal := gallon(5) 
ozs := gal.quart().cup().ounce() 
</pre><p class="calibre10">The entire implementation uses a simple, but effective, typical structure to represent both data type and behavior. Reading the code, it cleanly expresses its intended meaning without any reliance on heavy class structures.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre10"><span class="strong"><strong class="calibre2">Method set</strong></span></p><p class="calibre10">The number of methods attached to a type, via the receiver parameter, is known as the type's <span class="strong"><em class="calibre11">method set</em></span>. This includes both concrete and pointer value receivers. The concept of a method set is important in determining type equality, interface implementation, and support of the notion of the empty method set for the <span class="strong"><em class="calibre11">empty interface </em></span>(all discussed in this chapter).</p></div></div></div></body></html>