- en: Go methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Go function can be defined with a scope narrowed to that of a specific type.
    When a function is scoped to a type, or attached to the type, it is known as a
    *method*. A method is defined just like any other Go function. However, its definition
    includes a *method receiver*, which is an extra parameter placed before the method's
    name, used to specify the host type to which the method is attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better illustrate this concept, the following figure highlights the different
    parts involved in defining a method. It shows the `quart` method attached to the
    `type gallon` based receiver via the `g gallon` receiver parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Go methods](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned, a method has the scope of a type. Therefore, it can only be accessed
    via a declared value (concrete or pointer) of the attached type using *dot notation*.
    The following program shows how the declared method `quart` is accessed using
    this notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/method_basic.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the `gal` variable is initialized as the `gallon` type.
    Therefore, the `quart` method can be accessed using `gal.quart()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, the receiver parameter provides access to the value assigned to
    the base type of the method. In the example, the `quart` method receives the `g`
    parameter, which passes in a copy of the value for the declared type. So when
    the `gal` variable is initialized with a value of `5`, a call to `gal.quart()`
    sets the receiver parameter `g` to `5`. So the following would then print a value
    of `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the base type for method receivers cannot be a
    pointer (nor an interface). For instance, the following will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows a lengthier version of the source that implements a more
    general liquid volume conversion program. Each volumetric type receives its respective
    methods to expose behaviors attributed to that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: github.com/vladimirvivien/learning-go/ch08/methods.go
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, converting `5` gallons to ounces can be done by invoking the
    proper conversion methods on a given value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The entire implementation uses a simple, but effective, typical structure to
    represent both data type and behavior. Reading the code, it cleanly expresses
    its intended meaning without any reliance on heavy class structures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Method set**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of methods attached to a type, via the receiver parameter, is known
    as the type's *method set*. This includes both concrete and pointer value receivers.
    The concept of a method set is important in determining type equality, interface
    implementation, and support of the notion of the empty method set for the *empty
    interface* (all discussed in this chapter).
  prefs: []
  type: TYPE_NORMAL
