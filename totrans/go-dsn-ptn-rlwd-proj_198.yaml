- en: Go methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 方法
- en: A Go function can be defined with a scope narrowed to that of a specific type.
    When a function is scoped to a type, or attached to the type, it is known as a
    *method*. A method is defined just like any other Go function. However, its definition
    includes a *method receiver*, which is an extra parameter placed before the method's
    name, used to specify the host type to which the method is attached.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用范围缩小到特定类型的 Go 函数定义。当一个函数的范围缩小到类型时，或者附加到类型上，它被称为 *方法*。方法定义的方式与任何其他 Go 函数一样。然而，它的定义包括一个
    *方法接收器*，这是一个放在方法名之前额外的参数，用于指定方法附加的主类型。
- en: 'To better illustrate this concept, the following figure highlights the different
    parts involved in defining a method. It shows the `quart` method attached to the
    `type gallon` based receiver via the `g gallon` receiver parameter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这个概念，以下图突出了定义方法时涉及的不同部分。它显示了通过 `g gallon` 接收器参数将 `quart` 方法附加到 `type
    gallon` 基础接收器：
- en: '![Go methods](img/00018.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Go 方法](img/00018.jpeg)'
- en: 'As mentioned, a method has the scope of a type. Therefore, it can only be accessed
    via a declared value (concrete or pointer) of the attached type using *dot notation*.
    The following program shows how the declared method `quart` is accessed using
    this notation:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，方法具有类型的范围。因此，它只能通过声明值（具体或指针）使用 *点符号* 访问附加的类型。以下程序展示了如何使用此符号访问声明的 `quart`
    方法：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch08/method_basic.go
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/method_basic.go
- en: In the previous example, the `gal` variable is initialized as the `gallon` type.
    Therefore, the `quart` method can be accessed using `gal.quart()`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`gal` 变量被初始化为 `gallon` 类型。因此，可以使用 `gal.quart()` 来访问 `quart` 方法。
- en: 'At runtime, the receiver parameter provides access to the value assigned to
    the base type of the method. In the example, the `quart` method receives the `g`
    parameter, which passes in a copy of the value for the declared type. So when
    the `gal` variable is initialized with a value of `5`, a call to `gal.quart()`
    sets the receiver parameter `g` to `5`. So the following would then print a value
    of `20`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，接收器参数提供了对方法基本类型的值访问。在示例中，`quart` 方法接收 `g` 参数，它传递了声明的类型的值的副本。因此，当 `gal`
    变量初始化为 `5` 时，对 `gal.quart()` 的调用将接收器参数 `g` 设置为 `5`。因此，以下代码将打印出 `20` 的值：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is important to note that the base type for method receivers cannot be a
    pointer (nor an interface). For instance, the following will not compile:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，方法接收器的基本类型不能是指针（也不能是接口）。例如，以下代码将无法编译：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following shows a lengthier version of the source that implements a more
    general liquid volume conversion program. Each volumetric type receives its respective
    methods to expose behaviors attributed to that type:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了源代码的更长时间版本，它实现了一个更通用的液体体积转换程序。每个体积类型都接收其相应的方法来展示该类型所具有的行为：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: github.com/vladimirvivien/learning-go/ch08/methods.go
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: github.com/vladimirvivien/learning-go/ch08/methods.go
- en: 'For instance, converting `5` gallons to ounces can be done by invoking the
    proper conversion methods on a given value, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将 `5` 加仑转换为盎司可以通过在给定值上调用适当的转换方法来完成，如下所示：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entire implementation uses a simple, but effective, typical structure to
    represent both data type and behavior. Reading the code, it cleanly expresses
    its intended meaning without any reliance on heavy class structures.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 整个实现使用简单但有效的典型结构来表示数据类型和行为。阅读代码时，它清晰地表达了其意图，没有任何对重类结构的依赖。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Method set**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法集**'
- en: The number of methods attached to a type, via the receiver parameter, is known
    as the type's *method set*. This includes both concrete and pointer value receivers.
    The concept of a method set is important in determining type equality, interface
    implementation, and support of the notion of the empty method set for the *empty
    interface* (all discussed in this chapter).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到类型的、通过接收器参数的方法数量被称为该类型的 *方法集*。这包括具体和指针值接收器。方法集的概念在确定类型相等性、接口实现以及支持 *空接口*
    的空方法集概念（本章中均有讨论）中非常重要。
