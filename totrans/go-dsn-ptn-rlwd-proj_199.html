<html><head></head><body>
<div class="book" title="Chapter&#xA0;8.&#xA0;Methods, Interfaces, and Objects" id="1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Go methods">
<div class="book" title="Value and pointer receivers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec138" class="calibre1"/>Value and pointer receivers</h2></div></div></div><p class="calibre10">One aspect of methods that has escaped discussion so far is that receivers are normal function parameters. Therefore, they follow the pass-by-value mechanism of Go functions. This implies that the invoked method gets a copy of the original value from the declared type.</p><p class="calibre10">Receiver parameters can be passed as either values of or pointers of the base type. For instance, the following program shows two methods, <code class="email">half </code>and <code class="email">double</code>; both directly update the value of their respective method receiver parameters, <code class="email">g</code>:</p><pre class="programlisting">package main
import "fmt" 
type gallon float64 
func (g gallon) quart() float64 { 
  return float64(g * 4) 
} 
func (g gallon) half() { 
  g = gallon(g * 0.5) 
} 
func (g *gallon) double() { 
  *g = gallon(*g * 2) 
} 
func main() { 
  var gal gallon = 5 
  gal.half() 
  fmt.Println(gal) 
  gal.double() 
  fmt.Println(gal) 
} 
</pre><p class="calibre10">golang.fyi/ch08/receiver_ptr.go</p><p class="calibre10">In the <code class="email">half</code> method, the code updates the receiver parameter with <code class="email">g = gallon(g * 0.5)</code>. As you would expect, this will not update the original declared value, but rather the copy stored in the <code class="email">g</code> parameter. So, when <code class="email">gal.half()</code> is invoked in <code class="email">main</code>, the original value remains unchanged and the following would print <code class="email">5</code>:</p><pre class="programlisting">func main() { 
   var gal gallon = 5 
   gal.half() 
   fmt.Println(gal) 
} 
</pre><p class="calibre10">Similar to regular function parameters, a receiver parameter that uses a pointer to refer to its base value allows the code to dereference the original value to update it. This is highlighted in the <code class="email">double</code> methodÂ following snippet. It uses a method receiver of the <code class="email">*gallon</code> type, which is updated using <code class="email">*g = gallon(*g * 2)</code>. So when the following is invoked in <code class="email">main</code>, it would print a value of <span class="strong"><strong class="calibre2">10</strong></span>:</p><pre class="programlisting">func main() { 
   var gal gallon = 5 
   gal.double() 
   fmt.Println(gal) 
} 
</pre><p class="calibre10">Pointer receiver parameters are widely used in Go. This is because they make it possible to express object-like primitives that can carry both state and behaviors. As the next section shows, pointer receivers, along with other type features, are the basis for creating objects in Go.</p></div></div></div></body></html>