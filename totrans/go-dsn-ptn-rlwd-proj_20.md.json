["```go\ntype MessageRetriever interface { \n  Message()string \n} \n\ntype Template interface { \n   first() string \n   third() string \n   ExecuteAlgorithm(MessageRetriever) string \n} \n\n```", "```go\ntype TemplateImpl struct{} \n\nfunc (t *TemplateImpl) first() string { \n  return \"\" \n} \n\nfunc (t *TemplateImpl) third() string { \n  return \"\" \n} \n\nfunc (t *TemplateImpl) ExecuteAlgorithm(m MessageRetriever) string { \n  return \"\" \n} \n\n```", "```go\ntype TestStruct struct { \n  Template \n} \n\nfunc (m *TestStruct) Message() string { \n  return \"world\" \n} \n\n```", "```go\nfunc TestTemplate_ExecuteAlgorithm(t *testing.T) { \n  t.Run(\"Using interfaces\", func(t *testing.T){ \n    s := &TestStruct{} \n    res := s.ExecuteAlgorithm(s) \n   expected := \"world\" \n\n    if !strings.Contains(res, expected) { \n      t.Errorf(\"Expected string '%s' wasn't found on returned string\\n\", expected) \n    } \n  }) \n} \n\n```", "```go\ngo test -v . \n=== RUN   TestTemplate_ExecuteAlgorithm\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces\n--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)\n --- FAIL: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)\n template_test.go:47: Expected string ' world ' was not found on returned string\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype Template struct{} \n\nfunc (t *Template) first() string { \n  return \"hello\" \n} \n\nfunc (t *Template) third() string { \n  return \"template\" \n} \n\n```", "```go\nfunc (t *Template) ExecuteAlgorithm(m MessageRetriever) string { \n  return strings.Join([]string{t.first(), m.Message(), t.third()},  \" \") \n} \n\n```", "```go\nfunc Join([]string,string) string \n\n```", "```go\ngo test -v . \n=== RUN   TestTemplate_ExecuteAlgorithm \n=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces \n--- PASS: TestTemplate_ExecuteAlgorithm (0.00s) \n    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s) \nPASS \nok\n\n```", "```go\nfunc TestTemplate_ExecuteAlgorithm(t *testing.T) { \n  t.Run(\"Using interfaces\", func(t *testing.T){ \n    s := &TestStruct{} \n    res := s.ExecuteAlgorithm(s) \n\n    expectedOrError(res, \" world \", t) \n  }) \n\n t.Run(\"Using anonymous functions\", func(t *testing.T)\n  {\n m := new(AnonymousTemplate)\n res := m.ExecuteAlgorithm(func() string {\n return \"world\"\n })\n expectedOrError(res, \" world \", t)\n }) \n} \n\nfunc expectedOrError(res string, expected string, t *testing.T){ \n  if !strings.Contains(res, expected) { \n    t.Errorf(\"Expected string '%s' was not found on returned string\\n\", expected) \n  } \n} \n\n```", "```go\ntype AnonymousTemplate struct{} \n\nfunc (a *AnonymousTemplate) first() string { \n  return \"\" \n} \n\nfunc (a *AnonymousTemplate) third() string { \n  return \"\" \n} \n\nfunc (a *AnonymousTemplate) ExecuteAlgorithm(f func() string) string { \n  return \"\" \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestTemplate_ExecuteAlgorithm\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions\n--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)\n --- FAIL: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)\n template_test.go:47: Expected string ' world ' was not found on returned string\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype AnonymousTemplate struct{} \n\nfunc (a *AnonymousTemplate) first() string { \n  return \"hello\" \n} \n\nfunc (a *AnonymousTemplate) third() string { \n  return \"template\" \n} \n\nfunc (a *AnonymousTemplate) ExecuteAlgorithm(f func() string) string { \n  return strings.Join([]string{a.first(), f(), a.third()}, \" \") \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestTemplate_ExecuteAlgorithm\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions\n--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)\nPASS\nok\n\n```", "```go\ntype TemplateAdapter struct { \n  myFunc func() string \n} \n\nfunc (a *TemplateAdapter) Message() string { \n  return \"\" \n} \n\nfunc MessageRetrieverAdapter(f func() string) MessageRetriever { \n  return nil \n} \n\n```", "```go\nt.Run(\"Using anonymous functions adapted to an interface\", func(t *testing.T){ \n  messageRetriever := MessageRetrieverAdapter(func() string { \n    return \"world\" \n  }) \n\n  if messageRetriever == nil { \n    t.Fatal(\"Can not continue with a nil MessageRetriever\") \n  } \n\n  template := Template{} \n  res := template.ExecuteAlgorithm(messageRetriever) \n\n  expectedOrError(res, \" world \", t) \n}) \n\n```", "```go\ngo test -v .\n=== RUN   TestTemplate_ExecuteAlgorithm\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface\n--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)\n --- FAIL: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface (0.00s)\n template_test.go:39: Can not continue with a nil MessageRetriever\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc MessageRetrieverAdapter(f func() string) MessageRetriever { \n  return &adapter{myFunc: f} \n} \n\n```", "```go\ntype adapter struct { \n  myFunc func() string \n} \n\nfunc (a *adapter) Message() string { \n  if a.myFunc != nil { \n    return a.myFunc() \n  } \n\n  return \"\" \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestTemplate_ExecuteAlgorithm\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions\n=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface\n--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)\n --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface (0.00s)\nPASS\nok\n\n```", "```go\ntype Interface interface { \n  Len() int \n  Less(i, j int) bool \n  Swap(i, j int) \n} \n\n```", "```go\npackage main \n\nimport ( \n  \"sort\" \n  \"fmt\" \n) \n\ntype MyList []int \n\nfunc (m MyList) Len() int { \n  return len(m) \n} \n\nfunc (m MyList) Swap(i, j int) { \n  m[i], m[j] = m[j], m[i] \n} \n\nfunc (m MyList) Less(i, j int) bool { \n  return m[i] < m[j] \n} \n\n```", "```go\nfunc main() { \n  var myList MyList = []int{6,4,2,8,1} \n\n  fmt.Println(myList) \n  sort.Sort(myList) \n  fmt.Println(myList) \n} \n\n```", "```go\ngo run sort_example.go \n[6 4 2 8 1]\n[1 2 4 6 8]\n\n```", "```go\ntype State struct { \n  Description string \n} \n\n```", "```go\ntype memento struct { \n  state State \n} \n\n```", "```go\ntype originator struct { \n  state State \n} \n\nfunc (o *originator) NewMemento() memento { \n  return memento{} \n} \n\nfunc (o *originator) ExtractAndStoreState(m memento) { \n  //Does nothing \n} \n\n```", "```go\ntype careTaker struct { \n  mementoList []memento \n} \n\nfunc (c *careTaker) Add(m memento) { \n  //Does nothing \n} \n\nfunc (c *careTaker) Memento(i int) (memento, error) { \n  return memento{}, fmt.Errorf(\"Not implemented yet\") \n} \n\n```", "```go\nfunc TestCareTaker_Add(t *testing.T) { \n  originator := originator{} \n  originator.state = State{Description:\"Idle\"} \n\n  careTaker := careTaker{} \n  mem := originator.NewMemento() \n  if mem.state.Description != \"Idle\" { \n    t.Error(\"Expected state was not found\") \n  } \n\n```", "```go\n  currentLen := len(careTaker.mementoList) \n  careTaker.Add(mem) \n\n  if len(careTaker.mementoList) != currentLen+1 { \n    t.Error(\"No new elements were added on the list\") \n  } \n\n```", "```go\nfunc TestCareTaker_Memento(t *testing.T) { \n  originator := originator{} \n  careTaker := careTaker{} \n\n  originator.state = State{\"Idle\"} \n  careTaker.Add(originator.NewMemento()) \n\n```", "```go\n  mem, err := careTaker.Memento(0) \n  if err != nil { \n    t.Fatal(err) \n  } \n\n  if mem.state.Description != \"Idle\" { \n    t.Error(\"Unexpected state\") \n  } \n\n```", "```go\n  mem, err = careTaker.Memento(-1) \n  if err == nil { \n    t.Fatal(\"An error is expected when asking for a negative number but no error was found\") \n  } \n} \n\n```", "```go\nfunc TestOriginator_ExtractAndStoreState(t *testing.T) { \n  originator := originator{state:State{\"Idle\"}} \n  idleMemento := originator.NewMemento() \n\n  originator.ExtractAndStoreState(idleMemento) \n  if originator.state.Description != \"Idle\" { \n    t.Error(\"Unexpected state found\") \n  } \n} \n\n```", "```go\ngo test -v . \n=== RUN   TestCareTaker_Add\n--- FAIL: TestCareTaker_Add (0.00s)\n memento_test.go:13: Expected state was not found\n memento_test.go:20: No new elements were added on the list\n=== RUN   TestCareTaker_Memento\n--- FAIL: TestCareTaker_Memento (0.00s)\n memento_test.go:33: Not implemented yet\n=== RUN   TestOriginator_ExtractAndStoreState\n--- FAIL: TestOriginator_ExtractAndStoreState (0.00s)\n memento_test.go:54: Unexpected state found\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype originator struct { \n  state State \n} \n\nfunc (o *originator) NewMemento() memento { \n  return memento{state: o.state} \n} \n\nfunc (o *originator) ExtractAndStoreState(m memento) { \n  o.state = m.state \n} \n\n```", "```go\ntype careTaker struct { \n  mementoList []memento \n} \n\nfunc (c *careTaker) Push(m memento) { \n  c.mementoList = append(c.mementoList, m) \n} \n\nfunc (c *careTaker) Memento(i int) (memento, error) { \n  if len(c.mementoList) < i || i < 0 { \n    return memento{}, fmt.Errorf(\"Index not found\\n\") \n  } \n  return c.mementoList[i], nil \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestCareTaker_Add\n--- PASS: TestCareTaker_Add (0.00s)\n=== RUN   TestCareTaker_Memento\n--- PASS: TestCareTaker_Memento (0.00s)\n=== RUN   TestOriginator_ExtractAndStoreState\n--- PASS: TestOriginator_ExtractAndStoreState (0.00s)\nPASS\nok\n\n```", "```go\ntype Command interface { \n  GetValue() interface{} \n} \n\n```", "```go\ntype Volume byte \n\nfunc (v Volume) GetValue() interface{} { \n  return v \n} \n\ntype Mute bool \n\nfunc (m Mute) GetValue() interface{} { \n  return m \n} \n\n```", "```go\ntype Memento struct { \n  memento Command \n} \n\n```", "```go\ntype originator struct { \n  Command Command \n} \n\nfunc (o *originator) NewMemento() Memento { \n  return Memento{memento: o.Command} \n} \n\nfunc (o *originator) ExtractAndStoreCommand(m Memento) { \n  o.Command = m.memento \n} \n\n```", "```go\ntype careTaker struct { \n  mementoList []Memento \n} \n\nfunc (c *careTaker) Add(m Memento) { \n  c.mementoList = append(c.mementoList, m) \n} \n\nfunc (c *careTaker) Pop() Memento { \n  if len(c.mementoStack) > 0 { \n    tempMemento := c.mementoStack[len(c.mementoStack)-1] \n    c.mementoStack = c.mementoStack[0:len(c.mementoStack)-1] \n    return tempMemento \n  } \n\n  return Memento{} \n} \n\n```", "```go\ntype MementoFacade struct { \n  originator originator \n  careTaker  careTaker \n} \n\nfunc (m *MementoFacade) SaveSettings(s Command) { \n  m.originator.Command = s \n  m.careTaker.Add(m.originator.NewMemento()) \n} \n\nfunc (m *MementoFacade) RestoreSettings(i int) Command { \n  m.originator.ExtractAndStoreCommand(m.careTaker.Memento(i)) \n  return m.originator.Command \n} \n\n```", "```go\nfunc main(){ \n  m := MementoFacade{} \n\n  m.SaveSettings(Volume(4)) \n  m.SaveSettings(Mute(false)) \n\n```", "```go\nfunc assertAndPrint(c Command){ \n  switch cast := c.(type) { \n  case Volume: \n    fmt.Printf(\"Volume:\\t%d\\n\", cast) \n  case Mute: \n    fmt.Printf(\"Mute:\\t%t\\n\", cast) \n  } \n} \n\n```", "```go\nfunc main() { \n  m := MementoFacade{} \n\n  m.SaveSettings(Volume(4)) \n  m.SaveSettings(Mute(false)) \n\n assertAndPrint(m.RestoreSettings(0))\n assertAndPrint(m.RestoreSettings(1)) \n} \n\n```", "```go\n$ go run memento_command.go\nMute:   false\nVolume: 4\n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  return 0, fmt.Errorf(\"Not implemented yet\") \n} \n\n```", "```go\nfunc TestCalculate(t *testing.T) { \n  tempOperation = \"3 4 sum 2 sub\" \n  res, err = Calculate(tempOperation) \n  if err != nil { \n    t.Error(err) \n  } \n\n  if res != 5 { \n    t.Errorf(\"Expected result not found: %d != %d\\n\", 5, res) \n  } \n\n```", "```go\n  tempOperation := \"5 3 sub 8 mul 4 sum 5 div\" \n  res, err := Calculate(tempOperation) \n  if err != nil { \n    t.Error(err) \n  } \n\n  if res != 4 { \n    t.Errorf(\"Expected result not found: %d != %d\\n\", 4, res) \n  } \n} \n\n```", "```go\n(((5 - 3) * 8) + 4) / 5\n ((2 * 8) + 4) / 5\n (16 + 4) / 5\n 20 / 5\n 4\n\n```", "```go\n$ go test -v .\n interpreter_test.go:9: Not implemented yet\n interpreter_test.go:13: Expected result not found: 4 != 0\n interpreter_test.go:19: Not implemented yet\n interpreter_test.go:23: Expected result not found: 5 != 0\nexit status 1\nFAIL\n\n```", "```go\nconst ( \n  SUM = \"sum\" \n  SUB = \"sub\" \n  MUL = \"mul\" \n  DIV = \"div\" \n) \n\n```", "```go\ntype polishNotationStack []int \n\nfunc (p *polishNotationStack) Push(s int) { \n  *p = append(*p, s) \n} \n\nfunc (p *polishNotationStack) Pop() int { \n  length := len(*p) \n\n  if length > 0 { \n    temp := (*p)[length-1] \n    *p = (*p)[:length-1] \n    return temp \n  } \n\n  return 0 \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\n```", "```go\nfunc isOperator(o string) bool { \n  if o == SUM || o == SUB || o == MUL || o == DIV { \n    return true \n  } \n\n  return false \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators {\n if isOperator(operatorString) {\n right := stack.Pop()\n left := stack.Pop()\n } \n  else \n  {\n //Is a value\n } \n}\n\n```", "```go\nfunc getOperationFunc(o string) func(a, b int) int { \n  switch o { \n  case SUM: \n    return func(a, b int) int { \n      return a + b \n    } \n  case SUB: \n    return func(a, b int) int { \n      return a - b \n    } \n  case MUL: \n    return func(a, b int) int { \n      return a * b \n    } \n  case DIV: \n    return func(a, b int) int { \n      return a / b \n    } \n  } \n  return nil \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators { \n  if isOperator(operatorString) { \n      right := stack.Pop() \n      left := stack.Pop() \n mathFunc := getOperationFunc(operatorString)\n res := mathFunc(left, right)\n stack.Push(res) \n    } else { \n      //Is a value \n    } \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators { \n    if isOperator(operatorString) { \n      right := stack.Pop() \n      left := stack.Pop() \n      mathFunc := getOperationFunc(operatorString) \n      res := mathFunc(left, right) \n      stack.Push(res) \n    } else { \n val, err := strconv.Atoi(operatorString)\n if err != nil {\n return 0, err\n }\n stack.Push(val) \n    } \n  } \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators { \n    if isOperator(operatorString) { \n      right := stack.Pop() \n      left := stack.Pop() \n      mathFunc := getOperationFunc(operatorString) \n      res := mathFunc(left, right) \n      stack.Push(res) \n    } else { \n      val, err := strconv.Atoi(operatorString) \n      if err != nil { \n        return 0, err \n      } \n\n      stack.Push(val) \n    } \n  } \n return int(stack.Pop()), nil\n}\n\n```", "```go\n$ go test -v .\nok\n\n```", "```go\ntype Interpreter interface { \n  Read() int \n} \n\n```", "```go\ntype value int \n\nfunc (v *value) Read() int { \n  return int(*v) \n} \n\n```", "```go\ntype operationSum struct { \n  Left  Interpreter \n  Right Interpreter \n} \n\nfunc (a *operationSum) Read() int { \n  return a.Left.Read() + a.Right.Read() \n} \n\n```", "```go\ntype operationSubtract struct { \n  Left  Interpreter \n  Right Interpreter \n} \n\nfunc (s *operationSubtract) Read() int { \n  return s.Left.Read() - s.Right.Read() \n} \n\n```", "```go\nfunc operatorFactory(o string, left, right Interpreter) Interpreter { \n  switch o { \n  case SUM: \n    return &operationSum{ \n      Left: left, \n      Right: right, \n    } \n  case SUB: \n    return &operationSubtract{ \n      Left: left, \n      Right: right, \n    } \n  } \n\n  return nil \n} \n\n```", "```go\ntype polishNotationStack []Interpreter \n\nfunc (p *polishNotationStack) Push(s Interpreter) { \n  *p = append(*p, s) \n} \n\nfunc (p *polishNotationStack) Pop() Interpreter { \n  length := len(*p) \n\n  if length > 0 { \n    temp := (*p)[length-1] \n    *p = (*p)[:length-1] \n    return temp \n  } \n\n  return nil \n} \n\n```", "```go\nfunc main() { \n  stack := polishNotationStack{} \n  operators := strings.Split(\"3 4 sum 2 sub\", \" \") \n\n  for _, operatorString := range operators { \n    if operatorString == SUM || operatorString == SUB { \n      right := stack.Pop() \n      left := stack.Pop() \n      mathFunc := operatorFactory(operatorString, left, right) \n      res := value(mathFunc.Read()) \n      stack.Push(&res) \n    } else { \n      val, err := strconv.Atoi(operatorString) \n      if err != nil { \n        panic(err) \n      } \n\n      temp := value(val) \n      stack.Push(&temp) \n    } \n  } \n\n  println(int(stack.Pop().Read())) \n} \n\n```", "```go\n$ go run interpreter.go\n5\n\n```"]