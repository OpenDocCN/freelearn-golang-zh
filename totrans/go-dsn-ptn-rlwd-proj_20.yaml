- en: Chapter 6. Behavioral Patterns - Template, Memento, and Interpreter Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see the next three Behavioral design patterns. The
    difficulty is being raised as now we will use combinations of Structural and Creational
    patterns to better solve the objective of some of the Behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with Template design pattern, a pattern that looks very similar
    to the Strategy pattern but that provides greater flexibility. Memento design
    pattern is used in 99% of applications we use every day to achieve undo functions
    and transactional operations. Finally, we will write a reverse polish notation
    interpreter to perform simple mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the Template design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Template design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Template** pattern is one of those widely used patterns that are incredibly
    useful, especially when writing libraries and frameworks. The idea is to provide
    a user some way to execute code within an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how to write idiomatic Go Template patterns and
    see some Go source code where it's wisely used. We will write an algorithm of
    three steps where the second step is delegated to the user while the first and
    third aren't. The first and third steps on the algorithm represent the template.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While with the Strategy pattern we were encapsulating algorithm implementation
    in different strategies, with the Template pattern we will try to achieve something
    similar but with just part of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Template design pattern lets the user write a part of an algorithm while
    the rest is executed by the abstraction. This is common when creating libraries
    to ease in some complex task or when reusability of some algorithm is compromised
    by only a part of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine, for example, that we have a long transaction of HTTP requests. We
    have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticate user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorize him.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve some details from a database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make some modification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the details back in a new request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It wouldn't make sense to repeat steps 1 to 5 in the user's code every time
    he needs to modify something on the database. Instead, steps 1, 2, 3, and 5 will
    be abstracted in the same algorithm that receives an interface with whatever the
    fifth step needs to finish the transaction. It doesn't need to be a interface
    either, it could be a callback.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Template design pattern is all about reusability and giving responsibilities
    to the user. So the objectives for this pattern are following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defer a part of an algorithm of the library to a the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve reusability by abstracting the parts of the code that are not common
    between executions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example - a simple algorithm with a deferred step
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our first example, we are going to write an algorithm that is composed of
    three steps and each of them returns a message. The first and third steps are
    controlled by the Template and just the second step is deferred to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A brief description of what the Template pattern has to do is to define a template
    for an algorithm of three steps that defers the implementation of the second step
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Each step in the algorithm must return a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step is a method called `first()` and returns the string `hello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third step is a method called `third()` and returns the string `template`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is whatever string the user wants to return but it's defined
    by the `MessageRetriever` interface that has a `Message() string` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm is executed sequentially by a method called `ExecuteAlgorithm`
    and returns the strings returned by each step joined in a single string by a space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit tests for the simple algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will focus on testing the public methods only. This is a very common approach.
    All in all, if your private methods aren''t called from some level of the public
    ones, they aren''t called at all. We need two interfaces here, one for the Template
    implementors and one for the abstract step of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A Template implementor will accept a `MessageRetriever` interface to execute
    as part of its execution algorithm. We need a type that implements this interface
    called `Template`, we will call it `TemplateImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So our first test checks the fourth and fifth acceptance criteria. We will
    create the `TestStruct` type that implements the `MessageRetriever` interface
    returning the string `world` and has embedded the Template so that it can call
    the `ExecuteAlgorithm` method. It will act as the Template and the abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we will define the `TestStruct` type. In this case, the part of the algorithm
    deferred to us is going to return the `world` text. This is the string we will
    look for later in the test doing a check of type "is the word `world` present
    on this string?".
  prefs: []
  type: TYPE_NORMAL
- en: Take a close look, the `TestStruct` embeds a type called `Template` which represents
    the Template pattern of our algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we implement the `Message()` method, we are implicitly implementing the
    `MessageRetriever` interface. So now we can use `TestStruct` type as a pointer
    to a `MessageRetriever` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the test, we will use the type we have just created. When we call the `ExecuteAlgorithm`
    method, we need to pass the `MessageRetriever` interface. As the `TestStruct`
    type also implements the `MessageRetriever` interface, we can pass it as an argument,
    but this is not mandatory, of course.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the `ExecuteAlgorithm` method, as defined in the fifth acceptance
    criterion, must return a string that contains the returned value of the `first()` method,
    the returned value of `TestStruct` (the `world` string) and the returned value
    of the `third()` method separated by a space. Our implementation is on the second
    place; that's why we checked that a space is prefixed and suffixed on the string
    `world`.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the returned string, when calling the `ExecuteAlgorithm` method, doesn't
    contain the string `world`, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is enough to make the project compile and run the tests that should fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Time to pass to the implementation of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Template pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As defined in the acceptance criteria, we have to return the string `hello`
    in the `first()` method and the string `template` in the `third()` method. That''s
    pretty easy to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, we should be covering the *second* and *third* acceptance
    criteria and partially covering the *first* criterion (each step in the algorithm
    must return a string).
  prefs: []
  type: TYPE_NORMAL
- en: 'To cover the *fifth* acceptance criterion, we define an `ExecuteAlgorithm`
    method that accepts the `MessageRetriever` interface as argument and returns the
    full algorithm: a single string done by joining the strings returned by the `first()`,
    `Message() string` and `third()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strings.Join` function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It takes an array of strings and joins them, placing the second argument between
    each item in the array. In our case, we create a string array on the fly to pass
    it as the first argument. Then we pass a whitespace as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this implementation, the tests must be passing already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The tests passed. The test has checked that the string `world` is present in
    the returned result, which is the `hello world template` message. The `hello` text
    was the string returned by the `first()` method, the `world` string was returned
    by our `MessageRetriever` implementation, and `template` was the string returned
    by the `third()` method. The whitespaces are inserted by Go's `strings.Join` function.
    But any use of the `TemplateImpl.ExecuteAlgorithm` type will always return "hello
    [something] template" in its result.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not the only way to achieve the Template design pattern. We can also
    use an anonymous function to give our implementation to the `ExecuteAlgorithm`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test in the same method that was used previously just after
    the test (marked in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our new test is called *Using anonymous functions*. We have also extracted the
    checking on the test to an external function to reuse it in this test. We have
    called this function `expectedOrError` because it will fail with an error if the
    expected value isn't received.
  prefs: []
  type: TYPE_NORMAL
- en: In our test, we will create a type called `AnonymousTemplate` that replaces
    the previous `Template` type. The `ExecuteAlgorithm` method of this new type accepts
    the `func()` method `string` type that we can implement directly in the test to
    return the string `world`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnonymousTemplate` type will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference with the `Template` type is that the `ExecuteAlgorithm`
    method accepts a function that returns a string instead of a `MessageRetriever`
    interface. Let''s run the new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can read in the output of the test execution, the error is thrown on
    the *Using anonymous functions* test, which is what we were expecting. Now we
    will write the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is quite similar to the one in the `Template` type. However,
    now we have passed a function called `f` that we will use as the second item in
    the string array we used on `Join` function. As `f` is simply a function that
    returns a string, the only thing we need to do with it is to execute it in the
    proper place (the second position in the array).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Now we know two ways to implement the Template design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How to avoid modifications on the interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem of the previous approach is that now we have two templates to maintain
    and we could end duplicating code. What can we do in the situation that we cannot
    change the interface are we using? Our interface was `MessageRetriever` but we
    want to use an anonymous function now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, do you remember the Adapter design pattern? We just have to create an
    `Adapter` type that, accepting a `func() string` type, returns an implementation
    of the `MessageRetriever` interface. We will call this type `TemplateAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `TemplateAdapter` type has a field called `myFunc` which
    is of type `func() string`. We have also defined adapter as private because it
    shouldn''t be used without a function defined in the `myFunc` field. We have created
    a public function called the `MessageRetrieverAdapter` to achieve this. Our test
    should look more or less like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Look at the statement where we called the `MessageRetrieverAdapter` method.
    We passed an anonymous function as an argument defined as `func()` string. Then,
    we reuse the previously defined `Template` type from our first test to pass the
    `messageRetriever` variable. Finally, we checked again with the `expectedOrError`
    method. Take a look at the `MessageRetrieverAdapter` method, it will return a
    function that has nil value. If strictly following the test-driven development
    rules, we must do tests first and they must not pass before implementation is
    done. That's why we returned nil on the `MessageRetrieverAdapter` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The test fails on *line 39* of the code and it doesn't continue (again, depending
    on how you wrote your code, the line representing your error could be somewhere
    else). We stop test execution because we will need a valid `MessageRetriever`
    interface when we call the `ExecuteAlgorithm` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the implementation of the adapter for our Template pattern, we will start
    with `MessageRetrieverAdapter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It's very easy, right? You could be wondering what happens if we pass `nil` value
    for the `f` argument. Well, we will cover this issue by calling the `myFunc` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `adapter` type is finished with this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When calling the `Message()` function, we check that we actually have something
    stored in the `myFunc` function before calling. If nothing was stored, we return
    an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our third implementation of the `Template` type, using the Adapter pattern,
    is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Looking for the Template pattern in Go's source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Sort` package in Go's source code can be considered a Template implementation
    of a sort algorithm. As defined in the package itself, the `Sort` package provides
    primitives for sorting slices and user-defined collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can also find a good example of why Go authors aren''t worried about
    implementing generics. Sorting the lists is maybe the best example of generic
    usage in other languages. The way that Go deals with this is very elegant too-it
    deals with this issue with an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the interface for lists that need to be sorted by using the `sort`
    package. In the words of Go''s authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A type, typically, is a collection that satisfies sort. Interface can be
    sorted by the routines in this package. The methods require that the elements
    of the collection be enumerated by an integer index."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, write a type that implements this `Interface` so that the `Sort`
    package can be used to sort any slice. The sorting algorithm is the template and
    we must define how to retrieve values in our slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we peek in the `sort` package, we can also find an example of how to use
    the sorting template but we will create our own example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we have done a very simple type that stores an `int` list. This could
    be any kind of list, usually a list of some kind of struct. Then we have implemented
    the `sort.Interface` interface by defining the `Len`, `Swap`, and `Less` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `main` function creates an unordered list of numbers of the `MyList`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We print the list that we created (unordered) and then we sort it (the `sort.Sort`
    method actually modifies our variable instead of returning a new list so beware!).
    Finally, we print again the resulting list. The console output of this `main`
    method is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `sort.Sort` function has sorted our list in a transparent way. It has a
    lot of code written and delegates `Len`, `Swap` and `Less` methods to an interface,
    like we did in our template delegating to the `MessageRetriever` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the Template design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We wanted to put a lot of focus on this pattern because it is very important
    when developing libraries and frameworks and allows a lot of flexibility and control
    to users of our library.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen again that it's very common to mix patterns to provide flexibility
    to the users, not only in a behavioral way but also structural. This will come
    very handy when working with concurrent apps where we need to restrict access
    to parts of our code to avoid races.
  prefs: []
  type: TYPE_NORMAL
- en: Memento design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now look at a pattern with a fancy name. If we check a dictionary to
    see the meaning of *memento*, we will find the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"An object kept as a reminder of a person or event."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here, the key word is **reminder** as we will remember actions with this design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The meaning of memento is very similar to the functionality it provides in design
    patterns. Basically, we'll have a type with some state and we want to be able
    to save milestones of its state. Having a finite amount of states saved, we can
    recover them if necessary for a variety of tasks-undo operations, historic, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Memento design pattern usually has three players (usually called **actors**):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memento**: A type that stores the type we want to save. Usually, we won''t
    store the business type directly and we provide an extra layer of abstraction
    through this type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Originator**: A type that is in charge of creating mementos and storing the
    current active state. We said that the Memento type wraps states of the business
    type and we use originator as the creator of mementos.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Care Taker**: A type that stores the list of mementos that can have the logic
    to store them in a database or to not store more than a specified number of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memento is all about a sequence of actions over time, say to undo one or two
    operations or to provide some kind of transactionality to some application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memento provides the foundations for many tasks, but its main objectives could
    be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture an object state without modifying the object itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save a limited amount of states so we can retrieve them later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple example with strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop a simple example using a string as the state we want to save.
    This way, we will focus on the common Memento pattern implementations before making
    it a bit more complex with a new example.
  prefs: []
  type: TYPE_NORMAL
- en: The string, stored in a field of a `State` instance, will be modified and we
    will be able to undo the operations done in this state.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are constantly talking about state; all in all, the Memento pattern is about
    storing and retrieving states. Our acceptance criteria must be all about states:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to store a finite amount of states of type string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a way to restore the current stored state to one of the state list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these two simple requirements, we can already start writing some tests
    for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, the Memento design pattern is usually composed of
    three actors: state, memento, and originator. So we will need three types to represent
    these actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `State` type is the core business object we will be using during this example.
    It''s any kind of object that we want to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `memento` type has a field called `state` representing a single value of
    a `State` type. Our `states` will be containerized within this type before storing
    them into the `care taker` type. You could be wondering why we don''t store directly
    `State` instances. Basically, because it will couple the `originator` and the
    `careTaker` to the business object and we want to have as little coupling as possible.
    It will also be less flexible, as we will see in the second example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `originator` type also stores a state. The `originator` struct's objects
    will take states from mementos and create new mementos with their stored state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What's the difference between the originator object and the Memento pattern?
    Why don't we use Originator pattern's object directly? Well, if the Memento contains
    a specific state, the `originator` type contains the state that is currently loaded.
    Also, to save the state of something could be as simple as to take some value
    or as complex as to maintain the state of some distributed application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Originator will have two public methods--the `NewMemento()` method and
    the `ExtractAndStoreState(m memento)` method. The `NewMemento` method will return
    a new Memento built with `originator` current `State` value. The `ExtractAndStoreState`
    method will take the state of a Memento and store it in the `Originator`''s state
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `careTaker` type stores the Memento list with all the states we need to
    save. It also stores an `Add` method to insert a new Memento on the list and a
    Memento retriever that takes an index on the Memento list.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start with the `Add` method of the `careTaker` type. The `Add` method
    must take a `memento` object and add it to the `careTaker` object''s list of Mementos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of our test, we created two basic actors for memento--the `originator`
    and the `careTaker`. We set a first state on the originator with the description
    `Idle`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the first Memento calling the `NewMemento` method. This should
    wrap the current originator's state in a `memento` type. Our first check is very
    simple--the state description of the returned Memento must be like the state description
    we pass to the originator, that is, the `Idle` description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to check whether our Memento''s `Add` method works correctly
    is to see whether the Memento list has grown after adding one item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to test the `Memento(int) memento` method. This should take a
    `memento` value from the `careTaker` list. It takes the index you want to retrieve
    from the list so, as usual with lists, we must check that it behaves correctly
    against negative numbers and out of index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to start like we did in our previous test--creating an `originator`
    and `careTaker` objects and adding the first Memento to the `caretaker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the first object on the `careTaker` object, we can ask for it using `careTaker.Memento(0)`.
    Index `0` on the `Memento(int)` method retrieves the first item on the slice (remember
    that slices start with `0`). No error should be returned because we have already
    added a value to the `caretaker` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after retrieving the first memento, we checked that the description matches
    the one that we passed at the beginning of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The last step on this test involves using a negative number to retrieve some
    value. In this case, an error must be returned that shows that no negative numbers
    can be used. It is also possible to return the first index when you pass negative
    numbers but here we will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function to check is the `ExtractAndStoreState` method. This function
    must take a Memento and extract all its state information to set it in the `Originator`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This test is simple. We create a default `originator` variable with an `Idle`
    state. Then, we retrieve a new Memento object to use it later. We change the state
    of the `originator` variable to the `Working` state to ensure that the new state
    will be written.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to call the `ExtractAndStoreState` method with the `idleMemento`
    variable. This should restore the state of the originator to the `idleMemento`
    state's value, something that we checked in the last `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Because the three tests fail, we can continue with the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Memento pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Memento pattern''s implementation is usually very simple if you don''t
    get too crazy. The three actors (`memento`, `originator`, and `care taker`) have
    a very defined role in the pattern and their implementation is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Originator` object needs to return a new values of Memento types when
    calling the `NewMemento` method. It also needs to store the value of a `memento`
    object in the state field of the struct as needed for the `ExtractAndStoreState`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `careTaker` type is also straightforward. When we call the `Add` method,
    we overwrite the `mementoList` field by calling the `append` method with the value
    passed in the argument. This creates a new list with the new value included.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the `Memento` method, we have to do a couple of checks beforehand.
    In this case, we check that the index is not outside of the range of the slice
    and that the index is not a negative number in the `if` statement, in which case
    we return an error. If everything goes fine, it just returns the specified `memento`
    object and no errors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A note about method and function naming conventions. You could find some people
    that like to give slightly more descriptive names to methods such as `Memento`.
    An example would be to use a name such as `MementoOrError` method, clearly showing
    that you return two objects when calling this function or even `GetMementoOrError`
    method. This could be a very explicit approach for naming and it's not necessarily
    bad, but you won't find it very common in Go's source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to check the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: That was enough to reach 100% of coverage. While this is far from being a perfect
    metric, at least we know that we are reaching every corner of our source code
    and that we haven't cheated in our tests to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: Another example using the Command and Facade patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example is good and simple enough to understand the functionality
    of the Memento pattern. However, it is more commonly used in conjunction with
    the Command pattern and a simple Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to use a Command pattern to encapsulate a set of different types
    of states (those that implement a `Command` interface) and provide a small facade
    to automate the insertion in the `caretaker` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to develop a small example of a hypothetical audio mixer. We are
    going to use the same Memento pattern to save two types of states: `Volume` and
    `Mute`. The `Volume` state is going to be a byte type and the `Mute` state a Boolean
    type. We will use two completely different types to show the flexibility of this
    approach (and its drawbacks).'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, we can also ship each `Command` interface with their own serialization
    methods on the interface. This way, we can give the ability to the caretaker to
    store states in some kind of storage without really knowing what's storing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Command` interface is going to have one method to return the value of
    its implementer. It''s very simple, every command in our audio mixer that we want
    to undo will have to implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something interesting in this interface. The `GetValue` method returns
    an interface to a value. This also means that the return type of this method is...
    well... untyped? Not really, but it returns an interface that can be a representation
    of any type and we will need to typecast it later if we want to use its specific
    type. Now we have to define the `Volume` and `Mute` types and implement the `Command`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: They are both quite easy implementations. However, the `Mute` type will return
    a `bool` type on the `GetValue()` method and `Volume` will return a `byte` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, we''ll need a `Memento` type that will hold a `Command`.
    In other words, it will store a pointer to a `Mute` or a `Volume` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `originator` type works as in the previous example but uses the `Command`
    keyword instead of the `state` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `caretaker` object is almost the same, but this time we''ll use a stack
    instead of a simple list and we will store a command instead of a state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: However, our `Memento` list is replaced with a `Pop` method. It also returns
    a `memento` object but it will return them acting as a stack (last to enter, first
    to go out). So, we take the last element on the stack and store it in the `tempMemento`
    variable. Then we replace the stack with a new version that doesn't contain the
    last element on the next line. Finally, we return the `tempMemento` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, everything looks almost like in the previous example. We also talked
    about automating some tasks by using the Facade pattern, so let''s do it. This
    is going to be called the `MementoFacade` type and will have the `SaveSettings`
    and `RestoreSettings` methods. The `SaveSettings` method takes a `Command`, stores
    it in an inner originator, and saves it in an inner `careTaker` field. The `RestoreSettings`
    method makes the opposite flow-restores an index of the `careTaker` and returns
    the `Command` inside the `Memento` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Our Facade pattern will hold the contents of the originator and the care taker
    and will provide those two easy-to-use methods to save and restore settings.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we use this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: First, we get a variable with a Facade pattern. Zero-value initialization will
    give us zero-valued `originator` and `caretaker` objects. They don't have any
    unexpected field so everything will initialize correctly (if any of them had a
    pointer, for example, it would be initialized to `nil` as mentioned in the *Zero
    initialization* section of [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!*).
  prefs: []
  type: TYPE_NORMAL
- en: We create a `Volume` value with `Volume(4)` and, yes, we have used parentheses.
    The `Volume` type does not have any inner field like structs so we cannot use
    curly braces to set its value. The way to set it is to use parentheses (or create
    a pointer to the type `Volume` and then set the value of the pointed space). We
    also save a value of the type `Mute` using the Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t know what `Command` type is returned here, so we need to make a type
    assertion. We will make a small function to help us with this that checks the
    type and prints an appropriate value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `assertAndPrint` method takes a `Command` type and casts it to the two
    possible types-`Volume` or `Mute`. In each case, it prints a message to the console
    with a personalized message. Now we can continue and finish the `main` function,
    which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The part highlighted in bold shows the new changes within the `main` function.
    We took the index 0 from the `careTaker` object and passed it to the new function
    and the same with the index `1`. Running this small program, we should get the
    `Volume` and `Mute` values on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Great! In this small example, we have combined three different design patterns
    to keep getting comfortable using various patterns. Keep in mind that we could
    have abstracted the creation of `Volume` and `Mute` states to a Factory pattern
    too so this is not where would stop.
  prefs: []
  type: TYPE_NORMAL
- en: Last words on the Memento pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Memento pattern, we have learned a powerful way to create undoable
    operations that are very useful when writing UI applications but also when you
    have to develop transactional operations. In any case, the situation is the same:
    you need a `Memento`, an `Originator`, and a `caretaker` actor.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **transaction operation** is a set of atomic operations that must all be done
    or fail. In other words, if you have a transaction composed of five operations
    and just one of them fails, the transaction cannot be completed and every modification
    done by the other four must be undone.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to dig into a quite complex pattern. The **Interpreter** pattern
    is, in fact, widely used to solve business cases where it's useful to have a language
    to perform common operations. Let's see what we mean by language.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most famous interpreter we can talk about is probably SQL. It's defined
    as a special-purpose programming language for managing data held in relational
    databases. SQL is quite complex and big but, all in all, is a set of words and
    operators that allow us to perform operations such as insert, select, or delete.
  prefs: []
  type: TYPE_NORMAL
- en: Another typical example is musical notation. It's a language itself and the
    interpreter is the musician who knows the connection between a note and its representation
    on the instrument they are playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In computer science, it can be useful to design a small language for a variety
    of reasons: repetitive tasks, higher-level languages for non-developers, or **Interface
    Definition Languages** (**IDL**) such as **Protocol buffers** or **Apache Thrift**.'
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Designing a new language, big or small, can be a time consuming task so it''s
    very important to have the objectives clear before investing time and resources
    on writing an interpreter of it:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide syntax for very common operations in some scope (such as playing notes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a intermediate language to translate actions between two systems. For example,
    the apps that generate the **Gcode** needed to print with 3D printers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease the use of some operations in an easier-to-use syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL allows the use of relational databases in a very easy-to-use syntax (that
    can become incredibly complex too) but the idea is to not need to write your own
    functions to make insertions and searches.
  prefs: []
  type: TYPE_NORMAL
- en: Example - a polish notation calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very typical example of an interpreter is to create a reverse polish notation
    calculator. For those who don't know what polish notation is, it's a mathematical
    notation to make operations where you write your operation first (sum) and then
    the values (3 4), so *+ 3 4* is equivalent to the more common *3 + 4* and its
    result would be *7*. So, for a reverse polish notation, you put first the values
    and then the operation, so *3 4 +* would also be *7*.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria for the calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our calculator, the acceptance criteria we should pass to consider it done
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a language that allows making common arithmetic operations (sums, subtractions,
    multiplications, and divisions). The syntax is `sum` for sums, `mul` for multiplications,
    `sub` for subtractions, and `div` for divisions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must be done using reverse polish notation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user must be able to write as many operations in a row as they want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operations must be performed from left to right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So the `3 4 sum 2 sub` notation is the same than *(3 + 4) - 2* and result would
    be *5*.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test of some operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this case, we will only have a public method called `Calculate` that takes
    an operation with its values defined as a string and will return a value or an
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we will send a string like `"3 4 +"` to the `Calculate` method and it should
    return *7, nil*. Two tests more will check the correct implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we are going to make the operation we have used as an example. The `3
    4 sum 2 sub` notation is part of our language and we use it in the `Calculate`
    function. If an error is returned, the test fails. Finally, the result must be
    equal to `5` and we check it on the last lines. The next test checks the rest
    of the operators on slightly more complex operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we repeated the preceding process with a longer operation, the *(((5
    - 3) * 8) + 4) / 5* notation which is equal to *4*. From left to right, it would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The test must fail, of course!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementation is going to be longer than testing this time. To start, we will
    define our possible operators in constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Interpreter patterns are usually implemented using an abstract syntax tree,
    something that is commonly achieved using a stack. We have created stacks before
    during the book so this should be already familiar to readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We have two methods--the `Push` method to add elements to the top of the stack
    and the `Pop` method to remove elements and return them. In case you are thinking
    that the line `*p = (*p)[:length-1]` is a bit cryptic, we'll explain it.
  prefs: []
  type: TYPE_NORMAL
- en: The value stored in the direction of `p` will be overridden with the actual
    value in the direction of `p (*p)` but taking only the elements from the beginning
    to the penultimate element of the array `(:length-1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we will go step by step with the `Calculate` function, creating more
    functions as far as we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first two things we need to do are to create the stack and to get all different
    symbols from the incoming operation (in this case, we aren't checking that it
    isn't empty). We split the incoming string operations by the space to get a nice
    slice of symbols (values and operators).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will iterate over every symbol by using range but we need a function
    to know whether the incoming symbol is a value or an operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the incoming symbol is any of the ones defined in our constants, the incoming
    symbol is an operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is an operator, we consider that we have already passed two values so
    what we have to do is to take those two values from the stack. The first value
    taken would be the rightmost and the second the leftmost (remember that in subtractions
    and divisions, the order of the operands is important). Then, we need some function
    to get the operation we want to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getOperationFunc` functions returns a two-argument function that returns
    an integer. We check the incoming operator and we return an anonymous function
    that performs the specified operation. So, now our `for range` continues like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `mathFunc` variable is returned by the function. We use it immediately to
    perform the operation on the left and right values taken from the stack and we
    store its result in a new variable called `res`. Finally, we need to push this
    new value to the stack to keep operating with it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here is the implementation when the incoming symbol is a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: What we need to do every time we get a symbol is to push it to the stack. We
    have to parse the string symbol to a usable `int` type. This is commonly done
    with the `strconv` package by using its `Atoi` function. The `Atoi` function takes
    a string and returns an integer from it or an error. If everything goes well,
    the value is pushed into the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `range` statement, just one value must be stored on it, so
    we just need to return it and the function is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have just created a reverse polish notation interpreter in a very
    simple and easy way (we still lack the parser, but that's another story).
  prefs: []
  type: TYPE_NORMAL
- en: Complexity with the Interpreter design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we haven't used any interfaces. This is not exactly how the
    Interpreter design pattern is defined in more object-oriented languages. However,
    this example is the simplest example possible to understand the objectives of
    the language and the next level is inevitably much more complex and not intended
    for beginner users.
  prefs: []
  type: TYPE_NORMAL
- en: With a more complex example, we will have to define a type containing more types
    of itself, a value, or nothing. With a parser, you create this abstract syntax
    tree to interpret it later.
  prefs: []
  type: TYPE_NORMAL
- en: The same example, done by using interfaces, would be as in the following description
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter pattern again - now using interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main interface we are going to use is called the `Interpreter` interface.
    This interface has a `Read()` method that every symbol (value or operator) must
    implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will implement only the sum and the subtraction from the operators and a
    type called `Value` for the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Value` is a type `int` that, when implementing the `Read` method, just
    returns its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `operationSum` struct has the `Left` and `Right` fields and its `Read`
    method returns the sum of each of their `Read` methods. The `operationSubtract` struct
    is the same but subtracting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a Factory pattern to create operators; we will call it the `operatorFactory`
    method. The difference now is that it not only accepts the symbol but also the
    `Left` and `Right` values taken from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have just mentioned, we also need a stack. We can reuse the one from
    the previous example by changing its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the stack works with Interpreter pointers instead of `int` but its functionality
    is the same. Finally, our `main` method also looks similar to our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Like before, we check whether the symbol is operator or value first. When it's
    a value, it pushes it into the stack.
  prefs: []
  type: TYPE_NORMAL
- en: When the symbol is an operator, we also take the right and left values from
    the stack, we call the Factory pattern using the current operator and the left
    and right values that we just took from the stack. Once we have the operator type,
    we just need to call its `Read` method to push the returned value to the stack
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, just one example must be left on the stack, so we print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The power of the Interpreter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern is extremely powerful but it must also be used carefully. To create
    a language, it generates a strong coupling between its users and the functionality
    it provides. One can fall into the error of trying to create a too flexible language
    that is incredibly complex to use and maintain. Also, one can create a fairly
    small and useful language that doesn't interpret correctly sometimes and it could
    be a pain for its users.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have omitted quite a lot of error-checking to focus on the
    implementation of the Interpreter. However, you'll need quite a lot of error checking
    and verbose output on errors to help the user correct its syntax errors. So, have
    fun writing your language but be nice to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has dealt with three extremely powerful patterns that require
    a lot of practice before using them in production code. It''s a very good idea
    to make some exercises with them by simulating typical production problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple REST server that reuses most of the error-checking and connection
    functionality to provide an easy-to-use interface to practice the Template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a small library that can write to different databases but only in the case
    that all writes were OK, or delete the newly created writes to practice Memento
    for example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write your own language, to make simple things such as answering simple questions
    like bots usually do so you can practice a bit of the Interpreter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea is to practice coding and reread any section until you get comfortable
    with each pattern.
  prefs: []
  type: TYPE_NORMAL
