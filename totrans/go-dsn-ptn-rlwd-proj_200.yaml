- en: Objects in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lengthy introductory material from the previous sections was the setup to
    lead to the discussion of objects in Go. It has been mentioned that Go was not
    designed to function as traditional object-oriented language. There are no object
    or class keywords defined in Go. So then, why are we discussing objects in Go
    at all? Well, it turns out that Go perfectly supports object idioms and the practice
    of object-oriented programming without the heavy baggage of classical hierarchies
    and complex inheritance structures found in other object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: Let us review some of the primordial features usually attributed to an object-oriented
    language in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Object feature** | **Go** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| Object: A data type that stores states and exposes behavior | Yes | In Go
    all types can achieve this. There is no special type called a class or object
    to do this. Any type can receive a set of method to define its behavior, although
    the `struct` type comes the closest to what is commonly called an object in other
    languages. |'
  prefs: []
  type: TYPE_TB
- en: '| Composition | Yes | Using a type such as a `struct` or an `interface` (discussed
    later), it is possible to create objects and express their polymorphic relationships
    through composition. |'
  prefs: []
  type: TYPE_TB
- en: '| Subtype via interface | Yes | A type that defines a set of behaviors (methods)
    that other types may implement. Later you will see how it is used to implement
    object sub-typing. |'
  prefs: []
  type: TYPE_TB
- en: '| Modularity and encapsulation | Yes | Go supports physical and logical modularity
    at its core with concepts such packages and an extensible type system, and code
    element visibility. |'
  prefs: []
  type: TYPE_TB
- en: '| Type inheritance | No | Go does not support polymorphism through inheritance.
    A newly declared named type does not inherit all attributes of its underlying
    type and are treated differently by the type system. As a consequence, it is hard
    to implement inheritance via type lineage as found in other languages. |'
  prefs: []
  type: TYPE_TB
- en: '| Classes | No | There is no notion of a class type that serves as the basis
    for objects in Go. Any data type in Go can be used as an object. |'
  prefs: []
  type: TYPE_TB
- en: As the previous table suggests, Go supports the majority of concepts that are
    usually attributed to object-oriented programming. The remainder of this chapter
    covers topics and examples showing how to use Go as an object-oriented programming
    language.
  prefs: []
  type: TYPE_NORMAL
