- en: Objects in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 中的对象
- en: The lengthy introductory material from the previous sections was the setup to
    lead to the discussion of objects in Go. It has been mentioned that Go was not
    designed to function as traditional object-oriented language. There are no object
    or class keywords defined in Go. So then, why are we discussing objects in Go
    at all? Well, it turns out that Go perfectly supports object idioms and the practice
    of object-oriented programming without the heavy baggage of classical hierarchies
    and complex inheritance structures found in other object-oriented languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的冗长介绍材料是为了引出对 Go 中对象的讨论。提到 Go 并非设计为作为传统的面向对象语言。Go 中没有定义对象或类关键字。那么，我们为什么还要讨论
    Go 中的对象呢？好吧，事实证明，Go 完美地支持面向对象的习惯用法和面向对象编程的实践，而没有其他面向对象语言中发现的经典层次结构和复杂的继承结构所带来的沉重负担。
- en: Let us review some of the primordial features usually attributed to an object-oriented
    language in the following table.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下表中回顾一下通常归因于面向对象语言的一些原始特征。
- en: '| **Object feature** | **Go** | **Comment** |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| **对象特征** | **Go** | **注释** |'
- en: '| Object: A data type that stores states and exposes behavior | Yes | In Go
    all types can achieve this. There is no special type called a class or object
    to do this. Any type can receive a set of method to define its behavior, although
    the `struct` type comes the closest to what is commonly called an object in other
    languages. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 对象：存储状态并公开行为的类型 | 是 | 在 Go 中，所有类型都可以实现这一点。没有称为类或对象的特殊类型来完成这项工作。任何类型都可以接收一组方法来定义其行为，尽管
    `struct` 类型在语言中通常称为对象的其他语言中最为接近。|'
- en: '| Composition | Yes | Using a type such as a `struct` or an `interface` (discussed
    later), it is possible to create objects and express their polymorphic relationships
    through composition. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 组合 | 是 | 使用如 `struct` 或 `interface`（稍后讨论）之类的类型，可以通过组合创建对象并表达它们的多态关系。|'
- en: '| Subtype via interface | Yes | A type that defines a set of behaviors (methods)
    that other types may implement. Later you will see how it is used to implement
    object sub-typing. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 通过接口实现子类型 | 是 | 定义了一组行为（方法）的类型，其他类型可以实施。稍后你将看到它是如何用于实现对象子类型化的。|'
- en: '| Modularity and encapsulation | Yes | Go supports physical and logical modularity
    at its core with concepts such packages and an extensible type system, and code
    element visibility. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 模块化和封装 | 是 | Go 通过概念如包和可扩展的类型系统以及代码元素可见性，在其核心支持物理和逻辑模块化。|'
- en: '| Type inheritance | No | Go does not support polymorphism through inheritance.
    A newly declared named type does not inherit all attributes of its underlying
    type and are treated differently by the type system. As a consequence, it is hard
    to implement inheritance via type lineage as found in other languages. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 类型继承 | 否 | Go 不支持通过继承实现多态。新声明的命名类型不会继承其底层类型的所有属性，并且类型系统会以不同的方式处理它们。因此，很难像在其他语言中找到的那样通过类型谱系实现继承。|'
- en: '| Classes | No | There is no notion of a class type that serves as the basis
    for objects in Go. Any data type in Go can be used as an object. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 否 | Go 中没有作为对象基础的服务于类类型的概念。Go 中的任何数据类型都可以用作对象。|'
- en: As the previous table suggests, Go supports the majority of concepts that are
    usually attributed to object-oriented programming. The remainder of this chapter
    covers topics and examples showing how to use Go as an object-oriented programming
    language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，Go 支持通常归因于面向对象编程的大多数概念。本章的剩余部分将涵盖主题和示例，展示如何将 Go 作为面向对象编程语言使用。
