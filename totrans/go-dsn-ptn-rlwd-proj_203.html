<html><head></head><body>
<div class="book" title="Objects in Go">
<div class="book" title="Field and method promotion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec141" class="calibre1"/>Field and method promotion</h2></div></div></div><p class="calibre10">Now that the objects have been established in the previous section, let us spend some time discussing the visibility of fields, methods, and embedded types inside the structs. The following source snippet shows a continuation of the previous example. It declares and initializes a variable <code class="email">t</code> of type <code class="email">truck</code> and <code class="email">p</code> for <code class="email">plane</code>. The former is initialized using a struct literal and the latter is updated using dot notation:</p><pre class="programlisting">func main() { 
   t := &amp;truck { 
         vehicle:vehicle{"Ford", "F750"}, 
         engine:engine{GASOLINE+BIO,700}, 
         axels:2, 
         wheels:6, 
         class:3,     
   } 
   t.start() 
   t.drive() 
 
   p := &amp;plane{} 
   p.make = "HondaJet" 
   p.model = "HA-420" 
   p.fuel = JET 
   p.thrust = 2050 
   p.engineCount = 2 
   p.fixedWings = true 
   p.maxAltitude = 43000 
   p.start() 
   p.fly() 
 
} 
</pre><p class="calibre10">golang.fyi/ch08/structobj.go</p><p class="calibre10">One of the more interesting details in the previous snippet is how the <code class="email">struct</code> type embedding mechanism promotes fields and methods when accessed using dot notation. For instance, the following fields (<code class="email">make</code>, <code class="email">mode</code>, <code class="email">fuel</code>, and <code class="email">thrust</code>), are all declared in types that are embedded inside of the <code class="email">plane</code> type:</p><pre class="programlisting">p.make = "HondaJet" 
p.model = "HA-420" 
p.fuel = JET 
p.thrust = 2050 
</pre><p class="calibre10">The previous fields are promoted from their embedded types. They are accessed as if they are members of the <code class="email">plane </code>type when, in fact, they are coming from the types <code class="email">vehicle</code> and <code class="email">engine</code> respectively. To avoid ambiguity, the name of the fields can be qualified as shown here:</p><pre class="programlisting">p.vehicle.make = "HondaJet" 
p.vehicle.model = "HA-420" 
p.engine.fuel = JET 
p.engine.thrust = 2050 
</pre><p class="calibre10">Methods can also be promoted in a similar way. For instance, in the previous code we saw the methods <code class="email">t.start()</code> and <code class="email">p.start()</code> being invoked. However, neither type, <code class="email">truck</code> nor <code class="email">plane</code>, are receivers of a method named <code class="email">start()</code>. As shown in the program from earlier, the <code class="email">start()</code>method is defined for the <code class="email">engine</code> type. Since the <code class="email">engine</code> type is embedded in the types <code class="email">truck</code> and <code class="email">plane</code>, the <code class="email">start()</code>method is promoted in scope to these enclosing types and is therefore Â accessible.</p></div></div></body></html>