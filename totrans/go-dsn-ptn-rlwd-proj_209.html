<html><head></head><body>
<div class="book" title="The interface type">
<div class="book" title="Interface embedding"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec146" class="calibre1"/>Interface embedding</h2></div></div></div><p class="calibre10">Another interesting aspects of the <code class="email">interface</code> type is its support for type embedding (similar to the <code class="email">struct</code> type). This gives you the flexibility to structure your types in ways that maximize type reuse. Continuing with the shape example, the following code snippet reorganizes and reduces the previous interface count from three to two by embedding shape into the other two types:</p><pre class="programlisting">type shape interface { 
   area() float64 
} 
 
type polygon interface { 
   shape 
   perim() 
} 
 
type curved interface { 
   shape 
   circonf() 
} 
</pre><p class="calibre10">golang.fyi/ch08/interface_impl3.go</p><p class="calibre10">The following illustration shows how the interface types may be combined so the <span class="strong"><em class="calibre11">is-a</em></span>Â relationship still satisfies the relationships between code components:</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Interface embedding" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">When embedding interface types, the enclosing type will inherit the method set of the embedded types. The compiler will complain if the embedded type causes method signatures to clash. Embedding becomes a crucial feature, especially when the code applies type validation using type checking. It allows a type to roll up type information, thus reducing unnecessary assertion steps (type assertion is discussed later).</p></div></div></body></html>