- en: Interface embedding
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口嵌入
- en: 'Another interesting aspects of the `interface` type is its support for type
    embedding (similar to the `struct` type). This gives you the flexibility to structure
    your types in ways that maximize type reuse. Continuing with the shape example,
    the following code snippet reorganizes and reduces the previous interface count
    from three to two by embedding shape into the other two types:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`类型的另一个有趣方面是其对类型嵌入的支持（类似于`struct`类型）。这为您提供了以最大化类型重用的方式结构化类型的能力。继续使用形状示例，以下代码片段通过将形状嵌入到其他两个类型中，重新组织并减少了之前的接口数量，从三个减少到两个：'
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch08/interface_impl3.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/interface_impl3.go
- en: 'The following illustration shows how the interface types may be combined so
    the *is-a* relationship still satisfies the relationships between code components:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了接口类型如何组合，以便“是...的”关系仍然满足代码组件之间的关系：
- en: '![Interface embedding](img/00022.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![接口嵌入](img/00022.jpeg)'
- en: When embedding interface types, the enclosing type will inherit the method set
    of the embedded types. The compiler will complain if the embedded type causes
    method signatures to clash. Embedding becomes a crucial feature, especially when
    the code applies type validation using type checking. It allows a type to roll
    up type information, thus reducing unnecessary assertion steps (type assertion
    is discussed later).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌入接口类型时，封装类型将继承嵌入类型的函数集。如果嵌入类型导致方法签名冲突，编译器将报错。嵌入成为一个关键特性，尤其是在代码使用类型检查进行类型验证时。它允许类型汇总类型信息，从而减少不必要的断言步骤（类型断言将在后面讨论）。
