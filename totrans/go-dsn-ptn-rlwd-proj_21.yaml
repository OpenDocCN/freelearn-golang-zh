- en: Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last chapter about Behavioral patterns and it also closes this book's
    section about common, well known design patterns in Go language.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at three more design patterns. Visitor
    pattern is very useful when you want to abstract away some functionality from
    a set of objects.
  prefs: []
  type: TYPE_NORMAL
- en: State is used commonly to build **Finite State Machines** (**FSM**) and, in
    this section, we will develop a small *guess the number* game.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Observer pattern is commonly used in event-driven architectures
    and is gaining a lot of traction again, especially in the microservices world.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, we'll need to feel very comfortable with common design patterns
    before digging in concurrency and the advantages (and complexity), it brings to
    design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next design pattern, we are going to delegate some logic of an object's
    type to an external type called the visitor that will visit our object to perform
    operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Visitor design pattern, we are trying to separate the logic needed to
    work with a specific object outside of the object itself. So we could have many
    different visitors that do some things to specific types.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that we have a log writer that writes to console. We could
    make the logger "visitable" so that you can prepend any text to each log. We could
    write a Visitor pattern that prepends the date, the time, and the hostname to
    a field stored in the object.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Behavioral design patterns we are mainly dealing with algorithms. Visitor
    patterns are not an exception. The objectives that we are trying to achieve are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To separate the algorithm of some type from its implementation within some other
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To improve the flexibility of some types by using them with little or no logic
    at all so all new functionality can be added without altering the object structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fix a structure or behavior that would break the open/closed principle in
    a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be thinking what the open/closed principle is. In computer science,
    the open/closed principle states that: *entities should be open for * *extension
    but closed for modification*. This simple state has lots of implications that
    allows building more maintainable software and less prone to errors. And the Visitor
    pattern helps us to delegate some commonly changing algorithm from a type that
    we need it to be "stable" to an external type that can change often without affecting
    our original one.
  prefs: []
  type: TYPE_NORMAL
- en: A log appender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to develop a simple log appender as an example of the Visitor pattern.
    Following the approach we have had in previous chapters, we will start with an
    extremely simple example to clearly understand how the Visitor design pattern
    works before jumping to a more complex one. We have already developed similar
    examples modifying texts too, but in slightly different ways.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular example, we will create a Visitor that appends different
    information to the types it "visits".
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To effectively use the Visitor design pattern, we must have two roles--a visitor
    and a visitable. The `Visitor` is the type that will act within a `Visitable`
    type. So a `Visitable` interface implementation has an algorithm detached to the `Visitor`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need two message loggers: `MessageA` and `MessageB` that will print a message
    with an `A:` or a `B:` respectively before the message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a Visitor able to modify the message to be printed. It will append the
    text "Visited A" or "Visited B" to them, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned before, we will need a role for the `Visitor` and the `Visitable`
    interfaces. They will be interfaces. We also need the `MessageA` and `MessageB`
    structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The types `MessageA` and `MessageB` structs both have an `Msg` field to store
    the text that they will print. The output `io.Writer` will implement the `os.Stdout`
    interface by default or a new `io.Writer` interface, like the one we will use
    to check that the contents are correct.
  prefs: []
  type: TYPE_NORMAL
- en: The `Visitor` interface has a `Visit` method, one for each of `Visitable` interface's
    `MessageA` and `MessageB` type. The `Visitable` interface has a method called `Accept(Visitor)`
    that will execute the decoupled algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like in previous examples, we will create a type that implements the `io.Writer`
    package so that we can use it in tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `TestHelper` struct implements the `io.Writer` interface. Its functionality
    is quite simple; it stores the written bytes on the `Received` field. Later we
    can check the contents of `Received` to test against our expected value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write just one test that will check the overall correctness of the
    code. Within this test, we will write two sub tests: one for `MessageA` and one
    for `MessageB` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a `TestHelper` struct and a `MessageVisitor` struct on each test
    for each message type. First, we will test the `MessageA` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the full first test. We created `MessageA` struct, giving it a value
    `Hello World` for the `Msg` field and the pointer to `TestHelper`, which we created
    at the beginning of the test. Then, we execute its `Accept` method. Inside the
    `Accept(Visitor)` method on the `MessageA` struct, the `VisitA(*MessageA)` method
    is executed to alter the contents of the `Msg` field (that's why we passed the
    pointer to `VisitA` method, without a pointer the contents won't be persisted).
  prefs: []
  type: TYPE_NORMAL
- en: To test if the `Visitor` type has done its job within the `Accept` method, we
    must call the `Print()` method on the `MessageA` type later. This way, the `MessageA` struct
    must write the contents of `Msg` to the provided `io.Writer` interface (our `TestHelper`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the test is the check. According to the description of *acceptance
    criteria 2*, the output text of `MessageA` type must be prefixed with the text `A:`,
    the stored message and the text `"(Visited)"` just at the end. So, for the `MessageA`
    type, the expected text must be `"A: Hello World (Visited)"`, this is the check
    that we did in the `if` section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageB` type has a very similar implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we have just changed the type from `MessageA` to `MessageB` and the
    expected text now is `"B: Hello World (Visited B)"`. The `Msg` field is also `"Hello
    World"` and we also used the `TestHelper` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We still lack the correct implementations of the interfaces to compile the
    code and run the tests. The `MessageA` and `MessageB` structs have to implement
    the `Accept(Visitor)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We need the implementations of the `VisitA(*MessageA)` and `VisitB(*MessageB)`
    methods that are declared on the `Visitor` interface. The `MessageVisitor` interface
    is the type that must implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will create a `Print()` method for each message type. This is the
    method that we will use to test the contents of the `Msg` field on each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the tests to really check if they are failing yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The outputs of the tests are clear. The expected messages were incorrect because
    the contents were empty. It's time to create the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of Visitor pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start completing the implementation of the `VisitA(*MessageA)` and
    `VisitB(*MessageB)` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Its functionality is quite straightforward--the `fmt.Sprintf` method returns
    a formatted string with the actual contents of `m.Msg`, a white space, and the
    message, `Visited`. This string will be stored on the `Msg` field, overriding
    the previous contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will develop the `Accept` method for each message type that must execute
    the corresponding Visitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This small code has some implications on it. In both cases, we are using a
    `Visitor`, which in our example is exactly the same as the `MessageVisitor` interface,
    but they could be completely different. The key is to understand that the Visitor
    pattern executes an algorithm in its `Visit` method that deals with the `Visitable`
    object. What could the `Visitor` be doing? In this example, it alters the `Visitable`
    object, but it could be simply fetching information from it. For example, we could
    have a `Person` type with lots of fields: name, surname, age, address, city, postal
    code, and so on. We could write a Visitor to fetch just the name and surname from
    a person as a unique string, a visitor to fetch the address info for a different
    section of an app, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is the `Print()` method, which will help us to test the types.
    We mentioned before that it must print to the `Stdout` call by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It first checks the content of the `Output` field to assign the output of the `os.Stdout` call
    in case it is null. In our tests, we are storing a pointer there to our `TestHelper`
    type so this line is never executed in our test. Finally, each message type prints
    to the `Output` field, the full message stored in the `Msg` field. This is done
    by using the `Fprintf` method, which takes an `io.Writer` package as the first
    argument and the text to format as the next arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation is now complete and we can run the tests again to see if
    they all pass now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is OK! The Visitor pattern has done its job flawlessly and the message
    contents were altered after calling their `Visit` methods. The very important
    thing here is that we can add more functionality to both the structs, `MessageA`
    and `MessageB`, without altering their types. We can just create a new Visitor
    type that does everything on the `Visitable`, for example, we can create a `Visitor`
    to add a method that prints the contents of the `Msg` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have just added some functionality to both types without altering their contents!
    That's the power of the Visitor design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Another example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop a second example, this one a bit more complex. In this case,
    we will emulate an online shop with a few products. The products will have plain
    types, with just fields and we will make a couple of visitors to deal with them
    in the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will develop the interfaces. The `ProductInfoRetriever` type
    has a method to get the price and the name of the product. The `Visitor` interface,
    like before, has a `Visit` method that accepts the `ProductInfoRetriever` type.
    Finally, `Visitable` interface is exactly the same; it has an `Accept` method
    that takes a `Visitor` type as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All the products of the online shop must implement the `ProductInfoRetriever`
    type. Also, most products will have some commons fields, such as name or price
    (the ones defined in the `ProductInfoRetriever` interface). We created the `Product`
    type, implemented the `ProductInfoRetriever` and the `Visitable` interfaces, and
    embedded it on each product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a very generic `Product` type that can store the information about
    almost any product of the shop. For example, we could have a `Rice` and a `Pasta`
    product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Each has the `Product` type embedded. Now we need to create a couple of `Visitors`
    interfaces, one that sums the price of all products and one that prints the name
    of each product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `PriceVisitor` struct takes the value of the `Price` variable of the `ProductInfoRetriever`
    type, passed as an argument, and adds it to the `Sum` field. The `NamePrinter`
    struct stores the name of the `ProductInfoRetriever` type, passed as an argument,
    and appends it to a new line on the `ProductList` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a slice of two `Visitable` objects: a `Rice` and a `Pasta` type with
    some arbitrary names. Then we iterate for each of them using a `PriceVisitor`
    instance as an argument. We print the total price after the range for. Finally,
    we repeat this operation with the `NamePrinter` and print the resulting `ProductList`.
    The output of this `main` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, this is a nice example of the Visitor pattern but... what if there are
    special considerations about a product? For example, what if we need to sum 20
    to the total price of a fridge type? OK, let''s write the `Fridge` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea here is to just override the `GetPrice()` method to return the product''s
    price plus 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this isn''t enough for our example. The `Fridge` structure is
    not of a  `Visitable` type. The `Product` struct is of a `Visitable` type and
    the `Fridge` struct has a `Product` struct embedded but, as we mentioned in earlier
    chapters, a type that embeds a second type cannot be considered of that latter
    type, even when it has all its fields and methods. The solution is to also implement
    the `Accept(Visitor)` method so that it can be considered as a `Visitable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite the `main` function  to add this new `Fridge` product to the
    slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything else continues the same. Running this new `main` function produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the total price is higher now, outputting the sum of the rice (32),
    the pasta (40), and the fridge (50 of the product plus 20 of the transport, so
    70). We could be adding visitors forever to this products, but the idea is clear--we
    decoupled some algorithms outside of the types to the visitors.
  prefs: []
  type: TYPE_NORMAL
- en: Visitors to the rescue!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen a powerful abstraction to add new algorithms to some types. However,
    because of the lack of overloading in Go, this pattern could be limiting in some
    aspects (we have seen it in the first example, where we had to create the `VisitA`
    and `VisitB` implementations). In the second example, we haven't dealt with this
    limitation because we have used an interface to the `Visit` method of the `Visitor` struct,
    but we just used one type of visitor (`ProductInfoRetriever`) and we would have
    the same problem if we implemented a `Visit` method for a second type, which is
    one of the objectives of the original *Gang of Four* design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: State design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State patterns are directly related to FSMs. An FSM, in very simple terms, is
    something that has one or more states and travels between them to execute some
    behaviors. Let's see how the State pattern helps us to define FSM.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A light switch is a common example of an FSM. It has two states--on and off.
    One state can transit to the other and vice versa. The way that the State pattern
    works is similar. We have a `State` interface and an implementation of each state
    we want to achieve. There is also usually a context that holds cross-information
    between the states.
  prefs: []
  type: TYPE_NORMAL
- en: With FSM, we can achieve very complex behaviors by splitting their scope between
    states. This way we can model pipelines of execution based on any kind of inputs
    or create event-driven software that responds to particular events in specified
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main objectives of the State pattern is to develop FSM are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To have a type that alters its own behavior when some internal things have changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model complex graphs and pipelines can be upgraded easily by adding more states
    and rerouting their output states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small guess the number game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to develop a very simple game that uses FSM. This game is a number
    guessing game. The idea is simple--we will have to guess some number between 0
    and 10 and we have just a few attempts or we'll lose.
  prefs: []
  type: TYPE_NORMAL
- en: We will leave the player to choose the level of difficulty by asking how many
    tries the user has before losing. Then, we will ask the player for the correct
    number and keep asking if they don't guess it or if the number of tries reaches
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this simple game, we have five acceptance criteria that basically describe
    the mechanics of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: The game will ask the player how many tries they will have before losing the
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number to guess must be between 0 and 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time a player enters a number to guess, the number of retries drops by
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number of retries reaches zero and the number is still incorrect, the
    game finishes and the player has lost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player guesses the number, the player wins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementation of State pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of unit tests is quite straightforward in a State pattern so we will
    spend more time explaining in detail the mechanism to use it, which is a bit more
    complex than usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need the interface to represent the different states and a
    game context to store the information between states. For this game, the context
    needs to store the number of retries, if the user has won or not, the secret number
    to guess, and the current state. The state will have an `executeState` method
    that accepts one of these contexts and returns `true` if the game has finished,
    or `false` if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As described in *acceptance criteria 1*, the player must be able to introduce
    the number of retries they want. This will be achieved by a state called `StartState`.
    Also, the `StartState` struct must prepare the game, setting the context to its
    initial value before the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First of all, the `StartState` struct implements the `GameState` structure because
    it has the `executeState(*Context)` method of Boolean type on its structure. At
    the beginning of this state, it sets the only state possible after executing this
    one--the `AskState` state. The `AskState` struct is not declared yet, but it will
    be the state where we ask the player for a number to guess.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two lines, we use the `Rand` package of Go to generate a random
    number. In the first line, we feed the random generator with the `int64` type
    number returned by the current moment, so we ensure a random feed in each execution
    (if you put a constant number here, the randomizer will also generate the same
    number too). The `rand.Intn(int)` method returns an integer number between zero
    and the specified number, so here we cover *acceptance criteria 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a message asking for a number of retries to set precedes the `fmt.Fscanf`
    method, a powerful function where you can pass it an `io.Reader` (the standard
    input of the console), a format (number), and an interface to store the contents
    of the reader, in this case, the `Retries` field of the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we return `true` to tell the engine that the game must continue. Let''s
    see the `AskState` struct, which we have used at the beginning of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `AskState` structure also implements the `GameState` state, as you have
    probably guessed already. This states starts with a message for the player, asking
    them to insert a new number. In the next three lines, we create a local variable
    to store the contents of the number that the player will introduce. We used the
    `fmt.Fscanf` method again, as we did in `StartState` struct to capture the player's
    input and store it in the variable `n`. Then, we have one retry less in our counter,
    so we have to subtract one to the number of retries represented in the `Retries`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there are two checks: one that checks if the user has entered the correct
    number, in which case the context field `Won` is set to `true` and the next state
    is set to the `FinishState` struct (not declared yet).'
  prefs: []
  type: TYPE_NORMAL
- en: The second check is controlling that the number of retries has not reached zero,
    in which case it won't let the player ask again for a number and it will send
    the player to the `FinishState` struct directly. After all, we have to tell the
    game engine again that the game must continue by returning `true` in the `executeState`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the `FinishState` struct. It controls the exit status of
    the game, checking the contents of the `Won` field in the context object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `TheFinishState` struct also implements the `GameState` state by having
    `executeState` method in its structure. The idea here is very simple--if the player
    has won (this field is set previously in the `AskState` struct), the `FinishState`
    structure will print the message `Congrats, you won`. If the player has not won
    (remember that the zero value of the Boolean variable is `false`), the `FinishState`
    prints the message `You lose.`
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the game can be considered finished, so we return `false` to say
    that the game must not continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need the `main` method to play our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Well, yes, it can't be simpler. The game must begin with the `start` method,
    although it could be abstracted more outside in case that the game needs more
    initialization in the future, but in our case it is fine. Then, we create a context
    where we set the `Next` state as a pointer to the `start` variable. So the first
    state that will be executed in the game will be the `StartState` state.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the `main` function has a lot of things just there. We create
    a loop, without any statement inside it. As with any loop, it keeps looping after
    the condition is not satisfied. The condition we are using is the returned value
    of the `GameStates` structure, `true` as soon as the game is not finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the idea is simple: we execute the state in the context, passing a pointer
    to the context to it. Each state returns `true` until the game has finished and
    the `FinishState` struct will return `false`. So our for loop will keep looping,
    waiting for a `false` condition sent by the `FinishState` structure to end the
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s play once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We lost! We set the number of retries to 5\. Then we kept inserting numbers,
    trying to guess the secret number. We entered 8, 2, 1, 3, and 4, but it wasn't
    any of them. I don't even know what the correct number was; let's fix this!
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the definition of the `FinishState` struct and change the line where
    it says `You lose`, and replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it will show the correct number. Let''s play again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we make it a little harder by setting only three tries... and we
    lost again. I entered 6, 2, and 1, but the correct number was 9\. Last try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Great! This time we lowered the difficulty, allowing up to five tries and we
    won! we even had one more try left, but we guessed the number in the fourth try
    after entering 3, 4, 5\. The correct number was 6, which was my fourth try.
  prefs: []
  type: TYPE_NORMAL
- en: A state to win and a state to lose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have you realized that we could have a winning and a lose state instead of
    printing the messages directly in the `FinishState` struct? This way we could,
    for example, check some hypothetical scoreboard in the win section to see if we
    have set a record. Let''s refactor our game. First we need a `WinState` and a
    `LoseState` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'These two new states have nothing new. They contain the same messages that
    were previously in the `FinishState` state that, by the way, must be modified
    to use these new states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, the finish state doesn't print anything and, instead, delegates this to
    the next state in the chain--the `WinState` structure, if the user has won and
    the `LoseState` struct, if not. Remember that the game doesn't finish on the `FinishState`
    struct now, and we must return `true` instead of `false` to notify to the engine
    that it must keep executing states in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: The game built using the State pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must be thinking now that you can extend this game forever with new states,
    and it's true. The power of the State pattern is not only the capacity to create
    a complex FSM, but also the flexibility to improve it as much as you want by adding
    new states and modifying some old states to point to the new ones without affecting
    the rest of the FSM.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with the Mediator pattern. As its name implies, it's a pattern
    that will be in between two types to exchange information. But, why will we want
    this behavior at all? Let's look at this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key objectives of any design pattern is to avoid tight coupling between
    objects. This can be done in many ways, as we have seen already.
  prefs: []
  type: TYPE_NORMAL
- en: But one particularly effective method when the application grows a lot is the
    Mediator pattern. The Mediator pattern is the perfect example of a pattern that
    is commonly used by every programmer without thinking very much about it.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator pattern will act as the type in charge of exchanging communication
    between two objects. This way, the communicating objects don't need to know each
    other and can change more freely. The pattern that maintains which objects give
    what information is the Mediator.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously described, the main objectives of the Mediator pattern are about
    loose coupling and encapsulation. The objectives are:'
  prefs: []
  type: TYPE_NORMAL
- en: To provide loose coupling between two objects that must communicate between
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reduce the amount of dependencies of a particular type to the minimum by
    passing these needs to the Mediator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the Mediator pattern, we are going to develop an extremely simple arithmetic
    calculator. You're probably thinking that a calculator is so simple that it does
    not need any pattern. But we will see that this is not exactly true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our calculator will only do two very simple operations: sum and subtract.'
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It sounds quite funny to talk about acceptance criteria to define a calculator,
    but let''s do it anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an operation called `Sum` that takes a number and adds it to another
    number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an operation called `Subtract` that takes a number and substracts it
    to another number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well, I don't know about you, but I really need a rest after this *complex*
    criteria. So why are we defining this so much? Patience, you will have the answer
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to jump directly to the implementation because we cannot test that the
    sum will be correct (well, we can, but we will be testing if Go is correctly written!).
    We could test that we pass the acceptance criteria, but it's a bit of an overkill
    for our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start by implementing the necessary types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Well... this look quite awkward. We already have numeric types in Go to perform
    these operations, we don't need a type for each number!
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s continue for a second with this insane approach. Let''s implement
    the `One` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: OK , I'll stop here. What is wrong with this implementation? This is completely
    crazy! It's overkill to make every operation possible between numbers to make
    sums! Especially when we have more than one digit.
  prefs: []
  type: TYPE_NORMAL
- en: Well, believe it or not, this is how a lot of software is commonly designed
    today. A small app where an object uses two or three objects grows, and it ends
    up using dozens of them. It becomes an absolute hell to simply add or remove a
    type from the application because it is hidden in some of this craziness.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what can we do in this calculator? Use a Mediator type that frees all the
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have just developed a couple of numbers to keep things short. The `Sum` function
    acts as a mediator between two numbers. First it checks the type of the first
    number named `a`. Then, for each type of the first number, it checks the type
    of the second number named `b` and returns the resulting type.
  prefs: []
  type: TYPE_NORMAL
- en: While the solution still looks very crazy now, the only one that knows about
    all possible numbers in the calculator is the `Sum` function. But take a closer
    look and you'll see that we have added a type case for the `int` type. We have
    cases `One`, `Two` , and `int`. Inside the `int` case, we also have another `int` case
    for the `b` number. What do we do here? If both types are of the `int` case, we
    can return the sum of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you think that this will work? Let''s write a simple `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We print the sum of type `One` and type `Two`. By using the `"%#v"` format,
    we ask to print information about the type. The second line in the function uses
    `int` types, and we also print the result. This in the console produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Not very impressive, right? But let's think for a second. By using the Mediator
    pattern, we have been able to refactor the initial calculator, where we have to
    define every operation on every type to a Mediator pattern, the `Sum` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing is that, thanks to the Mediator pattern, we have been able to
    start using integers as values for our calculator. We have just defined the simplest
    example by adding two integers, but we could have done the same with an integer
    and the `type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With this small modification, we can now use type `One` with an `int` as number
    `b`. If we keep working on this Mediator pattern, we could achieve a lot of flexibility
    between types, without having to implement every possible operation between them,
    generating a tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a new `Sum` method in the main function to see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Nice. The Mediator pattern is in charge of knowing about the possible types
    and returns the most convenient type for our case, which is an integer. Now we
    could keep growing this `Sum` function until we completely get rid of using the
    numeric types we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: Uncoupling two types with the Mediator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have carried out a disruptive example to try to think outside the box and
    reason deeply about the Mediator pattern. Tight coupling between entities in an
    app can become really complex to deal with in the future and allow more difficult
    refactoring if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that the Mediator pattern is there to act as a managing type between
    two types that don't know about each other so that you can take one of the types
    without affecting the other and replace a type in a more easy and convenient way.
  prefs: []
  type: TYPE_NORMAL
- en: Observer design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will finish the common *Gang of Four* design patterns with my favorite:
    the Observer pattern, also known as publish/subscriber or publish/listener. With
    the State pattern, we defined our first event-driven architecture, but with the
    Observer pattern we will really reach a new level of abstraction.'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind the Observer pattern is simple--to subscribe to some event that
    will trigger some behavior on many subscribed types. Why is this so interesting?
    Because we uncouple an event from its possible handlers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a login button. We could code that when the user clicks
    the button, the button color changes, an action is executed, and a form check
    is performed in the background. But with the Observer pattern, the type that changes
    the color will subscribe to the event of the clicking of the button. The type
    that checks the form and the type that performs an action will subscribe to this
    event too.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Observer pattern is especially useful to achieve many actions that are
    triggered on one event. It is also especially useful when you don''t know how
    many actions are performed after an event in advance or there is a possibility
    that the number of actions is going to grow in the near future. To resume, do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide an event-driven architecture where one event can trigger one or more
    actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncouple the actions that are performed from the event that triggers them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide more than one event that triggers the same action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop the simplest possible application to fully understand the roots
    of the Observer pattern. We are going to make a `Publisher` struct, which is the
    one that triggers an event so it must accept new observers and remove them if
    necessary. When the `Publisher` struct is triggered, it must notify all its observers
    of the new event with the data associated.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The requirements must tell us to have some type that triggers some method in
    one or more actions:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have a publisher with a `NotifyObservers` method that accepts a message
    as an argument and triggers a `Notify` method on every observer subscribed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must have a method to add new subscribers to the publisher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must have a method to remove new subscribers from the publisher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maybe you have realized that our requirements defined almost exclusively the
    `Publisher` type. This is because the action performed by the observer is irrelevant
    for the Observer pattern. It should simply execute an action, in this case the
    `Notify` method, that one or many types will implement. So let''s define this
    only interface for this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `Observer` interface has a `Notify` method that accepts a `string` type
    that will contain the message to spread. It does not need to return anything,
    but we could return an error if we want to check if all observers have been reached
    when calling the `publish` method of the `Publisher` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test all the acceptance criteria, we just need a structure called `Publisher`
    with three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `Publisher` structure stores the list of subscribed observers in a slice
    field called `ObserversList`. Then it has the three methods mentioned on the acceptance
    criteria-the `AddObserver` method to subscribe a new observer to the publisher,
    the `RemoveObserver` method to unsubscribe an observer, and the `NotifyObservers`
    method with a string that acts as the message we want to spread between all observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these three methods, we have to set up a root test to configure the `Publisher`
    and three subtests to test each method. We also need to define a test type structure
    that implements the `Observer` interface. This structure is going to be called
    `TestObserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `TestObserver` structure implements the Observer pattern by defining a `Notify(string)`
    method in its structure. In this case, it prints the received message together
    with its own observer ID. Then, it stores the message in its `Message` field.
    This allows us to check later if the content of the `Message` field is as expected.
    Remember that it could also be done by passing the `testing.T` pointer and the
    expected message and checking within the `TestObserver` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can set up the `Publisher` structure to execute the three tests. We
    will create three instances of the `TestObserver` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We have given a different ID to each observer so that we can see later that
    each of them has printed the expected message. Then, we have added the observers
    by calling the `AddObserver` method on the `Publisher` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write an `AddObserver` test, it must add a new observer to the `ObserversList`
    field of the `Publisher` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We have added three observers to the `Publisher` structure, so the length of
    the slice must be 3\. If it's not 3, the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RemoveObserver` test will take the observer with ID 2 and remove it from
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After removing the second observer, the length of the `Publisher` structure
    must be 2 now. We also check that none of the observers left have the `ID` 2 because
    it must be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method to test is the `Notify` method. When using the `Notify` method,
    all instances of `TestObserver` structure must change their `Message` field from
    empty to the passed message (`Hello World!` in this case). First we will check
    that all the `Message` fields are, in fact, empty before calling the `NotifyObservers`
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Using a `for` statement, we are iterating over the `ObserversList` field to
    slice in the `publisher` instance. We need to make a type casting from a pointer
    to an observer, to a pointer to the `TestObserver` structure, and check that the
    casting has been done correctly. Then, we check that the `Message` field is actually
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a message to send--in this case, it will be `"Hello
    World!"` and then pass this message to the `NotifyObservers` method to notify
    every observer on the list (currently observers 1 and 3 only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After calling the `NotifyObservers` method, each `TestObserver` tests in the
    `ObserversList` field must have the message `"Hello World!"` stored in their `Message`
    field. Again, we use a `for` loop to iterate over every observer of the `ObserversList`
    field and we typecast each to a `TestObserver` test (remember that `TestObserver`
    structure doesn't have any field as it's an interface). We could avoid type casting
    by adding a new `Message()` method to `Observer` instance and implementing it
    in the `TestObserver` structure to return the contents of the `Message` field.
    Both methods are equally valid. Once we have type casted to a `TestObserver` method
    called `printObserver` variable as a local variable, we check that each instance
    in the `ObserversList` structure has the string `"Hello World!"` stored in their
    `Message` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to run the tests that must fail all to check their effectiveness in the
    later implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Something isn't working as expected. How is the `Notify` method passing the
    tests if we haven't implemented the function yet? Take a look at the test of the
    `Notify` method again. The test iterates over the `ObserversList` structure and
    each `F` `ail` call is inside this for loop. If the list is empty, it won't iterate,
    so it won't execute any `Fail call`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this issue by adding a small non-empty list check at the beginning
    of the `Notify` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will rerun the tests to see if the `TestSubject/Notify` method is already
    failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Nice, all of them are failing and now we have some guarantee on our tests. We
    can proceed to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our implementation is just to define the `AddObserver`, the `RemoveObserver`,
    and the `NotifyObservers` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddObserver` method adds the `Observer` instance to the `ObserversList`
    structure by appending the pointer to the current list of pointers. This one was
    very easy. The `AddObserver` test must be passing now (but not the rest or we
    could have done something wrong):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent. Just the `AddObserver` method has passed the test, so we can now
    continue to the `RemoveObserver` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoveObserver` method will iterate for each element in the `ObserversList`
    structure, comparing the `Observer` object''s `o` variable with the ones stored
    in the list. If it finds a match, it saves the index  in the local variable, `indexToRemove`,
    and stops the iteration. The way to remove indexes on a slice in Go is a bit tricky:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to use slice indexing to return a new slice containing every
    object from the beginning of the slice to the index we want to remove (not included).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we get another slice from the index we want to remove (not included) to
    the last object in the slice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we join the previous two new slices into a new one (the `append` function)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, in a list from 1 to 10 in which we want to remove the number 5,
    we have to create a new slice, joining a slice from 1 to 4 and a slice from 6
    to 10.
  prefs: []
  type: TYPE_NORMAL
- en: This index removal is done with the `append` function again because we are actually
    appending two lists together. Just take a closer look at the three dots at the
    end of the second argument of the `append` function. The `append` function adds
    an element (the second argument) to a slice (the first), but we want to append
    an entire list. This can be achieved using the three dots, which translate to
    something like *keep adding elements until you finish the second array*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, let''s run this test now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue in the good path. The `RemoveObserver` test has been fixed without
    fixing anything else. Now we have to finish our implementation by defining the
    `NotifyObservers` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NotifyObservers` method is quite simple because it prints a message to
    the console to announce that a particular message is going to be passed to the
    `Observers`. After this, we use a for loop to iterate over `ObserversList` structure
    and execute each `Notify(string)` method by passing the argument `m`. After executing
    this, all observers must have the message `Hello World!` stored in their `Message`
    field. Let''s see if this is true by running the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We can also see the outputs of the `Publisher` and `Observer` types
    on the console. The `Publisher` structure prints the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, all observers print their respective messages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And the same for the third observer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have unlocked the power of event-driven architectures with the State pattern
    and the Observer pattern. Now you can really execute asynchronous algorithms and
    operations in your application that respond to events in your system.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern is commonly used in UI's. Android programming is filled
    with Observer patterns so that the Android SDK can delegate the actions to be
    performed by the programmers creating an app.
  prefs: []
  type: TYPE_NORMAL
