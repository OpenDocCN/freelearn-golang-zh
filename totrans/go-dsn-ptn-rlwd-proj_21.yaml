- en: Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。行为模式 - 访问者、状态、中介者和观察者设计模式
- en: This is the last chapter about Behavioral patterns and it also closes this book's
    section about common, well known design patterns in Go language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于行为模式的最后一章，同时也结束了这本书关于Go语言中常见、知名设计模式的部分。
- en: In this chapter, we are going to look at three more design patterns. Visitor
    pattern is very useful when you want to abstract away some functionality from
    a set of objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨三个更多设计模式。访问者模式在你想从一组对象中抽象出某些功能时非常有用。
- en: State is used commonly to build **Finite State Machines** (**FSM**) and, in
    this section, we will develop a small *guess the number* game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通常用于构建**有限状态机**（**FSM**），在本节中，我们将开发一个小型的*猜数字*游戏。
- en: Finally, the Observer pattern is commonly used in event-driven architectures
    and is gaining a lot of traction again, especially in the microservices world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，观察者模式在事件驱动架构中很常见，并且在微服务世界中再次获得了大量关注。
- en: After this chapter, we'll need to feel very comfortable with common design patterns
    before digging in concurrency and the advantages (and complexity), it brings to
    design patterns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，我们需要在深入并发及其在设计模式中的优势（以及复杂性）之前，对常见设计模式感到非常熟悉。
- en: Visitor design pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者设计模式
- en: In the next design pattern, we are going to delegate some logic of an object's
    type to an external type called the visitor that will visit our object to perform
    operations on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个设计模式中，我们将将对象类型的某些逻辑委托给一个外部类型，称为访问者，它将访问我们的对象以执行操作。
- en: Description
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: In the Visitor design pattern, we are trying to separate the logic needed to
    work with a specific object outside of the object itself. So we could have many
    different visitors that do some things to specific types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问者设计模式中，我们试图将处理特定对象所需的逻辑与对象本身分离。因此，我们可以有许多不同的访问者对特定类型执行某些操作。
- en: For example, imagine that we have a log writer that writes to console. We could
    make the logger "visitable" so that you can prepend any text to each log. We could
    write a Visitor pattern that prepends the date, the time, and the hostname to
    a field stored in the object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个写入控制台的日志记录器。我们可以使记录器“可访问”，这样你就可以在每个日志前添加任何文本。我们可以编写一个访问者模式，将日期、时间和主机名添加到对象中存储的字段。
- en: Objectives
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'With Behavioral design patterns we are mainly dealing with algorithms. Visitor
    patterns are not an exception. The objectives that we are trying to achieve are
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为设计模式中，我们主要处理算法。访问者模式也不例外。我们试图实现的目标如下：
- en: To separate the algorithm of some type from its implementation within some other
    type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将某些类型的算法与其在另一个类型中的实现分离
- en: To improve the flexibility of some types by using them with little or no logic
    at all so all new functionality can be added without altering the object structure
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用几乎没有任何逻辑的某些类型来提高它们的灵活性，这样所有新的功能都可以添加，而无需更改对象结构
- en: To fix a structure or behavior that would break the open/closed principle in
    a type
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了修复一个会破坏类型开放/封闭原则的结构或行为
- en: You might be thinking what the open/closed principle is. In computer science,
    the open/closed principle states that: *entities should be open for * *extension
    but closed for modification*. This simple state has lots of implications that
    allows building more maintainable software and less prone to errors. And the Visitor
    pattern helps us to delegate some commonly changing algorithm from a type that
    we need it to be "stable" to an external type that can change often without affecting
    our original one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道开放/封闭原则是什么。在计算机科学中，开放/封闭原则指出：*实体应该对扩展开放，但对修改封闭*。这种简单的状态有很多含义，允许构建更易于维护的软件，并且更不容易出错。访问者模式帮助我们将一些经常变化的算法从需要“稳定”的类型中委托给一个可以经常更改而不影响原始类型的外部类型。
- en: A log appender
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志追加器
- en: We are going to develop a simple log appender as an example of the Visitor pattern.
    Following the approach we have had in previous chapters, we will start with an
    extremely simple example to clearly understand how the Visitor design pattern
    works before jumping to a more complex one. We have already developed similar
    examples modifying texts too, but in slightly different ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个简单的日志追加器为例，来开发一个访问者模式的示例。遵循我们在前几章中采用的方法，我们将从一个极其简单的例子开始，以便清楚地理解访问者设计模式是如何工作的，然后再转向一个更复杂的例子。我们之前也开发过类似的例子，修改文本，但方式略有不同。
- en: For this particular example, we will create a Visitor that appends different
    information to the types it "visits".
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，我们将创建一个访问者，它将向它“访问”的类型追加不同的信息。
- en: Acceptance criteria
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'To effectively use the Visitor design pattern, we must have two roles--a visitor
    and a visitable. The `Visitor` is the type that will act within a `Visitable`
    type. So a `Visitable` interface implementation has an algorithm detached to the `Visitor`
    type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用访问者设计模式，我们必须有两个角色——访问者和可访问者。`访问者`是将在`可访问者`类型内执行操作的类型。因此，`可访问者`接口实现有一个与`访问者`类型分离的算法：
- en: 'We need two message loggers: `MessageA` and `MessageB` that will print a message
    with an `A:` or a `B:` respectively before the message.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个消息记录器：`MessageA`和`MessageB`，它们将在消息前分别打印`A:`或`B:`。
- en: We need a Visitor able to modify the message to be printed. It will append the
    text "Visited A" or "Visited B" to them, respectively.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个能够修改要打印的消息的访问者。它将分别向它们追加文本“Visited A”或“Visited B”。
- en: Unit tests
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'As we mentioned before, we will need a role for the `Visitor` and the `Visitable`
    interfaces. They will be interfaces. We also need the `MessageA` and `MessageB`
    structs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们需要为`访问者`和`可访问者`接口提供一个角色。它们将是接口。我们还需要`MessageA`和`MessageB`结构体：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The types `MessageA` and `MessageB` structs both have an `Msg` field to store
    the text that they will print. The output `io.Writer` will implement the `os.Stdout`
    interface by default or a new `io.Writer` interface, like the one we will use
    to check that the contents are correct.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageA`和`MessageB`结构体类型都有一个`Msg`字段来存储它们将要打印的文本。默认情况下，输出`io.Writer`将实现`os.Stdout`接口，或者一个新的`io.Writer`接口，就像我们将用它来检查内容是否正确的那样。'
- en: The `Visitor` interface has a `Visit` method, one for each of `Visitable` interface's
    `MessageA` and `MessageB` type. The `Visitable` interface has a method called `Accept(Visitor)`
    that will execute the decoupled algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`访问者`接口有一个`Visit`方法，对应于`可访问者`接口的`MessageA`和`MessageB`类型。`可访问者`接口有一个名为`Accept(Visitor)`的方法，它将执行解耦算法。'
- en: 'Like in previous examples, we will create a type that implements the `io.Writer`
    package so that we can use it in tests:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将创建一个实现`io.Writer`包的类型，以便我们可以在测试中使用它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `TestHelper` struct implements the `io.Writer` interface. Its functionality
    is quite simple; it stores the written bytes on the `Received` field. Later we
    can check the contents of `Received` to test against our expected value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestHelper`结构体实现了`io.Writer`接口。它的功能相当简单；它将写入的字节存储在`Received`字段上。稍后我们可以检查`Received`的内容以测试我们的预期值。'
- en: 'We will write just one test that will check the overall correctness of the
    code. Within this test, we will write two sub tests: one for `MessageA` and one
    for `MessageB` types:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只编写一个测试来检查代码的整体正确性。在这个测试中，我们将编写两个子测试：一个用于`MessageA`类型，一个用于`MessageB`类型：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use a `TestHelper` struct and a `MessageVisitor` struct on each test
    for each message type. First, we will test the `MessageA` type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个消息类型的每个测试中使用一个`TestHelper`结构体和一个`MessageVisitor`结构体。首先，我们将测试`MessageA`类型：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the full first test. We created `MessageA` struct, giving it a value
    `Hello World` for the `Msg` field and the pointer to `TestHelper`, which we created
    at the beginning of the test. Then, we execute its `Accept` method. Inside the
    `Accept(Visitor)` method on the `MessageA` struct, the `VisitA(*MessageA)` method
    is executed to alter the contents of the `Msg` field (that's why we passed the
    pointer to `VisitA` method, without a pointer the contents won't be persisted).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的第一个测试。我们创建了`MessageA`结构体，给它`Msg`字段一个值`Hello World`，并提供了我们在测试开始时创建的`TestHelper`的指针。然后，我们执行它的`Accept`方法。在`MessageA`结构体上的`Accept(Visitor)`方法内部，执行了`VisitA(*MessageA)`方法来更改`Msg`字段的内容（这就是为什么我们传递了`VisitA`方法的指针，如果没有指针，内容将不会持久化）。
- en: To test if the `Visitor` type has done its job within the `Accept` method, we
    must call the `Print()` method on the `MessageA` type later. This way, the `MessageA` struct
    must write the contents of `Msg` to the provided `io.Writer` interface (our `TestHelper`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`访问者`类型是否在`Accept`方法中完成了其工作，我们必须稍后在`MessageA`类型上调用`Print()`方法。这样，`MessageA`结构体必须将`Msg`字段的内容写入提供的`io.Writer`接口（我们的`TestHelper`）。
- en: 'The last part of the test is the check. According to the description of *acceptance
    criteria 2*, the output text of `MessageA` type must be prefixed with the text `A:`,
    the stored message and the text `"(Visited)"` just at the end. So, for the `MessageA`
    type, the expected text must be `"A: Hello World (Visited)"`, this is the check
    that we did in the `if` section.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '测试的最后部分是检查。根据 *验收标准 2* 的描述，`MessageA` 类型的输出文本必须以文本 `A:` 开头，存储的消息和文本 `"(Visited)"`
    在末尾。所以，对于 `MessageA` 类型，预期的文本必须是 `"A: Hello World (Visited)"`，这就是我们在 `if` 部分所做的检查。'
- en: 'The `MessageB` type has a very similar implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageB` 类型有一个非常相似的实现：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In fact, we have just changed the type from `MessageA` to `MessageB` and the
    expected text now is `"B: Hello World (Visited B)"`. The `Msg` field is also `"Hello
    World"` and we also used the `TestHelper` type.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '事实上，我们只是将类型从 `MessageA` 改为 `MessageB`，现在期望的文本是 `"B: Hello World (Visited B)"`。`Msg`
    字段也是 `"Hello World"`，我们同样使用了 `TestHelper` 类型。'
- en: 'We still lack the correct implementations of the interfaces to compile the
    code and run the tests. The `MessageA` and `MessageB` structs have to implement
    the `Accept(Visitor)` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少接口的正确实现来编译代码和运行测试。`MessageA` 和 `MessageB` 结构体必须实现 `Accept(Visitor)` 方法：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We need the implementations of the `VisitA(*MessageA)` and `VisitB(*MessageB)`
    methods that are declared on the `Visitor` interface. The `MessageVisitor` interface
    is the type that must implement them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现 `Visitor` 接口上声明的 `VisitA(*MessageA)` 和 `VisitB(*MessageB)` 方法。`MessageVisitor`
    接口是必须实现它们的类型：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we will create a `Print()` method for each message type. This is the
    method that we will use to test the contents of the `Msg` field on each type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为每种消息类型创建一个 `Print()` 方法。这是我们用来测试每个类型 `Msg` 字段内容的工具：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can run the tests to really check if they are failing yet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行测试来真正检查它们是否已经失败：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The outputs of the tests are clear. The expected messages were incorrect because
    the contents were empty. It's time to create the implementations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输出很清晰。预期的消息是不正确的，因为内容是空的。是时候创建实现啦。
- en: Implementation of Visitor pattern
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者模式的实现
- en: 'We will start completing the implementation of the `VisitA(*MessageA)` and
    `VisitB(*MessageB)` methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始完成 `VisitA(*MessageA)` 和 `VisitB(*MessageB)` 方法的实现：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Its functionality is quite straightforward--the `fmt.Sprintf` method returns
    a formatted string with the actual contents of `m.Msg`, a white space, and the
    message, `Visited`. This string will be stored on the `Msg` field, overriding
    the previous contents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其功能相当直接--`fmt.Sprintf` 方法返回一个格式化的字符串，包含 `m.Msg` 的实际内容、一个空格和消息 `Visited`。这个字符串将被存储在
    `Msg` 字段，覆盖之前的内 容。
- en: 'Now we will develop the `Accept` method for each message type that must execute
    the corresponding Visitor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为必须执行相应访问者的每种消息类型开发 `Accept` 方法：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This small code has some implications on it. In both cases, we are using a
    `Visitor`, which in our example is exactly the same as the `MessageVisitor` interface,
    but they could be completely different. The key is to understand that the Visitor
    pattern executes an algorithm in its `Visit` method that deals with the `Visitable`
    object. What could the `Visitor` be doing? In this example, it alters the `Visitable`
    object, but it could be simply fetching information from it. For example, we could
    have a `Person` type with lots of fields: name, surname, age, address, city, postal
    code, and so on. We could write a Visitor to fetch just the name and surname from
    a person as a unique string, a visitor to fetch the address info for a different
    section of an app, and so on.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码有一些含义。在两种情况下，我们都在使用 `Visitor`，在我们的例子中，它正好与 `MessageVisitor` 接口相同，但它们可能完全不同。关键是理解访问者模式在其
    `Visit` 方法中执行算法，该算法处理 `Visitable` 对象。`Visitor` 可以做什么？在这个例子中，它改变了 `Visitable` 对象，但它也可以简单地从它那里获取信息。例如，我们可以有一个
    `Person` 类型，有很多字段：姓名、姓氏、年龄、地址、城市、邮政编码等等。我们可以编写一个访问者来从一个人那里获取唯一的字符串（姓名和姓氏），一个访问者来获取应用程序不同部分的地址信息，等等。
- en: 'Finally, there is the `Print()` method, which will help us to test the types.
    We mentioned before that it must print to the `Stdout` call by default:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是 `Print()` 方法，它将帮助我们测试类型。我们之前提到，它默认必须打印到 `Stdout` 调用：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It first checks the content of the `Output` field to assign the output of the `os.Stdout` call
    in case it is null. In our tests, we are storing a pointer there to our `TestHelper`
    type so this line is never executed in our test. Finally, each message type prints
    to the `Output` field, the full message stored in the `Msg` field. This is done
    by using the `Fprintf` method, which takes an `io.Writer` package as the first
    argument and the text to format as the next arguments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先检查 `Output` 字段的内容，以分配 `os.Stdout` 调用的输出，以防它是空的。在我们的测试中，我们在这里存储了一个指向我们的 `TestHelper`
    类型的指针，所以这行代码在我们的测试中永远不会被执行。最后，每个消息类型都会将存储在 `Msg` 字段中的完整消息打印到 `Output` 字段。这是通过使用
    `Fprintf` 方法完成的，该方法将 `io.Writer` 包作为第一个参数，将格式化文本作为后续参数。
- en: 'Our implementation is now complete and we can run the tests again to see if
    they all pass now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的实现已经完成，我们可以再次运行测试，看看它们现在是否都通过了：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Everything is OK! The Visitor pattern has done its job flawlessly and the message
    contents were altered after calling their `Visit` methods. The very important
    thing here is that we can add more functionality to both the structs, `MessageA`
    and `MessageB`, without altering their types. We can just create a new Visitor
    type that does everything on the `Visitable`, for example, we can create a `Visitor`
    to add a method that prints the contents of the `Msg` field:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常！访问者模式完美地完成了它的任务，并且在调用它们的 `Visit` 方法之后，消息内容被修改了。这里非常重要的一点是，我们可以为这两个结构体，`MessageA`
    和 `MessageB`，添加更多功能，而不改变它们的类型。我们只需创建一个新的访问者类型，它可以在 `Visitable` 上做所有事情，例如，我们可以创建一个
    `Visitor` 来添加一个打印 `Msg` 字段内容的方法：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have just added some functionality to both types without altering their contents!
    That's the power of the Visitor design pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是为这两种类型添加了一些功能，而没有改变它们的内部内容！这就是访问者设计模式的力量。
- en: Another example
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个示例
- en: We will develop a second example, this one a bit more complex. In this case,
    we will emulate an online shop with a few products. The products will have plain
    types, with just fields and we will make a couple of visitors to deal with them
    in the group.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发第二个示例，这个示例稍微复杂一些。在这种情况下，我们将模拟一个在线商店，其中包含一些产品。产品将具有普通类型，只有字段，我们将创建几个访问者来处理这些产品。
- en: 'First of all, we will develop the interfaces. The `ProductInfoRetriever` type
    has a method to get the price and the name of the product. The `Visitor` interface,
    like before, has a `Visit` method that accepts the `ProductInfoRetriever` type.
    Finally, `Visitable` interface is exactly the same; it has an `Accept` method
    that takes a `Visitor` type as an argument:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开发接口。`ProductInfoRetriever` 类型有一个方法可以获取产品的价格和名称。`Visitor` 接口，就像之前一样，有一个
    `Visit` 方法，它接受 `ProductInfoRetriever` 类型。最后，`Visitable` 接口完全相同；它有一个 `Accept` 方法，该方法接受一个
    `Visitor` 类型作为参数：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All the products of the online shop must implement the `ProductInfoRetriever`
    type. Also, most products will have some commons fields, such as name or price
    (the ones defined in the `ProductInfoRetriever` interface). We created the `Product`
    type, implemented the `ProductInfoRetriever` and the `Visitable` interfaces, and
    embedded it on each product:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在线商店的所有产品都必须实现 `ProductInfoRetriever` 类型。此外，大多数产品将有一些公共字段，例如名称或价格（在 `ProductInfoRetriever`
    接口中定义的）。我们创建了 `Product` 类型，实现了 `ProductInfoRetriever` 和 `Visitable` 接口，并将其嵌入到每个产品中：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we have a very generic `Product` type that can store the information about
    almost any product of the shop. For example, we could have a `Rice` and a `Pasta`
    product:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常通用的 `Product` 类型，它可以存储商店几乎任何产品的信息。例如，我们可能有一个 `Rice` 和 `Pasta` 产品：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each has the `Product` type embedded. Now we need to create a couple of `Visitors`
    interfaces, one that sums the price of all products and one that prints the name
    of each product:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都嵌入了 `Product` 类型。现在我们需要创建几个 `Visitors` 接口，一个用于计算所有产品的价格总和，另一个用于打印每个产品的名称：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `PriceVisitor` struct takes the value of the `Price` variable of the `ProductInfoRetriever`
    type, passed as an argument, and adds it to the `Sum` field. The `NamePrinter`
    struct stores the name of the `ProductInfoRetriever` type, passed as an argument,
    and appends it to a new line on the `ProductList` field.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriceVisitor` 结构体接受作为参数传递的 `ProductInfoRetriever` 类型的 `Price` 变量的值，并将其添加到
    `Sum` 字段。`NamePrinter` 结构体存储作为参数传递的 `ProductInfoRetriever` 类型的名称，并将其追加到新的 `ProductList`
    字段行。'
- en: 'Time for the `main` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 `main` 函数的时间：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We create a slice of two `Visitable` objects: a `Rice` and a `Pasta` type with
    some arbitrary names. Then we iterate for each of them using a `PriceVisitor`
    instance as an argument. We print the total price after the range for. Finally,
    we repeat this operation with the `NamePrinter` and print the resulting `ProductList`.
    The output of this `main` function is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含两个`Visitable`对象的切片：一个`Rice`和一个`Pasta`类型的对象，具有一些任意的名称。然后我们使用`PriceVisitor`实例作为参数对它们中的每一个进行迭代。在for循环结束后，我们打印出总价。最后，我们使用`NamePrinter`重复此操作并打印出结果`ProductList`。这个`main`函数的输出如下：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Ok, this is a nice example of the Visitor pattern but... what if there are
    special considerations about a product? For example, what if we need to sum 20
    to the total price of a fridge type? OK, let''s write the `Fridge` structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个访问者模式的良好示例，但是……如果对产品有特殊考虑怎么办？例如，如果我们需要将20加到冰箱类型的总价上怎么办？好的，让我们编写`Fridge`结构：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The idea here is to just override the `GetPrice()` method to return the product''s
    price plus 20:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是只是重写`GetPrice()`方法以返回产品的价格加上20：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unfortunately, this isn''t enough for our example. The `Fridge` structure is
    not of a  `Visitable` type. The `Product` struct is of a `Visitable` type and
    the `Fridge` struct has a `Product` struct embedded but, as we mentioned in earlier
    chapters, a type that embeds a second type cannot be considered of that latter
    type, even when it has all its fields and methods. The solution is to also implement
    the `Accept(Visitor)` method so that it can be considered as a `Visitable`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这对我们的示例还不够。`Fridge`结构不是`Visitable`类型。`Product`结构是`Visitable`类型，而`Fridge`结构包含一个`Product`结构体，但正如我们在前面的章节中提到的，嵌套第二个类型的类型不能被认为是后者类型，即使它具有所有字段和方法。解决方案是实现`Accept(Visitor)`方法，使其可以被认为是`Visitable`：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s rewrite the `main` function  to add this new `Fridge` product to the
    slice:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写`main`函数，以添加这个新的`Fridge`产品到切片中：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Everything else continues the same. Running this new `main` function produces
    the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切继续相同。运行这个新的`main`函数会产生以下输出：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As expected, the total price is higher now, outputting the sum of the rice (32),
    the pasta (40), and the fridge (50 of the product plus 20 of the transport, so
    70). We could be adding visitors forever to this products, but the idea is clear--we
    decoupled some algorithms outside of the types to the visitors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，总价现在更高了，输出的是大米（32）、意大利面（40）和冰箱（产品50加上运输20，所以70）的总和。我们可以永远向这些产品添加访问者，但理念是清晰的——我们将一些算法从类型中解耦到了访问者中。
- en: Visitors to the rescue!
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者来拯救！
- en: We have seen a powerful abstraction to add new algorithms to some types. However,
    because of the lack of overloading in Go, this pattern could be limiting in some
    aspects (we have seen it in the first example, where we had to create the `VisitA`
    and `VisitB` implementations). In the second example, we haven't dealt with this
    limitation because we have used an interface to the `Visit` method of the `Visitor` struct,
    but we just used one type of visitor (`ProductInfoRetriever`) and we would have
    the same problem if we implemented a `Visit` method for a second type, which is
    one of the objectives of the original *Gang of Four* design patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个强大的抽象，可以将新算法添加到某些类型中。然而，由于Go中缺少重载，这个模式在某些方面可能有限制（我们在第一个示例中看到了这一点，当时我们必须创建`VisitA`和`VisitB`实现）。在第二个示例中，我们没有处理这个限制，因为我们使用了`Visitor`结构体的`Visit`方法接口，但我们只使用了一种类型的访问者（`ProductInfoRetriever`），如果我们为第二种类型实现`Visit`方法，我们也会遇到同样的问题，这是原始*四人帮*设计模式的一个目标。
- en: State design pattern
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: State patterns are directly related to FSMs. An FSM, in very simple terms, is
    something that has one or more states and travels between them to execute some
    behaviors. Let's see how the State pattern helps us to define FSM.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式与FSM直接相关。在非常简单的术语中，FSM是具有一个或多个状态并在它们之间移动以执行某些行为的东西。让我们看看状态模式如何帮助我们定义FSM。
- en: Description
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: A light switch is a common example of an FSM. It has two states--on and off.
    One state can transit to the other and vice versa. The way that the State pattern
    works is similar. We have a `State` interface and an implementation of each state
    we want to achieve. There is also usually a context that holds cross-information
    between the states.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 开关灯是有限状态机（FSM）的一个常见示例。它有两个状态——开和关。一个状态可以转换到另一个状态，反之亦然。状态模式的工作方式与此类似。我们有一个`State`接口和每个我们想要实现的状态的实现。通常还有一个上下文，它持有状态之间的跨信息。
- en: With FSM, we can achieve very complex behaviors by splitting their scope between
    states. This way we can model pipelines of execution based on any kind of inputs
    or create event-driven software that responds to particular events in specified
    ways.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有限状态机（FSM），我们可以通过在状态之间分割它们的范围来实现非常复杂的行为。这样，我们可以根据任何类型的输入来建模执行管道，或者创建响应特定事件的特定方式的基于事件的软件。
- en: Objectives
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The main objectives of the State pattern is to develop FSM are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 国家模式的主要目标是为了开发有限状态机（FSM），具体如下：
- en: To have a type that alters its own behavior when some internal things have changed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要有一个类型，当某些内部事物发生变化时改变其自身的行为
- en: Model complex graphs and pipelines can be upgraded easily by adding more states
    and rerouting their output states
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加更多状态并重新路由它们的输出状态，可以轻松升级复杂的图和管道模型
- en: A small guess the number game
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的猜数字游戏
- en: We are going to develop a very simple game that uses FSM. This game is a number
    guessing game. The idea is simple--we will have to guess some number between 0
    and 10 and we have just a few attempts or we'll lose.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个非常简单的游戏，该游戏使用有限状态机（FSM）。这个游戏是一个数字猜测游戏。想法很简单——我们将在0到10之间猜测一个数字，我们只有几次尝试，否则就会失败。
- en: We will leave the player to choose the level of difficulty by asking how many
    tries the user has before losing. Then, we will ask the player for the correct
    number and keep asking if they don't guess it or if the number of tries reaches
    zero.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让玩家通过询问他们在游戏失败前有多少次尝试机会来选择难度级别。然后，我们将询问玩家正确的数字，如果他们猜不对或者尝试次数达到零，我们将继续询问。
- en: Acceptance criteria
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'For this simple game, we have five acceptance criteria that basically describe
    the mechanics of the game:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的游戏，我们有五个验收标准，基本上描述了游戏的机制：
- en: The game will ask the player how many tries they will have before losing the
    game.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏将询问玩家在游戏失败前将有多少次尝试机会。
- en: The number to guess must be between 0 and 10.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要猜测的数字必须在0到10之间。
- en: Every time a player enters a number to guess, the number of retries drops by
    one.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次玩家输入一个猜测数字时，尝试次数就会减少一次。
- en: If the number of retries reaches zero and the number is still incorrect, the
    game finishes and the player has lost.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尝试次数达到零而数字仍然不正确，游戏结束，玩家失败。
- en: If the player guesses the number, the player wins.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家猜对了数字，玩家获胜。
- en: Implementation of State pattern
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模式的实现
- en: The idea of unit tests is quite straightforward in a State pattern so we will
    spend more time explaining in detail the mechanism to use it, which is a bit more
    complex than usual.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态模式中，单元测试的想法非常直接，因此我们将花更多的时间详细解释如何使用它，这比通常要复杂一些。
- en: 'First of all, we need the interface to represent the different states and a
    game context to store the information between states. For this game, the context
    needs to store the number of retries, if the user has won or not, the secret number
    to guess, and the current state. The state will have an `executeState` method
    that accepts one of these contexts and returns `true` if the game has finished,
    or `false` if not:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个接口来表示不同的状态，以及一个游戏上下文来存储状态之间的信息。对于这个游戏，上下文需要存储重试次数、用户是否获胜、要猜测的秘密数字以及当前状态。状态将有一个
    `executeState` 方法，它接受这些上下文之一，如果游戏结束则返回 `true`，否则返回 `false`：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As described in *acceptance criteria 1*, the player must be able to introduce
    the number of retries they want. This will be achieved by a state called `StartState`.
    Also, the `StartState` struct must prepare the game, setting the context to its
    initial value before the player:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *验收标准 1* 所述，玩家必须能够输入他们想要的尝试次数。这将通过一个名为 `StartState` 的状态来实现。此外，`StartState`
    结构体必须在玩家之前准备游戏，将上下文设置为初始值：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First of all, the `StartState` struct implements the `GameState` structure because
    it has the `executeState(*Context)` method of Boolean type on its structure. At
    the beginning of this state, it sets the only state possible after executing this
    one--the `AskState` state. The `AskState` struct is not declared yet, but it will
    be the state where we ask the player for a number to guess.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`StartState` 结构体实现了 `GameState` 结构体，因为它在其结构体上有一个布尔类型的 `executeState(*Context)`
    方法。在这个状态开始时，它设置执行此状态后唯一可能的状态——`AskState` 状态。`AskState` 结构体尚未声明，但将是我们询问玩家猜测数字的状态。
- en: In the next two lines, we use the `Rand` package of Go to generate a random
    number. In the first line, we feed the random generator with the `int64` type
    number returned by the current moment, so we ensure a random feed in each execution
    (if you put a constant number here, the randomizer will also generate the same
    number too). The `rand.Intn(int)` method returns an integer number between zero
    and the specified number, so here we cover *acceptance criteria 2*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两行中，我们使用 Go 的 `Rand` 包来生成随机数。在第一行，我们将随机生成器与当前时刻返回的 `int64` 类型数字相结合，以确保每次执行时都能提供随机的输入（如果你在这里放置一个常数，随机化器也会生成相同的数字）。`rand.Intn(int)`
    方法返回一个介于零和指定数字之间的整数，因此在这里我们涵盖了*接受标准 2*。
- en: Next, a message asking for a number of retries to set precedes the `fmt.Fscanf`
    method, a powerful function where you can pass it an `io.Reader` (the standard
    input of the console), a format (number), and an interface to store the contents
    of the reader, in this case, the `Retries` field of the context.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个请求设置重试次数的消息位于 `fmt.Fscanf` 方法之前，这是一个强大的函数，你可以向它传递一个 `io.Reader`（控制台的标准输入）、一个格式（数字）和一个接口来存储读取器的内容，在这种情况下，是上下文的
    `Retries` 字段。
- en: 'Finally, we return `true` to tell the engine that the game must continue. Let''s
    see the `AskState` struct, which we have used at the beginning of the function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回 `true` 来告诉引擎游戏必须继续。让我们看看我们一开始在函数中使用的 `AskState` 结构体：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `AskState` structure also implements the `GameState` state, as you have
    probably guessed already. This states starts with a message for the player, asking
    them to insert a new number. In the next three lines, we create a local variable
    to store the contents of the number that the player will introduce. We used the
    `fmt.Fscanf` method again, as we did in `StartState` struct to capture the player's
    input and store it in the variable `n`. Then, we have one retry less in our counter,
    so we have to subtract one to the number of retries represented in the `Retries`
    field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`AskState` 结构体也实现了 `GameState` 状态，正如你可能已经猜到的。这个状态从给玩家的消息开始，要求他们插入一个新的数字。在接下来的三行中，我们创建一个局部变量来存储玩家将要输入的数字的内容。我们再次使用了
    `fmt.Fscanf` 方法，就像我们在 `StartState` 结构体中所做的那样，来捕获玩家的输入并将其存储在变量 `n` 中。然后，我们的计数器中减少了一个重试，所以我们必须从
    `Retries` 字段表示的重试次数中减去一个。'
- en: 'Then, there are two checks: one that checks if the user has entered the correct
    number, in which case the context field `Won` is set to `true` and the next state
    is set to the `FinishState` struct (not declared yet).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个检查：一个检查用户是否输入了正确的数字，如果是这样，则将上下文字段的 `Won` 设置为 `true`，并将下一个状态设置为 `FinishState`
    结构体（尚未声明）。
- en: The second check is controlling that the number of retries has not reached zero,
    in which case it won't let the player ask again for a number and it will send
    the player to the `FinishState` struct directly. After all, we have to tell the
    game engine again that the game must continue by returning `true` in the `executeState`
    method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个检查是控制重试次数是否未达到零，如果是这样，它不会让玩家再次请求数字，并将玩家直接发送到 `FinishState` 结构体。毕竟，我们必须再次告诉游戏引擎游戏必须继续，通过在
    `executeState` 方法中返回 `true`。
- en: 'Finally, we define the `FinishState` struct. It controls the exit status of
    the game, checking the contents of the `Won` field in the context object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义 `FinishState` 结构体。它控制游戏的退出状态，检查上下文对象中 `Won` 字段的内容：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `TheFinishState` struct also implements the `GameState` state by having
    `executeState` method in its structure. The idea here is very simple--if the player
    has won (this field is set previously in the `AskState` struct), the `FinishState`
    structure will print the message `Congrats, you won`. If the player has not won
    (remember that the zero value of the Boolean variable is `false`), the `FinishState`
    prints the message `You lose.`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`TheFinishState` 结构体通过在其结构体中拥有 `executeState` 方法来实现 `GameState` 状态。这里的想法非常简单--如果玩家已经赢了（这个字段在
    `AskState` 结构体中之前已经设置），则 `FinishState` 结构体会打印消息 `恭喜，你赢了`。如果玩家没有赢（记住布尔变量的零值是 `false`），则
    `FinishState` 会打印消息 `你输了`。'
- en: In this case, the game can be considered finished, so we return `false` to say
    that the game must not continue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，游戏可以被认为是结束了，所以我们返回 `false` 来表示游戏必须不继续。
- en: 'We just need the `main` method to play our game:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要 `main` 方法来玩我们的游戏：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Well, yes, it can't be simpler. The game must begin with the `start` method,
    although it could be abstracted more outside in case that the game needs more
    initialization in the future, but in our case it is fine. Then, we create a context
    where we set the `Next` state as a pointer to the `start` variable. So the first
    state that will be executed in the game will be the `StartState` state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是的，这不能更简单了。游戏必须从`start`方法开始，尽管将来如果游戏需要更多的初始化，它可以在外面进一步抽象化，但就我们目前的情况来看，这是可以的。然后，我们创建一个上下文，我们将`Next`状态设置为指向`start`变量的指针。所以游戏将首先执行的是`StartState`状态。
- en: The last line of the `main` function has a lot of things just there. We create
    a loop, without any statement inside it. As with any loop, it keeps looping after
    the condition is not satisfied. The condition we are using is the returned value
    of the `GameStates` structure, `true` as soon as the game is not finished.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的最后一行有很多东西只是在那里。我们创建了一个循环，循环体内没有任何语句。就像任何循环一样，当条件不满足时，它会一直循环。我们使用的是`GameStates`结构的返回值，只要游戏没有结束，就返回`true`。'
- en: 'So, the idea is simple: we execute the state in the context, passing a pointer
    to the context to it. Each state returns `true` until the game has finished and
    the `FinishState` struct will return `false`. So our for loop will keep looping,
    waiting for a `false` condition sent by the `FinishState` structure to end the
    application.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个想法很简单：我们在上下文中执行状态，传递上下文的指针给它。每个状态都会返回`true`，直到游戏结束，`FinishState`结构将返回`false`。所以我们的for循环会一直循环，等待`FinishState`结构发送的`false`条件来结束应用程序。
- en: 'Let''s play once:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一次：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We lost! We set the number of retries to 5\. Then we kept inserting numbers,
    trying to guess the secret number. We entered 8, 2, 1, 3, and 4, but it wasn't
    any of them. I don't even know what the correct number was; let's fix this!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输了！我们将重试次数设置为5。然后我们继续输入数字，试图猜出秘密数字。我们输入了8、2、1、3和4，但都不是。我甚至不知道正确的数字是什么；让我们修复这个问题！
- en: 'Go to the definition of the `FinishState` struct and change the line where
    it says `You lose`, and replace it with the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`FinishState`结构的定义，并更改显示“你输了”的那一行，将其替换为以下内容：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now it will show the correct number. Let''s play again:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它会显示正确的数字。让我们再玩一次：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time we make it a little harder by setting only three tries... and we
    lost again. I entered 6, 2, and 1, but the correct number was 9\. Last try:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们让它变得更难一些，只设置了三次尝试...我们又输了。我输入了6、2和1，但正确的数字是9。最后一次尝试：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great! This time we lowered the difficulty, allowing up to five tries and we
    won! we even had one more try left, but we guessed the number in the fourth try
    after entering 3, 4, 5\. The correct number was 6, which was my fourth try.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这次我们降低了难度，允许最多尝试五次，我们赢了！我们甚至还有一次额外的尝试，但在第四次尝试后，我们输入了3、4、5，猜出了数字。正确的数字是6，这是我第四次尝试。
- en: A state to win and a state to lose
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 胜利状态和失败状态
- en: 'Have you realized that we could have a winning and a lose state instead of
    printing the messages directly in the `FinishState` struct? This way we could,
    for example, check some hypothetical scoreboard in the win section to see if we
    have set a record. Let''s refactor our game. First we need a `WinState` and a
    `LoseState` struct:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到我们可以有一个胜利状态和一个失败状态，而不是直接在`FinishState`结构中打印消息吗？这样我们就可以，例如，检查胜利部分的一些假设的分数板，看看我们是否创下了记录。让我们重构我们的游戏。首先我们需要一个`WinState`和一个`LoseState`结构：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These two new states have nothing new. They contain the same messages that
    were previously in the `FinishState` state that, by the way, must be modified
    to use these new states:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新状态没有新内容。它们包含之前在`FinishState`状态中已有的相同信息，顺便说一句，必须修改以使用这些新状态：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the finish state doesn't print anything and, instead, delegates this to
    the next state in the chain--the `WinState` structure, if the user has won and
    the `LoseState` struct, if not. Remember that the game doesn't finish on the `FinishState`
    struct now, and we must return `true` instead of `false` to notify to the engine
    that it must keep executing states in the chain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成状态不会打印任何内容，而是将这个任务委托给链中的下一个状态——如果用户赢了，就是`WinState`结构，如果没有赢，就是`LoseState`结构。记住，现在游戏不会在`FinishState`结构中结束，我们必须返回`true`来通知引擎它必须继续执行链中的状态。
- en: The game built using the State pattern
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用状态模式构建的游戏
- en: You must be thinking now that you can extend this game forever with new states,
    and it's true. The power of the State pattern is not only the capacity to create
    a complex FSM, but also the flexibility to improve it as much as you want by adding
    new states and modifying some old states to point to the new ones without affecting
    the rest of the FSM.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Mediator design pattern
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with the Mediator pattern. As its name implies, it's a pattern
    that will be in between two types to exchange information. But, why will we want
    this behavior at all? Let's look at this in detail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Description
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key objectives of any design pattern is to avoid tight coupling between
    objects. This can be done in many ways, as we have seen already.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: But one particularly effective method when the application grows a lot is the
    Mediator pattern. The Mediator pattern is the perfect example of a pattern that
    is commonly used by every programmer without thinking very much about it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Mediator pattern will act as the type in charge of exchanging communication
    between two objects. This way, the communicating objects don't need to know each
    other and can change more freely. The pattern that maintains which objects give
    what information is the Mediator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously described, the main objectives of the Mediator pattern are about
    loose coupling and encapsulation. The objectives are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: To provide loose coupling between two objects that must communicate between
    them
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reduce the amount of dependencies of a particular type to the minimum by
    passing these needs to the Mediator pattern
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A calculator
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the Mediator pattern, we are going to develop an extremely simple arithmetic
    calculator. You're probably thinking that a calculator is so simple that it does
    not need any pattern. But we will see that this is not exactly true.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Our calculator will only do two very simple operations: sum and subtract.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It sounds quite funny to talk about acceptance criteria to define a calculator,
    but let''s do it anyway:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Define an operation called `Sum` that takes a number and adds it to another
    number.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an operation called `Subtract` that takes a number and substracts it
    to another number.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well, I don't know about you, but I really need a rest after this *complex*
    criteria. So why are we defining this so much? Patience, you will have the answer
    soon.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to jump directly to the implementation because we cannot test that the
    sum will be correct (well, we can, but we will be testing if Go is correctly written!).
    We could test that we pass the acceptance criteria, but it's a bit of an overkill
    for our example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start by implementing the necessary types:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Well... this look quite awkward. We already have numeric types in Go to perform
    these operations, we don't need a type for each number!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s continue for a second with this insane approach. Let''s implement
    the `One` struct:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: OK , I'll stop here. What is wrong with this implementation? This is completely
    crazy! It's overkill to make every operation possible between numbers to make
    sums! Especially when we have more than one digit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Well, believe it or not, this is how a lot of software is commonly designed
    today. A small app where an object uses two or three objects grows, and it ends
    up using dozens of them. It becomes an absolute hell to simply add or remove a
    type from the application because it is hidden in some of this craziness.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'So what can we do in this calculator? Use a Mediator type that frees all the
    cases:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have just developed a couple of numbers to keep things short. The `Sum` function
    acts as a mediator between two numbers. First it checks the type of the first
    number named `a`. Then, for each type of the first number, it checks the type
    of the second number named `b` and returns the resulting type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: While the solution still looks very crazy now, the only one that knows about
    all possible numbers in the calculator is the `Sum` function. But take a closer
    look and you'll see that we have added a type case for the `int` type. We have
    cases `One`, `Two` , and `int`. Inside the `int` case, we also have another `int` case
    for the `b` number. What do we do here? If both types are of the `int` case, we
    can return the sum of them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you think that this will work? Let''s write a simple `main` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We print the sum of type `One` and type `Two`. By using the `"%#v"` format,
    we ask to print information about the type. The second line in the function uses
    `int` types, and we also print the result. This in the console produces the following
    output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Not very impressive, right? But let's think for a second. By using the Mediator
    pattern, we have been able to refactor the initial calculator, where we have to
    define every operation on every type to a Mediator pattern, the `Sum` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing is that, thanks to the Mediator pattern, we have been able to
    start using integers as values for our calculator. We have just defined the simplest
    example by adding two integers, but we could have done the same with an integer
    and the `type`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this small modification, we can now use type `One` with an `int` as number
    `b`. If we keep working on this Mediator pattern, we could achieve a lot of flexibility
    between types, without having to implement every possible operation between them,
    generating a tight coupling.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a new `Sum` method in the main function to see this in action:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Nice. The Mediator pattern is in charge of knowing about the possible types
    and returns the most convenient type for our case, which is an integer. Now we
    could keep growing this `Sum` function until we completely get rid of using the
    numeric types we have defined.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Uncoupling two types with the Mediator
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have carried out a disruptive example to try to think outside the box and
    reason deeply about the Mediator pattern. Tight coupling between entities in an
    app can become really complex to deal with in the future and allow more difficult
    refactoring if needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that the Mediator pattern is there to act as a managing type between
    two types that don't know about each other so that you can take one of the types
    without affecting the other and replace a type in a more easy and convenient way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Observer design pattern
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will finish the common *Gang of Four* design patterns with my favorite:
    the Observer pattern, also known as publish/subscriber or publish/listener. With
    the State pattern, we defined our first event-driven architecture, but with the
    Observer pattern we will really reach a new level of abstraction.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Description
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind the Observer pattern is simple--to subscribe to some event that
    will trigger some behavior on many subscribed types. Why is this so interesting?
    Because we uncouple an event from its possible handlers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a login button. We could code that when the user clicks
    the button, the button color changes, an action is executed, and a form check
    is performed in the background. But with the Observer pattern, the type that changes
    the color will subscribe to the event of the clicking of the button. The type
    that checks the form and the type that performs an action will subscribe to this
    event too.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Observer pattern is especially useful to achieve many actions that are
    triggered on one event. It is also especially useful when you don''t know how
    many actions are performed after an event in advance or there is a possibility
    that the number of actions is going to grow in the near future. To resume, do
    the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Provide an event-driven architecture where one event can trigger one or more
    actions
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncouple the actions that are performed from the event that triggers them
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide more than one event that triggers the same action
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notifier
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop the simplest possible application to fully understand the roots
    of the Observer pattern. We are going to make a `Publisher` struct, which is the
    one that triggers an event so it must accept new observers and remove them if
    necessary. When the `Publisher` struct is triggered, it must notify all its observers
    of the new event with the data associated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The requirements must tell us to have some type that triggers some method in
    one or more actions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We must have a publisher with a `NotifyObservers` method that accepts a message
    as an argument and triggers a `Notify` method on every observer subscribed.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must have a method to add new subscribers to the publisher.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must have a method to remove new subscribers from the publisher.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit tests
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maybe you have realized that our requirements defined almost exclusively the
    `Publisher` type. This is because the action performed by the observer is irrelevant
    for the Observer pattern. It should simply execute an action, in this case the
    `Notify` method, that one or many types will implement. So let''s define this
    only interface for this pattern:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `Observer` interface has a `Notify` method that accepts a `string` type
    that will contain the message to spread. It does not need to return anything,
    but we could return an error if we want to check if all observers have been reached
    when calling the `publish` method of the `Publisher` structure.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'To test all the acceptance criteria, we just need a structure called `Publisher`
    with three methods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Publisher` structure stores the list of subscribed observers in a slice
    field called `ObserversList`. Then it has the three methods mentioned on the acceptance
    criteria-the `AddObserver` method to subscribe a new observer to the publisher,
    the `RemoveObserver` method to unsubscribe an observer, and the `NotifyObservers`
    method with a string that acts as the message we want to spread between all observers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'With these three methods, we have to set up a root test to configure the `Publisher`
    and three subtests to test each method. We also need to define a test type structure
    that implements the `Observer` interface. This structure is going to be called
    `TestObserver`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `TestObserver` structure implements the Observer pattern by defining a `Notify(string)`
    method in its structure. In this case, it prints the received message together
    with its own observer ID. Then, it stores the message in its `Message` field.
    This allows us to check later if the content of the `Message` field is as expected.
    Remember that it could also be done by passing the `testing.T` pointer and the
    expected message and checking within the `TestObserver` structure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can set up the `Publisher` structure to execute the three tests. We
    will create three instances of the `TestObserver` structure:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have given a different ID to each observer so that we can see later that
    each of them has printed the expected message. Then, we have added the observers
    by calling the `AddObserver` method on the `Publisher` structure.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write an `AddObserver` test, it must add a new observer to the `ObserversList`
    field of the `Publisher` structure:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We have added three observers to the `Publisher` structure, so the length of
    the slice must be 3\. If it's not 3, the test will fail.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RemoveObserver` test will take the observer with ID 2 and remove it from
    the list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After removing the second observer, the length of the `Publisher` structure
    must be 2 now. We also check that none of the observers left have the `ID` 2 because
    it must be removed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method to test is the `Notify` method. When using the `Notify` method,
    all instances of `TestObserver` structure must change their `Message` field from
    empty to the passed message (`Hello World!` in this case). First we will check
    that all the `Message` fields are, in fact, empty before calling the `NotifyObservers`
    test:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using a `for` statement, we are iterating over the `ObserversList` field to
    slice in the `publisher` instance. We need to make a type casting from a pointer
    to an observer, to a pointer to the `TestObserver` structure, and check that the
    casting has been done correctly. Then, we check that the `Message` field is actually
    empty.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a message to send--in this case, it will be `"Hello
    World!"` and then pass this message to the `NotifyObservers` method to notify
    every observer on the list (currently observers 1 and 3 only):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After calling the `NotifyObservers` method, each `TestObserver` tests in the
    `ObserversList` field must have the message `"Hello World!"` stored in their `Message`
    field. Again, we use a `for` loop to iterate over every observer of the `ObserversList`
    field and we typecast each to a `TestObserver` test (remember that `TestObserver`
    structure doesn't have any field as it's an interface). We could avoid type casting
    by adding a new `Message()` method to `Observer` instance and implementing it
    in the `TestObserver` structure to return the contents of the `Message` field.
    Both methods are equally valid. Once we have type casted to a `TestObserver` method
    called `printObserver` variable as a local variable, we check that each instance
    in the `ObserversList` structure has the string `"Hello World!"` stored in their
    `Message` field.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to run the tests that must fail all to check their effectiveness in the
    later implementation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Something isn't working as expected. How is the `Notify` method passing the
    tests if we haven't implemented the function yet? Take a look at the test of the
    `Notify` method again. The test iterates over the `ObserversList` structure and
    each `F` `ail` call is inside this for loop. If the list is empty, it won't iterate,
    so it won't execute any `Fail call`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this issue by adding a small non-empty list check at the beginning
    of the `Notify` test:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And we will rerun the tests to see if the `TestSubject/Notify` method is already
    failing:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Nice, all of them are failing and now we have some guarantee on our tests. We
    can proceed to the implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our implementation is just to define the `AddObserver`, the `RemoveObserver`,
    and the `NotifyObservers` methods:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `AddObserver` method adds the `Observer` instance to the `ObserversList`
    structure by appending the pointer to the current list of pointers. This one was
    very easy. The `AddObserver` test must be passing now (but not the rest or we
    could have done something wrong):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Excellent. Just the `AddObserver` method has passed the test, so we can now
    continue to the `RemoveObserver` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `RemoveObserver` method will iterate for each element in the `ObserversList`
    structure, comparing the `Observer` object''s `o` variable with the ones stored
    in the list. If it finds a match, it saves the index  in the local variable, `indexToRemove`,
    and stops the iteration. The way to remove indexes on a slice in Go is a bit tricky:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to use slice indexing to return a new slice containing every
    object from the beginning of the slice to the index we want to remove (not included).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we get another slice from the index we want to remove (not included) to
    the last object in the slice
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we join the previous two new slices into a new one (the `append` function)
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, in a list from 1 to 10 in which we want to remove the number 5,
    we have to create a new slice, joining a slice from 1 to 4 and a slice from 6
    to 10.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: This index removal is done with the `append` function again because we are actually
    appending two lists together. Just take a closer look at the three dots at the
    end of the second argument of the `append` function. The `append` function adds
    an element (the second argument) to a slice (the first), but we want to append
    an entire list. This can be achieved using the three dots, which translate to
    something like *keep adding elements until you finish the second array*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, let''s run this test now:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We continue in the good path. The `RemoveObserver` test has been fixed without
    fixing anything else. Now we have to finish our implementation by defining the
    `NotifyObservers` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `NotifyObservers` method is quite simple because it prints a message to
    the console to announce that a particular message is going to be passed to the
    `Observers`. After this, we use a for loop to iterate over `ObserversList` structure
    and execute each `Notify(string)` method by passing the argument `m`. After executing
    this, all observers must have the message `Hello World!` stored in their `Message`
    field. Let''s see if this is true by running the tests:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Excellent! We can also see the outputs of the `Publisher` and `Observer` types
    on the console. The `Publisher` structure prints the following message:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After this, all observers print their respective messages as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And the same for the third observer.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have unlocked the power of event-driven architectures with the State pattern
    and the Observer pattern. Now you can really execute asynchronous algorithms and
    operations in your application that respond to events in your system.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern is commonly used in UI's. Android programming is filled
    with Observer patterns so that the Android SDK can delegate the actions to be
    performed by the programmers creating an app.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
