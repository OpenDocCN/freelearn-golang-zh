<html><head></head><body><div class="book" title="Type assertion" id="1O8H61-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec55" class="calibre1"/>Type assertion</h1></div></div></div><p class="calibre10">When an interface (empty or otherwise) is assigned to a variable, it carries type information that can be queried at runtime. Type assertion is a mechanism that is available in Go to idiomatically narrow a variable (of <code class="email">interface</code> type) down to a concrete type and value that are stored in the variable. The following example uses type assertion in the <code class="email">eat</code> function to select which <code class="email">food</code> type to select in the <code class="email">eat</code> function:</p><pre class="programlisting">type food interface { 
   eat() 
} 
 
type veggie string 
func (v veggie) eat() { 
   fmt.Println("Eating", v) 
} 
 
type meat string 
func (m meat) eat() { 
   fmt.Println("Eating tasty", m) 
} 
 
func eat(f food) { 
   veg, ok := f.(veggie) 
   if ok { 
         if veg == "okra" { 
               fmt.Println("Yuk! not eating ", veg) 
         }else{ 
               veg.eat() 
         } 
 
         return 
   } 
 
   mt, ok := f.(meat) 
   if ok { 
         if mt == "beef" { 
               fmt.Println("Yuk! not eating ", mt) 
         }else{ 
               mt.eat() 
         } 
         return 
   } 
 
   fmt.Println("Not eating whatever that is: ", f) 
} 
</pre><p class="calibre10">golang.fyi/interface_assert.go</p><p class="calibre10">The <code class="email">eat</code> function takes the <code class="email">food</code> interface type as its parameter. The code shows how to use idiomatic Go to extract the static type and value stored in the <code class="email">f</code> interface parameter using assertion. The general form for type assertion expression is given as follows:</p><p class="calibre10"><span class="strong"><em class="calibre11">&lt;interface_variable&gt;.(concrete type name)</em></span></p><p class="calibre10">The expression starts with the variable of the interface type. It is then followed by a dot and the concrete type being asserted enclosed in parentheses. The type assertion expression can return two values: one is the concrete value (extracted from the interface) and the second is a Boolean indicating the success of the assertion, as shown here:</p><p class="calibre10"><span class="strong"><em class="calibre11">value, boolean := &lt;interface_variable&gt;.(concrete type name)</em></span></p><p class="calibre10">This is the form of assertion that is shown in the following snippet (extracted from the earlier example) when narrowing the <code class="email">f </code>parameter to a specific type of <code class="email">food</code>. If the type is asserted to be <code class="email">meat</code>, then the code continues to test the value of the <code class="email">mt</code> variable:</p><pre class="programlisting">mt, ok := f.(meat) 
if ok { 
   if mt == "beef" { 
         fmt.Println("Yuk! not eating ", mt) 
   }else{ 
         mt.eat() 
   } 
   return 
} 
</pre><p class="calibre10">A type assertion expression can also return just the value, as follows:</p><p class="calibre10"><span class="strong"><em class="calibre11">value := &lt;interface_variable&gt;<span class="strong"><strong class="calibre2">.</strong></span>(concrete type name)</em></span></p><p class="calibre10">This form of assertion is risky to do as the runtime will cause a panic in the program if the value stored in the interface variable is not of the asserted type. Use this form only if you have other safeguards to either prevent or gracefully handle a panic.</p><p class="calibre10">Lastly, when your code requires multiple assertions to test many types at runtime, a much nicer idiom for assertions is the type <code class="email">switch</code> statement. It uses the <code class="email">switch</code> statement semantic to query static type information from an interface value using case clauses. The <code class="email">eat</code> function from the previous food-related example can been updated to use a type <code class="email">switch</code> instead of <code class="email">if</code> statement, as shown in the following code snippet:</p><pre class="programlisting">func eat(f food) { 
   swtich morsel := f.(type){ 
   case veggie: 
         if morsel == "okra" { 
               fmt.Println("Yuk! not eating ", mosel) 
         }else{ 
               mosel.eat() 
         } 
   case meat: 
         if morsel == "beef" { 
               fmt.Println("Yuk! not eating ", mosel) 
         }else{ 
               mosel.eat() 
         }            
   default: 
         fmt.Println("Not eating whatever that is: ", f) 
   } 
} 
</pre><p class="calibre10">golang.fyi/interface_assert2.go</p><p class="calibre10">Notice the code is much nicer to read. It can support any number of cases and is clearly laid out with visual clues that makes it easy to reason about. The <code class="email">switch</code> type also makes the panic issue go away by simply specifying a default case that can handle any types not specifically handled in the case clause.</p></div></body></html>