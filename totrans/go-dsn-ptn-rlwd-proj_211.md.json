["```go\ntype food interface { \n   eat() \n} \n\ntype veggie string \nfunc (v veggie) eat() { \n   fmt.Println(\"Eating\", v) \n} \n\ntype meat string \nfunc (m meat) eat() { \n   fmt.Println(\"Eating tasty\", m) \n} \n\nfunc eat(f food) { \n   veg, ok := f.(veggie) \n   if ok { \n         if veg == \"okra\" { \n               fmt.Println(\"Yuk! not eating \", veg) \n         }else{ \n               veg.eat() \n         } \n\n         return \n   } \n\n   mt, ok := f.(meat) \n   if ok { \n         if mt == \"beef\" { \n               fmt.Println(\"Yuk! not eating \", mt) \n         }else{ \n               mt.eat() \n         } \n         return \n   } \n\n   fmt.Println(\"Not eating whatever that is: \", f) \n} \n\nf parameter to a specific type of food. If the type is asserted to be meat, then the code continues to test the value of the mt variable:\n```", "```go\nmt, ok := f.(meat) \nif ok { \n   if mt == \"beef\" { \n         fmt.Println(\"Yuk! not eating \", mt) \n   }else{ \n         mt.eat() \n   } \n   return \n} \n\n```", "```go\nfunc eat(f food) { \n   swtich morsel := f.(type){ \n   case veggie: \n         if morsel == \"okra\" { \n               fmt.Println(\"Yuk! not eating \", mosel) \n         }else{ \n               mosel.eat() \n         } \n   case meat: \n         if morsel == \"beef\" { \n               fmt.Println(\"Yuk! not eating \", mosel) \n         }else{ \n               mosel.eat() \n         }            \n   default: \n         fmt.Println(\"Not eating whatever that is: \", f) \n   } \n} \n\n```"]