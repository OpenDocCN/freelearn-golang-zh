<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Concurrency" id="1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Goroutines"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec57" class="calibre1"/>Goroutines</h1></div></div></div><p class="calibre10">If you have worked in other languages, such as Java or C/C++, you are probably familiar with the notion of concurrency. It is the ability of a program to run two or more paths of execution independently. This is usually done by exposing a thread primitive directly to the programmer to create and manage concurrency.</p><p class="calibre10">Go has its own concurrency primitive called the <span class="strong"><em class="calibre11">goroutine</em></span>, which allows a program to launch a function (routine) to execute independently from its calling function. Goroutines are lightweight execution contexts that are multiplexed among a small number of OS-backed threads and scheduled by Go's runtime scheduler. That makes them cheap to create without the overhead requirements of true kernel threads. As such, a Go program can initiate thousands (even hundreds of thousands) of goroutines with minimal impact on performance and resource degradation.</p></div></div></body></html>