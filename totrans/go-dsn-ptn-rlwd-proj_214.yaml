- en: Goroutines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: If you have worked in other languages, such as Java or C/C++, you are probably
    familiar with the notion of concurrency. It is the ability of a program to run
    two or more paths of execution independently. This is usually done by exposing
    a thread primitive directly to the programmer to create and manage concurrency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在其他语言中工作过，例如 Java 或 C/C++，你可能熟悉并发性的概念。这是程序运行两个或更多独立执行路径的能力。这通常是通过直接向程序员暴露线程原语来创建和管理并发性来实现的。
- en: Go has its own concurrency primitive called the *goroutine*, which allows a
    program to launch a function (routine) to execute independently from its calling
    function. Goroutines are lightweight execution contexts that are multiplexed among
    a small number of OS-backed threads and scheduled by Go's runtime scheduler. That
    makes them cheap to create without the overhead requirements of true kernel threads.
    As such, a Go program can initiate thousands (even hundreds of thousands) of goroutines
    with minimal impact on performance and resource degradation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有自己的并发原语，称为 *goroutine*，它允许程序从其调用函数独立地启动一个函数（例程）执行。Goroutines 是轻量级的执行上下文，它们在少数几个由操作系统支持的线程之间多路复用，并由
    Go 的运行时调度器进行调度。这使得它们在创建时成本较低，无需真正内核线程的开销要求。因此，Go 程序可以启动成千上万（甚至数十万）的 goroutines，而对性能和资源退化影响最小。
