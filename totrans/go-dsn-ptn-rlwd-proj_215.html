<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Concurrency" id="1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Goroutines">
<div class="book" title="The go statement"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec148" class="calibre1"/>The go statement</h2></div></div></div><p class="calibre10">Goroutines are launched using the <code class="email">go</code> statement as follows:</p><p class="calibre10"><span class="strong"><em class="calibre11">go &lt;function or expression&gt;</em></span></p><p class="calibre10">A goroutine is created with the <code class="email">go</code> keyword followed by the function to schedule for execution. The specified function can be an existing function, an anonymous function, or an expression that calls a function. The following code snippet shows an example of the use of goroutines:</p><pre class="programlisting">func main() { 
   go count(10, 50, 10) 
   go count(60, 100, 10) 
   go count(110, 200, 20) 
} 
func count(start, stop, delta int) { 
   for i := start; i &lt;= stop; i += delta { 
         fmt.Println(i) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch09/goroutine0.go</p><p class="calibre10">In the previous code sample, when the <code class="email">go count()</code>Â statement is encountered in the <code class="email">main</code> function, it launches the <code class="email">count</code> function in an independent execution context. Both the <code class="email">main</code> and <code class="email">count</code> functions will be executing concurrently. As a side effect, <code class="email">main</code> will complete before any of the <code class="email">count</code> functions get a chance to print anything to the console.</p><p class="calibre10">Later in the chapter, we will see how to handle synchronization idiomatically between goroutines. For now, let us use <code class="email">fmt.Scanln()</code> to block and wait for keyboard input, as shown in the following sample. In this version, the concurrent functions get a chance to complete while waiting for keyboard input:</p><pre class="programlisting">func main() { 
   go count(10, 30, 10) 
   go count(40, 60, 10) 
   go count(70, 120, 20) 
   fmt.Scanln() // blocks for kb input 
} 
</pre><p class="calibre10">golang.fyi/ch09/goroutine1.go</p><p class="calibre10">Goroutines may also be defined as function literals directly in the <code class="email">go</code> statement, as shown in this updated version of the example shown in the following code snippet:</p><pre class="programlisting">func main() { 
   go count(10, 30, 10) 
   go func() { 
         count(40, 60, 10) 
   }() 
   ... 
}  
</pre><p class="calibre10">golang.fyi/ch09/goroutine2.go</p><p class="calibre10">The function literal provides a convenient idiom that allows programmers to assemble logic directly at the site of the <code class="email">go</code> statement. When using the <code class="email">go</code> statement with a function literal, it is treated as a regular closure with lexical access to non-local variables, as shown in the following example:</p><pre class="programlisting">func main() { 
   start := 0 
   stop := 50 
   step := 5 
   go func() { 
         count(start, stop, step) 
   }() 
} 
</pre><p class="calibre10">golang.fyi/ch09/goroutine3.go</p><p class="calibre10">In the previous code, the goroutine is able to access and use the variables <code class="email">start</code>, <code class="email">stop</code>, and <code class="email">step</code>. This is safe as long as the variables captured in the closure are not expected to change after the goroutine starts. If these values are updated outside of the closure, it may create race conditions causing the goroutine to read unexpected values by the time it is scheduled to run.</p><p class="calibre10">The following snippet shows an example where the goroutine closure captures the variable <code class="email">j</code> from the loop:</p><pre class="programlisting">func main() { 
   starts := []int{10,40,70,100} 
   for _, j := range starts{ 
         go func() { 
               count(j, j+20, 10) 
         }() 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch09/goroutine4.go</p><p class="calibre10">Since <code class="email">j</code> is updated with each iteration, it is impossible to determine what value will be read by the closure. In most cases, the goroutine closures will see the last updated value of <code class="email">j</code> by the time they are executed. This can be easily fixed by passing the variable as a parameter in the function literal for the goroutine, as shown here:</p><pre class="programlisting">func main() { 
   starts := []int{10,40,70,100} 
   for _, j := range starts{ 
         go func(s int) { 
               count(s, s+20, 10) 
         }(j) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch09/goroutine5.go</p><p class="calibre10">The goroutine closures, invoked with each loop iteration, receive a copy of the <code class="email">j</code> variable via the function parameter. This creates a local copy of the <code class="email">j</code> value with the proper value to be used when the goroutine is scheduled to run.</p></div></div></div></body></html>