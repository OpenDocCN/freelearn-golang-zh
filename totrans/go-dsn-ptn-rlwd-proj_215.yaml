- en: The go statement
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go语句
- en: 'Goroutines are launched using the `go` statement as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines是通过以下方式启动的：
- en: '*go <function or expression>*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*go <函数或表达式>*'
- en: 'A goroutine is created with the `go` keyword followed by the function to schedule
    for execution. The specified function can be an existing function, an anonymous
    function, or an expression that calls a function. The following code snippet shows
    an example of the use of goroutines:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go`关键字创建一个goroutine，后跟要调度的函数。指定的函数可以是现有函数、匿名函数或调用函数的表达式。以下代码片段显示了goroutines的使用示例：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch09/goroutine0.go
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine0.go
- en: In the previous code sample, when the `go count()` statement is encountered
    in the `main` function, it launches the `count` function in an independent execution
    context. Both the `main` and `count` functions will be executing concurrently.
    As a side effect, `main` will complete before any of the `count` functions get
    a chance to print anything to the console.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，当在`main`函数中遇到`go count()`语句时，它将在一个独立的执行上下文中启动`count`函数。`main`和`count`函数将并发执行。作为副作用，`main`将在任何`count`函数有机会将任何内容打印到控制台之前完成。
- en: 'Later in the chapter, we will see how to handle synchronization idiomatically
    between goroutines. For now, let us use `fmt.Scanln()` to block and wait for keyboard
    input, as shown in the following sample. In this version, the concurrent functions
    get a chance to complete while waiting for keyboard input:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到如何以惯用的方式在goroutine之间处理同步。现在，让我们使用`fmt.Scanln()`来阻塞并等待键盘输入，如下面的示例所示。在这个版本中，在等待键盘输入的同时，并发函数有机会完成：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch09/goroutine1.go
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine1.go
- en: 'Goroutines may also be defined as function literals directly in the `go` statement,
    as shown in this updated version of the example shown in the following code snippet:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines也可以直接在`go`语句中以函数字面量的形式定义，如下面代码片段中示例的更新版本所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch09/goroutine2.go
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine2.go
- en: 'The function literal provides a convenient idiom that allows programmers to
    assemble logic directly at the site of the `go` statement. When using the `go`
    statement with a function literal, it is treated as a regular closure with lexical
    access to non-local variables, as shown in the following example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量提供了一个方便的惯用语法，允许程序员在`go`语句的现场组装逻辑。当使用函数字面量与`go`语句一起使用时，它被视为一个常规闭包，具有对非局部变量的词法访问，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch09/goroutine4.go
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine4.go
- en: 'Since `j` is updated with each iteration, it is impossible to determine what
    value will be read by the closure. In most cases, the goroutine closures will
    see the last updated value of `j` by the time they are executed. This can be easily
    fixed by passing the variable as a parameter in the function literal for the goroutine,
    as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`j`在每次迭代中都会更新，因此无法确定闭包将读取什么值。在大多数情况下，goroutine闭包在执行时将看到`j`的最后一个更新值。这可以通过在goroutine的函数字面量中将变量作为参数传递来轻松修复，如下所示：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch09/goroutine5.go
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine5.go
- en: The goroutine closures, invoked with each loop iteration, receive a copy of
    the `j` variable via the function parameter. This creates a local copy of the
    `j` value with the proper value to be used when the goroutine is scheduled to
    run.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中调用的goroutine闭包通过函数参数接收`j`变量的一个副本。这创建了一个带有正确值的`j`值的局部副本，以便在goroutine被调度运行时使用。
