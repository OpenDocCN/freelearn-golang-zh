- en: The go statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Goroutines are launched using the `go` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*go <function or expression>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A goroutine is created with the `go` keyword followed by the function to schedule
    for execution. The specified function can be an existing function, an anonymous
    function, or an expression that calls a function. The following code snippet shows
    an example of the use of goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine0.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code sample, when the `go count()`Â statement is encountered
    in the `main` function, it launches the `count` function in an independent execution
    context. Both the `main` and `count` functions will be executing concurrently.
    As a side effect, `main` will complete before any of the `count` functions get
    a chance to print anything to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the chapter, we will see how to handle synchronization idiomatically
    between goroutines. For now, let us use `fmt.Scanln()` to block and wait for keyboard
    input, as shown in the following sample. In this version, the concurrent functions
    get a chance to complete while waiting for keyboard input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Goroutines may also be defined as function literals directly in the `go` statement,
    as shown in this updated version of the example shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The function literal provides a convenient idiom that allows programmers to
    assemble logic directly at the site of the `go` statement. When using the `go`
    statement with a function literal, it is treated as a regular closure with lexical
    access to non-local variables, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine4.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `j` is updated with each iteration, it is impossible to determine what
    value will be read by the closure. In most cases, the goroutine closures will
    see the last updated value of `j` by the time they are executed. This can be easily
    fixed by passing the variable as a parameter in the function literal for the goroutine,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine5.go
  prefs: []
  type: TYPE_NORMAL
- en: The goroutine closures, invoked with each loop iteration, receive a copy of
    the `j` variable via the function parameter. This creates a local copy of the
    `j` value with the proper value to be used when the goroutine is scheduled to
    run.
  prefs: []
  type: TYPE_NORMAL
