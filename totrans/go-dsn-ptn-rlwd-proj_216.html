<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Concurrency" id="1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Goroutines">
<div class="book" title="Goroutine scheduling"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec149" class="calibre1"/>Goroutine scheduling</h2></div></div></div><p class="calibre10">In general, all goroutines run independently of each other, as depicted in the following illustration. A function that creates a goroutine does not wait for it to return, it continues with its own execution stream unless there is a blocking condition. Later, the chapter covers synchronization idioms to coordinate goroutines:</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Goroutine scheduling" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">Go's runtime scheduler uses a form of cooperative scheduling to schedule goroutines. By default, the scheduler will allow a running goroutine to execute to completion. However, the scheduler will automatically yield to another goroutine for execution if one of the following events occurs:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A <code class="email">go</code> statement is encountered in the executing goroutine</li><li class="listitem">A channel operation is encountered (channels are covered later)</li><li class="listitem">A blocking system call (file or network IO for instance) is encountered</li><li class="listitem">After the completion of a garbage collection cycle</li></ul></div><p class="calibre10">The scheduler will schedule a queued goroutines ready to enter execution when one of the previous events is encountered in a running goroutine. It is important to point out that the scheduler makes no guarantee of the order of execution of goroutines. When the following code snippet is executed, for instance, the output will be printed in an arbitrary order for each run:</p><pre class="programlisting">func main() { 
   go count(10, 30, 10) 
   go count(40, 60, 10) 
   go count(70, 120, 20) 
   fmt.Scanln() // blocks for kb input 
} 
func count(start, stop, delta int) { 
   for i := start; i &lt;= stop; i += delta { 
         fmt.Println(i) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch09/goroutine1.go</p><p class="calibre10">The following shows possible output for the previous program:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">10</strong></span>
<span class="strong"><strong class="calibre2">70</strong></span>
<span class="strong"><strong class="calibre2">90</strong></span>
<span class="strong"><strong class="calibre2">110</strong></span>
<span class="strong"><strong class="calibre2">40</strong></span>
<span class="strong"><strong class="calibre2">50</strong></span>
<span class="strong"><strong class="calibre2">60</strong></span>
<span class="strong"><strong class="calibre2">20</strong></span>
<span class="strong"><strong class="calibre2">30</strong></span>
</pre></div></div></div></body></html>