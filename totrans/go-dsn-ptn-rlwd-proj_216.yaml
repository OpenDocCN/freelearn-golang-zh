- en: Goroutine scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, all goroutines run independently of each other, as depicted in
    the following illustration. A function that creates a goroutine does not wait
    for it to return, it continues with its own execution stream unless there is a
    blocking condition. Later, the chapter covers synchronization idioms to coordinate
    goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Goroutine scheduling](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go''s runtime scheduler uses a form of cooperative scheduling to schedule goroutines.
    By default, the scheduler will allow a running goroutine to execute to completion.
    However, the scheduler will automatically yield to another goroutine for execution
    if one of the following events occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: A `go` statement is encountered in the executing goroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A channel operation is encountered (channels are covered later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blocking system call (file or network IO for instance) is encountered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the completion of a garbage collection cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The scheduler will schedule a queued goroutines ready to enter execution when
    one of the previous events is encountered in a running goroutine. It is important
    to point out that the scheduler makes no guarantee of the order of execution of
    goroutines. When the following code snippet is executed, for instance, the output
    will be printed in an arbitrary order for each run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows possible output for the previous program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
