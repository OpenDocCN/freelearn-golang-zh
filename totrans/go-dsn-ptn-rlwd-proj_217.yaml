- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about concurrency, one of the natural concerns that arises is that
    of data safety and synchronization among concurrently executing code. If you have
    done concurrent programming in languages such as Java or C/C++, you are likely
    familiar with the, sometimes brittle, choreography required to ensure running
    threads can safely access shared memory values to achieve communication and synchronization
    between threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one area where Go diverges from its C lineage. Instead of having concurrent
    code communicate by using shared memory locations, Go uses channels as a conduit
    between running goroutines to communicate and share data. The blog post *Effective
    Go* ([https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html))
    has reduced this concept to the following slogan:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not communicate by sharing memory; instead, share memory by communicating.*'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of channel has its roots in **communicating sequential processes**
    (**CSP**), work done by renowned computer scientist C. A. Hoare, to model concurrency
    using communication primitives. As will be discussed in this section, channels
    provide the means to synchronize and safely communicate data between running goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses the Go channel type and provides insights into its characteristics.
    Later, you will learn how to use channels to craft concurrent programs.
  prefs: []
  type: TYPE_NORMAL
