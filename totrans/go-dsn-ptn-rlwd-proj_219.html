<html><head></head><body>
<div class="book" title="Channels">
<div class="book" title="Unbuffered channel"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec151" class="calibre1"/>Unbuffered channel</h2></div></div></div><p class="calibre10">When the <code class="email">make</code> function is invoked without the capacity argument, it returns a bidirectional <span class="strong"><em class="calibre11">unbuffered</em></span> channel. The following snippet shows the creation of an unbuffered channel of type <code class="email">chan int</code>:</p><pre class="programlisting">func main() { 
   ch := make(chan int) // unbuffered channel 
   ... 
} 
</pre><p class="calibre10">The characteristics of an unbuffered channel are illustrated in the following figure:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="Unbuffered channel" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">The sequence in the preceding figure (from left to right) shows how the unbuffered channel works:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If the channel is empty, the receiver blocks until there is data</li><li class="listitem">The sender can send only to an empty channel and blocks until the next receive operation</li><li class="listitem">When the channel has data, the receiver can proceed to receive the data.</li></ul></div><p class="calibre10">Sending to an unbuffered channel can easily cause a <span class="strong"><em class="calibre11">deadlock</em></span> if the operation is not wrapped in a goroutine. The following code will block after sending <code class="email">12</code> to the channel:</p><pre class="programlisting">func main() { 
   ch := make(chan int) 
   ch &lt;- 12 // blocks   
   fmt.Println(&lt;-ch) 
} 
</pre><p class="calibre10">golang.fyi/ch09/chan-unbuff0.go</p><p class="calibre10">When you run the previous program, you will get the following result:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go run chan-unbuff0.go</strong></span>
<span class="strong"><strong class="calibre2">fatal error: all goroutines are asleep - deadlock!</strong></span>
</pre><p class="calibre10">Recall that the sender blocks immediately upon sending to an unbuffered channel. This means any subsequent statement, to receive from the channel for instance, becomes unreachable, causing a deadlock. The following code shows the proper way to send to an unbuffered channel:</p><pre class="programlisting">func main() { 
   ch := make(chan int) 
   go func() { ch &lt;- 12 }() 
   fmt.Println(&lt;-ch) 
} 
</pre><p class="calibre10">golang.fyi/ch09/chan-unbuff1.go</p><p class="calibre10">Notice that the send operation is wrapped in an anonymous function invoked as a separate goroutine. This allows the <code class="email">main</code> function to reach the receive operation without blocking. As you will see later, this blocking property of unbuffered channels is used extensively as a synchronization and coordination idioms between goroutines.</p></div></div></body></html>