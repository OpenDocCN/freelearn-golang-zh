- en: Unbuffered channel
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无缓冲通道
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The characteristics of an unbuffered channel are illustrated in the following
    figure:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲通道的特性在以下图中得到说明：
- en: '![Unbuffered channel](img/00024.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![无缓冲通道](img/00024.jpeg)'
- en: 'The sequence in the preceding figure (from left to right) shows how the unbuffered
    channel works:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图（从左到右）的序列显示了无缓冲通道的工作方式：
- en: If the channel is empty, the receiver blocks until there is data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通道为空，接收者会阻塞，直到有数据到来
- en: The sender can send only to an empty channel and blocks until the next receive
    operation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者只能向空通道发送，并且会阻塞，直到下一个接收操作
- en: When the channel has data, the receiver can proceed to receive the data.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道中有数据时，接收者可以继续接收数据。
- en: 'Sending to an unbuffered channel can easily cause a *deadlock* if the operation
    is not wrapped in a goroutine. The following code will block after sending `12`
    to the channel:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作未在goroutine中封装，向无缓冲通道发送可能会轻易导致*死锁*。以下代码在向通道发送`12`后将会阻塞：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch09/chan-unbuff0.go
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan-unbuff0.go
- en: 'When you run the previous program, you will get the following result:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的程序时，你将得到以下结果：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Recall that the sender blocks immediately upon sending to an unbuffered channel.
    This means any subsequent statement, to receive from the channel for instance,
    becomes unreachable, causing a deadlock. The following code shows the proper way
    to send to an unbuffered channel:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，发送者发送到无缓冲通道后立即阻塞。这意味着任何后续的语句，例如从通道接收，都变得不可达，导致死锁。以下代码展示了向无缓冲通道发送的正确方式：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch09/chan-unbuff1.go
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan-unbuff1.go
- en: Notice that the send operation is wrapped in an anonymous function invoked as
    a separate goroutine. This allows the `main` function to reach the receive operation
    without blocking. As you will see later, this blocking property of unbuffered
    channels is used extensively as a synchronization and coordination idioms between
    goroutines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，发送操作被封装在一个匿名函数中，作为一个独立的goroutine调用。这允许`main`函数在不阻塞的情况下到达接收操作。正如你稍后将会看到的，无缓冲通道的这种阻塞特性被广泛用作goroutine之间的同步和协调惯用语。
