<html><head></head><body>
<div class="book" title="Channels">
<div class="book" title="Buffered channel"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec152" class="calibre1"/>Buffered channel</h2></div></div></div><p class="calibre10">When the <code class="email">make</code> function uses the capacity argument, it returns a bidirectional <span class="strong"><em class="calibre11">buffered</em></span> channel, as shown in the following snippet:</p><pre class="programlisting">func main 
   ch := make(chan int, 3) // buffered channel  
} 
</pre><p class="calibre10">The previous code will create a buffered channel with a capacity of <code class="email">3</code>. The buffered channel operates as a first-in-first-out blocking queue, as illustrated in the following figure:</p><div class="mediaobject"><img src="../images/00025.jpeg" alt="Buffered channel" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">The buffered channel depicted in the preceding figure has the following characteristics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When the channel is empty, the receiver blocks until there is at least one element</li><li class="listitem">The sender always succeeds as long as the channel is not at capacity</li><li class="listitem">When the channel is at capacity, the sender blocks until at least one element is received</li></ul></div><p class="calibre10">Using a buffered channel, it is possible to send and receive values within the same goroutine without causing a deadlock. The following shows an example of sending and receiving using a buffered channel with a capacity of <code class="email">4</code> elements:</p><pre class="programlisting">func main() { 
   ch := make(chan int, 4) 
   ch &lt;- 2 
   ch &lt;- 4 
   ch &lt;- 6 
   ch &lt;- 8 
 
   fmt.Println(&lt;-ch) 
   fmt.Println(&lt;-ch) 
   fmt.Println(&lt;-ch) 
   fmt.Println(&lt;-ch) 
    
} 
</pre><p class="calibre10">golang.fyi/ch09/chan0.go</p><p class="calibre10">The code in the previous example is able to send the values <code class="email">2</code>, <code class="email">4</code>, <code class="email">6</code>, and <code class="email">8</code> to the <code class="email">ch</code> channel without the risk of blocking. The four <code class="email">fmt.Println(&lt;-ch)</code> statements are used to receive the values buffered in the channel successively. However, if a fifth send operation is added, prior to the first receive, the code will deadlock as highlighted in the following snippet:</p><pre class="programlisting">func main() { 
   ch := make(chan int, 4) 
   ch &lt;- 2 
   ch &lt;- 4 
   ch &lt;- 6 
   ch &lt;- 8 
   ch &lt;- 10  
   fmt.Println(&lt;-ch) 
   ... 
} 
</pre><p class="calibre10">Later in the chapter, you will read more about idiomatic and safe ways to use channels for communications.</p></div></div></body></html>