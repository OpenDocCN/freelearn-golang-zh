- en: Buffered channel
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: 'When the `make` function uses the capacity argument, it returns a bidirectional
    *buffered* channel, as shown in the following snippet:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `make` 函数使用容量参数时，它返回一个双向的 *缓冲* 通道，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous code will create a buffered channel with a capacity of `3`. The
    buffered channel operates as a first-in-first-out blocking queue, as illustrated
    in the following figure:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将创建一个容量为 `3` 的缓冲通道。缓冲通道作为一个先进先出（FIFO）的阻塞队列，如下所示：
- en: '![Buffered channel](img/00025.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![缓冲通道](img/00025.jpeg)'
- en: 'The buffered channel depicted in the preceding figure has the following characteristics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 前图所示的缓冲通道具有以下特性：
- en: When the channel is empty, the receiver blocks until there is at least one element
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道为空时，接收者会阻塞，直到至少有一个元素
- en: The sender always succeeds as long as the channel is not at capacity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要通道未满，发送者总是成功
- en: When the channel is at capacity, the sender blocks until at least one element
    is received
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道满时，发送者会阻塞，直到至少接收到一个元素
- en: 'Using a buffered channel, it is possible to send and receive values within
    the same goroutine without causing a deadlock. The following shows an example
    of sending and receiving using a buffered channel with a capacity of `4` elements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓冲通道，可以在同一个goroutine中发送和接收值，而不会导致死锁。以下是一个使用容量为 `4` 元素的缓冲通道进行发送和接收的示例：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch09/chan0.go
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan0.go
- en: 'The code in the previous example is able to send the values `2`, `4`, `6`,
    and `8` to the `ch` channel without the risk of blocking. The four `fmt.Println(<-ch)`
    statements are used to receive the values buffered in the channel successively.
    However, if a fifth send operation is added, prior to the first receive, the code
    will deadlock as highlighted in the following snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的代码能够将值 `2`、`4`、`6` 和 `8` 发送到 `ch` 通道，而不会阻塞。四个 `fmt.Println(<-ch)` 语句用于依次接收通道中缓冲的值。然而，如果在第一次接收之前添加第五次发送操作，代码将如以下代码片段所示死锁：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Later in the chapter, you will read more about idiomatic and safe ways to use
    channels for communications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将了解到关于使用通道进行通信的惯用和安全的用法。
