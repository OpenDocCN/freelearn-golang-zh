<html><head></head><body>
<div class="book" title="Channels">
<div class="book" title="Unidirectional channels"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec153" class="calibre1"/>Unidirectional channels</h2></div></div></div><p class="calibre10">At declaration, a channel type may also include a unidirectional operator (using the <code class="email">&lt;- </code>arrow again) to indicate whether a channel is send-only or receive-only, as listed in the following table:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Declaration</strong></span></p>
</td><td class="calibre22">
<p class="calibre23"><span><strong class="calibre24">Operation</strong></span></p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><code class="literal">&lt;-</code>
<span><em class="calibre25"> chan &lt;element type&gt;</em></span></p>
</td><td class="calibre22">
<p class="calibre23">Declares a receive-only channel as shown later.
</p><pre class="programlisting1">var Ch &lt;-chan int</pre>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23"><span><em class="calibre25">chan </em></span><code class="literal">&lt;-</code><span><em class="calibre25">&lt;element type&gt;</em></span></p>
</td><td class="calibre22">
<p class="calibre23">Declares a send-only channel as shown later.
</p><pre class="programlisting1">var Ch &lt;-chan int</pre>
</td></tr></tbody></table></div><p class="calibre10">The following code snippet shows function <code class="email">makeEvenNums</code> with a send-only channel argument of type <code class="email">chan &lt;- int</code>:</p><pre class="programlisting">func main() { 
   ch := make(chan int, 10) 
   makeEvenNums(4, ch) 
 
   fmt.Println(&lt;-ch) 
   fmt.Println(&lt;-ch) 
   fmt.Println(&lt;-ch) 
   fmt.Println(&lt;-ch) 
} 
 
func makeEvenNums(count int, in chan&lt;- int) { 
   for i := 0; i &lt; count; i++ { 
         in &lt;- 2 * i 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch09/chan1.go</p><p class="calibre10">Since the directionality of the channel is baked in the type, access violations will be detected at compile time. So in the previous example, the <code class="email">in</code> channel can only be used for receive operations.</p><p class="calibre10">A bidirectional channel can be converted to a unidirectional channel explicitly or automatically. For instance, when <code class="email">makeEvenNums()</code> is called from <code class="email">main()</code>, it receives the bidirectional channel <code class="email">ch</code> as a parameter. The compiler automatically converts the channel to the appropriate type.</p></div></div></body></html>