<html><head></head><body>
<div class="book" title="Writing concurrent programs">
<div class="book" title="Synchronization"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec156" class="calibre1"/>Synchronization</h2></div></div></div><p class="calibre10">One of the primary uses of channels is synchronization between running goroutines. To illustrate this use case, let us examine the following code, which implements a word histogram. The program reads the words from the <code class="email">data</code> slice then, on a separate goroutine, collects the occurrence of each word:</p><pre class="programlisting">func main() { 
   data := []string{ 
         "The yellow fish swims slowly in the water", 
         "The brown dog barks loudly after a drink ...", 
         "The dark bird bird of prey lands on a small ...", 
   } 
 
   histogram := make(map[string]int) 
   done := make(chan bool) 
 
   // splits and count words 
   go func() { 
         for _, line := range data { 
               words := strings.Split(line, " ") 
               for _, word := range words { 
                     word = strings.ToLower(word) 
                     histogram[word]++ 
               } 
         } 
         done &lt;- true 
   }() 
 
   if &lt;-done { 
         for k, v := range histogram { 
               fmt.Printf("%s\t(%d)\n", k, v) 
         } 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch09/pattern0.go</p><p class="calibre10">The code in the previous example uses <code class="email">done := make(chan bool)</code> to create the channel that will be used to synchronize the two running goroutines in the program. The <code class="email">main</code> function launches a secondary goroutine, which does the word counting, and then it continues execution until it blocks at the <code class="email">&lt;-done</code> expression, causing it to wait.</p><p class="calibre10">In the meantime, the secondary goroutine runs until it completes its loop. Then, it sends a value to the <code class="email">done</code> channel with <code class="email">done &lt;- true</code>, causing the blocked <code class="email">main</code> routine to become unblocked and continues with its execution.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre10">The previous code has a bug that may cause a race condition. A correction will be introduced later in the chapter.</p></div><p class="calibre10">In the previous example, the code allocates and actually sends a Boolean value that is used for the synchronization. Upon further inspection, it is clear that the value in the channel is irrelevant and we simply want it to signal. So, we can further distill the synchronization idiom into a colloquial form that is presented in the following code snippet:</p><pre class="programlisting">func main() { 
... 
   histogram := make(map[string]int) 
   done := make(chan struct{}) 
 
   // splits and count 
   go func() { 
         defer close(done) // closes channel upon fn return 
         for _, line := range data { 
               words := strings.Split(line, " ") 
               for _, word := range words { 
                     word = strings.ToLower(word) 
                     histogram[word]++ 
               } 
         } 
   }() 
 
   &lt;-done // blocks until closed 
 
   for k, v := range histogram { 
         fmt.Printf("%s\t(%d)\n", k, v) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch09/pattern1.go</p><p class="calibre10">This version of the code achieves goroutine synchronization using:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The done channel, declared as type <code class="email">chan struct{}</code></li><li class="listitem">The main goroutine blocks at receive expression <code class="email">&lt;-done</code></li><li class="listitem">When the done channel is closed, all receivers succeed without blocking</li></ul></div><p class="calibre10">Although the signaling is done using different constructs, this version of the code is equivalent to the first version (<code class="email">pattern0.go</code>). The emtpy <code class="email">struct{}</code> type stores no value and it is used strictly for signaling. This version of the code closes the <code class="email">done</code> channel (instead of sending a value). This has the effect of allowing the main goroutine to unblock and continue execution.</p></div></div></body></html>