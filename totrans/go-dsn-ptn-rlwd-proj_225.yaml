- en: Synchronization
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步
- en: 'One of the primary uses of channels is synchronization between running goroutines.
    To illustrate this use case, let us examine the following code, which implements
    a word histogram. The program reads the words from the `data` slice then, on a
    separate goroutine, collects the occurrence of each word:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: channels的主要用途之一是在运行的goroutines之间进行同步。为了说明这一用法，让我们检查以下代码，该代码实现了一个单词直方图。程序从`data`切片中读取单词，然后在单独的goroutine中收集每个单词的出现次数：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch09/pattern0.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern0.go
- en: The code in the previous example uses `done := make(chan bool)` to create the
    channel that will be used to synchronize the two running goroutines in the program.
    The `main` function launches a secondary goroutine, which does the word counting,
    and then it continues execution until it blocks at the `<-done` expression, causing
    it to wait.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子中使用`done := make(chan bool)`创建了一个将用于同步程序中两个运行goroutines的通道。`main`函数启动一个次要goroutine，执行单词计数，然后它继续执行，直到在`<-done`表达式处阻塞，导致它等待。
- en: In the meantime, the secondary goroutine runs until it completes its loop. Then,
    it sends a value to the `done` channel with `done <- true`, causing the blocked
    `main` routine to become unblocked and continues with its execution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，次要的goroutine会一直运行直到它完成其循环。然后，它通过`done <- true`向`done`通道发送一个值，导致阻塞的`main`程序变为非阻塞状态并继续执行。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The previous code has a bug that may cause a race condition. A correction will
    be introduced later in the chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码有一个可能导致竞态条件的bug。在章节的后面将引入一个修正。
- en: 'In the previous example, the code allocates and actually sends a Boolean value
    that is used for the synchronization. Upon further inspection, it is clear that
    the value in the channel is irrelevant and we simply want it to signal. So, we
    can further distill the synchronization idiom into a colloquial form that is presented
    in the following code snippet:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，代码分配并发送了一个用于同步的布尔值。经过进一步检查，很明显通道中的值是无关紧要的，我们只想用它来发出信号。因此，我们可以进一步提炼同步习语，以以下代码片段中的口语形式呈现：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch09/pattern1.go
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern1.go
- en: 'This version of the code achieves goroutine synchronization using:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本的代码使用以下方式实现goroutine同步：
- en: The done channel, declared as type `chan struct{}`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明为`chan struct{}`类型的`done`通道
- en: The main goroutine blocks at receive expression `<-done`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`goroutine在接收表达式`<-done`处阻塞'
- en: When the done channel is closed, all receivers succeed without blocking
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`done`通道关闭时，所有接收者都能成功接收而不会阻塞。
- en: Although the signaling is done using different constructs, this version of the
    code is equivalent to the first version (`pattern0.go`). The emtpy `struct{}`
    type stores no value and it is used strictly for signaling. This version of the
    code closes the `done` channel (instead of sending a value). This has the effect
    of allowing the main goroutine to unblock and continue execution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用不同的结构进行信号，但此版本的代码与第一个版本（`pattern0.go`）等效。空的`struct{}`类型不存储任何值，它仅用于信号。此版本的代码关闭了`done`通道（而不是发送一个值）。这允许`main`goroutine解除阻塞并继续执行。
