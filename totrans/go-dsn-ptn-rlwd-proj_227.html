<html><head></head><body>
<div class="book" title="Writing concurrent programs">
<div class="book" title="Using for…range to receive data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec158" class="calibre1"/>Using for…range to receive data</h2></div></div></div><p class="calibre10">The previous pattern is so common in Go that the idiom is built into the language in the form of the following <code class="email">for…range</code> statement:</p><p class="calibre10"><span class="strong"><em class="calibre11">for &lt;elemem&gt; := range &lt;channel&gt;{...}</em></span></p><p class="calibre10">With each iteration, this <code class="email">for…range</code> statement will block until it receives incoming data from the indicated channel, as shown in the following snippet:</p><pre class="programlisting">func main(){                           
... 
   go func() { 
         defer close(wordsCh) 
         for _, line := range data { 
               words := strings.Split(line, " ") 
               for _, word := range words { 
                     word = strings.ToLower(word) 
                     wordsCh &lt;- word 
               } 
         } 
   }() 
 
   for word := range wordsCh { 
         histogram[word]++ 
   } 
... 
} 
</pre><p class="calibre10">golang.fyi/ch09/pattern3.go</p><p class="calibre10">The previous code shows the an updated version of the code using a for-range statement, <code class="email">for word := range wordsCh</code>. It successively emits the received value from the <code class="email">wordsCh</code> channel. When the channel is closed (from the goroutine), the loop automatically breaks.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre10">Always remember to close the channel so receivers are signaled properly. Otherwise, the program may enter into a deadlock which could cause a panic.</p></div></div></div></body></html>