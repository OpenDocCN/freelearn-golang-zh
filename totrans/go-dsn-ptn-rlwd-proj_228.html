<html><head></head><body>
<div class="book" title="Writing concurrent programs">
<div class="book" title="Generator functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec159" class="calibre1"/>Generator functions</h2></div></div></div><p class="calibre10">Channels and goroutines provide a natural substrate for implementing a form of producer/producer pattern using generator functions. In this approach, a goroutine is wrapped in a function which generates values that are sent via a channel returned by the function. The consumer goroutine receives these values as they are generated.</p><p class="calibre10">The word histogram has been updated to use this pattern, as shown in the following code snippet:</p><pre class="programlisting">func main() { 
   data := []string{"The yellow fish swims...", ...} 
   histogram := make(map[string]int) 
 
   words := words(data) // returns handle to data channel 
   for word := range words { 
         histogram[word]++ 
   } 
... 
} 
 
// generator function that produces data 
func words(data []string) &lt;-chan string { 
   out := make(chan string) 
   go func() { 
         defer close(out) // closes channel upon fn return 
         for _, line := range data { 
               words := strings.Split(line, " ") 
               for _, word := range words { 
                     word = strings.ToLower(word) 
                     out &lt;- word 
               } 
         } 
   }() 
   return out 
} 
</pre><p class="calibre10">golang.fyi/ch09/pattern4.go</p><p class="calibre10">In this example, the generator function, declared as <code class="email">func words(data []string) &lt;-chan string</code>, returns a receive-only channel of string elements. The consumer function, in this instance <code class="email">main()</code>, receives the data emitted by the generator function, which is processed using a <code class="email">forâ€¦range</code> loop.</p></div></div></body></html>