["```go\nselect statement. The generator function words select between two channels, out to send data as before and a new channel stopCh, passed as a parameter, which is used to detect an interruption signal to stop sending data:\n```", "```go\nfunc main() { \n... \n   histogram := make(map[string]int) \n   stopCh := make(chan struct{}) // used to signal stop \n\n   words := words(stopCh, data) // returns handle to channel \n   for word := range words { \n         if histogram[\"the\"] == 3 { \n               close(stopCh) \n         } \n         histogram[word]++ \n   } \n... \n} \n\nfunc words(stopCh chan struct{}, data []string) <-chan string { \n   out := make(chan string) \n   go func() { \n         defer close(out) // closes channel upon fn return \n         for _, line := range data { \n               words := strings.Split(line, \" \") \n               for _, word := range words { \n                     word = strings.ToLower(word) \n                     select { \n                     case out <- word: \n                     case <-stopCh: // succeeds first when close \n                         return \n                     } \n               } \n         } \n   }() \n   return out \n} \n\nwords generator function will select the first communication operation that succeeds: out <- word or <-stopCh. As long as the consumer code in main() continues to receive from the out channel, the send operation will succeed first. Notice, however, the code in main() closes the stopCh channel when it encounters the third instance of \"the\". When that happens, it will cause the receive case, in the select statement, to proceed first causing the goroutine to return.\n```"]