["```go\npackage barrier \n\nimport ( \n    \"bytes\" \n    \"io\" \n    \"os\" \n    \"strings\" \n    \"testing\" \n) \n\nfunc TestBarrier(t *testing.T) { \n  t.Run(\"Correct endpoints\", func(t *testing.T) { \n    endpoints := []string{\"http://httpbin.org/headers\",  \"http://httpbin.org/User-Agent\"\n    } \n  }) \n\n  t.Run(\"One endpoint incorrect\", func(t *testing.T) { \n    endpoints := []string{\"http://malformed-url\",  \"http://httpbin.org/User-Agent\"} \n  }) \n\n  t.Run(\"Very short timeout\", func(t *testing.T) { \n    endpoints := []string{\"http://httpbin.org/headers\",  \"http://httpbin.org/User-Agent\"} \n  }) \n} \n\n```", "```go\nfunc barrier(endpoints ...string) {} \n\n```", "```go\nfunc captureBarrierOutput(endpoints ...string) string { \n    reader, writer, _ := os.Pipe() \n\n    os.Stdout = writer \n    out := make(chan string) \n\n    go func() { \n      var buf bytes.Buffer \n      io.Copy(&buf, reader) \n      out <- buf.String() \n    }() \n\n    barrier(endpoints...) \n\n    writer.Close() \n    temp := <-out \n\n    return temp \n} \n\n```", "```go\nt.Run(\"Correct endpoints\", func(t *testing.T) { \n    endpoints := []string{\"http://httpbin.org/headers\", \"http://httpbin.org/User-Agent\"\n    } \n\n result := captureBarrierOutput(endpoints...)\n if !strings.Contains(result, \"Accept-Encoding\") || strings.Contains (result, \"User-Agent\") \n  {\n t.Fail()\n }\n t.Log(result) \n}) \n\n```", "```go\nt.Run(\"One endpoint incorrect\", func(t *testing.T) { \n  endpoints := []string\n  {\n    \"http://malformed-url\", \"http://httpbin.org/User-Agent\"} \n\n result := captureBarrierOutput(endpoints...)\n if !strings.Contains(result, \"ERROR\") {\n t.Fail()\n }\n t.Log(result) \n}) \n\n```", "```go\nt.Run(\"Very short timeout\", func(t *testing.T) { \n  endpoints := []string\n  {\n    \"http://httpbin.org/headers\", \"http://httpbin.org/User-Agent\"} \n timeoutMilliseconds = 1\n result := captureBarrierOutput(endpoints...)\n if !strings.Contains(result, \"Timeout\") {\n t.Fail()\n }\n t.Log(result) \n  }) \n\n```", "```go\npackage barrier \n\nimport ( \n    \"fmt\" \n    \"io/ioutil\" \n    \"net/http\" \n    \"time\" \n) \n\nvar timeoutMilliseconds int = 5000 \n\n```", "```go\ntype barrierResp struct { \n    Err  error \n    Resp string \n} \n\n```", "```go\nfunc barrier(endpoints ...string) { \n    requestNumber := len(endpoints) \n\n    in := make(chan barrierResp, requestNumber) \n    defer close(in) \n\n    responses := make([]barrierResp, requestNumber) \n\n    for _, endpoint := range endpoints { \n        go makeRequest(in, endpoint) \n    } \n\n    var hasError bool \n    for i := 0; i < requestNumber; i++ { \n        resp := <-in \n        if resp.Err != nil { \n            fmt.Println(\"ERROR: \", resp.Err) \n            hasError = true \n        } \n        responses[i] = resp \n    } \n\n    if !hasError { \n        for _, resp := range responses { \n            fmt.Println(resp.Resp) \n        } \n    } \n} \n\n```", "```go\nfunc makeRequest(out chan<- barrierResp, url string) { \n    res := barrierResp{} \n    client := http.Client{ \n        Timeout: time.Duration(time.Duration(timeoutMilliseconds) * time.Millisecond), \n    } \n\n    resp, err := client.Get(url) \n    if err != nil { \n        res.Err = err \n        out <- res \n        return \n    } \n\n    byt, err := ioutil.ReadAll(resp.Body) \n    if err != nil { \n        res.Err = err \n        out <- res \n        return \n    } \n\n    res.Resp = string(byt) \n    out <- res \n} \n\n```", "```go\ngo test -run=TestBarrier/Correct_endpoints -v .\n=== RUN   TestBarrier\n=== RUN   TestBarrier/Correct_endpoints\n--- PASS: TestBarrier (0.54s)\n --- PASS: TestBarrier/Correct_endpoints (0.54s)\n barrier_test.go:20: {\n \"headers\": {\n \"Accept-Encoding\": \"gzip\", \n\"Host\": \"httpbin.org\",\n\"User-Agent\": \"Go-http-client/1.1\"\n }\n }\n {\n \"User-Agent\": \"Go-http-client/1.1\"\n } \n ok\n\n```", "```go\ngo test -run=TestBarrier/One_endpoint_incorrect -v .\n=== RUN   TestBarrier\n=== RUN   TestBarrier/One_endpoint_incorrect\n--- PASS: TestBarrier (0.27s)\n --- PASS: TestBarrier/One_endpoint_incorrect (0.27s)\n barrier_test.go:31: ERROR:  Get http://malformed-url: dial tcp: lookup malformed-url: no such host\nok\n\n```", "```go\ngo test -run=TestBarrier/Very_short_timeout -v .     \n=== RUN   TestBarrier \n=== RUN   TestBarrier/Very_short_timeout \n--- PASS: TestBarrier (0.00s) \n    --- PASS: TestBarrier/Very_short_timeout (0.00s) \n        barrier_test.go:43: ERROR:  Get http://httpbin.org/User-Agent: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) \n        ERROR:  Get http://httpbin.org/headers: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) \n\nok\n\n```", "```go\ntype MaybeString struct {} \n\n```", "```go\npackage future \n\nimport ( \n  \"errors\" \n  \"testing\" \n  \"sync\" \n) \n\nfunc TestStringOrError_Execute(t *testing.T) { \n  future := &MaybeString{} \n  t.Run(\"Success result\", func(t *testing.T) { \n    ... \n  }) \n  t.Run(\"Error result\", func(t *testing.T) { \n  ... \n  }) \n} \n\n```", "```go\nt.Run(\"Success result\", func(t *testing.T) { \n future.Success(func(s string) {\n t.Log(s)\n }).Fail(func(e error) {\n t.Fail()\n })\n future.Execute(func() (string, error) {\n return \"Hello World!\", nil\n }) \n}) \n\n```", "```go\nt.Run(\"Success result\", func(t *testing.T) { \n var wg sync.WaitGroup\n wg.Add(1) \n    future.Success(func(s string) { \n      t.Log(s) \n\n wg.Done() \n    }).Fail(func(e error) { \n      t.Fail() \n\n wg.Done() \n    }) \n\n    future.Execute(func() (string, error) { \n      return \"Hello World!\", nil \n    }) \n wg.Wait() \n  }) \n\n```", "```go\nt.Run(\"Failed result\", func(t *testing.T) { \n var wg sync.WaitGroup\n wg.Add(1)\n future.Success(func(s string) {\n t.Fail()\n wg.Done()\n }).Fail(func(e error) {\n t.Log(e.Error())\n wg.Done()\n })\n future.Execute(func() (string, error) {\n return \"\", errors.New(\"Error ocurred\")\n })\n wg.Wait() \n}) \n\n```", "```go\npackage future \n\ntype SuccessFunc func(string) \ntype FailFunc func(error) \ntype ExecuteStringFunc func() (string, error) \n\ntype MaybeString struct { \n  ... \n} \n\nfunc (s *MaybeString) Success(f SuccessFunc) *MaybeString { \n  return nil \n} \n\nfunc (s *MaybeString) Fail(f FailFunc) *MaybeString { \n  return nil \n} \n\nfunc (s *MaybeString) Execute(f ExecuteStringFunc) { \n  ... \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestStringOrError_Execute\n=== RUN   TestStringOrError_Execute/Success_result\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan receive]:\ntesting.(*T).Run(0xc4200780c0, 0x5122e9, 0x19, 0x51d750, 0xc420041d30)\n /usr/lib/go/src/testing/testing.go:647 +0x316\ntesting.RunTests.func1(0xc4200780c0)\n /usr/lib/go/src/testing/testing.go:793 +0x6d\ntesting.tRunner(0xc4200780c0, 0xc420041e20)\n /usr/lib/go/src/testing/testing.go:610 +0x81\ntesting.RunTests(0x51d758, 0x5931e0, 0x1, 0x1, 0x50feb4)\n /usr/lib/go/src/testing/testing.go:799 +0x2f5\ntesting.(*M).Run(0xc420041ee8, 0xc420014550)\n /usr/lib/go/src/testing/testing.go:743 +0x85\nmain.main()\n go-design-patterns/future/_test/_testmain.go:54 +0xc6\n...continue\n\n```", "```go\nfunc timeout(t *testing.T, wg *sync.WaitGroup) { \n  time.Sleep(time.Second) \n  t.Log(\"Timeout!\") \n\n  t.Fail() \n  wg.Done() \n} \n\n```", "```go\nt.Run(\"Success result\", func(t *testing.T) { \n  var wg sync.WaitGroup \n  wg.Add(1) \n\n  //Timeout! \n  go timeout(t, wg) \n  // ... \n}) \n\n```", "```go\ngo test -v .\n=== RUN   TestStringOrError_Execute\n=== RUN   TestStringOrError_Execute/Success_result\n=== RUN   TestStringOrError_Execute/Failed_result\n--- FAIL: TestStringOrError_Execute (2.00s)\n --- FAIL: TestStringOrError_Execute/Success_result (1.00s)\n future_test.go:64: Timeout!\n --- FAIL: TestStringOrError_Execute/Failed_result (1.00s)\n future_test.go:64: Timeout!\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype MaybeString struct { \n  successFunc SuccessFunc \n  failFunc    FailFunc \n} \n\nfunc (s *MaybeString) Success(f SuccessFunc) *MaybeString { \n  s.successFunc = f \n  return s \n} \n\nfunc (s *MaybeString) Fail(f FailFunc) *MaybeString { \n  s.failFunc = f \n  return s \n} \n\n```", "```go\nfunc (s *MaybeString) Execute(f ExecuteStringFunc) { \n  go func(s *MaybeString) { \n    str, err := f() \n    if err != nil { \n      s.failFunc(err) \n    } else { \n      s.successFunc(str) \n    } \n  }(s) \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestStringOrError_Execute\n=== RUN   TestStringOrError_Execute/Success_result\n=== RUN   TestStringOrError_Execute/Failed_result\n--- PASS: TestStringOrError_Execute (0.00s)\n --- PASS: TestStringOrError_Execute/Success_result (0.00s)\n future_test.go:21: Hello World!\n --- PASS: TestStringOrError_Execute/Failed_result (0.00s)\n future_test.go:49: Error ocurred\nPASS\nok \n\n```", "```go\nfunc setContext(msg string) ExecuteStringFunc { \n  msg = fmt.Sprintf(\"%d Closure!\\n\", msg) \n\n  return func() (string, error){ \n    return msg, nil \n  } \n} \n\n```", "```go\nt.Run(\"Closure Success result\", func(t *testing.T) { \n    var wg sync.WaitGroup \n    wg.Add(1) \n    //Timeout! \n    go timeout(t, &wg) \n\n    future.Success(func(s string) { \n      t.Log(s) \n      wg.Done() \n    }).Fail(func(e error) { \n      t.Fail() \n      wg.Done() \n    }) \n    future.Execute(setContext(\"Hello\")) \n    wg.Wait() \n  }) \n\n```", "```go\ngo test -v .\n=== RUN   TestStringOrError_Execute\n=== RUN   TestStringOrError_Execute/Success_result\n=== RUN   TestStringOrError_Execute/Failed_result\n=== RUN   TestStringOrError_Execute/Closure_Success_result\n--- PASS: TestStringOrError_Execute (0.00s)\n --- PASS: TestStringOrError_Execute/Success_result (0.00s)\n future_test.go:21: Hello World!\n --- PASS: TestStringOrError_Execute/Failed_result (0.00s)\n future_test.go:49: Error ocurred\n --- PASS: TestStringOrError_Execute/Closure_Success_result (0.00s)\n future_test.go:69: Hello Closure!\nPASS\nok\n\n```", "```go\npackage pipelines \n\nfunc LaunchPipeline(amount int) int { \n  return 0 \n} \n\n```", "```go\npackage pipelines \n\nimport \"testing\" \n\nfunc TestLaunchPipeline(t *testing.T) { \n  tableTest := [][]int{ \n    {3, 14}, \n    {5, 55}, \n  } \n  // ... \n} \n\n```", "```go\n  // ... \n\n  var res int \n  for _, test := range tableTest { \n    res = LaunchPipeline(test[0]) \n    if res != test[1] { \n      t.Fatal() \n    } \n\n    t.Logf(\"%d == %d\\n\", res, test[1]) \n  } \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestLaunchPipeline\n--- FAIL: TestLaunchPipeline (0.00s)\n pipeline_test.go:15: \nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc functionName(in <-chan int) (<-chan int){ \n  out := make(chan bool, 100) \n\n  go func(){ \n    for v := range in { \n      // Do something with v and send it to channel out \n} \n\nclose(out) \n   }() \n\n  return out \n} \n\n```", "```go\nfunc generator(max int) <-chan int { \n  outChInt := make(chan int, 100) \n\n  go func() { \n    for i := 1; i <= max; i++ { \n      outChInt <- i \n    } \n\n    close(outChInt) \n  }() \n  return outChInt \n} \n\n```", "```go\nfunc power(in <-chan int) <-chan int { \n  out := make(chan int, 100) \n\n  go func() { \n    for v := range in { \n      out <- v * v \n    } \n    close(out) \n  }() \n  return out \n} \n\n```", "```go\nfunc sum(in <-chan int) <-chan int { \n  out := make(chan int, 100) \n  go func() { \n    var sum int \n\n    for v := range in { \n      sum += v \n    } \n\n    out <- sum \n    close(out) \n  }()\n\n  return out \n} \n\n```", "```go\nfunc LaunchPipeline(amount int) int { \n  firstCh := generator(amount) \n  secondCh := power(firstCh) \n  thirdCh := sum(secondCh) \n\n  result := <-thirdCh \n\n  return result \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestLaunchPipeline\n--- PASS: TestLaunchPipeline (0.00s)\n pipeline_test.go:18: 14 == 14\n pipeline_test.go:18: 55 == 55\nPASS\nok\n\n```", "```go\nfunc LaunchPipeline(amount int) int { \n  return <-sum(power(generator(amount))) \n} \n\n```"]