- en: Chapter 9. Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 并发模式 - 障碍、未来和管道设计模式
- en: 'Now that we are familiar with the concepts of concurrency and parallelism,
    and we have understood how to achieve them by using Go''s concurrency primitives,
    we can see some patterns regarding concurrent work and parallel execution. In
    this chapter we''ll see the following patterns:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了并发和并行性的概念，并且我们已经理解了如何通过使用Go的并发原语来实现它们，我们可以看到一些关于并发工作和并行执行的模式。在本章中，我们将看到以下模式：
- en: Barrier is a very common pattern, especially when we have to wait for more than
    one response from different Goroutines before letting the program continue
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 障碍是一个非常常见的模式，尤其是在我们需要等待多个Goroutine的响应后才能让程序继续之前
- en: Future pattern allows us to write an algorithm that will be executed eventually
    in time (or not) by the same Goroutine or a different one
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来模式允许我们编写一个算法，该算法最终（或不会）由同一个Goroutine或不同的Goroutine执行
- en: Pipeline is a powerful pattern to build complex synchronous flows of Goroutines
    that are connected with each other according to some logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道是一个强大的模式，用于构建复杂的同步Goroutine流，这些Goroutine根据某种逻辑相互连接
- en: Take a quick look at the description of the three patterns. They all describe
    some sort of logic to synchronize execution in time. It's very important to keep
    in mind that we are now developing concurrent structures with all the tools and
    patterns we have seen in the previous chapters. With Creational patterns we were
    dealing with creating objects. With the Structural patterns we were learning how
    to build idiomatic structures and in Behavioral patterns we were managing mostly
    with algorithms. Now, with Concurrency patterns, we will mostly manage the timing
    execution and order execution of applications that has more than one *flow*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览一下这三种模式的描述。它们都描述了某种逻辑，用于在时间上同步执行。记住，我们现在正在使用前几章中看到的所有工具和模式来开发并发结构。在使用创建型模式时，我们处理的是对象的创建。在使用结构型模式时，我们学习如何构建惯用的结构，而在行为模式中，我们主要使用算法进行管理。现在，在并发模式中，我们将主要管理具有多个
    *流程* 的应用程序的定时执行和顺序执行。
- en: Barrier concurrency pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 障碍并发模式
- en: We are going to start with the Barrier pattern. Its purpose is simple--put up
    a barrier so that nobody passes until we have all the results we need, something
    quite common in concurrent applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从障碍模式开始。其目的是简单的——设置一个障碍，直到我们得到所有需要的结果，这在并发应用程序中相当常见。
- en: Description
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: Imagine the situation where we have a microservices application where one service
    needs to compose its response by merging the responses of another three microservices.
    This is where the Barrier pattern can help us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这种情况，我们有一个微服务应用程序，其中一个服务需要通过合并其他三个微服务的响应来组合其响应。这就是障碍模式可以帮助我们的地方。
- en: Our Barrier pattern could be a service that will block its response until it
    has been composed with the results returned by one or more different Goroutines
    (or services). And what kind of primitive do we have that has a blocking nature?
    Well, we can use a lock, but it's more idiomatic in Go to use an unbuffered channel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的障碍模式可能是一个服务，它将阻塞其响应，直到它已经与一个或多个不同的Goroutine（或服务）返回的结果组合。那么我们有什么具有阻塞性质的原始类型呢？嗯，我们可以使用一个锁，但在Go中更惯用使用无缓冲通道。
- en: Objectives
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'As its name implies, the Barrier pattern tries to stop an execution so it doesn''t
    finish before it''s ready to finish. The Barrier pattern''s objectives are as
    follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，障碍模式试图阻止执行，直到它准备好完成。障碍模式的目标如下：
- en: Compose the value of a type with the data coming from one or more Goroutines.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型值与来自一个或多个Goroutine的数据组合。
- en: Control the correctness of any of those incoming data pipes so that no inconsistent
    data is returned. We don't want a partially filled result because one of the pipes
    has returned an error.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制任何传入数据管道的正确性，以确保不会返回不一致的数据。我们不希望得到一个部分填充的结果，因为其中一个管道返回了错误。
- en: An HTTP GET aggregator
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个HTTP GET聚合器
- en: For our example, we are going to write a very typical situation in a microservices
    application-an app that performs two HTTP `GET` calls and joins them in a single
    response that will be printed on the console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将编写一个在微服务应用程序中非常典型的情况——一个执行两个HTTP `GET`调用并将它们合并成一个单独的响应，该响应将在控制台上打印的应用程序。
- en: Our small app must perform each request in a different Goroutine and print the
    result on the console if both responses are correct. If any of them returns an
    error, then we print just the error.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小应用程序必须以不同的Goroutine执行每个请求，并在控制台上打印结果，如果两个响应都是正确的。如果任何一个返回错误，那么我们只打印错误。
- en: 'The design must be concurrent, allowing us to take advantage of our multicore
    CPUs to make the calls in parallel:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计必须是并发的，这样我们就可以利用我们的多核CPU并行进行调用：
- en: '![An HTTP GET aggregator](img/00039.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![一个HTTP GET聚合器](img/00039.jpeg)'
- en: In the preceding diagram, the solid lines represent calls and the dashed lines
    represent channels. The balloons are Goroutines, so we have two Goroutines launched
    by the `main` function (which could also be considered a Goroutine). These two
    functions will communicate back to the `main` function by using a **common channel**
    that they received when they were created on the `makeRequest` calls.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，实线代表调用，虚线代表通道。气球是Goroutine，所以我们有两个由`main`函数（这也可以被认为是一个Goroutine）启动的Goroutine。这两个函数将通过它们在`makeRequest`调用时接收到的**公共通道**与`main`函数通信。
- en: Acceptance criteria
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'Our main objective in this app is to get a merged response of two different
    calls, so we can describe our acceptance criteria like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们的主要目标是获取两个不同调用的合并响应，因此我们可以这样描述我们的验收标准：
- en: Print on the console the merged result of the two calls to `http://httpbin.org/headers`
    and `http://httpbin.org/User-Agent` URLs. These are a couple of public endpoints
    that respond with data from the incoming connections. They are very popular for
    testing purposes. You will need an internet connection to do this exercise.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台上打印对`http://httpbin.org/headers`和`http://httpbin.org/User-Agent` URL的两个调用的合并结果。这些是一些公共端点，它们响应来自传入连接的数据。它们在测试目的上非常受欢迎。您需要互联网连接来完成这个练习。
- en: If any of the calls fails, it must not print any result-just the error message
    (or error messages if both calls failed).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个调用失败，则不能打印任何结果——只打印错误消息（如果两个调用都失败了，则打印错误消息）。
- en: The output must be printed as a composed result when both calls have finished.
    It means that we cannot print the result of one call and then the other.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个调用都完成时，输出必须打印为一个组合结果。这意味着我们不能先打印一个调用的结果，然后再打印另一个调用的结果。
- en: Unit test - integration
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试 - 集成测试
- en: 'To write unit or integration tests for concurrent designs can sometimes be
    tricky, but this won''t stop us from writing our awesome unit tests. We will have
    a single `barrier` method that accepts a set of endpoints defined as a `string`
    type. The barrier will make a `GET` request to each endpoint and compose the result
    before printing it out. In this case, we will write three integration tests to
    simplify our code so we don''t need to generate mock responses:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为并发设计编写单元测试或集成测试有时可能很棘手，但这不会阻止我们编写我们出色的单元测试。我们将有一个单独的`barrier`方法，它接受一组定义为`string`类型的端点。屏障将对每个端点进行`GET`请求，并在打印之前组合结果。在这种情况下，我们将编写三个集成测试来简化我们的代码，这样我们就不需要生成模拟响应：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have a single test that will execute three subtests:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单独的测试，将执行三个子测试：
- en: The first test makes two calls to the correct endpoints
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次测试是对正确的端点进行两次调用
- en: The second test will have an incorrect endpoint, so it must return an error
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次测试将有一个错误的端点，因此它必须返回一个错误
- en: The last test will return the maximum timeout time so that we can force a timeout
    error
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一次测试将返回最大超时时间，这样我们就可以强制一个超时错误
- en: 'We will have a function called `barrier` that will accept an undetermined number
    of endpoints in the form of strings. Its signature could be like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个名为`barrier`的函数，它将接受字符串形式的未确定数量的端点。它的签名可能如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the `barrier` function doesn''t return any value because its
    result will be printed on the console. Previously, we have written an implementation
    of an `io.Writer` interface to emulate the writing on the operating system''s
    `stdout` library. Just to change things a bit, we will capture the `stdout` library
    instead of emulating one. The process to capture the `stdout` library isn''t difficult
    once you understand concurrency primitives in Go:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`barrier`函数不返回任何值，因为它的结果将在控制台上打印。之前，我们已经编写了一个`io.Writer`接口的实现来模拟操作系统`stdout`库的写入。为了改变一下，我们将捕获`stdout`库而不是模拟一个。一旦您理解了Go中的并发原语，捕获`stdout`库的过程并不困难：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't feel daunted by this code; it's really simple. First we created a pipe;
    we have done this before in [Chapter 3](part0117_split_000.html#3FIHQ2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 3. Structural Patterns - Composite, Adapter, and Bridge Design Patterns"),
    *Structural Patterns - Adapter, Bridge, and Composite Design Patterns*, when we
    talked about the Adapter design pattern. To recall, a pipe allows us to connect
    an `io.Writer` interface to an `io.Reader` interface so that the reader input
    is the `Writer` output. We define the `os.Stdout` as the writer. Then, to capture
    `stdout` output, we will need a different Goroutine that listens while we write
    to the console. As you know, if we write, we don't capture, and if we capture,
    we are not writing. The keyword here is `while`; it is a good rule of thumb that
    if you find this word in some definition, you'll probably need a concurrent structure.
    So we use the `go` keyword to launch a different Goroutine that copies reader
    input to a bytes buffer before sending the contents of the buffer through a channel
    (that we should have previously created).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这段代码吓倒；它实际上非常简单。首先我们创建了一个管道；我们之前在 [第3章](part0117_split_000.html#3FIHQ2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第3章。结构型模式 - 组合、适配器和桥接设计模式") 中做过，*结构型模式 - 适配器、桥接和组合设计模式*，当我们讨论适配器设计模式时。为了回忆，管道允许我们将
    `io.Writer` 接口连接到 `io.Reader` 接口，以便读者的输入是 `Writer` 的输出。我们将 `os.Stdout` 定义为写入者。然后，为了捕获
    `stdout` 输出，我们需要一个不同的 Goroutine，它在我们在控制台写入时监听。正如你所知，如果我们写入，我们不会捕获，如果我们捕获，我们就不会写入。这里的关键字是
    `while`；如果你在某个定义中找到这个单词，那么你可能需要一个并发结构。所以我们使用 `go` 关键字启动一个不同的 Goroutine，在将缓冲区的内容通过通道发送之前，将读取器的输入复制到一个字节缓冲区中（我们应该之前创建这个通道）。
- en: At this point, we have a listening Goroutine, but we haven't printed anything
    yet, so we call our (not yet written) function `barrier` with the provided endpoints.
    Next, we have to close the writer to signal the Goroutine that no more input is
    going to come to it. Our channel called out blocks execution until some value
    is received (the one sent by our launched Goroutine). The last step is to return
    the contents captured from the console.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个监听 Goroutine，但我们还没有打印任何内容，所以我们调用提供的（尚未编写的）函数 `barrier`。接下来，我们必须关闭写入者，以向
    Goroutine 发送信号，表示不再有输入将发送给它。我们称为 `out` 的通道阻塞执行，直到接收到某个值（由我们启动的 Goroutine 发送的值）。最后一步是返回从控制台捕获的内容。
- en: 'OK, so we have a function called `captureBarrierOutput` that will capture the
    outputs in `stdout` and return them as a string. We can write our tests now:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有一个名为 `captureBarrierOutput` 的函数，它将捕获 `stdout` 中的输出并将它们作为字符串返回。我们现在可以编写测试了：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All the tests are very easy to implement. All in all, it is the `captureBarrierOutput`
    function that calls the `barrier` function. So we pass the endpoints and check
    the returned result. Our composed response directed to [http://httpbin.org](http://httpbin.org)
    must contain the text *Accept-Encoding* and *User-Agent* in the responses of each
    endpoint. If we don''t find those texts, the test will fail. For debugging purposes,
    we log the response in case we want to check it with the `-v` flag on the go test:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都非常容易实现。总的来说，是 `captureBarrierOutput` 函数调用了 `barrier` 函数。因此，我们传递端点并检查返回的结果。我们指向
    [http://httpbin.org](http://httpbin.org) 的组合响应必须在每个端点的响应中包含文本 *Accept-Encoding*
    和 *User-Agent*。如果我们找不到这些文本，测试将失败。为了调试目的，我们记录响应，以便我们可以在 go test 的 `-v` 标志下检查它：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time we used an incorrect endpoint URL, so the response must return the
    error prefixed with the word *ERROR* that we will write ourselves in the `barrier`
    function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了错误的端点URL，因此响应必须返回一个以单词 *ERROR* 开头的错误，这个错误我们将自己在 `barrier` 函数中编写。
- en: 'The last function will reduce the timeout of the HTTP `GET` client to a minimum
    of 1 ms, so we force a timeout:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数将 HTTP `GET` 客户端的超时时间减少到最小值 1 毫秒，因此我们强制超时：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `timeoutMilliseconds` variable will be a package variable that we will have
    to define later during implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeoutMilliseconds` 变量将是一个包变量，我们将在实现过程中稍后定义。'
- en: Implementation
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We needed to define a package variable called `timeoutMilliseconds`. Let''s
    start from there:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个名为 `timeoutMilliseconds` 的包变量。让我们从这里开始：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The initial timeout delay is 5 seconds (5,000 milliseconds) and we will need
    those packages in our code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 初始超时延迟为5秒（5,000毫秒），我们将在我们的代码中需要这些包。
- en: OK, so we need a function that launches a Goroutine for each endpoint URL. Do
    you remember how we achieve the communication between Goroutines? Exactly--channels!
    So we will need a channel to handle responses and a channel to handle errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们需要一个函数来为每个端点URL启动一个Goroutine。你还记得我们是如何在Goroutines之间实现通信的吗？没错——通道！因此，我们需要一个通道来处理响应，另一个通道来处理错误。
- en: 'But we can simplify it a bit more. We will receive two correct responses, two
    errors, or a response and an error; in any case, there are always two responses,
    so we can join errors and responses in a merged type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以进一步简化它。我们将收到两个正确响应，两个错误，或者一个响应和一个错误；在任何情况下，总是有两个响应，所以我们可以将错误和响应合并到一个合并类型中：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, each Goroutine will send back a value of the `barrierResp` type. This value
    will have a value for `Err` or a value for the `Resp` field.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个Goroutine都会发送回一个`barrierResp`类型的值。这个值将包含`Err`字段的值或`Resp`字段的值。
- en: 'The procedure is simple: we create a channel of size 2, the one that will receive
    responses of the `barrierResp` type, we launch both requests and wait for two
    responses, and then check to see if there is any error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 流程很简单：我们创建一个大小为2的通道，用于接收`barrierResp`类型的响应，我们启动两个请求并等待两个响应，然后检查是否有任何错误：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Following the previous description, we created a buffered channel called `in`,
    making it the size of the incoming endpoints, and we deferred channel closing.
    Then, we launched a function called `makeRequest` with each endpoint and the response
    channel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的描述，我们创建了一个缓冲通道`in`，使其大小与传入的端点相同，并延迟关闭通道。然后，我们为每个端点和响应通道启动了一个名为`makeRequest`的函数。
- en: Now we will loop  twice, once for each endpoint. In the loop, we block the execution
    waiting for data from the `in` channel. If we find an error, we print it prefixed
    with the word *ERROR* as we expect in our tests, and set `hasErrorvar` to true.
    After two responses, if we don't find any error (`hasError== false`) we print
    every response and the channel will be closed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将循环两次，一次针对每个端点。在循环中，我们阻塞执行，等待从`in`通道的数据。如果我们发现错误，我们将打印带有前缀单词*ERROR*的错误信息，正如我们在测试中预期的那样，并将`hasErrorvar`设置为true。在两个响应之后，如果我们没有找到任何错误（`hasError==
    false`），我们将打印每个响应，并将通道关闭。
- en: 'We still lack the `makeRequest` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少`makeRequest`函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `makeRequest` function is a very straightforward functions that accepts
    a channel to output `barrierResp` values to and a URL to request. We create an
    `http.Client` and set its timeout field to the value of the `timeoutMilliseconds`
    package variable. This is how we can change the timeout delay before the `in`
    function tests. Then, we simply make the `GET` call, take the response, parse
    it to a byte slice, and send it through the `out` channel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRequest`函数是一个非常直接的函数，它接受一个通道来输出`barrierResp`值，以及一个请求的URL。我们创建一个`http.Client`，并将其超时字段设置为`timeoutMilliseconds`包变量的值。这就是我们如何改变`in`函数测试的超时延迟。然后，我们简单地发起`GET`调用，获取响应，将其解析为字节切片，并通过`out`通道发送。'
- en: We do all this by filling a variable called `res` of the `barrierResp` type.
    If we find an error while performing a `GET` request or parsing the body of the
    result, we fill the `res.Err` field, send it to the `out` channel (which has the
    opposite side connected to the original Goroutine), and exit the function (so
    we don't send two values through the `out` channel by mistake).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过填充一个名为`res`的`barrierResp`类型变量来完成所有这些操作。如果在执行`GET`请求或解析结果体时发现错误，我们将填充`res.Err`字段，将其发送到`out`通道（该通道与原始Goroutine的另一侧相连），并退出函数（这样我们就不小心通过`out`通道发送两个值了）。
- en: 'Time to run the tests. Remember that you need an Internet connection, or the
    first two tests will fail. We will first try the test that has two endpoints that
    are correct:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行测试了。请记住，你需要一个互联网连接，否则前两个测试将会失败。我们首先尝试有两个正确端点的测试：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Perfect. We have a JSON response with a key, `headers`, and another JSON response
    with a key `User-Agent`. In our integration tests, we were looking for the strings, `User-Agent`
    and `Accept-Encoding`, which are present, so the test has passed successfully.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。我们有一个包含`headers`键的JSON响应，还有一个包含`User-Agent`键的JSON响应。在我们的集成测试中，我们寻找的是存在的字符串`User-Agent`和`Accept-Encoding`，所以测试已经成功通过。
- en: 'Now we will run the test that has an incorrect endpoint:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行一个包含错误端点的测试：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that we have had an error where `http://malformed-url` has returned
    a *no such host* error. A request to this URL must return a text with the word
    `ERROR:` prefixed, as we stated during the acceptance criteria, that's why this
    test is correct (we don't have a false positive).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们遇到了一个错误，`http://malformed-url` 返回了一个 *没有这样的主机* 错误。对这个 URL 的请求必须返回一个以
    `ERROR:` 开头的文本，正如我们在验收标准中所述，这就是为什么这个测试是正确的（我们没有出现假阳性）。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In testing, it''s very important to understand the concepts of "false positive"
    and "false negative" tests. A false positive test is roughly described as a test
    that passes a condition when it shouldn''t (result: all passed) while the false
    negative is just the reverse (result: test failed). For example, we could be testing
    that a string is returned when doing the requests but, the returned string could
    be completely empty! This will lead to a false negative, a test that doesn''t
    fail even when we are checking a behavior that is incorrect on purpose (a request
    to `http://malformed-url`).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，理解“假阳性”和“假阴性”测试的概念非常重要。假阳性测试大致描述为当它不应该通过条件时通过测试（结果：全部通过）而假阴性则正好相反（结果：测试失败）。例如，我们可能在请求时测试是否返回了一个字符串，但返回的字符串可能是完全空的！这将导致假阴性，即使我们在检查故意不正确的行为时（对
    `http://malformed-url` 的请求），测试也不会失败。
- en: 'The last test reduced the timeout time to 1 ms:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试将超时时间减少到 1 毫秒：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, the test passed successfully and we have got two timeout errors. The
    URLs were correct, but we didn't have a response in less than one millisecond,
    so the client has returned a timeout error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试成功通过，我们得到了两个超时错误。URL 是正确的，但我们没有在不到一毫秒的时间内收到响应，因此客户端返回了一个超时错误。
- en: Waiting for responses with the Barrier design pattern
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用障碍设计模式等待响应
- en: The Barrier pattern opens the door of microservices programming with its composable
    nature. It could be considered a Structural pattern, as you can imagine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 障碍模式以其可组合性打开了微服务编程的大门。它可以被认为是一种结构模式，就像你可以想象的那样。
- en: The Barrier pattern is not only useful to make network requests; we could also
    use it to split some task into multiple Goroutines. For example, an expensive
    operation could be split into a few smaller operations distributed in different
    Goroutines to maximize parallelism and achieve better performance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 障碍模式不仅对网络请求有用；我们还可以用它将一些任务拆分成多个 Goroutine。例如，一个昂贵的操作可以被拆分成几个较小的操作，分布在不同的 Goroutine
    中，以最大化并行性并实现更好的性能。
- en: Future design pattern
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Future 设计模式
- en: The Future design pattern (also called **Promise**) is a quick and easy way
    to achieve concurrent structures for asynchronous programming. We will take advantage
    of first class functions in Go to develop *Futures*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Future 设计模式（也称为 **Promise**）是实现异步编程并发结构的一种快速简单的方法。我们将利用 Go 中的第一类函数来开发 *Futures*。
- en: Description
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: In short, we will define each possible behavior of an action before executing
    them in different Goroutines. Node.js uses this approach, providing event-driven
    programming by default. The idea here is to achieve a *fire-and-forget* that handles
    all possible results in an action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将在不同的 Goroutine 中执行之前定义每个动作的可能行为。Node.js 使用这种方法，默认提供事件驱动编程。这里的想法是实现一个
    *发射并忘记*，它处理动作中所有可能的结果。
- en: To understand it better, we can talk about a type that has embedded the behavior
    in case an execution goes well or in case it fails.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它，我们可以讨论一个在执行成功或失败的情况下嵌入行为的类型。
- en: '![Description](img/00040.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![描述](img/00040.jpeg)'
- en: In the preceding diagram, the `main` function launches a **Future** within a
    new Goroutine. It won't wait for anything, nor will it receive any progress of
    the Future. It really fires and forgets it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`main` 函数在一个新的 Goroutine 中启动了一个 **Future**。它不会等待任何事情，也不会接收 Future 的任何进度。它实际上只是发射并忘记它。
- en: 'The interesting thing here is that we can launch a new Future within a Future
    and embed as many Futures as we want in the same Goroutine (or new ones). The
    idea is to take advantage of the result of one Future to launch the next. For
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们可以在一个 Future 中启动一个新的 Future，并在同一个 Goroutine（或新的）中嵌入尽可能多的 Future。想法是利用一个
    Future 的结果来启动下一个。例如：
- en: '![Description](img/00041.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![描述](img/00041.jpeg)'
- en: Here, we have the same Future. In this case, if the `Execute` function returned
    a correct result, the `Success` function is executed, and only in this case we
    execute a new Goroutine with another Future inside (or even without a Goroutine).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有相同的Future。在这种情况下，如果`Execute`函数返回了正确的结果，则执行`Success`函数，并且只有在这种情况下，我们才会执行一个新的Goroutine，其中包含另一个Future（或者甚至没有Goroutine）。
- en: This is a kind of lazy programming, where a Future could be calling to itself
    indefinitely or just until some rule is satisfied. The idea is to define the behavior
    in advance and let the future resolve the possible solutions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种懒惰编程，其中Future可以无限期地调用自己，或者直到满足某些规则为止。这个想法是在事先定义行为，并让未来解决可能的解决方案。
- en: Objectives
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'With the Future pattern, we can launch many new Goroutines, each with an action
    and its own handlers. This enables us to do the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Future模式，我们可以启动许多新的Goroutine，每个Goroutine都有一个动作和它自己的处理程序。这使得我们能够做到以下事情：
- en: Delegate the action handler to a different Goroutine
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动作处理程序委托给不同的Goroutine
- en: Stack many asynchronous calls between them (an asynchronous call that calls
    another asynchronous call in its results)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在它们之间堆叠许多异步调用（一个异步调用在其结果中调用另一个异步调用）
- en: A simple asynchronous requester
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的异步请求者
- en: We are going to develop a very simple example to try to understand how a Future
    works. In this example, we will have a method that returns a string or an error,
    but we want to execute it concurrently. We have learned ways to do this already.
    Using a channel, we can launch a new Goroutine and handle the incoming result
    from the channel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个非常简单的示例，以尝试理解Future是如何工作的。在这个例子中，我们将有一个返回字符串或错误的函数，但我们想并发地执行它。我们已经学习了如何做到这一点。使用通道，我们可以启动一个新的Goroutine，并处理从通道传入的结果。
- en: But in this case, we will have to handle the result (string or error), and we
    don't want this. Instead, we will define what to do in case of success and what
    to do in case of error and fire-and-forget the Goroutine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，我们必须处理结果（字符串或错误），我们不想这样做。相反，我们将定义在成功的情况下要做什么，在出错的情况下要做什么，并让Goroutine执行完毕后不再关注。
- en: Acceptance criteria
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'We don''t have functional requirements for this task. Instead, we will have
    technical requirements for it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个任务没有功能需求。相反，我们将有技术需求：
- en: Delegate the function execution to a different Goroutine
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数执行委托给不同的Goroutine
- en: The function will return a string (maybe) or an error
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将返回一个字符串（可能）或一个错误
- en: The handlers must be already defined before executing the function
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序必须在执行函数之前已经定义
- en: The design must be reusable
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计必须是可重用的
- en: Unit tests
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'So, as we mentioned, we will use first class functions to achieve this behavior,
    and we will need three specific types of function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们提到的，我们将使用一等函数来实现这种行为，并且我们需要三种特定的函数类型：
- en: '`type SuccessFunc func(string)`: The `SuccessFunc` function will be executed
    if everything went well. Its string argument will be the result of the operation,
    so this function will be called by our Goroutine.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type SuccessFunc func(string)`: 如果一切顺利，`SuccessFunc`函数将被执行。它的字符串参数将是操作的结果，因此这个函数将由我们的Goroutine调用。'
- en: '`type FailFunc func(error)`: The `FailFunc` function handles the opposite result,
    that is, when something goes wrong, and, as you can see, it will return an error.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type FailFunc func(error)`: `FailFunc`函数处理相反的结果，即当出现问题时，并且，正如你所看到的，它将返回一个错误。'
- en: '`type ExecuteStringFunc func() (string, error)`: Finally, the `ExecuteStringFunc` function
    is a type that defines the operation we want to perform. Maybe it will return
    a string or an error. Don''t worry if this all seems confusing; it will be clearer
    later.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type ExecuteStringFunc func() (string, error)`: 最后，`ExecuteStringFunc`函数是一个类型，它定义了我们想要执行的操作。也许它将返回一个字符串或一个错误。不用担心这一切似乎很复杂；稍后会更清楚。'
- en: 'So, we create the `future` object, we define a success behavior, we define
    a fail behavior, and we pass an `ExecuteStringFunc` type to be executed. In the
    implementation file, we''ll need a new type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建`future`对象，定义成功行为，定义失败行为，并传递一个要执行的`ExecuteStringFunc`类型。在实现文件中，我们需要一个新的类型：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will also create two tests in the `_test.go` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`_test.go`文件中创建两个测试：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will define functions by chaining them, as you would usually see in Node.js.
    Code like this is compact and not particularly difficult to follow:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过链式调用定义函数，就像你通常在Node.js中看到的那样。这样的代码紧凑，并不特别难懂：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `future.Success` function must be defined in the `MaybeString` structure
    to accept a `SuccessFunc` function that will be executed if everything goes correctly
    and return the same pointer to the `future` object (so we can keep chaining).
    The `Fail` function must also be defined in the `MaybeString` structure and must
    accept a `FailFunc` function to later return the pointer. We return the pointer
    in both cases so we can define the `Fail` and the `Success` or vice versa.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`future.Success` 函数必须在 `MaybeString` 结构体中定义，以便接受一个 `SuccessFunc` 函数，如果一切顺利，该函数将被执行，并返回相同的
    `future` 对象指针（这样我们就可以继续链式调用）。`Fail` 函数也必须在 `MaybeString` 结构体中定义，并且必须接受一个 `FailFunc`
    函数，稍后返回指针。在两种情况下，我们都返回指针，这样我们就可以定义 `Fail` 和 `Success` 或反之。'
- en: Finally, we use the `Execute` method to pass an `ExecuteStringFunc` type (a
    function that accepts nothing and returns a string or an error). In this case,
    we return a string and nil, so we expect that the `SuccessFunc` function will
    be executed and we log the result to the console. In case that fail function is
    executed, the test has failed because the `FailFunc` function shouldn't be executed
    for a returned nil error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `Execute` 方法传递一个 `ExecuteStringFunc` 类型（一个不接受任何参数并返回字符串或错误的函数）。在这种情况下，我们返回一个字符串和
    nil，所以我们期望 `SuccessFunc` 函数将被执行，并将结果记录到控制台。如果执行了失败函数，测试失败，因为对于返回的 nil 错误，不应该执行
    `FailFunc` 函数。
- en: 'But we still lack something here. We said that the function must be executed
    asynchronously in a different Goroutine, so we have to synchronize this test somehow
    so that it doesn''t finish too soon. Again, we can use a channel or a `sync.WaitGroup`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里仍然缺少一些东西。我们说函数必须在不同的 Goroutine 中异步执行，所以我们必须以某种方式同步这个测试，以免它过早完成。再次强调，我们可以使用一个通道或
    `sync.WaitGroup`：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have seen WaitGroups before in the previous channel. This WaitGroup is configured
    to wait for one signal (`wg.Add(1)`). The `Success` and `Fail` methods will trigger
    the `Done()` method of the `WaitGroup` to allow execution to continue and finish
    testing (that is why the `Wait()` method is at the end). Remember that each `Done()`
    method will subtract one from the WaitGroup, and we have added only one, so our
    `Wait()` method will only block until one `Done()` method is executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的通道中已经见过 WaitGroups。这个 WaitGroup 被配置为等待一个信号（`wg.Add(1)`）。`Success` 和 `Fail`
    方法将触发 `WaitGroup` 的 `Done()` 方法，以便允许执行继续并完成测试（这就是为什么 `Wait()` 方法在最后）。记住，每个 `Done()`
    方法都会从 WaitGroup 中减去一个，而我们只添加了一个，所以我们的 `Wait()` 方法只会阻塞，直到执行了一个 `Done()` 方法。
- en: 'Using what we know of making a `Success` result unit test, it''s easy to make
    a Failed result unit test by swapping the `t.Fail()` method call from the error
    to success so that the test fails if a call to success is done:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们关于创建 `Success` 结果单元测试的知识，很容易通过将 `t.Fail()` 方法调用从错误切换到成功来创建一个失败的单元测试，这样如果执行了成功的调用，测试就会失败：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you are using an IDE like me, your `Success`, `Fail`, and `Execute` method
    calls must be in red. This is because we lack our method''s declaration in the
    implementation file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样使用 IDE，你的 `Success`、`Fail` 和 `Execute` 方法调用必须显示为红色。这是因为我们在实现文件中缺少方法的声明：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our test seems ready to execute. Let''s try it out:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试看起来已经准备好执行了。让我们试一试：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Well... the tests have failed, yes... but not in a controllable way. Why is
    this? We don't have any implementation yet, so no `Success` or `Fail` functions
    are being executed either. Our WaitGroup is waiting forever for a call to the `Done()`
    method that will never arrive, so it can't continue and finish the test. That's
    the meaning of *All Goroutines are asleep - deadlock!*. In our specific example,
    it would mean *Nobody is going to call Done(), so we are dead!*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧... 测试失败了，是的... 但不是可控的方式。为什么是这样？我们还没有任何实现，所以既没有 `Success` 也没有 `Fail` 函数被执行。我们的
    WaitGroup 无限期地等待一个永远不会到达的 `Done()` 方法调用，所以它无法继续并完成测试。这就是 *所有 Goroutines 都处于休眠状态
    - 死锁* 的含义。在我们的具体例子中，这意味着 *没有人会调用 Done()，所以我们处于死锁状态!*。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Thanks to the Go compiler and the runtime executor, we can detect deadlocks
    easily. Imagine if Go runtime couldn't detect deadlocks--we would be effectively
    stuck in a blank screen without knowing what was wrong.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Go 编译器和运行时执行器，我们可以轻松地检测死锁。想象一下，如果 Go 运行时无法检测死锁，我们就会在不知道出了什么问题的情况下，有效地卡在一个空白屏幕上。
- en: So how can we solve this? Well, an easy way would be with a timeout that calls
    the `Done()` method after waiting a while for completion. For this code, it's
    safe to wait for 1 second because it's not doing long-running operations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们该如何解决这个问题呢？一个简单的方法是使用超时，在等待一段时间后调用 `Done()` 方法。对于这段代码，等待 1 秒是安全的，因为它没有进行长时间运行的操作。
- en: 'We will declare a `timeout` function within our `test` file that waits for
    a second, then prints a message, sets the test as failed, and lets the WaitGroup
    continue by calling its `Done()` method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`test`文件中声明一个`timeout`函数，该函数等待一秒钟，然后打印一条消息，将测试设置为失败，并通过调用其`Done()`方法让WaitGroup继续：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final look of each subtest is similar to our previous example of the `"Success
    result"`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子测试的最终外观类似于我们之前的`"Success result"`示例：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s see what happens when we execute our tests again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们再次执行测试时会发生什么：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our tests failed, but in a controlled way. Look at the end of the `FAIL` lines--notice
    how the elapsed time is 1 second because it has been triggered by the timeout,
    as we can see in the logging messages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试失败了，但是以受控的方式。看看`FAIL`行末尾——注意经过的时间是1秒，因为它已经被超时触发，正如我们在日志消息中看到的那样。
- en: It's time to pass to the implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候转向实现了。
- en: Implementation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: According to our tests, the implementation must take a `SuccessFunc`, a `FailFunc`,
    and an `ExecuteStringFunc` function in a chained fashion within the `MaybeString`
    type and launches the `ExecuteStringFunc` function asynchronously to call `SuccessFunc`
    or `FailFunc` functions according to the returned result of the `ExecuteStringFunc`
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的测试，实现必须以链式方式在`MaybeString`类型中采取`SuccessFunc`、`FailFunc`和`ExecuteStringFunc`函数，并异步启动`ExecuteStringFunc`函数以根据`ExecuteStringFunc`函数返回的结果调用`SuccessFunc`或`FailFunc`函数。
- en: 'The chain is implemented by storing the functions within the type and returning
    the pointer to the type. We are talking about our previously declared type methods,
    of course:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 链式实现是通过在类型中存储函数并返回类型的指针来完成的。我们当然是在谈论我们之前声明的类型方法：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We needed two fields to store the `SuccessFunc` and `FailFunc` functions, which
    are named the `successFunc` and `failFunc` fields respectively. This way, calls
    to the `Success` and `Fail` methods simply store their incoming functions to our
    new fields. They are simply setters that also return the pointer to the specific
    `MaybeString` value. These type methods take a pointer to the `MaybeString` structure,
    so don't forget to put "`*`" on `MaybeString` after the `func` declaration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个字段来存储`SuccessFunc`和`FailFunc`函数，分别命名为`successFunc`和`failFunc`字段。这样，对`Success`和`Fail`方法的调用只是将传入的函数存储到我们的新字段中。它们只是返回特定`MaybeString`值的指针的设置器。这些类型方法接受`MaybeString`结构的指针，所以别忘了在`func`声明后在`MaybeString`后加上"`*`"。
- en: Execute takes the `ExecuteStringFunc` method and executes it asynchronously.
    This seems quite simple with a Goroutine, right?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行方法接受`ExecuteStringFunc`方法并异步执行它。这看起来很简单，对吧？
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Looks quite simple because it is simple! We launch the Goroutine that executes
    the `f` method (an `ExecuteStringFunc`) and takes its result--maybe a string and
    maybe an error. If an error is present, we call the field `failFunc` in our `MaybeString`
    structure. If no error is present, we call the `successFunc` field. We use a Goroutine
    to delegate a function execution and error handling so our Goroutine doesn't have
    to do it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，因为它确实很简单！我们启动执行`f`方法（一个`ExecuteStringFunc`）的Goroutine，并获取其结果——可能是一个字符串和一个错误。如果存在错误，我们调用`MaybeString`结构中的`failFunc`字段。如果没有错误，我们调用`successFunc`字段。我们使用Goroutine来委托函数执行和错误处理，这样我们的Goroutine就不必执行它。
- en: 'Let''s run unit tests now:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在运行单元测试：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Great! Look how the execution time is now nearly zero, so our timeouts have
    not been executed (actually, they were executed, but the tests already finished
    and their result was already stated).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！看看执行时间现在几乎为零，所以我们的超时并没有被执行（实际上，它们被执行了，但测试已经完成，结果已经声明）。
- en: What's more, now we can use our `MaybeString` type to asynchronously execute
    any type of function that accepts nothing and returns a string or an error. A
    function that accepts nothing seems a bit useless, right? But we can use closures
    to introduce a context into this type of function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，现在我们可以使用我们的`MaybeString`类型异步执行任何不接受任何参数并返回字符串或错误的函数。不接受任何参数的函数似乎有点无用，对吧？但我们可以使用闭包将上下文引入此类函数。
- en: 'Let''s write a `setContext` function that takes a string as an argument and
    returns an `ExecuteStringFunc` method that returns the previous argument with
    the suffix `Closure!`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`setContext`函数，它接受一个字符串作为参数，并返回一个`ExecuteStringFunc`方法，该方法返回带有后缀`Closure!`的前一个参数：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, we can write a new test that uses this closure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以编写一个新的测试，使用这个闭包：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `setContext` function returns an `ExecuteStringFunc` method it can pass
    directly to the `Execute` function. We call the `setContext` function with an
    arbitrary text that we know will be returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`setContext`函数返回一个可以直接传递给`Execute`函数的`ExecuteStringFunc`方法。我们使用一个任意文本调用`setContext`函数，我们知道这个文本将会被返回。'
- en: Let's execute our tests again. Now everything has to go well!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次执行我们的测试。现在一切都要顺利！
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It gave us an OK too. Closure test shows the behavior that we explained before.
    By taking a message `"Hello"` and appending it with something else (`"Closure!"`),
    we can change the context of the text we want to return. Now scale this to a HTTP
    `GET` call, a call to a database, or anything you can imagine. It will just need
    to end by returning a string or an error. Remember, however, that everything within
    the `setContext` function but outside of the anonymous function that we are returning
    is not concurrent, and will be executed asynchronously before calling execute,
    so we must try to put as much logic as possible within the anonymous function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它也给了我们一个OK。闭包测试显示了我们在之前解释过的行为。通过取一个消息`"Hello"`并将其与另一个消息（`"Closure!"`）连接起来，我们可以改变我们想要返回的文本的上下文。现在将其扩展到HTTP
    `GET`调用、数据库调用或任何你能想象的事情。它只需要通过返回一个字符串或错误来结束。记住，然而，在`setContext`函数内部但不在我们返回的匿名函数之外的所有内容都不是并发的，它们将在调用execute之前异步执行，所以我们必须尽量在匿名函数内放置尽可能多的逻辑。
- en: Putting the Future together
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Future组合起来
- en: We have seen a good way to achieve asynchronous programming by using a function
    type system. However, we could have done it without functions by setting an interface
    with `Success`, `Fail`, and `Execute` methods and the types that satisfy them,
    and using the Template pattern to execute them asynchronously, as we have previously
    seen in this chapter. It is up to you!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到通过使用函数类型系统来实现异步编程的一个好方法。然而，我们也可以通过设置一个包含`Success`、`Fail`和`Execute`方法及其满足的类型，并使用模板模式来异步执行它们，就像我们在本章之前所看到的那样，而不使用函数来完成它。这取决于你！
- en: Pipeline design pattern
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流水线设计模式
- en: The third and final pattern we will see in this chapter is the Pipeline pattern.
    You will use this pattern heavily in your concurrent structures, and we can consider
    it one of the most useful too.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将看到的第三个也是最后一个模式是流水线模式。你将在你的并发结构中大量使用这个模式，我们可以将其视为最有用的模式之一。
- en: Description
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: 'We already know what a pipeline is. Every time that we write any function that
    performs some logic, we are writing a pipeline: If *this* then *that*, or else
    *something else*. Pipelines pattern can be made more complex by using a few functions
    that call to each other. They can even get looped in their out execution.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道什么是流水线。每次我们编写执行某些逻辑的任何函数时，我们都在编写一个流水线：如果*这个*，那么*那个*，否则*其他什么*。通过使用几个相互调用的函数，流水线模式可以变得更加复杂。它们甚至可以在它们的输出执行中形成循环。
- en: The Pipeline pattern in Go works in a similar fashion, but each step in the
    Pipeline will be in a different Goroutine and communication, and synchronizing
    will be done using channels.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的流水线模式以类似的方式工作，但流水线中的每个步骤都将位于不同的Goroutine中，并且将通过通道进行通信和同步。
- en: Objectives
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'When creating a Pipeline, we are mainly looking for the following benefits:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建流水线时，我们主要寻找以下好处：
- en: We can create a concurrent structure of a multistep algorithm
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个多步算法的并发结构
- en: We can exploit the parallelism of multicore machines by decomposing an algorithm
    in different Goroutines
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将算法分解为不同的Goroutines来利用多核机器的并行性
- en: However, just because we decompose an algorithm in different Goroutines doesn't
    necessarily mean that it will execute the fastest. We are constantly talking about
    CPUs, so ideally the algorithm must be CPU-intensive to take advantage of a concurrent
    structure. The overhead of creating Goroutines and channels could make an algorithm
    smaller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅因为我们将算法分解为不同的Goroutines并不意味着它就会执行得最快。我们一直在谈论CPU，所以理想情况下，算法必须是CPU密集型的，以便利用并发结构。创建Goroutines和通道的开销可能会使算法变得更小。
- en: A concurrent multi-operation
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发多操作
- en: We are going to do some math for our example. We are going to generate a list
    of numbers starting with 1 and ending at some arbitrary number N. Then we will
    take each number, power it to 2, and sum the resulting numbers to a unique result.
    So, if *N=3*, our list will be [1,2,3]. After powering them to 2, our list becomes
    [1,4,9]. If we sum the resulting list, the resulting value is 14.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的示例做一些数学运算。我们将生成一个从1开始到某个任意数字N结束的数字列表。然后我们将每个数字平方，并将结果数字加到一个唯一的结果中。所以，如果*N=3*，我们的列表将是[1,2,3]。在将它们平方后，我们的列表变为[1,4,9]。如果我们将这些结果相加，结果值是14。
- en: Acceptance criteria
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'Functionally speaking, our Pipeline pattern needs to raise to the power of
    2 every number and then sum them all. It will be divided into a number generator
    and two operations, so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，我们的Pipeline模式需要将每个数字平方，然后对所有数字求和。它将被分为一个数字生成器和两个操作，所以：
- en: Generate a list from 1 to N where N can be any integer number.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从1生成一个到N的列表，其中N可以是任何整数。
- en: Take each number of this generated list and raise it to the power of 2.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的列表中的每个数字平方。
- en: Sum each resulting number into a final result and return it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个结果数字加到最终结果中并返回它。
- en: Beginning with tests
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从测试开始
- en: 'We will create only one function that will manage everything. We will call
    this function `LaunchPipeline` to simplify things. It will take an integer as
    an argument, which will be our N number, the number of items in our list. The
    declaration in the implementation file looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个只管理一切的功能。我们将称这个函数为`LaunchPipeline`以简化事情。它将接受一个整数作为参数，这将是我们列表中的N数字，即项目数量。在实现文件中的声明如下所示：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our test file, we will create a table of tests by using a slice of slices:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试文件中，我们将使用切片的切片创建一个测试表：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our table is a slice of slices of integer types. On each slice, the first integer
    represents the list size and the second position represents the item within the
    list. It is, effectively, a matrix. When passing 3, it must return 14\. When passing
    5, it must return 55\. Then we have to iterate over the table and pass the first
    index of each array to the `LaunchPipeline` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据表是整数类型的切片的切片。在每一片中，第一个整数代表列表大小，第二个位置代表列表中的项目。实际上，它是一个矩阵。当传递3时，必须返回14。当传递5时，必须返回55。然后我们必须遍历这个表，并将每个数组的第一个索引传递给`LaunchPipeline`函数：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using `range`, we get every row in the matrix . Each row is contained in a
    temporary variable called `test`. `test[0]` represents `N` and `test[1]` the expected
    result. We compare the expected result with the returning value of the `LaunchPipeline`
    function. If they aren''t the same, the test fails:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range`，我们得到矩阵中的每一行。每一行都包含在一个临时变量`test`中。`test[0]`代表`N`，`test[1]`代表期望的结果。我们比较期望的结果与`LaunchPipeline`函数返回的值。如果它们不相同，测试失败：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implementation
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The key for our implementation is to separate every operation in a different
    Goroutine and connect them with channels. The `LaunchPipeline` function is the
    one that orchestrates them all, as shown in the following diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的关键是将每个操作分离到不同的Goroutine中，并通过通道将它们连接起来。`LaunchPipeline`函数是负责协调所有操作的函数，如下面的图所示：
- en: '![Implementation](img/00042.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/00042.jpeg)'
- en: 'The operation consist of three steps: generate a list of numbers, raise them
    to the power of 2, and add the resulting numbers.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 操作包括三个步骤：生成一个数字列表，将它们平方，然后加和结果数字。
- en: 'Each step in this Pipeline pattern will have the following structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Pipeline模式中的每个步骤都将具有以下结构：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function represents a common step. Let''s dissect it in the same order
    that the Go scheduler will probably take to execute it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数代表一个常见的步骤。让我们按照Go调度器可能执行的顺序来分析它：
- en: The `functionName` function will commonly receive a channel to take values from
    (`in <-chan int`). We call it the `in` function, as in the word incoming. We can't
    send values through it within the scope of this function; that's why the arrow
    points `out` of the keyword `chan`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functionName`函数通常接收一个通道来获取值（`in <-chan int`）。我们称它为`in`函数，正如单词incoming。在这个函数的作用域内，我们不能通过它发送值；这就是为什么箭头指向关键字`chan`的外面。'
- en: The `functionName` function returns a channel (`<-chan in`) that the function
    caller will only be allowed to take values from (again, represented by the arrow
    pointing `out` of the keyword `chan`). This also means that any value that goes
    through that channel must be generated within the scope of the function.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functionName` 函数返回一个通道 (`<-chan in`)，函数调用者只能从中取值（再次，由指向关键字 `chan` 的箭头表示）。这也意味着通过该通道传递的任何值都必须在函数的作用域内生成。'
- en: In the first line of the function, we create a channel called `out` that will
    be the return of the function (*point 2* in this list).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的第一行，我们创建了一个名为 `out` 的通道，它将是函数的返回值（在这个列表中的*第 2 点*）。
- en: Then, we will launch a new Goroutine. Its scope will enter into play after returning
    this function, so let's continue.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将启动一个新的 Goroutine。它的作用域将在返回此函数后进入，所以让我们继续。
- en: We return the previously created `out` channel.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回之前创建的 `out` 通道。
- en: Eventually, after finishing the execution of the function and returning the
    channel `out`, the Goroutine executes. It will take values from the `in` channel
    until it's closed. So the caller of this function is responsible for closing this
    channel, otherwise the Goroutine will never end!
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，在执行函数并返回通道 `out` 之后，Goroutine 执行。它将从 `in` 通道中取值，直到它被关闭。所以，这个函数的调用者负责关闭这个通道，否则
    Goroutine 将永远不会结束！
- en: When the `in` channel is closed, the for loop finishes and we close the `out`
    channel. Any Goroutine making use of this channel will not receive any new values
    since the last that was sent.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `in` 通道关闭时，for 循环结束，我们关闭 `out` 通道。任何使用此通道的 Goroutine 都不会收到最后发送的任何新值。
- en: 'The only step that doesn''t completely fit this approach is the first step
    that receives a number, representing the upper threshold on the list instead of
    a channel of incoming values. So, if we code this operation for each step in our
    pipeline, the final diagram looks more like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不完全符合这种方法的步骤是第一个步骤，它接收一个数字，代表列表的上限阈值，而不是一个输入值的通道。因此，如果我们为我们的管道中的每个步骤编码这个操作，最终的图示看起来更像这样：
- en: '![Implementation](img/00043.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/00043.jpeg)'
- en: Although the idea is exactly the same, now we can see that it's the function
    `LaunchPipeline` that is the one that is going to be receiving channels and sending
    them back to the next step in the Pipeline. Using this diagram, we can clearly
    see the flow of the pipeline creation by following the numbers of the arrows.
    A solid arrow represents a function call and a dashed arrow a channel.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然想法完全相同，但现在我们可以看到，接收通道并发送它们到管道中的下一个步骤的是 `LaunchPipeline` 函数。使用这个图，我们可以清楚地通过跟随箭头的数字来看到管道创建的流程。实线箭头代表函数调用，虚线箭头代表通道。
- en: Let's look a little more closely at the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看代码。
- en: The list generator
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表生成器
- en: 'The first step in the operation is list generation. The list starts at `1`
    and we will receive an integer representing the higher threshold. We have to pass
    each number in the list to the next step:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的第一步是列表生成。列表从 `1` 开始，我们将接收一个表示更高阈值的整数。我们必须将列表中的每个数字传递到下一个步骤：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we mentioned earlier, this is the pattern that we will follow in each step:
    create a channel, launch the Goroutine that will send the data through the channel,
    and immediately return the channel. This Goroutine will iterate from 1 to the
    max argument, which is the higher threshold for our list, and send each number
    through the channel. After sending every number, the channel is closed so that
    no more data can be sent through it, but the data already buffered can be retrieved.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这是我们将在每个步骤中遵循的模式：创建一个通道，启动将数据通过通道发送的 Goroutine，并立即返回通道。这个 Goroutine
    将从 `1` 迭代到最大参数，即我们列表的最高阈值，并将每个数字通过通道发送。发送完每个数字后，通道被关闭，因此无法再通过它发送更多数据，但已缓冲的数据可以被检索。
- en: Raising numbers to the power of 2
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数字提升到平方
- en: 'The second step will take every incoming number from the first step''s channel
    (that is taken from the arguments) and raise it to the power of 2\. Every result
    must be sent to the third step using a new channel:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步将接收来自第一步通道（即从参数中获取）的每个输入数字，并将其提升到平方。每个结果都必须通过一个新的通道发送到第三步：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We use the same pattern again: create a channel and launch the Goroutine while
    we return the created channel.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用相同的模式：创建一个通道，并在返回创建的通道的同时启动 Goroutine。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `for-range` loop keeps taking values from a channel indefinitely until the
    channel is closed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-range` 循环会无限期地从通道中取值，直到通道关闭。'
- en: Final reduce operation
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终的归约操作
- en: 'The third and final step receives every number from the second step and keeps
    adding them to a local value until the connection channel is closed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步和最后一步接收第二步中的每一个数字，并将它们持续添加到一个局部值中，直到连接通道关闭：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The function sum also takes a channel as an argument (the one returned from
    *step 2*). It also follows the same pattern of creating a channel, launching the
    Goroutine, and returning a channel. Goroutine keeps adding values to a variable
    called `sum` until the `in` channel is closed. When the `in` channel is closed,
    the value of sum is sent to the `out` channel, and it's immediately closed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `sum` 也接受一个通道作为参数（来自 *步骤 2* 返回的通道）。它也遵循相同的模式创建通道、启动 Goroutine 并返回一个通道。Goroutine
    会持续向名为 `sum` 的变量添加值，直到 `in` 通道关闭。当 `in` 通道关闭时，`sum` 的值会被发送到 `out` 通道，并且它立即关闭。
- en: Launching the Pipeline pattern
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动管道模式
- en: 'Finally, we can implement the `LaunchPipeline` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现 `LaunchPipeline` 函数：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The function `generator` first returns the channel that is passed to the power
    function. The `power` function returns the second channel that is passed to the `sum`
    function. The function `sum` finally returns the first channel that will receive
    a unique value, the result. Let''s try to test this now:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `generator` 首先返回传递给 `power` 函数的通道。`power` 函数返回传递给 `sum` 函数的第二个通道。`sum` 函数最终返回将接收唯一值（结果）的第一个通道。现在让我们尝试测试一下：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Awesome! It''s worth mentioning that the `LaunchPipeline` function doesn''t
    need to allocate every channel, and can be rewritten like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！值得提一下，`LaunchPipeline` 函数不需要为每个通道分配资源，它可以重写如下：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result of the `generator` function is passed directly to the `power` function
    and the result of `power` to `sum` functions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`generator` 函数的结果直接传递给 `power` 函数，而 `power` 函数的结果传递给 `sum` 函数。'
- en: Final words on the Pipeline pattern
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于管道模式的最后几句话
- en: With the Pipeline pattern, we can create really complex concurrent workflows
    in a very easy way. In our case, we created a linear workflow, but it could also
    have conditionals, pools, and fan-in and fan-out behavior. We will see some of
    these in the following chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道模式，我们可以非常容易地创建复杂的并发工作流程。在我们的例子中，我们创建了一个线性工作流程，但它也可以有条件语句、池以及输入和输出行为。我们将在下一章中看到一些这些内容。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Concurrency design patterns are a step forward in difficulty, and take some
    time to grasp. Our biggest mistake as concurrent programmers is thinking in terms
    of parallelism (How can I make this parallel? or How can I run this in a new thread?)
    instead of in terms of concurrent structures.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 并发设计模式在难度上是一个进步，需要一些时间来掌握。作为并发程序员，我们最大的错误是按照并行性（我如何使其并行？或者我如何在一个新线程中运行它？）而不是按照并发结构来思考。
- en: Pure functions (functions that will always produce the same output (given the
    same input) without affecting anything outside their scope) help in this design.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数（给定相同的输入始终产生相同输出（不对其作用域之外的事物产生影响）的函数）有助于这种设计。
- en: Concurrent programming requires practice and more practice. Go makes it easy
    once you understand the basic primitives. Diagrams can help you to understand
    the possible flow of data, but the best way of understanding it all is simply
    to practice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程需要练习，而且需要更多的练习。一旦你理解了基本原语，Go 就会变得简单。图表可以帮助你理解数据可能的流动，但理解所有这些的最佳方式仅仅是练习。
- en: In the following chapter, we will see how to use a pool of pipeline workers
    to do some work instead of having a unique pipeline. Also, we will learn how to
    create the publish/subscriber pattern in a concurrent structure and see how different
    the same pattern can be when we build by using concurrency.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何使用一组管道工作线程来完成一些工作，而不是使用一个唯一的管道。我们还将学习如何在并发结构中创建发布/订阅模式，并看到当我们使用并发构建时，相同的模式会有多么不同。
