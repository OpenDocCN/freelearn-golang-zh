["```go\ntype Service struct { \n   started bool \n   stpCh   chan struct{} \n   mutex   sync.Mutex \n} \nfunc (s *Service) Start() { \n   s.stpCh = make(chan struct{}) \n   go func() { \n         s.mutex.Lock() \n         s.started = true \n         s.mutex.Unlock() \n         <-s.stpCh // wait to be closed. \n   }() \n} \nfunc (s *Service) Stop() { \n   s.mutex.Lock() \n   defer s.mutex.Unlock() \n   if s.started { \n         s.started = false \n         close(s.stpCh) \n   } \n} \nfunc main() { \n   s := &Service{} \n   s.Start() \n   time.Sleep(time.Second) // do some work \n   s.Stop() \n} \n\nmutex, of type sync.Mutex, to synchronize access to the shared variable started. For this to work effectively, all contentious areas where the started variable is updated must use the same lock with successive calls to mutex.Lock() and mutex.Unlock(), as shown in the code.\nLock() and Unlock()methods as part of the struct itself:\n```", "```go\ntype Service struct { \n   ... \n   sync.Mutex \n} \n\nfunc (s *Service) Start() { \n   s.stpCh = make(chan struct{}) \n   go func() { \n         s.Lock() \n         s.started = true \n         s.Unlock() \n         <-s.stpCh // wait to be closed. \n   }() \n} \n\nfunc (s *Service) Stop() { \n   s.Lock() \n   defer s.Unlock() \n   ... \n} \n\n```"]