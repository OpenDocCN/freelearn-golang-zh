- en: Synchronizing with mutex locks
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用互斥锁进行同步
- en: 'Mutex locks allow serial access of shared resources by causing goroutines to
    block and wait until locks are released. The following sample illustrates a typical
    code scenario with the `Service` type, which must be started before it is ready
    to be used. After the service has started, the code updates an internal bool variable,
    `started`, to store its current state:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Mutex 锁通过使 goroutines 阻塞并等待锁释放，允许对共享资源进行串行访问。以下示例展示了使用 `Service` 类型的典型代码场景，该类型必须在准备使用之前启动。服务启动后，代码更新一个内部布尔变量
    `started`，以存储其当前状态：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch09/sync3.go
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync3.go
- en: The `sync` package also offers the RWMutex (read-write mutex), which can be
    used in cases where there is one writer that updates the shared resource, while
    there may be multiple readers. The writer would update the resource using a full
    lock, as before. However, readers use the `RLock()`/`RUnlock()` method pair (for
    read-lock/read-unlock respectively) to apply a read-only lock when reading the
    shared resource. The RWMutex type is used in the next section, *Synchronizing
    Access to Composite Values*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync` 包还提供了 RWMutex（读写互斥锁），在只有一个写者更新共享资源，而可能有多个读者的情况下可以使用。写者会像之前一样使用完整锁来更新资源。然而，读者使用
    `RLock()`/`RUnlock()` 方法对（分别用于读取锁/解锁）在读取共享资源时应用只读锁。RWMutex 类型将在下一节 *同步访问复合值* 中使用。'
