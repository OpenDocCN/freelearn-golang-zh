- en: Synchronizing access to composite values
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步访问复合值
- en: 'The previous section discussed concurrency safety when sharing access to simple
    values. The same level of care must be applied when sharing access to composite
    type values such as maps and slices, since Go does not offer concurrency-safe
    version of these types, as illustrated in the following example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节讨论了在共享访问简单值时的并发安全性。当共享访问复合类型值，如映射和切片时，必须采取相同级别的谨慎，因为Go不提供这些类型的并发安全版本，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch09/sync4.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync4.go
- en: The preceding code uses a `sync.RWMutex` variable (see preceding section, *Synchronizing
    with Mutex Locks*) to manage the locks when accessing the map variable `cache`.
    The code wraps the update operation to the `cache` variable within a pair of method
    calls, `mutex.Lock()` and `mutex.Unlock()`. However, when reading values from
    the `cache` variable, the `mutex.RLock()` and `mutex.RUnlock()`methods are used
    to provide concurrency safety.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了一个`sync.RWMutex`变量（参见前文章节，*使用互斥锁进行同步*）来管理访问`cache`变量时的锁。代码将更新`cache`变量的操作包裹在`mutex.Lock()`和`mutex.Unlock()`方法调用对中。然而，当从`cache`变量读取值时，使用`mutex.RLock()`和`mutex.RUnlock()`方法来提供并发安全性。
