<html><head></head><body>
<div class="book" title="The sync package" id="1T1401-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Concurrency barriers with sync.WaitGroup"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec164" class="calibre1"/>Concurrency barriers with sync.WaitGroup</h2></div></div></div><p class="calibre10">Sometimes when working with goroutines, you may need to create a synchronization barrier where you wish to wait for all running goroutines to finish before proceeding. The <code class="email">sync.WaitGroup</code> type is designed for such a scenario, allowing multiple goroutines to rendezvous at specific point in the code. Using WaitGroup requires three things:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The number of participants in the group via the Add method</li><li class="listitem">Each goroutine calls the Done method to signal completion</li><li class="listitem">Use the Wait method to block until all goroutines are done</li></ul></div><p class="calibre10">WaitGroup is often used as a way to implement work distribution patterns. The following code snippet illustrates work distribution to calculate the sum of multiples of <code class="email">3</code> and <code class="email">5</code> up to <code class="email">MAX</code>. The code uses the <code class="email">WaitGroup</code> variable, <code class="email">wg</code>, to create a concurrency barrier that waits for two goroutines to calculate the partial sums of the numbers, then gathers the result after all goroutines are done:</p><pre class="programlisting">const MAX = 1000 
 
func main() { 
   values := make(chan int, MAX) 
   result := make(chan int, 2) 
   var wg sync.WaitGroup 
   wg.Add(2) 
   go func() { // gen multiple of 3 &amp; 5 values 
         for i := 1; i &lt; MAX; i++ { 
               if (i%3) == 0 || (i%5) == 0 { 
                     values &lt;- i // push downstream 
               } 
         } 
         close(values) 
   }() 
 
   work := func() { // work unit, calc partial result 
         defer wg.Done() 
         r := 0 
         for i := range values { 
               r += i 
         } 
         result &lt;- r 
   } 
 
   // distribute work to two goroutines 
   go work() 
   go work() 
 
   wg.Wait()                    // wait for both groutines 
   total := &lt;-result + &lt;-result // gather partial results 
   fmt.Println("Total:", total) 
} 
</pre><p class="calibre10">golang.fyi/ch09/sync5.go</p><p class="calibre10">In the previous code, the method call, <code class="email">wg.Add(2)</code>, configures the <code class="email">WaitGroup</code> variable <code class="email">wg</code> because the work is distributed between two goroutines. The <code class="email">work</code> function calls <code class="email">defer wg.Done()</code> to decrement the WaitGroup counter by one every time it is completed.</p><p class="calibre10">Lastly, the <code class="email">wg.Wait()</code>method call blocks until its internal counter reaches zero. As explained previously, this will happen when both goroutines' <code class="email">work</code> running function complete successfully. When that happens, the program unblocks and gathers the partial results. It is important to remember that <code class="email">wg.Wait()</code> will block indefinitely if its internal counter never reaches zero.</p></div></div></body></html>