["```go\n3 and 5 up to MAX. The code uses the WaitGroup variable, wg, to create a concurrency barrier that waits for two goroutines to calculate the partial sums of the numbers, then gathers the result after all goroutines are done:\n```", "```go\nconst MAX = 1000 \n\nfunc main() { \n   values := make(chan int, MAX) \n   result := make(chan int, 2) \n   var wg sync.WaitGroup \n   wg.Add(2) \n   go func() { // gen multiple of 3 & 5 values \n         for i := 1; i < MAX; i++ { \n               if (i%3) == 0 || (i%5) == 0 { \n                     values <- i // push downstream \n               } \n         } \n         close(values) \n   }() \n\n   work := func() { // work unit, calc partial result \n         defer wg.Done() \n         r := 0 \n         for i := range values { \n               r += i \n         } \n         result <- r \n   } \n\n   // distribute work to two goroutines \n   go work() \n   go work() \n\n   wg.Wait()                    // wait for both groutines \n   total := <-result + <-result // gather partial results \n   fmt.Println(\"Total:\", total) \n} \n\n```"]