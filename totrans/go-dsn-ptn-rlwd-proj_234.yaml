- en: Concurrency barriers with sync.WaitGroup
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sync.WaitGroup 实现并发屏障
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch09/sync5.go
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync5.go
- en: In the previous code, the method call, `wg.Add(2)`, configures the `WaitGroup`
    variable `wg` because the work is distributed between two goroutines. The `work`
    function calls `defer wg.Done()` to decrement the WaitGroup counter by one every
    time it is completed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，方法调用 `wg.Add(2)` 配置了 `WaitGroup` 变量 `wg`，因为工作被分配给了两个 goroutine。`work`
    函数通过调用 `defer wg.Done()` 在每次完成时减少 WaitGroup 计数器一个单位。
- en: Lastly, the `wg.Wait()`method call blocks until its internal counter reaches
    zero. As explained previously, this will happen when both goroutines' `work` running
    function complete successfully. When that happens, the program unblocks and gathers
    the partial results. It is important to remember that `wg.Wait()` will block indefinitely
    if its internal counter never reaches zero.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`wg.Wait()` 方法调用会阻塞，直到其内部计数器达到零。如前所述，这将在两个 goroutine 的 `work` 运行函数成功完成后发生。当这种情况发生时，程序将解除阻塞并收集部分结果。重要的是要记住，如果
    `wg.Wait()` 的内部计数器永远不会达到零，它将无限期地阻塞。
