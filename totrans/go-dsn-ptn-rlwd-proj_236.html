<html><head></head><body><div class="book" title="Parallelism in Go" id="1UU541-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec62" class="calibre1"/>Parallelism in Go</h1></div></div></div><p class="calibre10">So far, the discussion in this chapter has focused on synchronizing concurrent programs. As was mentioned earlier in the chapter, the Go runtime scheduler automatically multiplexes and schedules goroutines across available OS-managed threads. This means concurrent programs that can be parallelized have the ability to take advantage of the underlying processor cores with little to no configuration. For instance, the following code cleanly segregates its work unit (to calculate sums of multiples of 3 and 5) to be calculated by launching <code class="email">workers</code> number of goroutines:</p><pre class="programlisting">const MAX = 1000 
const workers = 2 
 
func main() { 
   values := make(chan int) 
   result := make(chan int, workers) 
   var wg sync.WaitGroup 
 
   go func() { // gen multiple of 3 &amp; 5 values 
         for i := 1; i &lt; MAX; i++ { 
               if (i%3) == 0 || (i%5) == 0 { 
                     values &lt;- i // push downstream 
               } 
         } 
         close(values) 
   }() 
 
   work := func() { // work unit, calc partial result 
         defer wg.Done() 
         r := 0 
         for i := range values { 
               r += i 
         } 
         result &lt;- r 
   } 
 
   //launch workers 
   wg.Add(workers) 
   for i := 0; i &lt; workers; i++ { 
         go work() 
   } 
 
   wg.Wait() // wait for all groutines 
   close(result) 
   total := 0 
   // gather partial results 
   for pr := range result { 
         total += pr 
   } 
   fmt.Println("Total:", total) 
} 
</pre><p class="calibre10">golang.fyi/ch09/sync6.go</p><p class="calibre10">The previous code will automatically launch each goroutine, with <code class="email">go work()</code>, in parallel when executed on a multi-core machine. The Go runtime scheduler, by default, will create a number of OS-backed threads for scheduling that is equal to the number of CPU cores. That quantity is identified by runtime value called <span class="strong"><em class="calibre11">GOMAXPROCS</em></span>.</p><p class="calibre10">The GOMAXPROCS value can be explicitly changed to influence the number threads that are made available to the scheduler. That value can be changed using a command-line environment variable with the same name. GOMAXPROCS can also be updated in the using function <code class="email">GOMAXPROCS()</code> from the <span class="strong"><em class="calibre11">runtime</em></span> package (<a class="calibre1" href="https://golang.org/pkg/runtime">https://golang.org/pkg/runtime</a>). Either approach allows programmers to fine-tune the number of threads that will participate in scheduling goroutines.</p></div></body></html>