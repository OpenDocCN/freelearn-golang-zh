- en: Parallelism in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the discussion in this chapter has focused on synchronizing concurrent
    programs. As was mentioned earlier in the chapter, the Go runtime scheduler automatically
    multiplexes and schedules goroutines across available OS-managed threads. This
    means concurrent programs that can be parallelized have the ability to take advantage
    of the underlying processor cores with little to no configuration. For instance,
    the following code cleanly segregates its work unit (to calculate sums of multiples
    of 3 and 5) to be calculated by launching `workers` number of goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/sync6.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code will automatically launch each goroutine, with `go work()`,
    in parallel when executed on a multi-core machine. The Go runtime scheduler, by
    default, will create a number of OS-backed threads for scheduling that is equal
    to the number of CPU cores. That quantity is identified by runtime value called
    *GOMAXPROCS*.
  prefs: []
  type: TYPE_NORMAL
- en: The GOMAXPROCS value can be explicitly changed to influence the number threads
    that are made available to the scheduler. That value can be changed using a command-line
    environment variable with the same name. GOMAXPROCS can also be updated in the
    using function `GOMAXPROCS()` from the *runtime* package ([https://golang.org/pkg/runtime](https://golang.org/pkg/runtime)).
    Either approach allows programmers to fine-tune the number of threads that will
    participate in scheduling goroutines.
  prefs: []
  type: TYPE_NORMAL
