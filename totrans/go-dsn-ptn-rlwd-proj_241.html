<html><head></head><body>
<div class="book" title="The io.Reader interface" id="21PMQ1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Chaining readers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec165" class="calibre1"/>Chaining readers</h2></div></div></div><p class="calibre10">Chances are the standard library already has a reader that you can reuse - so it is common to wrap an existing reader and use its stream as the source for the new implementation. The following snippet shows an updated version of <code class="email">alphaReader</code>. This time, it takes an <code class="email">io.Reader</code> as its source as shown in the following code:</p><pre class="programlisting">type alphaReader struct { 
   src io.Reader 
} 
 
func NewAlphaReader(source io.Reader) *alphaReader { 
   return &amp;alphaReader{source} 
} 
 
func (a *alphaReader) Read(p []byte) (int, error) { 
   if len(p) == 0 { 
         return 0, nil 
   } 
   count, err := a.src.Read(p) // p has now source data 
   if err != nil { 
         return count, err 
   } 
   for i := 0; i &lt; len(p); i++ { 
         if (p[i] &gt;= 'A' &amp;&amp; p[i] &lt;= 'Z') || 
               (p[i] &gt;= 'a' &amp;&amp; p[i] &lt;= 'z') { 
               continue 
         } else { 
               p[i] = 0 
         } 
   } 
   return count, io.EOF 
} 
 
func main() { 
   str := strings.NewReader("Hello! Where is the sun?") 
   alpha := NewAlphaReader(str) 
   io.Copy(os.Stdout, alpha) 
   fmt.Println() 
} 
</pre><p class="calibre10">golang.fyi/ch10/reader1.go</p><p class="calibre10">The main change to note in this version of the code is that the <code class="email">alphaReader</code> type is now a struct which embeds an <code class="email">io.Reader</code> value. When <code class="email">alphaReader.Read()</code> is invoked, it calls the wrapped reader as <code class="email">a.src.Read(p)</code>, which will inject the source data into byte slice <code class="email">p</code>. Then the method loops through <code class="email">p</code> and applies the filter to the data. Now, to use the <code class="email">alphaReader</code>, it must first be provided with an existing reader which is facilitated by the <code class="email">NewAlphaReader()</code>Â constructor function.</p><p class="calibre10">The advantages of this approach may not be obvious at first. However, by using an <code class="email">io.Reader</code> as the underlying data source the <code class="email">alphaReader</code> type is capable of reading from any reader implementation. For instance, the following code snippet shows how the <code class="email">alphaReader</code> type can now be combined with an <code class="email">os.File</code> to filter out non-alphabetic characters from a file (the Go source code itself):</p><pre class="programlisting">... 
func main() { 
   file, _ := os.Open("./reader2.go") 
   alpha := NewAlphaReader(file) 
   io.Copy(os.Stdout, alpha) 
   fmt.Println() 
} 
</pre><p class="calibre10">golang.fyi/ch10/reader2.go</p></div></div></body></html>