["```go\ntype Writer interface { \n   Write(p []byte) (n int, err error) \n} \n\nchannelWriter type, a writer that decomposes and serializes its stream that is sent over a Go channel as consecutive bytes:\n```", "```go\ntype channelWriter struct { \n   Channel chan byte \n} \n\nfunc NewChannelWriter() *channelWriter { \n   return &channelWriter{ \n         Channel: make(chan byte, 1024), \n   } \n} \n\nfunc (c *channelWriter) Write(p []byte) (int, error) { \n   if len(p) == 0 { \n         return 0, nil \n   } \n\n   go func() { \n         defer close(c.Channel) // when done \n         for _, b := range p { \n               c.Channel <- b \n         } \n   }() \n\n   return len(p), nil \n} \n\nfmt.Fprint function to serialize the \"Stream me!\" string as a sequence of bytes over a channel using channelWriter:\n```", "```go\nfunc main() { \n   cw := NewChannelWriter() \n   go func() { \n         fmt.Fprint(cw, \"Stream me!\") \n   }() \n\n   for c := range cw.Channel { \n         fmt.Printf(\"%c\\n\", c) \n   } \n} \n\nforâ€¦range statement as they are successively printed. The following snippet shows another example where the content of a file is serialized over a channel using the same channelWriter. In this implementation, an io.File value and io.Copy function are used to source the data instead of the fmt.Fprint function:\n```", "```go\nfunc main() { \n   cw := NewChannelWriter() \n   file, err := os.Open(\"./writer2.go\") \n   if err != nil { \n         fmt.Println(\"Error reading file:\", err) \n         os.Exit(1) \n   } \n   _, err = io.Copy(cw, file) \n   if err != nil { \n         fmt.Println(\"Error copying:\", err) \n         os.Exit(1) \n   } \n\n   // consume channel \n   for c := range cw.Channel { \n         fmt.Printf(\"%c\\n\", c) \n   } \n} \n\n```"]