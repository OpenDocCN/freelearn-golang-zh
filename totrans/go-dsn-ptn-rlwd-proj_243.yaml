- en: Working with the io package
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 io 包
- en: The obvious place to start with IO is, well, the `io` package ([https://golang.org/pkg/io](https://golang.org/pkg/io)).
    As we have already seen, the `io` package defines input and output primitives
    as the `io.Reader` and `io.Writer` interfaces. The following table summarizes
    additional functions and types, available in the `io` package, that facilitate
    streaming IO operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IO 中开始的地方很显然是，`io` 包 ([https://golang.org/pkg/io](https://golang.org/pkg/io))。正如我们已经看到的，`io`
    包定义了输入和输出原语为 `io.Reader` 和 `io.Writer` 接口。以下表格总结了在 `io` 包中可用的其他函数和类型，这些函数和类型有助于简化流式
    IO 操作。
- en: '| **Function** | **Description** |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `io.Copy()` | The `io.Copy` function (and its variants `io.CopyBuffer` and
    `io.CopyN`) make it easy to copy data from an arbitrary `io.Reader` source into
    an equally arbitrary `io.Writer` sink as shown in the following snippet:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.Copy()` | `io.Copy` 函数（及其变体 `io.CopyBuffer` 和 `io.CopyN`）使得从任意的 `io.Reader`
    源复制数据到任意的 `io.Writer` 汇很容易，如下面的代码片段所示：'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch10/iocopy.go |
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iocopy.go |
- en: '| `PipeReader PipeWriter` | The `io` package includes the *PipeReader* and
    *PipeWriter* types that model IO operations as an in-memory pipe. Data is written
    to the pipe''s `io.Writer` and can independently be read at the pipe''s `io.Reader`.
    The following abbreviated snippet illustrates a simple pipe that writes a string
    to the writer `pw`. The data is then consumed with the `pr` reader and copied
    to a file:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '| `PipeReader PipeWriter` | `io` 包包括 *PipeReader* 和 *PipeWriter* 类型，它们将 IO
    操作建模为内存管道。数据写入管道的 `io.Writer`，可以独立地从管道的 `io.Reader` 读取。以下简化的代码片段演示了一个简单的管道，它将字符串写入写入器
    `pw`。然后，使用 `pr` 读取器消耗数据并将其复制到文件：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch10/iopipe.goNote that the pipe writer will block until the reader
    completely consumes the pipe content or an error is encountered. Therefore, both
    the reader and writer should be wrapped in a goroutine to avoid deadlocks. |
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iopipe.go 注意，管道写入器将在读取器完全消耗管道内容或遇到错误之前阻塞。因此，读取器和写入器都应该包装在 goroutine
    中，以避免死锁。|
- en: '| `io.TeeReader()` | Similar to the `io.Copy` function, `io.TeeReader` transfers
    content from a reader to a writer. However, the function also emits the copied
    bytes (unaltered) via a returned `io.Reader`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.TeeReader()` | 与 `io.Copy` 函数类似，`io.TeeReader` 将内容从读取器传输到写入器。然而，该函数还会通过返回的
    `io.Reader` 发射复制的字节（未更改）。'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'golang.fyi/ch10/ioteerdr0.goIf we wanted to calculate both SHA-1 and MD5, we
    can update the code to nest the two `TeeReader` values as shown in the following
    snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/ioteerdr0.go 如果我们想要同时计算 SHA-1 和 MD5，我们可以更新代码，将两个 `TeeReader`
    值嵌套，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch10/ioteerdr1.go |
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/ioteerdr1.go |
- en: '| `io.WriteString()` | The `io.WriteString` function writes the content of
    string into a specified writer. The following writes the content of a string to
    a file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.WriteString()` | `io.WriteString` 函数将字符串的内容写入指定的写入器。以下代码将字符串的内容写入文件：'
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch10/iowritestr.go |
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iowritestr.go |
- en: '| `io.LimitedReader` | As its name suggests, the `io.LimitedReader` struct is
    a reader that reads only *N* number of bytes from the specified `io.Reader`. The
    following snippet will print the first 19 bytes from the string:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.LimitedReader` | 如其名所示，`io.LimitedReader` 结构体是一个只从指定的 `io.Reader` 中读取
    *N* 个字节的读取器。以下代码片段将打印字符串的前 19 个字节：'
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: golang.fyi/ch10/iolimitedrdr.go
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iolimitedrdr.go
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.SectionReader` | The `io.SectionReader` type implements seek and skip
    primitives by specifying an index (zero-based) where to start reading and an offset
    value indicating the number of bytes to read as shown in the following snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.SectionReader` | `io.SectionReader` 类型通过指定一个索引（基于零）来开始读取，以及一个表示要读取的字节数的偏移值，实现了
    seek 和 skip 基本操作，如下面的代码片段所示：'
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: golang.fyi/ch10/iosectionrdr.goThis example will print `jumps over the lazy
    dog`. |
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iosectionrdr.go 此示例将打印 `jumps over the lazy dog`。|
- en: '| Package `io/ioutil` | The `io/ioutil` sub-package implements a small number
    of functions that provide utilitarian shortcuts to IO primitives such as file
    read, directory listing, temp directory creation, and file write. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 包 `io/ioutil` | `io/ioutil` 子包实现了一些提供实用快捷方式的函数，这些函数提供了对 IO 基本操作（如文件读取、目录列出、临时目录创建和文件写入）的访问。|'
