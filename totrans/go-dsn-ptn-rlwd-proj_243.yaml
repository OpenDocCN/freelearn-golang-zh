- en: Working with the io package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The obvious place to start with IO is, well, the `io` package ([https://golang.org/pkg/io](https://golang.org/pkg/io)).
    As we have already seen, the `io` package defines input and output primitives
    as the `io.Reader` and `io.Writer` interfaces. The following table summarizes
    additional functions and types, available in the `io` package, that facilitate
    streaming IO operations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `io.Copy()` | The `io.Copy` function (and its variants `io.CopyBuffer` and
    `io.CopyN`) make it easy to copy data from an arbitrary `io.Reader` source into
    an equally arbitrary `io.Writer` sink as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iocopy.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `PipeReader PipeWriter` | The `io` package includes the *PipeReader* and
    *PipeWriter* types that model IO operations as an in-memory pipe. Data is written
    to the pipe''s `io.Writer` and can independently be read at the pipe''s `io.Reader`.
    The following abbreviated snippet illustrates a simple pipe that writes a string
    to the writer `pw`. The data is then consumed with the `pr` reader and copied
    to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iopipe.goNote that the pipe writer will block until the reader
    completely consumes the pipe content or an error is encountered. Therefore, both
    the reader and writer should be wrapped in a goroutine to avoid deadlocks. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.TeeReader()` | Similar to the `io.Copy` function, `io.TeeReader` transfers
    content from a reader to a writer. However, the function also emits the copied
    bytes (unaltered) via a returned `io.Reader`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'golang.fyi/ch10/ioteerdr0.goIf we wanted to calculate both SHA-1 and MD5, we
    can update the code to nest the two `TeeReader` values as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/ioteerdr1.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.WriteString()` | The `io.WriteString` function writes the content of
    string into a specified writer. The following writes the content of a string to
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iowritestr.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.LimitedReader` | As its name suggests, the `io.LimitedReader` struct is
    a reader that reads only *N* number of bytes from the specified `io.Reader`. The
    following snippet will print the first 19 bytes from the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iolimitedrdr.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.SectionReader` | The `io.SectionReader` type implements seek and skip
    primitives by specifying an index (zero-based) where to start reading and an offset
    value indicating the number of bytes to read as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iosectionrdr.goThis example will print `jumps over the lazy
    dog`. |
  prefs: []
  type: TYPE_NORMAL
- en: '| Package `io/ioutil` | The `io/ioutil` sub-package implements a small number
    of functions that provide utilitarian shortcuts to IO primitives such as file
    read, directory listing, temp directory creation, and file write. |'
  prefs: []
  type: TYPE_TB
