<html><head></head><body>
<div class="book" title="Encoding and decoding data">
<div class="book" title="Binary encoding with gob"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec175" class="calibre1"/>Binary encoding with gob</h2></div></div></div><p class="calibre10">The <code class="email">gob</code> package (<a class="calibre1" href="https://golang.org/pkg/encoding/gob"><span class="strong"><em class="calibre11">https://golang.org/pkg/encoding/gob</em></span></a>) provides an encoding format that can be used to convert complex Go data types into binary. Gob is self-describing, meaning each encoded data item is accompanied by a type description. The encoding process involves streaming the gob-encoded data to an io.Writer so it can be written to a resource for future consumption.</p><p class="calibre10">The following snippet shows an example code that encodes variable <code class="email">books</code>, a slice of the <code class="email">Book</code> type with nested values, into the <code class="email">gob</code> format. The encoder writes its generated binary data to an os.Writer instance, in this case the <code class="email">file </code>variable of the <code class="email">*os.File</code> type:</p><pre class="programlisting">type Name struct { 
   First, Last string 
} 
 
type Book struct { 
   Title       string 
   PageCount   int 
   ISBN        string 
   Authors     []Name 
   Publisher   string 
   PublishDate time.Time 
} 
 
func main() { 
   books := []Book{ 
         Book{ 
               Title:       "Leaning Go", 
               PageCount:   375, 
               ISBN:        "9781784395438", 
               Authors:     []Name{{"Vladimir", "Vivien"}}, 
               Publisher:   "Packt", 
               PublishDate: time.Date( 
                     2016, time.July, 
                     0, 0, 0, 0, 0, time.UTC, 
               ), 
         }, 
         Book{ 
               Title:       "The Go Programming Language", 
               PageCount:   380, 
               ISBN:        "9780134190440", 
               Authors:     []Name{ 
                     {"Alan", "Donavan"}, 
                     {"Brian", "Kernighan"}, 
               }, 
               Publisher:   "Addison-Wesley", 
               PublishDate: time.Date( 
                     2015, time.October, 
                     26, 0, 0, 0, 0, time.UTC, 
               ), 
         }, 
         ... 
   } 
 
   // serialize data structure to file 
   file, err := os.Create("book.dat") 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
   enc := gob.NewEncoder(file) 
   if err := enc.Encode(books); err != nil { 
         fmt.Println(err) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch10/gob0.go</p><p class="calibre10">Although the previous example is lengthy, it is mostly made of the definition of the nested data structure assigned to variable <code class="email">books</code>. The last half-dozen or more lines are where the encoding takes place. The gob encoder is created with <code class="email">enc := gob.NewEncoder(file)</code>. Encoding the data is done by simply calling <code class="email">enc.Encode(books)</code> which streams the encoded data to the provide file.</p><p class="calibre10">The decoding process does the reverse by streaming the gob-encoded binary data using an <code class="email">io.Reader</code> and automatically reconstructing it as a strongly-typed Go value. The following code snippet decodes the gob data that was encoded and stored in the <code class="email">books.data</code> file in the previous example. The decoder reads the data from an <code class="email">io.Reader</code>, in this instance the variable <code class="email">file</code> of the <code class="email">*os.File</code> type:</p><pre class="programlisting">type Name struct { 
   First, Last string 
} 
 
type Book struct { 
   Title       string 
   PageCount   int 
   ISBN        string 
   Authors     []Name 
   Publisher   string 
   PublishDate time.Time 
} 
 
func main() { 
   file, err := os.Open("book.dat") 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
 
   var books []Book 
   dec := gob.NewDecoder(file) 
   if err := dec.Decode(&amp;books); err != nil { 
         fmt.Println(err) 
         return 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch10/gob1.go</p><p class="calibre10">Decoding a previously encoded gob data is done by creating a decoder using <code class="email">dec := gob.NewDecoder(file)</code>. The next step is to declare the variable that will store the decoded data. In our example, the <code class="email">books</code> variable, of the <code class="email">[]Book</code> type, is declared as the destination of the decoded data. The actual decoding is done by invoking <code class="email">dec.Decode(&amp;books)</code>. Notice the <code class="email">Decode()</code>Â method takes the address of its target variable as an argument. Once decoded, the <code class="email">books </code>variable will contain the reconstituted data structure streamed from the file.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre10">As of this writing, gob encoder and decoder APIs are only available in the Go programming language. This means that data encoded as gob can only be consumed by Go programs.</p></div></div></div></body></html>