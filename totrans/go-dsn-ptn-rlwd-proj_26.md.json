["```go\npackage main \nimport ( \n  \"log\" \n  \"net/http\" \n) \nfunc main() { \n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r  *http.Request) { \n    w.Write([]byte(`)) \n      <html> \n        <head> \n          <title>Chat</title> \n        </head> \n        <body> \n          Let's chat! \n        </body> \n      </html> \n    )) \n  }) \n  // start the web server \n  if err := http.ListenAndServe(\":8080\", nil); err != nil { \n    log.Fatal(\"ListenAndServe:\", err) \n  } \n} \n\n```", "```go\ngo run main.go\n\n```", "```go\nHello {{name}}, how are you? \n\n```", "```go\nHello Bruce, how are you? \n\n```", "```go\n<html> \n  <head> \n    <title>Chat</title> \n  </head> \n  <body> \n    Let's chat (from template) \n  </body> \n</html> \n\n```", "```go\n// templ represents a single template \ntype templateHandler struct { \n  once     sync.Once \n  filename string \n  templ    *template.Template \n} \n// ServeHTTP handles the HTTP request. \nfunc (t *templateHandler) ServeHTTP(w http.ResponseWriter, r  *http.Request) { \n  t.once.Do(func() { \n    t.templ =  template.Must(template.ParseFiles(filepath.Join(\"templates\",\n      t.filename))) \n  }) \n  t.templ.Execute(w, nil) \n} \n\n```", "```go\nfunc main() { \n  // root \n  http.Handle(\"/\", &templateHandler{filename: \"chat.html\"}) \n  // start the web server \n  if err := http.ListenAndServe(\":8080\", nil); err != nil { \n    log.Fatal(\"ListenAndServe:\", err) \n  } \n} \n\n```", "```go\ngo build -o {name}\n./{name}\n\n```", "```go\ngo build -o chat\n./chat\n\n```", "```go\npackage main  \nimport ( \n  \"github.com/gorilla/websocket\" \n) \n// client represents a single chatting user. \ntype client struct { \n  // socket is the web socket for this client. \n  socket *websocket.Conn \n  // send is a channel on which messages are sent. \n  send chan []byte \n  // room is the room this client is chatting in. \n  room *room \n} \n\n```", "```go\ngo get github.com/gorilla/websocket\n\n```", "```go\n./client.go:17 undefined: room\n\n```", "```go\npackage main \ntype room struct { \n  // forward is a channel that holds incoming messages \n  // that should be forwarded to the other clients. \n  forward chan []byte \n} \n\n```", "```go\nfunc (c *client) read() { \n  defer c.socket.Close() \n  for { \n    _, msg, err := c.socket.ReadMessage() \n    if err != nil { \n      return \n    } \n    c.room.forward <- msg \n  } \n} \nfunc (c *client) write() { \n  defer c.socket.Close() \n  for msg := range c.send { \n    err := c.socket.WriteMessage(websocket.TextMessage, msg) \n    if err != nil { \n      return \n    } \n  } \n} \n\n```", "```go\npackage main \ntype room struct { \n  // forward is a channel that holds incoming messages \n  // that should be forwarded to the other clients. \n  forward chan []byte \n  // join is a channel for clients wishing to join the room. \n  join chan *client \n  // leave is a channel for clients wishing to leave the room. \n  leave chan *client \n  // clients holds all current clients in this room. \n  clients map[*client]bool \n} \n\n```", "```go\nfunc (r *room) run() { \n  for { \n    select { \n    case client := <-r.join: \n      // joining \n      r.clients[client] = true \n    case client := <-r.leave: \n      // leaving \n      delete(r.clients, client) \n      close(client.send) \n    case msg := <-r.forward: \n      // forward message to all clients \n      for client := range r.clients { \n        client.send <- msg \n      } \n    } \n  } \n} \n\n```", "```go\nconst ( \n  socketBufferSize  = 1024 \n  messageBufferSize = 256 \n)  \nvar upgrader = &websocket.Upgrader{ReadBufferSize:  socketBufferSize,\n  WriteBufferSize: socketBufferSize}  \nfunc (r *room) ServeHTTP(w http.ResponseWriter, req *http.Request) { \n  socket, err := upgrader.Upgrade(w, req, nil) \n  if err != nil { \n    log.Fatal(\"ServeHTTP:\", err) \n    return \n  } \n  client := &client{ \n    socket: socket, \n    send:   make(chan []byte, messageBufferSize), \n    room:   r, \n  } \n  r.join <- client \n  defer func() { r.leave <- client }() \n  go client.write() \n  client.read() \n} \n\nTipIf you accessed the chat endpoint in a web browser, you would likely crash the program and see an error like **ServeHTTPwebsocket: version != 13**. This is because it is intended to be accessed via a web socket rather than a web browser.\n```", "```go\nr := &room{ \n  forward: make(chan []byte), \n  join:    make(chan *client), \n  leave:   make(chan *client), \n  clients: make(map[*client]bool), \n} \n\n```", "```go\n// newRoom makes a new room. \nfunc newRoom() *room { \n  return &room{ \n    forward: make(chan []byte), \n    join:    make(chan *client), \n    leave:   make(chan *client), \n    clients: make(map[*client]bool), \n  } \n} \n\n```", "```go\nfunc main() { \n  r := newRoom() \n  http.Handle(\"/\", &templateHandler{filename: \"chat.html\"}) \n  http.Handle(\"/room\", r) \n  // get the room going \n  go r.run() \n  // start the web server \n  if err := http.ListenAndServe(\":8080\", nil); err != nil { \n    log.Fatal(\"ListenAndServe:\", err) \n  } \n} \n\n```", "```go\n<html> \n  <head> \n    <title>Chat</title> \n    <style> \n      input { display: block; } \n      ul    { list-style: none; } \n    </style> \n  </head> \n  <body> \n    <ul id=\"messages\"></ul> \n    <form id=\"chatbox\"> \n      <textarea></textarea> \n      <input type=\"submit\" value=\"Send\" /> \n       </form>  </body> \n</html> \n\n```", "```go\n<script  src=\"img/jquery.min.js\"> </script> \n    <script> \n      $(function(){ \n        var socket = null; \n        var msgBox = $(\"#chatbox textarea\"); \n        var messages = $(\"#messages\"); \n        $(\"#chatbox\").submit(function(){ \n          if (!msgBox.val()) return false; \n          if (!socket) { \n            alert(\"Error: There is no socket connection.\"); \n            return false; \n          } \n          socket.send(msgBox.val()); \n          msgBox.val(\"\"); \n          return false; \n        }); \n        if (!window[\"WebSocket\"]) { \n          alert(\"Error: Your browser does not support web  sockets.\") \n        } else { \n          socket = new WebSocket(\"ws://localhost:8080/room\"); \n          socket.onclose = function() { \n            alert(\"Connection has been closed.\"); \n          } \n          socket.onmessage = function(e) { \n            messages.append($(\"<li>\").text(e.data)); \n          } \n        } \n      }); \n    </script> \n\n```", "```go\nif err := http.ListenAndServe(\":8080\", nil); err != nil { \n  log.Fatal(\"ListenAndServe:\", err) \n} \n\n```", "```go\nsocket = new WebSocket(\"ws://localhost:8080/room\"); \n\n```", "```go\nfunc main() {   \n  var addr = flag.String(\"addr\", \":8080\", \"The addr of the  application.\") \n  flag.Parse() // parse the flags \n  r := newRoom() \n  http.Handle(\"/\", &templateHandler{filename: \"chat.html\"}) \n  http.Handle(\"/room\", r) \n  // get the room going \n  go r.run() \n  // start the web server \n  log.Println(\"Starting web server on\", *addr) \n  if err := http.ListenAndServe(*addr, nil); err != nil { \n    log.Fatal(\"ListenAndServe:\", err) \n  } \n} \n\n```", "```go\nfunc (t *templateHandler) ServeHTTP(w http.ResponseWriter, r  *http.Request) { \n  t.once.Do(func() { \n    t.templ =  template.Must(template.ParseFiles(filepath.Join(\"templates\",\n      t.filename))) \n  }) \n  t.templ.Execute(w, r) \n} \n\n```", "```go\nsocket = new WebSocket(\"ws://{{.Host}}/room\"); \n\n```", "```go\ngo build -o chat \n./chat -addr=\":3000\" \n\n```", "```go\n/chat \n  client.go \n  main.go \n  room.go \n/trace \n\n```", "```go\npackage trace \n// Tracer is the interface that describes an object capable of \n// tracing events throughout code. \ntype Tracer interface { \n  Trace(...interface{}) \n} \n\n```", "```go\npackage trace \nimport ( \n  \"testing\" \n)  \nfunc TestNew(t *testing.T) { \n  t.Error(\"We haven't written our test yet\") \n} \n\n```", "```go\ngo test\n\n```", "```go\n--- FAIL: TestNew (0.00 seconds)\n tracer_test.go:8: We haven't written our test yet\nFAIL\nexit status 1\nFAIL  trace 0.011s\n\n```", "```go\nfunc TestNew(t *testing.T) { \n  var buf bytes.Buffer \n  tracer := New(&buf) \n  if tracer == nil { \n    t.Error(\"Return from New should not be nil\") \n  } else { \n    tracer.Trace(\"Hello trace package.\") \n    if buf.String() != \"Hello trace package.\\n\" { \n      t.Errorf(\"Trace should not write '%s'.\", buf.String()) \n    } \n  } \n\n} \n\n```", "```go\nif true == true { \n  t.Error(\"True should be true\") \n} \n\n```", "```go\nfunc New() {} \n\n```", "```go\n./tracer_test.go:11: too many arguments in call to New\n./tracer_test.go:11: New(&buf) used as value\n\n```", "```go\nfunc New(w io.Writer) {} \n\n```", "```go\nfunc New(w io.Writer) Tracer {} \n\n```", "```go\n./tracer.go:13: missing return at end of function\n\n```", "```go\nfunc New(w io.Writer) Tracer { \n  return nil \n} \n\n```", "```go\ntracer_test.go:14: Return from New should not be nil\n\n```", "```go\ngo test -cover\n\n```", "```go\ntype tracer struct { \n  out io.Writer \n}  \nfunc (t *tracer) Trace(a ...interface{}) {} \n\n```", "```go\nfunc New(w io.Writer) Tracer { \n  return &tracer{out: w} \n} \n\n```", "```go\ntracer_test.go:18: Trace should not write ''.\n\n```", "```go\nfunc (t *tracer) Trace(a ...interface{}) { \n  fmt.Fprint(t.out, a...) \n  fmt.Fprintln(t.out) \n} \n\n```", "```go\ngo test -cover\nPASS\ncoverage: 100.0% of statements\nok    trace 0.011s\n\n```", "```go\ntype room struct { \n  // forward is a channel that holds incoming messages \n  // that should be forwarded to the other clients. \n  forward chan []byte \n  // join is a channel for clients wishing to join the room. \n  join chan *client \n  // leave is a channel for clients wishing to leave the room. \n  leave chan *client \n  // clients holds all current clients in this room. \n  clients map[*client]bool  \n  // tracer will receive trace information of activity \n  // in the room. \n  tracer trace.Tracer \n} \nfunc (r *room) run() { \n  for { \n    select { \n    case client := <-r.join: \n      // joining \n      r.clients[client] = true \n      r.tracer.Trace(\"New client joined\") \n    case client := <-r.leave: \n      // leaving \n      delete(r.clients, client) \n      close(client.send) \n      r.tracer.Trace(\"Client left\") \n    case msg := <-r.forward: \n      r.tracer.Trace(\"Message received: \", string(msg)) \n      // forward message to all clients \n      for client := range r.clients { \n        client.send <- msg \n        r.tracer.Trace(\" -- sent to client\") \n      } \n    } \n  } \n}  \n\n```", "```go\nr := newRoom() \nr.tracer = trace.New(os.Stdout) \n\n```", "```go\nfunc TestOff(t *testing.T) { \n  var silentTracer Tracer = Off() \n  silentTracer.Trace(\"something\") \n} \n\n```", "```go\ntype nilTracer struct{} \n\nfunc (t *nilTracer) Trace(a ...interface{}) {} \n\n// Off creates a Tracer that will ignore calls to Trace. \nfunc Off() Tracer { \n  return &nilTracer{} \n} \n\n```", "```go\nfunc newRoom() *room { \n  return &room{ \n    forward: make(chan []byte), \n    join:    make(chan *client), \n    leave:   make(chan *client), \n    clients: make(map[*client]bool), \n    tracer:  trace.Off(), \n  } \n} \n\n```"]