- en: Chapter 1.  Chat Application with Web Sockets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 基于 WebSocket 的聊天应用程序
- en: Go is great for writing high-performance, concurrent server applications and
    tools, and the Web is the perfect medium over which to deliver them. It would
    be difficult these days to find a gadget that is not web-enabled and this allows
    us to build a single application that targets almost all platforms and devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是编写高性能、并发服务器应用程序和工具的绝佳选择，而网络是交付它们的完美媒介。如今，很难找到不是网络化的设备，这使得我们可以构建一个针对几乎所有平台和设备的单一应用程序。
- en: Our first project will be a web-based chat application that allows multiple
    users to have a real-time conversation right in their web browser. Idiomatic Go
    applications are often composed of many packages, which are organized by having
    code in different folders, and this is also true of the Go standard library. We
    will start by building a simple web server using the `net/http` package, which
    will serve the HTML files. We will then go on to add support for web sockets through
    which our messages will flow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个项目将是一个基于网络的聊天应用程序，它允许多个用户在他们的网络浏览器中进行实时对话。惯用的 Go 应用程序通常由许多包组成，这些包通过在不同的文件夹中放置代码来组织，Go
    标准库也是如此。我们将从使用 `net/http` 包构建一个简单的网络服务器开始，该服务器将提供 HTML 文件。然后我们将继续添加对 WebSocket
    的支持，我们的消息将通过它流动。
- en: In languages such as C#, Java, or Node.js, complex threading code and clever
    use of locks need to be employed in order to keep all clients in sync. As we will
    see, Go helps us enormously with its built-in channels and concurrency paradigms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C#、Java 或 Node.js 等语言中，需要使用复杂的线程代码和锁的巧妙使用来保持所有客户端的同步。正如我们将看到的，Go 通过其内置的通道和并发范式极大地帮助我们。
- en: 'In this chapter, you will learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Use the `net/http` package to serve HTTP requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `net/http` 包来服务 HTTP 请求
- en: Deliver template-driven content to users' browsers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户浏览器提供模板驱动的内容
- en: Satisfy a Go interface to build our own `http.Handler` types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足 Go 接口以构建我们自己的 `http.Handler` 类型
- en: Use Go's goroutines to allow an application to perform multiple tasks concurrently
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 的 goroutines 允许应用程序并发执行多个任务
- en: Use channels to share information between running goroutines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道在运行的 goroutines 之间共享信息
- en: Upgrade HTTP requests to use modern features such as web sockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTTP 请求升级以使用现代功能，如 WebSocket
- en: Add tracing to the application to better understand its inner working
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用程序添加跟踪以更好地理解其内部工作原理
- en: Write a complete Go package using test-driven development practices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试驱动开发实践编写一个完整的 Go 包
- en: Return unexported types through exported interfaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过导出接口返回未导出类型
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this project can be found at [https://github.com/matryer/goblueprints/tree/master/chapter1/chat](https://github.com/matryer/goblueprints/tree/master/chapter1/chat).
    The source code was periodically committed so the history in GitHub actually follows
    the flow of this chapter too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的完整源代码可以在 [https://github.com/matryer/goblueprints/tree/master/chapter1/chat](https://github.com/matryer/goblueprints/tree/master/chapter1/chat)
    找到。源代码定期提交，因此 GitHub 中的历史记录也遵循本章的流程。
- en: A simple web server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的网络服务器
- en: 'The first thing our chat application needs is a web server that has two main
    responsibilities:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天应用程序需要的第一件事是一个具有两个主要职责的网络服务器：
- en: Serving the HTML and JavaScript chat clients that run in the user's browser
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在用户浏览器中运行的 HTML 和 JavaScript 聊天客户端提供服务
- en: Accepting web socket connections to allow the clients to communicate
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 WebSocket 连接以允许客户端进行通信
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GOPATH` environment variable is covered in detail in [Appendix](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Appendix Appendix. Good Practices for a Stable Go Environment"), *Good Practices
    for a Stable Go environment*. Be sure to read that first if you need help getting
    set up.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPATH` 环境变量在 [附录](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "附录 附录. 稳定 Go 环境的最佳实践") 中详细说明，*稳定 Go 环境的最佳实践*。如果您需要帮助设置，请务必先阅读。'
- en: 'Create a `main.go` file inside a new folder called `chat` in your `GOPATH`
    and add the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `GOPATH` 中创建一个名为 `chat` 的新文件夹内的 `main.go` 文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a complete, albeit simple, Go program that will:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整、尽管简单的 Go 程序，它将：
- en: Listen to the root path using the `net/http` package
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `net/http` 包监听根路径
- en: Write out the hardcoded HTML when a request is made
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求时写入硬编码的 HTML
- en: Start a web server on port `:8080` using the `ListenAndServe` method
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ListenAndServe` 方法在端口 `:8080` 上启动网络服务器
- en: The `http.HandleFunc` function maps the path pattern `/` to the function we
    pass as the second argument, so when the user hits `http://localhost:8080/`, the
    function will be executed. The function signature of `func(w http.ResponseWriter,
    r *http.Request)` is a common way of handling HTTP requests throughout the Go
    standard library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.HandleFunc`函数将路径模式`/`映射为我们作为第二个参数传递的函数，因此当用户访问`http://localhost:8080/`时，该函数将被执行。`func(w
    http.ResponseWriter, r *http.Request)`函数签名是Go标准库中处理HTTP请求的常见方式。'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are using `package main` because we want to build and run our program from
    the command line. However, if we were building a reusable chatting package, we
    might choose to use something different, such as `package chat`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`package main`是因为我们想要从命令行构建和运行我们的程序。然而，如果我们正在构建一个可重用的聊天包，我们可能会选择使用不同的包名，例如`package
    chat`。
- en: 'In a terminal, run the program by navigating to the `main.go` file you just
    created and execute the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，通过导航到您刚刚创建的`main.go`文件并执行以下命令来运行程序：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `go run` command is a helpful shortcut for running simple Go programs. It
    builds and executes a binary in one go. In the real world, you usually use `go
    build` yourself to create and distribute binaries. We will explore this later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run`命令是运行简单Go程序的便捷快捷方式。它一次构建并执行一个二进制文件。在现实世界中，你通常使用`go build`自己创建和分发二进制文件。我们将在稍后探讨这一点。'
- en: Open the browser and type `http://localhost:8080` to see the **Let's chat!**
    message.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并输入`http://localhost:8080`以查看**Let's chat!**信息。
- en: Having the HTML code embedded within our Go code like this works, but it is
    pretty ugly and will only get worse as our projects grow. Next, we will see how
    templates can help us clean this up.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将HTML代码嵌入我们的Go代码中像这样是可行的，但它看起来相当丑陋，并且随着我们项目的增长，情况只会变得更糟。接下来，我们将看看模板如何帮助我们清理这个问题。
- en: Separating views from logic using templates
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板将视图与逻辑分离
- en: 'Templates allow us to blend generic text with specific text, for instance,
    injecting a user''s name into a welcome message. For example, consider the following
    template:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许我们将通用文本与特定文本混合，例如，将用户的姓名注入到欢迎信息中。例如，考虑以下模板：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are able to replace the `{{name}}` text in the preceding template with the
    real name of a person. So if Bruce signs in, he might see:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够替换前面模板中的`{{name}}`文本，用一个人的真实姓名替换。所以如果布鲁斯登录，他可能会看到：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Go standard library has two main template packages: one called `text/template`
    for text and one called `html/template` for HTML. The `html/template` package
    does the same as the text version except that it understands the context in which
    data will be injected into the template. This is useful because it avoids script
    injection attacks and resolves common issues such as having to encode special
    characters for URLs.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库有两个主要的模板包：一个叫做`text/template`用于文本，另一个叫做`html/template`用于HTML。`html/template`包与文本版本的功能相同，但它理解数据将被注入模板的上下文。这很有用，因为它避免了脚本注入攻击，并解决了需要为URL编码特殊字符等常见问题。
- en: Initially, we just want to move the HTML code from inside our Go code to its
    own file, but won't blend any text just yet. The template packages make loading
    external files very easy, so it's a good choice for us.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们只想将HTML代码从Go代码内部移动到自己的文件中，但暂时不会混合任何文本。模板包使得加载外部文件变得非常容易，因此对我们来说是一个不错的选择。
- en: 'Create a new folder under our `chat` folder called `templates` and create a `chat.html`
    file inside it. We will move the HTML from `main.go` to this file, but we will
    make a minor change to ensure our changes have taken effect:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`chat`文件夹下创建一个新的文件夹，命名为`templates`，并在其中创建一个`chat.html`文件。我们将把HTML从`main.go`移动到这个文件中，但我们会进行一些小的修改以确保我们的更改生效：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have our external HTML file ready to go, but we need a way to compile
    the template and serve it to the user's browser.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的外部HTML文件已经准备好了，但我们需要一个方法来编译模板并将其提供给用户的浏览器。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Compiling a template is a process by which the source template is interpreted
    and prepared for blending with various data, which must happen before a template
    can be used but only needs to happen once.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编译模板是一个将源模板进行解释并准备与各种数据混合的过程，这必须在模板可以使用之前发生，但只需要发生一次。
- en: We are going to write our own `struct` type that is responsible for loading,
    compiling, and delivering our template. We will define a new type that will take
    a `filename` string, compile the template once (using the `sync.Once` type), keep
    the reference to the compiled template, and then respond to HTTP requests. You
    will need to import the `text/template`, `path/filepath`, and `sync` packages
    in order to build your code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写自己的 `struct` 类型，该类型负责加载、编译和交付我们的模板。我们将定义一个新的类型，它将接受一个 `filename` 字符串，一次性编译模板（使用
    `sync.Once` 类型），保留编译后的模板引用，然后响应 HTTP 请求。你需要导入 `text/template`、`path/filepath`
    和 `sync` 包来构建你的代码。
- en: 'In `main.go`, insert the following code above the `func main()` line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，在 `func main()` 行之前插入以下代码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Did you know that you could automate the adding and removing of imported packages?
    See [Appendix](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Appendix Appendix. Good Practices for a Stable Go Environment"), *Good Practices
    for a Stable Go Environment*, on how to do this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你可以自动化添加和删除导入的包吗？请参阅 [附录](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "附录 附录. 稳定 Go 环境的良好实践")，*稳定 Go 环境的良好实践*，了解如何做到这一点。
- en: The `templateHandler` type has a single method called `ServeHTTP` whose signature
    looks suspiciously like the method we passed to `http.HandleFunc` earlier. This
    method will load the source file, compile the template and execute it, and write
    the output to the specified `http.ResponseWriter` method. Because the `ServeHTTP`
    method satisfies the `http.Handler` interface, we can actually pass it directly
    to `http.Handle`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateHandler` 类型有一个名为 `ServeHTTP` 的单一方法，其签名看起来与之前传递给 `http.HandleFunc`
    的方法非常相似。此方法将加载源文件，编译模板并执行它，然后将输出写入指定的 `http.ResponseWriter` 方法。因为 `ServeHTTP`
    方法满足 `http.Handler` 接口，所以我们可以直接将其传递给 `http.Handle`。'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A quick look at the Go standard library source code, which is located at [http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler),
    will reveal that the interface definition for `http.Handler` specifies that only
    the `ServeHTTP` method need be present in order for a type to be used to serve
    HTTP requests by the `net/http` package.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看位于 [http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler)
    的 Go 标准库源代码，会发现 `http.Handler` 接口定义指定，只有 `ServeHTTP` 方法存在，类型才能被 `net/http` 包用来服务
    HTTP 请求。
- en: Doing things once
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次性完成任务
- en: We only need to compile the template once, and there are a few different ways
    to approach this in Go. The most obvious is to have a `NewTemplateHandler` function
    that creates the type and calls some initialization code to compile the template.
    If we were sure the function would be called by only one goroutine (probably the
    main one during the setup in the `main` function), this would be a perfectly acceptable
    approach. An alternative, which we have employed in the preceding section, is
    to compile the template once inside the `ServeHTTP` method. The `sync.Once` type
    guarantees that the function we pass as an argument will only be executed once,
    regardless of how many goroutines are calling `ServeHTTP`. This is helpful because
    web servers in Go are automatically concurrent and once our chat application takes
    the world by storm, we could very well expect to have many concurrent calls to
    the `ServeHTTP` method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要编译一次模板，在 Go 中有几种不同的方法来实现这一点。最明显的方法是有一个 `NewTemplateHandler` 函数，它创建类型并调用一些初始化代码来编译模板。如果我们确定该函数只会被一个
    goroutine 调用（可能是 `main` 函数中的设置阶段），这将是一个完全可接受的方法。另一种方法，我们在前面的部分中已经使用过，是在 `ServeHTTP`
    方法内部一次性编译模板。`sync.Once` 类型保证我们传递给参数的函数只执行一次，无论有多少个 goroutine 调用 `ServeHTTP`。这很有帮助，因为
    Go 中的 web 服务器是自动并发的，一旦我们的聊天应用风靡全球，我们完全可能期望有多个并发调用 `ServeHTTP` 方法。
- en: Compiling the template inside the `ServeHTTP` method also ensures that our code
    does not waste time doing work before it is definitely needed. This lazy initialization
    approach doesn't save us much in our present case, but in cases where the setup
    tasks are time- and resource-intensive and where the functionality is used less
    frequently, it's easy to see how this approach would come in handy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ServeHTTP` 方法内部编译模板也确保了我们的代码不会在确定需要之前浪费时间做工作。这种惰性初始化方法在我们当前的案例中节省不了多少时间，但在设置任务耗时和资源密集且功能使用频率较低的情况下，很容易看出这种方法会很有用。
- en: Using your own handlers
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自己的处理器
- en: 'To implement our `templateHandler` type, we need to update the `main` body
    function so that it looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的 `templateHandler` 类型，我们需要更新 `main` 函数的主体，使其看起来像这样：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `templateHandler` structure is a valid `http.Handler` type so we can pass
    it directly to the `http.Handle` function and ask it to handle requests that match
    the specified pattern. In the preceding code, we created a new object of the type `templateHandler`,
     specifying the filename as `chat.html` that we then take the address of (using
    the `&` address of the operator) and pass it to the `http.Handle` function. We
    do not store a reference to our newly created `templateHandler` type, but that's
    OK because we don't need to refer to it again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateHandler` 结构体是一个有效的 `http.Handler` 类型，因此我们可以直接将其传递给 `http.Handle` 函数，并要求它处理与指定模式匹配的请求。在之前的代码中，我们创建了一个新的
    `templateHandler` 类型的对象，指定文件名为 `chat.html`，然后我们使用操作符的地址（`&`）获取其地址，并将其传递给 `http.Handle`
    函数。我们没有存储新创建的 `templateHandler` 类型的引用，但这没关系，因为我们不需要再次引用它。'
- en: In your terminal, exit the program by pressing *Ctrl + C* and re-run it, then
    refresh your browser and notice the addition of the (from template) text. Now
    our code is much simpler than an HTML code and free from its ugly blocks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中，通过按 *Ctrl + C* 退出程序，然后重新运行它，然后刷新浏览器，注意（来自模板）文本的添加。现在我们的代码比 HTML 代码简单得多，并且摆脱了其丑陋的块。
- en: Properly building and executing Go programs
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确构建和执行 Go 程序
- en: 'Running Go programs using a `go run` command is great when our code is made
    up of a single `main.go` file. However, often we might quickly need to add other
    files. This requires us to properly build the whole package into an executable
    binary before running it. This is simple enough, and from now on, this is how
    you will build and run your programs in a terminal:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go run` 命令运行 Go 程序在我们代码仅由一个 `main.go` 文件组成时非常棒。然而，我们可能很快就需要添加其他文件。这要求我们在运行之前正确地将整个包构建成一个可执行的二进制文件。这很简单，从现在开始，这就是您在终端中构建和运行程序的方式：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `go build` command creates the output binary using all the `.go` files in
    the specified folder, and the `-o` flag indicates the name of the generated binary.
    You can then just run the program directly by calling it by name.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`go build` 命令使用指定文件夹中的所有 `.go` 文件创建输出二进制文件，`-o` 标志表示生成的二进制文件名。然后您可以直接通过名称调用程序来运行程序。'
- en: 'For example, in the case of our chat application, we could run:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的聊天应用案例中，我们可以运行：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since we are compiling templates the first time the page is served, we will
    need to restart your web server program every time anything changes in order to
    see the changes take effect.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在页面首次提供服务时编译模板，因此每次有任何更改时，我们都需要重新启动您的 Web 服务器程序，以便看到更改生效。
- en: Modeling a chat room and clients on the server
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上模拟聊天室和客户端
- en: All users (clients) of our chat application will automatically be placed in
    one big public room where everyone can chat with everyone else. The `room` type
    will be responsible for managing client connections and routing messages in and
    out, while the `client` type represents the connection to a single client.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天应用的所有用户（客户端）将自动被放置在一个大型的公共聊天室中，每个人都可以与任何人聊天。`room` 类型将负责管理客户端连接和消息的进出路由，而
    `client` 类型代表与单个客户端的连接。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Go refers to classes as types and instances of those classes as objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Go 将类称为类型，将那些类的实例称为对象。
- en: To manage our web sockets, we are going to use one of the most powerful aspects
    of the Go community open source third-party packages. Every day, new packages
    solving real-world problems are released, ready for you to use in your own projects,
    and they even allow you to add features, report and fix bugs, and get support.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理我们的 WebSocket，我们将使用 Go 社区开源第三方包中最强大的功能之一。每天都有新的包解决现实世界的问题发布，供您在自己的项目中使用，它们甚至允许您添加功能、报告和修复错误，并获得支持。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is often unwise to reinvent the wheel unless you have a very good reason.
    So before embarking on building a new package, it is worth searching for any existing
    projects that might have already solved your very problem. If you find one similar
    project that doesn't quite satisfy your needs, consider contributing to the project
    and adding features. Go has a particularly active open source community (remember
    that Go itself is open source) that is always ready to welcome new faces or avatars.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有非常好的理由，否则重新发明轮子通常是不明智的。所以在开始构建一个新的包之前，值得搜索任何可能已经解决了你问题的现有项目。如果你找到一个类似的项目，但它并不完全满足你的需求，考虑为该项目做出贡献并添加功能。Go有一个特别活跃的开源社区（记住Go本身是开源的），它总是准备好欢迎新面孔或头像。
- en: We are going to use Gorilla Project's `websocket` package to handle our server-side
    sockets rather than write our own. If you're curious about how it works, head
    over to the project home page on GitHub, [https://github.com/gorilla/websocket](https://github.com/gorilla/websocket),
    and browse the open source code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Gorilla Project的`websocket`包来处理我们的服务器端套接字，而不是自己编写。如果你对它是如何工作的感到好奇，请前往GitHub上的项目主页[https://github.com/gorilla/websocket](https://github.com/gorilla/websocket)，并浏览开源代码。
- en: Modeling the client
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端建模
- en: 'Create a new file called `client.go` alongside `main.go` in the `chat` folder
    and add the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`文件夹中与`main.go`文件并列创建一个名为`client.go`的新文件，并添加以下代码：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, `socket` will hold a reference to the web socket that
    will allow us to communicate with the client, and the `send` field is a buffered
    channel through which received messages are queued ready to be forwarded to the
    user's browser (via the socket). The `room` field will keep a reference to the
    room that the client is chatting in this is required so that we can forward messages
    to everyone else in the room.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`socket`将持有对网络套接字的引用，这将允许我们与客户端通信，而`send`字段是一个缓冲通道，通过它接收到的消息被排队，准备转发到用户的浏览器（通过套接字）。`room`字段将保持对客户端正在聊天的房间的引用，这是必要的，这样我们才能将消息转发给房间中的其他所有人。
- en: 'If you try to build this code, you will notice a few errors. You must ensure
    that you have called `go get` to retrieve the `websocket` package, which is as
    easy as opening a terminal and typing the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试构建此代码，你会注意到一些错误。你必须确保你已经调用`go get`来检索`websocket`包，这就像打开一个终端并输入以下内容一样简单：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Building the code again will yield another error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建代码将产生另一个错误：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The problem is that we have referred to a `room` type without defining it anywhere.
    To make the compiler happy, create a file called `room.go` and insert the following
    placeholder code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们引用了一个`room`类型，但没有在任何地方定义它。为了让编译器高兴，创建一个名为`room.go`的文件，并插入以下占位符代码：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will improve this definition later once we know a little more about what
    our room needs to do, but for now, this will allow us to proceed. Later, the `forward`
    channel is what we will use to send the incoming messages to all other clients.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在了解我们的房间需要做什么之后，稍后改进这个定义，但现在这将允许我们继续前进。稍后，`forward`通道是我们将用来将传入的消息发送给所有其他客户端的通道。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can think of channels as an in-memory thread-safe message queue where senders
    pass data and receivers read data in a non-blocking, thread-safe way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将通道想象成一个内存中的线程安全消息队列，发送者通过它传递数据，接收者以非阻塞、线程安全的方式读取数据。
- en: 'In order for a client to do any work, we must define some methods that will
    do the actual reading and writing to and from the web socket. Adding the following
    code to `client.go` outside (underneath) the `client` struct will add two methods
    called `read` and `write` to the `client` type:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端做任何工作，我们必须定义一些方法，这些方法将执行实际的读取和写入操作，从/到网络套接字。将以下代码添加到`client.go`文件中（在`client`结构体外部下方）将为`client`类型添加两个名为`read`和`write`的方法：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `read` method allows our client to read from the socket via the `ReadMessage`
    method, continually sending any received messages to the `forward` channel on
    the `room` type. If it encounters an error (such as `'the socket has died'`),
    the loop will break and the socket will be closed. Similarly, the `write` method
    continually accepts messages from the `send` channel writing everything out of
    the socket via the `WriteMessage` method. If writing to the socket fails, the `for`
    loop is broken and the socket is closed. Build the package again to ensure everything
    compiles.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法允许我们的客户端通过`ReadMessage`方法从套接字读取，并将接收到的任何消息持续发送到`room`类型的`forward`通道。如果遇到错误（例如`''the
    socket has died''`），循环将中断，套接字将被关闭。同样，`write`方法持续从`send`通道接收消息，并通过`WriteMessage`方法将所有内容写入套接字。如果写入套接字失败，`for`循环将中断，套接字将被关闭。再次构建包以确保一切都能编译。'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code, we introduced the `defer` keyword, which is worth exploring
    a little. We are asking Go to run `c.socket.Close()` when the function exits.
    It's extremely useful for when you need to do some tidying up in a function (such
    as closing a file or, as in our case, a socket) but aren't sure where the function
    will exit. As our code grows, if this function has multiple `return` statements,
    we won't need to add any more calls to close the socket, because this single `defer`
    statement will catch them all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们介绍了`defer`关键字，这值得稍微探索一下。我们要求Go在函数退出时运行`c.socket.Close()`。这在需要在一个函数中做一些清理工作（例如关闭文件或，在我们的例子中，关闭套接字）但不确定函数将在哪里退出时非常有用。随着代码的增长，如果这个函数有多个`return`语句，我们就不需要添加更多关闭套接字的调用，因为这个单独的`defer`语句会捕获它们所有。
- en: Some people complain about the performance of using the `defer` keyword, since
    it doesn't perform as well as typing the `close` statement before every exit point
    in the function. You must weigh up the runtime performance cost against the code
    maintenance cost and potential bugs that may get introduced if you decide not
    to use defer. As a general rule of thumb, writing clean and clear code wins; after
    all, we can always come back and optimize any bits of code we feel is slowing
    our product down if we are lucky enough to have such success.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人抱怨使用`defer`关键字时的性能，因为它不如在函数的每个退出点之前键入`close`语句那样表现得好。你必须权衡运行时性能成本与代码维护成本以及可能引入的潜在错误。一般来说，编写干净、清晰的代码是获胜的关键；毕竟，如果我们足够幸运，我们总是可以回来优化我们认为会减慢我们的产品速度的任何代码片段。
- en: Modeling a room
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模房间
- en: 'We need a way for clients to join and leave rooms in order to ensure that the `c.room.forward
    <- msg` code in the preceding section actually forwards the message to all the
    clients. To ensure that we are not trying to access the same data at the same
    time, a sensible approach is to use two channels: one that will add a client to
    the room and another that will remove it. Let''s update our `room.go` code to
    look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法让客户端能够加入和离开房间，以确保上一节中的`c.room.forward <- msg`代码实际上将消息转发给所有客户端。为了确保我们不会同时尝试访问相同的数据，一个合理的方法是使用两个通道：一个用于将客户端添加到房间，另一个用于将其移除。让我们更新我们的`room.go`代码，使其看起来像这样：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have added three fields: two channels and a map. The `join` and `leave`
    channels exist simply to allow us to safely add and remove clients from the `clients`
    map. If we were to access the map directly, it is possible that two goroutines
    running concurrently might try to modify the map at the same time, resulting in
    corrupt memory or unpredictable state.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了三个字段：两个通道和一个映射。`join`和`leave`通道仅仅是为了允许我们安全地向`clients`映射添加和移除客户端。如果我们直接访问映射，可能两个并发运行的goroutine会尝试同时修改映射，从而导致内存损坏或不可预测的状态。
- en: Concurrency programming using idiomatic Go
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用惯用的Go进行并发编程
- en: Now we get to use an extremely powerful feature of Go's concurrency offerings
    the `select` statement. We can use `select` statements whenever we need to synchronize
    or modify shared memory, or take different actions depending on the various activities
    within our channels.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Go并发提供的非常强大的功能——`select`语句。当我们需要同步或修改共享内存，或者根据我们通道中的各种活动采取不同的操作时，我们可以使用`select`语句。
- en: 'Beneath the `room` structure, add the following `run` method that contains
    three `select` cases:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`room`结构体下面，添加以下包含三个`select`情况的`run`方法：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although this might seem like a lot of code to digest, once we break it down
    a little, we will see that it is fairly simple, although extremely powerful. The
    top `for` loop indicates that this method will run forever, until the program
    is terminated. This might seem like a mistake, but remember, if we run this code
    as a goroutine, it will run in the background, which won't block the rest of our
    application. The preceding code will keep watching the three channels inside our
    room: `join`, `leave`, and `forward`. If a message is received on any of those
    channels, the `select` statement will run the code for that particular case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能是一大堆难以消化的代码，但如果我们稍微分解一下，我们会看到它相当简单，尽管非常强大。顶部的`for`循环表示该方法将永远运行，直到程序终止。这看起来可能像是一个错误，但请记住，如果我们以goroutine的形式运行此代码，它将在后台运行，这不会阻塞我们的应用程序的其他部分。前面的代码将不断监视房间内的三个通道：`join`、`leave`和`forward`。如果任何这些通道收到消息，`select`语句将运行特定情况的代码。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to remember that it will only run one block of case code at
    a time. This is how we are able to synchronize to ensure that our `r.clients`
    map is only ever modified by one thing at a time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，它一次只会运行一个代码块。这就是我们能够同步以确保我们的`r.clients`映射一次只被一件事修改的原因。
- en: If we receive a message on the `join` channel, we simply update the `r.clients`
    map to keep a reference of the client that has joined the room. Notice that we
    are setting the value to `true`. We are using the map more like a slice, but do
    not have to worry about shrinking the slice as clients come and go through time
    setting the value to `true` is just a handy, low-memory way of storing the reference.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`join`通道上收到消息，我们只需更新`r.clients`映射以保持对已加入房间的客户端的引用。请注意，我们将值设置为`true`。我们更像是使用切片，但不必担心随着客户端的来去而缩小切片，将值设置为`true`只是存储引用的一种方便、低内存的方式。
- en: If we receive a message on the `leave` channel, we simply delete the `client`
    type from the map, and close its `send` channel. If we receive a message on the `forward`
    channel, we iterate over all the clients and add the message to each client's `send`
    channel. Then, the `write` method of our client type will pick it up and send
    it down the socket to the browser.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`leave`通道上收到消息，我们只需从映射中删除`client`类型，并关闭其`send`通道。如果我们收到`forward`通道上的消息，我们将遍历所有客户端并将消息添加到每个客户端的`send`通道。然后，我们的客户端类型的`write`方法将取回它并通过套接字发送到浏览器。
- en: Turning a room into an HTTP handler
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将房间转换为HTTP处理程序
- en: Now we are going to turn our `room` type into an `http.Handler` type like we
    did with the template handler earlier. As you will recall, to do this, we must
    simply add a method called `ServeHTTP` with the appropriate signature.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将我们的`room`类型转换为`http.Handler`类型，就像我们之前对模板处理程序所做的那样。如您所回忆的，要做到这一点，我们必须简单地添加一个名为`ServeHTTP`的方法，并具有适当的签名。
- en: 'Add the following code to the bottom of the `room.go` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`room.go`文件的底部：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In order to use web sockets, we must upgrade the HTTP connection using the `websocket.Upgrader`
    type, which is reusable so we need only create one. Then, when a request comes
    in via the `ServeHTTP` method, we get the socket by calling the `upgrader.Upgrade`
    method. All being well, we then create our client and pass it into the `join`
    channel for the current room. We also defer the leaving operation for when the
    client is finished, which will ensure everything is tidied up after a user goes
    away.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用WebSockets，我们必须使用`websocket.Upgrader`类型升级HTTP连接，它是可重用的，所以我们只需要创建一个。然后，当通过`ServeHTTP`方法收到请求时，我们通过调用`upgrader.Upgrade`方法来获取套接字。如果一切顺利，我们然后创建我们的客户端并将其传递到当前房间的`join`通道。我们还推迟了客户端完成后的离开操作，这将确保在用户离开后一切都会整理干净。
- en: The `write` method for the client is then called as a goroutine, as indicated
    by the three characters at the beginning of the line `go` (the word `go` followed
    by a space character). This tells Go to run the method in a different thread or
    goroutine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的`write`方法随后作为goroutine调用，如行首的三个字符`go`（单词`go`后跟一个空格字符）所示。这告诉Go在另一个线程或goroutine中运行该方法。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Compare the amount of code needed to achieve multithreading or concurrency in
    other languages with the three key presses that achieve it in Go, and you will
    see why it has become a favorite among system developers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将在其他语言中实现多线程或并发的代码量与Go中实现它的三个按键进行比较，您将了解为什么它已成为系统开发人员中的宠儿。
- en: Finally, we call the `read` method in the main thread, which will block operations
    (keeping the connection alive) until it's time to close it. Adding constants at
    the top of the snippet is a good practice for declaring values that would otherwise
    be hardcoded throughout the project. As these grow in number, you might consider
    putting them in a file of their own, or at least at the top of their respective
    files so they remain easy to read and modify.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在主线程中调用 `read` 方法，这将阻塞操作（保持连接活跃）直到关闭它。在代码片段顶部添加常量是声明那些在其他地方硬编码的值的良好实践。随着这些值的增加，你可能考虑将它们放在一个单独的文件中，或者至少在各自的文件顶部，以便它们易于阅读和修改。
- en: Using helper functions to remove complexity
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用辅助函数来减少复杂性
- en: 'Our room is almost ready to go, although in order for it to be of any use,
    the channels and map need to be created. As it is, this could be achieved by asking
    the developer to use the following code to be sure to do this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的房间几乎准备好了，尽管为了使其有用，需要创建通道和地图。目前，这可以通过要求开发者使用以下代码来确保完成这项工作：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another, slightly more elegant, solution is to instead provide a `newRoom`
    function that does this for us. This removes the need for others to know about
    exactly what needs to be done in order for our room to be useful. Underneath the `type
    room struct` definition, add this function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个稍微更优雅的解决方案是提供一个 `newRoom` 函数，为我们完成这项工作。这消除了其他人了解为了使我们的房间有用需要做什么的必要。在 `type
    room struct` 定义下方添加此函数：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the users of our code need only call the `newRoom` function instead of the
    more verbose six lines of code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码用户只需要调用 `newRoom` 函数，而不是更冗长的六行代码。
- en: Creating and using rooms
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用房间
- en: 'Let''s update our `main` function in `main.go` to first create and then run
    a room for everybody to connect to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `main.go` 中的 `main` 函数，首先创建一个房间，然后运行一个供所有人连接的房间：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are running the room in a separate goroutine (notice the `go` keyword again)
    so that the chatting operations occur in the background, allowing our main goroutine
    to run the web server. Our server is now finished and successfully built, but
    remains useless without clients to interact with.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个单独的 goroutine 中运行房间（再次注意 `go` 关键字），这样聊天操作就会在后台进行，允许我们的主 goroutine 运行网络服务器。我们的服务器现在已经完成并成功构建，但没有客户端与之交互就毫无用处。
- en: Building an HTML and JavaScript chat client
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建HTML和JavaScript聊天客户端
- en: In order for the users of our chat application to interact with the server and
    therefore other users, we need to write some client-side code that makes use of
    the web sockets found in modern browsers. We are already delivering HTML content
    via the template when users hit the root of our application, so we can enhance
    that.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的聊天应用的用户能够与服务器以及其他用户交互，我们需要编写一些客户端代码，利用现代浏览器中找到的 Web Sockets。当用户点击我们应用的根目录时，我们已经在通过模板传递HTML内容，因此我们可以增强这一点。
- en: 'Update the `chat.html` file in the `templates` folder with the following markup:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `templates` 文件夹中的 `chat.html` 文件更新以下标记：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding HTML will render a simple web form on the page containing a text
    area and a **Send** button this is how our users will submit messages to the server.
    The `messages` element in the preceding code will contain the text of the chat
    messages so that all the users can see what is being said. Next, we need to add
    some JavaScript to add some functionality to our page. Underneath the `form` tag,
    above the closing `</body>` tag, insert the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述HTML将在页面上渲染一个简单的表单，包含一个文本区域和一个 **发送** 按钮，这是用户向服务器提交消息的方式。上述代码中的 `messages`
    元素将包含聊天消息的文本，以便所有用户都能看到正在说的话。接下来，我们需要添加一些JavaScript来为我们的页面添加一些功能。在 `form` 标签下方，在关闭
    `</body>` 标签上方，插入以下代码：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `socket = new WebSocket("ws://localhost:8080/room")` line is where we open
    the socket and add event handlers for two key events: `onclose` and `onmessage`.
    When the socket receives a message, we use jQuery to append the message to the
    list element and thus present it to the user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket = new WebSocket("ws://localhost:8080/room")` 这一行是打开套接字并为两个关键事件 `onclose`
    和 `onmessage` 添加事件处理程序的地方。当套接字接收到消息时，我们使用 jQuery 将消息追加到列表元素中，从而将其展示给用户。'
- en: Submitting the HTML form triggers a call to `socket.send`, which is how we send
    messages to the server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提交HTML表单会触发对 `socket.send` 的调用，这是我们向服务器发送消息的方式。
- en: Build and run the program again to ensure the templates recompile so these changes
    are represented.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建并运行程序以确保模板重新编译，以便反映这些更改。
- en: 'Navigate to `http://localhost:8080/` in two separate browsers (or two tabs
    of the same browser) and play with the application. You will notice that messages
    sent from one client appear instantly in the other clients:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的浏览器（或同一浏览器的两个标签页）中导航到`http://localhost:8080/`并玩转这个应用。你会注意到从一个客户端发送的消息会立即出现在其他客户端：
- en: '![Building an HTML and JavaScript chat client](img/00044.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![构建HTML和JavaScript聊天客户端](img/00044.jpeg)'
- en: Getting more out of templates
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模板中获得更多
- en: Currently, we are using templates to deliver static HTML, which is nice because
    it gives us a clean and simple way to separate the client code from the server
    code. However, templates are actually much more powerful, and we are going to
    tweak our application to make some more realistic use of them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用模板来提供静态HTML，这很好，因为它为我们提供了一个干净简单的方法来将客户端代码与服务器端代码分离。然而，模板实际上功能更强大，我们将调整我们的应用程序以更现实地使用它们。
- en: 'The host address of our application (`:8080`) is hardcoded at two places at
    the moment. The first instance is in `main.go` where we start the web server:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序的主机地址（`:8080`）在两个地方硬编码。第一个实例是在`main.go`中，我们启动了Web服务器：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second time it is hardcoded in the JavaScript when we open the socket:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次在打开套接字时硬编码在JavaScript中：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our chat application is pretty stubborn if it insists on only running locally
    on port `8080`, so we are going to use command-line flags to make it configurable
    and then use the injection capabilities of templates to make sure our JavaScript
    knows the right host.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用如果坚持只在本地的`8080`端口上运行，就会显得相当固执，因此我们将使用命令行标志来使其可配置，然后利用模板的注入功能确保我们的JavaScript知道正确的宿主。
- en: 'Update your `main` function in `main.go`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`main.go`中的`main`函数：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will need to import the `flag` package in order for this code to build.
    The definition for the `addr` variable sets up our flag as a string that defaults
    to `:8080` (with a short description of what the value is intended for). We must
    call `flag.Parse()` that parses the arguments and extracts the appropriate information.
    Then, we can reference the value of the host flag by using `*addr`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码构建，你需要导入`flag`包。`addr`变量的定义将我们的标志设置为一个默认值为`:8080`的字符串（带有对值用途的简短描述）。我们必须调用`flag.Parse()`来解析参数并提取适当的信息。然后，我们可以通过使用`*addr`来引用主机标志的值。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call to `flag.String` returns a type of `*string`, which is to say it returns
    the address of a string variable where the value of the flag is stored. To get
    the value itself (and not the address of the value), we must use the pointer indirection
    operator, `*`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag.String`的调用返回一个`*string`类型，这意味着它返回一个字符串变量的地址，其中存储了标志的值。为了获取值本身（而不是值的地址），我们必须使用指针间接运算符，`*`。'
- en: We also added a `log.Println` call to output the address in the terminal so
    we can be sure that our changes have taken effect.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`log.Println`调用，以便在终端输出地址，这样我们就可以确保我们的更改已经生效。
- en: 'We are going to modify the `templateHandler` type we wrote so that it passes
    the details of the request as data into the template''s `Execute` method. In `main.go`,
    update the `ServeHTTP` function to pass the request `r` as the `data` argument
    to the `Execute` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们编写的`templateHandler`类型，使其将请求的详细信息作为数据传递给模板的`Execute`方法。在`main.go`中，更新`ServeHTTP`函数，将请求`r`作为`data`参数传递给`Execute`方法：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This tells the template to render itself using data that can be extracted from `http.Request`,
    which happens to include the host address that we need.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉模板使用可以从`http.Request`中提取的数据来渲染自身，这恰好包括我们需要的宿主地址。
- en: 'To use the `Host` value of `http.Request`, we can then make use of the special
    template syntax that allows us to inject data. Update the line where we create
    our socket in the `chat.html` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`http.Request`的`Host`值，我们可以利用特殊的模板语法，允许我们注入数据。更新在`chat.html`文件中创建套接字的行：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The double curly braces represent an annotation and the way we tell our template
    source to inject data. The `{{.Host}}` is essentially equivalent of telling it
    to replace the annotation with the value from `request.Host` (since we passed
    the request `r` object in as data).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 双大括号表示注释，以及我们告诉模板源注入数据的方式。`{{.Host}}`基本上等同于告诉它用`request.Host`的值替换注释（因为我们作为数据传递了请求`r`对象）。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We have only scratched the surface of the power of the templates built into
    Go's standard library. The `text/template` package documentation is a great place
    to learn more about what you can achieve. You can find more about it at [http://golang.org/pkg/text/template](http://golang.org/pkg/text/template).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了Go标准库内置的模板的强大功能的一角。《text/template》包文档是一个学习更多关于你可以实现什么的好地方。你可以在[http://golang.org/pkg/text/template](http://golang.org/pkg/text/template)了解更多。
- en: 'Rebuild and run the chat program again, but this time notice that the chatting
    operations no longer produce an error, whichever host we specify:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次重建并运行聊天程序，但这次请注意，无论我们指定哪个主机，聊天操作都不会产生错误：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: View the source of the page in the browser and notice that `{{.Host}}` has been
    replaced with the actual host of the application. Valid hosts aren't just port
    numbers; you can also specify the IP addresses or other hostnames provided they
    are allowed in your environment, for example, `-addr="192.168.0.1:3000"`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看页面的源代码，并注意`{{.Host}}`已被实际的应用程序主机名替换。有效的宿主不仅限于端口号；您还可以指定环境允许的IP地址或其他主机名，例如，`-addr="192.168.0.1:3000"`。
- en: Tracing code to get a look under the hood
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写跟踪代码以查看内部结构
- en: The only way we will know that our application is working is by opening two
    or more browsers and using our UI to send messages. In other words, we are manually
    testing our code. This is fine for experimental projects such as our chat application
    or small projects that aren't expected to grow, but if our code is to have a longer
    life or be worked on by more than one person, manual testing of this kind becomes
    a liability. We are not going to tackle **Test-driven Development** (**TDD**)
    for our chat program, but we should explore another useful debugging technique
    called **tracing**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的应用程序正在工作的唯一方法是通过打开两个或更多浏览器并使用我们的UI发送消息。换句话说，我们正在手动测试我们的代码。这对于像我们的聊天应用这样的实验性项目或预期不会增长的小项目来说是可以的，但如果我们的代码要有一个更长的生命周期或由多个人共同工作，这种手动测试就成为一种负担。我们不会在我们的聊天程序中处理**测试驱动开发**（**TDD**），但我们应该探索另一种有用的调试技术，称为**跟踪**。
- en: Tracing is a practice by which we log or print key steps in the flow of a program
    to make what is going on under the covers visible. In the previous section, we
    added a `log.Println` call to output the address that the chat program was binding
    to. In this section, we are going to formalize this and write our own complete
    tracing package.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪是一种实践，通过它我们在程序的流程中记录或打印关键步骤，以便使底层的操作变得可见。在前一节中，我们添加了一个`log.Println`调用，以输出聊天程序正在绑定的地址。在本节中，我们将正式化这一过程，并编写我们自己的完整跟踪包。
- en: We are going to explore TDD practices when writing our tracing code because
    TDD is a perfect example of a package that we are likely to reuse, add to, share,
    and hopefully, even open source.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在编写跟踪代码时探索TDD实践，因为TDD是我们可能重用、添加、共享，甚至希望开源的包的完美示例。
- en: Writing a package using TDD
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TDD编写包
- en: Packages in Go are organized into folders, with one package per folder. It is
    a build error to have differing package declarations within the same folder because
    all sibling files are expected to contribute to a single package. Go has no concept
    of subpackages, which means nested packages (in nested folders) exist only for
    aesthetic or informational reasons but do not inherit any functionality or visibility
    from super packages. In our chat application, all of our files contributed to
    the `main` package because we wanted to build an executable tool. Our tracing
    package will never be run directly, so it can and should use a different package
    name. We will also need to think about the **Application Programming Interface**
    (**API**) of our package, considering how to model a package so that it remains
    as extensible and flexible as possible for users. This includes the fields, functions,
    methods, and types that should be exported (visible to the user) and remain hidden
    for simplicity's sake.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的包组织到文件夹中，每个文件夹一个包。在同一个文件夹内有不同的包声明是一个构建错误，因为所有兄弟文件都预期为单个包做出贡献。Go没有子包的概念，这意味着嵌套包（在嵌套文件夹中）仅存在于美学或信息目的，但不从父包继承任何功能或可见性。在我们的聊天应用中，所有文件都贡献给了`main`包，因为我们想构建一个可执行工具。我们的跟踪包永远不会直接运行，因此它可以，并且应该使用不同的包名。我们还需要考虑我们包的**应用程序编程接口**（**API**），考虑如何构建一个包，使其尽可能地对用户具有可扩展性和灵活性。这包括应该导出（对用户可见）并为了简单起见保持隐藏的字段、函数、方法和类型。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go uses capitalization of names to denote which items are exported such that
    names that begin with a capital letter (for example, `Tracer`) are visible to
    users of a package, and names that begin with a lowercase letter (for example, `templateHandler`)
    are hidden or private.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用名称的大写来表示哪些项是导出的，这意味着以大写字母开头的名称（例如，`Tracer`）对包的用户是可见的，而以小写字母开头的名称（例如，`templateHandler`）是隐藏的或私有的。
- en: 'Create a new folder called `trace`, which will be the name of our tracing package,
    alongside the `chat` folder so that the folder structure now looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`文件夹旁边创建一个名为`trace`的新文件夹，这样文件夹结构现在看起来是这样的：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before we jump into code, let''s agree on some design goals for our package
    by which we can measure success:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们就我们的包的一些设计目标达成一致，这样我们就可以衡量成功：
- en: The package should be easy to use
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该包应该易于使用
- en: Unit tests should cover the functionality
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应涵盖功能
- en: Users should have the flexibility to replace the tracer with their own implementation
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该有灵活性，可以用自己的实现替换跟踪器
- en: Interfaces
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces in Go are an extremely powerful language feature that allows us to
    define an API without being strict or specific on the implementation details.
    Wherever possible, describing the basic building blocks of your packages using
    interfaces usually ends up paying dividends down the road, and this is where we
    will start for our tracing package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的接口是一个非常强大的语言特性，它允许我们定义一个API，而不必在实现细节上过于严格或具体。 wherever possible，使用接口描述你的包的基本构建块通常会在未来带来回报，这就是我们将从我们的跟踪包开始的地方。
- en: 'Create a new file called `tracer.go` inside the `trace` folder and write the
    following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trace`文件夹内创建一个名为`tracer.go`的新文件，并编写以下代码：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first thing to notice is that we have defined our package as `trace`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们已经将我们的包定义为`trace`。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it is a good practice to have the folder name match the package name,
    Go tools do not enforce it, which means you are free to name them differently
    if it makes sense. Remember, when people import your package, they will type the
    name of the folder, and if suddenly a package with a different name is imported,
    it could get confusing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然让文件夹名称与包名称匹配是一个好习惯，但Go工具并不强制执行这一点，这意味着如果你觉得有意义，你可以自由地给它们不同的名称。记住，当人们导入你的包时，他们会输入文件夹的名称，如果突然导入了一个不同名称的包，可能会造成混淆。
- en: Our `Tracer` type (the capital `T` means we intend this to be a publicly visible
    type) is an interface that describes a single method called `Trace`. The `...interface{}`
    argument type states that our `Trace` method will accept zero or more arguments
    of any type. You might think that this is a redundant provision as the method
    should just take a single string (we want to just trace out some string of characters,
    don't we?). However, consider functions such as `fmt.Sprint` and `log.Fatal`,
    both of which follow a pattern littered throughout Go's standard library that
    provides a helpful shortcut when trying to communicate multiple things in one
    go. Wherever possible, we should follow such patterns and practices because we
    want our own APIs to be familiar and clear to the Go community.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Tracer`类型（大写`T`表示我们打算将其作为一个公开可见的类型）是一个接口，它描述了一个名为`Trace`的单个方法。`...interface{}`参数类型表示我们的`Trace`方法将接受零个或多个任何类型的参数。你可能认为这是一个冗余的规定，因为该方法应该只接受一个字符串（我们只想追踪一些字符字符串，不是吗？）。然而，考虑像`fmt.Sprint`和`log.Fatal`这样的函数，它们都遵循Go标准库中普遍存在的模式，在尝试一次性传达多个事物时提供了一个有用的快捷方式。
    wherever possible，我们应该遵循这样的模式和做法，因为我们希望我们的API对Go社区来说既熟悉又清晰。
- en: Unit tests
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: We promised ourselves that we would follow test-driven practices, but interfaces
    are simply definitions that do not provide any implementation and so cannot be
    directly tested. But we are about to write a real implementation of a `Tracer`
    method, and we will indeed write the tests first.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承诺自己会遵循测试驱动实践，但接口只是定义，不提供任何实现，因此不能直接进行测试。但我们即将编写一个真正的`Tracer`方法实现，我们确实会先编写测试。
- en: 'Create a new file called `tracer_test.go` in the `trace` folder and insert
    the following scaffold code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trace`文件夹中创建一个名为`tracer_test.go`的新文件，并插入以下脚手架代码：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Testing was built into the Go tool chain from the very beginning, making writing
    automatable tests a first-class citizen. The test code lives alongside the production
    code in files suffixed with `_test.go`. The Go tools will treat any function that
    starts with `Test` (taking a single `*testing.T` argument) as a unit test, and
    it will be executed when we run our tests. To run them for this package, navigate
    to the `trace` folder in a terminal and do the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 测试从一开始就被构建到Go工具链中，使得编写可自动化的测试成为一等公民。测试代码与生产代码一起生活在以`_test.go`结尾的文件中。Go工具将任何以`Test`开头（接受单个`*testing.T`参数）的函数视为单元测试，并且当运行我们的测试时将执行它。要为此包运行它们，在终端中导航到`trace`文件夹，并执行以下操作：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will see that our tests fail because of our call to `t.Error` in the body
    of our `TestNew` function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现我们的测试失败是因为我们在`TestNew`函数体中调用了`t.Error`：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Clearing the terminal before each test run is a great way to make sure you aren't
    confusing previous runs with the most recent one. On Windows, you can use the `cls`
    command; on Unix machines, the `clear` command does the same thing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试运行之前清除终端是一个很好的方法，以确保你不会将之前的运行与最近的运行混淆。在Windows上，你可以使用`cls`命令；在Unix机器上，`clear`命令做同样的事情。
- en: 'Obviously, we haven''t properly written our test and we don''t expect it to
    pass yet, so let''s update the `TestNew` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们没有正确编写我们的测试，并且我们不期望它通过，所以让我们更新`TestNew`函数：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Most packages throughout the book are available from the Go standard library,
    so you can add an `import` statement for the appropriate package in order to access
    the package. Others are external, and that's when you need to use `go get` to
    download them before they can be imported. For this case, you'll need to add `import
    "bytes"` to the top of the file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的大多数包都来自Go标准库，所以你可以添加适当的包的`import`语句来访问该包。其他的是外部的，这时你需要使用`go get`来下载它们，然后才能导入。对于这个案例，你需要在文件顶部添加`import
    "bytes"`。
- en: We have started designing our API by becoming the first user of it. We want
    to be able to capture the output of our tracer in a `bytes.Buffer` variable so
    that we can then ensure that the string in the buffer matches the expected value.
    If it does not, a call to `t.Errorf` will fail the test. Before that, we check
    to make sure the return from a made-up `New` function is not `nil`; again, if
    it is, the test will fail because of the call to `t.Error`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过成为它的第一个用户来开始设计我们的API。我们希望能够在`bytes.Buffer`变量中捕获我们的跟踪器的输出，这样我们就可以确保缓冲区中的字符串与预期值匹配。如果不匹配，调用`t.Errorf`将使测试失败。在此之前，我们检查确保从虚构的`New`函数返回的不是`nil`；如果是，测试将因为调用`t.Error`而失败。
- en: Red-green testing
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 红绿测试
- en: Running `go test` now actually produces an error; it complains that there is
    no `New` function. We haven't made a mistake here; we are following a practice
    known as red-green testing. Red-green testing proposes that we first write a unit
    test, see it fail (or produce an error), write the minimum amount of code possible
    to make that test pass, and rinse and repeat it again. The key point here being
    that we want to make sure the code we add is actually doing something as well
    as ensuring that the test code we write is testing something meaningful.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`go test`实际上会产生一个错误；它抱怨没有`New`函数。我们在这里没有犯错误；我们正在遵循一种称为红绿测试的实践。红绿测试建议我们首先编写一个单元测试，看到它失败（或产生错误），编写尽可能少的代码来使该测试通过，然后重复这个过程。这里的关键点是，我们想要确保我们添加的代码实际上在做一些事情，同时确保我们编写的测试代码在测试有意义的内容。
- en: 'Consider a meaningless test for a minute:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下一个无意义的测试一分钟：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is logically impossible for `true` to not be  true (if `true` ever equals `false`,
    it's time to get a new computer), and so our test is pointless. If a test or claim
    cannot fail, there is no value whatsoever to be found in it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`true`不可能是`true`（如果`true`等于`false`，那么是时候换一台新电脑了）在逻辑上是不可能的，因此我们的测试是毫无意义的。如果一个测试或声明无法失败，那么在其中找不到任何价值。
- en: Replacing `true` with a variable that you expect to be set to `true` under certain
    conditions would mean that such a test can indeed fail (like when the code being
    tested is misbehaving) at this point, you have a meaningful test that is worth
    contributing to the code base.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 用你期望在特定条件下设置为`true`的变量替换`true`意味着这样的测试确实可以失败（比如当被测试的代码行为不当时），在这个时候，你有一个有意义的测试，值得贡献给代码库。
- en: 'You can treat the output of `go test` like a to-do list, solving only one problem
    at a time. Right now, the complaint about the missing `New` function is all we
    will address. In the `trace.go` file, let''s add the minimum amount of code possible
    to progress with things; add the following snippet underneath the interface type
    definition:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`go test`的输出视为一个待办事项列表，一次只解决一个问题。目前，关于缺少`New`函数的抱怨是我们唯一要解决的问题。在`trace.go`文件中，让我们添加尽可能少的代码来推进事情；在接口类型定义下方添加以下片段：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running `go test` now shows us that things have indeed progressed, albeit not
    very far. We now have two errors:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`go test`显示我们的确取得了一些进展，尽管进展不大。我们现在有两个错误：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first error tells us that we are passing arguments to our `New` function,
    but the `New` function doesn''t accept any. The second error says that we are
    using the return of the `New` function as a value, but that the `New` function
    doesn''t return anything. You might have seen this coming, and indeed as you gain
    more experience writing test-driven code, you will most likely jump over such
    trivial details. However, to properly illustrate the method, we are going to be
    pedantic for a while. Let''s address the first error by updating our `New` function
    to take in the expected argument:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误告诉我们我们在向`New`函数传递参数，但`New`函数不接受任何参数。第二个错误说我们将`New`函数的返回值用作一个值，但`New`函数实际上并没有返回任何东西。你可能已经预料到了这一点，而且随着你编写测试驱动代码经验的增加，你很可能会跳过这样的琐事。然而，为了正确说明这种方法，我们将会详细说明。让我们通过更新我们的`New`函数以接受预期的参数来解决第一个错误：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are taking an argument that satisfies the `io.Writer` interface, which means
    that the specified object must have a suitable `Write` method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用满足`io.Writer`接口的参数，这意味着指定的对象必须有一个合适的`Write`方法。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using existing interfaces, especially ones found in the Go standard library,
    is an extremely powerful and often necessary way to ensure that your code is as
    flexible and elegant as possible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有的接口，尤其是Go标准库中的接口，是确保你的代码尽可能灵活和优雅的极其强大且通常必要的方法。
- en: Accepting `io.Writer` means that the user can decide where the tracing output
    will be written. This output could be the standard output, a file, network socket,
    `bytes.Buffer` as in our test case, or even some custom-made object, provided
    it can act like an `io.Writer` interface.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`io.Writer`意味着用户可以决定跟踪输出将被写入的位置。这个输出可以是标准输出、一个文件、网络套接字、`bytes.Buffer`（如我们的测试用例所示），甚至是一些自定义对象，只要它可以像`io.Writer`接口一样行动。
- en: 'Running `go test` again shows us that we have resolved the first error and
    we only need add a return type in order to progress past our second error:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`go test`显示我们已经解决了第一个错误，我们只需要添加一个返回类型就可以解决第二个错误：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are stating that our `New` function will return a `Tracer`, but we do not
    return anything, which `go test` happily complains about:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明`New`函数将返回一个`Tracer`，但我们实际上没有返回任何东西，这让`go test`很不高兴：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Fixing this is easy; we can just return `nil` from the `New` function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题很简单；我们只需从`New`函数返回`nil`即可：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, our test code has asserted that the return should not be `nil`,
    so `go test` now gives us a failure message:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的测试代码已经断言返回值不应该为`nil`，所以`go test`现在给出了一个失败信息：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can see how this hyper-strict adherence to the red-green principle can get
    a little tedious, but it is vital that we do not jump too far ahead. If we were
    to write a lot of implementation code in one go, we will very likely have code
    that is not covered by a unit test.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这种对红绿原则的过度严格遵循可能会变得有些繁琐，但我们必须确保不要过于急躁。如果我们一次性写很多实现代码，我们很可能会有一些没有被单元测试覆盖的代码。
- en: 'The ever-thoughtful core team has even solved this problem for us by providing
    code coverage statistics. The following command provides code statistics:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 总是深思熟虑的核心团队甚至为我们解决了这个问题，通过提供代码覆盖率统计。以下命令提供了代码统计：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Provided that all tests pass, adding the `-cover` flag will tell us how much
    of our code was touched during the execution of the tests. Obviously, the closer
    we get to 100 percent the better.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有测试都通过，添加`-cover`标志将告诉我们测试执行期间我们的代码有多少被触及。显然，我们越接近100%，就越好。
- en: Implementing the interface
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现接口
- en: 'To satisfy this test, we need something that we can properly return from the `New`
    method because `Tracer` is only an interface and we have to return something real.
    Let''s add an implementation of a tracer to our `tracer.go` file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个测试，我们需要从 `New` 方法中正确返回一些内容，因为 `Tracer` 只是一个接口，我们必须返回一些真实的东西。让我们在我们的 `tracer.go`
    文件中添加一个跟踪器的实现：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our implementation is extremely simple: the `tracer` type has an `io.Writer`
    field called `out` which is where we will write the trace output to. And the `Trace`
    method exactly matches the method required by the `Tracer` interface, although
    it doesn''t do anything yet.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现非常简单：`tracer` 类型有一个名为 `out` 的 `io.Writer` 字段，这是我们将会写入跟踪输出的地方。而 `Trace`
    方法正好符合 `Tracer` 接口所需的方法，尽管目前它还没有做任何事情。
- en: 'Now we can finally fix the `New` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以最终修复 `New` 方法：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running `go test` again shows us that our expectation was not met because nothing
    was written during our call to `Trace`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `go test` 显示我们的预期没有达到，因为在我们的 `Trace` 调用期间没有任何内容被写入：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s update our `Trace` method to write the blended arguments to the specified `io.Writer`
    field:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的 `Trace` 方法，将混合参数写入指定的 `io.Writer` 字段：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the `Trace` method is called, we use `fmt.Fprint` (and `fmt.Fprintln`)
    to format and write the trace details to the `out` writer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `Trace` 方法时，我们使用 `fmt.Fprint`（和 `fmt.Fprintln`）来格式化和将跟踪细节写入 `out` 写入器。
- en: Have we finally satisfied our test?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终满足我们的测试了吗？
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Congratulations! We have successfully passed our test and have 100 percent test
    coverage. Once we have finished our glass of champagne, we can take a minute to
    consider something very interesting about our implementation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功通过了测试，并且测试覆盖率达到了100%。在我们喝完一杯香槟之后，我们可以花一分钟时间考虑一下我们实现中非常有趣的一点。
- en: Unexported types being returned to users
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回给用户的未导出类型
- en: The `tracer` struct type we wrote is **unexported** because it begins with a
    lowercase `t`, so how is it that we are able to return it from the exported `New`
    function? After all, doesn't the user receive the returned object? This is perfectly
    acceptable and valid Go code; the user will only ever see an object that satisfies
    the `Tracer` interface and will never even know about our private `tracer` type.
    Since they only interact with the interface anyway, it wouldn't matter if our
    `tracer` implementation exposed other methods or fields; they would never be seen.
    This allows us to keep the public API of our package clean and simple.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的 `tracer` 结构体类型是 **未导出的**，因为它以小写字母 `t` 开头，那么我们是如何从导出的 `New` 函数中返回它的呢？毕竟，用户不会收到返回的对象吗？这是完全可接受和有效的
    Go 代码；用户将只会看到一个满足 `Tracer` 接口的对象，并且永远不会知道我们的私有 `tracer` 类型。由于他们无论如何只与接口交互，所以我们的
    `tracer` 实现公开了其他方法或字段，它们永远不会被看到。这使我们能够保持我们包的公共 API 清洁和简单。
- en: This hidden implementation technique is used throughout the Go standard library;
    for example, the `ioutil.NopCloser` method is a function that turns a normal `io.Reader` interface
    into `io.ReadCloser` where the `Close` method does nothing (used for when `io.Reader`
    objects that don't need to be closed are passed into functions that require `io.ReadCloser`
    types). The method returns `io.ReadCloser` as far as the user is concerned, but
    under the hood, there is a secret `nopCloser` type hiding the implementation details.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐藏的实现技术在整个 Go 标准库中都有使用；例如，`ioutil.NopCloser` 方法是一个将正常的 `io.Reader` 接口转换为 `io.ReadCloser`
    的函数，其中 `Close` 方法不做任何事情（用于当不需要关闭的 `io.Reader` 对象被传递到需要 `io.ReadCloser` 类型的函数中时）。该方法对用户而言返回
    `io.ReadCloser`，但在底层，有一个隐藏的 `nopCloser` 类型隐藏了实现细节。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see this for yourself, browse the Go standard library source code at [http://golang.org/src/pkg/io/ioutil/ioutil.go](http://golang.org/src/pkg/io/ioutil/ioutil.go)
    and search for the `nopCloser` struct.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自查看，请浏览 Go 标准库源代码在 [http://golang.org/src/pkg/io/ioutil/ioutil.go](http://golang.org/src/pkg/io/ioutil/ioutil.go)
    并搜索 `nopCloser` 结构体。
- en: Using our new trace package
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们新的跟踪包
- en: Now that we have completed the first version of our `trace` package, we can
    use it in our chat application in order to better understand what is going on
    when users send messages through the user interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `trace` 包的第一个版本，我们可以在我们的聊天应用中使用它，以便更好地理解当用户通过用户界面发送消息时发生了什么。
- en: In `room.go`, let's import our new package and make some calls to the `Trace`
    method. The path to the `trace` package we just wrote will depend on your `GOPATH`
    environment variable because the import path is relative to the `$GOPATH/src`
    folder. So if you create your `trace` package in `$GOPATH/src/mycode/trace`, then
    you would need to import `mycode/trace`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`room.go`中，让我们导入我们的新包并调用`Trace`方法。我们刚刚编写的`trace`包的路径将取决于你的`GOPATH`环境变量，因为导入路径是相对于`$GOPATH/src`文件夹的。所以如果你在`$GOPATH/src/mycode/trace`中创建你的`trace`包，那么你需要导入`mycode/trace`。
- en: 'Update the `room` type and the `run()` method like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新`room`类型和`run()`方法：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We added a `trace.Tracer` field to our `room` type and then made periodic calls
    to the `Trace` method peppered throughout the code. If we run our program and
    try to send messages, you''ll notice that the application panics because the `tracer`
    field is `nil`. We can remedy this for now by making sure we create and assign
    an appropriate object when we create our `room` type. Update the `main.go` file
    to do this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`room`类型中添加了一个`trace.Tracer`字段，然后在代码中周期性地调用`Trace`方法。如果我们运行我们的程序并尝试发送消息，你会注意到应用程序崩溃，因为`tracer`字段是`nil`。我们可以通过在创建我们的`room`类型时创建和分配适当的对象来解决这个问题。更新`main.go`文件以执行此操作：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are using our `New` method to create an object that will send the output
    to the `os.Stdout` standard output pipe (this is a technical way of saying we
    want it to print the output to our terminal).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的`New`方法创建一个对象，该对象将输出发送到`os.Stdout`标准输出管道（这是一种技术性的说法，意思是我们要将其输出打印到我们的终端）。
- en: 'Rebuild and run the program and use two browsers to play with the application,
    and notice that the terminal now has some interesting trace information for us:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并运行程序，使用两个浏览器来玩这个应用程序，并注意现在终端有一些有趣的跟踪信息供我们查看：
- en: '![Using our new trace package](img/00045.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![使用我们的新跟踪包](img/00045.jpeg)'
- en: Now we are able to use the debug information to get an insight into what the
    application is doing, which will assist us when developing and supporting our
    project.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够使用调试信息来深入了解应用程序正在做什么，这将有助于我们在开发和支持我们的项目时。
- en: Making tracing optional
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使跟踪可选
- en: Once the application is released, the sort of tracing information we are generating
    will be pretty useless if it's just printed out to some terminal somewhere, or
    even worse, if it creates a lot of noise for our system administrators. Also,
    remember that when we don't set a tracer for our `room` type, our code panics,
    which isn't a very user-friendly situation. To resolve these two issues, we are
    going to enhance our `trace` package with a `trace.Off()` method that will return
    an object that satisfies the `Tracer` interface but will not do anything when
    the `Trace` method is called.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序发布，如果我们只是将生成的跟踪信息打印到某个终端，或者更糟糕的是，如果它给我们的系统管理员造成了很多噪音，那么这种跟踪信息将变得相当无用。此外，请记住，当我们没有为我们的`room`类型设置跟踪器时，我们的代码会崩溃，这不是一个用户友好的情况。为了解决这两个问题，我们打算通过在`trace`包中添加一个`trace.Off()`方法来增强我们的`trace`包，该方法将返回一个满足`Tracer`接口的对象，但在调用`Trace`方法时不会做任何事情。
- en: 'Let''s add a test that calls the `Off` function to get a silent tracer before
    making a call to `Trace` to ensure the code doesn''t panic. Since the tracing
    won''t happen, that''s all we can do in our test code. Add the following test
    function to the `tracer_test.go` file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个测试，在调用`Trace`方法之前调用`Off`函数来获取一个静默跟踪器，以确保代码不会崩溃。由于跟踪不会发生，我们可以在测试代码中做的就只有这些。将以下测试函数添加到`tracer_test.go`文件中：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To make it pass, add the following code to the `tracer.go` file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其通过，将以下代码添加到`tracer.go`文件中：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our `nilTracer` struct has defined a `Trace` method that does nothing, and a
    call to the `Off()` method will create a new `nilTracer` struct and return it.
    Notice that our `nilTracer` struct differs from our `tracer` struct in that it
    doesn't take an `io.Writer` interface; it doesn't need one because it isn't going
    to write anything.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`nilTracer`结构体定义了一个不执行任何操作的`Trace`方法，调用`Off()`方法将创建一个新的`nilTracer`结构体并返回它。请注意，我们的`nilTracer`结构体与我们的`tracer`结构体不同，因为它不接收`io.Writer`接口；它不需要，因为它不会写入任何内容。
- en: 'Now let''s solve our second problem by updating our `newRoom` method in the
    `room.go` file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过更新`room.go`文件中的`newRoom`方法来解决我们的第二个问题：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'By default, our `room` type will be created with a `nilTracer` struct and any
    calls to `Trace` will just be ignored. You can try this out by removing the `r.tracer
    = trace.New(os.Stdout)` line from the `main.go` file: notice that nothing gets
    written to the terminal when you use the application and there is no panic.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的 `room` 类型将使用 `nilTracer` 结构体创建，并且对 `Trace` 的任何调用都将被忽略。你可以通过从 `main.go`
    文件中移除 `r.tracer = trace.New(os.Stdout)` 行来尝试这一点：注意当你使用应用程序时，终端上没有任何内容被写入，也没有发生恐慌。
- en: Clean package APIs
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁的包 API
- en: 'A quick glance at the API (in this context, the exposed variables, methods,
    and types) for our `trace` package highlights that a simple and obvious design
    has emerged:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看我们的 `trace` 包的 API（在这个上下文中，暴露的变量、方法和类型）突显出一个简单且明显的设计已经出现：
- en: The `New()` - method-creates a new instance of a Tracer
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New()` 方法 - 创建一个 Tracer 的新实例'
- en: The `Off()` - method-gets a Tracer that does nothing
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Off()` 方法 - 获取一个不执行任何操作的 Tracer 对象'
- en: The `Tracer` interface - describes the methods Tracer objects will implement
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tracer` 接口 - 描述 Tracer 对象将实现的方法'
- en: I would be very confident to give this package to a Go programmer without any
    documentation or guidelines, and I'm pretty sure they would know what do to with
    it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我会非常有信心将这个包提供给一个没有文档或指南的 Go 程序员，而且我相当确信他们会知道如何使用它。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Go, adding documentation is as simple as adding comments to the line before
    each item. The blog post on the subject is a worthwhile read ([http://blog.golang.org/godoc-documenting-go-code](http://blog.golang.org/godoc-documenting-go-code)),
    where you can see a copy of the hosted source code for `tracer.go` that is an
    example of how you might annotate the `trace` package. For more information, refer
    to [https://github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go](https://github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，添加文档就像在每项之前添加注释一样简单。关于这个主题的博客文章值得一读（[http://blog.golang.org/godoc-documenting-go-code](http://blog.golang.org/godoc-documenting-go-code)），在那里你可以看到
    `tracer.go` 的托管源代码副本，它是 `trace` 包的一个示例，展示了你如何注释 `trace` 包。更多信息，请参阅 [https://github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go](https://github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go)。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a complete concurrent chat application and our
    own simple package to trace the flow of our programs to help us better understand
    what is going on under the hood.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个完整的并发聊天应用程序，以及我们自己的简单包来跟踪程序流程，以帮助我们更好地理解底层发生了什么。
- en: We used the `net/http` package to quickly build what turned out to be a very
    powerful concurrent HTTP web server. In one particular case, we then upgraded
    the connection to open a web socket between the client and server. This means
    that we can easily and quickly communicate messages to the user's web browser
    without having to write messy polling code. We explored how templates are useful
    to separate the code from the content as well as to allow us to inject data into
    our template source, which let us make the host address configurable. Command-line
    flags helped us give simple configuration control to the people hosting our application
    while also letting us specify sensible defaults.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `net/http` 包来快速构建了一个最终证明非常强大的并发 HTTP 网络服务器。在某个特定情况下，我们将连接升级以在客户端和服务器之间打开一个
    WebSocket。这意味着我们可以轻松快速地向用户的网络浏览器发送消息，而无需编写混乱的轮询代码。我们探讨了模板如何有助于将代码与内容分离，以及如何将数据注入模板源，这使得我们可以使主机地址可配置。命令行标志帮助我们向托管我们应用程序的人提供简单的配置控制，同时也让我们可以指定合理的默认值。
- en: Our chat application made use of Go's powerful concurrency capabilities that
    allowed us to write clear *threaded* code in just a few lines of idiomatic Go.
    By controlling the coming and going of clients through channels, we were able
    to set synchronization points in our code that prevented us from corrupting memory
    by attempting to modify the same objects at the same time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用程序利用了 Go 强大的并发能力，使我们能够在几行惯用的 Go 代码中编写清晰的 *线程* 代码。通过通过通道控制客户端的进出，我们能够在代码中设置同步点，防止我们尝试同时修改相同的对象而损坏内存。
- en: We learned how interfaces such as `http.Handler` and our own `trace.Tracer` interface
    allow us to provide disparate implementations without having to touch the code
    that makes use of them, and in some cases, without having to expose even the name
    of the implementation to our users. We saw how just by adding a `ServeHTTP` method
    to our `room` type, we turned our custom room concept into a valid HTTP handler
    object, which managed our web socket connections.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何通过接口如 `http.Handler` 和我们自己的 `trace.Tracer` 接口，在不触及使用它们的代码的情况下提供不同的实现，在某些情况下，甚至不需要向用户暴露实现名称。我们看到，只需在我们的
    `room` 类型中添加一个 `ServeHTTP` 方法，我们就能将我们的自定义房间概念转换成一个有效的 HTTP 处理器对象，该对象管理我们的 WebSocket
    连接。
- en: 'We aren''t actually very far away from being able to properly release our application,
    except for one major oversight: you cannot see who sent each message. We have
    no concept of users or even usernames, and for a real chat application, this is
    not acceptable.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们离能够正确发布我们的应用程序并不遥远，除了一个主要的疏忽：你无法看到谁发送了每条消息。我们没有用户或用户名的概念，对于一个真正的聊天应用程序来说，这是不可接受的。
- en: In the next chapter, we will add the names of the people responding to their
    messages in order to make them feel like they are having a real conversation with
    other humans.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加回复消息的人的名字，以便让他们感觉像是在与其他人类进行真正的对话。
