<html><head></head><body>
<div class="book" title="Encoding and decoding data">
<div class="book" title="Custom encoding and decoding"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec178" class="calibre1"/>Custom encoding and decoding</h2></div></div></div><p class="calibre10">The JSON package uses two interfaces, <span class="strong"><em class="calibre11">Marshaler</em></span> and <span class="strong"><em class="calibre11">Unmarshaler</em></span>, to hook into encoding and decoding events respectively. When the encoder encounters a value whose type implements <code class="email">json.Marshaler</code>, it delegates serialization of the value to the method <code class="email">MarshalJSON</code> defined in the Marshaller interface. This is exemplified in the following abbreviated code snippet where the type <code class="email">Name</code> is updated to implement <code class="email">json.Marshaller</code> as shown:</p><pre class="programlisting">type Name struct { 
   First, Last string 
} 
func (n *Name) MarshalJSON() ([]byte, error) { 
   return []byte( 
         fmt.Sprintf(""%s, %s"", n.Last, n.First) 
   ), nil 
} 
 
type Book struct { 
   Title       string 
   PageCount   int 
   ISBN        string 
   Authors     []Name 
   Publisher   string 
   PublishDate time.Time 
} 
func main(){ 
   books := []Book{ 
         Book{ 
               Title:       "Leaning Go", 
               PageCount:   375, 
               ISBN:        "9781784395438", 
               Authors:     []Name{{"Vladimir", "Vivien"}}, 
               Publisher:   "Packt", 
               PublishDate: time.Date( 
                     2016, time.July, 
                     0, 0, 0, 0, 0, time.UTC), 
         }, 
         ... 
   } 
   ... 
   enc := json.NewEncoder(file) 
   if err := enc.Encode(books); err != nil { 
         fmt.Println(err) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch10/json3.go</p><p class="calibre10">In the previous example, values of the <code class="email">Name</code> type are serialized as a JSON string (instead of an object as earlier). The serialization is handled by the method <code class="email">Name.MarshallJSON</code> which returns an array of bytes that contains the last and first name separated by a comma. The preceding code generates the following JSON output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">    [</strong></span>
<span class="strong"><strong class="calibre2">          ...</strong></span>
<span class="strong"><strong class="calibre2">          {
                "Title":"Leaning Go",
                "PageCount":375,
                "ISBN":"9781784395438",
                "Authors":["Vivien, Vladimir"],
                "Publisher":"Packt",
                "PublishDate":"2016-06-30T00:00:00Z"
          },
          ...
    ]
</strong></span>
</pre><p class="calibre10">For the inverse, when a decoder encounters a piece of JSON text that maps to a type that implements <code class="email">json.Unmarshaler</code>, it delegates the decoding to the type's <code class="email">UnmarshalJSON</code> method. For instance, the following shows the abbreviated code snippet that implements <code class="email">json.Unmarshaler</code> to handle the JSON output for the <code class="email">Name</code>Â type:</p><pre class="programlisting">type Name struct { 
   First, Last string 
} 
 
func (n *Name) UnmarshalJSON(data []byte) error { 
   var name string 
   err := json.Unmarshal(data, &amp;name) 
   if err != nil { 
         fmt.Println(err) 
         return err 
   } 
   parts := strings.Split(name, ", ") 
   n.Last, n.First = parts[0], parts[1] 
   return nil 
} 
</pre><p class="calibre10">golang.fyi/ch10/json4.go</p><p class="calibre10">The <code class="email">Name</code> type is an implementation of <code class="email">json.Unmarshaler</code>. When the decoder encounters a JSON object with the key <code class="email">"Authors"</code>, it uses the method <code class="email">Name.Unmarshaler</code> to reconstitute the Go struct <code class="email">Name </code>type from the JSON string.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre10">The Go standard libraries offer additional encoders (not covered here) including <code class="email">base32</code>, <code class="email">bas364</code>, <code class="email">binary</code>, <code class="email">csv</code>, <code class="email">hex</code>, <code class="email">xml</code>, <code class="email">gzip</code>, and numerous encryption format encoders.</p></div></div></div></body></html>