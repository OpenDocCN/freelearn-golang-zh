["```go\npackage main \nimport (\"net/http\") \ntype authHandler struct { \n  next http.Handler \n} \nfunc (h *authHandler) ServeHTTP(w http.ResponseWriter, r  *http.Request) { \n  _, err := r.Cookie(\"auth\") \n  if err == http.ErrNoCookie { \n    // not authenticated \n    w.Header().Set(\"Location\", \"/login\") \n    w.WriteHeader(http.StatusTemporaryRedirect) \n    return \n  }  \n  if err != nil { \n    // some other error \n   http.Error(w, err.Error(), http.StatusInternalServerError) \n   return \n  }  \n  // success - call the next handler \n  h.next.ServeHTTP(w, r) \n} \nfunc MustAuth(handler http.Handler) http.Handler { \n  return &authHandler{next: handler} \n} \n\n```", "```go\nhttp.Handle(\"/\", &templateHandler{filename: \"chat.html\"}) \n\n```", "```go\nhttp.Handle(\"/chat\", MustAuth(&templateHandler{filename:  \"chat.html\"})) \n\n```", "```go\ngo build -o chat\n./chat -host=\":8080\"\n\n```", "```go\nhttp.Handle(\"/assets/\", http.StripPrefix(\"/assets\",    http.FileServer(http.Dir(\"/path/to/assets/\"))))\n\n```", "```go\nhttp.Handle(\"/chat\", MustAuth(&templateHandler{filename:  \"chat.html\"})) \nhttp.Handle(\"/login\", &templateHandler{filename: \"login.html\"}) \nhttp.Handle(\"/room\", r) \n\n```", "```go\n<html> \n  <head> \n    <title>Login</title> \n    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com\n     /bootstrap/3.3.6/css/bootstrap.min.css\"> \n  </head> \n  <body> \n    <div class=\"container\"> \n      <div class=\"page-header\"> \n        <h1>Sign in</h1> \n      </div> \n      <div class=\"panel panel-danger\"> \n        <div class=\"panel-heading\"> \n          <h3 class=\"panel-title\">In order to chat, you must be signed\n          in</h3> \n        </div> \n        <div class=\"panel-body\"> \n          <p>Select the service you would like to sign in with:</p> \n          <ul> \n            <li> \n              <a href=\"/auth/login/facebook\">Facebook</a> \n            </li> \n            <li> \n              <a href=\"/auth/login/github\">GitHub</a> \n            </li> \n            <li> \n              <a href=\"/auth/login/google\">Google</a> \n            </li> \n          </ul> \n        </div> \n      </div> \n    </div> \n  </body> \n</html> \n\n```", "```go\n\"auth/:action/:provider_name\" \n\n```", "```go\n\"auth/\" \n\n```", "```go\n// loginHandler handles the third-party login process. \n// format: /auth/{action}/{provider} \nfunc loginHandler(w http.ResponseWriter, r *http.Request) { \n  segs := strings.Split(r.URL.Path, \"/\") \n  action := segs[2] \n  provider := segs[3] \n  switch action { \n  case \"login\": \n    log.Println(\"TODO handle login for\", provider) \n      default: \n        w.WriteHeader(http.StatusNotFound) \n        fmt.Fprintf(w, \"Auth action %s not supported\", action) \n  } \n} \n\n```", "```go\nhttp.Handle(\"/chat\", MustAuth(&templateHandler{filename:  \"chat.html\"})) \nhttp.Handle(\"/login\", &templateHandler{filename: \"login.html\"}) \nhttp.HandleFunc(\"/auth/\", loginHandler) \nhttp.Handle(\"/room\", r) \n\n```", "```go\ngo build -o chat\n./chat -host=\":8080\"\n\n```", "```go\ngo get github.com/stretchr/gomniauth\n\n```", "```go\nmain.go (just underneath the flag.Parse() line toward the top of the main function):\n```", "```go\n// setup gomniauth \ngomniauth.SetSecurityKey(\"PUT YOUR AUTH KEY HERE\") \ngomniauth.WithProviders( \n  facebook.New(\"key\", \"secret\", \n    \"http://localhost:8080/auth/callback/facebook\"), \n  github.New(\"key\", \"secret\", \n    \"http://localhost:8080/auth/callback/github\"), \n  google.New(\"key\", \"secret\", \n    \"http://localhost:8080/auth/callback/google\"), \n) \n\n```", "```go\nimport ( \n  \"github.com/stretchr/gomniauth/providers/facebook\" \n  \"github.com/stretchr/gomniauth/providers/github\" \n  \"github.com/stretchr/gomniauth/providers/google\" \n) \n\n```", "```go\nfunc loginHandler(w http.ResponseWriter, r *http.Request) { \n  segs := strings.Split(r.URL.Path, \"/\") \n  action := segs[2] \n  provider := segs[3] \n  switch action { \n  case \"login\": \n    provider, err := gomniauth.Provider(provider) \n    if err != nil { \n      http.Error(w, fmt.Sprintf(\"Error when trying to get provider \n      %s: %s\",provider, err), http.StatusBadRequest) \n      return \n    } \n    loginUrl, err := provider.GetBeginAuthURL(nil, nil) \n    if err != nil { \n      http.Error(w, fmt.Sprintf(\"Error when trying to GetBeginAuthURL            \n      for %s:%s\", provider, err), http. StatusInternalServerError) \n      return \n    } \n    w.Header.Set(\"Location\", loginUrl) \n    w.WriteHeader(http.StatusTemporaryRedirect) \n    default: \n      w.WriteHeader(http.StatusNotFound) \n      fmt.Fprintf(w, \"Auth action %s not supported\", action) \n  } \n} \n\n```", "```go\ngo build -o chat\n./chat -host=\":8080\"\n\n```", "```go\nhttp://localhost:8080/auth/callback/google?code=4/Q92xJ- BQfoX6PHhzkjhgtyfLc0Ylm.QqV4u9AbA9sYguyfbjFEsNoJKMOjQI \n\n```", "```go\ncase \"callback\": \n  provider, err := gomniauth.Provider(provider) \n  if err != nil { \n    http.Error(w, fmt.Sprintf(\"Error when trying to get provider %s: %s\",    \n    provider, err), http.StatusBadRequest) \n    return \n  } \n  creds, err :=  provider.CompleteAuth(objx.MustFromURLQuery(r.URL.RawQuery)) \n  if err != nil { \n    http.Error(w, fmt.Sprintf(\"Error when trying to complete auth for \n    %s: %s\", provider, err), http.StatusInternalServerError) \n    return \n  } \n  user, err := provider.GetUser(creds) \n  if err != nil { \n    http.Error(w, fmt.Sprintf(\"Error when trying to get user from %s: %s\", \n    provider, err), http.StatusInternalServerError) \n    return \n  } \n  authCookieValue := objx.New(map[string]interface{}{ \n    \"name\": user.Name(), \n  }).MustBase64() \n  http.SetCookie(w, &http.Cookie{ \n    Name:  \"auth\", \n    Value: authCookieValue, \n    Path:  \"/\"}) \n  w.Header().Set(\"Location\", \"/chat\") \n  w.WriteHeader(http.StatusTemporaryRedirect) \n\n```", "```go\ngo build -o chat\n./chat -host=\":8080\"\n\n```", "```go\nfunc (t *templateHandler) ServeHTTP(w http.ResponseWriter, r  *http.Request) { \n  t.once.Do(func() { \n    t.templ =  template.Must(template.ParseFiles(filepath.Join(\"templates\",  \n    t.filename))) \n  }) \n  data := map[string]interface{}{ \n    \"Host\": r.Host, \n  } \n  if authCookie, err := r.Cookie(\"auth\"); err == nil { \n    data[\"UserData\"] = objx.MustFromBase64(authCookie.Value) \n  } \n  t.templ.Execute(w, data) \n} \n\n```", "```go\n<form id=\"chatbox\"> \n  {{.UserData.name}}:<br/> \n  <textarea></textarea> \n  <input type=\"submit\" value=\"Send\" /> \n</form> \n\n```", "```go\ngo build -o chat\n./chat -host=\":8080\"\n\n```", "```go\npackage main \nimport ( \n  \"time\" \n) \n// message represents a single message \ntype message struct { \n  Name    string \n  Message string \n  When    time.Time \n} \n\n```", "```go\nfunc (c *client) read() { \n  defer c.socket.Close() \n  for { \n    var msg *message \n    err := c.socket.ReadJSON(&msg) \n    if err != nil { \n      return \n    } \n    msg.When = time.Now() \n    msg.Name = c.userData[\"name\"].(string) \n    c.room.forward <- msg  \n} \n}  \nfunc (c *client) write() { \n  defer c.socket.Close() \n  for msg := range c.send { \n    err := c.socket.WriteJSON(msg) \n    if err != nil { \n      break \n    } \n  } \n} \n\n```", "```go\n// client represents a single chatting user. \ntype client struct { \n  // socket is the web socket for this client. \n  socket *websocket.Conn \n  // send is a channel on which messages are sent. \n  send chan *message \n  // room is the room this client is chatting in. \n  room *room \n  // userData holds information about the user \n  userData map[string]interface{} \n} \n\n```", "```go\nfunc (r *room) ServeHTTP(w http.ResponseWriter, req *http.Request) { \n  socket, err := upgrader.Upgrade(w, req, nil) \n  if err != nil { \n    log.Fatal(\"ServeHTTP:\", err) \n    return \n  } \n  authCookie, err := req.Cookie(\"auth\") \n  if err != nil { \n    log.Fatal(\"Failed to get auth cookie:\", err) \n    return \n  } \n  client := &client{ \n    socket:   socket, \n    send:     make(chan *message, messageBufferSize), \n    room:     r, \n    userData: objx.MustFromBase64(authCookie.Value), \n  } \n  r.join <- client \n  defer func() { r.leave <- client }() \n  go client.write() \n  client.read() \n} \n\n```", "```go\nsocket.send(JSON.stringify({\"Message\": msgBox.val()})); \n\n```", "```go\nsocket.onmessage = function(e) { \n  var msg = JSON.parse(e.data); \n  messages.append( \n    $(\"<li>\").append( \n      $(\"<strong>\").text(msg.Name + \": \"), \n      $(\"<span>\").text(msg.Message) \n    ) \n  ); \n} \n\nJSON.parse function to turn the JSON string into a JavaScript object and then access the fields to build up the elements needed to properly display them.\n```", "```go\ngo build -o chat\n./chat -host=\":8080\"\n\n```"]