- en: Chapter 2.  Adding User Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chat application we built in the previous chapter focused on high performance
    transmission of messages from the clients to the server and back again. However,
    the way things stand, our users have no way of knowing who they would be talking
    to. One solution to this problem is building some kind of sign-up and login functionality
    and letting our users create accounts and authenticate themselves before they
    can open the chat page.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we are about to build something from scratch, we must ask ourselves
    how others have solved this problem before (it is extremely rare to encounter
    genuinely original problems) and whether any open solutions or standards already
    exist that we can make use of. Authorization and authentication can hardly be
    considered new problems, especially in the world of the Web, with many different
    protocols out there to choose from. So how do we decide the best option to pursue?
    As always, we must look at this question from the point of view of the user.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of websites these days allow you to sign in using your accounts that exist
    elsewhere on a variety of social media or community websites. This saves users
    the tedious job of entering all of their account information over and over again
    as they decide to try out different products and services. It also has a positive
    effect on the conversion rates for new sites.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will enhance our chat codebase to add authorization, which
    will allow our users to sign in using Google, Facebook, or GitHub, and you'll
    see how easy it is to add other sign-in portals too. In order to join the chat,
    users must first sign in. Following this, we will use the authorized data to augment
    our user experience so everyone knows who is in the room and who said what.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the decorator pattern to wrap `http.Handler` types in order to add additional
    functionality to handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve HTTP endpoints with dynamic paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `gomniauth` open source project to access authentication services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get and set cookies using the `http` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode objects as Base64 and back to normal again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send and receive JSON data over a web socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give different types of data to templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with the channels of your own types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlers all the way down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our chat application, we implemented our own `http.Handler` type (the room)
    in order to easily compile, execute, and deliver HTML content to browsers. Since
    this is a very simple but powerful interface, we are going to continue to use
    it wherever possible when adding functionality to our HTTP processing.
  prefs: []
  type: TYPE_NORMAL
- en: In order to determine whether a user is allowed to proceed, we will create an
    authorization wrapper handler that will perform the check and pass the execution
    on to the inner handler only if the user is authorized.
  prefs: []
  type: TYPE_NORMAL
- en: Our wrapper handler will satisfy the same `http.Handler` interface as the object
    inside it, allowing us to wrap any valid handler. In fact, even the authentication
    handler we are about to write could be later encapsulated inside a similar wrapper
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: '![Handlers all the way down](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Chaining pattern when applied to HTTP handlers
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows how this pattern could be applied in a more complicated
    HTTP handler scenario. Each object implements the `http.Handler` interface. This
    means that an object could be passed to the `http.Handle` method to directly handle
    a request, or it can be given to another object, which could add some kind of
    extra functionality. The `Logging` handler may write to a log file before and
    after the `ServeHTTP` method is called on the inner handler. Because the inner
    handler is just another `http.Handler`, any other handler can be wrapped in (or
    decorated with) the `Logging` handler.
  prefs: []
  type: TYPE_NORMAL
- en: It is also common for an object to contain logic that decides which inner handler
    should be executed. For example, our authentication handler will either pass the
    execution to the wrapped handler, or handle the request itself by issuing a redirect
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s plenty of theory for now; let''s write some code. Create a new file
    called `auth.go` in the `chat` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `authHandler` type not only implements the `ServeHTTP` method (which satisfies
    the `http.Handler` interface), but also stores (wraps) `http.Handler` in the `next`
    field. Our `MustAuth` helper function simply creates `authHandler` that wraps
    any other `http.Handler`. This is the pattern that allows us to easily add authorization
    to our code in `main.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tweak the following root mapping line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the first argument to make it explicit about the page meant for
    chatting. Next, let''s use the `MustAuth` function to wrap `templateHandler` for
    the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping `templateHandler` with the `MustAuth` function will cause the execution
    to run through `authHandler` first; it will run only to `templateHandler` if the
    request is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServeHTTP` method in `authHandler` will look for a special cookie called
    `auth`, and it will use the `Header` and `WriteHeader` methods on `http.ResponseWriter`
    to redirect the user to a login page if the cookie is missing. Notice that we
    discard the cookie itself using the underscore character and capture only the
    returning error; this is because we only care about whether the cookie is present
    at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the chat application and try to hit `http://localhost:8080/chat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to delete your cookies to clear out previous authentication tokens
    or any other cookies that might be left over from other development projects served
    through the localhost.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the address bar of your browser, you will notice that you are
    immediately redirected to the `/login` page. Since we cannot handle that path
    yet, you'll just get a **404 page not found** error.
  prefs: []
  type: TYPE_NORMAL
- en: Making a pretty social sign-in page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven't paid much attention to making our application look nice;
    after all, this book is about Go and not user interface development. However,
    there is no excuse for building ugly apps, and so we will build a social sign-in
    page that is as pretty as it is functional.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is a frontend framework for developing responsive projects on the
    Web. It provides CSS and JavaScript code that solve many user interface problems
    in a consistent and good-looking way. While sites built using Bootstrap tend to
    look the same (although there are a plenty of ways in which the UI can be customized),
    it is a great choice for early versions of apps or for developers who don't have
    access to designers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you build your application using the semantic standards set forth by Bootstrap,
    it will become easy for you to make a Bootstrap theme for your site or application,
    and you know it will slot right into your code.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the version of Bootstrap hosted on a CDN so we don't have to worry
    about downloading and serving our own version through our chat application. This
    means that in order to render our pages properly, we will need an active Internet
    connection even during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to download and host your own copy of Bootstrap, you can do so.
    Keep the files in an `assets` folder and add the following call to your `main`
    function (it uses `http.Handle` to serve the assets via your application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how the `http.StripPrefix` and `http.FileServer` functions return objects
    that satisfy the `http.Handler` interface as per the decorator pattern that we
    implement with our `MustAuth` helper function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.go`, let''s add an endpoint for the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we do not want to use the `MustAuth` method for our login page because
    it will cause an infinite redirection loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `login.html` inside our `templates` folder and insert
    the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the web server and navigate to `http://localhost:8080/login`. You will
    notice that it now displays our **Sign in** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a pretty social sign-in page](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Endpoints with dynamic paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pattern matching for the `http` package in the Go standard library isn''t the
    most comprehensive and fully featured implementation out there. For example, Ruby
    on Rails makes it much easier to have dynamic segments inside the path. You could
    map the route like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Rails then provides a data map (or dictionary) containing the values that it
    automatically extracted from the matched path. So if you visit `auth/login/google`,
    then `params[:provider_name]` would equal `google` and `params[:action]` would
    equal `login`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most the `http` package lets us specify by default is a path prefix, which
    we can make use of by leaving a trailing slash at the end of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then have to manually parse the remaining segments to extract the
    appropriate data. This is acceptable for relatively simple cases. This suits our
    needs for the time being since we only need to handle a few different paths, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/auth/login/google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/login/facebook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/callback/google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/callback/facebook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to handle more advanced routing situations, you may want to consider
    using dedicated packages, such as `goweb`, `pat`, `routes`, or `mux`. For extremely
    simple cases such as ours, built-in capabilities will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new handler that powers our login process. In `auth.go`,
    add the following `loginHandler` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we break the path into segments using `strings.Split`
    before pulling out the values for `action` and `provider`. If the action value
    is known, we will run the specific code; otherwise, we will write out an error
    message and return an `http.StatusNotFound` status code (which in the language
    of HTTP status code is `404`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will not bulletproof our code right now. But it's worth noticing that if
    someone hits `loginHandler` with few segments, our code will panic because it
    would expect `segs[2]` and `segs[3]` to exist.
  prefs: []
  type: TYPE_NORMAL
- en: For extra credit, see whether you can protect your code against this and return
    a nice error message instead of making it panic if someone hits `/auth/nonsense`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `loginHandler` is only a function and not an object that implements the
    `http.Handler` interface. This is because, unlike other handlers, we don''t need
    it to store any state. The Go standard library supports this, so we can use the
    `http.HandleFunc` function to map it in a way similar to how we used `http.Handle`
    earlier. In `main.go`, update the handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Rebuild and run the chat application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit the following URLs and notice the output logged in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/auth/login/google` outputs `TODO handle login for google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/auth/login/facebook` outputs `TODO handle login for
    facebook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have successfully implemented a dynamic path-matching mechanism that just
    prints out `TODO` messages so far; we need to integrate it with authorization
    services in order to make our login process work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth2 is an open authorization standard designed to allow resource owners to
    give clients delegated access to private data (such as wall posts or tweets) via
    an access token exchange handshake. Even if you do not wish to access the private
    data, OAuth2 is a great option that allows people to sign in using their existing
    credentials, without exposing those credentials to a third-party site. In this
    case, we are the third party, and we want to allow our users to sign in using
    services that support OAuth2.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a user''s point of view, the OAuth2 flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user selects the provider with whom they wish to sign in to the client app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected to the provider's website (with a URL that includes the
    client app ID) where they are asked to give permission to the client app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user signs in from the OAuth2 service provider and accepts the permissions
    requested by the third-party application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected to the client app with a request code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the background, the client app sends the grant code to the provider, who
    sends back an authentication token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client app uses the access token to make authorized requests to the provider,
    such as to get user information or wall posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid reinventing the wheel, we will look at a few open source projects that
    have already solved this problem for us.
  prefs: []
  type: TYPE_NORMAL
- en: Open source OAuth2 packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Andrew Gerrand has been working on the core Go team since February 2010, that
    is, two years before Go 1.0 was officially released. His `goauth2` package (see
    [https://github.com/golang/oauth2](https://github.com/golang/oauth2)) is an elegant
    implementation of the OAuth2 protocol written entirely in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Andrew's project inspired `gomniauth` (see [https://github.com/stretchr/gomniauth](https://github.com/stretchr/gomniauth)).
    An open source Go alternative to Ruby's `omniauth` project, `gomniauth` provides
    a unified solution to access different OAuth2 services. In the future, when OAuth3
    (or whatever the next-generation authorization protocol will be) comes out, in
    theory `gomniauth` could take on the pain of implementing the details, leaving
    the user code untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we will use `gomniauth` to access OAuth services provided
    by Google, Facebook, and GitHub, so make sure you have it installed by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the project dependencies of `gomniauth` are kept in Bazaar repositories,
    so you'll need to head over to [http://wiki.bazaar.canonical.com](http://wiki.bazaar.canonical.com)
    to download them.
  prefs: []
  type: TYPE_NORMAL
- en: Tell the authorization providers about your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we ask an authorization provider to help our users sign in, we must
    tell them about our application. Most providers have some kind of web tool or
    console where you can create applications to kick this process off. Here''s one
    from Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tell the authorization providers about your app](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In order to identify the client application, we need to create a client ID and
    secret. Despite the fact that OAuth2 is an open standard, each provider has their
    own language and mechanism to set things up. Therefore, you will most likely have
    to play around with the user interface or the documentation to figure it out in
    each case.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, in **Google Cloud Console**, you navigate to **API Manager**
    and click on the **Credentials** section.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, for added security, you have to be explicit about the host URLs
    from where requests will come. For now, since we're hosting our app locally on
    `localhost:8080`, you should use it. You will also be asked for a redirect URI
    that is the endpoint in our chat application and to which the user will be redirected
    after they successfully sign in. The callback will be another action in `loginHandler`,
    so the redirect URL for the Google client will be `http://localhost:8080/auth/callback/google`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you finish the authorization process for the providers you want to support,
    you will be given a client ID and secret for each provider. Make a note of these
    details because we will need them when we set up the providers in our chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we host our application on a real domain, we have to create new client IDs
    and secrets or update the appropriate URL fields on our authorization providers
    to ensure that they point to the right place. Either way, it is good practice
    to have a different set of development and production keys for security.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing external logging in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should replace the `key` and `secret` placeholders with the actual values
    you noted down earlier. The third argument represents the callback URL that should
    match the ones you provided when creating your clients on the provider's website.
    Notice the second path segment is `callback`; while we haven't implemented this
    yet, this is where we handle the response from the authorization process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you will need to ensure all the appropriate packages are imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gomniauth requires the `SetSecurityKey` call because it sends state data between
    the client and server along with a signature checksum, which ensures that the
    state values are not tempered with while being transmitted. The security key is
    used when creating the hash in a way that it is almost impossible to recreate
    the same hash without knowing the exact security key. You should replace `some
    long key` with a security hash or phrase of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have configured Gomniauth, we need to redirect users to the provider''s
    authorization page when they land on our `/auth/login/{provider}` path. We just
    have to update our `loginHandler` function in `auth.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We do two main things here. First, we use the `gomniauth.Provider` function
    to get the provider object that matches the object specified in the URL (such
    as `google` or `github`). Then, we use the `GetBeginAuthURL` method to get the
    location where we must send users to in order to start the authorization process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GetBeginAuthURL(nil, nil)` arguments are for the state and options respectively,
    which we are not going to use for our chat application.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a state map of data that is encoded and signed and sent
    to the authentication provider. The provider doesn't do anything with the state;
    it just sends it back to our callback endpoint. This is useful if, for example,
    we want to redirect the user back to the original page they were trying to access
    before the authentication process intervened. For our purpose, we have only the
    `/chat` endpoint, so we don't need to worry about sending any state.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a map of additional options that will be sent to the
    authentication provider, which somehow modifies the behavior of the authentication
    process. For example, you can specify your own `scope` parameter, which allows
    you to make a request for permission to access additional information from the
    provider. For more information about the available options, search for OAuth2
    on the Internet or read the documentation for each provider, as these values differ
    from service to service.
  prefs: []
  type: TYPE_NORMAL
- en: If our code gets no error from the `GetBeginAuthURL` call, we simply redirect
    the user's browser to the returned URL.
  prefs: []
  type: TYPE_NORMAL
- en: If errors occur, we use the `http.Error` function to write the error message
    out with a `non-200` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild and run the chat application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will continue to stop, rebuild, and run our projects manually throughout
    this book, but there are some tools that will take care of this for you by watching
    for changes and restarting Go applications automatically. If you're interested
    in such tools, check out [https://github.com/pilu/fresh](https://github.com/pilu/fresh)
    and [https://github.com/codegangsta/gin](https://github.com/codegangsta/gin).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the main chat page by accessing `http://localhost:8080/chat`. As we aren''t
    logged in yet, we are redirected to our sign-in page. Click on the **Google**
    option to sign in using your Google account and you will notice that you are presented
    with a Google-specific sign-in page (if you are not already signed in to Google).
    Once you are signed in, you will be presented with a page asking you to give permission
    for our chat application before you can view basic information about your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging in](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is the same flow that the users of our chat application will experience
    when signing in.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Accept** and you will notice that you are redirected to our application
    code but presented with an `Auth action callback not supported` error. This is
    because we haven't yet implemented the callback functionality in `loginHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the response from the provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user clicks on **Accept** on the provider's website (or if they click
    on the equivalent of **Cancel**), they will be redirected to the callback endpoint
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick glance at the complete URL that comes back shows us the grant code
    that the provider has given us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to worry about what to do with this code because Gomniauth does
    it for us; we can simply jump to implementing our callback handler. However, it's
    worth knowing that this code will be exchanged by the authentication provider
    for a token that allows us to access private user data. For added security, this
    additional step happens behind the scenes, from server to server rather than in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth.go`, we are ready to add another switch case to our action path segment.
    Insert the following code before the default case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the authentication provider redirects the users after they have granted
    permission, the URL specifies that it is a callback action. We look up the authentication
    provider as we did before and call its `CompleteAuth` method. We parse `RawQuery`
    from the request into `objx.Map` (the multipurpose map type that Gomniauth uses),
    and the `CompleteAuth` method uses the values to complete the OAuth2 provider
    handshake with the provider. All being well, we will be given some authorized
    credentials with which we will be able to access our user's basic data. We then
    use the `GetUser` method for the provider, and Gomniauth will use the specified
    credentials to access some basic information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the user data, we **Base64-encode** the `Name` field in a JSON
    object and store it as a value for our `auth` cookie for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Base64-encoding data ensures it won't contain any special or unpredictable characters,
    which is useful for situations such as passing data to a URL or storing it in
    a cookie. Remember that although Base64-encoded data looks encrypted, it is not
    you can easily decode Base64-encoded data back to the original text with little
    effort. There are online tools that do this for you.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the cookie, we redirect the user to the chat page, which we can
    safely assume was the original destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you build and run the code again and hit the `/chat` page, you will notice
    that the sign up flow works and we are finally allowed back to the chat page.
    Most browsers have an inspector or a console—a tool that allows you to view the
    cookies that the server has sent you-that you can use to see whether the `auth`
    cookie has appeared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the cookie value is `eyJuYW1lIjoiTWF0IFJ5ZXIifQ==`, which is a
    Base64-encoded version of `{"name":"Mat Ryer"}`. Remember, we never typed in a
    name in our chat application; instead, Gomniauth asked Google for a name when
    we opted to sign in with Google. Storing non-signed cookies like this is fine
    for incidental information, such as a user's name; however, you should avoid storing
    any sensitive information using non-signed cookies as it's easy for people to
    access and change the data.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the user data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having the user data inside a cookie is a good start, but non-technical people
    will never even know it's there, so we must bring the data to the fore. We will
    do this by enhancing `templateHandler` that first passes the user data to the
    template's `Execute` method; this allows us to use template annotations in our
    HTML to display the user data to the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ServeHTTP` method of `templateHandler` in `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just passing the entire `http.Request` object to our template as
    data, we are creating a new `map[string]interface{}` definition for a data object
    that potentially has two fields: `Host` and `UserData` (the latter will only appear
    if an `auth` cookie is present). By specifying the map type followed by curly
    braces, we are able to add the `Host` entry at the same time as making our map
    while avoiding the `make` keyword altogether. We then pass this new `data` object
    as the second argument to the `Execute` method on our template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add an HTML file to our template source to display the name. Update
    the `chatbox` form in `chat.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `{{.UserData.name}}` annotation tells the template engine to insert our
    user's name before the `textarea` control.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we're using the `objx` package, don't forget to run `go get http://github.com/stretchr/objx`
    and import it. Additional dependencies add complexity to projects, so you may
    decide to copy and paste the appropriate functions from the package or even write
    your own code that marshals between Base64-encoded cookies and back.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can **vendor** the dependency by copying the whole source
    code to your project (inside a root-level folder called `vendor`). Go will, at
    build time, first check the vendor folder for any imported packages before checking
    them in `$GOPATH` (which were put there by `go get`). This allows you to fix the
    exact version of a dependency rather than rely on the fact that the source package
    hasn't changed since you wrote your code.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about using vendors in Go, check out Daniel Theophanes'
    post on the subject at [https://blog.gopheracademy.com/advent-2015/vendor-folder/](https://blog.gopheracademy.com/advent-2015/vendor-folder/)
    or search for `vendoring in Go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild and run the chat application again and you will notice the addition
    of your name before the chat box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Augmenting messages with additional data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our chat application has only transmitted messages as slices of bytes
    or `[]byte` types between the client and the server; therefore, the forward channel
    for our room has the `chan []byte` type. In order to send data (such as who sent
    it and when) in addition to the message itself, we enhance our forward channel
    and also how we interact with the web socket on both ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new type that will replace the `[]byte` slice by creating a new file
    called `message.go` in the `chat` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `message` type will encapsulate the message string itself, but we have also
    added the `Name` and `When` fields that respectively hold the user's name and
    a timestamp of when the message was sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `client` type is responsible for communicating with the browser,
    it needs to transmit and receive more than just a single message string. As we
    are talking to a JavaScript application (that is, the chat client running in the
    browser) and the Go standard library has a great JSON implementation, this seems
    like the perfect choice to encode additional information in the messages. We will
    change the `read` and `write` methods in `client.go` to use the `ReadJSON` and
    `WriteJSON` methods on the socket, and we will encode and decode our new `message`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we receive a message from the browser, we will expect to populate only
    the `Message` field, which is why we set the `When` and `Name` fields ourselves
    in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that when you try to build the preceding code, it complains
    about a few things. The main reason is that we are trying to send a `*message`
    object down our `forward` and `send chan []byte` channels. This is not allowed
    until we change the type of the channel. In `room.go`, change the `forward` field
    to be of the type `chan *message`, and do the same for the `send chan` type in
    `client.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must update the code that initializes our channels since the types have
    now changed. Alternatively, you can wait for the compiler to raise these issues
    and fix them as you go. In `room.go`, you need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `forward: make(chan []byte)` to `forward: make(chan *message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change `r.tracer.Trace("Message received: ", string(msg))` to `r.tracer.Trace("Message
    received: ", msg.Message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change `send: make(chan []byte, messageBufferSize)` to `send: make(chan *message,
    messageBufferSize)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The compiler will also complain about the lack of user data on the client,
    which is a fair point because the `client` type has no idea about the new user
    data we have added to the cookie. Update the `client` struct to include a new
    general-purpose `map[string]interface{}` called `userData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The user data comes from the client cookie that we access through the `http.Request`
    object''s `Cookie` method. In `room.go`, update `ServeHTTP` with the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use the `Cookie` method on the `http.Request` type to get our user data before
    passing it to the client. We are using the `objx.MustFromBase64` method to convert
    our encoded cookie value back into a usable map object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have changed the type being sent and received on the socket from
    `[]byte` to `*message`, we must tell our JavaScript client that we are sending
    JSON instead of just a plain string. Also, we must ask that it send JSON back
    to the server when a user submits a message. In `chat.html`, first update the
    `socket.send` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are using `JSON.stringify` to serialize the specified JSON object (containing
    just the `Message` field) into a string, which is then sent to the server. Our
    Go code will decode (or unmarshal) the JSON string into a `message` object, matching
    the field names from the client JSON object with those of our `message` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the `socket.onmessage` callback function to expect JSON, and
    also add the name of the sender to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application, and if you can, log in with two different accounts
    in two different browsers (or invite a friend to help you test it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the chat application''s browser chat screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Augmenting messages with additional data](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a useful and necessary feature to our chat application
    by asking users to authenticate themselves using OAuth2 service providers before
    we allow them to join the conversation. We made use of several open source packages,
    such as `Gomniauth`, which dramatically reduced the amount of multiserver complexity
    we would otherwise have dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a pattern when we wrapped `http.Handler` types to allow us to
    easily specify which paths require the user to be authenticated and which were
    available, even without an `auth` cookie. Our `MustAuth` helper function allowed
    us to generate the wrapper types in a fluent and simple way, without adding clutter
    and confusion to our code.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use cookies and Base64-encoding to safely (although not securely)
    store the state of particular users in their respective browsers and to make use
    of that data over normal connections and through web sockets. We took more control
    of the data available to our templates in order to provide the name of the user
    to the UI and saw how to only provide certain data under specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Since we needed to send and receive additional information over the web socket,
    we learned how easy it was to change the channels of native types into channels
    that work with types of our own, such as our `message` type. We also learned how
    to transmit JSON objects over the socket, rather than just slices of bytes. Thanks
    to the type safety of Go and the ability to specify types for channels, the compiler
    helps ensure that we do not send anything other than `message` objects through
    `chan *message`. Attempting to do so would result in a compiler error, alerting
    us to the fact right away.
  prefs: []
  type: TYPE_NORMAL
- en: From building a chat application to seeing the name of the person chatting is
    a great leap forward in terms of usability. But it's very formal and might not
    attract modern users of the Web, who are used to a much more visual experience.
    We are missing pictures of people chatting, and in the next chapter, we will explore
    different ways in which this could be done. We can allow users to better represent
    themselves in our application by pulling profile pictures (avatars) from the OAuth2
    provider, the Gravatar web service, or the local disk after the users have uploaded
    them.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra assignment, see whether you can make use of the `time.Time` field
    that we put into the `message` type to tell users when the messages were sent.
  prefs: []
  type: TYPE_NORMAL
