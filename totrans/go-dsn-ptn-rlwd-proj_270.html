<html><head></head><body>
<div class="book" title="Chapter&#xA0;11.&#xA0;Writing Networked Services">
<div class="book" title="The net package">
<div class="book" title="Accepting client connections"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch11lvl2sec183" class="calibre1"/>Accepting client connections</h2></div></div></div><p class="calibre10">The <code class="email">net.Listener</code> interface uses the <span class="strong"><em class="calibre11">Accept</em></span> method to block indefinitely until a new connection arrives from a client. The following abbreviated code snippet shows a simple server that returns the string "Nice to meet you!" to each client connection and then disconnects immediately:</p><pre class="programlisting">func main() { 
   listener, err := net.Listen("tcp", ":4040") 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
   defer listener.Close() 
 
   for { 
         conn, err := listener.Accept() 
         if err != nil { 
               fmt.Println(err) 
               return 
         } 
         conn.Write([]byte("Nice to meet you!")) 
         conn.Close() 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch11/listen0.go</p><p class="calibre10">In the code, the <code class="email">listener.Accept</code> method returns a value of the <code class="email">net.Conn</code> type to handle data exchange between the server and the client (or it returns a non-nil <code class="email">error</code> if it fails). The <code class="email">conn.Write([]byte("Nice to meet you!"))</code> method call is used to write the response to the client. When the server program is running, it can be tested using a <span class="strong"><em class="calibre11">telnet</em></span> client as shown in the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go run listen0.go &amp; 
[1] 83884 
 
$&gt; telnet 127.0.0.1 4040 
Trying 127.0.0.1... 
Connected to localhost. 
Escape character is '^]'. 
Nice to meet you! Connection closed by foreign host.</strong></span>
</pre><p class="calibre10">To ensure that the server program continues to run and handle subsequent client connections, the call to the <code class="email">Accept</code> method is wrapped within an infinite for-loop. As soon as a connection is closed, the loop restarts the cycle to wait for the next client connection. Also notice that it is a good practice to close the listener when the server process is shutting down with a call to <code class="email">Listener.Close()</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre10">The observant reader may notice that this simple server will not scale as it cannot handle more than one client request at once. In the next section, we will see the techniques for creating a scalable server.</p></div></div></div></div></body></html>