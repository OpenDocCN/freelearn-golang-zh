<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="A TCP API server"><div class="book" id="2BASE2-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec75" class="calibre1"/>A TCP API server</h1></div></div></div><p class="calibre10">At this point, the chapter has covered the minimum networking components necessary to create client and service programs. The remainder of the chapter will discuss different versions of a server that implement a <span class="strong"><em class="calibre11">monetary currency information</em></span> service. The service returns ISO 4217 monetary currency information with each request. The intent is to show the implications of creating networked services, along with their clients, using different application-level protocols.</p><p class="calibre10">Earlier we introduced a very simple server to demonstrate the necessary steps required to set up a networked service. This section dives deeper into network programming by creating a TCP server that scales to handle many concurrent connections. The server code presented in this section has the following design goals:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Use raw TCP to communicate between client and server</li><li class="listitem">Develop a simple text-based protocol, over TCP, for communication</li><li class="listitem">Clients can query the server for global currency information with text commands</li><li class="listitem">Use a goroutine per connection to handle connection concurrency</li><li class="listitem">Maintain connection until the client disconnects</li></ul></div><p class="calibre10">The following lists an abbreviated version of the server code. The program uses the <code class="email">curr</code> package (found at <a class="calibre1" href="https://github.com/vladimirvivien/learning-go/ch11/curr0">https://github.com/vladimirvivien/learning-go/ch11/curr0</a>), not discussed here, to load monetary currency data from a local CSV file into slice <code class="email">currencies</code>.</p><p class="calibre10">Upon successful connection to a client, the server parses the incoming client commands specified with a simple text protocol with the format <span class="strong"><em class="calibre11">GET &lt;currency-filter-value&gt;</em></span> where <span class="strong"><em class="calibre11">&lt;currency-filter-value&gt;</em></span> specifies a string value used to search for currency information:</p><pre class="programlisting">import ( 
   "net" 
   ... 
   curr "https://github.com/vladimirvivien/learning-go/ch11/curr0" 
) 
 
var currencies = curr.Load("./data.csv") 
 
func main() { 
   ln, _ := net.Listen("tcp", ":4040") 
   defer ln.Close() 
    
   // connection loop 
   for { 
         conn, err := ln.Accept() 
         if err != nil { 
               fmt.Println(err) 
               conn.Close() 
               continue 
         }      
         go handleConnection(conn) 
   } 
} 
 
// handle client connection 
func handleConnection(conn net.Conn) { 
   defer conn.Close() 
 
   // loop to stay connected with client 
   for { 
         cmdLine := make([]byte, (1024 * 4)) 
         n, err := conn.Read(cmdLine) 
         if n == 0 || err != nil { 
               return 
         } 
         cmd, param := parseCommand(string(cmdLine[0:n])) 
         if cmd == "" { 
               continue 
         } 
 
         // execute command 
         switch strings.ToUpper(cmd) { 
         case "GET": 
               result := curr.Find(currencies, param) 
               // stream result to client 
               for _, cur := range result { 
                     _, err := fmt.Fprintf( 
                           conn, 
                           "%s %s %s %s\n", 
                           cur.Name, cur.Code, 
                           cur.Number, cur.Country, 
                     ) 
                     if err != nil { 
                           return 
                     } 
                     // reset deadline while writing, 
                     // closes conn if client is gone 
                     conn.SetWriteDeadline( 
                           time.Now().Add(time.Second * 5)) 
               } 
               // reset read deadline for next read 
               conn.SetReadDeadline( 
                     time.Now().Add(time.Second * 300)) 
 
         default: 
               conn.Write([]byte("Invalid command\n")) 
         } 
   } 
} 
 
func parseCommand(cmdLine string) (cmd, param string) { 
   parts := strings.Split(cmdLine, " ") 
   if len(parts) != 2 { 
         return "", "" 
   } 
   cmd = strings.TrimSpace(parts[0]) 
   param = strings.TrimSpace(parts[1]) 
   return 
} 
</pre><p class="calibre10">golang.fyi/ch11/tcpserv0.go</p><p class="calibre10">Unlike the simple server introduced in the last section, this server is able to service multiple client connections at the same time. Upon accepting a new connection, with <code class="email">ln.Accept()</code>, it delegates the handling of new client connections to a goroutine with <code class="email">go handleConnection(conn)</code>. The connection loop then continues immediately and waits for the next client connection.</p><p class="calibre10">The <code class="email">handleConnection</code> function manages the server communication with the connected client. It first reads and parses a slice of bytes, from the client, into a command string using <code class="email">cmd, param := parseCommand(string(cmdLine[0:n]))</code>. Next, the code tests the command with a <code class="email">switch</code> statement. If the <code class="email">cmd</code> is equal to <code class="email">"GET"</code>, the code searches slice <code class="email">currencies</code> for values that matches <code class="email">param</code> with a call to <code class="email">curr.Find(currencies, param)</code>. Finally, it streams the search result to the client's connection using <code class="email">fmt.Fprintf(conn, "%s %s %s %s\n", cur.Name, cur.Code, cur.Number, cur.Country)</code>.</p><p class="calibre10">The simple text protocol supported by the server does not include any sort of session control or control messages. Therefore, the code uses the <code class="email">conn.SetWriteDeadline</code> method to ensure the connection to the client does not linger unnecessarily for long periods of time. The method is called during the loop that streams out a response to the client. It is set for a deadline of 5 seconds to ensure the client is always ready to receive the next chunk of bytes within that time, otherwise it times the connection out.</p></div></body></html>