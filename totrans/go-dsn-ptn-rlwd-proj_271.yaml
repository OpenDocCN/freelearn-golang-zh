- en: A TCP API server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, the chapter has covered the minimum networking components necessary
    to create client and service programs. The remainder of the chapter will discuss
    different versions of a server that implement a *monetary currency information*
    service. The service returns ISO 4217 monetary currency information with each
    request. The intent is to show the implications of creating networked services,
    along with their clients, using different application-level protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we introduced a very simple server to demonstrate the necessary steps
    required to set up a networked service. This section dives deeper into network
    programming by creating a TCP server that scales to handle many concurrent connections.
    The server code presented in this section has the following design goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Use raw TCP to communicate between client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a simple text-based protocol, over TCP, for communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients can query the server for global currency information with text commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a goroutine per connection to handle connection concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain connection until the client disconnects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lists an abbreviated version of the server code. The program uses
    the `curr` package (found at [https://github.com/vladimirvivien/learning-go/ch11/curr0](https://github.com/vladimirvivien/learning-go/ch11/curr0)),
    not discussed here, to load monetary currency data from a local CSV file into
    slice `currencies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon successful connection to a client, the server parses the incoming client
    commands specified with a simple text protocol with the format *GET <currency-filter-value>*
    where *<currency-filter-value>* specifies a string value used to search for currency
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/tcpserv0.go
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the simple server introduced in the last section, this server is able
    to service multiple client connections at the same time. Upon accepting a new
    connection, with `ln.Accept()`, it delegates the handling of new client connections
    to a goroutine with `go handleConnection(conn)`. The connection loop then continues
    immediately and waits for the next client connection.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleConnection` function manages the server communication with the connected
    client. It first reads and parses a slice of bytes, from the client, into a command
    string using `cmd, param := parseCommand(string(cmdLine[0:n]))`. Next, the code
    tests the command with a `switch` statement. If the `cmd` is equal to `"GET"`,
    the code searches slice `currencies` for values that matches `param` with a call
    to `curr.Find(currencies, param)`. Finally, it streams the search result to the
    client's connection using `fmt.Fprintf(conn, "%s %s %s %s\n", cur.Name, cur.Code,
    cur.Number, cur.Country)`.
  prefs: []
  type: TYPE_NORMAL
- en: The simple text protocol supported by the server does not include any sort of
    session control or control messages. Therefore, the code uses the `conn.SetWriteDeadline`
    method to ensure the connection to the client does not linger unnecessarily for
    long periods of time. The method is called during the loop that streams out a
    response to the client. It is set for a deadline of 5 seconds to ensure the client
    is always ready to receive the next chunk of bytes within that time, otherwise
    it times the connection out.
  prefs: []
  type: TYPE_NORMAL
