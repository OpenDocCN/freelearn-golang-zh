<html><head></head><body>
<div class="book" title="A TCP API server">
<div class="book" title="Connecting to the TCP server with Go"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec185" class="calibre1"/>Connecting to the TCP server with Go</h2></div></div></div><p class="calibre10">A simple TCP client can also be written in Go to connect to the TCP server. The client captures the command from the console's standard input and sends it to the server as is shown in the following code snippet:</p><pre class="programlisting">var host, port = "127.0.0.1", "4040" 
var addr = net.JoinHostPort(host, port) 
const prompt = "curr" 
const buffLen = 1024 
 
func main() { 
   conn, err := net.Dial("tcp", addr) 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
   defer conn.Close() 
   var cmd, param string 
   // repl - interactive shell for client 
   for { 
         fmt.Print(prompt, "&gt; ") 
         _, err = fmt.Scanf("%s %s", &amp;cmd, &amp;param) 
         if err != nil { 
               fmt.Println("Usage: GET &lt;search string or *&gt;") 
               continue 
         } 
         // send command line 
         cmdLine := fmt.Sprintf("%s %s", cmd, param) 
         if n, err := conn.Write([]byte(cmdLine)); 
         n == 0 || err != nil { 
               fmt.Println(err) 
               return 
         } 
 
         // stream and display response 
         conn.SetReadDeadline( 
               time.Now().Add(time.Second * 5)) 
         for { 
               buff := make([]byte, buffLen) 
               n, err := conn.Read(buff) 
               if err != nil { break } 
               fmt.Print(string(buff[0:n])) 
               conn.SetReadDeadline( 
                     time.Now().Add(time.Millisecond * 700)) 
         } 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch11/tcpclient0.go</p><p class="calibre10">The source code for the Go client follows the same pattern as we have seen in the earlier client example. The first portion of the code dials out to the server using <code class="email">net.Dial()</code>. Once a connection is obtained, the code sets up an event loop to capture text commands from the standard input, parses it, and sends it as a request to the server.</p><p class="calibre10">There is a nested loop that is set up to handle incoming responses from the server (see code comment). It continuously streams incoming bytes into variablesÂ <code class="email">buff</code> with <code class="email">conn.Read(buff)</code>. This continues until the <code class="email">Read</code> method encounters an error. The following lists the sample output produced by the client when it is executed:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; Connected to Global Currency Service</strong></span>
<span class="strong"><strong class="calibre2">curr&gt; get pound</strong></span>
<span class="strong"><strong class="calibre2">Egyptian Pound EGP 818 EGYPT</strong></span>
<span class="strong"><strong class="calibre2">Gibraltar Pound GIP 292 GIBRALTAR</strong></span>
<span class="strong"><strong class="calibre2">Sudanese Pound SDG 938 SUDAN (THE)</strong></span>
<span class="strong"><strong class="calibre2">...</strong></span>
<span class="strong"><strong class="calibre2">Syrian Pound SYP 760 SYRIAN ARAB REPUBLIC</strong></span>
<span class="strong"><strong class="calibre2">Pound Sterling GBP 826 UNITED KINGDOM OF GREAT BRITAIN (THE)</strong></span>
<span class="strong"><strong class="calibre2">curr&gt;</strong></span>
</pre><p class="calibre10">An even better way of streaming the incoming bytes from the server is to use buffered IO as done in the following snippet of code. In the updated code, the <code class="email">conbuf </code>variable, of the <code class="email">bufio.Buffer</code> type, is used to read and split incoming streams from the server using the <code class="email">conbuf.ReadString </code>method:</p><pre class="programlisting">         conbuf := bufio.NewReaderSize(conn, 1024) 
         for { 
               str, err := conbuf.ReadString('\n') 
               if err != nil { 
                     break 
               } 
               fmt.Print(str) 
               conn.SetReadDeadline( 
                     time.Now().Add(time.Millisecond * 700)) 
         } 
</pre><p class="calibre10">golang.fyi/ch11/tcpclient1.go</p><p class="calibre10">As you can see, writing networked services directly on top of raw TCP has some costs. While raw TCP gives the programmer complete control of the application-level protocol, it also requires the programmer to carefully handle all data processing which can be error-prone. Unless it is absolutely necessary to implement your own custom protocol, a better approach is to leverage an existing and proven protocols to implement your server programs. The remainder of this chapter continues to explore this topic using services that are based on HTTP as an application-level protocol.</p></div></div></body></html>