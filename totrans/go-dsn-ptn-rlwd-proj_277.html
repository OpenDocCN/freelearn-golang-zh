<html><head></head><body>
<div class="book" title="The HTTP package">
<div class="book" title="Handling client requests and responses"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec188" class="calibre1"/>Handling client requests and responses</h2></div></div></div><p class="calibre10">An <code class="email">http.Request</code> value can be explicitly created using the <code class="email">http.NewRequest</code> function. A request value can be used to configure HTTP settings, add headers, and specify the content body of the request. The following source snippet uses the <code class="email">http.Request</code> type to create a new request which is used to specify the headers sent to the server:</p><pre class="programlisting">func main() { 
   client := &amp;http.Client{} 
   req, err := http.NewRequest( 
         "GET", "http://tools.ietf.org/rfc/rfc7540.txt", nil, 
   ) 
   req.Header.Add("Accept", "text/plain") 
   req.Header.Add("User-Agent", "SampleClient/1.0") 
 
   resp, err := client.Do(req) 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
   defer resp.Body.Close() 
   io.Copy(os.Stdout, resp.Body) 
} 
</pre><p class="calibre10">golang.fyi/ch11/httpclient3.go</p><p class="calibre10">The <code class="email">http.NewRequest</code> function has the following signature:</p><pre class="programlisting">func NewRequest(method, uStr string, body io.Reader) (*http.Request, error) 
</pre><p class="calibre10">It takes a string that specifies the HTTP method as its first argument. The next argument specifies the destination URL. The last argument is an <code class="email">io.Reader</code> that can be used to specify the content of the request (or set to nil if the request has no content). The function returns a pointer to a <code class="email">http.Request</code> struct value (or a non-nil <code class="email">error</code> if one occurs). Once the request value is created, the code uses the <code class="email">Header</code> field to add HTTP headers to the request to be sent to the server.</p><p class="calibre10">Once a request is prepared (as shown in the previous source snippet), it is sent to the server using the <span class="strong"><em class="calibre11">Do</em></span> method of the <code class="email">http.Client</code> type and has the following signature:</p><pre class="programlisting">Do(req *http.Request) (*http.Response, error) 
</pre><p class="calibre10">The method accepts a pointer to an <code class="email">http.Request</code> value, as discussed in the previous section. It then returns a pointer to an <code class="email">http.Response</code> value or an error if the request fails. In the previous source code, <code class="email">resp, err := client.Do(req)</code> is used to send the request to the server and assigns the response to the <code class="email">resp </code>variable.</p><p class="calibre10">The response from the server is encapsulated in struct <code class="email">http.Response</code> which contains several fields to describe the response including the HTTP response status, content length, headers, and the response body. The response body, exposed as the <code class="email">http.Response.Body</code> field, implements the <code class="email">io.Reader</code> which affords the use streaming IO primitives to consume the response content.</p><p class="calibre10">The <code class="email">Body</code> field also implements <code class="email">
<span class="strong"><em class="calibre11">io.Closer</em></span>
</code> which allows the closing of IO resources. The previous source uses <code class="email">defer resp.Body.Close()</code> to close the IO resource associated with the response body. This is a recommended idiom when the server is expected to return a non-nil body.</p></div></div></body></html>