<html><head></head><body>
<div class="book" title="The HTTP package">
<div class="book" title="A simple HTTP server"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec189" class="calibre1"/>A simple HTTP server</h2></div></div></div><p class="calibre10">The HTTP package provides two main components to accept HTTP requests and serve responses:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">http.Handler</code> interface</li><li class="listitem">The <code class="email">http.Server</code> type</li></ul></div><p class="calibre10">The <code class="email">http.Server</code> type uses the <code class="email">http.Handler</code> interface type, defined in the following listing, to receive requests and server responses:</p><pre class="programlisting">type Handler interface { 
        ServeHTTP(ResponseWriter, *Request) 
} 
</pre><p class="calibre10">Any type that implements <code class="email">http.Handler</code> can be registered (explained next) as a valid handler. The Go <code class="email">http.Server</code> type is used to create a new server. It is a struct whose values can be configured, at a minimum, with the TCP address of the service and a handler that will respond to incoming requests. The following code snippet shows a simple HTTP server that defines the <code class="email">msg</code> type as handler registered to handle incoming client requests:</p><pre class="programlisting">type msg string 
 
func (m msg) ServeHTTP( 
   resp http.ResponseWriter, req *http.Request) { 
   resp.Header().Add("Content-Type", "text/html") 
   resp.WriteHeader(http.StatusOK) 
   fmt.Fprint(resp, m) 
} 
 
func main() { 
   msgHandler := msg("Hello from high above!") 
   server := http.Server{Addr: ":4040", Handler: msgHandler} 
   server.ListenAndServe() 
} 
</pre><p class="calibre10">golang.fyi/ch11/httpserv0.go</p><p class="calibre10">In the previous code, the <code class="email">msg</code> type, which uses a string as its underlying type, implements the <code class="email">ServeHTTP()</code> method making it a valid HTTP handler. Its <code class="email">ServeHTTP</code> method uses the response parameter, <code class="email">resp</code>, to print response headers <code class="email">"200 OK"</code> and <code class="email">"Content-Type: text/html"</code>. The method also writes the string value <code class="email">m</code> to the response variable using <code class="email">fmt.Fprint(resp, m)</code> which is sent back to the client.</p><p class="calibre10">In the code, the variable <code class="email">server</code> is initialized as <code class="email">http.Server{Addr: ":4040", Handler: msgHandler}</code>. This means the server will listen on all network interfaces at port <code class="email">4040</code> and will use variable <code class="email">msgHandler</code> as its <code class="email">http.Handler</code> implementation. Once initialized, the server is started with the <code class="email">server.ListenAndServe()</code> method call that is used to block and listen for incoming requests.</p><p class="calibre10">Besides the <code class="email">Addr</code> and <code class="email">Handler</code>, the <code class="email">http.Server</code> struct exposes several additional fields that can be used to control different aspects of the HTTP service such as connection, timeout values, header sizes, and TLS configuration. For instance, the following snippet shows an updated example which specifies the server's read and write timeouts:</p><pre class="programlisting">type msg string 
func (m msg) ServeHTTP( 
   resp http.ResponseWriter, req *http.Request) { 
   resp.Header().Add("Content-Type", "text/html") 
   resp.WriteHeader(http.StatusOK) 
   fmt.Fprint(resp, m) 
} 
func main() { 
   msgHandler := msg("Hello from high above!") 
   server := http.Server{ 
         Addr:         ":4040", 
         Handler:      msgHandler, 
         ReadTimeout:  time.Second * 5, 
         WriteTimeout: time.Second * 3, 
   } 
   server.ListenAndServe() 
} 
</pre><p class="calibre10">golang.fyi/ch11/httpserv1.go</p><div class="book" title="The default server"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec11" class="calibre1"/>The default server</h3></div></div></div><p class="calibre10">It should be noted that the HTTP package includes a default server that can be used in simpler cases when there is no need for configuration of the server. The following abbreviated code snippet starts a simple server without explicitly creating a server variable:</p><pre class="programlisting">type msg string 
 
func (m msg) ServeHTTP( 
    resp http.ResponseWriter, req *http.Request) { 
   resp.Header().Add("Content-Type", "text/html") 
   resp.WriteHeader(http.StatusOK) 
   fmt.Fprint(resp, m) 
} 
    
   func main() { 
   msgHandler := msg("Hello from high above!") 
   http.ListenAndServe(":4040", msgHandler) 
} 
 
</pre><p class="calibre10">golang.fyi/ch11/httpserv2.go</p><p class="calibre10">In the code, the <code class="email">http.ListenAndServe(":4040", msgHandler)</code> function is used to start a server which is declared as a variable in the HTTP package. The server is configured with the local address <code class="email">":4040"</code> and the handler <code class="email">msgHandler</code> (as was done earlier) to handle all incoming requests.</p></div></div></div></body></html>