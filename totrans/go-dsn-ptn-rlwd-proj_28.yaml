- en: Chapter 3. Three Ways to Implement Profile Pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our chat application has made use of the **OAuth2** protocol to allow
    users to sign in to our application so that we know who is saying what. In this
    chapter, we are going to add profile pictures to make the chatting experience
    more engaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following ways to add pictures or avatars alongside the
    messages in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the avatar picture provided by the auth service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the [https://en.gravatar.com/](https://en.gravatar.com/) web service to
    look up a picture by the user's e-mail address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the user to upload their own picture and host it themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two options allow us to delegate the hosting of pictures to a third
    party either an authorization service or [https://en.gravatar.com/](https://en.gravatar.com/) which
    is great because it reduces the cost of hosting our application (in terms of storage
    costs and bandwidth, since the user's browsers will actually download the pictures
    from the servers of the authenticating service, not ours). The third option requires
    us to host pictures ourselves at a location that is accessible on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: These options aren't mutually exclusive; you will most likely use a combination
    of them in a real-world production application. Toward the end of the chapter,
    you will see how the flexible design that emerges allows us to try each implementation
    in turn until we find an appropriate avatar.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be agile with our design throughout this chapter, doing the
    minimum work needed to accomplish each milestone. This means that at the end of
    each section, we will have working implementations that are demonstrable in the
    browser. This also means that we will refactor code as and when we need to and
    discuss the rationale behind the decisions we make as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What the good practices to get additional information from auth services are,
    even when there are no standards in place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is appropriate to build abstractions into our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Go's zero-initialization pattern can save time and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How reusing an interface allows us to work with collections and individual objects
    in the same way as the existing interface did
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the [https://en.gravatar.com/](https://en.gravatar.com/) web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do MD5 hashing in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to upload files over HTTP and store them on a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to serve static files through a Go web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use unit tests to guide the refactoring of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and when to abstract functionality from `struct` types into interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avatars from the OAuth2 server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out that most auth servers already have images for their users, and
    they make them available through the protected user resource that we already used
    in order to get our user's names. To use this avatar picture, we need to get the
    URL from the provider, store it in the cookie for our user, and send it through
    a web socket so that every client can render the picture alongside the corresponding
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the avatar URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The schema for user or profile resources is not part of the OAuth2 spec, which
    means that each provider is responsible for deciding how to represent that data.
    Indeed, providers do things differently; for example, the avatar URL in a GitHub
    user resource is stored in a field called `avatar_url`, whereas in Google, the
    same field is called `picture`. Facebook goes even further by nesting the avatar
    URL value in a `url` field inside an object called `picture`. Luckily, Gomniauth
    abstracts this for us; its `GetUser` call on a provider standardizes the interface
    to get common fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of the avatar URL field, we need to go back and store
    that information in our cookie. In `auth.go`, look inside the `callback` action
    switch case and update the code that creates the `authCookieValue` object, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `AvatarURL` field called in the preceding code will return the appropriate
    URL value and store it in our `avatar_url` field, which we then put into the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gomniauth defines a `User` type of interface and each provider implements their
    own version. The generic `map[string]interface{}` data returned from the auth
    server is stored inside each object, and the method calls access the appropriate
    value using the right field name for that provider. This approach describing the
    way information is accessed without being strict about implementation details–is
    a great use of interfaces in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting the avatar URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to update our `message` type so that it can also carry the avatar URL
    with it. In `message.go`, add the `AvatarURL` string field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have not actually assigned a value to `AvatarURL` like we do for
    the `Name` field; so, we must update our `read` method in `client.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All we have done here is take the value from the `userData` field that represents
    what we put into the cookie and assigned it to the appropriate field in `message`
    if the value was present in the map. We now take the additional step of checking
    whether the value is present because we cannot guarantee that the auth service
    would provide a value for this field. And since it could be `nil`, it might cause
    panic to assign it to a `string` type if it's actually missing.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the avatar to the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our JavaScript client gets an avatar URL value via the socket, we
    can use it to display the image alongside the messages. We do this by updating
    the `socket.onmessage` code in `chat.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we receive a message, we will insert an `img` tag with the source set to
    the `AvatarURL` field. We will use jQuery's `css` method to force a width of `50`
    pixels. This protects us from massive pictures spoiling our interface and allows
    us to align the image to the middle of the surrounding text.
  prefs: []
  type: TYPE_NORMAL
- en: If we build and run our application having logged in with a previous version,
    you will find that the `auth` cookie that doesn't contain the avatar URL is still
    there. We are not asked to authenticate again (since we are already logged in),
    and the code that adds the `avatar_url` field never gets a chance to run. We could
    delete our cookie and refresh the page, but we would have to keep doing this whenever
    we make changes during development. Let's solve this problem properly by adding
    a logout feature.
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to log out a user is to get rid of the `auth` cookie and redirect
    the user to the chat page, which will in turn cause a redirect to the login page
    (since we just removed the cookie). We do this by adding a new `HandleFunc` call
    to `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding handler function uses `http.SetCookie` to update the cookie setting
    `MaxAge` to `-1`, which indicates that it should be deleted immediately by the
    browser. Not all browsers are forced to delete the cookie, which is why we also
    provide a new `Value` setting of an empty string, thus removing the user data
    that would previously have been stored.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an additional assignment, you can bulletproof your app a little by updating
    the first line in `ServeHTTP` for your `authHandler` method in `auth.go` to make
    it cope with the empty value case as well as the missing cookie case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if cookie, err := r.Cookie("auth"); err == http.ErrNoCookie || cookie.Value
    == ""`'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of ignoring the return of `r.Cookie`, we keep a reference to the returned
    cookie (if there was actually one) and also add an additional check to see whether
    the `Value` string of the cookie is empty or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, let''s add a `Sign Out` link to make it even easier to
    get rid of the cookie and also allow our end users to log out. In `chat.html`,
    update the `chatbox` form to insert a simple HTML link to the new `/logout` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the application and open a browser to `localhost:8080/chat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Log out if you need to and log back in. When you click on **Send**, you will
    see your avatar picture appear next to your messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging out](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Making things prettier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application is starting to look a little ugly, and its time to do something
    about it. In the previous chapter, we implemented the Bootstrap library into our
    login page, and we are going to extend its use to our chat page now. We will make
    three changes in `chat.html`: include Bootstrap and tweak the CSS styles for our
    page, change the markup for our form, and tweak how we render messages on the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s update the `style` tag at the top of the page and insert a `link`
    tag above it in order to include Bootstrap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s replace the markup at the top of the `body` tag (before the `script`
    tags) with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This markup follows Bootstrap standards of applying appropriate classes to various
    items; for example, the form-control class neatly formats elements within form
    (you can check out the Bootstrap documentation for more information on what these
    classes do).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s update our `socket.onmessage` JavaScript code to put the sender''s
    name as the title attribute for our image. This makes it display the image when
    you mouse over it rather than display it next to every message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the application and refresh your browser to see whether a new
    design appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making things prettier](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With relatively few changes to the code, we have dramatically improved the look
    and feel of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Gravatar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gravatar is a web service that allows users to upload a single profile picture
    and associate it with their e-mail address in order to make it available from
    any website. Developers, like us, can access these images for our application
    just by performing a `GET` operation on a specific API endpoint. In this section,
    we will look at how to implement Gravatar rather than use the picture provided
    by the auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting the avatar URL process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have three different ways of obtaining the avatar URL in our application,
    we have reached the point where it would be sensible to learn how to abstract
    the functionality in order to cleanly implement the options. Abstraction refers
    to a process in which we separate the idea of something from its specific implementation.
    The `http.Handler` method is a great example of how a handler will be used along
    with its ins and outs, without being specific about what action is taken by each
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, we start to describe our idea of getting an avatar URL by defining an
    interface. Let''s create a new file called `avatar.go` and insert the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Avatar` interface describes the `GetAvatarURL` method that a type must
    satisfy in order to be able to get avatar URLs. We took the client as an argument
    so that we know the user for which the URL to be returned. The method returns
    two arguments: a string (which will be the URL if things go well) and an error
    in case something goes wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that could go wrong is simply that one of the specific implementations
    of `Avatar` is unable to get the URL. In that case, `GetAvatarURL` will return
    the `ErrNoAvatarURL` error as the second argument. The `ErrNoAvatarURL` error
    therefore becomes a part of the interface; it's one of the possible returns from
    the method and something that users of our code should probably explicitly handle.
    We mention this in the comments part of the code for the method, which is the
    only way to communicate such design decisions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the error is initialized immediately using `errors.New` and stored in
    the `ErrNoAvatarURL` variable, only one of these objects will ever be created;
    passing the pointer of the error as a return is inexpensive. This is unlike Java's
    checked exceptions which serve a similar purpose where expensive exception objects
    are created and used as part of the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: The auth service and the avatar's implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first implementation of `Avatar` we write will replace the existing functionality
    where we had hardcoded the avatar URL obtained from the auth service. Let''s use
    a **Test-driven Development** (**TDD**) approach so that we can be sure our code
    works without having to manually test it. Let''s create a new file called `avatar_test.go`
    in the `chat` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This file contains a test for our as-of-yet, nonexistent `AuthAvatar` type's
    `GetAvatarURL` method. First, it uses a client with no user data and ensures that
    the `ErrNoAvatarURL` error is returned. After setting a suitable URL, our test
    calls the method again this time to assert that it returns the correct value.
    However, building this code fails because the `AuthAvatar` type doesn't exist,
    so we'll declare `authAvatar` next.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write our implementation, it's worth noticing that we only declare
    the `authAvatar` variable as the `AuthAvatar` type but never actually assign anything
    to it so its value remains `nil`. This is not a mistake; we are actually making
    use of Go's zero-initialization (or default initialization) capabilities. Since
    there is no state needed for our object (we will pass `client` in as an argument),
    there is no need to waste time and memory on initializing an instance of it. In
    Go, it is acceptable to call a method on a `nil` object, provided that the method
    doesn't try to access a field. When we actually come to writing our implementation,
    we will look at a way in which we can ensure this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s head back over to `avatar.go` and make our test pass. Add the following
    code at the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define our `AuthAvatar` type as an empty struct and define the implementation
    of the `GetAvatarURL` method. We also create a handy variable called `UseAuthAvatar`
    that has the `AuthAvatar` type but which remains of `nil` value. We can later
    assign the `UseAuthAvatar` variable to any field looking for an `Avatar` interface
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GetAvatarURL` method we wrote earlier doesn't have a very nice **line of
    sight**; the happy return is buried within two `if` blocks. See if you can refactor
    it so that the last line is `return urlStr, nil` and the method exits early if
    the `avatar_url` field is missing. You can refactor with confidence, since this
    code is covered by a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: For a little more on the rationale behind this kind of refactor, refer to the
    article at [http://bit.ly/lineofsightgolang](http://bit.ly/lineofsightgolang).
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the receiver of a method (the type defined in parentheses before the
    name) will be assigned to a variable so that it can be accessed in the body of
    the method. Since, in our case, we assume the object can have `nil` value, we
    can omit a variable name to tell Go to throw away the reference. This serves as
    an added reminder to ourselves that we should avoid using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of our implementation is relatively simple otherwise: we are safely
    looking for the value of `avatar_url` and ensuring that it is a string before
    returning it. If anything fails, we return the `ErrNoAvatarURL` error, as defined
    in the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the tests by opening a terminal and then navigating to the `chat`
    folder and typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If all is well, our tests will pass and we will have successfully created our
    first `Avatar` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Using an implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we use an implementation, we could refer to either the helper variables
    directly or create our own instance of the interface whenever we need the functionality.
    However, this would defeat the object of the abstraction. Instead, we use the
    `Avatar` interface type to indicate where we need the capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our chat application, we will have a single way to obtain an avatar URL
    per chat room. So, let''s update the `room` type so it can hold an `Avatar` object.
    In `room.go`, add the following field definition to the `room struct` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `newRoom` function so that we can pass in an `Avatar` implementation
    for use; we will just assign this implementation to the new field when we create
    our `room` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the project now will highlight the fact that the call to `newRoom`
    in `main.go` is broken because we have not provided an `Avatar` argument; let''s
    update it by passing in our handy `UseAuthAvatar` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We didn't have to create an instance of `AuthAvatar`, so no memory was allocated.
    In our case, this doesn't result in great saving (since we only have one room
    for our entire application), but imagine the size of the potential savings if
    our application has thousands of rooms. The way we named the `UseAuthAvatar` variable
    means that the preceding code is very easy to read and it also makes our intention
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thinking about code readability is important when designing interfaces. Consider
    a method that takes a Boolean input just passing in true or false hides the real
    meaning if you don''t know the argument names. Consider defining a couple of helper
    constants, as shown in the following short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about which of the following calls to `move` are easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left now is to change `client` to use our new `Avatar` interface.
    In `client.go`, update the `read` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are asking the `avatar` instance in `room` to get the avatar URL for
    us instead of extracting it from `userData` ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: When you build and run the application, you will notice that (although we have
    refactored things a little) the behavior and user experience hasn't changed at
    all. This is because we told our room to use the `AuthAvatar` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's add another implementation to the room.
  prefs: []
  type: TYPE_NORMAL
- en: The Gravatar implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Gravatar implementation in `Avatar` will do the same job as the `AuthAvatar`
    implementation, except that it will generate a URL for a profile picture hosted
    on [https://en.gravatar.com/](https://en.gravatar.com/). Let''s start by adding
    a test to our `avatar_test.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Gravatar uses a hash of the e-mail address to generate a unique ID for each
    profile picture, so we set up a client and ensure `userData` contains an e-mail
    address. Next, we call the same `GetAvatarURL` method, but this time on an object
    that has the `GravatarAvatar` type. We then assert that a correct URL was returned.
    We already know this is the appropriate URL for the specified e-mail address because
    it is listed as an example in the Gravatar documentation a great strategy to ensure
    our code is doing what it should be doing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that all the source code for this book is available for download from
    the publishers and has also been published on GitHub. You can save time on building
    the preceding core by copying and pasting bits and pieces from [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints).
    Hardcoding things such as the base URL is not usually a good idea; we have hardcoded
    throughout the book to make the code snippets easier to read and more obvious,
    but you are welcome to extract them as you go along if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running these tests (with `go test`) obviously causes errors because we haven''t
    defined our types yet. Let''s head back to `avatar.go` and add the following code
    while being sure to import the `io` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the same pattern as we did for `AuthAvatar`: we have an empty struct,
    a helpful `UseGravatar` variable, and the `GetAvatarURL` method implementation
    itself. In this method, we follow Gravatar''s guidelines to generate an MD5 hash
    from the e-mail address (after we ensured it was lowercase) and append it to the
    hardcoded base URL using `fmt.Sprintf`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding method also suffers from a bad line of sight in code. Can you
    live with it, or would you want to improve the readability somehow?
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy to achieve hashing in Go thanks to the hard work put in by the
    writers of the Go standard library. The `crypto` package has an impressive array
    of cryptography and hashing capabilities all very easy to use. In our case, we
    create a new `md5` hasher and because the hasher implements the `io.Writer` interface,
    we can use `io.WriteString` to write a string of bytes to it. Calling `Sum` returns
    the current hash for the bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we end up hashing the e-mail address every time
    we need the avatar URL. This is pretty inefficient, especially at scale, but we
    should prioritize getting stuff done over optimization. If we need to, we can
    always come back later and change the way this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the tests now shows us that our code is working, but we haven''t yet
    included an e-mail address in the `auth` cookie. We do this by locating the code
    where we assign to the `authCookieValue` object in `auth.go` and updating it to
    grab the `Email` value from Gomniauth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing we must do is tell our room to use the Gravatar implementation
    instead of the `AuthAvatar` implementation. We do this by calling `newRoom` in
    `main.go` and making the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the chat program once again and head to the browser. Remember,
    since we have changed the information stored in the cookie, we must sign out and
    sign back in again in order to see our changes take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have a different image for your Gravatar account, you will notice
    that the system is now pulling the image from Gravatar instead of the auth provider.
    Using your browser''s inspector or debug tool will show you that the `src` attribute
    of the `img` tag has indeed changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Gravatar implementation](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you don't have a Gravatar account, you'll most likely see a default placeholder
    image in place of your profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading an avatar picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the third and final approach of uploading a picture, we will look at how
    to allow users to upload an image from their local hard drive to use as their
    profile picture when chatting. The file will then be served to the browsers via
    a URL. We will need a way to associate a file with a particular user to ensure
    that we associate the right picture with the corresponding messages.
  prefs: []
  type: TYPE_NORMAL
- en: User identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to uniquely identify our users, we are going to copy Gravatar's approach
    by hashing their e-mail address and using the resulting string as an identifier.
    We will store the user ID in the cookie along with the rest of the user-specific
    data. This will actually have the added benefit of removing the inefficiency associated
    with continuous hashing from `GravatarAuth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth.go`, replace the code that creates the `authCookieValue` object with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have hashed the e-mail address and stored the resulting value in the
    `userid` field at the point at which the user logs in. From now on, we can use
    this value in our Gravatar code instead of hashing the e-mail address for every
    message. To do this, first, we update the test by removing the following line
    from `avatar_test.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then replace the preceding line with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to set the `email` field since it is not used; instead, we
    just have to set an appropriate value to the new `userid` field. However, if you
    run `go test` in a terminal, you will see this test fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, in `avatar.go`, update the `GetAvatarURL` method for
    the `GravatarAuth` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This won't change the behavior, but it allows us to make an unexpected optimization,
    which is a great example of why you shouldn't optimize code too early the inefficiencies
    that you spot early on may not last long enough to warrant the effort required
    to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: An upload form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If our users are to upload a file as their avatar, they need a way to browse
    their local hard drive and submit the file to the server. We facilitate this by
    adding a new template-driven page. In the `chat/templates` folder, create a file
    called `upload.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We used Bootstrap again to make our page look nice and also to make it fit in
    with the other pages. However, the key point to note here is the HTML form that
    will provide the user interface required to upload files. The action points to
    `/uploader`, the handler for which we have yet to implement, and the `enctype`
    attribute must be `multipart/form-data` so that the browser can transmit binary
    data over HTTP. Then, there is an `input` element of the type `file`, which will
    contain a reference to the file we want to upload. Also, note that we have included
    the `userid` value from the `UserData` map as a hidden input this will tell us
    which user is uploading a file. It is important that the `name` attributes be
    correct, as this is how we will refer to the data when we implement our handler
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now map the new template to the `/upload` path in `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Handling the upload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user clicks on **Upload** after selecting a file, the browser will
    send the data for the file as well as the user ID to `/uploader`, but right now,
    that data doesn't actually go anywhere. We will implement a new `HandlerFunc`
    interface that is capable of receiving the file, reading the bytes that are streamed
    through the connection, and saving it as a new file on the server. In the `chat`
    folder, let's create a new folder called `avatars` this is where we will save
    the avatar image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new file called `upload.go` and insert the following code make
    sure that you add the appropriate package name and imports (which are `ioutils`,
    `net/http`, `io`, and `path`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, first `uploaderHandler` uses the `FormValue` method in `http.Request`
    to get the user ID that we placed in the hidden input in our HTML form. Then,
    it gets an `io.Reader` type capable of reading the uploaded bytes by calling `req.FormFile`,
    which returns three arguments. The first argument represents the file itself with
    the `multipart.File` interface type, which is also `io.Reader`. The second is
    a `multipart.FileHeader` object that contains the metadata about the file, such
    as the filename. And finally, the third argument is an error that we hope will
    have a `nil` value.
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean when we say that the `multipart.File` interface type is also
    `io.Reader`? Well, a quick glance at the documentation at [http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)
    makes it clear that the type is actually just a wrapper interface for a few other
    more general interfaces. This means that a `multipart.File` type can be passed
    to methods that require `io.Reader`, since any object that implements `multipart.File`
    must, therefore, implement `io.Reader`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedding standard library interfaces, such as the wrapper, to describe new
    concepts is a great way to make sure your code works in as many contexts as possible.
    Similarly, you should try to write code that uses the simplest interface type
    you can find, ideally from the standard library. For example, if you wrote a method
    that needed you to read the contents of a file, you could ask the user to provide
    an argument of the type `multipart.File`. However, if you ask for `io.Reader`
    instead, your code will become significantly more flexible because any type that
    has the appropriate `Read` method can be passed in, which includes user-defined
    types as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `ioutil.ReadAll` method will just keep reading from the specified `io.Reader`
    interface until all of the bytes have been received, so this is where we actually
    receive the stream of bytes from the client. We then use `path.Join` and `path.Ext`
    to build a new filename using `userid` and copy the extension from the original
    filename that we can get from `multipart.FileHeader`.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `ioutil.WriteFile` method to create a new file in the `avatars`
    folder. We use `userid` in the filename to associate the image with the correct
    user, much in the same way as Gravatar does. The `0777` value specifies that the
    new file we create should have complete file permissions, which is a good default
    setting if you're not sure what other permissions should be set.
  prefs: []
  type: TYPE_NORMAL
- en: If an error occurs at any stage, our code will write it out to the response
    along with a 500 status code (since we specify `http.StatusInternalServerError`),
    which will help us debug it, or it will write **Successful** if everything went
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to map this new handler function to `/uploader`, we need to head back
    to `main.go` and add the following line to `func main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the application and remember to log out and log back in again
    in order to give our code a chance to upload the `auth` cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://localhost:8080/upload` and click on **Choose File**, and then select
    a file from your hard drive and click on **Upload**. Navigate to your `chat/avatars`
    folder and you will notice that the file was indeed uploaded and renamed to the
    value of your `userid` field.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a place to keep our user''s avatar images on the server, we
    need a way to make them accessible to the browser. We do this using the `net/http`
    package''s built-in file server. In `main.go`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is actually a single line of code that has been broken up to improve readability.
    The `http.Handle` call should feel familiar, as we are specifying that we want
    to map the `/avatars/` path with the specified handler this is where things get
    interesting. Both `http.StripPrefix` and `http.FileServer` return `http.Handler`,
    and they make use of the wrapping pattern we learned about in the previous chapter.
    The `StripPrefix` function takes `http.Handler` in, modifies the path by removing
    the specified prefix, and passes the functionality onto an inner handler. In our
    case, the inner handler is an `http.FileServer` handler that will simply serve
    static files, provide index listings, and generate the `404 Not Found` error if
    it cannot find the file. The `http.Dir` function allows us to specify which folder
    we want to expose publicly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we didn't strip the `/avatars/` prefix from the requests with `http.StripPrefix`,
    the file server would look for another folder called `avatars` inside the actual
    `avatars` folder, that is, `/avatars/avatars/filename` instead of `/avatars/filename`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build the program and run it before opening `http://localhost:8080/avatars/`
    in a browser. You'll notice that the file server has generated a listing of the
    files inside our `avatars` folder. Clicking on a file will either download the
    file, or in the case of an image, simply display it. If you haven't done this
    already, go to `http://localhost:8080/upload` and upload a picture, and then head
    back to the listing page and click on it to see it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The Avatar implementation for local files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step in making filesystem avatars work is writing an implementation
    of our `Avatar` interface that generates URLs that point to the filesystem endpoint
    we created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test function to our `avatar_test.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This test is similar to, but slightly more involved than, the `GravatarAvatar`
    test because we are also creating a test file in our `avatars` folder and deleting
    it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if our test code panics, the deferred functions will still be called. So
    regardless of what happens, our test code will clean up after itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the test is simple: we set a `userid` field in `client.userData`
    and call `GetAvatarURL` to ensure we get the right value back. Of course, running
    this test will fail, so let''s go and add the following code in order to make
    it pass in `avatar.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, in order to generate the correct URL, we simply get the
    `userid` value and build the final string by adding the appropriate segments together.
    You may have noticed that we have hardcoded the file extension to `.jpg`, which
    means that the initial version of our chat application will only support JPEGs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Supporting only JPEGs might seem like a half-baked solution, but following Agile
    methodologies, this is perfectly fine; after all, custom JPEG profile pictures
    are better than no custom profile pictures at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our new code in action by updating `main.go` to use our new
    `Avatar` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now build and run the application as usual and go to `http://localhost:8080/upload`
    and use a web form to upload a JPEG image to use as your profile picture. To make
    sure it's working correctly, choose a unique image that isn't your Gravatar picture
    or the image from the auth service. Once you see the successful message after
    clicking on **Upload**, go to `http://localhost:8080/chat` and post a message.
    You will notice that the application has indeed used the profile picture that
    you uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: To change your profile picture, go back to the `/upload` page and upload a different
    picture, and then jump back to the `/chat` page and post more messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Avatar implementation for local files](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Supporting different file types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To support different file types, we have to make our `GetAvatarURL` method for
    the `FileSystemAvatar` type a little smarter.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just blindly building the string, we will use the very important
    `ioutil.ReadDir` method to get a listing of the files. The listing also includes
    directories so we will use the `IsDir` method to determine whether we should skip
    it or not.
  prefs: []
  type: TYPE_NORMAL
- en: We will then check whether each file matches the `userid` field (remember that
    we named our files in this way) by a call to `path.Match`. If the filename matches
    the `userid` field, then we have found the file for that user and we return the
    path. If anything goes wrong or if we can't find the file, we return the `ErrNoAvatarURL`
    error as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the appropriate method in `avatar.go` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Delete all the files in the `avatar` folder to prevent confusion and rebuild
    the program. This time, upload an image of a different type and note that our
    application has no difficulty handling it.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and optimizing our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we look back at how our `Avatar` type is used, you will notice that every
    time someone sends a message, the application makes a call to `GetAvatarURL`.
    In our latest implementation, each time the method is called, we iterate over
    all the files in the `avatars` folder. For a particularly chatty user, this could
    mean that we end up iterating over and over again many times a minute. This is
    an obvious waste of resources and would, at some point very soon, become a scaling
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of getting the avatar URL for every message, we should get it only once
    when the user first logs in and cache it in the `auth` cookie. Unfortunately,
    our `Avatar` interface type requires that we pass in a `client` object to the
    `GetAvatarURL` method and we do not have such an object at the point at which
    we are authenticating the user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So did we make a mistake when we designed our `Avatar` interface? While this
    is a natural conclusion to come to, in fact we did the right thing. We designed
    the solution with the best information we had available at the time and therefore
    had a working chat application much sooner than if we'd tried to design for every
    possible future case. Software evolves and almost always changes during the development
    process and will definitely change throughout the lifetime of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing concrete types with interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have concluded that our `GetAvatarURL` method depends on a type that is not
    available to us at the point we need it, so what would be a good alternative?
    We could pass each required field as a separate argument, but this would make
    our interface brittle, since as soon as an `Avatar` implementation needs a new
    piece of information, we'd have to change the method signature. Instead, we will
    create a new type that will encapsulate the information our `Avatar` implementations
    need while conceptually remaining decoupled from our specific case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth.go`, add the following code to the top of the page (underneath the
    `package` keyword, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we only actually implemented one of the two required
    methods to satisfy our `ChatUser` interface. We got away with this because the
    Gomniauth `User` interface happens to define the same `AvatarURL` method. In practice,
    when we instantiate our `chatUser` struct provided we set an appropriate value
    for the implied Gomniauth `User` field our object implements both Gomniauth's
    `User` interface and our own `ChatUser` interface at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Changing interfaces in a test-driven way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can use our new type, we must update the `Avatar` interface and appropriate
    implementations to make use of it. As we will follow TDD practices, we are going
    to first make these changes in our test file, see the compiler errors when we
    try to build our code, and see failing tests once we fix those errors before finally
    making the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `avatar_test.go` and replace `TestAuthAvatar` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will also need to import the `gomniauth/test` package as `gomniauthtest`,
    like we did in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: Using our new interface before we have defined it is a good way to check the
    sanity of our thinking, which is another advantage of practicing TDD. In this
    new test, we create `TestUser` provided by Gomniauth and embed it into a `chatUser`
    type. We then pass the new `chatUser` type into our `GetAvatarURL` calls and make
    the same assertions about output as we always have done.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gomniauth's `TestUser` type is interesting as it makes use of the `Testify`
    package's mocking capabilities. Refer to [https://github.com/stretchr/testify](https://github.com/stretchr/testify)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The `On` and `Return` methods allow us to tell `TestUser` what to do when specific
    methods are called. In the first case, we tell the `AvatarURL` method to return
    the error, and in the second case, we ask it to return the `testUrl` value, which
    simulates the two possible outcomes we are covering in this test.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the other two tests is much simpler because they rely only on the `UniqueID`
    method, the value of which we can control directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the other two tests in `avatar_test.go` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this test code won''t even compile because we are yet to update
    our `Avatar` interface. In `avatar.go`, update the `GetAvatarURL` signature in
    the `Avatar` interface type to take a `ChatUser` type rather than a `client` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are using the `ChatUser` interface (with the starting letter in
    uppercase) rather than our internal `chatUser` implementation struct after all,
    we want to be flexible about the types our `GetAvatarURL` methods accept.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to build this will reveal that we now have broken implementations because
    all the `GetAvatarURL` methods are still asking for a `client` object.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the existing implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing an interface like the one we have is a good way to automatically find
    the parts of our code that have been affected because they will cause compiler
    errors. Of course, if we were writing a package that other people would use, we
    would have to be far stricter about changing the interfaces like this, but we
    haven't released our v1 yet, so it's fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to update the three implementation signatures to satisfy the
    new interface and change the method bodies to make use of the new type. Replace
    the implementation for `FileSystemAvatar` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The key change here is that we no longer access the `userData` field on the
    client, and just call `UniqueID` directly on the `ChatUser` interface instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we update the `AuthAvatar` implementation with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our new design proves to be much simpler, it's always a good thing if we can
    reduce the amount of code required. The preceding code makes a call to get the
    `AvatarURL` value, and provided it isn't empty, we return it; otherwise, we return
    the `ErrNoAvatarURL` error.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how the expected flow of the code is indented to one level, while error
    cases are nested inside `if` blocks. While you can't stick to this practice 100%
    of the time, it's a worthwhile endeavor. Being able to quickly scan the code (when
    reading it) to see the normal flow of execution down a single column allows you
    to understand the code much quicker. Compare this to code that has lots of `if...else`
    nested blocks, which takes a lot more unpicking to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the `GravatarAvatar` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Global variables versus fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have assigned the `Avatar` implementation to the `room` type, which
    enables us to use different avatars for different rooms. However, this has exposed
    an issue: when our users sign in, there is no concept of which room they are headed
    to so we cannot know which `Avatar` implementation to use. Because our application
    only supports a single room, we are going to look at another approach to select
    implementations: the use of global variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A global variable is simply a variable that is defined outside any type definition
    and is accessible from every part of the package (and from outside the package
    if it''s exported). For a simple configuration, such as which type of `Avatar`
    implementation to use, global variables are an easy and simple solution. Underneath
    the `import` statements in `main.go`, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This defines `avatars` as a global variable that we can use when we need to
    get the avatar URL for a particular user.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our new design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to change the code that calls `GetAvatarURL` for every message to just
    access the value that we put into the `userData` cache (via the `auth` cookie).
    Change the line where `msg.AvatarURL` is assigned, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the code inside `loginHandler` in `auth.go` where we call `provider.GetUser`
    and replace it, down to where we set the `authCookieValue` object, with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a new `chatUser` variable while setting the `User` field (which
    represents the embedded interface) to the `User` value returned from Gomniauth.
    We then saved the `userid` MD5 hash to the `uniqueID` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `avatars.GetAvatarURL` is where all of our hard work has paid off,
    as we now get the avatar URL for the user far earlier in the process. Update the
    `authCookieValue` line in `auth.go` to cache the avatar URL in the cookie and
    remove the e-mail address since it is no longer required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However expensive the work the `Avatar` implementation needs to do, such as
    iterating over files on the filesystem, it is mitigated by the fact that the implementation
    only does so when the user first logs in and not every time they send a message.
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up and testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we get to snip away at some of the fat that has accumulated during
    our refactoring process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we no longer store the `Avatar` implementation in `room`, let''s remove
    the field and all references to it from the type. In `room.go`, delete the `avatar
    Avatar` definition from the `room` struct and update the `newRoom` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to use the compiler as your to-do list where possible, and follow the
    errors to find where you have impacted other code.
  prefs: []
  type: TYPE_NORMAL
- en: In `main.go`, remove the parameter passed into the `newRoom` function call since
    we are using our global variable instead of this one.
  prefs: []
  type: TYPE_NORMAL
- en: After this exercise, the end user experience remains unchanged. Usually when
    refactoring the code, it is the internals that are modified while the public-facing
    interface remains stable and unchanged. As you go, remember to re-run the unit
    tests to make sure you don't break anything as you evolve the code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's usually a good idea to run tools such as `golint` and `go vet` against
    your code as well in order to make sure it follows good practices and doesn't
    contain any Go faux pas, such as missing comments or badly named functions. There
    are a few deliberately left in for you to fix yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Combining all three implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To close this chapter with a bang, we will implement a mechanism in which each
    `Avatar` implementation takes a turn in trying to get a URL for a user. If the
    first implementation returns the `ErrNoAvatarURL` error, we will try the next
    and so on until we find a useable value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `avatar.go`, underneath the `Avatar` type, add the following type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TryAvatars` type is simply a slice of `Avatar` objects that we are free
    to add methods to. Let''s add the following `GetAvatarURL` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This means that `TryAvatars` is now a valid `Avatar` implementation and can
    be used in place of any specific implementation. In the preceding method, we iterated
    over the slice of `Avatar` objects in an order, calling `GetAvatarURL` for each
    one. If no error is returned, we return the URL; otherwise, we carry on looking.
    Finally, if we are unable to find a value, we just return `ErrNoAvatarURL` as
    per the interface design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `avatars` global variable in `main.go` to use our new implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a new instance of our `TryAvatars` slice type while putting
    the other `Avatar` implementations inside it. The order matters since it iterates
    over the objects in the order in which they appear in the slice. So, first our
    code will check whether the user has uploaded a picture; if they haven't, the
    code will check whether the auth service has a picture for us to use. If the approaches
    fail, a Gravatar URL will be generated, which in the worst case (for example,
    if the user hasn't added a Gravatar picture) will render a default placeholder
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see our new functionality in action, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and rerun the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Log out by visiting `http://localhost:8080/logout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all the pictures from the `avatars` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log back in by navigating to `http://localhost:8080/chat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send some messages and take note of your profile picture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit `http://localhost:8080/upload` and upload a new profile picture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out again and log back in as you did earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send some more messages and note that your profile picture has been updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added three different implementations of profile pictures
    to our chat application. First, we asked the auth service to provide a URL for
    us to use. We did this using Gomniauth's abstraction of the user resource data,
    which we then included as part of the user interface every time a user would send
    a message. Using Go's zero (or default) initialization, we were able to refer
    to different implementations of our `Avatar` interface without actually creating
    any instances.
  prefs: []
  type: TYPE_NORMAL
- en: We stored data in a cookie for when the user would log in. Given the fact that
    cookies persist between builds of our code, we added a handy logout feature to
    help us validate our changes, which we also exposed to our users so that they
    could log out too. Other small changes to the code and the inclusion of Bootstrap
    on our chat page dramatically improved the look and feel of our application.
  prefs: []
  type: TYPE_NORMAL
- en: We used MD5 hashing in Go to implement the [https://en.gravatar.com/](https://en.gravatar.com/)
    API by hashing the e-mail address that the auth service provided. If the e-mail
    address is not known to Gravatar, they will deliver a nice default placeholder
    image for us, which means our user interface will never be broken due to missing
    images.
  prefs: []
  type: TYPE_NORMAL
- en: We then built and completed an upload form and associated the server functionality
    that saved uploaded pictures in the `avatars` folder. We saw how to expose the
    saved uploaded pictures to users via the standard library's `http.FileServer`
    handler. As this introduced inefficiencies in our design by causing too much filesystem
    access, we refactored our solution with the help of our unit tests. By moving
    the `GetAvatarURL` call to the point at which users log in rather than every time
    a message is sent, we made our code significantly more scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Our special `ErrNoAvatarURL` error type was used as part of our interface design
    in order to allow us to inform the calling code when it was not possible to obtain
    an appropriate URL this became particularly useful when we created our `Avatars`
    slice type. By implementing the `Avatar` interface on a slice of `Avatar` types,
    we were able to create a new implementation that took turns trying to get a valid
    URL from each of the different options available, starting with the filesystem,
    then the auth service, and finally Gravatar. We achieved this with zero impact
    on how the user would interact with the interface. If an implementation returned
    `ErrNoAvatarURL`, we tried the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Our chat application is ready to go live, so we can invite our friends and have
    a real conversation. But first, we need to choose a domain name to host it at,
    something we will look at in the next chapter.
  prefs: []
  type: TYPE_NORMAL
