- en: Chapter 3. Three Ways to Implement Profile Pictures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 实现个人头像的三种方式
- en: So far, our chat application has made use of the **OAuth2** protocol to allow
    users to sign in to our application so that we know who is saying what. In this
    chapter, we are going to add profile pictures to make the chatting experience
    more engaging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的聊天应用程序已经使用了**OAuth2**协议来允许用户登录我们的应用程序，这样我们就能知道是谁在说什么。在本章中，我们将添加个人头像，使聊天体验更加吸引人。
- en: 'We will look at the following ways to add pictures or avatars alongside the
    messages in our application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下几种在应用程序中的消息旁边添加图片或头像的方法：
- en: Using the avatar picture provided by the auth service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用认证服务提供的头像图片
- en: Using the [https://en.gravatar.com/](https://en.gravatar.com/) web service to
    look up a picture by the user's e-mail address
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[https://en.gravatar.com/](https://en.gravatar.com/)网络服务通过用户的电子邮件地址查找图片
- en: Allowing the user to upload their own picture and host it themselves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户上传自己的图片并自行托管
- en: The first two options allow us to delegate the hosting of pictures to a third
    party either an authorization service or [https://en.gravatar.com/](https://en.gravatar.com/) which
    is great because it reduces the cost of hosting our application (in terms of storage
    costs and bandwidth, since the user's browsers will actually download the pictures
    from the servers of the authenticating service, not ours). The third option requires
    us to host pictures ourselves at a location that is accessible on the Web.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种选项允许我们将图片的托管委托给第三方，无论是授权服务还是[https://en.gravatar.com/](https://en.gravatar.com/)，这很好，因为它减少了我们托管应用程序的成本（在存储成本和带宽方面，因为用户的浏览器实际上会从认证服务的服务器下载图片，而不是我们的服务器）。第三种选项要求我们自己在网络上可访问的位置托管图片。
- en: These options aren't mutually exclusive; you will most likely use a combination
    of them in a real-world production application. Toward the end of the chapter,
    you will see how the flexible design that emerges allows us to try each implementation
    in turn until we find an appropriate avatar.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项不是相互排斥的；你很可能在实际的生产应用程序中结合使用它们。在本章的结尾，你将看到灵活的设计如何使我们能够依次尝试每种实现，直到找到合适的头像。
- en: We are going to be agile with our design throughout this chapter, doing the
    minimum work needed to accomplish each milestone. This means that at the end of
    each section, we will have working implementations that are demonstrable in the
    browser. This also means that we will refactor code as and when we need to and
    discuss the rationale behind the decisions we make as we go.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对设计保持敏捷，完成每个里程碑所需的最少工作。这意味着在每个部分的结尾，我们将有可演示的、在浏览器中可工作的实现。这也意味着我们将根据需要重构代码，并在进行决策时讨论其背后的理由。
- en: 'Specifically, in this chapter, you will learn:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，你将学习：
- en: What the good practices to get additional information from auth services are,
    even when there are no standards in place
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使没有标准，从认证服务中获取额外信息的良好实践是什么
- en: When it is appropriate to build abstractions into our code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么情况下将抽象构建到我们的代码中是合适的
- en: How Go's zero-initialization pattern can save time and memory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的零初始化模式如何节省时间和内存
- en: How reusing an interface allows us to work with collections and individual objects
    in the same way as the existing interface did
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过重用接口以与现有接口相同的方式处理集合和单个对象
- en: How to use the [https://en.gravatar.com/](https://en.gravatar.com/) web service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用[https://en.gravatar.com/](https://en.gravatar.com/)网络服务
- en: How to do MD5 hashing in Go
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Go中进行MD5哈希
- en: How to upload files over HTTP and store them on a server
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过HTTP上传文件并将它们存储在服务器上
- en: How to serve static files through a Go web server
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过Go网络服务器提供静态文件
- en: How to use unit tests to guide the refactoring of code
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用单元测试来指导代码重构
- en: How and when to abstract functionality from `struct` types into interfaces
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及何时将功能从`struct`类型抽象到接口中
- en: Avatars from the OAuth2 server
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自OAuth2服务器的头像
- en: It turns out that most auth servers already have images for their users, and
    they make them available through the protected user resource that we already used
    in order to get our user's names. To use this avatar picture, we need to get the
    URL from the provider, store it in the cookie for our user, and send it through
    a web socket so that every client can render the picture alongside the corresponding
    message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，大多数认证服务器已经为他们的用户提供了图像，并且他们通过我们已使用来获取用户名的受保护用户资源提供这些图像。为了使用这个头像图片，我们需要从提供者那里获取URL，将其存储在我们的用户cookie中，并通过Websocket发送，以便每个客户端都可以在相应的消息旁边渲染图片。
- en: Getting the avatar URL
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取头像URL
- en: The schema for user or profile resources is not part of the OAuth2 spec, which
    means that each provider is responsible for deciding how to represent that data.
    Indeed, providers do things differently; for example, the avatar URL in a GitHub
    user resource is stored in a field called `avatar_url`, whereas in Google, the
    same field is called `picture`. Facebook goes even further by nesting the avatar
    URL value in a `url` field inside an object called `picture`. Luckily, Gomniauth
    abstracts this for us; its `GetUser` call on a provider standardizes the interface
    to get common fields.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户或配置文件资源的模式不是OAuth2规范的一部分，这意味着每个提供者都有责任决定如何表示这些数据。确实，提供者做事情的方式不同；例如，GitHub用户资源中的头像URL存储在一个名为`avatar_url`的字段中，而在Google中，相同的字段称为`picture`。Facebook甚至更进一步，将头像URL值嵌套在一个名为`picture`的对象的`url`字段中。幸运的是，Gomniauth为我们抽象了这一点；它在提供者标准上的`GetUser`调用标准化了获取常用字段的接口。
- en: 'In order to make use of the avatar URL field, we need to go back and store
    that information in our cookie. In `auth.go`, look inside the `callback` action
    switch case and update the code that creates the `authCookieValue` object, as
    follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用头像URL字段，我们需要返回并存储该信息到我们的cookie中。在`auth.go`中，查看`callback`动作的switch case内部，并更新创建`authCookieValue`对象的代码，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `AvatarURL` field called in the preceding code will return the appropriate
    URL value and store it in our `avatar_url` field, which we then put into the cookie.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中调用的`AvatarURL`字段将返回适当的URL值，并将其存储在我们的`avatar_url`字段中，然后我们将其放入cookie中。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Gomniauth defines a `User` type of interface and each provider implements their
    own version. The generic `map[string]interface{}` data returned from the auth
    server is stored inside each object, and the method calls access the appropriate
    value using the right field name for that provider. This approach describing the
    way information is accessed without being strict about implementation details–is
    a great use of interfaces in Go.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Gomniauth定义了一个`User`类型的接口，每个提供者实现自己的版本。从认证服务器返回的通用`map[string]interface{}`数据存储在每个对象中，方法调用使用正确的字段名访问相应的值。这种描述信息访问方式而不严格关注实现细节的方法——是Go中使用接口的绝佳例子。
- en: Transmitting the avatar URL
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输头像URL
- en: 'We need to update our `message` type so that it can also carry the avatar URL
    with it. In `message.go`, add the `AvatarURL` string field:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新我们的`message`类型，使其也能携带头像URL。在`message.go`中添加`AvatarURL`字符串字段：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So far, we have not actually assigned a value to `AvatarURL` like we do for
    the `Name` field; so, we must update our `read` method in `client.go`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上并没有为`AvatarURL`字段分配值，就像我们对`Name`字段所做的那样；因此，我们必须更新`client.go`中的`read`方法：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All we have done here is take the value from the `userData` field that represents
    what we put into the cookie and assigned it to the appropriate field in `message`
    if the value was present in the map. We now take the additional step of checking
    whether the value is present because we cannot guarantee that the auth service
    would provide a value for this field. And since it could be `nil`, it might cause
    panic to assign it to a `string` type if it's actually missing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的一切只是从表示我们放入cookie中的`userData`字段中获取值，并将其分配给`message`中的相应字段，如果该值存在于映射中。我们现在采取额外的步骤来检查值是否存在，因为我们不能保证认证服务会为这个字段提供一个值。而且，由于它可能是`nil`，如果实际上缺失，将其分配给`string`类型可能会引起panic。
- en: Adding the avatar to the user interface
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将头像添加到用户界面
- en: 'Now that our JavaScript client gets an avatar URL value via the socket, we
    can use it to display the image alongside the messages. We do this by updating
    the `socket.onmessage` code in `chat.html`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在JavaScript客户端通过socket获取了头像URL值，我们可以使用它来在消息旁边显示图像。我们通过更新`chat.html`中的`socket.onmessage`代码来完成此操作：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we receive a message, we will insert an `img` tag with the source set to
    the `AvatarURL` field. We will use jQuery's `css` method to force a width of `50`
    pixels. This protects us from massive pictures spoiling our interface and allows
    us to align the image to the middle of the surrounding text.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到消息时，我们将插入一个 `img` 标签，其源设置为 `AvatarURL` 字段。我们将使用jQuery的 `css` 方法强制宽度为 `50`
    像素。这可以保护我们免受大量图片破坏我们的界面，并允许我们将图像与周围的文本对齐。
- en: If we build and run our application having logged in with a previous version,
    you will find that the `auth` cookie that doesn't contain the avatar URL is still
    there. We are not asked to authenticate again (since we are already logged in),
    and the code that adds the `avatar_url` field never gets a chance to run. We could
    delete our cookie and refresh the page, but we would have to keep doing this whenever
    we make changes during development. Let's solve this problem properly by adding
    a logout feature.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前版本登录并构建和运行我们的应用程序，你会发现仍然存在不包含头像URL的 `auth` cookie。我们没有再次被要求进行身份验证（因为我们已经登录），添加
    `avatar_url` 字段的代码也从未有机会运行。我们可以删除我们的cookie并刷新页面，但我们在开发过程中每次更改时都必须这样做。让我们通过添加登出功能来正确解决这个问题。
- en: Logging out
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登出
- en: 'The simplest way to log out a user is to get rid of the `auth` cookie and redirect
    the user to the chat page, which will in turn cause a redirect to the login page
    (since we just removed the cookie). We do this by adding a new `HandleFunc` call
    to `main.go`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 退出用户的最简单方法是删除 `auth` cookie 并将用户重定向到聊天页面，这将反过来导致重定向到登录页面（因为我们刚刚删除了cookie）。我们通过在
    `main.go` 中添加一个新的 `HandleFunc` 调用来实现这一点：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding handler function uses `http.SetCookie` to update the cookie setting
    `MaxAge` to `-1`, which indicates that it should be deleted immediately by the
    browser. Not all browsers are forced to delete the cookie, which is why we also
    provide a new `Value` setting of an empty string, thus removing the user data
    that would previously have been stored.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个处理函数使用 `http.SetCookie` 更新cookie设置 `MaxAge` 为 `-1`，这表示浏览器应立即删除它。并非所有浏览器都会强制删除cookie，这就是为什么我们还提供了一个新的空字符串
    `Value` 设置，从而删除之前存储的用户数据。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'As an additional assignment, you can bulletproof your app a little by updating
    the first line in `ServeHTTP` for your `authHandler` method in `auth.go` to make
    it cope with the empty value case as well as the missing cookie case:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的任务，你可以通过更新 `auth.go` 中 `authHandler` 方法的 `ServeHTTP` 中的第一行来使你的应用程序更加健壮，使其能够处理空值情况以及缺失cookie的情况：
- en: '`if cookie, err := r.Cookie("auth"); err == http.ErrNoCookie || cookie.Value
    == ""`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`if cookie, err := r.Cookie("auth"); err == http.ErrNoCookie || cookie.Value
    == ""`'
- en: Instead of ignoring the return of `r.Cookie`, we keep a reference to the returned
    cookie (if there was actually one) and also add an additional check to see whether
    the `Value` string of the cookie is empty or not.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再忽略 `r.Cookie` 的返回值，我们保留返回的cookie的引用（如果实际上有一个的话），并添加一个额外的检查来查看cookie的 `Value`
    字符串是否为空。
- en: 'Before we continue, let''s add a `Sign Out` link to make it even easier to
    get rid of the cookie and also allow our end users to log out. In `chat.html`,
    update the `chatbox` form to insert a simple HTML link to the new `/logout` handler:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们添加一个 `登出` 链接，使其更容易删除cookie，并允许我们的最终用户登出。在 `chat.html` 中，更新 `chatbox`
    表单以插入一个简单的HTML链接到新的 `/logout` 处理程序：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now build and run the application and open a browser to `localhost:8080/chat`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序，并在浏览器中打开 `localhost:8080/chat`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Log out if you need to and log back in. When you click on **Send**, you will
    see your avatar picture appear next to your messages:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，请登出并重新登录。当你点击 **发送** 时，你会看到你的头像图片出现在你的消息旁边：
- en: '![Logging out](img/00051.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![登出](img/00051.jpeg)'
- en: Making things prettier
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让事物更美观
- en: 'Our application is starting to look a little ugly, and its time to do something
    about it. In the previous chapter, we implemented the Bootstrap library into our
    login page, and we are going to extend its use to our chat page now. We will make
    three changes in `chat.html`: include Bootstrap and tweak the CSS styles for our
    page, change the markup for our form, and tweak how we render messages on the
    page:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序开始看起来有点丑陋，是时候做些改变了。在上一章中，我们将Bootstrap库集成到我们的登录页面中，现在我们将扩展其使用到我们的聊天页面。在
    `chat.html` 中，我们将进行三项更改：包含Bootstrap并调整页面的CSS样式，更改表单的标记，以及调整我们在页面上渲染消息的方式：
- en: 'First, let''s update the `style` tag at the top of the page and insert a `link`
    tag above it in order to include Bootstrap:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们更新页面顶部的`style`标签，并在其上方插入一个`link`标签以包含Bootstrap：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let''s replace the markup at the top of the `body` tag (before the `script`
    tags) with the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们用以下代码替换`body`标签顶部的标记（在`script`标签之前）：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This markup follows Bootstrap standards of applying appropriate classes to various
    items; for example, the form-control class neatly formats elements within form
    (you can check out the Bootstrap documentation for more information on what these
    classes do).
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此标记遵循Bootstrap标准，为各种项目应用适当的类；例如，form-control类可以整洁地格式化表单内的元素（你可以查看Bootstrap文档以获取有关这些类如何工作的更多信息）。
- en: 'Finally, let''s update our `socket.onmessage` JavaScript code to put the sender''s
    name as the title attribute for our image. This makes it display the image when
    you mouse over it rather than display it next to every message:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们更新我们的`socket.onmessage` JavaScript代码，将发送者的名字作为图像的标题属性。这样，当鼠标悬停时，它会显示图像，而不是在每条消息旁边显示它：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build and run the application and refresh your browser to see whether a new
    design appears:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，刷新浏览器以查看是否出现新的设计：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding command shows the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令显示了以下输出：
- en: '![Making things prettier](img/00052.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使事物更美观](img/00052.jpeg)'
- en: With relatively few changes to the code, we have dramatically improved the look
    and feel of our application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行相对较少的修改，我们显著提高了应用程序的外观和感觉。
- en: Implementing Gravatar
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Gravatar
- en: Gravatar is a web service that allows users to upload a single profile picture
    and associate it with their e-mail address in order to make it available from
    any website. Developers, like us, can access these images for our application
    just by performing a `GET` operation on a specific API endpoint. In this section,
    we will look at how to implement Gravatar rather than use the picture provided
    by the auth service.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Gravatar是一个允许用户上传单个个人照片并将其与他们的电子邮件地址关联的在线服务，以便在任何网站上都可以访问。像我们这样的开发者可以通过对特定API端点执行`GET`操作来访问这些图像。在本节中，我们将探讨如何实现Gravatar而不是使用由认证服务提供的图片。
- en: Abstracting the avatar URL process
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象头像URL过程
- en: Since we have three different ways of obtaining the avatar URL in our application,
    we have reached the point where it would be sensible to learn how to abstract
    the functionality in order to cleanly implement the options. Abstraction refers
    to a process in which we separate the idea of something from its specific implementation.
    The `http.Handler` method is a great example of how a handler will be used along
    with its ins and outs, without being specific about what action is taken by each
    handler.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在应用程序中有三种获取头像URL的不同方式，我们已经达到了一个合理的点，即学习如何抽象功能以干净地实现选项。抽象是指将某物的概念与其特定的实现分离的过程。`http.Handler`方法是一个很好的例子，说明了如何使用处理程序及其输入输出，而不具体说明每个处理程序采取什么行动。
- en: 'In Go, we start to describe our idea of getting an avatar URL by defining an
    interface. Let''s create a new file called `avatar.go` and insert the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们通过定义一个接口来描述获取头像URL的想法。让我们创建一个名为`avatar.go`的新文件，并插入以下代码：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Avatar` interface describes the `GetAvatarURL` method that a type must
    satisfy in order to be able to get avatar URLs. We took the client as an argument
    so that we know the user for which the URL to be returned. The method returns
    two arguments: a string (which will be the URL if things go well) and an error
    in case something goes wrong.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar`接口描述了一个类型必须满足的`GetAvatarURL`方法，以便能够获取头像URL。我们以客户端作为参数，以便我们知道要返回URL的用户。该方法返回两个参数：一个字符串（如果一切顺利，将是URL）和一个错误，如果出现问题。'
- en: One of the things that could go wrong is simply that one of the specific implementations
    of `Avatar` is unable to get the URL. In that case, `GetAvatarURL` will return
    the `ErrNoAvatarURL` error as the second argument. The `ErrNoAvatarURL` error
    therefore becomes a part of the interface; it's one of the possible returns from
    the method and something that users of our code should probably explicitly handle.
    We mention this in the comments part of the code for the method, which is the
    only way to communicate such design decisions in Go.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出错的事情之一是 `Avatar` 的某个特定实现无法获取 URL。在这种情况下，`GetAvatarURL` 将返回 `ErrNoAvatarURL`
    错误作为第二个参数。因此，`ErrNoAvatarURL` 错误成为接口的一部分；它是方法可能的返回值之一，也是我们代码的用户可能需要明确处理的内容。我们在方法的注释部分提到了这一点，这是在
    Go 中传达此类设计决策的唯一方式。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because the error is initialized immediately using `errors.New` and stored in
    the `ErrNoAvatarURL` variable, only one of these objects will ever be created;
    passing the pointer of the error as a return is inexpensive. This is unlike Java's
    checked exceptions which serve a similar purpose where expensive exception objects
    are created and used as part of the control flow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误是立即使用 `errors.New` 初始化并存储在 `ErrNoAvatarURL` 变量中，因此只会创建这些对象中的一个；传递错误指针作为返回值是低成本的。这与
    Java 的检查异常类似，后者具有类似的目的，其中创建了昂贵的异常对象，并将其用作控制流的一部分。
- en: The auth service and the avatar's implementation
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证服务和头像的实现
- en: 'The first implementation of `Avatar` we write will replace the existing functionality
    where we had hardcoded the avatar URL obtained from the auth service. Let''s use
    a **Test-driven Development** (**TDD**) approach so that we can be sure our code
    works without having to manually test it. Let''s create a new file called `avatar_test.go`
    in the `chat` folder:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的 `Avatar` 的第一个实现将替换我们之前硬编码从身份验证服务获取的头像 URL 的现有功能。让我们采用 **测试驱动开发** （**TDD**）
    方法，以确保我们的代码在没有手动测试的情况下也能正常工作。让我们在 `chat` 文件夹中创建一个名为 `avatar_test.go` 的新文件：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This file contains a test for our as-of-yet, nonexistent `AuthAvatar` type's
    `GetAvatarURL` method. First, it uses a client with no user data and ensures that
    the `ErrNoAvatarURL` error is returned. After setting a suitable URL, our test
    calls the method again this time to assert that it returns the correct value.
    However, building this code fails because the `AuthAvatar` type doesn't exist,
    so we'll declare `authAvatar` next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含对我们目前尚不存在且未定义的 `AuthAvatar` 类型的 `GetAvatarURL` 方法的测试。首先，它使用一个没有用户数据的客户端，并确保返回
    `ErrNoAvatarURL` 错误。在设置一个合适的 URL 之后，我们的测试再次调用该方法，这次断言它返回正确的值。然而，构建此代码失败，因为 `AuthAvatar`
    类型不存在，所以我们将声明 `authAvatar`。
- en: Before we write our implementation, it's worth noticing that we only declare
    the `authAvatar` variable as the `AuthAvatar` type but never actually assign anything
    to it so its value remains `nil`. This is not a mistake; we are actually making
    use of Go's zero-initialization (or default initialization) capabilities. Since
    there is no state needed for our object (we will pass `client` in as an argument),
    there is no need to waste time and memory on initializing an instance of it. In
    Go, it is acceptable to call a method on a `nil` object, provided that the method
    doesn't try to access a field. When we actually come to writing our implementation,
    we will look at a way in which we can ensure this is the case.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写实现之前，值得注意的是，我们只声明了 `authAvatar` 变量为 `AuthAvatar` 类型，但从未实际分配任何内容，因此其值保持为 `nil`。这并不是一个错误；我们实际上正在利用
    Go 的零初始化（或默认初始化）功能。由于我们的对象不需要状态（我们将 `client` 作为参数传递），因此没有必要浪费时间和内存来初始化其实例。在 Go
    中，在 `nil` 对象上调用方法是可以接受的，只要该方法不尝试访问字段。当我们实际编写实现时，我们将查看一种确保这种情况的方法。
- en: 'Let''s head back over to `avatar.go` and make our test pass. Add the following
    code at the bottom of the file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `avatar.go` 并使测试通过。在文件底部添加以下代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we define our `AuthAvatar` type as an empty struct and define the implementation
    of the `GetAvatarURL` method. We also create a handy variable called `UseAuthAvatar`
    that has the `AuthAvatar` type but which remains of `nil` value. We can later
    assign the `UseAuthAvatar` variable to any field looking for an `Avatar` interface
    type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义我们的 `AuthAvatar` 类型为一个空的结构体，并定义了 `GetAvatarURL` 方法的实现。我们还创建了一个方便的变量
    `UseAuthAvatar`，它具有 `AuthAvatar` 类型，但其值为 `nil`。我们可以在以后将 `UseAuthAvatar` 变量分配给任何查找
    `Avatar` 接口类型的字段。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GetAvatarURL` method we wrote earlier doesn't have a very nice **line of
    sight**; the happy return is buried within two `if` blocks. See if you can refactor
    it so that the last line is `return urlStr, nil` and the method exits early if
    the `avatar_url` field is missing. You can refactor with confidence, since this
    code is covered by a unit test.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的 `GetAvatarURL` 方法没有很好的 **视线**；快乐的返回值被埋在两个 `if` 块中。看看你是否可以重构它，使得最后一行是
    `return urlStr, nil`，如果 `avatar_url` 字段缺失，则方法提前退出。你可以有信心地重构，因为这段代码被单元测试覆盖。
- en: For a little more on the rationale behind this kind of refactor, refer to the
    article at [http://bit.ly/lineofsightgolang](http://bit.ly/lineofsightgolang).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于这种重构背后的原因，请参阅[http://bit.ly/lineofsightgolang](http://bit.ly/lineofsightgolang)上的文章。
- en: Normally, the receiver of a method (the type defined in parentheses before the
    name) will be assigned to a variable so that it can be accessed in the body of
    the method. Since, in our case, we assume the object can have `nil` value, we
    can omit a variable name to tell Go to throw away the reference. This serves as
    an added reminder to ourselves that we should avoid using it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，方法的接收者（在名称之前括号中定义的类型）将被分配给一个变量，以便可以在方法体中访问它。由于在我们的情况下，我们假设对象可以有 `nil` 值，我们可以省略变量名来告诉
    Go 丢弃引用。这作为对我们自己的额外提醒，我们应该避免使用它。
- en: 'The body of our implementation is relatively simple otherwise: we are safely
    looking for the value of `avatar_url` and ensuring that it is a string before
    returning it. If anything fails, we return the `ErrNoAvatarURL` error, as defined
    in the interface.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现体在其他方面相对简单：我们安全地寻找 `avatar_url` 的值，并在返回之前确保它是一个字符串。如果任何东西失败，我们返回接口中定义的
    `ErrNoAvatarURL` 错误。
- en: 'Let''s run the tests by opening a terminal and then navigating to the `chat`
    folder and typing the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打开终端并导航到 `chat` 文件夹，然后输入以下内容来运行测试：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If all is well, our tests will pass and we will have successfully created our
    first `Avatar` implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们的测试将通过，我们将成功创建了我们的第一个 `Avatar` 实现。
- en: Using an implementation
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用实现
- en: When we use an implementation, we could refer to either the helper variables
    directly or create our own instance of the interface whenever we need the functionality.
    However, this would defeat the object of the abstraction. Instead, we use the
    `Avatar` interface type to indicate where we need the capability.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用实现时，我们可以直接引用辅助变量，或者在我们需要功能时创建接口的自己的实例。然而，这将违背抽象的目的。相反，我们使用 `Avatar` 接口类型来指示我们需要的能力。
- en: 'For our chat application, we will have a single way to obtain an avatar URL
    per chat room. So, let''s update the `room` type so it can hold an `Avatar` object.
    In `room.go`, add the following field definition to the `room struct` type:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的聊天应用程序，我们将为每个聊天室提供一个获取头像 URL 的唯一方式。因此，让我们更新 `room` 类型，使其可以持有 `Avatar` 对象。在
    `room.go` 中，向 `room struct` 类型添加以下字段定义：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update the `newRoom` function so that we can pass in an `Avatar` implementation
    for use; we will just assign this implementation to the new field when we create
    our `room` instance:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `newRoom` 函数，以便我们可以传递一个 `Avatar` 实现用于使用；当我们创建 `room` 实例时，我们将只把这个实现分配给新的字段：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Building the project now will highlight the fact that the call to `newRoom`
    in `main.go` is broken because we have not provided an `Avatar` argument; let''s
    update it by passing in our handy `UseAuthAvatar` variable, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建项目将突出显示在 `main.go` 中的 `newRoom` 调用是错误的，因为我们没有提供 `Avatar` 参数；让我们通过传递我们手头的
    `UseAuthAvatar` 变量来更新它，如下所示：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We didn't have to create an instance of `AuthAvatar`, so no memory was allocated.
    In our case, this doesn't result in great saving (since we only have one room
    for our entire application), but imagine the size of the potential savings if
    our application has thousands of rooms. The way we named the `UseAuthAvatar` variable
    means that the preceding code is very easy to read and it also makes our intention
    obvious.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要创建 `AuthAvatar` 的实例，所以没有分配内存。在我们的情况下，这并不导致很大的节省（因为我们整个应用程序只有一个房间），但想象一下如果我们的应用程序有成千上万的房间，潜在节省的大小。我们命名
    `UseAuthAvatar` 变量的方式意味着前面的代码非常易于阅读，它也使我们的意图明显。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Thinking about code readability is important when designing interfaces. Consider
    a method that takes a Boolean input just passing in true or false hides the real
    meaning if you don''t know the argument names. Consider defining a couple of helper
    constants, as shown in the following short example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计接口时考虑代码可读性很重要。考虑一个只接受布尔输入的方法，仅传递true或false会隐藏真实含义，如果您不知道参数名称的话。考虑定义几个辅助常量，如下面的简短示例所示：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Think about which of the following calls to `move` are easier to understand:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对`move`的调用哪个更容易理解：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All that is left now is to change `client` to use our new `Avatar` interface.
    In `client.go`, update the `read` method, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是将`client`更改为使用我们新的`Avatar`接口。在`client.go`中更新`read`方法，如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we are asking the `avatar` instance in `room` to get the avatar URL for
    us instead of extracting it from `userData` ourselves.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求`room`中的`avatar`实例为我们获取头像URL，而不是我们自己从`userData`中提取它。
- en: When you build and run the application, you will notice that (although we have
    refactored things a little) the behavior and user experience hasn't changed at
    all. This is because we told our room to use the `AuthAvatar` implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建并运行应用程序时，您会注意到（尽管我们进行了一些重构）行为和用户体验完全没有改变。这是因为我们告诉我们的房间使用`AuthAvatar`实现。
- en: Now let's add another implementation to the room.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为房间添加另一个实现。
- en: The Gravatar implementation
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gravatar实现
- en: 'The Gravatar implementation in `Avatar` will do the same job as the `AuthAvatar`
    implementation, except that it will generate a URL for a profile picture hosted
    on [https://en.gravatar.com/](https://en.gravatar.com/). Let''s start by adding
    a test to our `avatar_test.go` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar`中的Gravatar实现将执行与`AuthAvatar`实现相同的工作，但除了它会为托管在[https://en.gravatar.com/](https://en.gravatar.com/)上的个人资料图片生成一个URL。让我们首先在我们的`avatar_test.go`文件中添加一个测试：'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Gravatar uses a hash of the e-mail address to generate a unique ID for each
    profile picture, so we set up a client and ensure `userData` contains an e-mail
    address. Next, we call the same `GetAvatarURL` method, but this time on an object
    that has the `GravatarAvatar` type. We then assert that a correct URL was returned.
    We already know this is the appropriate URL for the specified e-mail address because
    it is listed as an example in the Gravatar documentation a great strategy to ensure
    our code is doing what it should be doing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Gravatar使用电子邮件地址的哈希值来为每个个人资料图片生成一个唯一的ID，因此我们设置了一个客户端并确保`userData`包含一个电子邮件地址。接下来，我们调用相同的`GetAvatarURL`方法，但这次是在具有`GravatarAvatar`类型的对象上。然后我们断言返回了正确的URL。因为我们知道这是指定电子邮件地址的正确URL，因为它在Gravatar文档中作为示例列出，这是一个确保我们的代码正在执行其应执行的操作的绝佳策略。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that all the source code for this book is available for download from
    the publishers and has also been published on GitHub. You can save time on building
    the preceding core by copying and pasting bits and pieces from [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints).
    Hardcoding things such as the base URL is not usually a good idea; we have hardcoded
    throughout the book to make the code snippets easier to read and more obvious,
    but you are welcome to extract them as you go along if you like.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，本书的所有源代码都可以从出版社下载，并且已在GitHub上发布。您可以通过复制粘贴[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)中的部分内容来节省构建先前核心的时间。通常，硬编码诸如基本URL之类的信息不是一个好主意；我们在整本书中硬编码以使代码片段更容易阅读且更明显，但如果您喜欢，欢迎在过程中提取它们。
- en: 'Running these tests (with `go test`) obviously causes errors because we haven''t
    defined our types yet. Let''s head back to `avatar.go` and add the following code
    while being sure to import the `io` package:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，运行这些测试（使用`go test`）会导致错误，因为我们还没有定义我们的类型。让我们回到`avatar.go`并添加以下代码，同时确保导入`io`包：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We used the same pattern as we did for `AuthAvatar`: we have an empty struct,
    a helpful `UseGravatar` variable, and the `GetAvatarURL` method implementation
    itself. In this method, we follow Gravatar''s guidelines to generate an MD5 hash
    from the e-mail address (after we ensured it was lowercase) and append it to the
    hardcoded base URL using `fmt.Sprintf`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与`AuthAvatar`相同的模式：我们有一个空的struct，一个有用的`UseGravatar`变量，以及`GetAvatarURL`方法实现本身。在这个方法中，我们遵循Gravatar的指南，从电子邮件地址生成MD5哈希（在我们确保它是小写之后），然后使用`fmt.Sprintf`将其附加到硬编码的基本URL上。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding method also suffers from a bad line of sight in code. Can you
    live with it, or would you want to improve the readability somehow?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法在代码中存在视线不佳的问题。你能忍受它，还是想以某种方式提高可读性？
- en: It is very easy to achieve hashing in Go thanks to the hard work put in by the
    writers of the Go standard library. The `crypto` package has an impressive array
    of cryptography and hashing capabilities all very easy to use. In our case, we
    create a new `md5` hasher and because the hasher implements the `io.Writer` interface,
    we can use `io.WriteString` to write a string of bytes to it. Calling `Sum` returns
    the current hash for the bytes written.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 标准库编写者的辛勤工作，在 Go 中实现哈希非常容易。`crypto` 包提供了一系列令人印象深刻的加密和哈希功能，使用起来非常简单。在我们的例子中，我们创建了一个新的
    `md5` 哈希器，因为哈希器实现了 `io.Writer` 接口，我们可以使用 `io.WriteString` 将字节字符串写入其中。调用 `Sum`
    返回已写入的字节当前哈希值。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might have noticed that we end up hashing the e-mail address every time
    we need the avatar URL. This is pretty inefficient, especially at scale, but we
    should prioritize getting stuff done over optimization. If we need to, we can
    always come back later and change the way this works.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每次我们需要头像 URL 时，我们都会对电子邮件地址进行哈希处理。这在规模较大时效率很低，但我们应该优先考虑完成工作而不是优化。如果需要，我们总是可以稍后回来并更改这种方式。
- en: 'Running the tests now shows us that our code is working, but we haven''t yet
    included an e-mail address in the `auth` cookie. We do this by locating the code
    where we assign to the `authCookieValue` object in `auth.go` and updating it to
    grab the `Email` value from Gomniauth:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试显示我们的代码正在工作，但我们还没有在 `auth` cookie 中包含电子邮件地址。我们通过定位在 `auth.go` 中分配给 `authCookieValue`
    对象的代码，并将其更新为从 Gomniauth 获取 `Email` 值来完成此操作：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The final thing we must do is tell our room to use the Gravatar implementation
    instead of the `AuthAvatar` implementation. We do this by calling `newRoom` in
    `main.go` and making the following change:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的最后一件事是告诉我们的房间使用 Gravatar 实现，而不是 `AuthAvatar` 实现。我们通过在 `main.go` 中调用 `newRoom`
    并进行以下更改来完成此操作：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Build and run the chat program once again and head to the browser. Remember,
    since we have changed the information stored in the cookie, we must sign out and
    sign back in again in order to see our changes take effect.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建并运行聊天程序，然后转到浏览器。记住，由于我们更改了 cookie 中存储的信息，我们必须注销并重新登录才能看到我们的更改生效。
- en: 'Assuming you have a different image for your Gravatar account, you will notice
    that the system is now pulling the image from Gravatar instead of the auth provider.
    Using your browser''s inspector or debug tool will show you that the `src` attribute
    of the `img` tag has indeed changed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个不同的 Gravatar 账户图片，你会注意到系统现在是从 Gravatar 而不是身份验证提供者拉取图片。使用你浏览器的检查器或调试工具将显示
    `img` 标签的 `src` 属性确实已更改：
- en: '![The Gravatar implementation](img/00053.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Gravatar 实现](img/00053.jpeg)'
- en: If you don't have a Gravatar account, you'll most likely see a default placeholder
    image in place of your profile picture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Gravatar 账户，你很可能会看到默认占位符图片代替你的个人资料图片。
- en: Uploading an avatar picture
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传头像图片
- en: In the third and final approach of uploading a picture, we will look at how
    to allow users to upload an image from their local hard drive to use as their
    profile picture when chatting. The file will then be served to the browsers via
    a URL. We will need a way to associate a file with a particular user to ensure
    that we associate the right picture with the corresponding messages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传图片的第三种和最后一种方法中，我们将探讨如何允许用户从他们的本地硬盘上传图片作为聊天时的个人资料图片。然后，文件将通过 URL 供浏览器服务。我们需要一种方法将文件与特定用户关联起来，以确保我们将正确的图片与相应的消息关联起来。
- en: User identification
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户标识
- en: In order to uniquely identify our users, we are going to copy Gravatar's approach
    by hashing their e-mail address and using the resulting string as an identifier.
    We will store the user ID in the cookie along with the rest of the user-specific
    data. This will actually have the added benefit of removing the inefficiency associated
    with continuous hashing from `GravatarAuth`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了唯一标识我们的用户，我们将通过哈希他们的电子邮件地址并使用结果字符串作为标识符来复制 Gravatar 的方法。我们将把用户 ID 与其他用户特定数据一起存储在
    cookie 中。这实际上还有额外的优点，即消除了与 `GravatarAuth` 持续哈希相关的低效性。
- en: 'In `auth.go`, replace the code that creates the `authCookieValue` object with
    the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `auth.go` 中，将创建 `authCookieValue` 对象的代码替换为以下代码：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we have hashed the e-mail address and stored the resulting value in the
    `userid` field at the point at which the user logs in. From now on, we can use
    this value in our Gravatar code instead of hashing the e-mail address for every
    message. To do this, first, we update the test by removing the following line
    from `avatar_test.go`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经对电子邮件地址进行了哈希处理，并在用户登录时将结果值存储在`userid`字段中。从现在开始，我们可以在我们的Gravatar代码中使用这个值，而不是为每条消息都重新哈希电子邮件地址。为此，首先，我们通过从`avatar_test.go`中删除以下行来更新测试：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then replace the preceding line with this line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将前面的行替换为这一行：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We no longer need to set the `email` field since it is not used; instead, we
    just have to set an appropriate value to the new `userid` field. However, if you
    run `go test` in a terminal, you will see this test fail.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要设置`email`字段，因为它没有被使用；相反，我们只需要为新`userid`字段设置一个适当的值。然而，如果你在终端中运行`go test`，你会看到这个测试失败。
- en: 'To make the test pass, in `avatar.go`, update the `GetAvatarURL` method for
    the `GravatarAuth` type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，在`avatar.go`中，更新`GravatarAuth`类型的`GetAvatarURL`方法：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This won't change the behavior, but it allows us to make an unexpected optimization,
    which is a great example of why you shouldn't optimize code too early the inefficiencies
    that you spot early on may not last long enough to warrant the effort required
    to fix them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会改变行为，但它允许我们进行一个意外的优化，这是一个很好的例子，说明为什么你不应该过早地优化代码——你早期发现的低效可能不会持续足够长的时间，以至于值得花费精力去修复它们。
- en: An upload form
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个上传表单
- en: 'If our users are to upload a file as their avatar, they need a way to browse
    their local hard drive and submit the file to the server. We facilitate this by
    adding a new template-driven page. In the `chat/templates` folder, create a file
    called `upload.html`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户要上传文件作为他们的头像，他们需要一种方式来浏览他们的本地硬盘并将文件提交到服务器。我们通过添加一个新的由模板驱动的页面来简化这个过程。在`chat/templates`文件夹中，创建一个名为`upload.html`的文件：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We used Bootstrap again to make our page look nice and also to make it fit in
    with the other pages. However, the key point to note here is the HTML form that
    will provide the user interface required to upload files. The action points to
    `/uploader`, the handler for which we have yet to implement, and the `enctype`
    attribute must be `multipart/form-data` so that the browser can transmit binary
    data over HTTP. Then, there is an `input` element of the type `file`, which will
    contain a reference to the file we want to upload. Also, note that we have included
    the `userid` value from the `UserData` map as a hidden input this will tell us
    which user is uploading a file. It is important that the `name` attributes be
    correct, as this is how we will refer to the data when we implement our handler
    on the server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了Bootstrap来使我们的页面看起来更美观，并且使其与其他页面保持一致。然而，这里需要注意的是那个将提供用户界面以便上传文件的HTML表单。表单的动作指向`/uploader`，而我们还没有实现它的处理程序，并且`enctype`属性必须是`multipart/form-data`，这样浏览器才能通过HTTP传输二进制数据。然后，有一个类型为`file`的`input`元素，它将包含我们想要上传的文件的引用。此外，请注意，我们已经将`UserData`映射中的`userid`值作为一个隐藏的输入包含在内，这将告诉我们哪个用户正在上传文件。确保`name`属性正确是很重要的，因为这是我们将在服务器上实现处理程序时引用数据的方式。
- en: 'Let''s now map the new template to the `/upload` path in `main.go`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在将新的模板映射到`main.go`中的`/upload`路径：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Handling the upload
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理上传
- en: When the user clicks on **Upload** after selecting a file, the browser will
    send the data for the file as well as the user ID to `/uploader`, but right now,
    that data doesn't actually go anywhere. We will implement a new `HandlerFunc`
    interface that is capable of receiving the file, reading the bytes that are streamed
    through the connection, and saving it as a new file on the server. In the `chat`
    folder, let's create a new folder called `avatars` this is where we will save
    the avatar image files.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在选择了文件后点击**上传**按钮，浏览器将发送文件的资料以及用户ID到`/uploader`，但到目前为止，这些数据实际上并没有去任何地方。我们将实现一个新的`HandlerFunc`接口，它能够接收文件，读取通过连接流过的字节，并将其作为新文件保存到服务器上。在`chat`文件夹中，让我们创建一个名为`avatars`的新文件夹，这是我们将会保存头像图片文件的地方。
- en: 'Next, create a new file called `upload.go` and insert the following code make
    sure that you add the appropriate package name and imports (which are `ioutils`,
    `net/http`, `io`, and `path`):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`upload.go`的新文件，并插入以下代码（确保添加适当的包名和导入，即`ioutils`、`net/http`、`io`和`path`）：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, first `uploaderHandler` uses the `FormValue` method in `http.Request`
    to get the user ID that we placed in the hidden input in our HTML form. Then,
    it gets an `io.Reader` type capable of reading the uploaded bytes by calling `req.FormFile`,
    which returns three arguments. The first argument represents the file itself with
    the `multipart.File` interface type, which is also `io.Reader`. The second is
    a `multipart.FileHeader` object that contains the metadata about the file, such
    as the filename. And finally, the third argument is an error that we hope will
    have a `nil` value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先`uploaderHandler`使用`http.Request`中的`FormValue`方法获取我们在HTML表单中隐藏输入中放置的用户ID。然后，它通过调用`req.FormFile`获取一个能够读取上传字节的`io.Reader`类型，该函数返回三个参数。第一个参数代表文件本身，具有`multipart.File`接口类型，它也是`io.Reader`。第二个是一个包含文件元数据的`multipart.FileHeader`对象，例如文件名。最后，第三个参数是一个我们希望其值为`nil`的错误。
- en: What do we mean when we say that the `multipart.File` interface type is also
    `io.Reader`? Well, a quick glance at the documentation at [http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)
    makes it clear that the type is actually just a wrapper interface for a few other
    more general interfaces. This means that a `multipart.File` type can be passed
    to methods that require `io.Reader`, since any object that implements `multipart.File`
    must, therefore, implement `io.Reader`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`multipart.File`接口类型也是`io.Reader`时，我们是什么意思？好吧，快速浏览一下[http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)的文档，可以清楚地看出，该类型实际上只是几个更通用接口的包装器接口。这意味着`multipart.File`类型可以被传递到需要`io.Reader`的方法中，因为任何实现了`multipart.File`的对象都必须实现`io.Reader`。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Embedding standard library interfaces, such as the wrapper, to describe new
    concepts is a great way to make sure your code works in as many contexts as possible.
    Similarly, you should try to write code that uses the simplest interface type
    you can find, ideally from the standard library. For example, if you wrote a method
    that needed you to read the contents of a file, you could ask the user to provide
    an argument of the type `multipart.File`. However, if you ask for `io.Reader`
    instead, your code will become significantly more flexible because any type that
    has the appropriate `Read` method can be passed in, which includes user-defined
    types as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准库接口，如包装器，嵌入以描述新概念，是确保你的代码在尽可能多的上下文中都能正常工作的一种好方法。同样，你应该尽量编写使用你能找到的最简单接口类型的代码，理想情况下是从标准库中。例如，如果你编写了一个需要你读取文件内容的方法，你可以要求用户提供一个类型为`multipart.File`的参数。然而，如果你要求`io.Reader`，你的代码将变得更加灵活，因为任何具有适当`Read`方法的类型都可以传递，这包括用户定义的类型。
- en: The `ioutil.ReadAll` method will just keep reading from the specified `io.Reader`
    interface until all of the bytes have been received, so this is where we actually
    receive the stream of bytes from the client. We then use `path.Join` and `path.Ext`
    to build a new filename using `userid` and copy the extension from the original
    filename that we can get from `multipart.FileHeader`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioutil.ReadAll`方法将不断从指定的`io.Reader`接口读取，直到接收到所有字节，因此这里是我们实际上从客户端接收字节流的地方。然后我们使用`path.Join`和`path.Ext`通过`userid`构建一个新的文件名，并从可以从中获取的原始文件名中复制扩展名`multipart.FileHeader`。'
- en: We then use the `ioutil.WriteFile` method to create a new file in the `avatars`
    folder. We use `userid` in the filename to associate the image with the correct
    user, much in the same way as Gravatar does. The `0777` value specifies that the
    new file we create should have complete file permissions, which is a good default
    setting if you're not sure what other permissions should be set.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`ioutil.WriteFile`方法在`avatars`文件夹中创建一个新文件。我们使用`userid`作为文件名，以便将图像与正确的用户关联起来，这与Gravatar的做法非常相似。`0777`值指定了我们创建的新文件应具有完整的文件权限，如果你不确定应该设置哪些其他权限，这是一个很好的默认设置。
- en: If an error occurs at any stage, our code will write it out to the response
    along with a 500 status code (since we specify `http.StatusInternalServerError`),
    which will help us debug it, or it will write **Successful** if everything went
    well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何阶段发生错误，我们的代码将将其写入响应中，并附带500状态码（因为我们指定了`http.StatusInternalServerError`），这将帮助我们调试它，或者如果一切顺利，它将写入**成功**。
- en: 'In order to map this new handler function to `/uploader`, we need to head back
    to `main.go` and add the following line to `func main`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个新的处理函数映射到`/uploader`，我们需要回到`main.go`，并在`func main`中添加以下行：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now build and run the application and remember to log out and log back in again
    in order to give our code a chance to upload the `auth` cookie:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序，并记得注销并重新登录，以便给我们的代码一个上传`auth`cookie的机会：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Open `http://localhost:8080/upload` and click on **Choose File**, and then select
    a file from your hard drive and click on **Upload**. Navigate to your `chat/avatars`
    folder and you will notice that the file was indeed uploaded and renamed to the
    value of your `userid` field.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8080/upload`，点击**选择文件**，然后从你的硬盘上选择一个文件并点击**上传**。导航到你的`chat/avatars`文件夹，你会注意到文件确实已上传，并重命名为你的`userid`字段的值。
- en: Serving the images
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端图像服务
- en: 'Now that we have a place to keep our user''s avatar images on the server, we
    need a way to make them accessible to the browser. We do this using the `net/http`
    package''s built-in file server. In `main.go`, add the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了在服务器上存储用户头像图片的地方，我们需要一种方法让浏览器能够访问它们。我们使用`net/http`包的内置文件服务器来完成这项工作。在`main.go`中添加以下代码：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is actually a single line of code that has been broken up to improve readability.
    The `http.Handle` call should feel familiar, as we are specifying that we want
    to map the `/avatars/` path with the specified handler this is where things get
    interesting. Both `http.StripPrefix` and `http.FileServer` return `http.Handler`,
    and they make use of the wrapping pattern we learned about in the previous chapter.
    The `StripPrefix` function takes `http.Handler` in, modifies the path by removing
    the specified prefix, and passes the functionality onto an inner handler. In our
    case, the inner handler is an `http.FileServer` handler that will simply serve
    static files, provide index listings, and generate the `404 Not Found` error if
    it cannot find the file. The `http.Dir` function allows us to specify which folder
    we want to expose publicly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一行代码，为了提高可读性而被拆分。`http.Handle`调用应该感觉熟悉，因为我们指定了想要将`/avatars/`路径映射到指定的处理器，这就是事情变得有趣的地方。`http.StripPrefix`和`http.FileServer`都返回`http.Handler`，并且它们使用了我们在上一章中学到的包装模式。`StripPrefix`函数接收`http.Handler`作为输入，通过删除指定的前缀来修改路径，并将功能传递给内部处理器。在我们的例子中，内部处理器是一个`http.FileServer`处理器，它将简单地提供静态文件，提供索引列表，如果找不到文件，则生成`404
    Not Found`错误。`http.Dir`函数允许我们指定我们想要公开哪个文件夹。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we didn't strip the `/avatars/` prefix from the requests with `http.StripPrefix`,
    the file server would look for another folder called `avatars` inside the actual
    `avatars` folder, that is, `/avatars/avatars/filename` instead of `/avatars/filename`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用`http.StripPrefix`从请求中去除`/avatars/`前缀，文件服务器将在实际的`avatars`文件夹内寻找另一个名为`avatars`的文件夹，即`/avatars/avatars/filename`而不是`/avatars/filename`。
- en: Let's build the program and run it before opening `http://localhost:8080/avatars/`
    in a browser. You'll notice that the file server has generated a listing of the
    files inside our `avatars` folder. Clicking on a file will either download the
    file, or in the case of an image, simply display it. If you haven't done this
    already, go to `http://localhost:8080/upload` and upload a picture, and then head
    back to the listing page and click on it to see it in the browser.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开浏览器中的`http://localhost:8080/avatars/`之前，让我们构建并运行程序。你会注意到文件服务器已经生成了我们`avatars`文件夹内文件的列表。点击一个文件将下载该文件，或者在图像的情况下，简单地显示它。如果你还没有这样做，请转到`http://localhost:8080/upload`并上传一张图片，然后回到列表页面并点击它，在浏览器中查看。
- en: The Avatar implementation for local files
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地文件的头像实现
- en: The final step in making filesystem avatars work is writing an implementation
    of our `Avatar` interface that generates URLs that point to the filesystem endpoint
    we created in the previous section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使文件系统头像工作最终一步是编写一个实现我们的`Avatar`接口的代码，该接口生成指向我们在上一节中创建的文件系统端点的URL。
- en: 'Let''s add a test function to our `avatar_test.go` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`avatar_test.go`文件中添加一个测试函数：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This test is similar to, but slightly more involved than, the `GravatarAvatar`
    test because we are also creating a test file in our `avatars` folder and deleting
    it afterwards.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与`GravatarAvatar`测试类似，但稍微复杂一些，因为我们还在我们的`avatars`文件夹中创建了一个测试文件，并在之后删除它。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even if our test code panics, the deferred functions will still be called. So
    regardless of what happens, our test code will clean up after itself.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的测试代码崩溃，延迟调用的函数仍然会被调用。所以无论发生什么，我们的测试代码都会自行清理。
- en: 'The rest of the test is simple: we set a `userid` field in `client.userData`
    and call `GetAvatarURL` to ensure we get the right value back. Of course, running
    this test will fail, so let''s go and add the following code in order to make
    it pass in `avatar.go`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的测试很简单：我们在`client.userData`中设置一个`userid`字段，并调用`GetAvatarURL`以确保我们得到正确的返回值。当然，运行这个测试将会失败，所以让我们去`avatar.go`中添加以下代码以便使其通过：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see here, in order to generate the correct URL, we simply get the
    `userid` value and build the final string by adding the appropriate segments together.
    You may have noticed that we have hardcoded the file extension to `.jpg`, which
    means that the initial version of our chat application will only support JPEGs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了生成正确的URL，我们只是获取`userid`值，并通过添加适当的段来构建最终的字符串。您可能已经注意到我们硬编码了文件扩展名为`.jpg`，这意味着我们聊天应用程序的初始版本将只支持JPEGs。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Supporting only JPEGs might seem like a half-baked solution, but following Agile
    methodologies, this is perfectly fine; after all, custom JPEG profile pictures
    are better than no custom profile pictures at all.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 仅支持JPEGs可能看起来像是一个半成品解决方案，但遵循敏捷方法，这完全没问题；毕竟，定制的JPEG个人资料图片比完全没有定制的个人资料图片要好。
- en: 'Let''s look at our new code in action by updating `main.go` to use our new
    `Avatar` implementation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新`main.go`以使用我们的新`Avatar`实现来查看我们的新代码的实际效果：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now build and run the application as usual and go to `http://localhost:8080/upload`
    and use a web form to upload a JPEG image to use as your profile picture. To make
    sure it's working correctly, choose a unique image that isn't your Gravatar picture
    or the image from the auth service. Once you see the successful message after
    clicking on **Upload**, go to `http://localhost:8080/chat` and post a message.
    You will notice that the application has indeed used the profile picture that
    you uploaded.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像往常一样构建并运行应用程序，然后转到`http://localhost:8080/upload`并使用网页表单上传一个JPEG图像作为您的个人资料图片。为了确保它正常工作，请选择一个独特的图像，而不是您的Gravatar图片或认证服务中的图片。一旦点击**上传**后看到成功消息，转到`http://localhost:8080/chat`并发布一条消息。您会注意到应用程序确实使用了您上传的个人资料图片。
- en: To change your profile picture, go back to the `/upload` page and upload a different
    picture, and then jump back to the `/chat` page and post more messages.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改您的个人资料图片，请返回到`/upload`页面并上传不同的图片，然后跳回`/chat`页面并发布更多消息。
- en: '![The Avatar implementation for local files](img/00054.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![本地文件的头像实现](img/00054.jpeg)'
- en: Supporting different file types
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持不同的文件类型
- en: To support different file types, we have to make our `GetAvatarURL` method for
    the `FileSystemAvatar` type a little smarter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持不同的文件类型，我们必须使`FileSystemAvatar`类型的`GetAvatarURL`方法变得更智能一些。
- en: Instead of just blindly building the string, we will use the very important
    `ioutil.ReadDir` method to get a listing of the files. The listing also includes
    directories so we will use the `IsDir` method to determine whether we should skip
    it or not.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会盲目地构建字符串，而是会使用非常重要的`ioutil.ReadDir`方法来获取文件列表。列表还包括目录，因此我们将使用`IsDir`方法来确定是否应该跳过它。
- en: We will then check whether each file matches the `userid` field (remember that
    we named our files in this way) by a call to `path.Match`. If the filename matches
    the `userid` field, then we have found the file for that user and we return the
    path. If anything goes wrong or if we can't find the file, we return the `ErrNoAvatarURL`
    error as usual.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用`path.Match`来检查每个文件是否与`userid`字段匹配（记住我们这样命名文件）。如果文件名与`userid`字段匹配，那么我们就找到了该用户的文件，并返回该路径。如果发生任何错误或找不到文件，我们将像往常一样返回`ErrNoAvatarURL`错误。
- en: 'Update the appropriate method in `avatar.go` with the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`avatar.go`中更新适当的方法，如下所示：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Delete all the files in the `avatar` folder to prevent confusion and rebuild
    the program. This time, upload an image of a different type and note that our
    application has no difficulty handling it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`avatar`文件夹中的所有文件以避免混淆并重新构建程序。这次，上传一个不同类型的图片，并注意我们的应用程序没有困难地处理它。
- en: Refactoring and optimizing our code
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重构和优化
- en: When we look back at how our `Avatar` type is used, you will notice that every
    time someone sends a message, the application makes a call to `GetAvatarURL`.
    In our latest implementation, each time the method is called, we iterate over
    all the files in the `avatars` folder. For a particularly chatty user, this could
    mean that we end up iterating over and over again many times a minute. This is
    an obvious waste of resources and would, at some point very soon, become a scaling
    problem.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾我们的 `Avatar` 类型是如何被使用的时候，你会注意到，每次有人发送消息时，应用程序都会调用 `GetAvatarURL`。在我们的最新实现中，每次调用该方法时，我们都会遍历
    `avatars` 文件夹中的所有文件。对于一个特别健谈的用户来说，这可能意味着我们每分钟会重复多次迭代。这是明显的资源浪费，并且很快就会成为一个可扩展性问题。
- en: Instead of getting the avatar URL for every message, we should get it only once
    when the user first logs in and cache it in the `auth` cookie. Unfortunately,
    our `Avatar` interface type requires that we pass in a `client` object to the
    `GetAvatarURL` method and we do not have such an object at the point at which
    we are authenticating the user.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该为每条消息获取头像 URL，而应该在用户首次登录时只获取一次，并将其缓存到 `auth` cookie 中。不幸的是，我们的 `Avatar`
    接口类型要求我们将 `client` 对象传递给 `GetAvatarURL` 方法，而在我们验证用户身份的点上我们没有这样的对象。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: So did we make a mistake when we designed our `Avatar` interface? While this
    is a natural conclusion to come to, in fact we did the right thing. We designed
    the solution with the best information we had available at the time and therefore
    had a working chat application much sooner than if we'd tried to design for every
    possible future case. Software evolves and almost always changes during the development
    process and will definitely change throughout the lifetime of the code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们在设计 `Avatar` 接口时犯了错误吗？虽然这是一个自然的结论，但事实上我们做得是对的。我们根据当时可用的最佳信息设计了解决方案，因此比尝试为所有可能的情况设计要早得多地拥有了一个工作的聊天应用程序。软件会进化，几乎总是会在开发过程中发生变化，并且在代码的整个生命周期中肯定会发生变化。
- en: Replacing concrete types with interfaces
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用接口替换具体类型
- en: We have concluded that our `GetAvatarURL` method depends on a type that is not
    available to us at the point we need it, so what would be a good alternative?
    We could pass each required field as a separate argument, but this would make
    our interface brittle, since as soon as an `Avatar` implementation needs a new
    piece of information, we'd have to change the method signature. Instead, we will
    create a new type that will encapsulate the information our `Avatar` implementations
    need while conceptually remaining decoupled from our specific case.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得出结论，我们的 `GetAvatarURL` 方法依赖于在我们需要它的点上不可用的类型，那么一个好的替代方案是什么？我们可以将每个必需字段作为单独的参数传递，但这会使我们的接口变得脆弱，因为一旦
    `Avatar` 实现需要新的信息，我们就必须更改方法签名。相反，我们将创建一个新的类型，它将封装 `Avatar` 实现所需的信息，同时在概念上保持与我们特定情况的解耦。
- en: 'In `auth.go`, add the following code to the top of the page (underneath the
    `package` keyword, of course):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `auth.go` 文件中，将以下代码添加到页面顶部（当然是在 `package` 关键字下方）：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You may have noticed that we only actually implemented one of the two required
    methods to satisfy our `ChatUser` interface. We got away with this because the
    Gomniauth `User` interface happens to define the same `AvatarURL` method. In practice,
    when we instantiate our `chatUser` struct provided we set an appropriate value
    for the implied Gomniauth `User` field our object implements both Gomniauth's
    `User` interface and our own `ChatUser` interface at the same time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们实际上只实现了两个必需方法中的一个来满足我们的 `ChatUser` 接口。我们之所以能够这样做，是因为 Gomniauth 的
    `User` 接口恰好定义了相同的 `AvatarURL` 方法。在实践中，当我们实例化我们的 `chatUser` 结构体，并且为隐含的 Gomniauth
    `User` 字段设置适当的值时，我们的对象同时实现了 Gomniauth 的 `User` 接口和我们的 `ChatUser` 接口。
- en: Changing interfaces in a test-driven way
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以测试驱动的方式更改接口
- en: Before we can use our new type, we must update the `Avatar` interface and appropriate
    implementations to make use of it. As we will follow TDD practices, we are going
    to first make these changes in our test file, see the compiler errors when we
    try to build our code, and see failing tests once we fix those errors before finally
    making the tests pass.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用我们的新类型之前，我们必须更新 `Avatar` 接口和适当的实现以使用它。由于我们将遵循 TDD 实践，我们将首先在我们的测试文件中做出这些更改，当我们尝试构建代码时，我们会看到编译错误，一旦我们修复了这些错误，我们就会看到失败的测试，最终使测试通过。
- en: 'Open `avatar_test.go` and replace `TestAuthAvatar` with the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `avatar_test.go` 文件，将 `TestAuthAvatar` 替换为以下代码：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will also need to import the `gomniauth/test` package as `gomniauthtest`,
    like we did in the last section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要导入`gomniauth/test`包，并将其命名为`gomniauthtest`，就像我们在上一节中所做的那样。
- en: Using our new interface before we have defined it is a good way to check the
    sanity of our thinking, which is another advantage of practicing TDD. In this
    new test, we create `TestUser` provided by Gomniauth and embed it into a `chatUser`
    type. We then pass the new `chatUser` type into our `GetAvatarURL` calls and make
    the same assertions about output as we always have done.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义之前使用我们的新接口是一个检查我们思考是否合理的有效方法，这也是练习TDD的另一个优点。在这个新的测试中，我们创建Gomniauth提供的`TestUser`，并将其嵌入到`chatUser`类型中。然后我们将新的`chatUser`类型传递给我们的`GetAvatarURL`调用，并对输出做出与以往相同的断言。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Gomniauth's `TestUser` type is interesting as it makes use of the `Testify`
    package's mocking capabilities. Refer to [https://github.com/stretchr/testify](https://github.com/stretchr/testify)
    for more information.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Gomniauth的`TestUser`类型很有趣，因为它使用了`Testify`包的模拟功能。有关更多信息，请参阅[https://github.com/stretchr/testify](https://github.com/stretchr/testify)。
- en: The `On` and `Return` methods allow us to tell `TestUser` what to do when specific
    methods are called. In the first case, we tell the `AvatarURL` method to return
    the error, and in the second case, we ask it to return the `testUrl` value, which
    simulates the two possible outcomes we are covering in this test.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`On`和`Return`方法允许我们告诉`TestUser`在调用特定方法时应该做什么。在第一种情况下，我们告诉`AvatarURL`方法返回错误，在第二种情况下，我们要求它返回`testUrl`值，这模拟了我们在测试中覆盖的两个可能的结果。'
- en: Updating the other two tests is much simpler because they rely only on the `UniqueID`
    method, the value of which we can control directly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更新其他两个测试要简单得多，因为它们只依赖于`UniqueID`方法，我们可以直接控制其值。
- en: 'Replace the other two tests in `avatar_test.go` with the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将`avatar_test.go`中的其他两个测试替换为以下代码：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Of course, this test code won''t even compile because we are yet to update
    our `Avatar` interface. In `avatar.go`, update the `GetAvatarURL` signature in
    the `Avatar` interface type to take a `ChatUser` type rather than a `client` type:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段测试代码甚至无法编译，因为我们还没有更新我们的`Avatar`接口。在`avatar.go`中，将`Avatar`接口类型中的`GetAvatarURL`签名更新为接受`ChatUser`类型而不是`client`类型：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that we are using the `ChatUser` interface (with the starting letter in
    uppercase) rather than our internal `chatUser` implementation struct after all,
    we want to be flexible about the types our `GetAvatarURL` methods accept.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们最终使用的是`ChatUser`接口（首字母大写），而不是我们内部的`chatUser`实现结构体。毕竟，我们希望我们的`GetAvatarURL`方法接受的类型更加灵活。
- en: Trying to build this will reveal that we now have broken implementations because
    all the `GetAvatarURL` methods are still asking for a `client` object.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试构建这个项目将揭示我们现在有破损的实现，因为所有的`GetAvatarURL`方法仍在请求一个`client`对象。
- en: Fixing the existing implementations
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复现有实现
- en: Changing an interface like the one we have is a good way to automatically find
    the parts of our code that have been affected because they will cause compiler
    errors. Of course, if we were writing a package that other people would use, we
    would have to be far stricter about changing the interfaces like this, but we
    haven't released our v1 yet, so it's fine.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 改变像我们这样的接口是一个自动找到我们代码中受影响部分的好方法，因为它们将导致编译错误。当然，如果我们正在编写其他人会使用的包，我们就必须对这种接口的改变更加严格，但我们还没有发布我们的v1版本，所以这没关系。
- en: 'We are now going to update the three implementation signatures to satisfy the
    new interface and change the method bodies to make use of the new type. Replace
    the implementation for `FileSystemAvatar` with the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新三个实现签名以满足新的接口，并将方法体更改为使用新类型。将`FileSystemAvatar`的实现替换为以下内容：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The key change here is that we no longer access the `userData` field on the
    client, and just call `UniqueID` directly on the `ChatUser` interface instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的改变是我们不再访问客户端的`userData`字段，而是直接在`ChatUser`接口上调用`UniqueID`。
- en: 'Next, we update the `AuthAvatar` implementation with the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下代码更新`AuthAvatar`实现：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our new design proves to be much simpler, it's always a good thing if we can
    reduce the amount of code required. The preceding code makes a call to get the
    `AvatarURL` value, and provided it isn't empty, we return it; otherwise, we return
    the `ErrNoAvatarURL` error.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新设计证明要简单得多，如果我们能减少所需的代码量，那总是好事。前面的代码调用以获取`AvatarURL`值，如果它不为空，我们就返回它；否则，我们返回`ErrNoAvatarURL`错误。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note how the expected flow of the code is indented to one level, while error
    cases are nested inside `if` blocks. While you can't stick to this practice 100%
    of the time, it's a worthwhile endeavor. Being able to quickly scan the code (when
    reading it) to see the normal flow of execution down a single column allows you
    to understand the code much quicker. Compare this to code that has lots of `if...else`
    nested blocks, which takes a lot more unpicking to understand.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码的预期流程缩进了一级，而错误情况被嵌套在`if`块中。虽然你不可能100%地坚持这种做法，但这是一种值得努力的事情。能够快速扫描代码（在阅读时）以查看单列中的正常执行流程，可以使你更快地理解代码。将此与具有大量嵌套的`if...else`块的代码进行比较，后者需要更多的时间来理解。
- en: 'Finally, update the `GravatarAvatar` implementation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`GravatarAvatar`实现：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Global variables versus fields
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量与字段
- en: 'So far, we have assigned the `Avatar` implementation to the `room` type, which
    enables us to use different avatars for different rooms. However, this has exposed
    an issue: when our users sign in, there is no concept of which room they are headed
    to so we cannot know which `Avatar` implementation to use. Because our application
    only supports a single room, we are going to look at another approach to select
    implementations: the use of global variables.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将`Avatar`实现分配给了`room`类型，这使得我们可以为不同的房间使用不同的头像。然而，这也暴露了一个问题：当我们的用户登录时，没有关于他们要去的房间的概念，因此我们不知道应该使用哪个`Avatar`实现。因为我们的应用程序只支持一个房间，我们将考虑另一种选择实现的方法：使用全局变量。
- en: 'A global variable is simply a variable that is defined outside any type definition
    and is accessible from every part of the package (and from outside the package
    if it''s exported). For a simple configuration, such as which type of `Avatar`
    implementation to use, global variables are an easy and simple solution. Underneath
    the `import` statements in `main.go`, add the following line:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量简单地说是一个定义在任何类型定义之外且可以从包的任何部分（以及如果它被导出，则从包外部）访问的变量。对于简单的配置，例如要使用哪种类型的`Avatar`实现，全局变量是一个简单且直接的解决方案。在`main.go`中的`import`语句下面添加以下行：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This defines `avatars` as a global variable that we can use when we need to
    get the avatar URL for a particular user.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`avatars`为一个全局变量，我们可以在需要获取特定用户的头像URL时使用它。
- en: Implementing our new design
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现我们的新设计
- en: 'We need to change the code that calls `GetAvatarURL` for every message to just
    access the value that we put into the `userData` cache (via the `auth` cookie).
    Change the line where `msg.AvatarURL` is assigned, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改调用`GetAvatarURL`的代码，使其仅访问我们放入`userData`缓存（通过`auth`cookie）中的值。更改`msg.AvatarURL`被分配的行，如下所示：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Find the code inside `loginHandler` in `auth.go` where we call `provider.GetUser`
    and replace it, down to where we set the `authCookieValue` object, with the following
    code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth.go`中的`loginHandler`内部找到调用`provider.GetUser`的代码，并将其替换，直到我们设置`authCookieValue`对象的位置，替换为以下代码：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we created a new `chatUser` variable while setting the `User` field (which
    represents the embedded interface) to the `User` value returned from Gomniauth.
    We then saved the `userid` MD5 hash to the `uniqueID` field.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在设置`User`字段（表示嵌入的接口）为Gomniauth返回的`User`值的同时创建了一个新的`chatUser`变量。然后我们将`userid`的MD5哈希保存到`uniqueID`字段中。
- en: 'The call to `avatars.GetAvatarURL` is where all of our hard work has paid off,
    as we now get the avatar URL for the user far earlier in the process. Update the
    `authCookieValue` line in `auth.go` to cache the avatar URL in the cookie and
    remove the e-mail address since it is no longer required:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`avatars.GetAvatarURL`是我们所有辛勤工作的回报，因为我们现在在处理过程中更早地获得了用户的头像URL。更新`auth.go`中的`authCookieValue`行，以在cookie中缓存头像URL并删除电子邮件地址，因为它不再需要：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However expensive the work the `Avatar` implementation needs to do, such as
    iterating over files on the filesystem, it is mitigated by the fact that the implementation
    only does so when the user first logs in and not every time they send a message.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Avatar`实现需要执行的工作多么昂贵，例如在文件系统上迭代文件，由于实现仅在用户首次登录时执行，而不是每次他们发送消息时执行，因此这种工作得到了缓解。
- en: Tidying up and testing
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整理和测试
- en: Finally, we get to snip away at some of the fat that has accumulated during
    our refactoring process.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在重构过程中积累的一些冗余代码上进行裁剪。
- en: 'Since we no longer store the `Avatar` implementation in `room`, let''s remove
    the field and all references to it from the type. In `room.go`, delete the `avatar
    Avatar` definition from the `room` struct and update the `newRoom` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再在 `room` 中存储 `Avatar` 实现了，让我们从类型中删除该字段及其所有引用。在 `room.go` 中，从 `room` 结构体中删除
    `avatar Avatar` 定义并更新 `newRoom` 方法：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to use the compiler as your to-do list where possible, and follow the
    errors to find where you have impacted other code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 记得尽可能使用编译器作为你的待办事项列表，并跟随错误找到你影响其他代码的地方。
- en: In `main.go`, remove the parameter passed into the `newRoom` function call since
    we are using our global variable instead of this one.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，删除传递给 `newRoom` 函数调用的参数，因为我们正在使用全局变量而不是这个变量。
- en: After this exercise, the end user experience remains unchanged. Usually when
    refactoring the code, it is the internals that are modified while the public-facing
    interface remains stable and unchanged. As you go, remember to re-run the unit
    tests to make sure you don't break anything as you evolve the code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习之后，最终用户体验保持不变。通常在重构代码时，内部结构会被修改，而公共接口保持稳定和不变。在这个过程中，记得重新运行单元测试，以确保你在代码演变过程中没有破坏任何东西。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's usually a good idea to run tools such as `golint` and `go vet` against
    your code as well in order to make sure it follows good practices and doesn't
    contain any Go faux pas, such as missing comments or badly named functions. There
    are a few deliberately left in for you to fix yourself.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，运行像 `golint` 和 `go vet` 这样的工具来检查你的代码是一个好主意，以确保它遵循良好的实践，并且不包含任何 Go 伪错误，例如缺少注释或命名不当的函数。有一些故意留下供你自己修复。
- en: Combining all three implementations
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合所有三个实现
- en: To close this chapter with a bang, we will implement a mechanism in which each
    `Avatar` implementation takes a turn in trying to get a URL for a user. If the
    first implementation returns the `ErrNoAvatarURL` error, we will try the next
    and so on until we find a useable value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以响亮的方式结束这一章节，我们将实现一个机制，其中每个 `Avatar` 实现轮流尝试获取用户的 URL。如果第一个实现返回 `ErrNoAvatarURL`
    错误，我们将尝试下一个，依此类推，直到找到可用的值。
- en: 'In `avatar.go`, underneath the `Avatar` type, add the following type definition:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `avatar.go` 中，在 `Avatar` 类型下方添加以下类型定义：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `TryAvatars` type is simply a slice of `Avatar` objects that we are free
    to add methods to. Let''s add the following `GetAvatarURL` method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryAvatars` 类型只是一个 `Avatar` 对象的切片，我们可以自由地向其中添加方法。让我们添加以下 `GetAvatarURL` 方法：'
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This means that `TryAvatars` is now a valid `Avatar` implementation and can
    be used in place of any specific implementation. In the preceding method, we iterated
    over the slice of `Avatar` objects in an order, calling `GetAvatarURL` for each
    one. If no error is returned, we return the URL; otherwise, we carry on looking.
    Finally, if we are unable to find a value, we just return `ErrNoAvatarURL` as
    per the interface design.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `TryAvatars` 现在是一个有效的 `Avatar` 实现并且可以替代任何特定的实现。在先前的方法中，我们按顺序遍历 `Avatar`
    对象的切片，为每个对象调用 `GetAvatarURL`。如果没有返回错误，我们返回 URL；否则，我们继续寻找。最后，如果我们无法找到值，我们根据接口设计返回
    `ErrNoAvatarURL`。
- en: 'Update the `avatars` global variable in `main.go` to use our new implementation:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.go` 中更新 `avatars` 全局变量以使用我们的新实现：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we created a new instance of our `TryAvatars` slice type while putting
    the other `Avatar` implementations inside it. The order matters since it iterates
    over the objects in the order in which they appear in the slice. So, first our
    code will check whether the user has uploaded a picture; if they haven't, the
    code will check whether the auth service has a picture for us to use. If the approaches
    fail, a Gravatar URL will be generated, which in the worst case (for example,
    if the user hasn't added a Gravatar picture) will render a default placeholder
    image.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的 `TryAvatars` 切片类型实例，同时将其他 `Avatar` 实现放入其中。顺序很重要，因为它按切片中对象出现的顺序迭代。因此，首先我们的代码将检查用户是否上传了图片；如果没有，代码将检查认证服务是否有我们可以使用的图片。如果这些方法失败，将生成一个
    Gravatar URL，在最坏的情况下（例如，如果用户没有添加 Gravatar 图片），将渲染一个默认占位符图像。
- en: 'To see our new functionality in action, perform the following steps:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的新功能如何工作，请执行以下步骤：
- en: 'Build and rerun the application:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并重新运行应用程序：
- en: '[PRE54]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Log out by visiting `http://localhost:8080/logout`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 `http://localhost:8080/logout` 来注销。
- en: Delete all the pictures from the `avatars` folder.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `avatars` 文件夹中删除所有图片。
- en: Log back in by navigating to `http://localhost:8080/chat`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 `http://localhost:8080/chat` 来重新登录。
- en: Send some messages and take note of your profile picture.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一些消息，并注意你的个人资料图片。
- en: Visit `http://localhost:8080/upload` and upload a new profile picture.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:8080/upload` 并上传一个新的个人资料图片。
- en: Log out again and log back in as you did earlier.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次注销并按照之前的方式重新登录。
- en: Send some more messages and note that your profile picture has been updated.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送更多消息，并注意你的个人资料图片已经更新。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added three different implementations of profile pictures
    to our chat application. First, we asked the auth service to provide a URL for
    us to use. We did this using Gomniauth's abstraction of the user resource data,
    which we then included as part of the user interface every time a user would send
    a message. Using Go's zero (or default) initialization, we were able to refer
    to different implementations of our `Avatar` interface without actually creating
    any instances.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在我们的聊天应用中添加了三种不同的个人资料图片实现。首先，我们要求身份验证服务为我们提供一个 URL。我们使用 Gomniauth 对用户资源数据的抽象，并将其作为用户界面的一部分包含在内，每次用户发送消息时都会这样做。利用
    Go 的零（或默认）初始化，我们能够在不实际创建任何实例的情况下引用我们的 `Avatar` 接口的不同实现。
- en: We stored data in a cookie for when the user would log in. Given the fact that
    cookies persist between builds of our code, we added a handy logout feature to
    help us validate our changes, which we also exposed to our users so that they
    could log out too. Other small changes to the code and the inclusion of Bootstrap
    on our chat page dramatically improved the look and feel of our application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据存储在 cookie 中，以便用户登录时使用。鉴于 cookie 在我们代码的构建之间持续存在，我们添加了一个方便的注销功能来帮助我们验证我们的更改，我们还将其暴露给我们的用户，以便他们也可以注销。对代码的一些小改动以及
    Bootstrap 在我们的聊天页面上的应用，极大地改善了我们的应用的外观和感觉。
- en: We used MD5 hashing in Go to implement the [https://en.gravatar.com/](https://en.gravatar.com/)
    API by hashing the e-mail address that the auth service provided. If the e-mail
    address is not known to Gravatar, they will deliver a nice default placeholder
    image for us, which means our user interface will never be broken due to missing
    images.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Go 中使用 MD5 哈希来实现 [https://en.gravatar.com/](https://en.gravatar.com/) API，通过哈希身份验证服务提供的电子邮件地址。如果电子邮件地址在
    Gravatar 中不为人知，他们将为我们提供一个漂亮的默认占位符图片，这意味着我们的用户界面永远不会因为缺少图片而损坏。
- en: We then built and completed an upload form and associated the server functionality
    that saved uploaded pictures in the `avatars` folder. We saw how to expose the
    saved uploaded pictures to users via the standard library's `http.FileServer`
    handler. As this introduced inefficiencies in our design by causing too much filesystem
    access, we refactored our solution with the help of our unit tests. By moving
    the `GetAvatarURL` call to the point at which users log in rather than every time
    a message is sent, we made our code significantly more scalable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建并完成了一个上传表单，并将服务器功能关联到 `avatars` 文件夹中保存上传的图片。我们看到了如何通过标准库的 `http.FileServer`
    处理器将保存的上传图片暴露给用户。由于这引入了设计中的低效，我们通过单元测试的帮助重构了我们的解决方案。通过将 `GetAvatarURL` 调用移动到用户登录的点，而不是每次发送消息时，我们使我们的代码具有更高的可扩展性。
- en: Our special `ErrNoAvatarURL` error type was used as part of our interface design
    in order to allow us to inform the calling code when it was not possible to obtain
    an appropriate URL this became particularly useful when we created our `Avatars`
    slice type. By implementing the `Avatar` interface on a slice of `Avatar` types,
    we were able to create a new implementation that took turns trying to get a valid
    URL from each of the different options available, starting with the filesystem,
    then the auth service, and finally Gravatar. We achieved this with zero impact
    on how the user would interact with the interface. If an implementation returned
    `ErrNoAvatarURL`, we tried the next one.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特殊的 `ErrNoAvatarURL` 错误类型被用作我们界面设计的一部分，以便在无法获取适当的 URL 时通知调用代码。这在我们创建 `Avatars`
    切片类型时变得特别有用。通过在 `Avatar` 类型的一个切片上实现 `Avatar` 接口，我们能够创建一个新的实现，该实现轮流尝试从不同的选项中获取有效的
    URL，首先是文件系统，然后是身份验证服务，最后是 Gravatar。我们通过不对用户与界面交互的方式产生任何影响来实现这一点。如果一个实现返回 `ErrNoAvatarURL`，我们就尝试下一个。
- en: Our chat application is ready to go live, so we can invite our friends and have
    a real conversation. But first, we need to choose a domain name to host it at,
    something we will look at in the next chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用已经准备好上线，因此我们可以邀请我们的朋友进行真正的对话。但首先，我们需要选择一个域名来托管它，这个问题我们将在下一章中探讨。
