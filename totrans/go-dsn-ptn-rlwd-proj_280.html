<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="A JSON API server"><div class="book" id="2D7TI2-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec77" class="calibre1"/>A JSON API server</h1></div></div></div><p class="calibre10">Armed with the information from the last section, it is possible to use the HTTP package to create services over HTTP. Earlier we discussed the perils of creating services using raw TCP directly when we created a server for our global monetary currency service. In this section, we explore how to create an API server for the same service using HTTP as the underlying protocol. The new HTTP-based service has the following design goals:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Use HTTP as the transport protocol</li><li class="listitem">Use JSON for structured communication between client and server</li><li class="listitem">Clients query the server for currency information using JSON-formatted requests</li><li class="listitem">The server respond using JSON-formatted responses</li></ul></div><p class="calibre10">The following shows the code involved in the implementation of the new service. This time, the server will use the <code class="email">curr1</code> package (see <a class="calibre1" href="https://github.com/vladimirvivien/learning-go%20/ch11/curr1">github.com/vladimirvivien/learning-go /ch11/curr1</a>) to load and query ISO 4217 currency data from a local CSV file.</p><p class="calibre10">The code in the curr1 package defines two types, <code class="email">CurrencyRequest</code> and <code class="email">Currency</code>, intended to represent the client request and currency data returned by the server, respectively as listed here:</p><pre class="programlisting">type Currency struct { 
   Code    string `json:"currency_code"` 
   Name    string `json:"currency_name"` 
   Number  string `json:"currency_number"` 
   Country string `json:"currency_country"` 
} 
 
type CurrencyRequest struct { 
   Get   string `json:"get"` 
   Limit int    `json:limit` 
} 
</pre><p class="calibre10">golang.fyi/ch11/curr1/currency.go</p><p class="calibre10">Note that the preceding struct types shown are annotated with tags that describe the JSON properties for each field. This information is used by the JSON encoder to encode the key name of JSON objects (see <a class="calibre1" title="Chapter 10. Data IO in Go" href="part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 10</a>, <span class="strong"><em class="calibre11">Data IO in Go</em></span>, for detail on encoding). The remainder of the code, listed in the following snippet, defines the functions that set up the server and the handler function for incoming requests:</p><pre class="programlisting">import ( 
   "encoding/json" 
   "fmt" 
   "net/http" 
 
   " github.com/vladimirvivien/learning-go/ch11/curr1" 
) 
var currencies = curr1.Load("./data.csv") 
 
func currs(resp http.ResponseWriter, req *http.Request) { 
   var currRequest curr1.CurrencyRequest 
   dec := json.NewDecoder(req.Body) 
   if err := dec.Decode(&amp;currRequest); err != nil { 
         resp.WriteHeader(http.StatusBadRequest) 
         fmt.Println(err) 
         return 
   } 
 
   result := curr1.Find(currencies, currRequest.Get) 
   enc := json.NewEncoder(resp) 
   if err := enc.Encode(&amp;result); err != nil { 
         fmt.Println(err) 
         resp.WriteHeader(http.StatusInternalServerError) 
         return 
   } 
} 
 
func main() { 
   mux := http.NewServeMux() 
   mux.HandleFunc("/currency", get) 
 
   if err := http.ListenAndServe(":4040", mux); err != nil { 
         fmt.Println(err) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch11/jsonserv0.go</p><p class="calibre10">Since we are leveraging HTTP as the transport protocol for the service, you can see the code is now much smaller than the prior implementation which used pure TCP. The <code class="email">currs</code> function implements the handler responsible for incoming requests. It sets up a decoder to decode the incoming JSON-encoded request to a value of the <code class="email">curr1.CurrencyRequest</code> type as highlighted in the following snippet:</p><pre class="programlisting">var currRequest curr1.CurrencyRequest 
dec := json.NewDecoder(req.Body) 
if err := dec.Decode(&amp;currRequest); err != nil { ... } 
</pre><p class="calibre10">Next, the function executes the currency search by calling <code class="email">curr1.Find(currencies, currRequest.Get)</code> which returns the slice <code class="email">[]Currency</code> assigned to the <code class="email">result</code> variable. The code then creates an encoder to encode the <code class="email">result</code> as a JSON payload, highlighted in the following snippet:</p><pre class="programlisting">result := curr1.Find(currencies, currRequest.Get) 
enc := json.NewEncoder(resp) 
if err := enc.Encode(&amp;result); err != nil { ... } 
</pre><p class="calibre10">Lastly, the handler function is mapped to the <code class="email">"/currency"</code> path in the <code class="email">main</code> function with the call to <code class="email">mux.HandleFunc("/currency", currs)</code>. When the server receives a request for that path, it automatically executes the <code class="email">currs</code> function.</p></div></body></html>