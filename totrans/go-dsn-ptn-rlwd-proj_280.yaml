- en: A JSON API server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Armed with the information from the last section, it is possible to use the
    HTTP package to create services over HTTP. Earlier we discussed the perils of
    creating services using raw TCP directly when we created a server for our global
    monetary currency service. In this section, we explore how to create an API server
    for the same service using HTTP as the underlying protocol. The new HTTP-based
    service has the following design goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Use HTTP as the transport protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JSON for structured communication between client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients query the server for currency information using JSON-formatted requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server respond using JSON-formatted responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following shows the code involved in the implementation of the new service.
    This time, the server will use the `curr1` package (see [github.com/vladimirvivien/learning-go
    /ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)) to
    load and query ISO 4217 currency data from a local CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the curr1 package defines two types, `CurrencyRequest` and `Currency`,
    intended to represent the client request and currency data returned by the server,
    respectively as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/curr1/currency.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the preceding struct types shown are annotated with tags that describe
    the JSON properties for each field. This information is used by the JSON encoder
    to encode the key name of JSON objects (see [Chapter 10](part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10. Data IO in Go"), *Data IO in Go*, for detail on encoding). The remainder
    of the code, listed in the following snippet, defines the functions that set up
    the server and the handler function for incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/jsonserv0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are leveraging HTTP as the transport protocol for the service, you
    can see the code is now much smaller than the prior implementation which used
    pure TCP. The `currs` function implements the handler responsible for incoming
    requests. It sets up a decoder to decode the incoming JSON-encoded request to
    a value of the `curr1.CurrencyRequest` type as highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the function executes the currency search by calling `curr1.Find(currencies,
    currRequest.Get)` which returns the slice `[]Currency` assigned to the `result`
    variable. The code then creates an encoder to encode the `result` as a JSON payload,
    highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, the handler function is mapped to the `"/currency"` path in the `main`
    function with the call to `mux.HandleFunc("/currency", currs)`. When the server
    receives a request for that path, it automatically executes the `currs` function.
  prefs: []
  type: TYPE_NORMAL
