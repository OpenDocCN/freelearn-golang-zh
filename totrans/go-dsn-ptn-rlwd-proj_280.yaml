- en: A JSON API server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 JSON API 服务器
- en: 'Armed with the information from the last section, it is possible to use the
    HTTP package to create services over HTTP. Earlier we discussed the perils of
    creating services using raw TCP directly when we created a server for our global
    monetary currency service. In this section, we explore how to create an API server
    for the same service using HTTP as the underlying protocol. The new HTTP-based
    service has the following design goals:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 带着上一节的信息，我们可以使用 HTTP 包在 HTTP 上创建服务。在创建我们的全球货币服务服务器时，我们之前讨论了直接使用原始 TCP 创建服务的风险。在本节中，我们将探讨如何使用
    HTTP 作为底层协议为同一服务创建一个 API 服务器。新的基于 HTTP 的服务有以下设计目标：
- en: Use HTTP as the transport protocol
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 作为传输协议
- en: Use JSON for structured communication between client and server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON 在客户端和服务器之间进行结构化通信
- en: Clients query the server for currency information using JSON-formatted requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端使用 JSON 格式的请求查询服务器以获取货币信息
- en: The server respond using JSON-formatted responses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器使用 JSON 格式的响应进行响应
- en: The following shows the code involved in the implementation of the new service.
    This time, the server will use the `curr1` package (see [github.com/vladimirvivien/learning-go
    /ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)) to
    load and query ISO 4217 currency data from a local CSV file.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了新服务实现的代码。这次，服务器将使用 `curr1` 包（参见 [github.com/vladimirvivien/learning-go
    /ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)）从本地
    CSV 文件加载和查询 ISO 4217 货币数据。
- en: 'The code in the curr1 package defines two types, `CurrencyRequest` and `Currency`,
    intended to represent the client request and currency data returned by the server,
    respectively as listed here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: curr1 包中的代码定义了两种类型，`CurrencyRequest` 和 `Currency`，分别用于表示客户端请求和服务器返回的货币数据，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch11/curr1/currency.go
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/curr1/currency.go
- en: 'Note that the preceding struct types shown are annotated with tags that describe
    the JSON properties for each field. This information is used by the JSON encoder
    to encode the key name of JSON objects (see [Chapter 10](part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10. Data IO in Go"), *Data IO in Go*, for detail on encoding). The remainder
    of the code, listed in the following snippet, defines the functions that set up
    the server and the handler function for incoming requests:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面显示的结构体类型带有标签，这些标签描述了每个字段的 JSON 属性。这些信息被 JSON 编码器用于编码 JSON 对象的键名（参见[第 10
    章](part0068_split_000.html#20R681-9c484ed022e64a0fb0e1aebf8e05d4fd "第 10 章。Go
    中的数据输入输出")，*Go 中的数据输入输出*，有关编码的详细信息）。以下代码片段中列出的代码定义了设置服务器和处理器函数的函数：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch11/jsonserv0.go
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/jsonserv0.go
- en: 'Since we are leveraging HTTP as the transport protocol for the service, you
    can see the code is now much smaller than the prior implementation which used
    pure TCP. The `currs` function implements the handler responsible for incoming
    requests. It sets up a decoder to decode the incoming JSON-encoded request to
    a value of the `curr1.CurrencyRequest` type as highlighted in the following snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用 HTTP 作为服务的传输协议，您可以看到代码现在比之前使用纯 TCP 的实现要小得多。`currs` 函数实现了处理传入请求的处理程序。它设置了一个解码器来解码传入的
    JSON 编码请求到 `curr1.CurrencyRequest` 类型的值，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, the function executes the currency search by calling `curr1.Find(currencies,
    currRequest.Get)` which returns the slice `[]Currency` assigned to the `result`
    variable. The code then creates an encoder to encode the `result` as a JSON payload,
    highlighted in the following snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数通过调用 `curr1.Find(currencies, currRequest.Get)` 执行货币搜索，该调用返回分配给 `result`
    变量的 `[]Currency` 切片。然后，代码创建一个编码器来将 `result` 编码为 JSON 负载，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, the handler function is mapped to the `"/currency"` path in the `main`
    function with the call to `mux.HandleFunc("/currency", currs)`. When the server
    receives a request for that path, it automatically executes the `currs` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `main` 函数中通过调用 `mux.HandleFunc("/currency", currs)` 将处理函数映射到 `"/currency"`
    路径。当服务器接收到对该路径的请求时，它将自动执行 `currs` 函数。
