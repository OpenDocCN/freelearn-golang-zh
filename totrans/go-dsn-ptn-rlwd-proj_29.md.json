["```go\necho -n \"Hello\" | md5\n\n```", "```go\n8b1a9953c4611296a827abf8c47804d7\n\n```", "```go\npackage main \nimport ( \n  \"bufio\" \n  \"fmt\" \n  \"math/rand\" \n  \"os\" \n  \"strings\" \n  \"time\" \n) \nconst otherWord = \"*\" \nvar transforms = []string{  \notherWord, \n  otherWord + \"app\", \n  otherWord + \"site\", \n  otherWord + \"time\", \n  \"get\" + otherWord, \n  \"go\" + otherWord, \n  \"lets \" + otherWord, \n  otherWord + \"hq\", \n} \nfunc main() { \n  rand.Seed(time.Now().UTC().UnixNano()) \n  s := bufio.NewScanner(os.Stdin) \n  for s.Scan() { \n    t := transforms[rand.Intn(len(transforms))] \n    fmt.Println(strings.Replace(t, otherWord, s.Text(), -1)) \n  } \n} \n\n```", "```go\ngo build -o sprinkle\n./sprinkle\n\n```", "```go\nchat\ngo chat\nchat\nlets chat\nchat\nchat app\n\n```", "```go\necho \"chat\" | ./sprinkle\n\n```", "```go\npackage main \nvar tlds = []string{\"com\", \"net\"} \nconst allowedChars = \"abcdefghijklmnopqrstuvwxyz0123456789_-\" \nfunc main() { \n  rand.Seed(time.Now().UTC().UnixNano()) \n  s := bufio.NewScanner(os.Stdin) \n  for s.Scan() { \n    text := strings.ToLower(s.Text()) \n    var newText []rune \n    for _, r := range text { \n      if unicode.IsSpace(r) { \n        r = '-' \n      } \n      if !strings.ContainsRune(allowedChars, r) { \n        continue \n      } \n      newText = append(newText, r) \n    } \n    fmt.Println(string(newText) + \".\" +         \n                tlds[rand.Intn(len(tlds))]) \n  } \n} \n\n```", "```go\ngo build -o domainify\n./domainify\n\n```", "```go\n./sprinkle/sprinkle | ./domainify/domainify\n\n```", "```go\npackage main \nconst ( \n  duplicateVowel bool   = true \n  removeVowel    bool   = false \n)  \nfunc randBool() bool { \n  return rand.Intn(2) == 0 \n} \nfunc main() { \n  rand.Seed(time.Now().UTC().UnixNano()) \n  s := bufio.NewScanner(os.Stdin) \n  for s.Scan() { \n    word := []byte(s.Text()) \n    if randBool() { \n      var vI int = -1 \n      for i, char := range word { \n        switch char { \n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U': \n          if randBool() { \n            vI = i \n          } \n        } \n      } \n      if vI >= 0 { \n        switch randBool() { \n        case duplicateVowel: \n          word = append(word[:vI+1], word[vI:]...) \n        case removeVowel: \n          word = append(word[:vI], word[vI+1:]...) \n        } \n      } \n    } \n    fmt.Println(string(word)) \n  } \n} \n\n```", "```go\nswitch randBool() { \n  case true:\n    word = append(word[:vI+1], word[vI:]...)\n  case false:\n    word = append(word[:vI], word[vI+1:]...) }\n\n```", "```go\ntrue and false don't express any context. On the other hand, using duplicateVowel and removeVowel tells anyone reading the code what we mean by the result of randBool.\n```", "```go\ngo build -o coolify\n./coolify\n\n```", "```go\nblueprnts\nbleprints\nbluepriints\nblueprnts\nblueprints\nbluprints\n\n```", "```go\n./coolify/coolify | ./sprinkle/sprinkle | ./domainify/domainify\n\n```", "```go\n `export BHT_APIKEY=abc123def456ghi789jkl` \n\n```", "```go\n{ \n  \"noun\":{ \n    \"syn\":[ \n      \"passion\", \n      \"beloved\", \n      \"dear\" \n    ] \n  }, \n  \"verb\":{ \n    \"syn\":[ \n      \"love\", \n      \"roll in the hay\", \n      \"make out\" \n    ], \n    \"ant\":[ \n      \"hate\" \n    ] \n  } \n} \n\n```", "```go\npackage thesaurus \nimport ( \n  \"encoding/json\" \n  \"errors\" \n  \"net/http\" \n) \ntype BigHuge struct { \n  APIKey string \n} \ntype synonyms struct { \n  Noun *words `json:\"noun\"` \n  Verb *words `json:\"verb\"` \n} \ntype words struct { \n  Syn []string `json:\"syn\"` \n} \nfunc (b *BigHuge) Synonyms(term string) ([]string, error) { \n  var syns []string \n  response, err := http.Get(\"http://words.bighugelabs.com/api/2/\"  + \n   b.APIKey + \"/\" + term + \"/json\") \n  if err != nil { \n    return syns, errors.New(\"bighuge: Failed when looking for  synonyms    \n     for \"\" + term + \"\"\" + err.Error()) \n  } \n  var data synonyms \n  defer response.Body.Close() \n  if err := json.NewDecoder(response.Body).Decode(&data); err !=  nil { \n    return syns, err \n  } \n  if data.Noun != nil { \n    syns = append(syns, data.Noun.Syn...) \n  } \n  if data.Verb != nil { \n    syns = append(syns, data.Verb.Syn...) \n  } \n  return syns, nil \n} \n\n```", "```go\npackage thesaurus \ntype Thesaurus interface { \n  Synonyms(term string) ([]string, error) \n} \n\n```", "```go\nfunc main() { \n  apiKey := os.Getenv(\"BHT_APIKEY\") \n  thesaurus := &thesaurus.BigHuge{APIKey: apiKey} \n  s := bufio.NewScanner(os.Stdin) \n  for s.Scan() { \n    word := s.Text() \n    syns, err := thesaurus.Synonyms(word) \n    if err != nil { \n      log.Fatalln(\"Failed when looking for synonyms for  \"+word+\", err) \n    } \n    if len(syns) == 0 { \n      log.Fatalln(\"Couldn't find any synonyms for \" + word +  \") \n    } \n    for _, syn := range syns { \n      fmt.Println(syn) \n    } \n  } \n} \n\n```", "```go\ngo build -o synonyms\n./synonyms\nchat\nconfab\nconfabulation\nschmooze\nNew World chat\nOld World chat\nconversation\nthrush\nwood warbler\nchew the fat\nshoot the breeze\nchitchat\nchatter\n\n```", "```go\n./synonyms/synonyms | ./sprinkle/sprinkle | ./coolify/coolify |  ./domainify/domainify\n\n```", "```go\ngetcnfab.com\nconfabulationtim.com\ngetschmoozee.net\nschmosee.com\nneew-world-chatsite.net\noold-world-chatsite.com\nconversatin.net\nnew-world-warblersit.com\ngothrush.net\nlets-wood-wrbler.com\nchw-the-fat.com\n\n```", "```go\nfunc exists(domain string) (bool, error) { \n  const whoisServer string = \"com.whois-servers.net\" \n  conn, err := net.Dial(\"tcp\", whoisServer+\":43\") \n  if err != nil { \n    return false, err \n  } \n  defer conn.Close() \n  conn.Write([]byte(domain + \"rn\")) \n  scanner := bufio.NewScanner(conn) \n  for scanner.Scan() { \n    if strings.Contains(strings.ToLower(scanner.Text()), \"no match\") { \n      return false, nil \n    } \n  } \n  return true, nil \n} \n\n```", "```go\nvar marks = map[bool]string{true: \"✔\", false: \"✖\"}\nfunc main() {\ns := bufio.NewScanner(os.Stdin)\nfor s.Scan() {\ndomain := s.Text()\nfmt.Print(domain, \" \")\nexist, err := exists(domain)\nif err != nil {\nlog.Fatalln(err)\n}\nfmt.Println(marks[!exist])\ntime.Sleep(1 * time.Second)\n}\n} \n\n```", "```go\ngo build -o available\n./available\n\n```", "```go\n./synonyms/synonyms | ./sprinkle/sprinkle | ./coolify/coolify |  ./domainify/domainify | ./available/available\n\n```", "```go\n#!/bin/bash \necho Building domainfinder... \ngo build -o domainfinder \necho Building synonyms... \ncd ../synonyms \ngo build -o ../domainfinder/lib/synonyms \necho Building available... \ncd ../available \ngo build -o ../domainfinder/lib/available \ncd ../build \necho Building sprinkle... \ncd ../sprinkle \ngo build -o ../domainfinder/lib/sprinkle \ncd ../build \necho Building coolify... \ncd ../coolify \ngo build -o ../domainfinder/lib/coolify \ncd ../build \necho Building domainify... \ncd ../domainify \ngo build -o ../domainfinder/lib/domainify \ncd ../build \necho Done.\n```", "```go\npackage main \nvar cmdChain = []*exec.Cmd{ \n  exec.Command(\"lib/synonyms\"), \n  exec.Command(\"lib/sprinkle\"), \n  exec.Command(\"lib/coolify\"), \n  exec.Command(\"lib/domainify\"), \n  exec.Command(\"lib/available\"), \n} \nfunc main() { \n  cmdChain[0].Stdin = os.Stdin \n  cmdChain[len(cmdChain)-1].Stdout = os.Stdout \n  for i := 0; i < len(cmdChain)-1; i++ { \n    thisCmd := cmdChain[i] \n    nextCmd := cmdChain[i+1] \n    stdout, err := thisCmd.StdoutPipe() \n    if err != nil { \n      log.Fatalln(err) \n    } \n    nextCmd.Stdin = stdout \n  } \n  for _, cmd := range cmdChain { \n    if err := cmd.Start(); err != nil { \n      log.Fatalln(err) \n    } else { \n      defer cmd.Process.Kill() \n    } \n  } \n  for _, cmd := range cmdChain { \n    if err := cmd.Wait(); err != nil { \n      log.Fatalln(err) \n    } \n  } \n}\n```"]