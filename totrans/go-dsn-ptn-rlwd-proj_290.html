<html><head></head><body>
<div class="book" title="Writing Go tests">
<div class="book" title="The test functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec196" class="calibre1"/>The test functions</h2></div></div></div><p class="calibre10">The test source code in file <code class="email">vec_test.go</code> defines a series of functions that exercise the behavior of type <code class="email">SimpleVector</code> (see the preceding section) by testing each of its methods independently:</p><pre class="programlisting">import "testing" 
 
func TestVectorAdd(t *testing.T) { 
   v1 := New(8.218, -9.341) 
   v2 := New(-1.129, 2.111) 
   v3 := v1.Add(v2) 
   expect := New( 
       v1[0]+v2[0], 
       v1[1]+v2[1], 
   ) 
 
   if !v3.Eq(expect) { 
       t.Logf("Addition failed, expecting %s, got %s",  
          expect, v3) 
       t.Fail() 
   } 
   t.Log(v1, "+", v2, v3) 
} 
 
func TestVectorSub(t *testing.T) { 
   v1 := New(7.119, 8.215) 
   v2 := New(-8.223, 0.878) 
   v3 := v1.Sub(v2) 
   expect := New( 
       v1[0]-v2[0], 
       v1[1]-v2[1], 
   ) 
   if !v3.Eq(expect) { 
       t.Log("Subtraction failed, expecting %s, got %s",  
           expect, v3) 
           t.Fail() 
   } 
   t.Log(v1, "-", v2, "=", v3) 
} 
 
func TestVectorScale(t *testing.T) { 
   v := New(1.671, -1.012, -0.318) 
   v.Scale(7.41) 
   expect := New( 
       7.41*1.671, 
       7.41*-1.012, 
       7.41*-0.318, 
   ) 
   if !v.Eq(expect) { 
       t.Logf("Scalar mul failed, expecting %s, got %s",  
           expect, v) 
       t.Fail() 
   } 
   t.Log("1.671,-1.012, -0.318 Scale", 7.41, "=", v) 
} 
</pre><p class="calibre10">golang.fyi/ch12/vector/vec_test.go</p><p class="calibre10">As shown in the previous code, all test source code must import the <code class="email">"testing"</code> package. This is because each test function receives an argument of type <code class="email">*testing.T</code> as its parameter. As is discussed further in the chapter, this allows the test function to interact with the Go test runtime.</p><p class="calibre10">It is crucial to realize that each test function should be idempotent, with no reliance on any previously saved or shared states. In the previous source code snippet, each test function is executed as a standalone piece of code. Your test functions should not make any assumption about the order of execution as the Go test runtime makes no such guarantee.</p><p class="calibre10">The source code of a test function usually sets up an expected value, which is pre-determined based on knowledge of the tested code. That value is then compared to the calculated value returned by the code being tested. For instance, when adding two vectors, we can calculate the expected result using the rules of vector additions, as shown in the following snippet:</p><pre class="programlisting">v1 := New(8.218, -9.341) 
v2 := New(-1.129, 2.111) 
v3 := v1.Add(v2) 
expect := New( 
    v1[0]+v2[0], 
    v1[1]+v2[1], 
) 
</pre><p class="calibre10">In the preceding source snippet, the expected value is calculated using two simple vector values, <code class="email">v1</code> and <code class="email">v2</code>, and stored in the variable <code class="email">expect</code>. Variable <code class="email">v3</code>, on the other hand, stores the actual value of the vector, as calculated by the tested code. This allows us to test the actual versus the expected, as shown in the following:</p><pre class="programlisting">if !v3.Eq(expect) { 
    t.Log("Addition failed, expecting %s, got %s", expect, v3) 
    t.Fail() 
} 
</pre><p class="calibre10">In the preceding source snippet, if the tested condition is <code class="email">false</code>, then the test has failed. The code uses <code class="email">t.Fail()</code> to signal the failure of the test function. Signaling failure is discussed in more detail in the Reporting failure section.</p></div></div></body></html>