<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="HTTP testing" id="2H1VQ1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec81" class="calibre1"/>HTTP testing</h1></div></div></div><p class="calibre10">In <a class="calibre1" title="Chapter 11. Writing Networked Services" href="part0078_split_000.html#2ACBS2-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 11</a>, <span class="strong"><em class="calibre11">Writing Networked Services</em></span>, we saw that Go offers first-class APIs to build client and server programs using HTTP. The <code class="email">net/http/httptest</code> sub-package, part of the Go standard library, facilitates the testing automation of both HTTP server and client code, as discussed in this section.</p><p class="calibre10">To explore this space, we will implement a simple API service that exposes the vector operations (covered in earlier sections) as HTTP endpoints. For instance, the following source snippet partially shows the methods that make up the server (for a complete listing, see <a class="calibre1" href="https://github.com/vladimirvivien/learning-go/ch12/service/serv.go">https://github.com/vladimirvivien/learning-go/ch12/service/serv.go</a>):</p><pre class="programlisting">package main 
 
import ( 
   "encoding/json" 
   "fmt" 
   "net/http" 
 
   "github.com/vladimirvivien/learning-go/ch12/vector" 
) 
func add(resp http.ResponseWriter, req *http.Request) { 
   var params []vector.SimpleVector 
   if err := json.NewDecoder(req.Body).Decode(&amp;params);  
       err != nil { 
         resp.WriteHeader(http.StatusBadRequest) 
         fmt.Fprintf(resp, "Unable to parse request: %s\n", err) 
         return 
   } 
   if len(params) != 2 { 
         resp.WriteHeader(http.StatusBadRequest) 
         fmt.Fprintf(resp, "Expected 2 or more vectors") 
         return 
   } 
   result := params[0].Add(params[1]) 
   if err := json.NewEncoder(resp).Encode(&amp;result); err != nil { 
         resp.WriteHeader(http.StatusInternalServerError) 
         fmt.Fprintf(resp, err.Error()) 
         return 
   } 
} 
... 
func main() { 
   mux := http.NewServeMux() 
   mux.HandleFunc("/vec/add", add) 
   mux.HandleFunc("/vec/sub", sub) 
   mux.HandleFunc("/vec/dotprod", dotProd) 
   mux.HandleFunc("/vec/mag", mag) 
   mux.HandleFunc("/vec/unit", unit) 
 
   if err := http.ListenAndServe(":4040", mux); err != nil { 
         fmt.Println(err) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch12/service/serv.go</p><p class="calibre10">Each function (<code class="email">add</code>, <code class="email">sub</code>, <code class="email">dotprod</code>, <code class="email">mag</code>, and <code class="email">unit</code>) implements the <code class="email">http.Handler</code> interface. The functions are used to handle HTTP requests from the client to calculate the respective operations from the <code class="email">vector</code> package. Both requests and responses are formatted using JSON for simplicity.</p></div></body></html>