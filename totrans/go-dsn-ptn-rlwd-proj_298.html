<html><head></head><body>
<div class="book" title="HTTP testing" id="2H1VQ1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Testing HTTP client code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec203" class="calibre1"/>Testing HTTP client code</h2></div></div></div><p class="calibre10">Creating test code for an HTTP client is more involved, since you actually need a server running for proper testing. Luckily, package <code class="email">httptest</code> provides type <code class="email">httptest.Server</code> to programmatically create servers to test client requests and send back mock responses to the client.</p><p class="calibre10">To illustrate, let us consider the following code, which partially shows the implementation of an HTTP client to the vector server presented earlier (see the full code listing at <a class="calibre1" href="https://github.com/vladimirvivien/learning-go/ch12/client/client.go">https://github.com/vladimirvivien/learning-go/ch12/client/client.go</a>). The <code class="email">add</code> method encodes the parameters <code class="email">vec0</code> and <code class="email">vec2</code> of type <code class="email">vector.SimpleVector</code> as JSON objects, which are sent to the server using <code class="email">c.client.Do(req)</code>. The response is decoded from the JSON array into type <code class="email">vector.SimpleVector</code> assigned to variable <code class="email">result</code>:</p><pre class="programlisting">type vecClient struct { 
    svcAddr string 
    client *http.Client 
} 
func (c *vecClient) add( 
   vec0, vec1 vector.SimpleVector) (vector.SimpleVector, error) { 
   uri := c.svcAddr + "/vec/add" 
 
   // encode params 
   var body bytes.Buffer 
    params := []vector.SimpleVector{vec0, vec1} 
   if err := json.NewEncoder(&amp;body).Encode(&amp;params); err != nil { 
         return []float64{}, err 
   } 
   req, err := http.NewRequest("POST", uri, &amp;body) 
   if err != nil { 
        return []float64{}, err 
   } 
 
   // send request 
   resp, err := c.client.Do(req) 
   if err != nil { 
       return []float64{}, err 
   } 
   defer resp.Body.Close() 
 
   // handle response 
   var result vector.SimpleVector 
   if err := json.NewDecoder(resp.Body). 
        Decode(&amp;result); err != nil { 
        return []float64{}, err 
    } 
    return result, nil 
} 
</pre><p class="calibre10">golang.fyi/ch12/client/client.go</p><p class="calibre10">We can use type <code class="email">httptest.Server</code> to create code to test the requests sent by a client and to return data to the client code for further inspection. Function <code class="email">httptest.NewServer</code> takes a value of type <code class="email">http.Handler</code>, where the test logic for the server is encapsulated. The function then returns a new running HTTP server ready to serve on a system-selected port.</p><p class="calibre10">The following test function shows how to use <code class="email">httptest.Server</code> to exercise the <code class="email">add</code> method from the client code presented earlier. Notice that when creating the server, the code uses type <code class="email">http.HandlerFunc</code>, which is an adapter that takes a function value to produce an <code class="email">http.Handler</code>. This convenience allows us to skip the creation of a separate type to implement a new <code class="email">http.Handler</code>:</p><pre class="programlisting">import( 
    "net/http" 
    "net/http/httptest" 
    ... 
) 
func TestClientAdd(t *testing.T) { 
   server := httptest.NewServer(http.HandlerFunc( 
         func(resp http.ResponseWriter, req *http.Request) { 
             // test incoming request path 
             if req.URL.Path != "/vec/add" { 
                 t.Errorf("unexpected request path %s",  
                    req.URL.Path) 
                   return 
               } 
               // test incoming params 
               body, _ := ioutil.ReadAll(req.Body) 
               params := strings.TrimSpace(string(body)) 
               if params != "[[1,2],[3,4]]" { 
                     t.Errorf("unexpected params '%v'", params) 
                     return 
               } 
               // send result 
               result := vector.New(1, 2).Add(vector.New(3, 4)) 
               err := json.NewEncoder(resp).Encode(&amp;result) 
               if err != nil { 
                     t.Fatal(err) 
                     return 
               } 
         }, 
   )) 
   defer server.Close() 
   client := newVecClient(server.URL) 
   expected := vector.New(1, 2).Add(vector.New(3, 4)) 
   result, err := client.add(vector.New(1, 2), vector.New(3, 4)) 
   if err != nil { 
         t.Fatal(err) 
   } 
   if !result.Eq(expected) { 
         t.Errorf("Expecting %s, got %s", expected, result) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch12/client/client_test.go</p><p class="calibre10">The test function first sets up the <code class="email">server</code> along with its handler function. Inside the function ofÂ <code class="email">http.HandlerFunc</code>, the code first ensures that the client requests the proper path of <code class="email">"/vec/add"</code>. Next, the code inspects the request body from the client, ensuring proper JSON format and valid parameters for the add operation. Finally, the handler function encodes the expected result as JSON and sends it as a response to the client.</p><p class="calibre10">The code uses the system-generated <code class="email">server</code> address to create a new <code class="email">client</code> with <code class="email">newVecClient(server.URL)</code>. Method call <code class="email">client.add(vector.New(1, 2), vector.New(3, 4))</code> sends a request to the test server to calculate the vector addition of the two values in its parameter list. As shown earlier, the test server merely simulates the real server code and returns the calculated vector value. The <code class="email">result</code> is inspected against the <code class="email">expected</code> value to ensure proper working of the <code class="email">add</code> method.</p></div></div></body></html>