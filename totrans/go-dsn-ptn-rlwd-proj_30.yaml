- en: Chapter 5.  Building Distributed Systems and Working with Flexible Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：构建分布式系统和处理灵活数据
- en: In this chapter, we will explore transferrable skills that allow us to use schemaless
    data and distributed technologies to solve big data problems. The system we will
    build in this chapter will prepare us for a future where all democratic elections
    happen online on Twitter, of course. Our solution will collect and count votes
    by querying Twitter's streaming API for mentions of specific hash tags, and each
    component will be capable of horizontally scaling to meet demand. Our use case
    is a fun and interesting one, but the core concepts we'll learn and the specific
    technology choices we'll make are the real focus of this chapter. The ideas discussed
    here are directly applicable to any system that needs true-scale capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可转移的技能，这些技能使我们能够使用无模式数据和分布式技术来解决大数据问题。本章中我们将构建的系统将为我们准备一个未来，在这个未来中，所有民主选举都在Twitter上在线进行，当然。我们的解决方案将通过查询Twitter的流式API以获取特定哈希标签的提及来收集和计票，并且每个组件都将能够进行水平扩展以满足需求。我们的用例既有趣又引人入胜，但本章真正关注的是我们将学习到的核心概念和我们将做出的具体技术选择。这里讨论的想法可以直接应用于任何需要真实规模能力的系统。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Horizontal scaling** refers to adding nodes, such as physical machines, to
    a system in order to improve its availability, performance, and/or capacity. Big
    data companies such as Google can scale by adding affordable and easy-to-obtain
    hardware (commonly referred to as commodity hardware) due to the way they write
    their software and architect their solutions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**水平扩展**指的是向系统中添加节点，例如物理机器，以提高其可用性、性能和/或容量。像Google这样的大数据公司可以通过添加经济实惠且易于获得的硬件（通常称为通用硬件）来扩展，这得益于他们编写软件和构建解决方案的方式。'
- en: '**Vertical scaling** is synonymous to increasing the resource available to
    a single node, such as adding additional RAM to a box or a processor with more
    cores.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**垂直扩展**等同于增加单个节点可用的资源，例如向一个盒子添加额外的RAM或具有更多核心的处理器。'
- en: 'In this chapter, you will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Learn about distributed **NoSQL** datastores, specifically how to interact with
    MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解分布式**NoSQL**数据存储，特别是如何与MongoDB交互
- en: Learn about **distributed messaging queues**, in our case, Bit.ly's NSQ and
    how to use the `go-nsq` package to easily publish and subscribe to events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**分布式消息队列**，在我们的案例中，是Bit.ly的NSQ以及如何使用`go-nsq`包轻松发布和订阅事件
- en: Stream live tweet data through Twitter's streaming APIs and manage long running
    net connections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Twitter的流式API实时传输推文数据并管理长时间运行的网路连接
- en: Learn how to properly stop programs with many internal goroutines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何正确停止具有许多内部goroutines的程序
- en: Learn how to use low memory channels for signaling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用低内存通道进行信号传递
- en: The system design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统设计
- en: 'Having a basic design sketched out is often useful, especially in distributed
    systems where many components will be communicating with each other in different
    ways. We don''t want to spend too long on this stage because our design is likely
    to evolve as we get stuck into the details, but we will look at a high-level outline
    so that we can discuss the constituents and how they fit together:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，许多组件将以不同的方式相互通信，因此绘制一个基本设计通常很有用。我们不希望在这个阶段花费太多时间，因为我们的设计可能会随着我们陷入细节而演变，但我们将查看一个高级概述，以便我们可以讨论组成部分及其如何组合在一起：
- en: '![The system design](img/00060.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![系统设计](img/00060.jpeg)'
- en: 'The preceding diagram shows the basic overview of the system we are going to
    build:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们将要构建的系统的基本概述：
- en: Twitter is the social media network we all know and love.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter是我们所有人都知道并喜爱的社交媒体网络。
- en: Twitter's streaming API allows long-running connections where tweet data is
    streamed as quickly as possible.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter的流式API允许长时间运行的连接，推文数据可以尽可能快地传输。
- en: '`twittervotes` is a program we will write that pulls the relevant tweet data
    via the Twitter API, decides what is being voted for (rather, which options are
    mentioned in the tweet body), and then pushes the vote into NSQ.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twittervotes`是我们将编写的程序，它通过Twitter API提取相关推文数据，决定正在投票的内容（而不是推文正文中提到的选项），然后将投票推送到NSQ。'
- en: NSQ is an open source, real-time distributed messaging platform designed to
    operate at scale, built and maintained by Bit.ly. NSQ carries the message across
    its instances, making it available to anyone who has expressed an interest in
    the vote data.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSQ是一个开源的实时分布式消息平台，旨在进行大规模操作，由Bit.ly开发和维护。NSQ在其实例之间传输消息，使其对任何表示对投票数据感兴趣的人可用。
- en: '`counter` is a program we will write that listens out for votes on the messaging
    queue and periodically saves the results in the MongoDB database. It receives
    the vote messages from NSQ and keeps an in-memory tally of the results, periodically
    pushing an update to persist the data.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter` 是我们将编写的程序，它监听消息队列上的投票，并定期将结果保存到 MongoDB 数据库中。它从 NSQ 接收投票消息，并保持内存中的计分，定期推送更新以持久化数据。'
- en: MongoDB is an open source document database designed to operate at scale.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 是一个开源的文档数据库，旨在进行大规模操作。
- en: '`web` is a web server program that will expose the live results that we will
    write in the next chapter.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web` 是一个将暴露我们在下一章中编写的实时结果的 Web 服务器程序。'
- en: It could be argued that a single Go program could be written that reads the
    tweets, counts the votes, and pushes them to a user interface, but such a solution,
    while being a great proof of concept, would be very limited in scale. In our design,
    any one of the components can be horizontally scaled as the demand for that particular
    capability increases. If we have relatively few polls but lots of people viewing
    the data, we can keep the `twittervotes` and `counter` instances down and add
    more `web` and MongoDB nodes or vice versa if the situation is reversed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以争论说，可以编写一个单一的 Go 程序来读取推文、计数投票并将它们推送到用户界面，但这样的解决方案，虽然是一个很好的概念证明，但在规模上会非常有限。在我们的设计中，任何组件都可以随着对该特定功能的需求的增加而进行水平扩展。如果我们有相对较少的投票但很多人查看数据，我们可以保持
    `twittervotes` 和 `counter` 实例的数量，并添加更多的 `web` 和 MongoDB 节点，反之亦然。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another key advantage to our design is redundancy; since we can have many instances
    of our components working at the same time, if one of our boxes disappears (due
    to a system crash or a power cut, for example), the others can pick up the slack.
    Modern architectures often distribute such a system over the geographical expanse
    in order to protect from local natural disasters too. All of these options are
    available for use if we build our solution in this way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的另一个关键优势是冗余；由于我们可以同时运行许多组件实例，如果一个我们的盒子消失了（例如，由于系统崩溃或断电），其他可以填补空缺。现代架构通常将此类系统分布到地理范围，以防止局部自然灾害。如果我们以这种方式构建解决方案，所有这些选项都可以使用。
- en: We chose specific technologies in this chapter because of their links to Go
    (NSQ, for example, is written entirely in Go) and the availability of well-tested
    drivers and packages. Conceptually, however, you can drop in a variety of alternatives
    as you see fit.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中选择了特定的技术，因为它们与 Go 的联系（例如，NSQ 完全用 Go 编写）以及经过良好测试的驱动程序和包的可用性。然而，从概念上讲，你可以根据需要添加各种替代方案。
- en: The database design
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库设计
- en: 'We will call our MongoDB database `ballots`. It will contain a single collection
    called `polls`, which is where we will store the poll details, such as the title,
    the options, and the results (in a single JSON document). The code for a poll
    will look something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称我们的 MongoDB 数据库为 `ballots`。它将包含一个名为 `polls` 的单个集合，我们将在这里存储投票细节，例如标题、选项和结果（在一个单独的
    JSON 文档中）。投票的代码看起来可能像这样：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `_id` field is a unique string for each item that is automatically generated
    by MongoDB. The `options` field contains an array of string options; these are
    the hash tags we will look for on Twitter. The `results` field is a map where
    the key represents the option, and the value represents the total number of votes
    for each item.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`_id` 字段是 MongoDB 自动生成的每个项目的唯一字符串。`options` 字段包含一个字符串选项数组；这些是我们将在 Twitter 上寻找的哈希标签。`results`
    字段是一个映射，其中键代表选项，值代表每个项目的总投票数。'
- en: Installing the environment
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装环境
- en: The code we write in this chapter has real external dependencies that we need
    to set up before we can start to build our system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中编写的代码具有真实的外部依赖项，我们需要在开始构建我们的系统之前设置这些依赖项。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to check out the chapter notes at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    if you get stuck on installing any of the dependencies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装任何依赖项时遇到困难，请务必查看[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)中的章节注释。
- en: In most cases, services such as `mongod` and `nsqd` will have to be started
    before we can run our programs. Since we are writing components of a distributed
    system, we will have to run each program at the same time, which is as simple
    as opening many terminal windows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，必须在运行我们的程序之前启动像 `mongod` 和 `nsqd` 这样的服务。由于我们正在编写分布式系统的组件，我们必须同时运行每个程序，这就像打开许多终端窗口一样简单。
- en: Introducing NSQ
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 NSQ
- en: NSQ is a messaging queue that allows one program to send messages or events
    to another or to many other programs running either locally on the same machine
    or on different nodes connected by a network. NSQ guarantees the delivery of each
    message at least once, which means that it keeps undelivered messages cached until
    all interested parties have received them. This means that even if we stop our
    `counter` program, we won't miss any votes. You can contrast this capability with
    fire-and-forget message queues, where information is deemed out of date, and is,
    therefore, forgotten if it isn't delivered in time and when the sender of the
    messages doesn't care whether the consumer received them or not.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ 是一个消息队列，允许一个程序向另一个或多个程序发送消息或事件，这些程序可以是在同一台机器上本地运行的，也可以是通过网络连接的不同节点上的。NSQ
    保证至少将每条消息投递一次，这意味着它会将未投递的消息缓存起来，直到所有感兴趣的各方都收到它们。这意味着即使我们停止 `counter` 程序，也不会错过任何投票。你可以将这种能力与“火光即忘”的消息队列进行对比，其中信息被认为过时，因此如果信息没有及时投递，并且消息的发送者不关心消费者是否收到它们，那么这些信息就会被遗忘。
- en: A message queue abstraction allows you to have different components of a system
    running in different places, provided that they have network connectivity to the
    queue. Your programs are decoupled from others; instead, your designs start to
    care about the ins and outs of specialized micro services rather than flow of
    data through a monolithic program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列抽象允许系统中的不同组件在不同的地方运行，前提是它们能够通过网络连接到队列。你的程序与其他程序解耦；相反，你的设计开始关注专用微服务的输入输出，而不是通过单体程序的数据流。
- en: NSQ transfers raw bytes, which means that it is up to us how we encode data
    into these bytes. For example, we could encode the data as JSON or in a binary
    format depending on our needs. In our case, we are going to send the vote option
    as a string without any additional encoding, since we are only sharing a single
    data field.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ 转移原始字节，这意味着如何将这些字节编码成数据取决于我们。例如，根据我们的需求，我们可以将数据编码为 JSON 或二进制格式。在我们的案例中，我们将以字符串的形式发送投票选项，而不进行任何额外的编码，因为我们只共享单个数据字段。
- en: 'We first need to get NSQ installed and running:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要安装并运行 NSQ：
- en: 'Open [http://nsq.io/deployment/installing.html](http://nsq.io/deployment/installing.html)
    in a browser (or search `install nsq`) and follow the instructions for your environment.
    You can either download precompiled binaries or build your own from the source.
    If you have homebrew installed, installing NSQ is as simple as typing the following:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 [http://nsq.io/deployment/installing.html](http://nsq.io/deployment/installing.html)（或搜索
    `install nsq`）并遵循适合你环境的说明。你可以下载预编译的二进制文件，或者从源代码构建自己的版本。如果你已经安装了 homebrew，安装 NSQ
    只需输入以下命令：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have installed NSQ, you will need to add the `bin` folder to your `PATH`
    environment variable so that the tools are available in a terminal.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 NSQ 后，你需要将 `bin` 文件夹添加到你的 `PATH` 环境变量中，以便在终端中可以使用这些工具。
- en: 'To validate that NSQ is properly installed, open a terminal and run `nsqlookupd`;
    if the program successfully starts, you should see output similar to the following:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证 NSQ 是否正确安装，打开终端并运行 `nsqlookupd`；如果程序成功启动，你应该会看到类似以下输出的内容：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are going to use the default ports to interact with NSQ, so take note of
    the TCP and HTTP ports listed in the output, as we will be referring to them in
    our code.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用默认端口与 NSQ 交互，所以请注意输出中列出的 TCP 和 HTTP 端口，因为我们在代码中会引用它们。
- en: Press *Ctrl + C* to stop the process for now; we'll start them properly later.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl + C* 停止当前进程；我们稍后会正确启动它们。
- en: The key tools from the NSQ installation that we are going to use are `nsqlookupd`
    and `nsqd`. The `nsqlookupd` program is a daemon that manages topology information
    about the distributed NSQ environment; it keeps track of all the `nsqd` producers
    for specific topics and provides interfaces for clients to query such information.
    The `nsqd` program is a daemon that does the heavy lifting for NSQ, such as receiving,
    queuing, and delivering messages from and to interested parties.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 NSQ 安装中使用的关键工具是 `nsqlookupd` 和 `nsqd`。`nsqlookupd` 程序是一个守护进程，它管理分布式 NSQ
    环境中的拓扑信息；它跟踪特定主题的所有 `nsqd` 生产者，并为客户端提供查询此类信息的接口。`nsqd` 程序是一个守护进程，为 NSQ 执行繁重的工作，例如接收、排队和向感兴趣的一方投递消息。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information and background on NSQ, visit [http://nsq.io/](http://nsq.io/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于 NSQ 的信息和背景，请访问 [http://nsq.io/](http://nsq.io/)。
- en: NSQ driver for Go
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NSQ 驱动程序 for Go
- en: 'The NSQ tools themselves are written in Go, so it is logical that the Bit.ly
    team already has a Go package that makes interacting with NSQ very easy. We will
    need to use it, so in a terminal, you can get it using `go get`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ 工具本身是用 Go 编写的，因此 Bit.ly 团队已经有一个 Go 包，它使得与 NSQ 交互变得非常简单。我们将需要使用它，所以你可以在终端中使用
    `go get` 获取它：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Introducing MongoDB
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 MongoDB
- en: 'MongoDB is a document database, which allows you to store and query JSON documents
    and the data within them. Each document goes into a collection that can be used
    to group the documents together without enforcing any schema on the data inside
    them. Unlike rows in a traditional RDBMS, such as Oracle, Microsoft SQL Server,
    or MySQL, it is perfectly acceptable for documents to have a different shape.
    For example, a `people` collection can contain the following three JSON documents
    at the same time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个文档数据库，它允许你存储和查询 JSON 文档及其中的数据。每个文档都会进入一个集合，可以用来将文档分组在一起，而不会对其中数据强制任何模式。与传统的关系型数据库管理系统（如
    Oracle、Microsoft SQL Server 或 MySQL）中的行不同，文档具有不同的形状是完全可接受的。例如，一个 `people` 集合可以同时包含以下三个
    JSON 文档：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This flexibility allows data with varying structures to coexist without impacting
    performance or wasting space. It is also extremely useful if you expect your software
    to evolve over time, as we really always should.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性允许具有不同结构的数据共存，而不会影响性能或浪费空间。如果你预计你的软件会随着时间的推移而演变，这将是极其有用的，因为我们确实应该始终这样做。
- en: MongoDB was designed to scale while also remaining very easy to work with on
    single-box installations, such as our development machine. When we host our application
    for production, we would most likely install a more complex multi-sharded, replicated
    system, which is distributed across many nodes and locations, but for now, just
    running `mongod` will do.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 被设计成在扩展的同时，在单机安装（如我们的开发机）上也非常易于使用。当我们为生产部署应用程序时，我们很可能会安装一个更复杂的、多分片、复制的系统，该系统分布在许多节点和位置，但就目前而言，只需运行
    `mongod` 即可。
- en: Head over to [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)
    in order to grab the latest version of MongoDB and install it, making sure to
    register the `bin` folder with your `PATH` environment variable, as usual.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads) 以获取
    MongoDB 的最新版本并安装它，确保像往常一样将 `bin` 文件夹注册到你的 `PATH` 环境变量中。
- en: To validate that MongoDB is successfully installed, run the `mongod` command,
    and then hit *Ctrl + C* to stop it for now.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 MongoDB 是否成功安装，运行 `mongod` 命令，然后按 *Ctrl + C* 停止它。
- en: MongoDB driver for Go
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MongoDB Go 驱动程序
- en: 'Gustavo Niemeyer has done a great job in simplifying interactions with MongoDB
    with his `mgo` (pronounced *mango*) package hosted at [http://labix.org/mgo](http://labix.org/mgo),
    which is *go gettable* with the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gustavo Niemeyer 通过他在 [http://labix.org/mgo](http://labix.org/mgo) 上托管的 `mgo`（发音为
    *mango*）包，出色地简化了与 MongoDB 的交互，该包可以通过以下命令进行 *go get*：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Starting the environment
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动环境
- en: 'Now that we have all the pieces we need installed, we need to start our environment.
    In this section, we are going to:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有需要的组件，我们需要启动我们的环境。在本节中，我们将：
- en: Start `nsqlookupd` so that our `nsqd` instances are discoverable
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 `nsqlookupd` 以便我们的 `nsqd` 实例可被发现
- en: Start `nsqd` and tell it which `nsqlookupd` to use
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 `nsqd` 并告诉它使用哪个 `nsqlookupd`
- en: Start `mongod` for data services
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据服务启动 `mongod`
- en: Each of these daemons should run in their own terminal window, which will make
    it easy for us to stop them by just hitting *Ctrl + C*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些守护进程都应该在自己的终端窗口中运行，这样我们只需按 *Ctrl + C* 就可以轻松停止它们。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember the page number for this section as you are likely to revisit it a
    few times as you work through this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住本节的页码，因为你很可能在阅读本章时会多次回到这里。
- en: 'In a terminal window, run the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中，运行以下命令：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take note of the TCP port, which is `4160` by default, and in another terminal
    window, run the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意默认的 TCP 端口是 `4160`，然后在另一个终端窗口中运行以下命令：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Make sure the port number in the `--lookupd-tcp-address` flag matches the TCP
    port of the `nsqlookupd` instance. Once you start `nsqd`, you will notice some
    output printed to the terminal from both `nsqlookupd` and `nsqd`; this indicates
    that the two processes are talking to each other.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `--lookupd-tcp-address` 标志中的端口号与 `nsqlookupd` 实例的 TCP 端口匹配。一旦你启动 `nsqd`，你将注意到来自
    `nsqlookupd` 和 `nsqd` 的输出打印到终端；这表明这两个进程正在互相通信。
- en: 'In yet another window or tab, start MongoDB by running the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口或标签页中，通过运行以下命令来启动 MongoDB：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `dbpath` flag tells MongoDB where to store the data files for our database.
    You can pick any location you like, but you'll have to make sure the folder exists
    before `mongod` will run.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbpath`标志告诉MongoDB将数据库的数据文件存储在哪里。你可以选择任何你喜欢的位置，但你需要确保在`mongod`运行之前文件夹存在。'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By deleting the `dbpath` folder at any time, you can effectively erase all data
    and start afresh. This is especially useful during development.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在任何时候删除`dbpath`文件夹，您可以有效地擦除所有数据并重新开始。这在开发过程中特别有用。
- en: Now that our environment is running, we are ready to start building our components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了环境，我们准备开始构建我们的组件。
- en: Reading votes from Twitter
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Twitter读取投票
- en: 'In your `$GOPATH/src` folder, alongside other projects, create a new folder
    called `socialpoll` for this chapter. This folder won''t be a Go package or a
    program by itself, but it will contain our three component programs. Inside `socialpoll`,
    create a new folder called `twittervotes` and add the obligatory `main.go` template
    (this is important as `main` packages without a `main` function won''t compile):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`$GOPATH/src`文件夹中，与其他项目并列，为这一章创建一个名为`socialpoll`的新文件夹。这个文件夹本身不会是一个Go包或程序，但它将包含我们的三个组件程序。在`socialpoll`内部创建一个名为`twittervotes`的新文件夹，并添加必要的`main.go`模板（这很重要，因为没有`main`函数的`main`包无法编译）：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `twittervotes` program is going to:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`twittervotes`程序将：
- en: Load all polls from the MongoDB database using `mgo` and collect all options
    from the `options` array in each document
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`mgo`从MongoDB数据库中加载所有投票，并从每个文档的`options`数组中收集所有选项
- en: Open and maintain a connection to Twitter's streaming APIs looking for any mention
    of the options
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开并维护与Twitter流式API的连接，寻找任何提及的选项
- en: Figure out which option is mentioned and push that option through to NSQ for
    each tweet that matches the filter
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定哪个选项被提及，并将该选项推送到匹配过滤器的每个推文的NSQ
- en: If the connection to Twitter is dropped (which is common in long-running connections
    that are actually part of Twitter's streaming API specification) after a short
    delay (so that we do not bombard Twitter with connection requests), reconnect
    and continue
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Twitter的连接断开（这在Twitter流式API规范中的长时间运行连接中很常见），在短暂的延迟后（这样我们不会向Twitter发送过多的连接请求），重新连接并继续
- en: Periodically re-query MongoDB for the latest polls and refresh the connection
    to Twitter to make sure we are always looking out for the right options
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期重新查询MongoDB以获取最新的投票，并刷新与Twitter的连接，以确保我们始终在寻找正确的选项
- en: Gracefully stop itself when the user terminates the program by hitting *Ctrl
    + C*
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户通过按*Ctrl + C*终止程序时，优雅地停止自身
- en: Authorization with Twitter
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Twitter进行授权
- en: 'In order to use the streaming API, we will need authentication credentials
    from Twitter''s Application Management console, much in the same way we did for
    our Gomniauth service providers in Chapter 3, *Three Ways to Implement Profile
    Pictures*. Head over to [https://apps.twitter.com](https://apps.twitter.com) and
    create a new app called something like `SocialPoll` (the names have to be unique,
    so you can have some fun here; the choice of name doesn''t affect the code either
    way). When your app has been created, visit the **API Keys** tab and locate the
    **Your access token** section, where you need to create a new access token. After
    a short delay, refresh the page and note that you, in fact, have two sets of keys
    and secrets: an API key and a secret and an access token and the corresponding
    secret. Following good coding practices, we are going to set these values as environment
    variables so that our program can have access to them without us having to hardcode
    them in our source files. The keys we will use in this chapter are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用流式API，我们需要从Twitter的应用管理控制台获取认证凭据，这与我们在第3章“三种实现个人头像的方法”中为Gomniauth服务提供商所做的方式非常相似。请访问[https://apps.twitter.com](https://apps.twitter.com)并创建一个名为`SocialPoll`（名称必须是唯一的，所以你可以在这里玩得开心；名称的选择也不会影响代码）的新应用。当你的应用创建完成后，访问**API密钥**标签页，找到**您的访问令牌**部分，在那里你需要创建一个新的访问令牌。稍作延迟后，刷新页面并注意，实际上你拥有两组密钥和密钥：一个API密钥和一个密钥，以及一个访问令牌和相应的密钥。遵循良好的编码实践，我们将把这些值设置为环境变量，这样我们的程序就可以访问它们，而无需在我们源文件中硬编码它们。在本章中我们将使用的密钥如下：
- en: '`SP_TWITTER_KEY`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_KEY`'
- en: '`SP_TWITTER_SECRET`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_SECRET`'
- en: '`SP_TWITTER_ACCESSTOKEN`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_ACCESSTOKEN`'
- en: '`SP_TWITTER_ACCESSSECRET`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_ACCESSSECRET`'
- en: 'You may set the environment variables however you like, but since the app relies
    on them in order to work, creating a new file called `setup.sh` (for bash shells)
    or `setup.bat` (on Windows) is a good idea since you can check such files into
    your source code repository. Insert the following code in `setup.sh` by copying
    the appropriate values from the Twitter app page:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意设置环境变量，但由于应用程序依赖于它们才能工作，创建一个名为 `setup.sh`（用于 bash shell）或 `setup.bat`（在
    Windows 上）的新文件是个好主意，因为你可以将这些文件存入源代码仓库。在 `setup.sh` 中插入以下代码，通过从 Twitter 应用页面复制适当的值：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On Windows, the code will look something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，代码看起来可能如下所示：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the file with the source or call commands to have the values set appropriately,
    or add them to your `.bashrc` or `C:\cmdauto.cmd` files to save you from running
    them every time you open a new terminal window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源代码或调用命令来设置适当的值，或者将它们添加到你的 `.bashrc` 或 `C:\cmdauto.cmd` 文件中，以避免每次打开新终端窗口时都运行它们。
- en: If you're not sure how to do this, just search for `Setting environment variables
    on Linux` or something similar, and the Internet will help you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定如何操作，只需搜索 `在 Linux 上设置环境变量` 或类似的内容，互联网会帮助你。
- en: Extracting the connection
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取连接
- en: The Twitter streaming API supports HTTP connections that stay open for a long
    time, and given the design of our solution, we are going to need to access the
    `net.Conn` object in order to close it from outside of the goroutine in which
    requests occur. We can achieve this by providing our own `dial` method to an `http.Transport`
    object that we will create.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter 流式 API 支持长时间保持打开的 HTTP 连接，鉴于我们解决方案的设计，我们需要访问 `net.Conn` 对象以便从发生请求的 goroutine
    外部关闭它。我们可以通过为我们创建的 `http.Transport` 对象提供一个自己的 `dial` 方法来实现这一点。
- en: 'Create a new file called `twitter.go` inside `twittervotes` (which is where
    all things Twitter-related will live), and insert the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `twittervotes` 目录内创建一个名为 `twitter.go` 的新文件（这是所有与 Twitter 相关内容将存放的地方），并插入以下代码：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our bespoke `dial` function first ensures that `conn` is closed and then opens
    a new connection, keeping the `conn` variable updated with the current connection.
    If a connection dies (Twitter's API will do this from time to time) or is closed
    by us, we can redial without worrying about zombie connections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定制的 `dial` 函数首先确保 `conn` 已关闭，然后打开一个新的连接，同时保持 `conn` 变量更新为当前连接。如果连接中断（Twitter
    的 API 会不时这样做）或由我们关闭，我们可以重新连接而不必担心僵尸连接。
- en: 'We will periodically close the connection ourselves and initiate a new one
    because we want to reload the options from the database at regular intervals.
    To do this, we need a function that closes the connection and also closes `io.ReadCloser`,
    which we will use to read the body of the responses. Add the following code to
    `twitter.go`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定期自己关闭连接并启动一个新的连接，因为我们希望定期从数据库重新加载选项。为此，我们需要一个函数来关闭连接，并关闭 `io.ReadCloser`，我们将使用它来读取响应体。将以下代码添加到
    `twitter.go` 中：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we can call `closeConn` at any time in order to break the ongoing connection
    with Twitter and tidy things up. In most cases, our code will load the options
    from the database again and open a new connection right away, but if we're shutting
    the program down (in response to a *Ctrl + C* hit), then we can call `closeConn`
    just before we exit.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何时候调用 `closeConn` 来断开与 Twitter 的当前连接并整理事物。在大多数情况下，我们的代码将再次从数据库加载选项并立即打开一个新的连接，但如果我们正在关闭程序（响应于
    *Ctrl + C* 的按键），那么我们可以在退出之前调用 `closeConn`。
- en: Reading environment variables
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取环境变量
- en: 'Next, we are going to write a function that will read the environment variables
    and set up the `OAuth` objects we''ll need in order to authenticate the requests.
    Add the following code to the `twitter.go` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个函数来读取环境变量，并设置我们需要的 `OAuth` 对象，以便对请求进行身份验证。将以下代码添加到 `twitter.go` 文件中：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we define a `struct` type to store the environment variables that we need
    to authenticate with Twitter. Since we don't need to use the type elsewhere, we
    define it inline and create a variable called `ts` of this anonymous type (that's
    why we have the somewhat unusual `var ts struct...` code). We then use Joe Shaw's
    `envdecode` package to pull in these environment variables for us. You will need
    to run `go get github.com/joeshaw/envdecode` and also import the `log` package.
    Our program will try to load appropriate values for all the fields marked `required`
    and return an error if it fails to do so, which reminds people that the program
    won't work without Twitter credentials.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个`struct`类型来存储我们需要用Twitter进行认证的环境变量。由于我们不需要在其他地方使用这个类型，我们将其定义在内联，并创建一个名为`ts`的匿名类型变量（这就是为什么我们有`var
    ts struct...`这样的代码）。然后我们使用Joe Shaw的`envdecode`包来帮我们拉取这些环境变量。你需要运行`go get github.com/joeshaw/envdecode`，并且还需要导入`log`包。我们的程序将尝试加载所有标记为`required`的字段的适当值，如果失败则返回错误，这提醒人们程序没有Twitter凭证将无法工作。
- en: The strings inside the back ticks alongside each field in `struct` are called
    tags and are available through a reflection interface, which is how `envdecode`
    knows which variables to look for. We added the `required` argument to this package,
    which indicates that it is an error for any of the environment variables to be
    missing (or empty).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`struct`中每个字段旁边的反引号内的字符串被称为标签，并且可以通过反射接口访问，这就是`envdecode`知道要查找哪些变量的方式。我们向这个包中添加了`required`参数，这表示如果任何环境变量缺失（或为空）都是错误。
- en: Once we have the keys, we use them to create `oauth.Credentials` and an `oauth.Client`
    object from Gary Burd's `go-oauth` package, which will allow us to authorize requests
    with Twitter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了密钥，我们使用它们从Gary Burd的`go-oauth`包中创建`oauth.Credentials`和`oauth.Client`对象，这将允许我们使用Twitter授权请求。
- en: 'Now that we have the ability to control the underlying connection and authorize
    requests, we are ready to write the code that will actually build the authorized
    request and return the response. In `twitter.go`, add the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了控制底层连接和授权请求的能力，我们就可以编写实际构建授权请求并返回响应的代码了。在`twitter.go`中添加以下代码：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use `sync.Once` to ensure our initialization code gets run only once despite
    the number of times we call `makeRequest`. After calling the `setupTwitterAuth`
    method, we create a new `http.Client` function using an `http.Transport` function
    that uses our custom `dial` method. We then set the appropriate headers required
    for authorization with Twitter by encoding the specified `params` object that
    will contain the options we are querying for.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sync.Once`来确保初始化代码只运行一次，尽管我们可能多次调用`makeRequest`。在调用`setupTwitterAuth`方法之后，我们使用一个`http.Transport`函数创建一个新的`http.Client`函数，该函数使用我们自定义的`dial`方法。然后，我们设置适当的头信息，通过编码包含我们查询选项的指定`params`对象，以实现与Twitter的授权。
- en: Reading from MongoDB
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从MongoDB读取
- en: 'In order to load the polls, and therefore the options to search Twitter for,
    we need to connect to and query MongoDB. In `main.go`, add the two functions `dialdb`
    and `closedb`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载投票，并因此搜索Twitter的选项，我们需要连接到并查询MongoDB。在`main.go`中添加两个函数`dialdb`和`closedb`：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These two functions will connect to and disconnect from the locally running
    MongoDB instance using the `mgo` package and store `mgo.Session` (the database
    connection object) in a global variable called `db`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将使用`mgo`包连接到并断开本地运行的MongoDB实例，并将`mgo.Session`（数据库连接对象）存储在名为`db`的全局变量中。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As an additional assignment, see whether you can find an elegant way to make
    the location of the MongoDB instance configurable so that you don't need to run
    it locally.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加任务，看看你能否找到一个优雅的方法来使MongoDB实例的位置可配置，这样你就不需要本地运行它。
- en: 'Assuming MongoDB is running and our code is able to connect, we need to load
    the poll objects and extract all the options from the documents, which we will
    then use to search Twitter. Add the following `loadOptions` function to `main.go`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设MongoDB正在运行并且我们的代码能够连接，我们需要加载投票对象并从文档中提取所有选项，然后我们将使用这些选项来搜索Twitter。将以下`loadOptions`函数添加到`main.go`中：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our poll document contains more than just `Options`, but our program doesn't
    care about anything else, so there's no need for us to bloat our `poll` struct.
    We use the `db` variable to access the `polls` collection from the `ballots` database
    and call the `mgo` package's fluent `Find` method, passing `nil` (meaning no filtering).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投票文档包含的不仅仅是 `Options`，但我们的程序对其他任何东西都不关心，因此我们不需要膨胀我们的 `poll` 结构体。我们使用 `db`
    变量从 `ballots` 数据库访问 `polls` 集合，并调用 `mgo` 包的流畅的 `Find` 方法，传递 `nil`（表示没有过滤）。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A fluent interface (first coined by Eric Evans and Martin Fowler) refers to
    an API design that aims to make the code more readable by allowing you to chain
    method calls together. This is achieved by each method returning the context object
    itself so that another method can be called directly afterwards. For example,
    `mgo` allows you to write queries such as this: `query := col.Find(q).Sort("field").Limit(10).Skip(10)`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅式接口（最初由 Eric Evans 和 Martin Fowler 提出）是指一种旨在通过允许你链式调用方法来使代码更易于阅读的 API 设计。这是通过每个方法返回上下文对象本身来实现的，以便可以直接调用另一个方法。例如，`mgo`
    允许你编写如下查询：`query := col.Find(q).Sort("field").Limit(10).Skip(10)`
- en: We then get an iterator by calling the `Iter` method, which allows us to access
    each poll one by one. This is a very memory-efficient way of reading the poll
    data because it only ever uses a single `poll` object. If we were to use the `All`
    method instead, the amount of memory we'd use would depend on the number of polls
    we had in our database, which could be out of our control.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `Iter` 方法来获取一个迭代器，这允许我们逐个访问每个投票。这是一种非常节省内存的读取投票数据的方式，因为它始终只使用一个 `poll`
    对象。如果我们使用 `All` 方法，我们将使用的内存量将取决于我们数据库中的投票数量，这可能是我们无法控制的。
- en: When we have a poll, we use the `append` method to build up the `options` slice.
    Of course, with millions of polls in the database, this slice too would grow large
    and unwieldy. For that kind of scale, we would probably run multiple `twittervotes`
    programs, each dedicated to a portion of the poll data. A simple way to do this
    would be to break polls into groups based on the letters the titles begin with,
    such as group A-N and O-Z. A somewhat more sophisticated approach would be to
    add a field to the `poll` document, grouping it up in a more controlled manner,
    perhaps based on the stats for the other groups so that we are able to balance
    the load across many `twittervotes` instances.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个投票时，我们使用 `append` 方法来构建 `options` 切片。当然，随着数据库中数百万个投票的增加，这个切片也会变得很大且难以管理。对于这种规模，我们可能会运行多个
    `twittervotes` 程序，每个程序都专注于投票数据的一部分。一种简单的方法是将投票根据标题开头的字母分组，例如 A-N 组和 O-Z 组。一种稍微复杂的方法是在
    `poll` 文档中添加一个字段，以更受控的方式对其进行分组，可能基于其他组的统计数据，这样我们就能在许多 `twittervotes` 实例之间平衡负载。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `append` built-in function is actually a `variadic` function, which means
    you can pass multiple elements for it to append. If you have a slice of the correct
    type, you can add `...` to the end, which simulates the passing of each item of
    the slice as a different argument.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `append` 函数实际上是一个 `可变参数` 函数，这意味着你可以传递多个元素给它进行追加。如果你有一个正确类型的切片，你可以在末尾添加 `...`，这模拟了将切片的每个项目作为不同的参数传递。
- en: Finally, we close the iterator and clean up any used memory before returning
    the options and any errors that occurred while iterating (by calling the `Err`
    method in the `mgo.Iter` object).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在返回选项和迭代过程中发生的任何错误（通过在 `mgo.Iter` 对象中调用 `Err` 方法）之前关闭迭代器并清理任何使用的内存。
- en: Reading from Twitter
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Twitter 读取
- en: 'Now we are able to load the options and make authorized requests to the Twitter
    API. We are ready to write the code that initiates the connection and continuously
    reads from the stream until either we call our `closeConn` method or Twitter closes
    the connection for one reason or another. The structure contained in the stream
    is a complex one, containing all kinds of information about the tweet who made
    it and when and even what links or mentions of users occur in the body (refer
    to Twitter''s API documentation for more details). However, we are only interested
    in the tweet text itself; so, don''t worry about all the other noise and add the
    following structure to `twitter.go`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够加载选项并授权请求Twitter API。我们准备好编写代码来初始化连接，并持续从流中读取，直到我们调用我们的`closeConn`方法或Twitter因某种原因关闭连接。流中包含的结构是复杂的，包含有关发推文的人、时间以及推文中出现的各种链接或用户提及的信息（更多详情请参考Twitter的API文档）。然而，我们只对推文文本本身感兴趣；所以，不用担心所有其他噪音，并将以下结构添加到`twitter.go`中：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'This may feel incomplete, but think about how clear it makes our intentions
    to other programmers who might see our code: a tweet has some text, and that is
    all we care about.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉不完整，但想想它如何使其他可能看到我们代码的程序员对我们的意图更加清晰：推文有一些文本，这就是我们关心的全部。
- en: 'Using this new structure, in `twitter.go`, add the following `readFromTwitter`
    function that takes a send only channel called `votes`; this is how this function
    will inform the rest of our program that it has noticed a vote on Twitter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的结构，在`twitter.go`中添加以下`readFromTwitter`函数，该函数接受一个只发送通道`votes`；这是该函数如何通知我们程序它已经注意到Twitter上的投票：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, after loading the options from all the polls data (by
    calling the `loadOptions` function), we use `url.Parse` to create a `url.URL`
    object that describes the appropriate endpoint on Twitter. We build a `url.Values`
    object called `query` and set the options as a comma-separated list. As per the
    API, we make a new `POST` request using the encoded `url.Values` object as the
    body and pass it to `makeRequest` along with the query object itself. If all is
    well, we make a new `json.Decoder` from the body of the request and keep reading
    inside an infinite `for` loop by calling the `Decode` method. If there is an error
    (probably due to the connection being closed), we simply break the loop and exit
    the function. If there is a tweet to read, it will be decoded into the `t` variable,
    which will give us access to the `Text` property (the 140 characters of the tweet
    itself). We then iterate over all the possible options, and if the tweet has mentioned
    it, we send it on the `votes` channel. This technique also allows a tweet to contain
    many votes at the same time, something you may or may not decide to change based
    on the rules of the election.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在从所有投票数据中加载选项（通过调用`loadOptions`函数）之后，我们使用`url.Parse`创建一个描述Twitter上适当端点的`url.URL`对象。我们构建一个名为`query`的`url.Values`对象，并将选项作为逗号分隔的列表设置。根据API，我们使用编码后的`url.Values`对象作为正文，并连同查询对象本身一起传递给`makeRequest`。如果一切顺利，我们从请求的正文创建一个新的`json.Decoder`，并通过调用`Decode`方法在一个无限`for`循环中持续读取。如果出现错误（可能是由于连接被关闭），我们简单地退出循环并退出函数。如果有推文要读取，它将被解码到`t`变量中，这将使我们能够访问`Text`属性（推文本身的140个字符）。然后我们遍历所有可能的选项，如果推文提到了它，我们就通过`votes`通道发送它。这种技术还允许推文同时包含多个投票，你可能或可能不会根据选举规则决定是否更改这一点。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `votes` channel is send-only (which means we cannot receive on it), since
    it is of the `chan<- string` type. Think of the little arrow that tells us which
    way messages will flow: either into the channel (`chan<-`) or out of it (`<-chan`).
    This is a great way to express intent to other programmers or our future selves-it''s
    clear that we never intend to read votes using our `readFromTwitter` function;
    rather, we will only send them on that channel.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`votes`通道是只发送的（这意味着我们不能从它接收），因为它属于`chan<- string`类型。想象一下那个告诉我们消息将如何流动的小箭头：要么进入通道（`chan<-`），要么从它出来（`<-chan`）。这是向其他程序员或我们未来的自己表达意图的绝佳方式——很明显，我们永远不会使用我们的`readFromTwitter`函数来读取投票；相反，我们只会将它们发送到该通道。'
- en: Terminating the program whenever `Decode` returns an error doesn't provide a
    very robust solution. This is because the Twitter API documentation states that
    the connection will drop from time to time, and clients should consider this when
    consuming the services. And remember, we are going to terminate the connection
    periodically too, so we need to think about a way to reconnect once the connection
    is dropped.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Decode`返回错误时终止程序不是一个非常健壮的解决方案。这是因为Twitter API文档指出，连接有时会断开，客户端在消费服务时应考虑这一点。而且记住，我们也将定期终止连接，因此我们需要考虑一种在连接断开时重新连接的方法。
- en: Signal channels
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号通道
- en: A great use of channels in Go is to signal events between code running in different
    goroutines. We are going to see a real-world example of this when we write our
    next function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，通道的一个重要作用是在不同goroutine中运行的代码之间传递事件。当我们编写下一个函数时，我们将看到一个真实世界的例子。
- en: 'The purpose of the function is to start a goroutine that continually calls
    the `readFromTwitter` function (with the specified `votes` channel to receive
    the votes on) until we signal that we want it to stop. And once it has stopped,
    we want to be notified through another signal channel. The return of the function
    will be a channel of `struct{}`: a signal channel.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的目的是启动一个goroutine，该goroutine会持续调用`readFromTwitter`函数（使用指定的`votes`通道接收投票），直到我们发出停止信号。一旦停止，我们希望通过另一个信号通道得到通知。函数的返回值将是一个`struct{}`类型的通道：一个信号通道。
- en: Signal channels have some interesting properties that are worth taking a closer
    look at. Firstly, the type sent down the channels is an empty `struct{}`, instances
    of which actually take up zero bytes, since it has no fields. So, `struct{}{}`
    is a great memory-efficient option for signaling events. Some people use `bool`
    types, which are also fine, although `true` and `false` both take up a byte of
    memory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道有一些有趣的特性值得仔细研究。首先，通道中发送的类型是一个空的`struct{}`，其实例实际上占用零字节，因为它没有字段。所以，`struct{}{}`是一个很好的内存高效选项，用于信号事件。有些人使用`bool`类型，这也是可以的，尽管`true`和`false`都占用一个字节的内存。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Head over to [http://play.golang.org](http://play.golang.org) and try this out
    for yourself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[http://play.golang.org](http://play.golang.org)亲自尝试一下。
- en: 'The size of `bool` is one:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`类型的大小为1：'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other hand, the size of `struct{}{}` is zero:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`struct{}{}`的大小为零：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The signal channels also have a buffer size of 1, which means that execution
    will not get blocked until something reads the signal from the channel.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道也有一个缓冲区大小为1，这意味着执行不会因为读取通道中的信号而被阻塞。
- en: 'We are going to employ two signal channels in our code: one that we pass into
    our function that tells our goroutine that it should stop and another (provided
    by the function) that signals once the stopping is complete.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中使用两个信号通道：一个是我们传递给函数的，告诉我们的goroutine应该停止；另一个（由函数提供）在停止完成后发出信号。
- en: 'In `twitter.go`, add the following function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twitter.go`中添加以下函数：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, the first argument, `stopchan`, is a channel of type
    `<-chan struct{}`, a receive-only signal channel. It is this channel that, outside
    the code, will signal on, which will tell our goroutine to stop. Remember that
    it''s receive-only inside this function; the actual channel itself will be capable
    of sending. The second argument is the `votes` channel on which votes will be
    sent. The return type of our function is also a signal channel of type `<-chan
    struct{}`: a receive-only channel that we will use to indicate that we have stopped.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个参数`stopchan`是一个类型为`<-> struct{}`的通道，一个只读信号通道。这个通道在外部代码中会发出信号，这将告诉我们的goroutine停止。记住，在这个函数内部它是只读的；实际的通道本身将能够发送。第二个参数是`votes`通道，投票将通过这个通道发送。我们函数的返回类型也是一个`<->
    struct{}`类型的信号通道：一个只读通道，我们将用它来表示我们已经停止。
- en: These channels are necessary because our function triggers its own goroutine
    and immediately returns; so without this, calling code would have no idea whether
    the spawned code was still running or not.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通道是必要的，因为我们的函数会触发自己的goroutine并立即返回；如果没有这些，调用代码将无法知道生成的代码是否仍在运行。
- en: The first thing we do in the `startTwitterStream` function is make our `stoppedchan`
    argument, and defer the sending of `struct{}{}` to indicate that we have finished
    when our function exits. Note that `stoppedchan` is a normal channel, so even
    though it is returned as receive-only, we will be able to send it from within
    this function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startTwitterStream`函数中，我们首先创建我们的`stoppedchan`参数，并在函数退出时延迟发送`struct{}{}`以表示我们已经完成。请注意，`stoppedchan`是一个普通通道，因此尽管它被返回为只接收，我们仍然可以在函数内部发送它。
- en: We then start an infinite `for` loop in which we select from one of two channels.
    The first is `stopchan` (the first argument), which would indicate that it was
    time to stop and return (thus triggering the deferred signaling on `stoppedchan`).
    If that hasn't happened, we will call `readFromTwitter` (passing in the `votes`
    channel), which will go and load the options from the database and open the connection
    to Twitter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后启动一个无限`for`循环，在其中从两个通道中选择一个。第一个是`stopchan`（第一个参数），这表明是时候停止并返回（从而触发`stoppedchan`上的延迟信号）。如果没有发生这种情况，我们将调用`readFromTwitter`（传递`votes`通道），这将去加载数据库中的选项并打开到Twitter的连接。
- en: When the Twitter connection dies, our code will return, where we sleep for 10
    seconds using the `time.Sleep` function. This is to give the Twitter API rest
    in case it closed the connection due to overuse. Once we've rested, we re-enter
    the loop and check on `stopchan` again to see whether calling code wants us to
    stop or not.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当Twitter连接断开时，我们的代码将返回，我们使用`time.Sleep`函数暂停10秒钟。这是为了让Twitter API休息，以防它因为过度使用而关闭了连接。一旦我们休息完毕，我们重新进入循环，再次检查`stopchan`，看看调用代码是否想要我们停止。
- en: To make this flow clear, we are logging out key statements that will not only
    help us debug our code, but also let us peek into the inner workings of this somewhat
    complicated mechanism.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个流程更清晰，我们正在记录关键语句，这不仅有助于我们调试代码，还可以让我们窥视这个有些复杂的机制的内部工作。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Signal channels are a great solution for simple cases where all code lives inside
    a single package. If you need to cross API boundaries, the context package is
    the recommended way to deal with deadlines, cancelation and, stopping since it
    was promoted to the standard library in Go 1.7.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道是解决所有代码都位于单个包内部简单情况的一个很好的解决方案。如果你需要跨越API边界，从Go 1.7开始推广到标准库的上下文包是处理截止日期、取消和停止的推荐方式。
- en: Publishing to NSQ
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到NSQ
- en: Once our code successfully notices votes on Twitter and sends them down the
    `votes` channel, we need a way to publish them into an NSQ topic; after all, this
    is the point of the `twittervotes` program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的代码成功注意到Twitter上的投票并将它们发送到`votes`通道，我们需要一种方法将它们发布到NSQ主题；毕竟，这是`twittervotes`程序的目的。
- en: We will write a function called `publishVotes`, which will take the `votes`
    channel, this time of type `<-chan string` (a receive only channel), and publish
    each string that is received from it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`publishVotes`的函数，它将接受`votes`通道，这次类型为`<-chan string`（一个只接收通道），并发布从它接收到的每个字符串。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In our previous functions, the `votes` channel was of type `chan<- string`,
    but this time, it's of the type `<-chan string`. You might think this is a mistake
    or even that it means that we cannot use the same channel for both, but you would
    be wrong. The channel we create later will be made with `make(chan string)`, neither
    receive nor only send, and can act in both cases. The reason for using the `<-`
    operator on a channel in arguments is to make the intent of what the channel will
    be used for clear, or in the case where it is the return type, to prevent users
    from accidentally sending on channels intended for receiving or vice versa. The
    compiler will actually produce an error if they use such a channel incorrectly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的函数中，`votes`通道的类型是`chan<- string`，但这次它的类型是`<-chan string`。你可能认为这是一个错误，甚至认为这意味着我们不能为两者使用相同的通道，但你错了。我们稍后创建的通道将使用`make(chan
    string)`创建，既不接收也不只发送，可以在这两种情况下使用。在参数中使用`<-`操作符的原因是为了使通道将要被用于什么目的更加清晰，或者在它是返回类型的情况下，防止用户意外地在用于接收的通道上发送，或者反之亦然。如果他们错误地使用这样的通道，编译器实际上会生成一个错误。
- en: Once the `votes` channel is closed (this is how the external code will tell
    our function to stop working), we will stop publishing and send a signal down
    the returned stop signal channel.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`votes`通道关闭（这是外部代码告诉我们的函数停止工作的方式），我们将停止发布，并通过返回的停止信号通道发送一个信号。
- en: 'Add the `publishVotes` function to `main.go`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将`publishVotes`函数添加到`main.go`中：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, the first thing we do is create `stopchan`, which we later return, this
    time not deferring the signaling but doing it inline by sending `struct{}{}` down
    `stopchan`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们首先做的事情是创建 `stopchan`，我们稍后返回，这次不是延迟信号，而是通过向 `stopchan` 发送 `struct{}{}`
    来直接执行。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The difference in how we handle `stopchan` is to show alternative options. Within
    one code base, you should pick a style you like and stick with it until a standard
    emerges within the community; in which case, we should all go with that. It is
    also possible to close `stopchan` rather than send anything down it, which will
    also unblock the code waiting on that channel. But once a channel is closed, it
    cannot be reopened.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理 `stopchan` 的不同之处在于展示替代选项。在一个代码库中，你应该选择你喜欢的一种风格并坚持下去，直到社区中出现标准；在这种情况下，我们都应该采用那个标准。关闭
    `stopchan` 而不是向其发送任何内容也是可能的，这将也会解除等待该通道的代码的阻塞。但一旦通道被关闭，就不能重新打开。
- en: We then create an NSQ producer by calling `NewProducer` and connecting to the
    default NSQ port on `localhost` using a default configuration. We start a goroutine,
    which uses another great built-in feature of the Go language that lets us continually
    pull values from a channel (in our case, the `votes` channel) just by doing a
    normal `for...range` operation on it. Whenever the channel has no values, execution
    will be blocked until one comes down the line. If the `votes` channel is closed,
    the `for` loop will exit.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `NewProducer` 并使用默认配置连接到 `localhost` 上的默认 NSQ 端口来创建一个 NSQ 生产者。我们启动一个
    goroutine，它使用 Go 语言的一个出色的内置功能，允许我们通过在通道上执行正常的 `for...range` 操作来持续地从通道中拉取值（在我们的例子中，是
    `votes` 通道）。每当通道没有值时，执行将被阻塞，直到有值到来。如果 `votes` 通道被关闭，`for` 循环将退出。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn more about the power of channels in Go, it is highly recommended that
    you seek out blog posts and videos by John Graham-Cumming, in particular, one
    entitled *A Channel Compendium* that he presented at Gophercon 2014 and which
    contains a brief history of channels, including their origin (interestingly, John
    was also the guy who successfully petitioned the British government to officially
    apologize for its treatment of the late, great Alan Turing).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Go 中通道的力量，强烈建议你寻找约翰·格雷厄姆-卡明（John Graham-Cumming）的博客文章和视频，特别是他在 2014
    年 Gophercon 上展示的题为 *A Channel Compendium* 的文章，其中包含通道的简要历史，包括其起源（有趣的是，约翰也是那位成功请愿英国政府正式道歉，对已故的伟大艾伦·图灵（Alan
    Turing）进行处理的先生）。
- en: When the loop exits (after the `votes` channel is closed), the publisher is
    stopped, following which the `stopchan` signal is sent. Did anything stand-out
    as unusual in the `publishVotes` function? We are breaking a cardinal rule of
    Go by ignoring an error (assigning it to an underscore variables; therefore dismissing
    it). As an additional exercise, catch the error and deal with it in a way that
    seems suitable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环退出（`votes` 通道被关闭后），发布者被停止，随后发送 `stopchan` 信号。在 `publishVotes` 函数中有什么异常之处吗？我们违反了
    Go 的一个基本规则，即忽略了一个错误（将其分配给下划线变量；因此忽略它）。作为额外的练习，捕获错误并以适当的方式处理它。
- en: Gracefully starting and stopping programs
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅地启动和停止程序
- en: When our program is terminated, we want to do a few things before actually exiting,
    namely closing our connection to Twitter and stopping the NSQ publisher (which
    actually deregisters its interest in the queue). To achieve this, we have to override
    the default *Ctrl + C* behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的程序终止时，我们想在真正退出之前做几件事情，即关闭我们与 Twitter 的连接并停止 NSQ 发布者（它实际上注销了对队列的兴趣）。为了实现这一点，我们必须覆盖默认的
    *Ctrl + C* 行为。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The upcoming code blocks all go inside the `main` function; they are broken
    up so that we can discuss each section before continuing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块都放在 `main` 函数中；它们被拆分，这样我们可以在继续之前讨论每个部分。
- en: 'Add the following code inside the `main` function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部添加以下代码：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we create a stop `bool` with an associated `sync.Mutex` function so that
    we can access it from many goroutines at the same time. We then create two more
    signal channels, `stopChan` and `signalChan`, and use `signal.Notify` to ask Go
    to send the signal down `signalChan` when someone tries to halt the program (either
    with the `SIGINT` interrupt or the `SIGTERM` termination POSIX signals). The `stopChan`
    function is how we indicate that we want our processes to terminate, and we pass
    it as an argument to `startTwitterStream` later.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们创建一个带有相关`sync.Mutex`函数的`stop`布尔值，这样我们就可以同时从多个goroutine中访问它。然后我们创建另外两个信号通道，`stopChan`和`signalChan`，并使用`signal.Notify`请求Go在有人尝试停止程序时（无论是使用`SIGINT`中断还是`SIGTERM`终止POSIX信号）将信号发送到`signalChan`。`stopChan`函数是我们表示我们希望我们的进程终止的方式，我们将其作为参数传递给后续的`startTwitterStream`。 '
- en: We then run a goroutine that blocks waiting for the signal by trying to read
    from `signalChan`; this is what the `<-` operator does in this case (it's trying
    to read from the channel). Since we don't care about the type of signal, we don't
    bother capturing the object returned on the channel. Once a signal is received,
    we set `stop` to `true` and close the connection. Only when one of the specified
    signals is sent will the rest of the goroutine code run, which is how we are able
    to perform teardown code before exiting the program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后运行一个goroutine，该goroutine通过尝试从`signalChan`读取信号来阻塞等待，这就是在这个情况下`<-`操作符的作用（它正在尝试从通道中读取）。由于我们不关心信号的类型，所以我们没有麻烦地捕获通道返回的对象。一旦收到信号，我们将`stop`设置为`true`并关闭连接。只有当指定的信号之一被发送时，goroutine的其余代码才会运行，这就是我们能够在退出程序之前执行拆卸代码的原因。
- en: 'Add the following piece of code (inside the main function) to open and defer
    the closing of the database connection:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中添加以下代码片段以打开并延迟关闭数据库连接：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since the `readFromTwitter` method reloads the options from the database each
    time and because we want to keep our program updated without having to restart
    it, we are going to introduce one final goroutine. This goroutine will simply
    call `closeConn` every minute, causing the connection to die and cause `readFromTwitter`
    to be called all over again. Insert the following code at the bottom of the `main`
    function to start all of these processes and then wait for them to gracefully
    stop:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`readFromTwitter`方法每次都会从数据库重新加载选项，而且我们希望在不重新启动程序的情况下保持程序更新，因此我们将引入最后一个goroutine。这个goroutine将简单地每分钟调用一次`closeConn`，导致连接死亡并再次调用`readFromTwitter`。在`main`函数的底部插入以下代码以启动所有这些进程，然后等待它们优雅地停止：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we make the `votes` channel that we have been talking about throughout
    this section, which is a simple channel of strings. Note that it is neither a
    send (`chan<-`) nor a receive (`<-chan`) channel; in fact, making such channels
    makes little sense. We then call `publishVotes`, passing in the `votes` channel
    for it to receive from and capturing the returned stop signal channel as `publisherStoppedChan`.
    Similarly, we call `startTwitterStream`, passing in our `stopChan` function from
    the beginning of the `main` function and the `votes` channel for it to send to
    while capturing the resulting stop signal channel as `twitterStoppedChan`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建本节中一直在讨论的`votes`通道，这是一个简单的字符串通道。请注意，它既不是发送（`chan<-`）通道，也不是接收（`<-chan`）通道；实际上，创建这样的通道几乎没有意义。然后我们调用`publishVotes`，传入`votes`通道以便从中接收，并捕获返回的停止信号通道作为`publisherStoppedChan`。同样，我们调用`startTwitterStream`，传入主函数开头的`stopChan`函数以及要发送到该通道的`votes`通道，并捕获结果停止信号通道作为`twitterStoppedChan`。
- en: We then start our refresher goroutine, which immediately enters an infinite
    `for` loop before sleeping for a minute and closing the connection via the call
    to `closeConn`. If the stop `bool` has been set to true (in that previous goroutine),
    we will break the loop and exit; otherwise, we will loop around and wait another
    minute before closing the connection again. The use of `stoplock` is important
    because we have two goroutines that might try to access the stop variable at the
    same time, but we want to avoid collisions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动我们的刷新goroutine，该goroutine在休眠一分钟并通过调用`closeConn`关闭连接之前立即进入一个无限`for`循环。如果`stop`布尔值已经被设置为`true`（在之前的goroutine中），我们将退出循环；否则，我们将循环并等待另一分钟，然后再关闭连接。`stoplock`的使用很重要，因为我们有两个goroutine可能会同时尝试访问stop变量，但我们想避免冲突。
- en: Once the goroutine has started, we block `twitterStoppedChan` by attempting
    to read from it. When successful (which means the signal was sent on `stopChan`),
    we close the `votes` channel, which will cause the publisher's `for...range` loop
    to exit and the publisher itself to stop, after which the signal will be sent
    on `publisherStoppedChan`, which we wait for before exiting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 goroutine 开始运行，我们就通过尝试从中读取来阻塞 `twitterStoppedChan`。当成功时（这意味着在 `stopChan`
    上发送了信号），我们将关闭 `votes` 通道，这将导致发布者的 `for...range` 循环退出，并停止发布者本身，之后将在 `publisherStoppedChan`
    上发送信号，我们在退出之前等待这个信号。
- en: Testing
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'To make sure our program works, we need to do two things: first, we need to
    create a poll in the database, and second, we need to peer inside the messaging
    queue to see whether the messages are indeed being generated by `twittervotes`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的程序能正常工作，我们需要做两件事：首先，我们需要在数据库中创建一个投票，其次，我们需要查看消息队列内部，以确认消息确实是由 `twittervotes`
    生成的。
- en: 'In a terminal, run the `mongo` command to open a database shell that allows
    us to interact with MongoDB. Then, enter the following commands to add a test
    poll:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行 `mongo` 命令以打开一个数据库外壳，允许我们与 MongoDB 交互。然后，输入以下命令以添加一个测试投票：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding commands add a new item to the `polls` collection in the `ballots`
    database. We are using some common words for options that are likely to be mentioned
    by people on Twitter so that we can observe real tweets being translated into
    messages. You might notice that our poll object is missing the `results` field;
    this is fine since we are dealing with unstructured data where documents do not
    have to adhere to a strict schema. The `counter` program we are going to write
    in the next section will add and maintain the `results` data for us later.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令向 `ballots` 数据库中的 `polls` 集合添加了一个新条目。我们使用了一些常见的词汇作为选项，这些词汇可能会被推特上的人提及，这样我们就可以观察真实的推文被翻译成消息。你可能注意到我们的投票对象缺少
    `results` 字段；这是可以的，因为我们处理的是非结构化数据，文档不需要遵循严格的模式。我们将在下一节中编写的 `counter` 程序将为我们稍后添加并维护
    `results` 数据。
- en: 'Press *Ctrl *+ *C* to exit the MongoDB shell and type the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Ctrl *+ *C* 退出 MongoDB 外壳，并输入以下命令：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `nsq_tail` tool connects to the specified messaging queue topic and outputs
    any messages that it notices. This is where we will validate that our `twittervotes`
    program is sending messages.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsq_tail` 工具连接到指定的消息队列主题，并输出它注意到的任何消息。这是我们验证 `twittervotes` 程序是否发送消息的地方。'
- en: 'In a separate terminal window, let''s build and run the `twittervotes` program:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个独立的终端窗口中，让我们构建并运行 `twittervotes` 程序：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now switch back to the window running `nsq_tail` and note that messages are
    indeed being generated in response to live Twitter activity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换回运行 `nsq_tail` 的窗口，并注意确实有消息在响应实时推特活动时生成。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you don't see much activity, try to look up trending hash tags on Twitter
    and add another poll containing these options.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到太多活动，尝试查找推特上的热门话题标签，并添加另一个包含这些选项的投票。
- en: Counting votes
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数投票
- en: The second program we are going to implement is the `counter` tool, which will
    be responsible for watching out for votes in NSQ, counting them, and keeping MongoDB
    up to date with the latest numbers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第二个程序是 `counter` 工具，它将负责监视 NSQ 中的投票，计数它们，并确保 MongoDB 与最新的数字保持更新。
- en: 'Create a new folder called `counter` alongside `twittervotes`, and add the
    following code to a new `main.go` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `twittervotes` 旁边创建一个名为 `counter` 的新文件夹，并将以下代码添加到一个新的 `main.go` 文件中：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Connecting to the database
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'The best time to think about cleaning up resources, such as database connections,
    is immediately after you have successfully obtained the resource; Go''s `defer`
    keyword makes this easy. At the bottom of the main function, add the following
    code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑清理资源，如数据库连接的最佳时间是在成功获取资源后立即进行；Go 的 `defer` 关键字使这变得简单。在主函数的底部添加以下代码：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Consuming messages in NSQ
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 NSQ 中消费消息
- en: 'In order to count the votes, we need to consume the messages in the `votes`
    topic in NSQ, and we''ll need a place to store them. Add the following variables
    to the `main` function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计数投票，我们需要消费 NSQ 中 `votes` 主题的消息，并且我们需要一个地方来存储它们。将以下变量添加到 `main` 函数中：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A map and a lock (`sync.Mutex`) is a common combination in Go because we will
    have multiple goroutines trying to access the same map, and we need to avoid corrupting
    it by trying to modify or read it at the same time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，一个 map 和一个锁 (`sync.Mutex`) 是一个常见的组合，因为我们会有多个 goroutine 尝试访问同一个 map，我们需要避免在同时修改或读取时破坏它。
- en: 'Add the following code to the `main` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main`函数中：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `NewConsumer` function allows us to set up an object that will listen on
    the `votes` NSQ topic, so when `twittervotes` publishes a vote on that topic,
    we can handle it in this program. If `NewConsumer` returns an error, we'll use
    our `fatal` function to record it and return.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewConsumer`函数允许我们设置一个对象，该对象将监听`votes` NSQ主题，因此当`twittervotes`在该主题上发布投票时，我们可以在本程序中处理它。如果`NewConsumer`返回错误，我们将使用我们的`fatal`函数记录它并返回。'
- en: 'Next, we are going to add the code that handles messages (votes) from NSQ:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加处理来自NSQ的消息（投票）的代码：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We call the `AddHandler` method on `nsq.Consumer` and pass it a function that
    will be called for every message received on the `votes` topic.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`nsq.Consumer`上调用`AddHandler`方法，并传递一个函数，该函数将在接收到`votes`主题上的每条消息时被调用。
- en: When a vote comes in, the first thing we do is lock the `countsLock` mutex.
    Next, we defer the unlocking of the mutex for when the function exits. This allows
    us to be sure that while `NewConsumer` is running, we are the only ones allowed
    to modify the map; others will have to wait until our function exits before they
    can use it. Calls to the `Lock` method block execution while the lock is in place,
    and it only continues when the lock is released by a call to `Unlock`. This is
    why it's vital that every `Lock` call has an `Unlock` counterpart; otherwise,
    we will deadlock our program.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到投票时，我们首先做的事情是锁定`countsLock`互斥锁。接下来，我们推迟互斥锁的解锁，直到函数退出。这确保了在`NewConsumer`运行期间，我们是唯一允许修改映射的人；其他人必须等待我们的函数退出后才能使用它。在互斥锁存在的情况下，对`Lock`方法的调用会阻塞执行，只有当通过调用`Unlock`释放锁时才会继续。这就是为什么每个`Lock`调用都必须有一个`Unlock`对应调用是至关重要的；否则，我们的程序将陷入死锁。
- en: Every time we receive a vote, we check whether `counts` is `nil` and make a
    new map if it is because once the database has been updated with the latest results,
    we want to reset everything and start at zero. Finally, we increase the `int`
    value by one for the given key and return `nil`, indicating no errors.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们收到投票时，我们检查`counts`是否为`nil`，如果是，就创建一个新的映射，因为一旦数据库已经更新了最新的结果，我们希望重置一切并从零开始。最后，我们将给定键的`int`值增加一，并返回`nil`，表示没有错误。
- en: 'Although we have created our NSQ consumer and added our handler function, we
    still need to connect to the NSQ service, which we will do by adding the following
    code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经创建了我们的NSQ消费者并添加了我们的处理函数，但我们仍然需要连接到NSQ服务，我们将通过添加以下代码来完成：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that we are actually connecting to the HTTP port of
    the `nsqlookupd` instance rather than NSQ instances; this abstraction means that
    our program doesn't need to know *where* the messages are coming from in order
    to consume them. If we fail to connect to the server (for instance, if we forget
    to start it), we'll get an error, which we report to our fatal function before
    immediately returning.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们实际上是在连接到`nsqlookupd`实例的HTTP端口，而不是NSQ实例；这种抽象意味着我们的程序不需要知道消息是从哪里来的，以便消费它们。如果我们无法连接到服务器（例如，如果我们忘记启动它），我们会得到一个错误，我们会在立即返回之前将错误报告给我们的致命函数。
- en: Keeping the database updated
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持数据库更新
- en: 'Our code will listen out for votes and keep a map of the results in the memory,
    but that information is trapped inside our program so far. Next, we need to add
    the code that will periodically push the results to the database. Add the following
    `doCount` function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码将监听投票并保持结果映射在内存中，但到目前为止，这些信息被限制在我们的程序内部。接下来，我们需要添加将结果定期推送到数据库的代码。添加以下`doCount`函数：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When our `doCount` function runs, the first thing we do is lock `countsLock`
    and defer its unlocking. We then check to see whether there are any values in
    the `counts` map. If there aren't, we just log that we're skipping the update
    and wait for next time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`doCount`函数运行时，我们首先做的事情是锁定`countsLock`并推迟其解锁。然后我们检查`counts`映射中是否有任何值。如果没有，我们只是记录我们正在跳过更新，并等待下一次。
- en: We are taking all arguments in as pointers (note the `*` character before the
    type name) because we want to be sure that we are interacting with the underlying
    data itself and not a copy of it. For example, the `*counts = nil` line will actually
    reset the underlying map to `nil` rather than just invalidate our local copy of
    it. If there are some votes, we iterate over the `counts` map, pulling out the
    option and the number of votes (since the last update), and use some MongoDB magic
    to update the results.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有参数作为指针接收（注意类型名前的 `*` 字符），因为我们想确保我们正在与底层数据本身交互，而不是它的副本。例如，`*counts = nil`
    这行代码实际上会将底层映射重置为 `nil`，而不是仅仅使我们的本地副本无效。如果有一些投票，我们将遍历 `counts` 映射，提取选项和自上次更新以来的投票数，并使用一些
    MongoDB 魔法来更新结果。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB stores **BSON** (short for **Binary JSON**) documents internally, which
    are easier to traverse than normal JSON documents, and that is why the `mgo` package
    comes with the `mgo/bson` encoding package. When using `mgo`, we will often use
    `bson` types, such as the `bson.M` map, to describe concepts for MongoDB.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 内部存储 **BSON**（即 **Binary JSON**）文档，它们比正常的 JSON 文档更容易遍历，这就是为什么 `mgo`
    包附带 `mgo/bson` 编码包。当使用 `mgo` 时，我们经常会使用 `bson` 类型，如 `bson.M` 映射，来描述 MongoDB 的概念。
- en: 'We first create the selector for our update operation using the `bson.M` shortcut
    type, which is similar to creating `map[string]interface{}` types. The selector
    we create here will look something like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `bson.M` 简写类型创建更新操作的选择器，它类似于创建 `map[string]interface{}` 类型。我们创建的选择器看起来像这样：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In MongoDB, the preceding BSON specifies that we want to select polls where
    `"happy"` is one of the items in the `options` array.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，前面的 BSON 指定我们想要选择 `"happy"` 是 `options` 数组中项之一的投票。
- en: 'Next, we use the same technique to generate the update operation, which looks
    something like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用相同的技巧生成更新操作，看起来像这样：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In MongoDB, the preceding BSON specifies that we want to increase the `results.happy`
    field by three. If there is no `results` map in the poll, one will be created,
    and if there is no `happy` key inside `results`, zero will be assumed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，前面的 BSON 指定我们想要增加 `results.happy` 字段三个值。如果投票中没有 `results` 映射，将会创建一个，如果没有
    `happy` 键在 `results` 中，则默认为零。
- en: We then call the `UpdateAll` method in our `pollsData` query to issue the command
    to the database, which will in turn update every poll that matches the selector
    (contrast this to the `Update` method, which will update only one). If something
    goes wrong, we report it and set the `ok` Boolean to `false`. If all goes well,
    we set the `counts` map to nil, since we want to reset the counter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `pollsData` 查询中调用 `UpdateAll` 方法向数据库发出命令，这将反过来更新所有匹配选择器的投票（与只更新一个的 `Update`
    方法形成对比）。如果出现问题，我们将报告它并将 `ok` 布尔值设置为 `false`。如果一切顺利，我们将 `counts` 映射设置为 `nil`，因为我们想重置计数器。
- en: 'We are going to specify `updateDuration` as a constant at the top of the file,
    which will make it easy for us to change when we are testing our program. Add
    the following code above the `main` function:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `updateDuration` 作为常量指定在文件顶部，这将使我们在测试程序时更容易更改。在 `main` 函数上方添加以下代码：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we will add `time.Ticker` and make sure our `doCount` function gets called
    in the same `select` block that we use when responding to *Ctrl + C*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `time.Ticker` 并确保我们的 `doCount` 函数在响应 *Ctrl + C* 时使用的同一个 `select` 块中被调用。
- en: Responding to Ctrl + C
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应 Ctrl + C
- en: 'The last thing to do before our program is ready is set up a select block that
    periodically calls `doCount` and be sure that our `main` function waits for operations
    to complete before exiting, like we did in our `twittervotes` program. Add the
    following code at the end of the `main` function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序准备就绪之前要做的最后一件事是设置一个 `select` 块，该块定期调用 `doCount`，并确保我们的 `main` 函数在退出之前等待操作完成，就像我们在
    `twittervotes` 程序中所做的那样。在 `main` 函数的末尾添加以下代码：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `time.Ticker` function is a type that gives us a channel (via the `C` field)
    on which the current time is sent at the specified interval (in our case, `updateDuration`).
    We use this in a `select` block to call our `doCount` function while `termChan`
    and `q.StopChan` are quiet.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Ticker` 函数是一种类型，它为我们提供了一个通道（通过 `C` 字段），在指定的间隔（在我们的例子中，是 `updateDuration`）发送当前时间。我们使用这个通道在
    `select` 块中调用 `doCount` 函数，同时 `termChan` 和 `q.StopChan` 处于安静状态。'
- en: To handle termination, we have employed a slightly different tactic than before.
    We trap the termination event, which will cause a signal to go down `termChan`
    when we hit *Ctrl* + *C*. Next, we start an infinite loop, inside which we use
    the `select` structure to allow us to run the code if we receive something on
    either `termChan` or `StopChan` of the consumer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理终止，我们采用了与之前略有不同的策略。我们捕获终止事件，当我们按下*Ctrl* + *C*时，这将导致一个信号传到`termChan`。接下来，我们启动一个无限循环，在其中我们使用`select`结构来允许我们在接收到`termChan`或消费者`StopChan`上的任何东西时运行代码。
- en: In fact, we will only ever get a `termChan` signal first in response to a *Ctrl*
    + *C* press, at which point we stop `time.Ticker` and ask the consumer to stop
    listening for votes. Execution then re-enters the loop and blocks until the consumer
    reports that it has indeed stopped by signaling on its `StopChan` function. When
    that happens, we're done and we exit, at which point our deferred statement runs,
    which, if you remember, tidies up the database session.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们只有在按下*Ctrl* + *C*后才会首先收到`termChan`信号，此时我们停止`time.Ticker`并要求消费者停止监听投票。然后执行重新进入循环并阻塞，直到消费者通过在其`StopChan`函数上发出信号来报告它确实已经停止。当这种情况发生时，我们就完成了，然后退出，此时我们的延迟语句运行，如果你还记得，它会清理数据库会话。
- en: Running our solution
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的解决方案
- en: 'It''s time to see our code in action. Ensure that you have `nsqlookupd`, `nsqd`,
    and `mongod` running in separate terminal windows with the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看到我们的代码在行动了。确保你有`nsqlookupd`、`nsqd`和`mongod`在单独的终端窗口中运行，如下所示：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you haven''t already done so, make sure the `twittervotes` program is running
    too. Then, in the `counter` folder, build and run our counting program:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请确保`twittervotes`程序正在运行。然后，在`counter`文件夹中，构建并运行我们的计数程序：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see a periodic output describing what work `counter` is doing, such
    as the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到周期性的输出，描述`counter`正在做什么，例如以下内容：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The output will, of course, vary since we are actually responding to real, live
    activity on Twitter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实际上是在响应Twitter上的真实活动，所以输出当然会变化。
- en: 'We can see that our program is receiving vote data from NSQ and reports to
    update the database with the results. We can confirm this by opening the MongoDB
    shell and querying the poll data to see whether the `results` map is being updated.
    In another terminal window, open the MongoDB shell:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的程序正在从NSQ接收投票数据并向数据库报告更新结果。我们可以通过打开MongoDB shell并查询投票数据来确认这一点，以查看`results`映射是否正在更新。在另一个终端窗口中，打开MongoDB
    shell：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Ask it to use the ballots database:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要求它使用选票数据库：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use the `find` method with no arguments to get all polls (add the `pretty`
    method to the end to get nicely formatted JSON):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不带参数的`find`方法来获取所有投票（在末尾添加`pretty`方法以获取格式良好的JSON）：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `results` map is indeed updated, and at any point in time, it contains the
    total number of votes for each option.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`results`映射确实被更新了，在任何时刻，它都包含每个选项的总票数。'
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground. We learned different techniques
    to gracefully shut down programs using signaling channels, which is especially
    important when our code has some work to do before it can exit. We saw that deferring
    the reporting of fatal errors at the start of our program can give our other deferred
    functions a chance to execute before the process ends.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了很多内容。我们学习了使用信号通道优雅地关闭程序的不同技术，这在我们的代码在退出前需要做一些工作的情况下尤为重要。我们看到了在程序开始时推迟报告致命错误可以给其他延迟函数一个在进程结束前执行的机会。
- en: We also discovered how easy it is to interact with MongoDB using the `mgo` package
    and how to use BSON types when describing concepts for the database. The `bson.M`
    alternative to `map[string]interface{}` helps us keep our code more concise while
    still providing all the flexibility we need when working with unstructured or
    schemaless data.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了使用`mgo`包与MongoDB交互是多么容易，以及如何在描述数据库概念时使用BSON类型。`bson.M`作为`map[string]interface{}`的替代方案，帮助我们使代码更加简洁，同时在我们处理非结构化或无模式数据时仍然提供所需的所有灵活性。
- en: We learned about message queues and how they allow us to break apart the components
    of a system into isolated and specialized micro-services. We started an instance
    of NSQ by first running the `nsqlookupd` lookup daemon before running a single
    `nsqd` instance and connecting them via a TCP interface. We were then able to
    publish votes to the queue in `twittervotes` and connect to the lookup daemon
    to run a handler function for every vote sent in our `counter` program.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了消息队列以及它们如何允许我们将系统的组件分解成隔离和专业的微服务。我们首先运行了`nsqlookupd`查找守护进程，然后运行单个`nsqd`实例并将它们通过TCP接口连接起来。然后我们能够在`twittervotes`中发布投票并连接到查找守护进程，为我们的`counter`程序中发送的每个投票运行一个处理函数。
- en: While our solution is actually performing a pretty simple task, the architecture
    we have put together in this chapter is capable of doing some pretty great things.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的解决方案实际上执行的是一个相当简单的任务，但我们在本章中构建的架构能够完成一些相当了不起的事情。
- en: We eliminated the need for our `twittervotes` and counter programs to run on
    the same machine-as long as they can both connect to the appropriate NSQ, they
    will function as expected regardless of where they are running.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们消除了`twittervotes`和计数程序需要在同一台机器上运行的必要性——只要它们都能连接到适当的NSQ，无论它们在哪里运行，它们都将按预期工作。
- en: We can distribute our MongoDB and NSQ nodes across many physical machines, which
    would mean our system is capable of gigantic scale-whenever resources start running
    low, we can add new boxes to cope with the demand.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将MongoDB和NSQ节点分布到许多物理机器上，这意味着我们的系统具有巨大的可扩展性——当资源开始不足时，我们可以添加新的盒子来应对需求。
- en: When we add other applications that need to query and read the results from
    polls, we can be sure that our database services are highly available and capable
    of delivering.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加其他需要查询和读取投票结果的应用程序时，我们可以确信我们的数据库服务是高度可用且能够交付的。
- en: We can spread our database across geographical expanses, replicating data for
    backup so we don't lose anything when disaster strikes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据库扩展到地理范围，复制数据进行备份，这样在灾难发生时我们不会丢失任何东西。
- en: We can build a multinode, fault-tolerant NSQ environment, which means that when
    our `twittervotes` program learns of interesting tweets, there will always be
    some place to send the data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个多节点、容错性的NSQ环境，这意味着当我们的`twittervotes`程序发现有趣的推文时，总会有一个地方可以发送数据。
- en: We can write many more programs that generate votes from different sources;
    the only requirement is that they know how to put messages into NSQ.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写更多从不同来源生成投票的程序；唯一的要求是它们知道如何将消息放入NSQ。
- en: In the next chapter, we will build a RESTful data service of our own, through
    which we will expose the functionality of our social polling application. We will
    also build a web interface that lets users create their own polls and have the
    results visualized.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建我们自己的RESTful数据服务，通过这个服务我们将公开我们的社交投票应用程序的功能。我们还将构建一个网络界面，让用户可以创建他们自己的投票并可视化结果。
