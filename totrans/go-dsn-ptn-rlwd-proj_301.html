<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Code benchmark"><div class="book" id="2IV0U2-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec83" class="calibre1"/>Code benchmark</h1></div></div></div><p class="calibre10">The purpose of benchmarking is to measure a code's performance. The Go test command-line tool comes with support for the automated generation and measurement of benchmark metrics. Similar to unit tests, the test tool uses benchmark functions to specify what portion of the code to measure. The benchmark function uses the following function naming pattern and signature:</p><p class="calibre10"><span class="strong"><em class="calibre11">func Benchmark&lt;Name&gt;(*testing.B)</em></span></p><p class="calibre10">Benchmark functions are expected to have names that start with <span class="strong"><em class="calibre11">benchmark</em></span> and accept a pointer value of type <code class="email">*testing.B</code>. The following shows a function that benchmarks the <code class="email">Add</code> method for type <code class="email">SimpleVector</code> (introduced earlier):</p><pre class="programlisting">import ( 
    "math/rand" 
    "testing" 
    "time" 
) 
... 
func BenchmarkVectorAdd(b *testing.B) { 
   r := rand.New(rand.NewSource(time.Now().UnixNano())) 
   for i := 0; i &lt; b.N; i++ { 
         v1 := New(r.Float64(), r.Float64()) 
         v2 := New(r.Float64(), r.Float64()) 
         v1.Add(v2) 
   } 
} 
</pre><p class="calibre10">golang.fyi/ch12/vector/vec_bench_test.go</p><p class="calibre10">Go's test runtime invokes the benchmark functions by injecting pointer <code class="email">*testing.B</code> as a parameter. That value defines methods for interacting with the benchmark framework such as logging, failure-signaling, and other functionalities similar to type <code class="email">testing.T</code>. Type <code class="email">testing.B</code> also offers additional benchmark-specific elements, including an integer field <code class="email">N</code>. It is intended to be the number of iterations that the benchmark function should use for effective measurements.</p><p class="calibre10">The code being benchmarked should be placed within a <code class="email">for</code> loop bounded by <code class="email">N</code>, as illustrated in the previous example. For the benchmark to be effective, there should be no variances in the size of the input for each iteration of the loop. For instance, in the preceding benchmark, each iteration always uses a vector of size <code class="email">2</code> (while the actual values of the vectors are randomized).</p></div></body></html>