- en: Code benchmark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of benchmarking is to measure a code''s performance. The Go test
    command-line tool comes with support for the automated generation and measurement
    of benchmark metrics. Similar to unit tests, the test tool uses benchmark functions
    to specify what portion of the code to measure. The benchmark function uses the
    following function naming pattern and signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '*func Benchmark<Name>(*testing.B)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Benchmark functions are expected to have names that start with *benchmark*
    and accept a pointer value of type `*testing.B`. The following shows a function
    that benchmarks the `Add` method for type `SimpleVector` (introduced earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec_bench_test.go
  prefs: []
  type: TYPE_NORMAL
- en: Go's test runtime invokes the benchmark functions by injecting pointer `*testing.B`
    as a parameter. That value defines methods for interacting with the benchmark
    framework such as logging, failure-signaling, and other functionalities similar
    to type `testing.T`. Type `testing.B` also offers additional benchmark-specific
    elements, including an integer field `N`. It is intended to be the number of iterations
    that the benchmark function should use for effective measurements.
  prefs: []
  type: TYPE_NORMAL
- en: The code being benchmarked should be placed within a `for` loop bounded by `N`,
    as illustrated in the previous example. For the benchmark to be effective, there
    should be no variances in the size of the input for each iteration of the loop.
    For instance, in the preceding benchmark, each iteration always uses a vector
    of size `2` (while the actual values of the vectors are randomized).
  prefs: []
  type: TYPE_NORMAL
