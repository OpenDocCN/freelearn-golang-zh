<html><head></head><body>
<div class="book" title="Code benchmark">
<div class="book" title="Comparative benchmarks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch12lvl2sec209" class="calibre1"/>Comparative benchmarks</h2></div></div></div><p class="calibre10">Another useful aspect of benchmarking code is to compare the performance of different algorithms that implement similar functionalities. Exercising the algorithms using performance benchmarks will indicate which of the implementations may be more compute- and memory-efficient.</p><p class="calibre10">For instance, two vectors are said to be equal if they have the same magnitude and same direction (or have an angle value of zero between them). We can implement this definition using the following source snippet:</p><pre class="programlisting">const zero = 1.0e-7  
... 
func (v SimpleVector) Eq(other Vector) bool { 
   ang := v.Angle(other) 
   if math.IsNaN(ang) { 
         return v.Mag() == other.Mag() 
   } 
   return v.Mag() == other.Mag() &amp;&amp; ang &lt;= zero 
} 
</pre><p class="calibre10">golang.fyi/ch12/vector/vec.go</p><p class="calibre10">When the preceding method is benchmarked, it yields to the following result. Each of its 3 million iterations takes an average of half a millisecond to run:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go test -run=Bench -bench=Equal1</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">BenchmarkVectorEqual1-2  3000000           454 ns/op</strong></span>
<span class="strong"><strong class="calibre2">ok    github.com/vladimirvivien/learning-go/ch12/vector     1.849s</strong></span>
</pre><p class="calibre10">The benchmark result is not bad, especially when compared to the other benchmarked methods that we saw earlier. However, suppose we want to improve on the performance of the <code class="email">Eq</code> method (maybe because it is a critical part of a program). We can use the <code class="email">-benchmem </code>flag to get additional information about the benchmarked test:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go test -run=bench -bench=Equal1 -benchmem</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">BenchmarkVectorEqual1-2  3000000 474 ns/op  48 B/op  2 allocs/op</strong></span>
</pre><p class="calibre10">The <code class="email">-benchmem</code> flag causes the test tool to reveal two additional columns, which provide memory allocation metrics, as shown in the previous output. We see that the <code class="email">Eq</code> method allocates a total of 48 bytes, with two allocations calls per operation.</p><p class="calibre10">This does not tell us much until we have something else to compare it to. Fortunately, there is another equality algorithm that we can try. It is based on the fact that two vectors are also equal if they have the same number of elements and each element is equal. This definition can be implemented by traversing the vector and comparing its elements, as is done in the following code:</p><pre class="programlisting">func (v SimpleVector) Eq2(other Vector) bool { 
   v.assertLenMatch(other) 
   otherVec := other.(SimpleVector) 
   for i, val := range v { 
         if val != otherVec[i] { 
               return false 
         } 
   } 
   return true 
} 
</pre><p class="calibre10">golang.fyi/ch12/vector/vec.go</p><p class="calibre10">Now let us benchmark the <code class="email">Eq</code> and <code class="email">Eq2</code> equality methods to see which is more performant, as done in the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; go test -run=bench -bench=Equal -benchmem</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">BenchmarkVectorEqual1-2   3000000   447 ns/op   48 B/op   2 allocs/op</strong></span>
<span class="strong"><strong class="calibre2">BenchmarkVectorEqual2-2   5000000   265 ns/op   32 B/op   1 allocs/op</strong></span>
</pre><p class="calibre10">According to the benchmark report, method <code class="email">Eq2</code> is more performant of the two equality methods. It runs in about half the time of the original method, with considerably less memory allocated. Since both benchmarks run with similar input data, we can confidently say the second method is a better choice than the first.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre10">Depending on Go version and machine size and architecture, these benchmark numbers will vary. However, the result will always show that the Eq2 method is more performant.</p></div><p class="calibre10">This discussion only scratches the surface of comparative benchmarks. For instance, the previous benchmark tests use the same size input. Sometimes it is useful to observe the change in performance as the input size changes. We could have compared the performance profile of the equality method as we change the size of the input, say, from 3, 10, 20, or 30 elements. If the algorithm is sensitive size, expanding the benchmark using such attributes will reveal any bottlenecks.</p></div></div></body></html>