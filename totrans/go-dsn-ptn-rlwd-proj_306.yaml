- en: Comparative benchmarks
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较基准测试
- en: Another useful aspect of benchmarking code is to compare the performance of
    different algorithms that implement similar functionalities. Exercising the algorithms
    using performance benchmarks will indicate which of the implementations may be
    more compute- and memory-efficient.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试代码的另一个有用方面是比较实现类似功能的不同算法的性能。使用性能基准测试来锻炼算法将表明哪种实现可能更计算和内存高效。
- en: 'For instance, two vectors are said to be equal if they have the same magnitude
    and same direction (or have an angle value of zero between them). We can implement
    this definition using the following source snippet:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果两个向量具有相同的幅度和相同的方向（或者它们之间有一个零角度值），则称这两个向量相等。我们可以使用以下源代码片段来实现这个定义：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: 'When the preceding method is benchmarked, it yields to the following result.
    Each of its 3 million iterations takes an average of half a millisecond to run:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的方法进行基准测试时，它产生了以下结果。它的300万次迭代平均每次运行需要半个毫秒：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The benchmark result is not bad, especially when compared to the other benchmarked
    methods that we saw earlier. However, suppose we want to improve on the performance
    of the `Eq` method (maybe because it is a critical part of a program). We can
    use the `-benchmem` flag to get additional information about the benchmarked test:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果还不错，尤其是与其他我们之前看到的基准测试方法相比。然而，如果我们想提高`Eq`方法的性能（可能是因为它是程序的一个关键部分），我们可以使用`-benchmem`标志来获取关于基准测试测试的额外信息：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `-benchmem` flag causes the test tool to reveal two additional columns,
    which provide memory allocation metrics, as shown in the previous output. We see
    that the `Eq` method allocates a total of 48 bytes, with two allocations calls
    per operation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`-benchmem`标志导致测试工具显示两列额外的信息，提供了内存分配指标，如前一个输出所示。我们看到`Eq`方法总共分配了48字节，每个操作有两个分配调用。'
- en: 'This does not tell us much until we have something else to compare it to. Fortunately,
    there is another equality algorithm that we can try. It is based on the fact that
    two vectors are also equal if they have the same number of elements and each element
    is equal. This definition can be implemented by traversing the vector and comparing
    its elements, as is done in the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有其他东西可以比较之前，这并没有告诉我们太多。幸运的是，还有一个我们可以尝试的等价算法。它基于这样一个事实：如果两个向量具有相同数量的元素，并且每个元素都相等，那么这两个向量也是相等的。这个定义可以通过遍历向量并比较其元素来实现，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: 'Now let us benchmark the `Eq` and `Eq2` equality methods to see which is more
    performant, as done in the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来基准测试`Eq`和`Eq2`等价方法，看看哪个性能更好，如下所示：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: According to the benchmark report, method `Eq2` is more performant of the two
    equality methods. It runs in about half the time of the original method, with
    considerably less memory allocated. Since both benchmarks run with similar input
    data, we can confidently say the second method is a better choice than the first.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基准测试报告，方法`Eq2`在两种等价方法中性能更优。它运行时间大约是原始方法的一半，分配的内存也少得多。由于这两个基准测试都使用了类似的数据输入，我们可以有信心地说第二个方法比第一个方法更好。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on Go version and machine size and architecture, these benchmark numbers
    will vary. However, the result will always show that the Eq2 method is more performant.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Go版本、机器大小和架构的不同，这些基准测试数字会有所变化。然而，结果将始终显示`Eq2`方法性能更优。
- en: This discussion only scratches the surface of comparative benchmarks. For instance,
    the previous benchmark tests use the same size input. Sometimes it is useful to
    observe the change in performance as the input size changes. We could have compared
    the performance profile of the equality method as we change the size of the input,
    say, from 3, 10, 20, or 30 elements. If the algorithm is sensitive size, expanding
    the benchmark using such attributes will reveal any bottlenecks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这场讨论只是比较基准测试的表面。例如，之前的基准测试使用相同大小的输入。有时观察输入大小变化时的性能变化是有用的。我们可以比较等价方法在输入大小从3、10、20或30个元素变化时的性能轮廓。如果算法对大小敏感，使用这样的属性扩展基准测试将揭示任何瓶颈。
