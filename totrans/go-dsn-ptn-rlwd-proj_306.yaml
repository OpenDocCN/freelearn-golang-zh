- en: Comparative benchmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful aspect of benchmarking code is to compare the performance of
    different algorithms that implement similar functionalities. Exercising the algorithms
    using performance benchmarks will indicate which of the implementations may be
    more compute- and memory-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, two vectors are said to be equal if they have the same magnitude
    and same direction (or have an angle value of zero between them). We can implement
    this definition using the following source snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preceding method is benchmarked, it yields to the following result.
    Each of its 3 million iterations takes an average of half a millisecond to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The benchmark result is not bad, especially when compared to the other benchmarked
    methods that we saw earlier. However, suppose we want to improve on the performance
    of the `Eq` method (maybe because it is a critical part of a program). We can
    use the `-benchmem` flag to get additional information about the benchmarked test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `-benchmem` flag causes the test tool to reveal two additional columns,
    which provide memory allocation metrics, as shown in the previous output. We see
    that the `Eq` method allocates a total of 48 bytes, with two allocations calls
    per operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not tell us much until we have something else to compare it to. Fortunately,
    there is another equality algorithm that we can try. It is based on the fact that
    two vectors are also equal if they have the same number of elements and each element
    is equal. This definition can be implemented by traversing the vector and comparing
    its elements, as is done in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch12/vector/vec.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us benchmark the `Eq` and `Eq2` equality methods to see which is more
    performant, as done in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: According to the benchmark report, method `Eq2` is more performant of the two
    equality methods. It runs in about half the time of the original method, with
    considerably less memory allocated. Since both benchmarks run with similar input
    data, we can confidently say the second method is a better choice than the first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on Go version and machine size and architecture, these benchmark numbers
    will vary. However, the result will always show that the Eq2 method is more performant.
  prefs: []
  type: TYPE_NORMAL
- en: This discussion only scratches the surface of comparative benchmarks. For instance,
    the previous benchmark tests use the same size input. Sometimes it is useful to
    observe the change in performance as the input size changes. We could have compared
    the performance profile of the equality method as we change the size of the input,
    say, from 3, 10, 20, or 30 elements. If the algorithm is sensitive size, expanding
    the benchmark using such attributes will reveal any bottlenecks.
  prefs: []
  type: TYPE_NORMAL
