["```go\nctx := context.WithValue(r.Context(), \"key\", \"value\") \n\n```", "```go\nHandler.ServeHTTP(w, r.WithContext(ctx)) \n\n```", "```go\nfunc WithValue(parent Context, key, val interface{}) Context \n\n```", "```go\npackage main \nfunc main(){} \n\n```", "```go\ntype contextKey struct { \n  name string \n} \n\n```", "```go\nvar contextKeyAPIKey = &contextKey{\"api-key\"} \n\n```", "```go\nfunc APIKey(ctx context.Context) (string, bool) {\n key, ok := ctx.Value(contextKeyAPIKey).(string)\n return key, ok\n}\n\n```", "```go\nfunc withAPIKey(fn http.HandlerFunc) http.HandlerFunc { \n  return func(w http.ResponseWriter, r *http.Request) { \n    key := r.URL.Query().Get(\"key\") \n    if !isValidAPIKey(key) { \n      respondErr(w, r, http.StatusUnauthorized, \"invalid\n       API key\") \n      return \n    } \n    ctx := context.WithValue(r.Context(),\n     contextKeyAPIKey, key) \n    fn(w, r.WithContext(ctx)) \n  } \n} \n\n```", "```go\nfunc isValidAPIKey(key string) bool { \n  return key == \"abc123\" \n} \n\n```", "```go\nfunc withCORS(fn http.HandlerFunc) http.HandlerFunc { \n  return func(w http.ResponseWriter, r *http.Request) { \n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\") \n    w.Header().Set(\"Access-Control-Expose-Headers\",\n     \"Location\") \n    fn(w, r) \n  } \n} \n\n```", "```go\n// Server is the API server. \ntype Server struct { \n  db *mgo.Session \n} \n\n```", "```go\nfunc decodeBody(r *http.Request, v interface{}) error { \n  defer r.Body.Close() \n  return json.NewDecoder(r.Body).Decode(v) \n} \nfunc encodeBody(w http.ResponseWriter, r *http.Request, v  interface{}) error { \n  return json.NewEncoder(w).Encode(v) \n} \n\n```", "```go\nfunc respond(w http.ResponseWriter, r *http.Request, \n status int, data interface{}) { \n  w.WriteHeader(status) \n  if data != nil { \n    encodeBody(w, r, data) \n  } \n} \n\n```", "```go\nfunc respondErr(w http.ResponseWriter, r *http.Request, \n status int, args ...interface{}) { \n  respond(w, r, status, map[string]interface{}{ \n    \"error\": map[string]interface{}{ \n      \"message\": fmt.Sprint(args...), \n    }, \n  }) \n} \n\n```", "```go\nfunc respondHTTPErr(w http.ResponseWriter, r *http.Request, status int) { \n  respondErr(w, r, status, http.StatusText(status)) \n} \n\n```", "```go\npackage main \nimport ( \n  \"strings\" \n) \nconst PathSeparator = \"/\" \ntype Path struct { \n  Path string \n  ID   string \n} \nfunc NewPath(p string) *Path { \n  var id string \n  p = strings.Trim(p, PathSeparator) \n  s := strings.Split(p, PathSeparator) \n  if len(s) > 1 { \n    id = s[len(s)-1] \n    p = strings.Join(s[:len(s)-1], PathSeparator) \n  } \n  return &Path{Path: p, ID: id} \n} \nfunc (p *Path) HasID() bool { \n  return len(p.ID) > 0 \n} \n\n```", "```go\nfunc main() { \n  var ( \n    addr  = flag.String(\"addr\", \":8080\", \"endpoint\n     address\") \n    mongo = flag.String(\"mongo\", \"localhost\", \"mongodb\n     address\") \n  ) \n  log.Println(\"Dialing mongo\", *mongo) \n  db, err := mgo.Dial(*mongo) \n  if err != nil { \n    log.Fatalln(\"failed to connect to mongo:\", err) \n  } \n  defer db.Close() \n  s := &Server{ \n    db: db, \n  } \n  mux := http.NewServeMux() \n  mux.HandleFunc(\"/polls/\",\n   withCORS(withAPIKey(s.handlePolls))) \n  log.Println(\"Starting web server on\", *addr) \n  http.ListenAndServe(\":8080\", mux) \n  log.Println(\"Stopping...\") \n} \n\n```", "```go\nwithCORS(withAPIKey(handlePolls)) \n\n```", "```go\npackage main \nimport \"gopkg.in/mgo.v2/bson\" \ntype poll struct { \n  ID      bson.ObjectId  `bson:\"_id\" json:\"id\"` \n  Title   string         `json:\"title\"` \n  Options []string       `json:\"options\"` \n  Results map[string]int `json:\"results,omitempty\"` \n  APIKey  string         `json:\"apikey\"` \n} \n\n```", "```go\nID bson.ObjectId `bson:\"_id\" json:\"id\"` \n\n```", "```go\nfunc (s *Server) handlePolls(w http.ResponseWriter,\n r *http.Request) { \n  switch r.Method { \n    case \"GET\": \n    s.handlePollsGet(w, r) \n    return \n    case \"POST\": \n    s.handlePollsPost(w, r) \n    return \n    case \"DELETE\": \n    s.handlePollsDelete(w, r) \n    return \n  } \n  // not found \n  respondHTTPErr(w, r, http.StatusNotFound) \n} \n\n```", "```go\nfunc (s *Server) handlePollsGet(w http.ResponseWriter,\n r *http.Request) { \n  respondErr(w, r, http.StatusInternalServerError,\n   errors.New(\"not    \n  implemented\")) \n} \nfunc (s *Server) handlePollsPost(w http.ResponseWriter,\n r *http.Request) { \n  respondErr(w, r, http.StatusInternalServerError,\n   errors.New(\"not   \n   implemented\")) \n} \nfunc (s *Server) handlePollsDelete(w http.ResponseWriter,\n  r *http.Request) { \n  respondErr(w, r, http.StatusInternalServerError,\n   errors.New(\"not  \n   implemented\")) \n} \n\n```", "```go\nfunc (s *Server) handlePollsGet(w http.ResponseWriter,\n r *http.Request) { \n  session := s.db.Copy() \n  defer session.Close() \n  c := session.DB(\"ballots\").C(\"polls\") \n  var q *mgo.Query \n  p := NewPath(r.URL.Path) \n  if p.HasID() { \n    // get specific poll \n    q = c.FindId(bson.ObjectIdHex(p.ID)) \n  } else { \n    // get all polls \n    q = c.Find(nil) \n  } \n  var result []*poll \n  if err := q.All(&result); err != nil { \n    respondErr(w, r, http.StatusInternalServerError, err) \n    return \n  } \n  respond(w, r, http.StatusOK, &result) \n} \n\n```", "```go\n> use ballots\nswitched to db ballots\n> db.polls.insert({\"title\":\"Test  poll\",\"options\":\n     [\"one\",\"two\",\"three\"]})\n> db.polls.insert({\"title\":\"Test poll  two\",\"options\":\n     [\"four\",\"five\",\"six\"]})\n\n```", "```go\ngo build -o api\n./api\n\n```", "```go\nfunc (s *Server) handlePollsPost(w http.ResponseWriter, \n r *http.Request) { \n  session := s.db.Copy() \n  defer session.Close() \n  c := session.DB(\"ballots\").C(\"polls\") \n  var p poll \n  if err := decodeBody(r, &p); err != nil { \n    respondErr(w, r, http.StatusBadRequest, \"failed to\n     read poll from request\", err) \n    return \n  } \n  apikey, ok := APIKey(r.Context()) \n  if ok { \n    p.APIKey = apikey \n  } \n  p.ID = bson.NewObjectId() \n  if err := c.Insert(p); err != nil { \n    respondErr(w, r, http.StatusInternalServerError,\n     \"failed to insert \n    poll\", err) \n    return \n  } \n  w.Header().Set(\"Location\", \"polls/\"+p.ID.Hex()) \n  respond(w, r, http.StatusCreated, nil) \n} \n\n```", "```go\nfunc (s *Server) handlePollsDelete(w http.ResponseWriter, \n  r *http.Request) { \n  session := s.db.Copy() \n  defer session.Close() \n  c := session.DB(\"ballots\").C(\"polls\") \n  p := NewPath(r.URL.Path) \n  if !p.HasID() { \n    respondErr(w, r, http.StatusMethodNotAllowed,\n      \"Cannot delete all polls.\") \n    return \n  } \n  if err := c.RemoveId(bson.ObjectIdHex(p.ID)); err != nil { \n    respondErr(w, r, http.StatusInternalServerError,\n     \"failed to delete poll\", err) \n    return \n  } \n  respond(w, r, http.StatusOK, nil) // ok \n} \n\n```", "```go\ncase \"OPTIONS\": \n  w.Header().Add(\"Access-Control-Allow-Methods\", \"DELETE\") \n  respond(w, r, http.StatusOK, nil) \n  return \n\n```", "```go\ngo build -o api\n./api\n\n```", "```go\n    curl -X GET http://localhost:8080/polls/?\n             key=abc123\n\n    ```", "```go\n    [{\"id\":\"541727b08ea48e5e5d5bb189\",\"title\":\"Best\n              Beatle?\",\n              \"options\": [\"john\",\"paul\",\"george\",\"ringo\"]},\n            {\"id\":\"541728728ea48e5e5d5bb18a\",\"title\":\"Favorite\n              language?\",\n              \"options\": [\"go\",\"java\",\"javascript\",\"ruby\"]}]\n\n    ```", "```go\n    curl --data '{\"title\":\"test\",\"options\":\n             [\"one\",\"two\",\"three\"]}'\n             -X POST http://localhost:8080/polls/?key=abc123\n\n    ```", "```go\n    curl -X GET http://localhost:8080/polls/?\n             key=abc123\n\n    ```", "```go\n    curl -X GET\n              http://localhost:8080/polls/541727b08ea48e5e5d5bb189?\n              key=abc123\n    [{\"id\":\"541727b08ea48e5e5d5bb189\",\",\"title\":\"Best  Beatle?\",\n              \"options\": [\"john\",\"paul\",\"george\",\"ringo\"]}]\n\n    ```", "```go\n    curl -X DELETE  \n              http://localhost:8080/polls/541727b08ea48e5e5d5bb189? \n              key=abc123\n\n    ```", "```go\n    curl -X GET http://localhost:8080/polls/?key=abc123\n    [{\"id\":\"541728728ea48e5e5d5bb18a\",\"title\":\"Favorite    \n              language?\",\"options\":[\"go\",\"java\",\"javascript\",\"ruby\"]}]\n\n    ```", "```go\npackage main \nimport ( \n  \"flag\" \n  \"log\" \n  \"net/http\" \n) \nfunc main() { \n  var addr = flag.String(\"addr\", \":8081\", \"website address\") \n  flag.Parse() \n  mux := http.NewServeMux() \n  mux.Handle(\"/\", http.StripPrefix(\"/\",  \n    http.FileServer(http.Dir(\"public\")))) \n  log.Println(\"Serving website at:\", *addr) \n  http.ListenAndServe(*addr, mux) \n} \n\n```"]