- en: Index page showing a list of polls
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `public` folder inside `web` and add the `index.html` file after
    writing the following HTML code in it:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will use Bootstrap again to make our simple UI look nice, but we need to
    add two additional sections to the `body` tag of the HTML page. First, add the
    DOM elements that will display the list of polls:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are using Bootstrap's grid system to center-align our content that
    is made up of a list of polls and a link to `new.html`, where users can create
    new polls.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following `script` tags and JavaScript underneath that:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are using jQuery's `$.get` function to make an AJAX request to our web service.
    We are hardcoding the API URL –which, in practice, you might decide against –or
    at least use a domain name to abstract it. Once the polls have loaded, we use
    jQuery to build up a list containing hyperlinks to the `view.html` page, passing
    the ID of the poll as a query parameter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new poll
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow users to create a new poll, create a file called `new.html` inside
    the `public` folder, and add the following HTML code to the file:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are going to add the elements for an HTML form that will capture the information
    we need when creating a new poll, namely the title of the poll and the options.
    Add the following code inside the `body` tags:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since our API speaks JSON, we need to do a bit of work to turn the HTML form
    into a JSON-encoded string and also break the comma-separated options string into
    an array of options. Add the following `script` tag:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we add a listener to the `submit` event of our form and use jQuery's `val`
    method to collect the input values. We split the options with a comma and trim
    the spaces away before using the `$.post` method to make the `POST` request to
    the appropriate API endpoint. `JSON.stringify` allows us to turn the data object
    into a JSON string, and we use that string as the body of the request, as expected
    by the API. On success, we pull out the `Location` header and redirect the user
    to the `view.html` page, passing a reference to the newly created poll as the
    parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Showing the details of a poll
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final page of our app we need to complete is the `view.html` page, where
    users can see the details and live results of the poll. Create a new file called
    `view.html` inside the `public` folder and add the following HTML code to it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This page is mostly similar to the other pages; it contains elements to present
    the title of the poll, the options, and a pie chart. We will be mashing up Google''s
    Visualization API with our API to present the results. Underneath the final `div`
    tag in `view.html` (and above the closing `body` tag), add the following `script`
    tags:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We include the dependencies we will need in order to power our page, jQuery
    and Bootstrap, and also the Google JavaScript API. The code loads the appropriate
    visualization libraries from Google and waits for the DOM elements to load before
    extracting the poll ID from the URL by splitting it on `poll=`. We then create
    a variable called `update` that represents a function responsible for generating
    the view of the page. This approach is taken to make it easy for us to use `window.setTimeout`
    in order to issue regular calls to update the view. Inside the `update` function,
    we use `$.get` to make a `GET` request to our `/polls/{id}` endpoint, replacing
    `{id}` with the actual ID we extracted from the URL earlier. Once the poll has
    loaded, we update the title on the page and iterate over the options to add them
    to the list. If there are results (remember, in the previous chapter, the `results`
    map was only added to the data as votes started being counted), we create a new
    `google.visualization.PieChart` object and build a `google.visualization.DataTable`
    object containing the results. Calling `draw` on the chart causes it to render
    the data and thus update the chart with the latest numbers. We then use `setTimeout`
    to tell our code to call `update` again in another second.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we bind to the `click` event of the `delete` button we added to our
    page, and after asking the user whether they are sure, make a `DELETE` request
    to the polls URL and then redirect them back to the home page. It is this request
    that will actually cause the `OPTIONS` request to be made first, asking for permission,
    which is why we added explicit support for it in our `handlePolls` function earlier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Running the solution
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built many components over the previous two chapters, and it is now time
    to see them all working together. This section contains everything you need in
    order to get all the items running, assuming you have the environment set up properly,
    as described at the beginning of the previous chapter. This section assumes you
    have a single folder that contains the four subfolders: `api`, `counter`, `twittervotes`,
    and `web`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming nothing is running, take the following steps (each step in its own
    terminal window):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top-level folder, start the `nsqlookupd` daemon:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the same directory, start the `nsqd` daemon:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start the MongoDB daemon:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Navigate to the `counter` folder and build and run it:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Navigate to the `twittervotes` folder and build and run it. Ensure that you
    have the appropriate environment variables set; otherwise, you will see errors
    when you run the program:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Navigate to the `api` folder and build and run it:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Navigate to the `web` folder and build and run it:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that everything is running, open a browser and head to `http://localhost:8081/`.
    Using the user interface, create a poll called `Moods` and input the options as
    `happy,sad,fail,success`. These are common enough words that we are likely to
    see some relevant activity on Twitter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your poll, you will be taken to the view page where you
    will start to see the results coming in. Wait for a few seconds and enjoy the
    fruits of your hard work as the UI updates in real time, showing live, real-time
    results:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的投票，你将被带到查看页面，在那里你将开始看到结果陆续到来。等待几秒钟，享受你辛勤工作的果实，因为UI实时更新，显示实时、实时结果：
- en: '![Running the solution](img/00061.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![运行解决方案](img/00061.jpeg)'
- en: Summary
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we exposed the data for our social polling solution through
    a highly scalable RESTful API and built a simple website that consumes the API
    to provide an intuitive way for users to interact with it. The website consists
    of static content only, with no server-side processing (since the API does the
    heavy lifting for us). This allows us to host the website very cheaply on static
    hosting sites, such as [bitballoon.com](https://www.bitballoon.com/), or distribute
    the files to content delivery networks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过一个高度可扩展的RESTful API公开了我们的社交投票解决方案的数据，并构建了一个简单的网站，该网站消费API以提供一种直观的方式供用户与之交互。该网站仅包含静态内容，没有服务器端处理（因为API为我们做了繁重的工作）。这使得我们能够在静态托管网站上以非常低廉的成本托管网站，例如[bitballoon.com](https://www.bitballoon.com/)，或者将文件分发到内容分发网络。
- en: Within our API service, we learned how to share data between handlers without
    breaking or obfuscating the handler pattern from the standard library. We also
    saw how writing wrapped handler functions allows us to build a pipeline of functionality
    in a very simple and intuitive way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的API服务中，我们学习了如何在不会破坏或混淆标准库中的处理程序模式的情况下在处理程序之间共享数据。我们还看到了如何编写包装处理程序函数，这允许我们以非常简单直观的方式构建功能管道。
- en: We wrote some basic encoding and decoding functions that –while only simply
    wrapping their counterparts from the `encoding/json` package for now –could be
    improved later to support a range of different data representations without changing
    the internal interface to our code. We wrote a few simple helper functions that
    make responding to data requests easy while providing the same kind of abstraction
    that would allow us to evolve our API later.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一些基本的编码和解码函数，虽然目前它们只是简单地包装了`encoding/json`包中的对应函数，但以后可以改进以支持一系列不同的数据表示，而不必更改我们代码的内部接口。我们还编写了一些简单的辅助函数，使响应数据请求变得容易，同时提供允许我们以后演进API的相同类型的抽象。
- en: We saw how, for simple cases, switching to HTTP methods is an elegant way to
    support many functions for a single endpoint. We also saw how, with a few extra
    lines of code, we are able to build support for CORS in order to allow applications
    running on different domains to interact with our services –without the need for
    hacks such as JSONP.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在简单情况下，切换到HTTP方法是如何以一种优雅的方式支持单个端点上的许多功能。我们也看到了通过添加几行额外的代码，我们能够构建对CORS的支持，以便允许运行在不同域上的应用程序与我们的服务交互——无需使用诸如JSONP之类的黑客手段。
- en: In the next chapter, we will evolve our API and web skills to build a brand
    new startup app called Meander. We'll also explore an interesting way of representing
    enumerators in a language that doesn't officially support them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将演进我们的API和Web技能，以构建一个全新的创业应用，名为Meander。我们还将探索一种在官方不支持枚举器的语言中表示枚举器的方法。
