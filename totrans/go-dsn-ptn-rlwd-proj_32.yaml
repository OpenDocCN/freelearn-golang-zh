- en: Index page showing a list of polls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `public` folder inside `web` and add the `index.html` file after
    writing the following HTML code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use Bootstrap again to make our simple UI look nice, but we need to
    add two additional sections to the `body` tag of the HTML page. First, add the
    DOM elements that will display the list of polls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using Bootstrap's grid system to center-align our content that
    is made up of a list of polls and a link to `new.html`, where users can create
    new polls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following `script` tags and JavaScript underneath that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are using jQuery's `$.get` function to make an AJAX request to our web service.
    We are hardcoding the API URL –which, in practice, you might decide against –or
    at least use a domain name to abstract it. Once the polls have loaded, we use
    jQuery to build up a list containing hyperlinks to the `view.html` page, passing
    the ID of the poll as a query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new poll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow users to create a new poll, create a file called `new.html` inside
    the `public` folder, and add the following HTML code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to add the elements for an HTML form that will capture the information
    we need when creating a new poll, namely the title of the poll and the options.
    Add the following code inside the `body` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our API speaks JSON, we need to do a bit of work to turn the HTML form
    into a JSON-encoded string and also break the comma-separated options string into
    an array of options. Add the following `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a listener to the `submit` event of our form and use jQuery's `val`
    method to collect the input values. We split the options with a comma and trim
    the spaces away before using the `$.post` method to make the `POST` request to
    the appropriate API endpoint. `JSON.stringify` allows us to turn the data object
    into a JSON string, and we use that string as the body of the request, as expected
    by the API. On success, we pull out the `Location` header and redirect the user
    to the `view.html` page, passing a reference to the newly created poll as the
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the details of a poll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final page of our app we need to complete is the `view.html` page, where
    users can see the details and live results of the poll. Create a new file called
    `view.html` inside the `public` folder and add the following HTML code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This page is mostly similar to the other pages; it contains elements to present
    the title of the poll, the options, and a pie chart. We will be mashing up Google''s
    Visualization API with our API to present the results. Underneath the final `div`
    tag in `view.html` (and above the closing `body` tag), add the following `script`
    tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We include the dependencies we will need in order to power our page, jQuery
    and Bootstrap, and also the Google JavaScript API. The code loads the appropriate
    visualization libraries from Google and waits for the DOM elements to load before
    extracting the poll ID from the URL by splitting it on `poll=`. We then create
    a variable called `update` that represents a function responsible for generating
    the view of the page. This approach is taken to make it easy for us to use `window.setTimeout`
    in order to issue regular calls to update the view. Inside the `update` function,
    we use `$.get` to make a `GET` request to our `/polls/{id}` endpoint, replacing
    `{id}` with the actual ID we extracted from the URL earlier. Once the poll has
    loaded, we update the title on the page and iterate over the options to add them
    to the list. If there are results (remember, in the previous chapter, the `results`
    map was only added to the data as votes started being counted), we create a new
    `google.visualization.PieChart` object and build a `google.visualization.DataTable`
    object containing the results. Calling `draw` on the chart causes it to render
    the data and thus update the chart with the latest numbers. We then use `setTimeout`
    to tell our code to call `update` again in another second.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we bind to the `click` event of the `delete` button we added to our
    page, and after asking the user whether they are sure, make a `DELETE` request
    to the polls URL and then redirect them back to the home page. It is this request
    that will actually cause the `OPTIONS` request to be made first, asking for permission,
    which is why we added explicit support for it in our `handlePolls` function earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Running the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built many components over the previous two chapters, and it is now time
    to see them all working together. This section contains everything you need in
    order to get all the items running, assuming you have the environment set up properly,
    as described at the beginning of the previous chapter. This section assumes you
    have a single folder that contains the four subfolders: `api`, `counter`, `twittervotes`,
    and `web`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming nothing is running, take the following steps (each step in its own
    terminal window):'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top-level folder, start the `nsqlookupd` daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same directory, start the `nsqd` daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the MongoDB daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the `counter` folder and build and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the `twittervotes` folder and build and run it. Ensure that you
    have the appropriate environment variables set; otherwise, you will see errors
    when you run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the `api` folder and build and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the `web` folder and build and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that everything is running, open a browser and head to `http://localhost:8081/`.
    Using the user interface, create a poll called `Moods` and input the options as
    `happy,sad,fail,success`. These are common enough words that we are likely to
    see some relevant activity on Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your poll, you will be taken to the view page where you
    will start to see the results coming in. Wait for a few seconds and enjoy the
    fruits of your hard work as the UI updates in real time, showing live, real-time
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the solution](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we exposed the data for our social polling solution through
    a highly scalable RESTful API and built a simple website that consumes the API
    to provide an intuitive way for users to interact with it. The website consists
    of static content only, with no server-side processing (since the API does the
    heavy lifting for us). This allows us to host the website very cheaply on static
    hosting sites, such as [bitballoon.com](https://www.bitballoon.com/), or distribute
    the files to content delivery networks.
  prefs: []
  type: TYPE_NORMAL
- en: Within our API service, we learned how to share data between handlers without
    breaking or obfuscating the handler pattern from the standard library. We also
    saw how writing wrapped handler functions allows us to build a pipeline of functionality
    in a very simple and intuitive way.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote some basic encoding and decoding functions that –while only simply
    wrapping their counterparts from the `encoding/json` package for now –could be
    improved later to support a range of different data representations without changing
    the internal interface to our code. We wrote a few simple helper functions that
    make responding to data requests easy while providing the same kind of abstraction
    that would allow us to evolve our API later.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how, for simple cases, switching to HTTP methods is an elegant way to
    support many functions for a single endpoint. We also saw how, with a few extra
    lines of code, we are able to build support for CORS in order to allow applications
    running on different domains to interact with our services –without the need for
    hacks such as JSONP.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will evolve our API and web skills to build a brand
    new startup app called Meander. We'll also explore an interesting way of representing
    enumerators in a language that doesn't officially support them.
  prefs: []
  type: TYPE_NORMAL
