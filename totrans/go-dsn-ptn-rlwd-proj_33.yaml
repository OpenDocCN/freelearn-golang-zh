- en: Chapter 7.  Random Recommendations Web Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept behind the project that we will build in this chapter is a simple
    one: we want users to be able to generate random recommendations for things to
    do in specific geographical locations based on a predefined set of journey types
    that we will expose through the API. We will give our project the codename Meander.'
  prefs: []
  type: TYPE_NORMAL
- en: Often on projects in the real world, you are not responsible for the full stack;
    somebody else builds the website, a different person might write the iOS app,
    and maybe an outsourced company builds the desktop version. On more successful
    API projects, you might not even know who the consumers of your API are, especially
    if it's a public API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will simulate this reality by designing and agreeing a minimal
    API design with a fictional partner up front before going on to implement the
    API. Once we have finished our side of the project, we will download a user interface
    built by our teammates to see the two work together to produce the final application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to express the general goals of a project using short and simple Agile
    user stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover that you can agree on a meeting point in a project by agreeing on the
    design of an API, which allows many people to work in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how early versions can have data fixtures written in code and compiled into
    the program, allowing us to change the implementation later without touching the
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn a strategy that allows structs (and other types) to represent a public
    version of themselves for cases where we want to hide or transform internal representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to use embedded structs to represent nested data while keeping the interface
    of our types simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to use `http.Get` to make external API requests, specifically to the Google
    Places API, with no code bloat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to effectively implement enumerators in Go even though they aren't really
    a language feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experience a real-world example of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at how the `math/rand` package makes it easy to select an item from a slice
    at random
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn an easy way to grab data from the URL parameters of the `http.Request`
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following Agile methodologies, let's write two user stories that describe the
    functionality of our project. User stories shouldn't be comprehensive documents
    describing the entire set of features of an application; rather, small cards are
    perfect for not only describing what the user is trying to do, but also why. Also,
    we should do this without trying to design the whole system up front or delving
    too deep into implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a story about seeing the different journey types from which
    our users can select:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **As a** | **traveler** |'
  prefs: []
  type: TYPE_TB
- en: '| **I want** | to see the different types of journeys I can get recommendations
    for |'
  prefs: []
  type: TYPE_TB
- en: '| **So that** | I can decide what kind of evening to take my partner on |'
  prefs: []
  type: TYPE_TB
- en: 'Secondly, we need a story about providing random recommendations for a selected
    journey type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **As a** | **traveler** |'
  prefs: []
  type: TYPE_TB
- en: '| **I want** | to see a random recommendation for my selected journey type
    |'
  prefs: []
  type: TYPE_TB
- en: '| **So that** | I know where to go and what the evening will entail |'
  prefs: []
  type: TYPE_TB
- en: These two stories represent the two core capabilities that our API needs to
    provide and actually ends up representing two endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In order to discover places around specified locations, we are going to make
    use of the Google Places API, which allows us to search for listings of businesses
    with given types, such as `bar`, `cafe`, or `movie_theater`. We will then use
    Go's `math/rand` package to pick from these places at random, building up a complete
    journey for our users.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Google Places API supports many business types; refer to [https://developers.google.com/places/documentation/supported_types](https://developers.google.com/places/documentation/supported_types)
    for the complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Project design specifics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to turn our stories into an interactive application, we are going
    to provide two JSON endpoints: one to deliver the kinds of journeys users will
    be able to select in the application and another to actually generate the random
    recommendations for the selected journey type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding call should return a list similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` field is a human-readable label for the type of recommendations
    the app generates, and the `journey` field is a pipe-separated list of the supported
    journey types. It is the journey value that we will pass, as a URL parameter,
    into our other endpoint, which generates the actual recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This endpoint is responsible for querying the Google Places API and generating
    the recommendations before returning an array of place objects. We will use the
    parameters in the URL to control the kind of query to make. The `lat` and `lng`
    parameters representing latitude and longitude, respectively tell our API where
    in the world we want recommendations from, and the `radius` parameter represents
    the distance in meters around the point in which we are interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cost` value is a human-readable way of representing the price range for
    places that the API returns. It is made up of two values: a lower and upper range
    separated by three dots. The number of dollar characters represents the price
    level, with `$` being the most affordable and `$$$$$` being the most expensive.
    Using this pattern, a value of `$...$$` would represent very low-cost recommendations,
    where `$$$$...$$$$$` would represent a pretty expensive experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some programmers might insist that the cost range is represented by numerical
    values, but since our API is going to be consumed by people, why not make things
    a little more interesting? It is up to you as the API designer.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example payload for this call might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The array returned contains a place object representing a random recommendation
    for each segment in the journey in the appropriate order. The preceding example
    is a cafe in London. The data fields are fairly self-explanatory; the `lat` and
    `lng` fields represent the location of the place, the `name` and `vicinity` fields
    tell us what and where the business is, and the `photos` array gives us a list
    of relevant photographs from Google's servers. The `vicinity` and `icon` fields
    will help us deliver a richer experience to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Representing data in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are first going to expose the journeys that users can select from; so, create
    a new folder called `meander` in `GOPATH` and add the following `journeys.go`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define an internal type called `j` inside the `meander` package, which
    we then use to describe the journeys by creating instances of them inside the
    `Journeys` slice. This approach is an ultra-simple way of representing data in
    the code without building a dependency on an external data store.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an additional assignment, why not see if you can keep `golint` happy throughout
    this process? Every time you add some code, run `golint` for the packages and
    satisfy any suggestions that emerge. It cares a lot about exported items that
    have no documentation; so adding simple comments in the correct format will keep
    it happy. To learn more about `golint`, refer to [https://github.com/golang/lint](https://github.com/golang/lint).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is likely to evolve into just that later, maybe even with the
    ability for users to create and share their own journeys. Since we are exposing
    our data via an API, we are free to change the internal implementation without
    affecting the interface, so this approach is great for a version 1.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a slice of type `[]interface{}` because we will later implement
    a general way of exposing public data regardless of the actual types.
  prefs: []
  type: TYPE_NORMAL
- en: A romantic journey consists of a visit first to a park, then a bar, a movie
    theater, then a restaurant before a visit to a florist, and finally, a taxi ride
    home; you get the general idea. Feel free to get creative and add others by consulting
    the supported types in the Google Places API.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that since we are containing our code inside a package
    called `meander` (rather than `main`), our code can never be run as a tool like
    the other APIs we have written so far. Create two new folders inside meander so
    that you have a path that looks like `meander/cmd/meander`; this will house the
    actual command-line tool that exposes the `meander` package's capabilities via
    an HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are primarily building a package for our meandering project (something
    that other tools can import and make use of), the code in the root folder is the
    `meander` package, and we nest our command (the `main` package) inside the `cmd`
    folder. We include the additional final `meander` folder to follow good practices
    where the command name is the same as the folder if we omitted it, our command
    would be called `cmd` instead of `meander`, which would get confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `cmd/meander` folder, add the following code to the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will recognize this as a simple API endpoint program, mapping to the `/journeys`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll have to import the `encoding/json`, `net/http`, and `runtime` packages,
    along with your own `meander` package you created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We set the value of `APIKey` in the `meander` package (which is commented out
    for now, since we are yet to implement it) before calling the familiar `HandleFunc`
    function on the `net/http` package to bind our endpoint, which then just responds
    with the `meander.Journeys` variable. We borrow the abstract responding concept
    from the previous chapter by providing a `respond` function that encodes the specified
    data to the `http.ResponseWriter` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our API program by navigating to the `cmd/meander` folder in a terminal
    and using `go run`. We don''t need to build this into an executable file at this
    stage since it''s just a single file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit the `http://localhost:8080/journeys` endpoint, and note that our `Journeys`
    data payload is served, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly acceptable, but there is one major flaw: it exposes internals
    about our implementation. If we changed the `PlaceTypes` field name to `Types`,
    promises made in our API would break, and it''s important that we avoid this.'
  prefs: []
  type: TYPE_NORMAL
- en: Projects evolve and change over time, especially successful ones, and as developers,
    we should do what we can to protect our customers from the impact of the evolution.
    Abstracting interfaces is a great way to do this, as is taking ownership of the
    public-facing view of our data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Public views of Go structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to control the public view of structs in Go, we need to invent a way
    to allow individual `journey` types to tell us how they want to be exposed. In
    the root `meander` folder, create a new file called `public.go` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Facade` interface exposes a single `Public` method, which will return the
    public view of a struct. The exported `Public` function takes any object and checks
    whether it implements the `Facade` interface (does it have a `Public() interface{}`
    method?); if it is implemented, it calls the method and returns the result otherwise,
    it just returns the original object untouched. This allows us to pass anything
    through the `Public` function before writing the result to the `ResponseWriter`
    object, allowing individual structs to control their public appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, single method interfaces such as our `Facade` are named after the
    method they describe, such as `Reader` and `Writer`. However, `Publicer` is just
    confusing, so I deliberately broke the rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a `Public` method for our `j` type by adding the following
    code to `journeys.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The public view of our `j` type joins the `PlaceTypes` field into a single string
    separated by the pipe character as per our API design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to `cmd/meander/main.go` and replace the `respond` method with one
    that makes use of our new `Public` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we iterate over the data slice calling the `meander.Public` function
    for each item, building the results into a new slice of the same size. In the
    case of our `j` type, its `Public` method will be called to serve the public view
    of the data rather than the default view. In a terminal, navigate to the `cmd/meander`
    folder again and run `go run main.go` before hitting `http://localhost:8080/journeys`.
    Note that the same data has now changed to a new structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative way of achieving the same result would be to use tags to control
    the field names, as we have done in previous chapters, and implement your own
    `[]string` type that provides a `MarshalJSON` method which tells the encoder how
    to marshal your type. Both are perfectly acceptable, but the `Facade` interface
    and `Public` method are probably more expressive (if someone reads the code, isn't
    it obvious what's going on?) and give us more control.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to obtain the places from which our code will randomly build up recommendations,
    we need to query the Google Places API. In the root `meander` folder, add the
    following `query.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code defines the structures we will need in order to parse the JSON response
    from the Google Places API into usable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Head over to the Google Places API documentation for an example of the response
    we are expecting. Refer to [http://developers.google.com/places/documentation/search](http://developers.google.com/places/documentation/search).
  prefs: []
  type: TYPE_NORMAL
- en: Most of the preceding code will be obvious, but it's worth noting that the `Place`
    type embeds the `googleGeometry` type, which allows us to represent the nested
    data as per the API while essentially flattening it in our code. We do this with
    `googleLocation` inside `googleGeometry`, which means that we will be able to
    access the `Lat` and `Lng` values directly on a `Place` object even though they're
    technically nested in other structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to control how a `Place` object appears publically, let''s
    give this type the following `Public` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to run `golint` on this code to see which comments need to be added
    to the exported items.
  prefs: []
  type: TYPE_NORMAL
- en: The Google Places API key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like with most APIs, we will need an API key in order to access the remote services.
    Head over to the Google APIs Console, sign in with a Google account, and create
    a key for the Google Places API. For more detailed instructions, refer to the
    documentation on the Google's developer website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your key, let''s create a variable inside the `meander` package
    that can hold it. At the top of `query.go`, add the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now nip back into `main.go`, remove the double slash `//` from the `APIKey`
    line, and replace the `TODO` value with the actual key provided by the Google
    APIs Console. Remember that it is bad practice to hardcode keys like this directly
    in your code; instead, it's worth breaking them out into environment variables,
    which keeps them out of your source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerators in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle the various cost ranges for our API, it makes sense to use an enumerator
    (or **enum**) to denote the various values and handle conversions to and from
    string representations. Go doesn't explicitly provide enumerators as a language
    feature, but there is a neat way of implementing them, which we will explore in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple flexible checklist to write enumerators in Go is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a new type based on a primitive integer type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use that type whenever you need users to specify one of the appropriate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `iota` keyword to set the values in a `const` block, disregarding the
    first zero value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a map of sensible string representations to the values of your enumerator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `String` method on the type that returns the appropriate string
    representation from the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `ParseType` function that converts from a string to your type using
    the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will write an enumerator to represent the cost levels in our API. Create
    a new file called `cost_level.go` inside the root `meander` folder and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the type of our enumerator, which we have called `Cost`, and
    since we need to represent a only few values, we have based it on an `int8` range.
    For enumerators where we need larger values, you are free to use any of the integer
    types that work with `iota`. The `Cost` type is now a real type in its own right,
    and we can use it wherever we need to represent one of the supported values for
    example, we can specify a `Cost` type as an argument in functions, or we can use
    it as the type for a field in a struct.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a list of constants of that type and use the `iota` keyword to
    indicate that we want incrementing values for the constants. By disregarding the
    first `iota` value (which is always zero), we indicate that one of the specified
    constants must be explicitly used rather than the zero value.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a string representation of our enumerator, we only need to add a
    `String` method to the `Cost` type. This is a useful exercise even if you don't
    need to use the strings in your code, because whenever you use the print calls
    from the Go standard library (such as `fmt.Println`), the numerical values will
    be used by default. Often, these values are meaningless and will require you to
    look them up and even count the lines to determine the numerical value for each
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the `String()` method in Go, refer to the `Stringer`
    and `GoStringer` interfaces in the `fmt` package at [http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer).
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven enumerator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure that our enumerator code is working correctly, we are going to write
    unit tests that make some assertions about expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside `cost_level.go`, add a new file called `cost_level_test.go` and add
    the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You will need to run `go get` in order to get the CheekyBits `is` package (from
    [https://github.com/cheekybits/is](https://github.com/cheekybits/is)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `is` package is an alternative testing helper package, but this one is ultra-simple
    and deliberately bare-bones. You get to pick your favorite when you write your
    own projects or use none at all.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we wouldn't worry about the actual integer value of constants in our
    enumerator, but since the Google Places API uses numerical values to represent
    the same thing, we need to care about the values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed something strange about this test file that breaks from
    convention. Although it is inside the root `meander` folder, it is not a part
    of the `meander` package; rather, it's in `meander_test`.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, this is an error in every case except for tests. Because we are putting
    our test code into its own package, it means that we no longer have access to
    the internals of the `meander` package. Note how we have to use the package prefix.
    This may seem like a disadvantage, but in fact, it allows us to be sure that we
    are testing the package as though we were a real user of it. We may only call
    exported methods and only have visibility into exported types; just like our users.
    And we cannot mess around with internals to do things that our users cannot; it's
    a true user test. In testing, sometimes you do need to fiddle with an internal
    state, in which case your tests would need to be in the same package as the code
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests by running `go test` in a terminal and note that it passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to make assertions about the string representations
    for each `Cost` constant. In `cost_level_test.go`, add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This test asserts that calling the `String` method for each constant yields
    the expected value. Running these tests will, of course, fail because we haven't
    implemented the `String` method yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `Cost` constants, add the following map and the `String` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `map[string]Cost` variable maps the cost values to the string representation,
    and the `String` method iterates over the map to return the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our case, a simple `strings.Repeat("$", int(l))` return would work just as
    well (and wins because it's simpler code); but it often won't; therefore, this
    section explores the general approach.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we were to print out the `Cost3` value, we would actually see `$$$`,
    which is much more useful than numerical values. As we want to use these strings
    in our API, we are also going to add a `ParseCost` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `cost_value_test.go`, add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assert that calling `ParseCost` will, in fact, yield the appropriate
    value depending on the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `cost_value.go`, add the following implementation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Parsing a `Cost` string is very simple since this is how our map is laid out.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we need to represent a range of cost values, let''s imagine a `CostRange`
    type and write the tests out for how we intend to use it. Add the following tests
    to `cost_value_test.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We specify that passing in a string with two dollar characters first, followed
    by three dots and then three dollar characters should create a new `meander.CostRange`
    type that has `From` set to `meander.Cost2` and `To` set to `meander.Cost3`. We
    also use `is.NoErr` in order to assert that no error is returned when we parse
    our strings. The second test does the reverse by testing that the `CostRange.String`
    method, which returns the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our tests pass, add the following `CostRange` type and the associated
    `String` and `ParseString` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to convert a string such as `$...$$$$$` to a structure that
    contains two `Cost` values: a `From` and `To` set and vice versa. If somebody
    passes in an invalid cost range (we just perform a simple check on the number
    of segments after splitting on the dots), then we return an error. You can do
    additional checking here if you want to, such as ensuring only dots and dollar
    signs are mentioned in the strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the Google Places API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are capable of representing the results of the API, we need a way
    to represent and initiate the actual query. Add the following structure to `query.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure contains all the information we will need in order to build
    up the query, all of which will actually come from the URL parameters in the requests
    from the client. Next, add the following `find` method, which will be responsible
    for making the actual request to Google''s servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First, we build the request URL as per the Google Places API specification by
    appending the `url.Values` encoded string of the data for `lat`, `lng`, `radius`,
    and, of course, the `APIKey` values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `url.Values` type is actually a `map[string][]string` type, which is why
    we use `make` rather than `new`.
  prefs: []
  type: TYPE_NORMAL
- en: The `types` value we specify as an argument represents the kind of business
    to look for. If there is `CostRangeStr`, we parse it and set the `minprice` and
    `maxprice` values before finally calling `http.Get` to actually make the request.
    If the request is successful, we defer the closing of the response body and use
    a `json.Decoder` method to decode the JSON that comes back from the API into our
    `googleResponse` type.
  prefs: []
  type: TYPE_NORMAL
- en: Building recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to write a method that will allow us to make many calls to find
    for the different steps in a journey. Underneath the `find` method, add the following
    `Run` method to the `Query` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is set the random seed to the current time in nanoseconds
    since January 1, 1970 UTC. This ensures that every time we call the `Run` method
    and use the `rand` package, the results will be different. If we don't do this,
    our code would suggest the same recommendations every time, which defeats the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Since we need to make many requests to Google and since we want to make sure
    this is as quick as possible we are going to run all the queries at the same time
    by making concurrent calls to our `Query.find` method. So next, we create `sync.WaitGroup` and
    a map to hold the selected places along with a `sync.Mutex` method to allow many
    goroutines to safely access the map concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate over each item in the `Journey` slice, which might be `bar`,
    `cafe`, or `movie_theater`. For each item, we add `1` to the `WaitGroup` object
    and start a goroutine. Inside the routine, we first defer the `w.Done` call, informing
    the `WaitGroup` object that this request has completed before calling our `find`
    method to make the actual request. Assuming no errors occurred and it was indeed
    able to find some places, we iterate over the results and build up a usable URL
    for any photos that might be present. According to the Google Places API, we are
    given a `photoreference` key, which we can use in another API call to get the
    actual image. To save our clients from having to have knowledge of the Google
    Places API at all, we build the complete URL for them.
  prefs: []
  type: TYPE_NORMAL
- en: We then lock the map locker and with a call to `rand.Intn`, pick one of the
    options at random and insert it into the right position in the `places` slice
    before unlocking `sync.Mutex`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wait for all goroutines to complete with a call to `w.Wait` before
    returning the places.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers that use query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to wire up our `/recommendations` call, so head back to `main.go`
    in the `cmd/meander` folder and add the following code inside the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This handler is responsible for preparing the `meander.Query` object and calling
    its `Run` method before responding with the results. The `http.Request` type's
    URL value exposes the `Query` data that provides a `Get` method which, in turn,
    looks up a value for a given key.
  prefs: []
  type: TYPE_NORMAL
- en: The journey string is translated from the `bar|cafe|movie_theater` format to
    a slice of strings by splitting on the pipe character. Then, a few calls to functions
    in the `strconv` package turn the string latitude, longitude, and radius values
    into numerical types. If the values are in an incorrect format, we will get an
    error, which we will then write out to the client using the `http.Error` helper
    with an `http.StatusBadRequest` status.
  prefs: []
  type: TYPE_NORMAL
- en: CORS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final piece of the first version of our API will be to implement CORS, as
    we did in the previous chapter. See if you can solve this problem yourself before
    reading on about the solution in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to tackle this yourself, remember that your aim is to set the
    `Access-Control-Allow-Origin` response header to `*`. Also, consider the `http.HandlerFunc`
    wrapping we did in the previous chapter. The best place for this code is probably
    in the `cmd/meander` program, since that is what exposes the functionality through
    an HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.go`, add the following `cors` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This familiar pattern takes in an `http.HandlerFunc` type and returns a new
    one that sets the appropriate header before calling the passed-in function. Now,
    we can modify our code to make sure that the `cors` function gets called for both
    of our endpoints. Update the appropriate lines in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, calls to our API will be allowed from any domain without a cross-origin
    error occurring.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can you see a way to smarten up the code by removing the multiple calls to `r.URL.Query()`?
    Perhaps do this once and cache the result in a local variable. Then, you can avoid
    parsing the query many times.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are ready to test our API, head to a console and navigate to the
    `cmd/meander` folder. Because our program imports the `meander` package, building
    the program will automatically build our `meander` package too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To see meaningful results from our API, let's take a minute to find your actual
    latitude and longitude. Head over to [http://mygeoposition.com/](http://mygeoposition.com/)
    and use the web tools to get the `x,y` values for a location you are familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, pick from these popular cities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'London, England: `51.520707 x 0.153809`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New York, USA: `40.7127840 x -74.0059410`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tokyo, Japan: `35.6894870 x 139.6917060`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'San Francisco, USA: `37.7749290 x -122.4194160`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, open a web browser and access the `/recommendations` endpoint with some
    appropriate values for the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what a sample recommendation around London might
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our API](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to play around with the values in the URL to see how powerful the
    simple API is by trying various journey strings, tweaking the locations, and trying
    different cost range value strings.
  prefs: []
  type: TYPE_NORMAL
- en: Web application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to download a complete web application built to the same API specifications
    and point it at our implementation to see it come to life before our eyes. Head
    over to [https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb](https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb)
    and download the `meanderweb` project into your `GOPATH` folder (alongside your
    root meander folder will do).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, navigate to the `meanderweb` folder and build and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will start a website running on `localhost:8081`, which is hardcoded to
    look for the API running at `localhost:8080`. Because we added the CORS support,
    this won't be a problem despite them running on different domains.
  prefs: []
  type: TYPE_NORMAL
- en: Open a browser to `http://localhost:8081/` and interact with the application;
    while somebody else built the UI, it would be pretty useless without the API that
    we built in order to power it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an API that consumes and abstracts the Google Places
    API to provide a fun and interesting way of letting users plan their days and
    evenings.
  prefs: []
  type: TYPE_NORMAL
- en: We started by writing some simple and short user stories that described what
    we wanted to achieve at a really high level without trying to design the implementation
    up front. In order to parallelize the project, we agreed upon the meeting point
    of the project as the API design, and we built toward it (as would our partners).
  prefs: []
  type: TYPE_NORMAL
- en: We embedded data directly in the code, avoiding the need to investigate, design,
    and implement a data store in the early stages of a project. By caring about how
    that data is accessed (via the API endpoint) instead, we allowed our future selves
    to completely change how and where the data is stored without breaking any apps
    that have been written with our API.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the `Facade` interface, which allows our structs and other types
    to provide public representations of them without revealing messy or sensitive
    details about our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Our foray into enumerators gave us a useful starting point to build enumerated
    types, even though there is no official support for them in the language. The
    `iota` keyword that we used lets us specify constants of our own numerical type,
    with incrementing values. The common `String` method that we implemented showed
    us how to make sure that our enumerated types don't become obscure numbers in
    our logs. At the same time, we also saw a real-world example of TDD and red/green
    programming, where we wrote unit tests that first fail but which we then go on
    to make pass by writing the implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a break from web services in order
    to build a backup tool for our code, where we'll explore how easy Go makes it
    for us to interact with the local filesystem.
  prefs: []
  type: TYPE_NORMAL
