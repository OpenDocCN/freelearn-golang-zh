- en: Chapter 7.  Random Recommendations Web Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 随机推荐网络服务
- en: 'The concept behind the project that we will build in this chapter is a simple
    one: we want users to be able to generate random recommendations for things to
    do in specific geographical locations based on a predefined set of journey types
    that we will expose through the API. We will give our project the codename Meander.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将要构建的项目背后的概念很简单：我们希望用户能够根据我们通过API公开的预定义旅程类型生成特定地理位置的随机活动推荐。我们将给我们的项目取名为Meander。
- en: Often on projects in the real world, you are not responsible for the full stack;
    somebody else builds the website, a different person might write the iOS app,
    and maybe an outsourced company builds the desktop version. On more successful
    API projects, you might not even know who the consumers of your API are, especially
    if it's a public API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的项目中，你通常不负责整个栈；有人可能构建了网站，另一个人可能编写了iOS应用程序，也许外包公司构建了桌面版本。在更成功的API项目中，你可能甚至不知道你的API的消费者是谁，尤其是如果它是一个公开API的话。
- en: In this chapter, we will simulate this reality by designing and agreeing a minimal
    API design with a fictional partner up front before going on to implement the
    API. Once we have finished our side of the project, we will download a user interface
    built by our teammates to see the two work together to produce the final application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在实施API之前，通过与一个虚构的合作伙伴设计和同意一个最小API设计来模拟这种现实。一旦我们完成了我们这一部分的项目，我们将下载我们的队友构建的用户界面，以查看两者如何协同工作以产生最终的应用程序。
- en: 'In this chapter, you will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Learn to express the general goals of a project using short and simple Agile
    user stories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用简短和简单的敏捷用户故事来表达项目的总体目标
- en: Discover that you can agree on a meeting point in a project by agreeing on the
    design of an API, which allows many people to work in parallel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现你可以在通过API设计达成一致的基础上在项目中达成一个会议点，这允许许多人并行工作
- en: See how early versions can have data fixtures written in code and compiled into
    the program, allowing us to change the implementation later without touching the
    interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看早期版本可以如何将数据固定写入代码并编译到程序中，这样我们可以在不触及接口的情况下稍后更改实现
- en: Learn a strategy that allows structs (and other types) to represent a public
    version of themselves for cases where we want to hide or transform internal representations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一种策略，允许struct（和其他类型）在需要隐藏或转换内部表示的情况下表示自己的公共版本
- en: Learn to use embedded structs to represent nested data while keeping the interface
    of our types simple
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用内嵌struct来表示嵌套数据，同时保持我们类型接口的简单性
- en: Learn to use `http.Get` to make external API requests, specifically to the Google
    Places API, with no code bloat
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`http.Get`来发起外部API请求，特别是对Google Places API的请求，而不产生代码膨胀
- en: Learn to effectively implement enumerators in Go even though they aren't really
    a language feature
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在Go中有效地实现枚举器，即使它们并不是真正的语言特性
- en: Experience a real-world example of TDD
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经历一个真实的TDD（测试驱动开发）示例
- en: Look at how the `math/rand` package makes it easy to select an item from a slice
    at random
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看`math/rand`包如何使从切片中随机选择一个项目变得容易
- en: Learn an easy way to grab data from the URL parameters of the `http.Request`
    type
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一种简单的方法来从`http.Request`类型的URL参数中抓取数据
- en: The project overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Following Agile methodologies, let's write two user stories that describe the
    functionality of our project. User stories shouldn't be comprehensive documents
    describing the entire set of features of an application; rather, small cards are
    perfect for not only describing what the user is trying to do, but also why. Also,
    we should do this without trying to design the whole system up front or delving
    too deep into implementation details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照敏捷方法论，让我们编写两个用户故事来描述我们项目的功能。用户故事不应该是不完整的文档，描述应用程序的全部功能集；相反，小卡片非常适合不仅描述用户试图做什么，还为什么这样做。此外，我们应该在不试图一开始就设计整个系统或深入实现细节的情况下完成这项工作。
- en: 'First, we need a story about seeing the different journey types from which
    our users can select:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个关于查看用户可以从中选择的不同旅程类型的故事：
- en: '| **As a** | **traveler** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **作为** | **旅行者** |'
- en: '| **I want** | to see the different types of journeys I can get recommendations
    for |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **我想** | 看看我可以获得推荐的不同旅程类型'
- en: '| **So that** | I can decide what kind of evening to take my partner on |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **为了** | 我可以决定带我的伴侣去哪种晚上的活动'
- en: 'Secondly, we need a story about providing random recommendations for a selected
    journey type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要一个关于为选定的旅行类型提供随机推荐的故事：
- en: '| **As a** | **traveler** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **作为一个** | **旅行者** |'
- en: '| **I want** | to see a random recommendation for my selected journey type
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **我想** | 看到我选择的旅行类型的随机推荐 |'
- en: '| **So that** | I know where to go and what the evening will entail |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **以便** | 我知道去哪里以及晚上将有什么活动 |'
- en: These two stories represent the two core capabilities that our API needs to
    provide and actually ends up representing two endpoints.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个故事代表了我们的API需要提供的两个核心功能，并且最终代表了两个端点。
- en: In order to discover places around specified locations, we are going to make
    use of the Google Places API, which allows us to search for listings of businesses
    with given types, such as `bar`, `cafe`, or `movie_theater`. We will then use
    Go's `math/rand` package to pick from these places at random, building up a complete
    journey for our users.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现指定地点周围的地方，我们将利用Google Places API，它允许我们搜索具有给定类型（如`bar`、`cafe`或`movie_theater`）的商家列表。然后我们将使用Go的`math/rand`包从这些地点中随机选择，为我们的用户提供完整的旅程。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Google Places API supports many business types; refer to [https://developers.google.com/places/documentation/supported_types](https://developers.google.com/places/documentation/supported_types)
    for the complete list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Google Places API支持许多商业类型；有关完整列表，请参阅[https://developers.google.com/places/documentation/supported_types](https://developers.google.com/places/documentation/supported_types)。
- en: Project design specifics
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设计具体细节
- en: 'In order to turn our stories into an interactive application, we are going
    to provide two JSON endpoints: one to deliver the kinds of journeys users will
    be able to select in the application and another to actually generate the random
    recommendations for the selected journey type.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的故事变成一个交互式应用程序，我们将提供两个JSON端点：一个用于提供用户可以在应用程序中选择的旅行类型，另一个用于为选定的旅行类型生成随机推荐。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding call should return a list similar to the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用应该返回一个类似于以下列表的结果：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `name` field is a human-readable label for the type of recommendations
    the app generates, and the `journey` field is a pipe-separated list of the supported
    journey types. It is the journey value that we will pass, as a URL parameter,
    into our other endpoint, which generates the actual recommendations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`字段是应用程序生成的推荐类型的可读标签，而`journey`字段是支持旅行类型的管道分隔列表。我们将作为URL参数传递的旅行值传递给我们的另一个端点，该端点生成实际的推荐：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This endpoint is responsible for querying the Google Places API and generating
    the recommendations before returning an array of place objects. We will use the
    parameters in the URL to control the kind of query to make. The `lat` and `lng`
    parameters representing latitude and longitude, respectively tell our API where
    in the world we want recommendations from, and the `radius` parameter represents
    the distance in meters around the point in which we are interested.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点负责查询Google Places API并在返回地点对象数组之前生成推荐。我们将使用URL中的参数来控制要进行的查询类型。`lat`和`lng`参数分别表示纬度和经度，告诉我们的API我们希望从世界的哪个地方获取推荐，而`radius`参数表示我们感兴趣的点的周围距离（以米为单位）。
- en: 'The `cost` value is a human-readable way of representing the price range for
    places that the API returns. It is made up of two values: a lower and upper range
    separated by three dots. The number of dollar characters represents the price
    level, with `$` being the most affordable and `$$$$$` being the most expensive.
    Using this pattern, a value of `$...$$` would represent very low-cost recommendations,
    where `$$$$...$$$$$` would represent a pretty expensive experience.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`cost`值是以人类可读的方式表示API返回的地点的价格范围。它由两个值组成：一个下限和一个上限，由三个点分隔。美元字符的数量表示价格水平，其中`$`是最便宜的，而`$$$$$`是最贵的。使用这种模式，`$...$$`表示非常低成本的推荐，而`$$$$...$$$$$`则表示相当昂贵的体验。'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some programmers might insist that the cost range is represented by numerical
    values, but since our API is going to be consumed by people, why not make things
    a little more interesting? It is up to you as the API designer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员可能会坚持认为成本范围应该用数值表示，但鉴于我们的API将由人们使用，为什么不使事情变得更有趣呢？这取决于作为API设计者的你。
- en: 'An example payload for this call might look something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个调用，一个可能的负载示例可能看起来像这样：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The array returned contains a place object representing a random recommendation
    for each segment in the journey in the appropriate order. The preceding example
    is a cafe in London. The data fields are fairly self-explanatory; the `lat` and
    `lng` fields represent the location of the place, the `name` and `vicinity` fields
    tell us what and where the business is, and the `photos` array gives us a list
    of relevant photographs from Google's servers. The `vicinity` and `icon` fields
    will help us deliver a richer experience to our users.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数组包含一个表示旅程中每个段落的随机推荐的地方对象，并按适当的顺序排列。前面的例子是在伦敦的咖啡馆。数据字段相当直观；`lat`和`lng`字段表示地点的位置，`name`和`vicinity`字段告诉我们业务是什么以及在哪里，`photos`数组提供了来自Google服务器的相关照片列表。`vicinity`和`icon`字段将帮助我们为用户提供更丰富的体验。
- en: Representing data in code
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中表示数据
- en: 'We are first going to expose the journeys that users can select from; so, create
    a new folder called `meander` in `GOPATH` and add the following `journeys.go`
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将展示用户可以选择的旅程；因此，在`GOPATH`中创建一个名为`meander`的新文件夹，并添加以下`journeys.go`代码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we define an internal type called `j` inside the `meander` package, which
    we then use to describe the journeys by creating instances of them inside the
    `Journeys` slice. This approach is an ultra-simple way of representing data in
    the code without building a dependency on an external data store.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`meander`包内部定义了一个名为`j`的内部类型，然后通过在`Journeys`切片内部创建其实例来描述旅程。这种方法是在不依赖外部数据存储的情况下在代码中表示数据的一种超简单方式。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As an additional assignment, why not see if you can keep `golint` happy throughout
    this process? Every time you add some code, run `golint` for the packages and
    satisfy any suggestions that emerge. It cares a lot about exported items that
    have no documentation; so adding simple comments in the correct format will keep
    it happy. To learn more about `golint`, refer to [https://github.com/golang/lint](https://github.com/golang/lint).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的作业，为什么不尝试在整个过程中保持`golint`满意呢？每次添加一些代码，就为包运行`golint`并满足出现的任何建议。它非常关注没有文档的导出项；因此，在正确的格式中添加简单的注释将使其保持满意。要了解更多关于`golint`的信息，请参阅[https://github.com/golang/lint](https://github.com/golang/lint)。
- en: Of course, this is likely to evolve into just that later, maybe even with the
    ability for users to create and share their own journeys. Since we are exposing
    our data via an API, we are free to change the internal implementation without
    affecting the interface, so this approach is great for a version 1.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这很可能会演变成那样，也许甚至允许用户创建和分享他们自己的旅程。由于我们通过API公开数据，我们可以自由地更改内部实现而不影响接口，因此这种方法非常适合版本1。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are using a slice of type `[]interface{}` because we will later implement
    a general way of exposing public data regardless of the actual types.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类型`[]interface{}`的切片，因为我们将在以后实现一种通用的公开数据方式，无论实际类型如何。
- en: A romantic journey consists of a visit first to a park, then a bar, a movie
    theater, then a restaurant before a visit to a florist, and finally, a taxi ride
    home; you get the general idea. Feel free to get creative and add others by consulting
    the supported types in the Google Places API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一场浪漫的旅程包括首先参观公园，然后是酒吧、电影院，接着是餐厅，在访问花店之后，最后乘坐出租车回家；你大概能理解这个概念。请随意发挥创意，并参考Google
    Places API支持的类型添加其他旅程。
- en: You might have noticed that since we are containing our code inside a package
    called `meander` (rather than `main`), our code can never be run as a tool like
    the other APIs we have written so far. Create two new folders inside meander so
    that you have a path that looks like `meander/cmd/meander`; this will house the
    actual command-line tool that exposes the `meander` package's capabilities via
    an HTTP endpoint.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，由于我们的代码包含在名为`meander`的包中（而不是`main`），我们的代码永远不能像我们迄今为止编写的其他API那样作为工具运行。在`meander`内部创建两个新文件夹，以便你有类似`meander/cmd/meander`的路径；这将容纳实际通过HTTP端点公开`meander`包功能的命令行工具。
- en: Since we are primarily building a package for our meandering project (something
    that other tools can import and make use of), the code in the root folder is the
    `meander` package, and we nest our command (the `main` package) inside the `cmd`
    folder. We include the additional final `meander` folder to follow good practices
    where the command name is the same as the folder if we omitted it, our command
    would be called `cmd` instead of `meander`, which would get confusing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们主要是在构建一个用于我们蜿蜒项目的包（其他工具可以导入并使用），根目录中的代码是`meander`包，我们将我们的命令（`main`包）嵌套在`cmd`文件夹中。我们包括额外的最终`meander`文件夹，以遵循良好的实践，如果省略它，命令名将与文件夹相同，我们的命令将被称为`cmd`而不是`meander`，这可能会造成混淆。
- en: 'Inside the `cmd/meander` folder, add the following code to the `main.go` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cmd/meander`文件夹内，将以下代码添加到`main.go`文件中：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will recognize this as a simple API endpoint program, mapping to the `/journeys`
    endpoint.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你会认出这是一个简单的API端点程序，映射到`/journeys`端点。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You'll have to import the `encoding/json`, `net/http`, and `runtime` packages,
    along with your own `meander` package you created earlier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不得不导入`encoding/json`、`net/http`和`runtime`包，以及你之前创建的自己的`meander`包。
- en: We set the value of `APIKey` in the `meander` package (which is commented out
    for now, since we are yet to implement it) before calling the familiar `HandleFunc`
    function on the `net/http` package to bind our endpoint, which then just responds
    with the `meander.Journeys` variable. We borrow the abstract responding concept
    from the previous chapter by providing a `respond` function that encodes the specified
    data to the `http.ResponseWriter` type.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`net/http`包上的熟悉的`HandleFunc`函数以绑定我们的端点之前，我们在`meander`包中设置了`APIKey`的值（目前被注释掉，因为我们还没有实现它），然后只响应`meander.Journeys`变量。我们通过提供一个将指定数据编码到`http.ResponseWriter`类型的`respond`函数，从上一章借用了抽象响应的概念。
- en: 'Let''s run our API program by navigating to the `cmd/meander` folder in a terminal
    and using `go run`. We don''t need to build this into an executable file at this
    stage since it''s just a single file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在终端中导航到`cmd/meander`文件夹并使用`go run`来运行我们的API程序。在这个阶段我们不需要将其构建成一个可执行文件，因为它只是一个单独的文件：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Hit the `http://localhost:8080/journeys` endpoint, and note that our `Journeys`
    data payload is served, which looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/journeys`端点，并注意我们的`Journeys`数据负载被提供，看起来是这样的：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is perfectly acceptable, but there is one major flaw: it exposes internals
    about our implementation. If we changed the `PlaceTypes` field name to `Types`,
    promises made in our API would break, and it''s important that we avoid this.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是可以接受的，但有一个主要的缺陷：它暴露了我们实现的一些内部信息。如果我们把`PlaceTypes`字段名改为`Types`，我们API中做出的承诺就会失效，因此我们避免这种情况是很重要的。
- en: Projects evolve and change over time, especially successful ones, and as developers,
    we should do what we can to protect our customers from the impact of the evolution.
    Abstracting interfaces is a great way to do this, as is taking ownership of the
    public-facing view of our data objects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 项目会随着时间的推移而发展和变化，尤其是那些成功的项目，作为开发者，我们应该尽我们所能来保护我们的客户免受演变的影响。抽象接口是做这件事的一个很好的方法，同样，负责我们数据对象面向公众的视图也是。
- en: Public views of Go structs
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go结构体的公共视图
- en: 'In order to control the public view of structs in Go, we need to invent a way
    to allow individual `journey` types to tell us how they want to be exposed. In
    the root `meander` folder, create a new file called `public.go` and add the following
    code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制Go中结构体的公共视图，我们需要发明一种方法，允许单个`journey`类型告诉我们它们希望如何被暴露。在根`meander`文件夹中，创建一个名为`public.go`的新文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Facade` interface exposes a single `Public` method, which will return the
    public view of a struct. The exported `Public` function takes any object and checks
    whether it implements the `Facade` interface (does it have a `Public() interface{}`
    method?); if it is implemented, it calls the method and returns the result otherwise,
    it just returns the original object untouched. This allows us to pass anything
    through the `Public` function before writing the result to the `ResponseWriter`
    object, allowing individual structs to control their public appearance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Facade`接口公开了一个单一的`Public`方法，它将返回结构体的公共视图。导出的`Public`函数接受任何对象并检查它是否实现了`Facade`接口（它是否有`Public()
    interface{}`方法？）；如果实现了，它将调用该方法并返回结果；如果没有实现，它将原封不动地返回原始对象。这允许我们在将结果写入`ResponseWriter`对象之前通过`Public`函数传递任何内容，允许单个结构体控制它们的公共外观。'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Normally, single method interfaces such as our `Facade` are named after the
    method they describe, such as `Reader` and `Writer`. However, `Publicer` is just
    confusing, so I deliberately broke the rule.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像我们的 `Facade` 这样的单方法接口会以它们描述的方法命名，例如 `Reader` 和 `Writer`。然而，“Publicer”这个名字很令人困惑，所以我故意打破了规则。
- en: 'Let''s implement a `Public` method for our `j` type by adding the following
    code to `journeys.go`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `journeys.go` 中添加以下代码来实现我们的 `j` 类型的 `Public` 方法：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The public view of our `j` type joins the `PlaceTypes` field into a single string
    separated by the pipe character as per our API design.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `j` 类型的公共视图将 `PlaceTypes` 字段连接成一个由管道字符分隔的单个字符串，符合我们的 API 设计。
- en: 'Head back to `cmd/meander/main.go` and replace the `respond` method with one
    that makes use of our new `Public` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `cmd/meander/main.go` 并将 `respond` 方法替换为使用我们新 `Public` 函数的方法：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we iterate over the data slice calling the `meander.Public` function
    for each item, building the results into a new slice of the same size. In the
    case of our `j` type, its `Public` method will be called to serve the public view
    of the data rather than the default view. In a terminal, navigate to the `cmd/meander`
    folder again and run `go run main.go` before hitting `http://localhost:8080/journeys`.
    Note that the same data has now changed to a new structure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历数据切片，对每个项目调用 `meander.Public` 函数，将结果构建成一个新的同大小切片。在我们的 `j` 类型中，其 `Public`
    方法将被调用以提供数据的公共视图，而不是默认视图。在终端中，再次导航到 `cmd/meander` 文件夹，并在运行 `go run main.go` 之前访问
    `http://localhost:8080/journeys`。请注意，相同的数据现在已更改为新的结构：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative way of achieving the same result would be to use tags to control
    the field names, as we have done in previous chapters, and implement your own
    `[]string` type that provides a `MarshalJSON` method which tells the encoder how
    to marshal your type. Both are perfectly acceptable, but the `Facade` interface
    and `Public` method are probably more expressive (if someone reads the code, isn't
    it obvious what's going on?) and give us more control.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的一种替代方法是通过使用标签来控制字段名称，就像我们在前面的章节中所做的那样，并实现你自己的 `[]string` 类型，该类型提供了一个
    `MarshalJSON` 方法，告诉编码器如何序列化你的类型。两者都是完全可以接受的，但 `Facade` 接口和 `Public` 方法可能更具表达性（如果有人阅读代码，这不是很明显吗？）并且给我们更多的控制。
- en: Generating random recommendations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机推荐
- en: 'In order to obtain the places from which our code will randomly build up recommendations,
    we need to query the Google Places API. In the root `meander` folder, add the
    following `query.go` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的代码随机构建推荐的地方，我们需要查询 Google Places API。在 `meander` 根目录下，添加以下 `query.go`
    文件：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code defines the structures we will need in order to parse the JSON response
    from the Google Places API into usable objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了我们解析 Google Places API 的 JSON 响应到可用对象所需的结构。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Head over to the Google Places API documentation for an example of the response
    we are expecting. Refer to [http://developers.google.com/places/documentation/search](http://developers.google.com/places/documentation/search).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 Google Places API 文档查看我们期望的响应示例。[http://developers.google.com/places/documentation/search](http://developers.google.com/places/documentation/search)
- en: Most of the preceding code will be obvious, but it's worth noting that the `Place`
    type embeds the `googleGeometry` type, which allows us to represent the nested
    data as per the API while essentially flattening it in our code. We do this with
    `googleLocation` inside `googleGeometry`, which means that we will be able to
    access the `Lat` and `Lng` values directly on a `Place` object even though they're
    technically nested in other structures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的大部分内容都很明显，但值得注意的是，`Place` 类型嵌入了 `googleGeometry` 类型，这允许我们按照 API 的要求表示嵌套数据，同时在我们的代码中将其扁平化。我们通过在
    `googleGeometry` 中的 `googleLocation` 来实现这一点，这意味着我们甚至可以直接在 `Place` 对象上访问 `Lat`
    和 `Lng` 值，尽管它们在技术上嵌套在其他结构中。
- en: 'Because we want to control how a `Place` object appears publically, let''s
    give this type the following `Public` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想控制 `Place` 对象的公开显示方式，让我们给这个类型以下 `Public` 方法：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to run `golint` on this code to see which comments need to be added
    to the exported items.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记得运行 `golint` 来查看哪些注释需要添加到导出项中。
- en: The Google Places API key
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Places API 密钥
- en: Like with most APIs, we will need an API key in order to access the remote services.
    Head over to the Google APIs Console, sign in with a Google account, and create
    a key for the Google Places API. For more detailed instructions, refer to the
    documentation on the Google's developer website.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数API一样，我们需要一个API密钥才能访问远程服务。前往Google APIs Console，使用Google账户登录，并为Google Places
    API创建一个密钥。有关更详细的说明，请参阅Google开发者网站上的文档。
- en: 'Once you have your key, let''s create a variable inside the `meander` package
    that can hold it. At the top of `query.go`, add the following definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了你的密钥，让我们在`meander`包内部创建一个变量来保存它。在`query.go`的顶部添加以下定义：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now nip back into `main.go`, remove the double slash `//` from the `APIKey`
    line, and replace the `TODO` value with the actual key provided by the Google
    APIs Console. Remember that it is bad practice to hardcode keys like this directly
    in your code; instead, it's worth breaking them out into environment variables,
    which keeps them out of your source code repository.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`main.go`，从`APIKey`行中移除双斜杠`//`，并将`TODO`值替换为Google APIs Console提供的实际密钥。记住，直接在代码中硬编码这样的密钥是不良的做法；相反，将它们分离到环境变量中是值得的，这样可以防止它们出现在源代码库中。
- en: Enumerators in Go
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go中的枚举器
- en: To handle the various cost ranges for our API, it makes sense to use an enumerator
    (or **enum**) to denote the various values and handle conversions to and from
    string representations. Go doesn't explicitly provide enumerators as a language
    feature, but there is a neat way of implementing them, which we will explore in
    this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理我们API中的各种成本范围，使用枚举器（或**枚举**）来表示不同的值并处理字符串表示的转换是有意义的。Go语言本身并不提供枚举器作为语言特性，但有一个巧妙的方法来实现它们，我们将在本节中探讨。
- en: 'A simple flexible checklist to write enumerators in Go is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的灵活的清单，用于在Go中编写枚举器如下：
- en: Define a new type based on a primitive integer type
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于原始整数类型定义一个新的类型
- en: Use that type whenever you need users to specify one of the appropriate values
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要用户指定适当的值时，使用该类型
- en: Use the `iota` keyword to set the values in a `const` block, disregarding the
    first zero value
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`iota`关键字在`const`块中设置值，忽略第一个零值
- en: Implement a map of sensible string representations to the values of your enumerator
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个映射，将合理的字符串表示与枚举器的值对应
- en: Implement a `String` method on the type that returns the appropriate string
    representation from the map
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型上实现一个`String`方法，该方法从映射中返回适当的字符串表示
- en: Implement a `ParseType` function that converts from a string to your type using
    the map
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`ParseType`函数，它使用映射将字符串转换为你的类型
- en: 'Now, we will write an enumerator to represent the cost levels in our API. Create
    a new file called `cost_level.go` inside the root `meander` folder and add the
    following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个枚举器来表示我们API中的成本级别。在根`meander`文件夹内创建一个名为`cost_level.go`的新文件，并添加以下代码：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we define the type of our enumerator, which we have called `Cost`, and
    since we need to represent a only few values, we have based it on an `int8` range.
    For enumerators where we need larger values, you are free to use any of the integer
    types that work with `iota`. The `Cost` type is now a real type in its own right,
    and we can use it wherever we need to represent one of the supported values for
    example, we can specify a `Cost` type as an argument in functions, or we can use
    it as the type for a field in a struct.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了枚举器的类型，我们称之为`Cost`，由于我们只需要表示几个值，所以我们基于`int8`的范围。对于需要更大值的枚举器，你可以自由地使用任何与`iota`一起工作的整数类型。`Cost`类型现在是一个真正的类型，我们可以在需要表示支持的值的地方使用它，例如，我们可以将`Cost`类型作为函数的参数，或者我们可以将其用作结构体字段的类型。
- en: We then define a list of constants of that type and use the `iota` keyword to
    indicate that we want incrementing values for the constants. By disregarding the
    first `iota` value (which is always zero), we indicate that one of the specified
    constants must be explicitly used rather than the zero value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后定义该类型的一组常量，并使用`iota`关键字来指示我们想要常量的递增值。通过忽略第一个`iota`值（它总是零），我们表明必须显式使用指定的常量而不是零值。
- en: To provide a string representation of our enumerator, we only need to add a
    `String` method to the `Cost` type. This is a useful exercise even if you don't
    need to use the strings in your code, because whenever you use the print calls
    from the Go standard library (such as `fmt.Println`), the numerical values will
    be used by default. Often, these values are meaningless and will require you to
    look them up and even count the lines to determine the numerical value for each
    item.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the `String()` method in Go, refer to the `Stringer`
    and `GoStringer` interfaces in the `fmt` package at [http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven enumerator
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure that our enumerator code is working correctly, we are going to write
    unit tests that make some assertions about expected behavior.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside `cost_level.go`, add a new file called `cost_level_test.go` and add
    the following unit test:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will need to run `go get` in order to get the CheekyBits `is` package (from
    [https://github.com/cheekybits/is](https://github.com/cheekybits/is)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `is` package is an alternative testing helper package, but this one is ultra-simple
    and deliberately bare-bones. You get to pick your favorite when you write your
    own projects or use none at all.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we wouldn't worry about the actual integer value of constants in our
    enumerator, but since the Google Places API uses numerical values to represent
    the same thing, we need to care about the values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed something strange about this test file that breaks from
    convention. Although it is inside the root `meander` folder, it is not a part
    of the `meander` package; rather, it's in `meander_test`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In Go, this is an error in every case except for tests. Because we are putting
    our test code into its own package, it means that we no longer have access to
    the internals of the `meander` package. Note how we have to use the package prefix.
    This may seem like a disadvantage, but in fact, it allows us to be sure that we
    are testing the package as though we were a real user of it. We may only call
    exported methods and only have visibility into exported types; just like our users.
    And we cannot mess around with internals to do things that our users cannot; it's
    a true user test. In testing, sometimes you do need to fiddle with an internal
    state, in which case your tests would need to be in the same package as the code
    instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests by running `go test` in a terminal and note that it passes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to make assertions about the string representations
    for each `Cost` constant. In `cost_level_test.go`, add the following unit test:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test asserts that calling the `String` method for each constant yields
    the expected value. Running these tests will, of course, fail because we haven't
    implemented the `String` method yet.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `Cost` constants, add the following map and the `String` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `map[string]Cost` variable maps the cost values to the string representation,
    and the `String` method iterates over the map to return the appropriate value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`map[string]Cost`变量将成本值映射到字符串表示形式，而`String`方法遍历映射以返回适当的值。'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In our case, a simple `strings.Repeat("$", int(l))` return would work just as
    well (and wins because it's simpler code); but it often won't; therefore, this
    section explores the general approach.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，简单的`strings.Repeat("$", int(l))`返回将同样有效（并且因为代码更简单而获胜）；但通常不会这样；因此，本节探讨了通用方法。
- en: Now if we were to print out the `Cost3` value, we would actually see `$$$`,
    which is much more useful than numerical values. As we want to use these strings
    in our API, we are also going to add a `ParseCost` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打印出`Cost3`值，我们实际上会看到`$$$`，这比数值更有用。由于我们想在API中使用这些字符串，我们还将添加一个`ParseCost`方法。
- en: 'In `cost_value_test.go`, add the following unit test:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cost_value_test.go`中添加以下单元测试：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we assert that calling `ParseCost` will, in fact, yield the appropriate
    value depending on the input string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们断言调用`ParseCost`将根据输入字符串产生适当的价值。
- en: 'In `cost_value.go`, add the following implementation code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cost_value.go`中添加以下实现代码：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Parsing a `Cost` string is very simple since this is how our map is laid out.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 解析`Cost`字符串非常简单，因为我们的映射就是这样布局的。
- en: 'As we need to represent a range of cost values, let''s imagine a `CostRange`
    type and write the tests out for how we intend to use it. Add the following tests
    to `cost_value_test.go`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要表示一系列成本值，让我们想象一个`CostRange`类型，并编写我们打算如何使用它的测试。将以下测试添加到`cost_value_test.go`中：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We specify that passing in a string with two dollar characters first, followed
    by three dots and then three dollar characters should create a new `meander.CostRange`
    type that has `From` set to `meander.Cost2` and `To` set to `meander.Cost3`. We
    also use `is.NoErr` in order to assert that no error is returned when we parse
    our strings. The second test does the reverse by testing that the `CostRange.String`
    method, which returns the appropriate value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定，传入一个以两个美元符号开头，然后是三个点，最后是三个美元符号的字符串应该创建一个新的`meander.CostRange`类型，其中`From`设置为`meander.Cost2`，`To`设置为`meander.Cost3`。我们还使用`is.NoErr`来断言在解析我们的字符串时不会返回错误。第二个测试通过测试`CostRange.String`方法，该方法返回适当的值。
- en: 'To make our tests pass, add the following `CostRange` type and the associated
    `String` and `ParseString` functions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的测试通过，添加以下`CostRange`类型及其相关的`String`和`ParseString`函数：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This allows us to convert a string such as `$...$$$$$` to a structure that
    contains two `Cost` values: a `From` and `To` set and vice versa. If somebody
    passes in an invalid cost range (we just perform a simple check on the number
    of segments after splitting on the dots), then we return an error. You can do
    additional checking here if you want to, such as ensuring only dots and dollar
    signs are mentioned in the strings.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将类似于`$...$$$$$`的字符串转换为包含两个`Cost`值的结构：一个`From`和一个`To`，反之亦然。如果有人传入无效的成本范围（我们只是在点分割后的段数上执行简单的检查），则返回错误。如果您想进行额外的检查，例如确保字符串中只包含点和美元符号，您也可以在这里进行。
- en: Querying the Google Places API
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询Google Places API
- en: 'Now that we are capable of representing the results of the API, we need a way
    to represent and initiate the actual query. Add the following structure to `query.go`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够表示API的结果，我们需要一种方式来表示和启动实际的查询。将以下结构添加到`query.go`中：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This structure contains all the information we will need in order to build
    up the query, all of which will actually come from the URL parameters in the requests
    from the client. Next, add the following `find` method, which will be responsible
    for making the actual request to Google''s servers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构包含构建查询所需的所有信息，所有这些信息实际上都来自客户端请求中的URL参数。接下来，添加以下`find`方法，该方法将负责向Google服务器发送实际请求：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we build the request URL as per the Google Places API specification by
    appending the `url.Values` encoded string of the data for `lat`, `lng`, `radius`,
    and, of course, the `APIKey` values.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据Google Places API规范构建请求URL，通过附加`lat`、`lng`、`radius`和当然，`APIKey`值的`url.Values`编码字符串。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `url.Values` type is actually a `map[string][]string` type, which is why
    we use `make` rather than `new`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`url.Values`类型实际上是`map[string][]string`类型，这就是为什么我们使用`make`而不是`new`。'
- en: The `types` value we specify as an argument represents the kind of business
    to look for. If there is `CostRangeStr`, we parse it and set the `minprice` and
    `maxprice` values before finally calling `http.Get` to actually make the request.
    If the request is successful, we defer the closing of the response body and use
    a `json.Decoder` method to decode the JSON that comes back from the API into our
    `googleResponse` type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Building recommendations
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to write a method that will allow us to make many calls to find
    for the different steps in a journey. Underneath the `find` method, add the following
    `Run` method to the `Query` struct:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first thing we do is set the random seed to the current time in nanoseconds
    since January 1, 1970 UTC. This ensures that every time we call the `Run` method
    and use the `rand` package, the results will be different. If we don't do this,
    our code would suggest the same recommendations every time, which defeats the
    object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Since we need to make many requests to Google and since we want to make sure
    this is as quick as possible we are going to run all the queries at the same time
    by making concurrent calls to our `Query.find` method. So next, we create `sync.WaitGroup` and
    a map to hold the selected places along with a `sync.Mutex` method to allow many
    goroutines to safely access the map concurrently.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate over each item in the `Journey` slice, which might be `bar`,
    `cafe`, or `movie_theater`. For each item, we add `1` to the `WaitGroup` object
    and start a goroutine. Inside the routine, we first defer the `w.Done` call, informing
    the `WaitGroup` object that this request has completed before calling our `find`
    method to make the actual request. Assuming no errors occurred and it was indeed
    able to find some places, we iterate over the results and build up a usable URL
    for any photos that might be present. According to the Google Places API, we are
    given a `photoreference` key, which we can use in another API call to get the
    actual image. To save our clients from having to have knowledge of the Google
    Places API at all, we build the complete URL for them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We then lock the map locker and with a call to `rand.Intn`, pick one of the
    options at random and insert it into the right position in the `places` slice
    before unlocking `sync.Mutex`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wait for all goroutines to complete with a call to `w.Wait` before
    returning the places.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Handlers that use query parameters
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to wire up our `/recommendations` call, so head back to `main.go`
    in the `cmd/meander` folder and add the following code inside the `main` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This handler is responsible for preparing the `meander.Query` object and calling
    its `Run` method before responding with the results. The `http.Request` type's
    URL value exposes the `Query` data that provides a `Get` method which, in turn,
    looks up a value for a given key.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The journey string is translated from the `bar|cafe|movie_theater` format to
    a slice of strings by splitting on the pipe character. Then, a few calls to functions
    in the `strconv` package turn the string latitude, longitude, and radius values
    into numerical types. If the values are in an incorrect format, we will get an
    error, which we will then write out to the client using the `http.Error` helper
    with an `http.StatusBadRequest` status.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: CORS
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final piece of the first version of our API will be to implement CORS, as
    we did in the previous chapter. See if you can solve this problem yourself before
    reading on about the solution in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to tackle this yourself, remember that your aim is to set the
    `Access-Control-Allow-Origin` response header to `*`. Also, consider the `http.HandlerFunc`
    wrapping we did in the previous chapter. The best place for this code is probably
    in the `cmd/meander` program, since that is what exposes the functionality through
    an HTTP endpoint.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.go`, add the following `cors` function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This familiar pattern takes in an `http.HandlerFunc` type and returns a new
    one that sets the appropriate header before calling the passed-in function. Now,
    we can modify our code to make sure that the `cors` function gets called for both
    of our endpoints. Update the appropriate lines in the `main` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, calls to our API will be allowed from any domain without a cross-origin
    error occurring.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can you see a way to smarten up the code by removing the multiple calls to `r.URL.Query()`?
    Perhaps do this once and cache the result in a local variable. Then, you can avoid
    parsing the query many times.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Testing our API
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are ready to test our API, head to a console and navigate to the
    `cmd/meander` folder. Because our program imports the `meander` package, building
    the program will automatically build our `meander` package too.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the program:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To see meaningful results from our API, let's take a minute to find your actual
    latitude and longitude. Head over to [http://mygeoposition.com/](http://mygeoposition.com/)
    and use the web tools to get the `x,y` values for a location you are familiar
    with.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, pick from these popular cities:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'London, England: `51.520707 x 0.153809`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New York, USA: `40.7127840 x -74.0059410`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tokyo, Japan: `35.6894870 x 139.6917060`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'San Francisco, USA: `37.7749290 x -122.4194160`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, open a web browser and access the `/recommendations` endpoint with some
    appropriate values for the fields:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following screenshot shows what a sample recommendation around London might
    look like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our API](img/00062.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Feel free to play around with the values in the URL to see how powerful the
    simple API is by trying various journey strings, tweaking the locations, and trying
    different cost range value strings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Web application
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to download a complete web application built to the same API specifications
    and point it at our implementation to see it come to life before our eyes. Head
    over to [https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb](https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb)
    and download the `meanderweb` project into your `GOPATH` folder (alongside your
    root meander folder will do).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, navigate to the `meanderweb` folder and build and run it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will start a website running on `localhost:8081`, which is hardcoded to
    look for the API running at `localhost:8080`. Because we added the CORS support,
    this won't be a problem despite them running on different domains.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Open a browser to `http://localhost:8081/` and interact with the application;
    while somebody else built the UI, it would be pretty useless without the API that
    we built in order to power it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an API that consumes and abstracts the Google Places
    API to provide a fun and interesting way of letting users plan their days and
    evenings.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We started by writing some simple and short user stories that described what
    we wanted to achieve at a really high level without trying to design the implementation
    up front. In order to parallelize the project, we agreed upon the meeting point
    of the project as the API design, and we built toward it (as would our partners).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We embedded data directly in the code, avoiding the need to investigate, design,
    and implement a data store in the early stages of a project. By caring about how
    that data is accessed (via the API endpoint) instead, we allowed our future selves
    to completely change how and where the data is stored without breaking any apps
    that have been written with our API.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the `Facade` interface, which allows our structs and other types
    to provide public representations of them without revealing messy or sensitive
    details about our implementation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Our foray into enumerators gave us a useful starting point to build enumerated
    types, even though there is no official support for them in the language. The
    `iota` keyword that we used lets us specify constants of our own numerical type,
    with incrementing values. The common `String` method that we implemented showed
    us how to make sure that our enumerated types don't become obscure numbers in
    our logs. At the same time, we also saw a real-world example of TDD and red/green
    programming, where we wrote unit tests that first fail but which we then go on
    to make pass by writing the implementation code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a break from web services in order
    to build a backup tool for our code, where we'll explore how easy Go makes it
    for us to interact with the local filesystem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
