- en: Maps
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: 'Maps are like dictionaries--for each word, we have a definition but we can
    use any type as word or definition and they''ll never be ordered alphabetically.
    We can create maps of string that point to numbers, a string that points to `interfaces` and
    `structs` that point to `int` and `int` to `function`. You cannot use as key:
    slices, the functions, and maps. Finally, you create maps by using the keyword
    make and specifying the key type and the value type:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 映射就像字典--对于每个单词，我们都有一个定义，但我们可以使用任何类型作为单词或定义，并且它们永远不会按字母顺序排序。我们可以创建指向数字的字符串映射，指向
    `interfaces` 和 `structs` 的字符串，以及指向 `int` 和 `int` 的函数。你不能使用切片、函数和映射作为键。最后，你通过使用关键字
    make 并指定键类型和值类型来创建映射：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When parsing JSON content, you can also use them to get a `string[interface]`
    map:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析 JSON 内容时，你还可以使用它们来获取 `string[interface]` 映射：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `myJsonMap` variable is a map that will store the contents of JSON and that
    we will need to pass its pointer to the `Unmarshal` function. The `jsonData` variable
    declares an array of bytes with the typical content of a JSON object; we are using
    this as the mock object. Then, we unmarshal the contents of the JSON storing the
    result of the memory location of `myJsonMap` variable. After checking that the
    conversion was ok and the JSON byte array didn't have syntax mistakes, we can
    access the contents of the map in a JSON-like syntax.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`myJsonMap` 变量是一个将存储 JSON 内容的映射，我们需要将其指针传递给 `Unmarshal` 函数。`jsonData` 变量声明了一个包含
    JSON 对象典型内容的字节数组；我们使用这个作为模拟对象。然后，我们将 JSON 内容反序列化，并将 `myJsonMap` 变量的内存位置的结果存储。在确认转换无误且
    JSON 字节数组没有语法错误后，我们可以使用类似 JSON 的语法访问映射的内容。'
