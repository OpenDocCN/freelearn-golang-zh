<html><head></head><body><div class="book" title="Zero-initialization" id="30A8Q1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec018" class="calibre1"/>Zero-initialization</h1></div></div></div><p class="calibre10">Zero-initialization is a source of confusion sometimes. They are default values for many types that are assigned even if you don't provide a value for the definition. Following are the zero-initialization for various types:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">false</code> initialization for <code class="email">bool</code> type.</li><li class="listitem">Using <code class="email">0</code> values for <code class="email">int</code> type.</li><li class="listitem">Using <code class="email">0.0</code> for <code class="email">float</code> type.</li><li class="listitem">Using <code class="email">""</code> (empty strings) for <code class="email">string</code> type.</li><li class="listitem">Using <code class="email">nil</code> keyword for pointers, functions, interfaces, slices, channels and maps.</li><li class="listitem">Empty <code class="email">struct</code> for structures without fields.</li><li class="listitem">Zero-initialized <code class="email">struct</code> for structures with fields. The zero value of a structure is defined as the structure that has its fields initialized as zero value too.</li></ul></div><p class="calibre10">Zero-initialization is important when programming in Go because you won't be able to return a <code class="email">nil</code> value if you have to return an <code class="email">int</code> type or a <code class="email">struct</code>. Keep this in mind, for example, in functions where you have to return a <code class="email">bool</code> value. Imagine that you want to know if a number is divisible by a different number but you pass <code class="email">0</code> (zero) as the divisor.</p><pre class="programlisting">func main() { 
    res := divisibleBy(10,0) 
    fmt.Printf("%v\n", res) 
} 
 
func divisibleBy(n, divisor int) bool { 
    if divisor == 0 { 
        //You cannot divide by zero 
        return false 
    } 
 
    return (n % divisor == 0) 
} 
</pre><p class="calibre10">The output of this program is <code class="email">false</code> but this is incorrect. A number divided by zero is an error, it's not that 10 isn't divisible by zero but that a number cannot be divided by zero by definition. Zero-initialization is making things awkward in this situation. So, how can we solve this error? Consider the following code:</p><pre class="programlisting">func main() { 
    res, err := divisibleBy(10,0) 
    if err != nil { 
log.Fatal(err) 
    } 
 
    log.Printf("%v\n", res) 
} 
 
func divisibleBy(n, divisor int) (bool, error) { 
    if divisor == 0 { 
        //You cannot divide by zero 
        return false, errors.New("A number cannot be divided by zero") 
    } 
 
    return (n % divisor == 0), nil 
} 
</pre><p class="calibre10">We're dividing <code class="email">10</code> by <code class="email">0</code> again but now the output of this function is <code class="email">A number cannot be divided by zero</code>. Error captured, theÂ program finished gracefully.</p></div></body></html>