- en: What is a pointer? Why are they good?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pointers are hated, loved, and very useful at the same time. To understand what
    a pointer is can be difficult so let's try with a real world explanation. As we
    mentioned earlier in this chapter, a pointer is a like a mailbox. Imagine a bunch
    of mailboxes in a building; all of them have the same size and shape but each
    refers to a different house within the building. Just because all mailboxes are
    the same size does not mean that each house will have the same size. We could
    even have a couple of houses joined, a house that was there but now has a license
    of commerce, or a house that is completely empty. So the pointers are the mailboxes,
    all of them of the same size and that refer to a house. The building is our memory
    and the houses are the types our pointers refer to and the memory they allocate.
    If you want to receive something in your house, it's far easier to simply send
    the address of your house (to send the pointer) instead of sending the entire
    house so that your package is deposited inside. But they have some drawbacks as
    if you send your address and your house (variable it refers to) disappears after
    sending, or its type owner change--you'll be in trouble.
  prefs: []
  type: TYPE_NORMAL
- en: How is this useful? Imagine that somehow you have 4 GB of data in a variable
    and you need to pass it to a different function. Without a pointer, the entire
    variable is cloned to the scope of the function that is going to use it. So, you'll
    have 8 GB of memory occupied by using this variable twice that, hopefully, the
    second function isn't going to use in a different function again to raise this
    number even more.
  prefs: []
  type: TYPE_NORMAL
- en: You could use a pointer to pass a very small reference to this chunk to the
    first function so that just the small reference is cloned and you can keep your
    memory usage low.
  prefs: []
  type: TYPE_NORMAL
- en: While this isn't the most academic nor exact explanation, it gives a good view
    of what a pointer is without explaining what a stack or a heap is or how they
    work in x86 architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers in Go are very limited compared with C or C++ pointers. You can't use
    pointer arithmetic nor can you create a pointer to reference an exact position
    in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pointers in Go can be declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `number := 5` code represents our 4 GB variable and `pointer_to_number`
    contains the reference (represented by an ampersand) to this variable. It''s the
    direction to the variable (the one that you put in the mailbox of this `house/type/variable`).
    Let''s print the variable `pointer_to_number` , which is a simple variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What's that number? Well, the direction to our variable in memory. And how can
    I print the actual value of the house? Well, with an asterisk (`*)` we tell the
    compiler to take the value that the pointer is referencing, which is our 4 GB
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
