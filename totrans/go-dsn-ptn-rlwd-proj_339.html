<html><head></head><body>
<div class="book" title="Pointers and structures" id="318PC1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Structs"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec021" class="calibre1"/>Structs</h2></div></div></div><p class="calibre10">A struct is an object in Go. It has some similarities with classes in OOP as they have fields. Structs can implement interfaces and declare methods. But, for example, in Go, there's not inheritance. Lack of inheritance looks limiting but in fact, <span class="strong"><em class="calibre11">composition over inheritance</em></span> was a requirement of the language.</p><p class="calibre10">To declare a structure, you have to prefix its name with the keyword <code class="email">type</code> and suffix with the keyword <code class="email">struct</code> and then you declare any field or method between brackets, for example:</p><pre class="programlisting">type Person struct { 
    Name string 
    Surname string 
    Hobbies []string 
    id string 
} 
</pre><p class="calibre10">In this piece of code, we have declared a <code class="email">Person</code> structure with three public fields (<code class="email">Name</code>, <code class="email">Age</code> , and <code class="email">Hobbies</code>) and one private field (<code class="email">id</code>, if you recall the <span class="strong"><em class="calibre11">Visibility</em></span> section in this chapter, lowercase fields in Go refers to private fields are just visible within the same package). With this <code class="email">struct</code>, we can now create as many instances of <code class="email">Person</code> as we want. Now we will write a function called <code class="email">GetFullName</code> that will give the composition of the name and the surname of the <code class="email">struct</code> it belongs to:</p><pre class="programlisting">func (person *Person) GetFullName() string { 
    return fmt.Sprintf("%s %s", person.Name, person.Surname) 
} 
 
func main() { 
    p := Person{ 
        Name: "Mario", 
        Surname: "Castro", 
        Hobbies: []string{"cycling", "electronics", "planes"}, 
        id: "sa3-223-asd", 
    } 
 
    fmt.Printf("%s likes %s, %s and %s\n", p.GetFullName(), p.Hobbies[0], p.Hobbies[1], p.Hobbies[2]) 
} 
</pre><p class="calibre10">Methods are defined similarly to functions but in a slightly different way. There is a<code class="email">(p *Person)</code> that refers to a pointer to the created instance of the <code class="email">struct </code>(recall the <span class="strong"><em class="calibre11">Pointers</em></span> section in this chapter). It's like using the keyword <code class="email">this</code> in Java or <code class="email">self</code> in Python when referring to the pointing object.</p><p class="calibre10">Maybe you are thinking why does (<code class="email">p *Person</code>) have the pointer operator to reflect that <code class="email">p</code> is actually a pointer and not a value? This is because you can also pass Person by value by removing the pointer signature, in which case a copy of the value of Person is passed to the function. This has some implications, for example, any change that you make in p if you pass it by value won't be reflected in source <code class="email">p</code>. But what about our <code class="email">GetFullName()</code> method?</p><pre class="programlisting">func (person Person) GetFullName() string { 
    return fmt.Sprintf("%s %s", person.Name, person.Surname) 
} 
</pre><p class="calibre10">Its console output has no effect in appearance but a full copy was passed before evaluating the function. But if we modify <code class="email">person </code>here, the source <code class="email">p</code> won't be affected and the new <code class="email">person </code>value will be available only on the scope of this function.</p><p class="calibre10">On the <code class="email">main</code> function, we create an instance of our structure called <code class="email">p</code>. As you can see, we have used implicit notation to create the variable (the <code class="email">:=</code> symbol). To set the fields, you have to refer to the name of the field, colon, the value, and the comma (don't forget the comma at the end!). To access the fields of the instantiated structure, we just refer to them by their name like <code class="email">p.Name</code> or <code class="email">p.Surname</code>. You use the same syntax to access the methods of the structure like <code class="email">p.GetFullName()</code>.</p><p class="calibre10">The output of this program is:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go </strong></span>
<span class="strong"><strong class="calibre2">Mario Castro likes cycling, electronics and planes</strong></span>
</pre><p class="calibre10">Structures can also contain another structure (composition) and implement interface methods apart from their own but, what's an interface method?</p></div></div></body></html>