- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A struct is an object in Go. It has some similarities with classes in OOP as
    they have fields. Structs can implement interfaces and declare methods. But, for
    example, in Go, there's not inheritance. Lack of inheritance looks limiting but
    in fact, *composition over inheritance* was a requirement of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a structure, you have to prefix its name with the keyword `type`
    and suffix with the keyword `struct` and then you declare any field or method
    between brackets, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this piece of code, we have declared a `Person` structure with three public
    fields (`Name`, `Age` , and `Hobbies`) and one private field (`id`, if you recall
    the *Visibility* section in this chapter, lowercase fields in Go refers to private
    fields are just visible within the same package). With this `struct`, we can now
    create as many instances of `Person` as we want. Now we will write a function
    called `GetFullName` that will give the composition of the name and the surname
    of the `struct` it belongs to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Methods are defined similarly to functions but in a slightly different way.
    There is a`(p *Person)` that refers to a pointer to the created instance of the
    `struct` (recall the *Pointers* section in this chapter). It's like using the
    keyword `this` in Java or `self` in Python when referring to the pointing object.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you are thinking why does (`p *Person`) have the pointer operator to reflect
    that `p` is actually a pointer and not a value? This is because you can also pass
    Person by value by removing the pointer signature, in which case a copy of the
    value of Person is passed to the function. This has some implications, for example,
    any change that you make in p if you pass it by value won't be reflected in source
    `p`. But what about our `GetFullName()` method?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Its console output has no effect in appearance but a full copy was passed before
    evaluating the function. But if we modify `person` here, the source `p` won't
    be affected and the new `person` value will be available only on the scope of
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: On the `main` function, we create an instance of our structure called `p`. As
    you can see, we have used implicit notation to create the variable (the `:=` symbol).
    To set the fields, you have to refer to the name of the field, colon, the value,
    and the comma (don't forget the comma at the end!). To access the fields of the
    instantiated structure, we just refer to them by their name like `p.Name` or `p.Surname`.
    You use the same syntax to access the methods of the structure like `p.GetFullName()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Structures can also contain another structure (composition) and implement interface
    methods apart from their own but, what's an interface method?
  prefs: []
  type: TYPE_NORMAL
