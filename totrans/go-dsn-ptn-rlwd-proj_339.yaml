- en: Structs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: A struct is an object in Go. It has some similarities with classes in OOP as
    they have fields. Structs can implement interfaces and declare methods. But, for
    example, in Go, there's not inheritance. Lack of inheritance looks limiting but
    in fact, *composition over inheritance* was a requirement of the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是 Go 语言中的一个对象。它与面向对象中的类有相似之处，因为它们都有字段。结构体可以实现接口并声明方法。但是，例如，在 Go 语言中，没有继承。缺乏继承看起来很有限，但实际上，“组合优于继承”是语言的要求。
- en: 'To declare a structure, you have to prefix its name with the keyword `type`
    and suffix with the keyword `struct` and then you declare any field or method
    between brackets, for example:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个结构体，你必须用关键字 `type` 前缀，用关键字 `struct` 后缀，然后在括号内声明任何字段或方法，例如：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this piece of code, we have declared a `Person` structure with three public
    fields (`Name`, `Age` , and `Hobbies`) and one private field (`id`, if you recall
    the *Visibility* section in this chapter, lowercase fields in Go refers to private
    fields are just visible within the same package). With this `struct`, we can now
    create as many instances of `Person` as we want. Now we will write a function
    called `GetFullName` that will give the composition of the name and the surname
    of the `struct` it belongs to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们声明了一个名为 `Person` 的结构体，它有三个公共字段（`Name`、`Age` 和 `Hobbies`）和一个私有字段（`id`，如果你还记得本章中的
    *可见性* 部分，Go 中的小写字段表示私有字段，仅在同一个包内可见）。有了这个 `struct`，我们现在可以创建任意多的 `Person` 实例。现在我们将编写一个名为
    `GetFullName` 的函数，该函数将给出所属 `struct` 的名字和姓氏的组合：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Methods are defined similarly to functions but in a slightly different way.
    There is a`(p *Person)` that refers to a pointer to the created instance of the
    `struct` (recall the *Pointers* section in this chapter). It's like using the
    keyword `this` in Java or `self` in Python when referring to the pointing object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义的方式与函数类似，但略有不同。有一个 `(p *Person)` 指向创建的 `struct` 实例的指针（回忆本章中的 *指针* 部分）。这就像在
    Java 中使用 `this` 关键字或在 Python 中使用 `self` 关键字来引用指向的对象。
- en: Maybe you are thinking why does (`p *Person`) have the pointer operator to reflect
    that `p` is actually a pointer and not a value? This is because you can also pass
    Person by value by removing the pointer signature, in which case a copy of the
    value of Person is passed to the function. This has some implications, for example,
    any change that you make in p if you pass it by value won't be reflected in source
    `p`. But what about our `GetFullName()` method?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么 (`p *Person`) 有指针运算符来表示 `p` 实际上是一个指针而不是一个值？这是因为你也可以通过移除指针签名以值的形式传递
    `Person`。在这种情况下，会传递 `Person` 值的一个副本。这有一些影响，例如，如果你通过值传递修改了 `p`，那么源 `p` 将不会受到影响，新的
    `person` 值只会在该函数的作用域内可用。但我们的 `GetFullName()` 方法呢？
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Its console output has no effect in appearance but a full copy was passed before
    evaluating the function. But if we modify `person` here, the source `p` won't
    be affected and the new `person` value will be available only on the scope of
    this function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它的控制台输出在外观上没有影响，但在评估函数之前已经传递了一个完整的副本。但如果我们在这里修改 `person`，源 `p` 不会受到影响，新的 `person`
    值只会在该函数的作用域内可用。
- en: On the `main` function, we create an instance of our structure called `p`. As
    you can see, we have used implicit notation to create the variable (the `:=` symbol).
    To set the fields, you have to refer to the name of the field, colon, the value,
    and the comma (don't forget the comma at the end!). To access the fields of the
    instantiated structure, we just refer to them by their name like `p.Name` or `p.Surname`.
    You use the same syntax to access the methods of the structure like `p.GetFullName()`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建了一个名为 `p` 的结构体实例。正如你所见，我们使用了隐式表示法来创建变量（`:=` 符号）。要设置字段，你必须引用字段名，冒号，值，逗号（别忘了最后的逗号！）。要访问实例化结构体的字段，我们只需通过它们的名称来引用，如
    `p.Name` 或 `p.Surname`。你使用相同的语法来访问结构体的方法，如 `p.GetFullName()`。
- en: 'The output of this program is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出是：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Structures can also contain another structure (composition) and implement interface
    methods apart from their own but, what's an interface method?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体也可以包含另一个结构体（组合）并实现接口方法，除了它们自己的方法之外，但什么是接口方法？
