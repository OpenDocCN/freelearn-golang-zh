["```go\n/backup - package \n/backup/cmds/backup - user interaction tool \n/backup/cmds/backupd - worker daemon \n\n```", "```go\npackage backup \ntype Archiver interface { \n  Archive(src, dest string) error \n} \n\n```", "```go\ntype zipper struct{} \n\n```", "```go\n// Zip is an Archiver that zips and unzips files. \nvar ZIP Archiver = (*zipper)(nil) \n\nZIP of type Archiver, so from outside the package, it's pretty clear that we can use that variable wherever Archiver is needed if you want to zip things. Then, we assign it with nil cast to the type *zipper. We know that nil takes no memory, but since it's cast to a zipper pointer, and given that our zipper struct has no state, it's an appropriate way of solving a problem, which hides the complexity of code (and indeed the actual implementation) from outside users. There is no reason anybody outside of the package needs to know about our zipper type at all, which frees us up to change the internals without touching the externals at any time: the true power of interfaces.\n```", "```go\n./archiver.go:10: cannot use (*zipper)(nil) (type *zipper) as type \n    Archiver in assignment:\n *zipper does not implement Archiver (missing Archive method)\n\n```", "```go\nfunc (z *zipper) Archive(src, dest string) error { \n  if err := os.MkdirAll(filepath.Dir(dest), 0777); err != nil { \n    return err \n  } \n  out, err := os.Create(dest) \n  if err != nil { \n    return err \n  } \n  defer out.Close() \n  w := zip.NewWriter(out) \n  defer w.Close() \n  return filepath.Walk(src, func(path string, info os.FileInfo, err error) \n  error { \n    if info.IsDir() { \n      return nil // skip \n    } \n    if err != nil { \n      return err \n    } \n    in, err := os.Open(path) \n    if err != nil { \n      return err \n    } \n    defer in.Close() \n    f, err := w.Create(path) \n    if err != nil { \n      return err \n    } \n    _, err = io.Copy(f, in) \n    if err != nil { \n      return err \n    } \n    return nil \n  }) \n} \n\n```", "```go\ntype FileInfo interface { \n  Name() string       // base name of the file \n  Size() int64        // length in bytes for regular files;  \n                         system-dependent for others \n  Mode() FileMode     // file mode bits \n  ModTime() time.Time // modification time \n  IsDir() bool        // abbreviation for Mode().IsDir() \n  Sys() interface{}   // underlying data source (can return nil) \n} \n\n```", "```go\npackage backup \nimport ( \n  \"crypto/md5\" \n  \"fmt\" \n  \"io\" \n  \"os\" \n  \"path/filepath\" \n) \nfunc DirHash(path string) (string, error) { \n  hash := md5.New() \n  err := filepath.Walk(path, func(path string, info os.FileInfo, err error) \n  error { \n    if err != nil { \n      return err \n    } \n    io.WriteString(hash, path) \n    fmt.Fprintf(hash, \"%v\", info.IsDir()) \n    fmt.Fprintf(hash, \"%v\", info.ModTime()) \n    fmt.Fprintf(hash, \"%v\", info.Mode()) \n    fmt.Fprintf(hash, \"%v\", info.Name()) \n    fmt.Fprintf(hash, \"%v\", info.Size()) \n    return nil \n  }) \n  if err != nil { \n    return \"\", err \n  } \n  return fmt.Sprintf(\"%x\", hash.Sum(nil)), nil \n} \n\n```", "```go\ntype Monitor struct { \n  Paths       map[string]string \n  Archiver    Archiver \n  Destination string \n} \n\n```", "```go\nfunc (m *Monitor) Now() (int, error) { \n  var counter int \n  for path, lastHash := range m.Paths { \n    newHash, err := DirHash(path) \n    if err != nil { \n      return counter, err \n    } \n    if newHash != lastHash { \n      err := m.act(path) \n      if err != nil { \n        return counter, err \n      } \n      m.Paths[path] = newHash // update the hash \n      counter++ \n    } \n  } \n  return counter, nil \n} \n\n```", "```go\nm.act undefined (type *Monitor has no field or method act) \n\n```", "```go\nfunc (m *Monitor) act(path string) error { \n  dirname := filepath.Base(path) \n  filename := fmt.Sprintf(\"%d.zip\", time.Now().UnixNano()) \n  return m.Archiver.Archive(path, filepath.Join(m.Destination,  dirname, filename)) \n} \n\n```", "```go\ntype Archiver interface { \n  DestFmt() string \n  Archive(src, dest string) error \n} \n\n```", "```go\nfunc (z *zipper) DestFmt() string { \n  return \"%d.zip\" \n} \n\n```", "```go\nfunc (m *Monitor) act(path string) error { \n  dirname := filepath.Base(path) \n  filename := fmt.Sprintf(m.Archiver.DestFmt(), time.Now().UnixNano()) \n  return m.Archiver.Archive(path, filepath.Join(m.Destination, dirname, \n  filename)) \n} \n\n```", "```go\nfunc main() { \n  var fatalErr error \n  defer func() { \n    if fatalErr != nil { \n      flag.PrintDefaults() \n      log.Fatalln(fatalErr) \n    } \n  }() \n  var ( \n    dbpath = flag.String(\"db\", \"./backupdata\", \"path to database directory\") \n  ) \n  flag.Parse() \n  args := flag.Args() \n  if len(args) < 1 { \n    fatalErr = errors.New(\"invalid usage; must specify command\") \n    return \n  } \n} \n\n```", "```go\ndb, err := filedb.Dial(*dbpath) \nif err != nil { \n  fatalErr = err \n  return \n} \ndefer db.Close() \ncol, err := db.C(\"paths\") \nif err != nil { \n  fatalErr = err \n  return \n} \n\n```", "```go\ntype path struct { \n  Path string \n  Hash string \n} \n\n```", "```go\nbackup -db=/path/to/db add {path} [paths...]\n\n```", "```go\nbackup -db=/path/to/db remove {path} [paths...]\n\n```", "```go\nbackup -db=/path/to/db list\n\n```", "```go\nswitch strings.ToLower(args[0]) { \ncase \"list\": \ncase \"add\": \ncase \"remove\": \n} \n\n```", "```go\nvar path path \ncol.ForEach(func(i int, data []byte) bool { \n  err := json.Unmarshal(data, &path) \n  if err != nil { \n    fatalErr = err \n    return true \n  } \n  fmt.Printf(\"= %s\\n\", path) \n  return false \n}) \n\n```", "```go\nfunc (p path) String() string { \n  return fmt.Sprintf(\"%s [%s]\", p.Path, p.Hash) \n} \n\n```", "```go\nif len(args[1:]) == 0 { \n  fatalErr = errors.New(\"must specify path to add\") \n  return \n} \nfor _, p := range args[1:] { \n  path := &path{Path: p, Hash: \"Not yet archived\"} \n  if err := col.InsertJSON(path); err != nil { \n    fatalErr = err \n    return \n  } \n  fmt.Printf(\"+ %s\\n\", path) \n} \n\n```", "```go\nvar path path \ncol.RemoveEach(func(i int, data []byte) (bool, bool) { \n  err := json.Unmarshal(data, &path) \n  if err != nil { \n    fatalErr = err \n    return false, true \n  } \n  for _, p := range args[1:] { \n    if path.Path == p { \n      fmt.Printf(\"- %s\\n\", path) \n      return true, false \n    } \n  } \n  return false, false \n}) \n\n```", "```go\ngo build -o backup\n\n```", "```go\n./backup -db=./backupdata add ./test ./test2\n\n```", "```go\n+ ./test [Not yet archived]\n+ ./test2 [Not yet archived]\n\n```", "```go\n./backup -db=./backupdata add ./test3\n\n```", "```go\n./backup -db=./backupdata list\n\n```", "```go\n= ./test [Not yet archived]\n= ./test2 [Not yet archived]\n= ./test3 [Not yet archived]\n\n```", "```go\n./backup -db=./backupdata remove ./test3\n./backup -db=./backupdata list\n\n```", "```go\n+ ./test [Not yet archived]\n+ ./test2 [Not yet archived]\n\n```", "```go\nfunc main() { \n  var fatalErr error \n  defer func() { \n    if fatalErr != nil { \n      log.Fatalln(fatalErr) \n    } \n  }() \n  var ( \n    interval = flag.Duration(\"interval\", 10 * time.Second, \"interval between \n    checks\") \n    archive  = flag.String(\"archive\", \"archive\", \"path to archive location\") \n    dbpath   = flag.String(\"db\", \"./db\", \"path to filedb database\") \n  ) \n  flag.Parse() \n} \n\n```", "```go\nm := &backup.Monitor{ \n  Destination: *archive, \n  Archiver:    backup.ZIP, \n  Paths:       make(map[string]string), \n} \n\n```", "```go\ndb, err := filedb.Dial(*dbpath) \nif err != nil { \n  fatalErr = err \n  return \n} \ndefer db.Close() \ncol, err := db.C(\"paths\") \nif err != nil { \n  fatalErr = err \n  return \n} \n\n```", "```go\ntype path struct { \n  Path string \n  Hash string \n} \n\nLastChecked field to our backupd program so that we can add rules where each folder only gets archived once an hour at most. Our backup program doesn't care about this and will chug along perfectly happy with its view into what fields constitute a path structure.\n```", "```go\nvar path path \ncol.ForEach(func(_ int, data []byte) bool { \n  if err := json.Unmarshal(data, &path); err != nil { \n    fatalErr = err \n    return true \n  } \n  m.Paths[path.Path] = path.Hash \n  return false // carry on \n}) \nif fatalErr != nil { \n  return \n} \nif len(m.Paths) < 1 { \n  fatalErr = errors.New(\"no paths - use backup tool to add at least one\") \n  return \n} \n\n```", "```go\nfor {} \n\n```", "```go\ncheck(m, col) \nsignalChan := make(chan os.Signal, 1) \nsignal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM) \nfor { \n  select { \n  case <-time.After(*interval): \n    check(m, col) \n  case <-signalChan: \n    // stop \n    fmt.Println() \n    log.Printf(\"Stopping...\") \n    return \n  } \n} \n\n```", "```go\nfunc check(m *backup.Monitor, col *filedb.C) { \n  log.Println(\"Checking...\") \n  counter, err := m.Now() \n  if err != nil { \n    log.Fatalln(\"failed to backup:\", err) \n  } \n  if counter > 0 { \n    log.Printf(\"  Archived %d directories\\n\", counter) \n    // update hashes \n    var path path \n    col.SelectEach(func(_ int, data []byte) (bool, []byte, bool) { \n      if err := json.Unmarshal(data, &path); err != nil { \n        log.Println(\"failed to unmarshal data (skipping):\", err) \n        return true, data, false \n      } \n      path.Hash, _ = m.Paths[path.Path] \n      newdata, err := json.Marshal(&path) \n      if err != nil { \n        log.Println(\"failed to marshal data (skipping):\", err) \n        return true, data, false \n      } \n      return true, newdata, false \n    }) \n  } else { \n    log.Println(\"  No changes\") \n  } \n} \n\n```", "```go\n./backup -db=\"./backupdata\" list\n\n```", "```go\n= ./test [Not yet archived]\n= ./test2 [Not yet archived]\n\n```", "```go\ngo build -o backupd\n\n```", "```go\n./backupd -db=\"../backup/backupdata/\" -archive=\"./archive\" - interval=5s\n\n```", "```go\nChecking...\nArchived 2 directories\n\n```", "```go\nChecking...\n No changes\nChecking...\n No changes\n\n```"]