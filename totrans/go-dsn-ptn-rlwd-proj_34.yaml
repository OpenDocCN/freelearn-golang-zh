- en: Chapter 8. Filesystem Backup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many solutions that provide filesystem backup capabilities. These
    include everything from apps such as Dropbox, Box, and Carbonite to hardware solutions
    such as Apple's Time Machine, Seagate, or network-attached storage products, to
    name a few. Most consumer tools provide some key automatic functionality, along
    with an app or website for you to manage your policies and content. Often, especially
    for developers, these tools don't quite do the things we need them to. However,
    thanks to Go's standard library (which includes packages such as `ioutil` and
    `os`), we have everything we need to build a backup solution that behaves exactly
    the way we need it to.
  prefs: []
  type: TYPE_NORMAL
- en: For our next project, we will build a simple filesystem backup for our source
    code projects that archive specified folders and save a snapshot of them every
    time we make a change. The change could be when we tweak a file and save it, when
    we add new files and folders, or even when we delete a file. We want to be able
    to go back to any point in time to retrieve old files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to structure projects that consist of packages and command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pragmatic approach to persisting simple data across tool executions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the `os` package allows you to interact with a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run code in an infinite timed loop while respecting *Ctrl + C*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `filepath.Walk` to iterate over files and folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to quickly determine whether the contents of a directory have changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `archive/zip` package to zip files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build tools that care about a combination of command-line flags and normal
    arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by listing some high-level acceptance criteria for our solution
    and the approach we want to take:'
  prefs: []
  type: TYPE_NORMAL
- en: The solution should create a snapshot of our files at regular intervals as we
    make changes to our source code projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to control the interval at which the directories are checked for changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code projects are primarily text-based, so zipping the directories to generate
    archives will save a lot of space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build this project quickly, while keeping a close watch over where we
    might want to make improvements later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any implementation decisions we make should be easily modified if we decide
    to change our implementation in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will build two command-line tools: the backend daemon that does the work
    and a user interaction utility that will let us list, add, and remove paths from
    the backup service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common in Go solutions to have, in a single project, both a package that
    allows other Go programmers to use your capabilities and a command-line tool that
    allows end users to use your programs.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the last chapter, a convention to structure such projects is emerging
    whereby we have the package in the main project project folder and the command-line
    tool inside a subfolder called `cmd` or `cmds` if you have multiple commands.
    Because all packages are equal in Go (regardless of the directory tree), you can
    import the package from the command subpackages, knowing you'll never need to
    import the commands from the project package (which is illegal as you can't have
    cyclical dependencies). This may seem like an unnecessary abstraction, but it
    is actually quite a common pattern and can be seen in the standard Go tool chain
    with examples such as `gofmt` and `goimports`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for our project, we are going to write a package called `backup`
    and two command-line tools: the daemon and the user interaction tool. We will
    structure our project in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason we don't just put code directly inside the `cmd` folder (even if
    we only had one command) is that when `go install` builds projects, it uses the
    name of the folder as the command name, and it wouldn't be very useful if all
    of our tools were called `cmd`.
  prefs: []
  type: TYPE_NORMAL
- en: The backup package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are first going to write the `backup` package, of which we will become the
    first customer when we write the associated tools. The package will be responsible
    for deciding whether directories have changed and need backing up or not as well
    as actually performing the backup procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Considering obvious interfaces first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the early things to think about when embarking on a new Go program is
    whether any interfaces stand out to you. We don't want to over-abstract or waste
    too much time upfront designing something that we know will change as we start
    to code, but that doesn't mean we shouldn't look for obvious concepts that are
    worth pulling out. If you're not sure, that is perfectly acceptable; you should
    write your code using concrete types and revisit potential abstractions after
    you have actually solved the problems.
  prefs: []
  type: TYPE_NORMAL
- en: However, since our code will archive files, the `Archiver` interface pops out
    as a candidate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder inside your `GOPATH/src` folder called `backup`, and add
    the following `archiver.go` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An `Archiver` interface will specify a method called `Archive`, which takes
    source and destination paths and returns an error. Implementations of this interface
    will be responsible for archiving the source folder and storing it in the destination
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining an interface up front is a nice way to get some concepts out of our
    heads and into the code; it doesn't mean that this interface can't change as we
    evolve our solution as long as we remember the power of simple interfaces. Also,
    remember that most of the I/O interfaces in the `io` package expose only a single
    method.
  prefs: []
  type: TYPE_NORMAL
- en: From the very beginning, we have made the case that while we are going to implement
    ZIP files as our archive format, we could easily swap this out later with another
    kind of `Archiver` format.
  prefs: []
  type: TYPE_NORMAL
- en: Testing interfaces by implementing them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the interface for our `Archiver` types, we are going to implement
    one that uses the ZIP file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `struct` definition to `archiver.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are not going to export this type, which might make you jump to the conclusion
    that users outside of the package won't be able to make use of it. In fact, we
    are going to provide them with an instance of the type for them to use in order
    to save them from having to worry about creating and managing their own types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following exported implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another handy side benefit to this trick is that the compiler will now be checking
    whether our zipper type properly implements the `Archiver` interface or not, so
    if you try to build this code, you''ll get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We see that our `zipper` type does not implement the `Archive` method as mandated
    in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the `Archive` method in test code to ensure that your types
    implement the interfaces they should. If you don''t need to use the variable,
    you can always throw it away using an underscore and you''ll still get the compiler
    help:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var _ Interface = (*Implementation)(nil)`'
  prefs: []
  type: TYPE_NORMAL
- en: To make the compiler happy, we are going to add the implementation of the `Archive`
    method for our `zipper` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `archiver.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also have to import the `archive/zip` package from the Go standard
    library. In our `Archive` method, we take the following steps to prepare writing
    to a ZIP file:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `os.MkdirAll` to ensure that the destination directory exists. The `0777`
    code represents the file permissions with which you may need to create any missing
    directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `os.Create` to create a new file as specified by the `dest` path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is created without an error, defer the closing of the file with
    `defer out.Close()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `zip.NewWriter` to create a new `zip.Writer` type that will write to the
    file we just created and defer the closing of the writer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have a `zip.Writer` type ready to go, we use the `filepath.Walk` function
    to iterate over the source directory, `src`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filepath.Walk` function takes two arguments: the root path and a callback
    function to be called for every item (files and folders) it encounters while iterating
    over the filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions are first class types in Go, which means you can use them as argument
    types as well as global functions and methods. The `filepath.Walk` function specifies
    the second argument type as `filepath.WalkFunc`, which is a function with a specific
    signature. As long as we adhere to the signature (correct input and return arguments)
    we can write inline functions rather than worrying about the `filepath.WalkFunc`
    type at all.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a quick look at the Go source code tell us that the signature for `filepath.WalkFunc`
    matches the function we are passing in `func(path string, info os.FileInfo, err
    error) error`
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filepath.Walk` function is recursive, so it will travel deep into subfolders
    too. The callback function itself takes three arguments: the full path of the
    file, the `os.FileInfo` object that describes the file or folder itself, and an
    error (it also returns an error in case something goes wrong). If any calls to
    the callback function result in an error (other than the special `SkipDir` error
    value) being returned, the operation will be aborted and `filepath.Walk` returns
    that error. We simply pass this up to the caller of `Archive` and let them worry
    about it, since there''s nothing more we can do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each item in the tree, our code takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `info.IsDir` method tells us that the item is a folder, we just return
    `nil`, effectively skipping it. There is no reason to add folders to ZIP archives
    because the path of the files will encode that information for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error is passed in (via the third argument), it means something went wrong
    when trying to access information about the file. This is uncommon, so we just
    return the error, which will eventually be passed out to the caller of `Archive`.
    As the implementor of `filepath.Walk`, you aren't forced to abort the operation
    here; you are free to do whatever makes sense in your individual case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `os.Open` to open the source file for reading, and if successful, defer
    its closing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `Create` on the `ZipWriter` object to indicate that we want to create a
    new compressed file and give it the full path of the file, which includes the
    directories it is nested inside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `io.Copy` to read all of the bytes from the source file and write them through
    the `ZipWriter` object to the ZIP file we opened earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `nil` to indicate no errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will not cover unit testing or **Test-driven Development** (**TDD**)
    practices, but feel free to write a test to ensure that our implementation does
    what it is meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are writing a package, spend some time commenting on the exported pieces
    so far. You can use `golint` to help you find anything you may have missed.
  prefs: []
  type: TYPE_NORMAL
- en: Has the filesystem changed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest problems our backup system has is deciding whether a folder
    has changed or not in a cross-platform, predictable, and reliable way. After all,
    there''s no point in creating a backup if nothing is different from the previous
    backup. A few things spring to mind when we think about this problem: should we
    just check the last modified date on the top-level folder? Should we use system
    notifications to be informed whenever a file we care about changes? There are
    problems with both of these approaches, and it turns out it''s not a simple problem
    to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out the `fsnotify` project at [https://fsnotify.org](https://fsnotify.org)
    (project source: [https://github.com/fsnotify](https://github.com/fsnotify)).
    The authors are attempting to build a cross-platform package for subscription
    to filesystem events. At the time of writing this, the project is still in its
    infancy and it not a viable option for this chapter, but in the future, it could
    well become the standard solution for filesystem events.'
  prefs: []
  type: TYPE_NORMAL
- en: We are, instead, going to generate an MD5 hash made up of all of the information
    that we care about when considering whether something has changed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `os.FileInfo` type, we can see that we can find out a lot of
    information about a file or folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To ensure we are aware of a variety of changes to any file in a folder, the
    hash will be made up of the filename and path (so if they rename a file, the hash
    will be different), size (if a file changes size, it's obviously different), the
    last modified date, whether the item is a file or folder, and the file mode bits.
    Even though we won't be archiving the folders, we still care about their names
    and the tree structure of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `dirhash.go` and add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We first create a new `hash.Hash` function that knows how to calculate MD5s
    before using `filepath.Walk` again to iterate over all of the files and folders
    inside the specified path directory. For each item, assuming there are no errors,
    we write the differential information to the hash generator using `io.WriteString`,
    which lets us write a string to `io.Writer` and `fmt.Fprintf`, which does the
    same but exposes formatting capabilities at the same time, allowing us to generate
    the default value format for each item using the `%v` format verb.
  prefs: []
  type: TYPE_NORMAL
- en: Once each file has been processed, and assuming no errors occurred, we then
    use `fmt.Sprintf` to generate the result string. The `Sum` method in `hash.Hash`
    calculates the final hash value with the specified values appended. In our case,
    we do not want to append anything since we've already added all of the information
    we care about, so we just pass `nil`. The `%x` format verb indicates that we want
    the value to be represented in hex (base 16) with lowercase letters. This is the
    usual way of representing an MD5 hash.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for changes and initiating a backup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the ability to hash a folder and perform a backup, we are going
    to put the two together in a new type called `Monitor`. The `Monitor` type will
    have a map of paths with their associated hashes, a reference to any `Archiver`
    type (of course, we'll use `backup.ZIP` for now), and a destination string representing
    where to put the archives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `monitor.go` and add the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to trigger a check for changes, we are going to add the following
    `Now` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Now` method iterates over every path in the map and generates the latest
    hash of that folder. If the hash does not match the hash from the map (generated
    the last time it checked), then it is considered to have changed and needs backing
    up again. We do this with a call to the as-yet-unwritten `act` method before then
    updating the hash in the map with this new hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give our users a high-level indication of what happened when they called
    `Now`, we are also maintaining a counter, which we increment every time we back
    up a folder. We will use this later to keep our end users up to date on what the
    system is doing without bombarding them with information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is helping us again and reminding us that we have yet to add the
    `act` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because we have done the heavy lifting in our ZIP `Archiver` type, all we have
    to do here is generate a filename, decide where the archive will go, and call
    the `Archive` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Archive` method returns an error, the `act` method and then the `Now`
    method will each return it. This mechanism of passing errors up the chain is very
    common in Go and allows you to either handle cases where you can do something
    useful to recover or else defer the problem to somebody else.
  prefs: []
  type: TYPE_NORMAL
- en: The `act` method in the preceding code uses `time.Now().UnixNano()` to generate
    a timestamp filename and hardcodes the `.zip` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoding is OK for a short while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hardcoding the file extension like we have is OK in the beginning, but if you
    think about it, we have blended concerns a little here. If we change the `Archiver`
    implementation to use RAR or a compression format of our making, the `.zip` extension
    would no longer be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before reading on, think about what steps you might take to avoid this hardcoding.
    Where does the filename extension decision live? What changes would you need to
    make in order to avoid hardcoding?
  prefs: []
  type: TYPE_NORMAL
- en: The right place for the filename extensions decision is probably in the `Archiver`
    interface, since it knows the kind of archiving it will be doing. So we could
    add an `Ext()` string method and access that from our `act` method. But we can
    add a little extra power with not much extra work by allowing `Archiver` authors
    to specify the entire filename format rather than just the extension instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `archiver.go`, update the `Archiver` interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `zipper` type needs to now implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can ask our `act` method to get the whole format string from the
    `Archiver` interface, update the `act` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The user command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first of two tools we will build allows the user to add, list, and remove
    paths for the backup daemon tool (which we will write later). You can expose a
    web interface or even use the binding packages for the desktop user interface
    integration, but we are going to keep things simple and build ourselves a command-line
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `cmds` inside the `backup` folder and create another
    `backup` folder inside that so you have `backup/cmds/backup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our new `backup` folder, add the following code to `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We first define our `fatalErr` variable and defer the function that checks to
    ensure that value is `nil`. If it is not, it will print the error along with flag
    defaults and exit with a nonzero status code. We then define a flag called `db`
    that expects the path to the `filedb` database directory before parsing the flags
    and getting the remaining arguments and ensuring that there is at least one.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting small data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to keep track of the paths and the hashes that we generate, we will
    need some kind of data storage mechanism that ideally works even when we stop
    and start our programs. We have lots of choices here: everything from a text file
    to a full horizontally scalable database solution. The Go ethos of simplicity
    tells us that building-in a database dependency to our little backup program would
    not be a great idea; rather, we should ask what the simplest way in which we can
    solve this problem is.'
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/matryer/filedb` package is an experimental solution for just
    this kind of problem. It lets you interact with the filesystem as though it were
    a very simple, schemaless database. It takes its design lead from packages such
    as `mgo` and can be used in cases where data querying needs are very simple. In
    `filedb`, a database is a folder, and a collection is a file where each line represents
    a different record. Of course, this could all change as the `filedb` project evolves,
    but the interface, hopefully, won't.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding dependencies such as this to a Go project should be done very carefully
    because over time, dependencies go stale, change beyond their initial scope, or
    disappear altogether in some cases. While it sounds counterintuitive, you should
    consider whether copying and pasting a few files into your project is a better
    solution than relying on an external dependency. Alternatively, consider vendoring
    the dependency by copying the entire package into the `vendor` folder of your
    command. This is akin to storing a snapshot of the dependency that you know works
    for your tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `filedb.Dial` function to connect with the `filedb` database.
    In actuality, nothing much happens here except specifying where the database is,
    since there are no real database servers to connect to (although this might change
    in the future, which is why such provisions exist in the interface). If that was
    successful, we defer the closing of the database. Closing the database does actually
    do something, since files may be open that need to be cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: Following the `mgo` pattern, next we specify a collection using the `C` method
    and keep a reference to it in the `col` variable. If an error occurs at any point,
    we assign it to the `fatalErr` variable and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store data, we are going to define a type called `path`, which will store
    the full path and the last hash value and use JSON encoding to store this in our
    `filedb` database. Add the following `struct` definition above the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Parsing arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we call `flag.Args` (as opposed to `os.Args`), we receive a slice of arguments
    excluding the flags. This allows us to mix flag arguments and non-flag arguments
    in the same tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our tool to be able to be used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To list all paths:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To achieve this, since we have already dealt with flags, we must check the first
    (non-flag) argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply switch on the first argument after setting it to lowercase (if
    the user types `backup LIST`, we still want it to work).
  prefs: []
  type: TYPE_NORMAL
- en: Listing the paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To list the paths in the database, we are going to use a `ForEach` method on
    the path''s `col` variable. Add the following code to the list case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We pass in a callback function to `ForEach`, which will be called for every
    item in that collection. We then unmarshal it from JSON into our `path` type,
    and just print it out using `fmt.Printf`. We return `false` as per the `filedb`
    interface, which tells us that returning `true` would stop iterating and that
    we want to make sure we list them all.
  prefs: []
  type: TYPE_NORMAL
- en: String representations for your own types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you print structs in Go in this way, using the `%s` format verbs, you can
    get some messy results that are difficult for users to read. If, however, the
    type implements a `String()` string method, it will be used instead, and we can
    use this to control what gets printed. Below the path struct, add the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `path` type how it should represent itself as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Adding paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a path, or many paths, we are going to iterate over the remaining arguments
    and call the `InsertJSON` method for each one. Add the following code to the `add`
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the user hasn't specified any additional arguments, for example if they just
    called `backup add` without typing any paths, we will return a fatal error. Otherwise,
    we do the work and print out the path string (prefixed with a `+` symbol) to indicate
    that it was successfully added. By default, we'll set the hash to the `Not yet
    archived` string literal this is an invalid hash but serves the dual purposes
    of letting the user know that it hasn't yet been archived as well as indicating
    as such to our code (given that a hash of the folder will never equal that string).
  prefs: []
  type: TYPE_NORMAL
- en: Removing paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove a path, or many paths, we use the `RemoveEach` method for the path''s
    collection. Add the following code to the `remove` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function we provide to `RemoveEach` expects us to return two bool
    types: the first one indicates whether the item should be removed or not, and
    the second one indicates whether we should stop iterating or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Using our new tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have completed our simple `backup` command-line tool. Let's look at it in
    action. Create a folder called `backupdata` inside `backup/cmds/backup`; this
    will become the `filedb` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the tool in a terminal by navigating to the `main.go` file and running
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If all is well, we can now add a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add another path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our program should yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove `test3` in order to make sure the `remove` functionality is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take us back to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We are now able to interact with the `filedb` database in a way that makes sense
    for our use case. Next, we build the daemon program that will actually use our
    `backup` package to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: The daemon backup tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `backup` tool, which we will call `backupd`, will be responsible for periodically
    checking the paths listed in the `filedb` database, hashing the folders to see
    whether anything has changed, and using the `backup` package to actually perform
    the archiving of the folders that need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `backupd` alongside the `backup/cmds/backup` folder,
    and let''s jump right into handling the fatal errors and flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You must be quite used to seeing this kind of code by now. We defer the handling
    of fatal errors before specifying three flags: `interval`, `archive`, and `db`.
    The `interval` flag represents the number of seconds between checks to see whether
    folders have changed, the `archive` flag is the path to the archive location where
    ZIP files will go, and the `db` flag is the path to the same `filedb` database
    that the `backup` command is interacting with. The usual call to `flag.Parse`
    sets the variables up and validates whether we''re ready to move on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to check the hashes of the folders, we are going to need an instance
    of `Monitor` that we wrote earlier. Append the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create `backup.Monitor` using the `archive` value as the `Destination`
    type. We'll use the `backup.ZIP` archiver and create a map ready for it to store
    the paths and hashes internally. At the start of the daemon, we want to load the
    paths from the database so that it doesn't archive unnecessarily as we stop and
    start things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You have seen this code earlier too; it dials the database and creates an object
    that allows us to interact with the `paths` collection. If anything fails, we
    set `fatalErr` and return.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicated structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we''re going to use the same path structure as we used in our user command-line
    tool program, we need to include a definition of it for this program too. Insert
    the following structure above the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Caching data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now query all existing paths and update the `Paths` map, which is a useful
    technique to increase the speed of a program, especially given slow or disconnected
    data stores. By loading the data into a cache (in our case, the `Paths` map),
    we can access it at lightning speed without having to consult the files each time
    we need information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the body of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using the `ForEach` method again allows us to iterate over all the paths in
    the database. We unmarshal the JSON bytes into the same `path` structure as we
    used in our other program and set the values in the `Paths` map. Assuming that
    nothing goes wrong, we do a final check to make sure there is at least one path,
    and if not, we return with an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One limitation to our program is that it will not dynamically add paths once
    it has started. The daemon would need to be restarted. If this bothers you, you
    can always build in a mechanism that updates the `Paths` map periodically or uses
    some other kind of configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next thing we need to do is perform a check on the hashes right away to
    see whether anything needs archiving before entering into an infinite timed loop
    where we perform the check again at regular, specified intervals.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop sounds like a bad idea; in fact, to some, it sounds like a
    bug. However, since we're talking about an infinite loop within this program,
    and since infinite loops can be easily broken with a simple `break` command, they're
    not as dramatic as they might sound. When we mix an infinite loop with a select
    statement that has no default case, we are able to run the code in a manageable
    way without gobbling up CPU cycles as we wait for something to happen. The execution
    will be blocked until one of the two channels receive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, to write an infinite loop is as simple as running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The instructions inside the braces get executed over and over again, as quickly
    as the machine running the code can execute them. Again, this sounds like a bad
    plan unless you're careful about what you're asking it to do. In our case, we
    are immediately initiating a `select` case on the two channels that will block
    safely until one of the channels has something interesting to say.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, as responsible programmers, we care about what happens when the
    user terminates our programs. So after a call to the `check` method (which doesn''t
    yet exist), we make a signal channel and use `signal.Notify` to ask for the termination
    signal to be given to the channel rather than it being handled automatically.
    In our infinite `for` loop, we select two possibilities: either the `timer` channel
    sends a message or the termination signal channel sends a message. If it''s the
    `timer` channel message, we call `check` again; if it''s `signalChan`, we go about
    terminating the program; otherwise, we''ll loop back and wait.'
  prefs: []
  type: TYPE_NORMAL
- en: The `time.After` function returns a channel that will send a signal (actually,
    the current time) after the specified time has elapsed. Since we are using `flag.Duration`,
    we can pass this (deferenced via `*`) as the `time.Duration` argument directly
    into the function. Using `flag.Duration` also means that users can specify time
    durations in a human readable way, such as `10s` for 10 seconds or `1m` for a
    minute.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return from the main function, causing the deferred statements to
    execute, such as closing the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Updating filedb records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that is left is for us is implement the `check` function that should call
    the `Now` method on the `Monitor` type and update the database with new hashes
    if there are any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `main` function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `check` function first tells the user that a check is happening before immediately
    calling `Now`. If the `Monitor` type did any work for us, which is to ask whether
    it archived any files, we output them to the user and go on to update the database
    with the new values. The `SelectEach` method allows us to change each record in
    the collection if we so wish by returning the replacement bytes. So we unmarshal
    the bytes to get the path structure, update the hash value, and return the marshaled
    bytes. This ensures that the next time we start a `backupd` process, it will do
    so with the correct hash values.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see whether our two programs play nicely together. You may want to open
    two terminal windows for this, since we'll be running two programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already added some paths to the database, so let''s use `backup` to
    see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the two test folders; if you don''t, refer to the *Adding paths*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In another window, navigate to the `backupd` folder and create our two test
    folders, called `test` and `test2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build `backupd` using the usual method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming all is well, we can now start the backup process, being sure to point
    the `db` path to the same path as we used for the `backup` program and specifying
    that we want to use a new folder called `archive` to store the ZIP files. For
    testing purposes, let''s specify an interval of `5` seconds in order to save time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, `backupd` should check the folders, calculate the hashes, note
    that they are different (to `Not yet archived`), and initiate the archive process
    for both folders. It will print the output that tells us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the newly created `archive` folder inside `backup/cmds/backupd` and note
    that it has created two subfolders: `test` and `test2`. Inside these are compressed
    archive versions of the empty folders. Feel free to unzip one and see; nothing
    very exciting so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, back in the terminal window, `backupd` has been checking the folders
    for changes again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In your favorite text editor, create a new text file inside the `test2` folder,
    containing the word `test`, and save it as `one.txt`. After a few seconds, you
    will see that `backupd` has noticed the new file and created another snapshot
    inside the `archive/test2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it has a different filename because the time is different, but if
    you unzip it, you will notice that it has indeed created a compressed archive
    version of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play around with the solution by taking the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the contents of the `one.txt` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a file to the `test` folder too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we successfully built a very simple backup system for your
    code projects. You can see how simple it would be to extend or modify the behavior
    of these programs. The scope for potential problems that you could go on to solve
    is limitless.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having a local archive destination folder like we did in the previous
    section, imagine mounting a network storage device and using that instead. Suddenly,
    you have off-site (or at least off-machine) backups of these vital files. You
    can easily set a Dropbox folder as the archive destination, which would mean that
    not only do you get access to the snapshots yourself, but a copy is also stored
    in the cloud and can even be shared with other users.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the `Archiver` interface to support `Restore` operations (which would
    just use the `encoding/zip` package to unzip the files) allows you to build tools
    that can peer inside the archives and access the changes of individual files,
    much like Time Machine on a Mac allows you to do. Indexing the files gives you
    the complete search across the entire history of your code, much like GitHub does.
  prefs: []
  type: TYPE_NORMAL
- en: Since the filenames are timestamps, you could have backupd retiring old archives
    to less active storage mediums or summarized the changes into a daily dump.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, backup software exists, is well tested, and is used throughout the
    world, and it may be a smart move to focus on solving problems that haven't been
    solved yet. But when it requires such little effort to write small programs to
    get things done, it is often worth doing because of the control it gives you.
    When you write the code, you can get exactly what you want without compromise,
    and it's down to each individual to make that call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we explored how easy Go''s standard library
    makes it to interact with the filesystem: opening files for reading, creating
    new files, and making directories. The `os` package mixed in with the powerful
    types from the `io` package, blended further with capabilities such as `encoding/zip`
    and others, gives a clear example of how extremely simple Go interfaces can be
    composed to deliver very powerful results.'
  prefs: []
  type: TYPE_NORMAL
