<html><head></head><body>
<div class="book" title="Interfaces" id="3279U1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Interfaces - signing a contract"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec022" class="calibre1"/>Interfaces - signing a contract</h2></div></div></div><p class="calibre10">An interface is something really simple but powerful. It's usually defined as a contract between the objects that implement it but this explanation isn't clear enough in my honest opinion for newcomers to the interface world.</p><p class="calibre10">A water-pipe is a contract too; whatever you pass through it must be a liquid. Anyone can use the pipe, and the pipe will transport whatever liquid you put in it (without knowing the content). The water-pipe is the interface that enforces that the users must pass liquids (and not something else).</p><p class="calibre10">Let's think about another example: a train. The railroads of a train are like an interface. A train must construct (implement) its width with a specified value so that it can enter the railroad but the railroad never knows exactly what it's carrying (passengers or cargo). So for example, an interface of the railroad will have the following aspect:</p><pre class="programlisting">type RailroadWideChecker interface { 
    CheckRailsWidth() int 
} 
</pre><p class="calibre10">The <code class="email">RailroadWideChecker</code> is the type our trains must implement to provide information about their width. The trains will verify that the train isn't too wide or too narrow to use its railroads:</p><pre class="programlisting">type Railroad struct { 
    Width int 
} 
 
func (r *Railroad) IsCorrectSizeTrain(r RailRoadWideChecker) bool { 
    return r.CheckRailsWidth() != r.Width 
} 
</pre><p class="calibre10">The <code class="email">Railroad</code> is implemented by an imaginary station object that contains the information about the width of the railroads in this station and that has a method to check whether a train fits the needs of the railroad with the <code class="email">IsCorrectSizeTrain</code> method. The <code class="email">IsCorrectSizeTrain</code> method receives an interface object which is a pointer to a train that implements this interface and returns a validation between the width of the train and the railroad:</p><pre class="programlisting">Type Train struct { 
    TrainWidth int 
} 
 
func (p *Train) CheckRailsWidth() int { 
    return p.TrainWidth 
} 
</pre><p class="calibre10">Now we have created a passenger's train. It has a field to contain its width and implements our <code class="email">CheckRailsWidth</code> interface method. This structure is considered to fulfill the needs of a <code class="email">RailRoadWideChecker</code> interface (because it has an implementation of the methods that the interfaces ask for).</p><p class="calibre10">So now, we'll create a railroad of <code class="email">10</code> units wide and two trains--one of <code class="email">10</code> units wide that fit the railroad size and another of <code class="email">15</code> units that cannot use the railroad.</p><pre class="programlisting">func main(){ 
    railroad := Railroad{Width:10} 
 
    passengerTrain := Train{TrainWidth: 10} 
    cargoTrain := Train {TrainWidth: 15} 
 
    canPassengerTrainPass := railroad.IsCorrectSizeTrain(passengerTrain) 
    canCargoTrainPass := railroad.IsCorrectSizeTrain(cargoTrain) 
 
    fmt.Printf("Can passenger train pass? %b\n", canPassengerTrainPass) 
    fmt.Printf("Can cargo train pass? %b\n", canCargoTrainPass) 
} 
</pre><p class="calibre10">Let's dissect this <code class="email">main</code> function. First, we created a railroad object of <code class="email">10</code> units called <code class="email">railroad</code>. Then two trains, of <code class="email">10</code> and <code class="email">15</code> units' width for passengers and cargo respectively. Then, we pass both objects to the railroad method that accepts interfaces of the <code class="email">RailroadWideChecker</code> interface. The railroad itself does not know the width of each train separately (we'll have a huge list of trains) but it has an interface that trains must implement so that it can ask for each width and returns a value telling you if a train can or cannot use of the railroads. Finally, the output of the call to <code class="email">printf</code> function is the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">Can passenger train pass? true</strong></span>
<span class="strong"><strong class="calibre2">Can cargo train pass? false</strong></span>
</pre><p class="calibre10">As I mentioned earlier, interfaces are so widely used during this book that it doesn't matter if it still looks confusing for the reader as they'll be plenty of examples during the book.</p></div></div></body></html>