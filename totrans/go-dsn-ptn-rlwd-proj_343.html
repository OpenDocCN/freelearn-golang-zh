<html><head></head><body>
<div class="book" title="Testing and TDD" id="335QG1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="The testing package"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec023" class="calibre1"/>The testing package</h2></div></div></div><p class="calibre10">Testing is very important in every programming language. Go creators knew it and decided to provide all libraries and packages needed for the test in the core package. You don't need any third-party library for testing or code coverage.</p><p class="calibre10">The package that allows for testing Go apps is called, conveniently, testing. We will create a small app that sums two numbers that we provide through the command line:</p><pre class="programlisting">func main() { 
    //Atoi converts a string to an int 
    a, _ := strconv.Atoi(os.Args[1]) 
    b, _ := strconv.Atoi(os.Args[2]) 
 
    result := sum(a,b) 
    fmt.Printf("The sum of %d and %d is %d\n", a, b, result) 
} 
 
func sum(a, b int) int { 
    return a + b 
} 
</pre><p class="calibre10">Let's execute our program in the terminal to get the sum:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go 3 4</strong></span>
<span class="strong"><strong class="calibre2">The sum of 3 and 4 is 7</strong></span>
</pre><p class="calibre10">By the way, we're using the <code class="email">strconv</code> package to convert strings to other types, in this case, to <code class="email">int</code>. The method <code class="email">Atoi</code> receives a string and returns an <code class="email">int</code> and an <code class="email">error</code> that, for simplicity, we are ignoring here (by using the underscore).</p><div class="informaltable" title="Note"><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre10">You can ignore variable returns by using the underscores if necessary, but usually, you don't want to ignore errors.</p></div><p class="calibre10">Ok, so let's write a test that checks the correct result of the sum. We're creating a new file called <code class="email">main_test.go</code>. By convention, test files are named like the files they're testing plus the <code class="email">_test</code> suffix:</p><pre class="programlisting">func TestSum(t *testing.T) { 
    a := 5 
    b := 6 
    expected := 11 
 
    res := sum(a, b) 
    if res != expected { 
        t.Errorf("Our sum function doens't work, %d+%d isn't %d\n", a, b, res) 
    } 
} 
</pre><p class="calibre10">Testing in Go is used by writing methods started with the prefix <code class="email">Test</code>, a test name, and the injection of the <code class="email">testing.T</code> pointer called <code class="email">t</code>. Contrary to other languages, there are no asserts nor special syntax for testing in Go. You can use Go syntax to check for errors and you call <code class="email">t</code> with information about the error in case it fails. If the code reaches the end of the <code class="email">Test</code> function without arising errors, the function has passed the tests.</p><p class="calibre10">To run a test in Go, you must use the <code class="email">go test -v</code> command (<code class="email">-v</code> is to receive verbose output from the test) keyword, as following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestSum</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestSum (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok   github.com/go-design-patterns/introduction/ex_xx_testing 0.001s</strong></span>
</pre><p class="calibre10">Our tests were correct. Let's see what happens if we break things on purpose and we change the expected value of the test from <code class="email">11</code> to <code class="email">10</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestSum (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    main_test.go:12: Our sum function doens't work, 5+6 isn't 10</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL  github.com/sayden/go-design-patterns/introduction/ex_xx_testing 0.002s</strong></span>
</pre><p class="calibre10">The test has failed (as we expected). The testing package provides the information you set on the test. Let's make it work again and check test coverage. Change the value of the variable <code class="email">expected</code> from <code class="email">10</code> to <code class="email">11</code> again and run the command <code class="email">go test -cover</code> to see code coverage:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -cover</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">coverage: 20.0% of statements</strong></span>
<span class="strong"><strong class="calibre2">ok  github.com/sayden/go-design-patterns/introduction/ex_xx_testing 0.001s</strong></span>
</pre><p class="calibre10">The <code class="email">-cover</code> options give us information about the code coverage for a given package. Unfortunately, it doesn't provide information about overall application coverage.</p></div></div></body></html>