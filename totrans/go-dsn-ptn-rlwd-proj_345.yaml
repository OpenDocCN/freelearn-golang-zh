- en: Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: Until now, most of our examples were applications. An application is defined
    by its `main` function and package. But with Go, you can also create pure libraries.
    In libraries, the package need not be called main nor do you need the `main` function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的大多数示例都是应用程序。应用程序由其`main`函数和包定义。但是，使用Go，你也可以创建纯库。在库中，包不必命名为`main`，也不需要`main`函数。
- en: As libraries aren't applications, you cannot build a binary file with them and
    you need the `main` package that is going to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为库不是应用程序，你不能用它们构建二进制文件，你需要使用将使用它们的`main`包。
- en: 'For example, let''s create an arithmetic library to perform common operations
    on integers: sums, subtractions, multiplications, and divisions. We''ll not get
    into many details about the implementation to focus on the particularities of
    Go''s libraries:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个算术库来执行整数上的常见操作：求和、减法、乘法和除法。我们不会深入实现细节，而是关注Go库的特定之处：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we need a name for our library; we set this name by giving a name to
    the entire package. This means that every file in this folder must have this package
    name too and the entire group of files composes the library called **arithmetic**
    too in this case (because it only contains one package). This way, we won''t need
    to refer to the filenames for this library and to provide the library name and
    path will be enough to import and use it. We have defined a `Sum` function that
    takes as many arguments as you need and that will return an integer that, during
    the scope of the function, is going to be called `res`. This allows us to initialize
    to `0` the value we''re returning. We defined a package (not the `main` package
    but a library one) and called it `arithmetic`. As this is a library package, we
    can''t run it from the command line directly so we''ll have to create the `main`
    function for it or a unit test file. For simplicity , we''ll create a `main` function
    that runs some of the operations now but let''s finish the library first:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的库起一个名字；我们通过给整个包命名来设置这个名称。这意味着这个文件夹中的每个文件都必须有这个包名，而且在这种情况下，整个文件组也构成了名为**算术**的库（因为它只包含一个包）。这样，我们就无需引用这个库的文件名，只需提供库名和路径就足够导入和使用它了。我们定义了一个`Sum`函数，它接受你需要的任意数量的参数，并将返回一个整数，在函数的作用域内将被称为`res`。这允许我们将返回的值初始化为`0`。我们定义了一个包（不是`main`包，而是一个库包），并将其命名为`arithmetic`。由于这是一个库包，我们不能直接从命令行运行它，所以我们将为它创建一个`main`函数或一个单元测试文件。为了简单起见，我们将创建一个`main`函数，现在运行一些操作，但让我们先完成库：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Subtraction` code will return `0` if the number of arguments is less than
    zero and the subtraction of all its arguments if it has two arguments or more:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subtraction`代码将在参数数量少于零时返回`0`，如果它有两个或更多参数，则返回所有参数的减法：'
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Multiply` function works in a similar fashion. It returns `0` when arguments
    are less than two and the multiplication of all its arguments when it has two
    or more. Finally, the `Division` code changes a bit because it will return an
    error if you ask it to divided by zero:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Multiply`函数以类似的方式工作。当参数少于两个时返回`0`，当有两个或更多参数时返回所有参数的乘积。最后，`Division`代码略有不同，因为它会在你要求除以零时返回错误：'
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So now we have our library finished, but we need a `main` function to use it
    as libraries cannot be converted to executable files directly. Our main function
    looks like the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的库已经完成，但我们需要一个`main`函数来使用它，因为库不能直接转换为可执行文件。我们的`main`函数看起来如下：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are performing an operation over every function that we have defined. Take
    a closer look at the `import` clause. It is taking the library we have written
    from its folder within `$GOPATH` that matches its URL in [https://bitbucket.org/](https://bitbucket.org/)
    . Then, to use every one of the functions that are defined within a library, you
    have to name the package name that the library has before each method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在对定义的每个函数执行操作。仔细看看`import`子句。它正在从匹配其URL在[https://bitbucket.org/](https://bitbucket.org/)的`$GOPATH`文件夹中获取我们编写的库。然后，为了使用库中定义的每个函数，你必须在每个方法之前命名库的包名。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have you realized that we called our functions with uppercase names? Because
    of the visibility rules we have seen before, exported functions in a package must
    have uppercase names or they won't be visible outside of the scope of the package.
    So, with this rule in mind, you cannot call a lowercase function or variable within
    a package and package calls will always be followed by uppercase names.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到我们使用大写字母来命名我们的函数？由于我们之前看到的可见性规则，包中的导出函数必须使用大写字母命名，否则它们将不会在包的作用域之外可见。因此，考虑到这个规则，你无法在包内调用小写字母的函数或变量，并且包调用总是跟随大写字母的名称。
- en: 'Let''s recall, some naming conventions about libraries:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下关于库的一些命名约定：
- en: Each file in the same folder must contain the same package name. Files don't
    need to be named in any special way.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一文件夹中的每个文件必须包含相同的包名。文件不需要以任何特殊的方式命名。
- en: A folder represents a package name within a library. The folder name will be
    used on import paths and it doesn't need to reflect the package name (although
    it's recommended for the parent package).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹代表库中的一个包名。文件夹名称将用于导入路径，并且不需要反映包名（尽管对于父包来说推荐这样做）。
- en: A library is one or many packages representing a tree that you import by the
    parent of all packages folder.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库是一个或多个包，代表一个树状结构，你可以通过所有包文件夹的父级来导入。
- en: You call things within a library by their package name.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过包名来调用库中的内容。
