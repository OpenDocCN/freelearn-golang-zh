- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, most of our examples were applications. An application is defined
    by its `main` function and package. But with Go, you can also create pure libraries.
    In libraries, the package need not be called main nor do you need the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: As libraries aren't applications, you cannot build a binary file with them and
    you need the `main` package that is going to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create an arithmetic library to perform common operations
    on integers: sums, subtractions, multiplications, and divisions. We''ll not get
    into many details about the implementation to focus on the particularities of
    Go''s libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need a name for our library; we set this name by giving a name to
    the entire package. This means that every file in this folder must have this package
    name too and the entire group of files composes the library called **arithmetic**
    too in this case (because it only contains one package). This way, we won''t need
    to refer to the filenames for this library and to provide the library name and
    path will be enough to import and use it. We have defined a `Sum` function that
    takes as many arguments as you need and that will return an integer that, during
    the scope of the function, is going to be called `res`. This allows us to initialize
    to `0` the value we''re returning. We defined a package (not the `main` package
    but a library one) and called it `arithmetic`. As this is a library package, we
    can''t run it from the command line directly so we''ll have to create the `main`
    function for it or a unit test file. For simplicity , we''ll create a `main` function
    that runs some of the operations now but let''s finish the library first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Subtraction` code will return `0` if the number of arguments is less than
    zero and the subtraction of all its arguments if it has two arguments or more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Multiply` function works in a similar fashion. It returns `0` when arguments
    are less than two and the multiplication of all its arguments when it has two
    or more. Finally, the `Division` code changes a bit because it will return an
    error if you ask it to divided by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we have our library finished, but we need a `main` function to use it
    as libraries cannot be converted to executable files directly. Our main function
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are performing an operation over every function that we have defined. Take
    a closer look at the `import` clause. It is taking the library we have written
    from its folder within `$GOPATH` that matches its URL in [https://bitbucket.org/](https://bitbucket.org/)
    . Then, to use every one of the functions that are defined within a library, you
    have to name the package name that the library has before each method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you realized that we called our functions with uppercase names? Because
    of the visibility rules we have seen before, exported functions in a package must
    have uppercase names or they won't be visible outside of the scope of the package.
    So, with this rule in mind, you cannot call a lowercase function or variable within
    a package and package calls will always be followed by uppercase names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall, some naming conventions about libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Each file in the same folder must contain the same package name. Files don't
    need to be named in any special way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A folder represents a package name within a library. The folder name will be
    used on import paths and it doesn't need to reflect the package name (although
    it's recommended for the parent package).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A library is one or many packages representing a tree that you import by the
    parent of all packages folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You call things within a library by their package name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
