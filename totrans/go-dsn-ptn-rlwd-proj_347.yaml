- en: Managing JSON data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理JSON数据
- en: 'JSON is the acronym for **JavaScript Object Notation** and, like the name implies,
    it''s natively JavaScript. It has become very popular and it''s the most used
    format for communication today. Go has very good support for JSON serialization/deserialization
    with the `JSON` package that does most of the dirty work for you. First of all,
    there are two concepts to learn when working with JSON:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是**JavaScript对象表示法**的缩写，正如其名所示，它是JavaScript的本地格式。它已经变得非常流行，并且是目前最常用的通信格式。Go语言对JSON序列化和反序列化提供了非常好的支持，`JSON`包为你做了大部分脏活。首先，当与JSON一起工作时，有两个概念需要了解：
- en: '**Marshal**: When you marshal an instance of a structure or object, you are
    converting it to its JSON counterpart.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元帅**：当你将结构体或对象的实例进行序列化时，你实际上是在将其转换为它的JSON等价物。'
- en: '**Unmarshal**: When you are unmarshaling some data, in the form of an array
    of bytes, you are trying to convert some JSON-expected-data to a known struct
    or object. You can also *unmarshal* to a `map[string]interface{}` in a fast but
    not very safe way to interpret the data as we''ll see now.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反序列化**：当你正在反序列化一些数据，以字节数组的形式时，你试图将一些预期的JSON数据转换为已知的结构体或对象。你也可以以快速但不太安全的方式将数据`反序列化`到`map[string]interface{}`中，正如我们现在将要看到的。'
- en: 'Let''s see an example of marshaling a string:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个序列化字符串的例子：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we have defined a variable called `packt` to hold the contents of the
    `packt` string. Then, we have used the `json` library to use the `Marshal` command
    with our new variable. This will return a new `bytearray` with the JSON and a
    flag to provide and `boolOK` result for the operation. When we print the contents
    of the bytes array (previous casting to string) the expected value appears. Note
    that `packt` appeared actually between quotes as the JSON representation would
    be.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`packt`的变量来保存`packt`字符串的内容。然后，我们使用了`json`库来使用`Marshal`命令与我们的新变量。这将返回一个新的`bytearray`，其中包含JSON和一个标志，用于提供`boolOK`操作结果。当我们打印字节数组的内容（之前的字符串转换）时，预期的值就会出现。注意，`packt`实际上出现在引号之间，因为JSON表示法就是这样。
