<html><head></head><body>
<div class="book" title="Managing JSON data" id="361C61-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="The encoding package"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec025" class="calibre1"/>The encoding package</h2></div></div></div><p class="calibre10">Have you realized that we have imported the package <code class="email">encoding/json</code>? Why is it prefixed with the word <code class="email">encoding</code>? If you take a look at Go's source code to the <code class="email">src/encoding</code> folder you'll find many interesting packages for encoding/decoding such as, XML, HEX, binary, or even CSV.</p><p class="calibre10">Now something a bit more complicated:</p><pre class="programlisting">type MyObject struct { 
    Number int 
    `json:"number"` 
    Word string 
} 
 
func main(){ 
    object := MyObject{5, "Packt"} 
    oJson, _ := json.Marshal(object) 
    fmt.Printf("%s\n", oJson) 
} 
<span class="strong"><strong class="calibre2">$ {"Number":5,"Word":"Packt"}</strong></span>
</pre><p class="calibre10">Conveniently, it also works pretty well with structures but what if I want to not use uppercase in the JSON data? You can define the output/input name of the JSON in the structure declaration:</p><pre class="programlisting">type MyObject struct { 
    Number int 
    Word string 
} 
 
func main(){ 
    object := MyObject{5, "Packt"} 
    oJson, _ := json.Marshal(object) 
    fmt.Printf("%s\n", oJson) 
} 
<span class="strong"><strong class="calibre2">$ {"number":5,"string":"Packt"}</strong></span>
</pre><p class="calibre10">We have not only lowercased the names of the keys, but we have even changed the name of the <code class="email">Word</code> key to string.</p><p class="calibre10">Enough of marshalling, we will receive JSON data as an array of bytes, but the process is very similar with some changes:</p><pre class="programlisting">type MyObject struct { 
Number int`json:"number"` 
Word string`json:"string"` 
} 
 
func main(){ 
    jsonBytes := []byte(`{"number":5, "string":"Packt"}`) 
    var object MyObject 
    err := json.Unmarshal(jsonBytes, &amp;object) 
    if err != nil { 
        panic(err) 
    } 
    fmt.Printf("Number is %d, Word is %s\n", object.Number, object.Word) 
} 
</pre><p class="calibre10">The big difference here is that you have to allocate the space for the structure first (with a zero value) and the pass the reference to the method <code class="email">Unmarshal</code> so that it tries to fill it. When you use <code class="email">Unmarshal</code>, the first parameter is the array of bytes that contains the JSON information while the second parameter is the reference (that's why we are using an ampersand) to the structure we want to fill. Finally, let's use a generic <code class="email">map[string]interface{}</code> method to hold the content of a JSON:</p><pre class="programlisting">type MyObject struct { 
    Number int     `json:"number"` 
    Word string    `json:"string"` 
} 
 
func main(){ 
    jsonBytes := []byte(`{"number":5, "string":"Packt"}`) 
    var dangerousObject map[string]interface{} 
    err := json.Unmarshal(jsonBytes, &amp;dangerousObject) 
    if err != nil { 
        panic(err) 
    } 
 
    fmt.Printf("Number is %d, ", dangerousObject["number"]) 
    fmt.Printf("Word is %s\n", dangerousObject["string"]) 
    fmt.Printf("Error reference is %v\n",  
dangerousObject["nothing"])
} 
$ Number is %!d(float64=5), Word is Packt 
Error reference is &lt;nil&gt; 
</pre><p class="calibre10">What happened in the result? This is why we described the object as dangerous. You can point to a <code class="email">nil</code> location when using this mode if you call a non-existing key in the JSON. Not only this, like in the example, it could also interpret a value as a <code class="email">float64</code> when it is simply a <code class="email">byte</code>, wasting a lot of memory.</p><p class="calibre10">So remember to just use <code class="email">map[string]interface{}</code> when you need dirty quick access to JSON data that is fairly simple and you have under control the type of scenarios described previously.</p></div></div></body></html>