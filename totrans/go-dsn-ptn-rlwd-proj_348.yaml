- en: The encoding package
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码包
- en: Have you realized that we have imported the package `encoding/json`? Why is
    it prefixed with the word `encoding`? If you take a look at Go's source code to
    the `src/encoding` folder you'll find many interesting packages for encoding/decoding
    such as, XML, HEX, binary, or even CSV.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有意识到我们已经导入了`encoding/json`包？为什么它以`encoding`为前缀？如果你查看Go的源代码到`src/encoding`文件夹，你会找到许多有趣的编码/解码包，例如XML、HEX、二进制，甚至是CSV。
- en: 'Now something a bit more complicated:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一些更复杂的事情：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Conveniently, it also works pretty well with structures but what if I want
    to not use uppercase in the JSON data? You can define the output/input name of
    the JSON in the structure declaration:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，它也很好地与结构体一起工作，但如果我们不想在JSON数据中使用大写字母怎么办？你可以在结构体声明中定义JSON的输出/输入名称：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have not only lowercased the names of the keys, but we have even changed
    the name of the `Word` key to string.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将键的名称转换为小写，甚至还将`Word`键的名称更改为字符串。
- en: 'Enough of marshalling, we will receive JSON data as an array of bytes, but
    the process is very similar with some changes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的序列化，我们将以字节数组的形式接收JSON数据，但过程非常相似，只是有一些变化：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The big difference here is that you have to allocate the space for the structure
    first (with a zero value) and the pass the reference to the method `Unmarshal`
    so that it tries to fill it. When you use `Unmarshal`, the first parameter is
    the array of bytes that contains the JSON information while the second parameter
    is the reference (that''s why we are using an ampersand) to the structure we want
    to fill. Finally, let''s use a generic `map[string]interface{}` method to hold
    the content of a JSON:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别是，你必须首先为结构体分配空间（使用零值），然后将引用传递给`Unmarshal`方法，以便它尝试填充。当你使用`Unmarshal`时，第一个参数是包含JSON信息的字节数组，而第二个参数是我们想要填充的结构体的引用（这就是为什么我们使用反引号的原因）。最后，让我们使用一个通用的`map[string]interface{}`方法来保存JSON的内容：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What happened in the result? This is why we described the object as dangerous.
    You can point to a `nil` location when using this mode if you call a non-existing
    key in the JSON. Not only this, like in the example, it could also interpret a
    value as a `float64` when it is simply a `byte`, wasting a lot of memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中发生了什么？这就是我们描述该对象为危险的原因。如果你在使用此模式时调用JSON中不存在的键，你可以指向一个`nil`位置。不仅如此，就像示例中那样，它还可能将一个值解释为`float64`，而实际上它只是一个`byte`，这会浪费很多内存。
- en: So remember to just use `map[string]interface{}` when you need dirty quick access
    to JSON data that is fairly simple and you have under control the type of scenarios
    described previously.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请记住，当你需要快速访问相对简单且你能够控制的JSON数据，并且需要使用`map[string]interface{}`时，请使用它。
