["```go\ngoapp version\n\n```", "```go\ngo version go1.6.1 (appengine-1.9.37) darwin/amd64\n\n```", "```go\npackage api \nimport ( \n  \"io\" \n  \"net/http\" \n) \nfunc init() { \n  http.HandleFunc(\"/\", handleHello) \n} \nfunc handleHello(w http.ResponseWriter, r *http.Request) { \n  io.WriteString(w, \"Hello from App Engine\") \n} \n\n```", "```go\napplication: YOUR_APPLICATION_ID_HERE \nversion: 1 \nruntime: go \napi_version: go1 \nhandlers: \n- url: /.* \n  script: _go_app \n\n```", "```go\ngoapp serve\n\n```", "```go\ngoapp deploy\n\n```", "```go\nCompleted update of app: theanswersapp, version: 1\n\n```", "```go\npackage defaultmodule \nfunc init() {} \n\n```", "```go\n/answersapp/api \n/answersapp/default \n/answersapp/web \n\n```", "```go\napplication: YOUR_APPLICATION_ID_HERE \nversion: 1 \nruntime: go \nmodule: api \napi_version: go1 \nhandlers: \n- url: /.* \n  script: _go_app \n\n```", "```go\napplication: YOUR_APPLICATION_ID_HERE \nversion: 1 \nruntime: go \nmodule: default \napi_version: go1 \nhandlers: \n- url: /.* \n  script: _go_app \n\n```", "```go\napplication: YOUR_APPLICATION_ID_HERE \ndispatch: \n  - url: \"*/api/*\" \n    module: api \n  - url: \"*/*\" \n    module: web \n\n```", "```go\ntype Question struct { \n  Key *datastore.Key `json:\"id\" datastore:\"-\"` \n  CTime time.Time `json:\"created\"` \n  Question string `json:\"question\"` \n  User UserCard `json:\"user\"` \n  AnswersCount int `json:\"answers_count\"` \n} \n\n```", "```go\nfunc (q Question) OK() error { \n  if len(q.Question) < 10 { \n    return errors.New(\"question is too short\") \n  } \n  return nil \n} \n\n```", "```go\nfunc (q *Question) Create(ctx context.Context) error { \n  log.Debugf(ctx, \"Saving question: %s\", q.Question) \n  if q.Key == nil { \n    q.Key = datastore.NewIncompleteKey(ctx, \"Question\", nil) \n  } \n  user, err := UserFromAEUser(ctx) \n  if err != nil { \n    return err \n  } \n  q.User = user.Card() \n  q.CTime = time.Now() \n  q.Key, err = datastore.Put(ctx, q.Key, q) \n  if err != nil { \n    return err \n  } \n  return nil \n} \n\n```", "```go\nfunc (q *Question) Update(ctx context.Context) error { \n  if q.Key == nil { \n    q.Key = datastore.NewIncompleteKey(ctx, \"Question\", nil) \n  } \n  var err error \n  q.Key, err = datastore.Put(ctx, q.Key, q) \n  if err != nil { \n    return err \n  } \n  return nil \n} \n\n```", "```go\nfunc GetQuestion(ctx context.Context, key *datastore.Key) \n(*Question, error) { \n  var q Question \n  err := datastore.Get(ctx, key, &q) \n  if err != nil { \n    return nil, err \n  } \n  q.Key = key \n  return &q, nil \n} \n\n```", "```go\ntype User struct { \n  Key *datastore.Key `json:\"id\" datastore:\"-\"` \n  UserID string `json:\"-\"` \n  DisplayName string `json:\"display_name\"` \n  AvatarURL string `json:\"avatar_url\"` \n  Score int `json:\"score\"` \n} \n\n```", "```go\nfunc UserFromAEUser(ctx context.Context) (*User, error) { \n  aeuser := user.Current(ctx) \n  if aeuser == nil { \n    return nil, errors.New(\"not logged in\") \n  } \n  var appUser User \n  appUser.Key = datastore.NewKey(ctx, \"User\", aeuser.ID, 0, nil) \n  err := datastore.Get(ctx, appUser.Key, &appUser) \n  if err != nil && err != datastore.ErrNoSuchEntity { \n    return nil, err \n  } \n  if err == nil { \n    return &appUser, nil \n  } \n  appUser.UserID = aeuser.ID \n  appUser.DisplayName = aeuser.String() \n  appUser.AvatarURL = gravatarURL(aeuser.Email) \n  log.Infof(ctx, \"saving new user: %s\", aeuser.String()) \n  appUser.Key, err = datastore.Put(ctx, appUser.Key, &appUser) \n  if err != nil { \n    return nil, err \n  } \n  return &appUser, nil \n} \n\n```", "```go\nfunc gravatarURL(email string) string { \n  m := md5.New() \n  io.WriteString(m, strings.ToLower(email)) \n  return fmt.Sprintf(\"//www.gravatar.com/avatar/%x\", m.Sum(nil)) \n} \n\n```", "```go\ntype UserCard struct { \n  Key         *datastore.Key `json:\"id\"` \n  DisplayName string         `json:\"display_name\"` \n  AvatarURL   string         `json:\"avatar_url\"` \n} \nfunc (u User) Card() UserCard { \n  return UserCard{ \n    Key:         u.Key, \n    DisplayName: u.DisplayName, \n    AvatarURL:   u.AvatarURL, \n  } \n} \n\n```", "```go\ntype Answer struct { \n  Key    *datastore.Key `json:\"id\" datastore:\"-\"` \n  Answer string         `json:\"answer\"` \n  CTime  time.Time      `json:\"created\"` \n  User   UserCard       `json:\"user\"` \n  Score  int            `json:\"score\"` \n} \nfunc (a Answer) OK() error { \n  if len(a.Answer) < 10 { \n    return errors.New(\"answer is too short\") \n  } \n  return nil \n} \n\n```", "```go\nfunc (a *Answer) Create(ctx context.Context, questionKey *datastore.Key) error { \n  a.Key = datastore.NewIncompleteKey(ctx, \"Answer\", questionKey) \n  user, err := UserFromAEUser(ctx) \n  if err != nil { \n    return err \n  } \n  a.User = user.Card() \n  a.CTime = time.Now() \n  err = datastore.RunInTransaction(ctx, func(ctx context.Context) error { \n    q, err := GetQuestion(ctx, questionKey) \n    if err != nil { \n      return err \n    } \n    err = a.Put(ctx) \n    if err != nil { \n      return err \n    } \n    q.AnswersCount++ \n    err = q.Update(ctx) \n    if err != nil { \n      return err \n    } \n    return nil \n  }, &datastore.TransactionOptions{XG: true}) \n  if err != nil { \n    return err \n  } \n  return nil \n} \n\n```", "```go\nfunc GetAnswer(ctx context.Context, answerKey *datastore.Key)  \n(*Answer, error) { \n  var answer Answer \n  err := datastore.Get(ctx, answerKey, &answer) \n  if err != nil { \n    return nil, err \n  } \n  answer.Key = answerKey \n  return &answer, nil \n} \n\n```", "```go\nfunc (a *Answer) Put(ctx context.Context) error { \n  var err error \n  a.Key, err = datastore.Put(ctx, a.Key, a) \n  if err != nil { \n    return err \n  } \n  return nil \n} \n\n```", "```go\nfunc GetAnswers(ctx context.Context, questionKey *datastore.Key)  \n([]*Answer, error) { \n  var answers []*Answer \n  answerKeys, err := datastore.NewQuery(\"Answer\"). \n    Ancestor(questionKey). \n    Order(\"-Score\"). \n    Order(\"-CTime\"). \n    GetAll(ctx, &answers) \n  for i, answer := range answers { \n    answer.Key = answerKeys[i] \n  } \n  if err != nil { \n    return nil, err \n  } \n  return answers, nil \n} \n\n```", "```go\ndatastore.NewQuery(\"Answer\"). \n Filter(\"Authorized =\", true) \n\n```", "```go\nfunc TopQuestions(ctx context.Context) ([]*Question, error) { \n  var questions []*Question \n  questionKeys, err := datastore.NewQuery(\"Question\"). \n    Order(\"-AnswersCount\"). \n    Order(\"-CTime\"). \n    Limit(25). \n    GetAll(ctx, &questions) \n  if err != nil { \n    return nil, err \n  } \n  for i := range questions { \n    questions[i].Key = questionKeys[i] \n  } \n  return questions, nil \n} \n\n```"]