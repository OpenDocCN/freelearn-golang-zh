- en: Chapter 9.  Building a Q&A Application for Google App Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google App Engine gives developers a **NoOps** (short for **No Operations**,
    indicating that developers and engineers have no work to do in order to have their
    code running and available) way of deploying their applications, and Go has been
    officially supported as a language option for some years now. Google's architecture
    runs some of the biggest applications in the world, such as Google Search, Google
    Maps, and Gmail, among others, so is a pretty safe bet when it comes to deploying
    our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Google App Engine allows you to write a Go application, add a few special configuration
    files, and deploy it to Google's servers, where it will be hosted and made available
    in a highly available, scalable, and elastic environment. Instances will automatically
    spin up to meet demand and tear down gracefully when they are no longer needed
    with a healthy free quota and preapproved budgets.
  prefs: []
  type: TYPE_NORMAL
- en: Along with running application instances, Google App Engine makes available
    a myriad of useful services, such as fast and high-scale data stores, search,
    memcache, and task queues. Transparent load balancing means you don't need to
    build and maintain additional software or hardware to ensure servers don't get
    overloaded and that requests are fulfilled quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build the API backend for a question and answer service
    similar to Stack Overflow or Quora and deploy it to Google App Engine. In the
    process, we'll explore techniques, patterns, and practices that can be applied
    to all such applications, as well as dive deep into some of the more useful services
    available to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the Google App Engine SDK for Go to build and test applications locally
    before deploying to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `app.yaml` to configure your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Modules in Google App Engine let you independently manage the different
    components that make up your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Google Cloud Datastore lets you persist and query data at scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sensible pattern for the modeling of data and working with keys in Google
    Cloud Datastore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Google App Engine Users API to authenticate people with Google
    accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pattern to embed denormalized data into entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ensure data integrity and build counters using transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why maintaining a good line of sight in code helps improve maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to achieve simple HTTP routing without adding a dependency to a third-party
    package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Google App Engine SDK for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run and deploy Google App Engine applications, we must download
    and configure the Go SDK. Head over to [https://cloud.google.com/appengine/downloads](https://cloud.google.com/appengine/downloads)
    and download the latest *Google App Engine SDK for Go* for your computer. The
    ZIP file contains a folder called `go_appengine`, which you should place in an
    appropriate folder outside of your `GOPATH`, for example, in `/Users/yourname/work/go_appengine`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible that the names of these SDKs will change in the future; if that
    happens, ensure that you consult the project home page for notes pointing you
    in the right direction at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will need to add the `go_appengine` folder to your `$PATH` environment
    variable, much like what you did with the `go` folder when you first configured
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your installation, open a terminal and type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The actual version of Go is likely to differ and is often a few months behind
    actual Go releases. This is because the Cloud Platform team at Google needs to
    do work on its end to support new releases of Go.
  prefs: []
  type: TYPE_NORMAL
- en: The `goapp` command is a drop-in replacement for the `go` command with a few
    additional subcommands; so you can do things like `goapp test` and `goapp vet`,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to deploy an application to Google's servers, we must use the Google
    Cloud Platform Console to set it up. In a browser, go to [https://console.cloud.google.com](https://console.cloud.google.com/)
    and sign in with your Google account. Look for the **Create Project** menu item,
    which often gets moved around as the console changes from time to time. If you
    already have some projects, click on a project name to open a submenu, and you'll
    find it in there.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you can't find what you're looking for, just search **Creating App Engine
    project** and you'll find it.
  prefs: []
  type: TYPE_NORMAL
- en: When the **New Project** dialog box opens, you will be asked for a name for
    your application. You are free to call it whatever you like (for example, Answers),
    but note the Project ID that is generated for you; you will need to refer to this
    when you configure your app later. You can also click on **Edit** and specify
    your own ID, but know that the value must be globally unique, so you'll have to
    get creative when thinking one up. In this book, we will use `answersapp` as the
    application ID, but you won't be able to use that one since it has already been
    taken.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to wait a minute or two for your project to get created; there's
    no need to watch the page you can continue and check back later.
  prefs: []
  type: TYPE_NORMAL
- en: App Engine applications are Go packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the Google App Engine SDK for Go is configured and our application
    has been created, we can start building it.
  prefs: []
  type: TYPE_NORMAL
- en: In Google App Engine, an application is just a normal Go package with an `init`
    function that registers handlers via the `http.Handle` or `http.HandleFunc` functions.
    It does not need to be the `main` package like normal tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder (somewhere inside your `GOPATH` folder) called `answersapp/api`
    and add the following `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will be familiar with most of this by now, but note that there is no `ListenAndServe`
    call, and the handlers are set inside the `init` function rather than `main`.
    We are going to handle every request with our simple `handleHello` function, which
    will just write a welcoming string.
  prefs: []
  type: TYPE_NORMAL
- en: The app.yaml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to turn our simple Go package into a Google App Engine application,
    we must add a special configuration file called `app.yaml`. The file will go at
    the root of the application or module, so create it inside the `answersapp/api`
    folder with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is a simple human-(and machine) readable configuration file in **YAML**
    (**Yet Another Markup Language** format refer to yaml.org for more details). The
    following table describes each property:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `application` | The application ID (copied and pasted from when you created
    your project). |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | Your application version number you can deploy multiple versions
    and even split traffic between them to test new features, among other things.
    We''ll just stick with version 1 for now. |'
  prefs: []
  type: TYPE_TB
- en: '| `runtime` | The name of the runtime that will execute your application. Since
    this is a Go book and since we''re building a Go application, we''ll use `go`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `api_version` | The `go1` api version is the runtime version supported by
    Google; you can imagine that this could be `go2` in the future. |'
  prefs: []
  type: TYPE_TB
- en: '| `handlers` | A selection of configured URL mappings. In our case, everything
    will be mapped to the special `_go_app` script, but you can also specify static
    files and folders here. |'
  prefs: []
  type: TYPE_TB
- en: Running simple applications locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we deploy our application, it makes sense to test it locally. We can
    do this using the App Engine SDK we downloaded earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to your `answersapp/api` folder and run the following command in a
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running simple applications locally](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This indicates that an API server is running locally on port `:56443`, an admin
    server is running on :`8000`, and our application (the module `default`) is now
    serving at `localhost:8080`, so let's hit that one in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running simple applications locally](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see by the `Hello from App Engine` response, our application is running
    locally. Navigate to the admin server by changing the port from `:8080` to `:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running simple applications locally](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the web portal that we can use to interrogate
    the internals of our application, including viewing running instances, inspecting
    the data store, managing task queues, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying simple applications to Google App Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To truly understand the power of Google App Engine''s NoOps promise, we are
    going to deploy this simple application to the cloud. Back in the terminal, stop
    the server by hitting *Ctrl*+*C* and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Your application will be packaged and uploaded to Google''s servers. Once it''s
    finished, you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It really is as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: You can prove this by navigating to the endpoint you get for free with every
    Google App Engine application, remembering to replace the application ID with
    your own: `https://YOUR_APPLICATION_ID_HERE.appspot.com/`.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the same output as earlier (the font may render differently since
    Google's servers will make assumptions about the content type that the local dev
    server doesn't).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application is being served over HTTP/2 and is already capable of pretty
    massive scale, and all we did was write a `config` file and a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Modules in Google App Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A module is a Go package that can be versioned, updated, and managed independently.
    An app might have a single module, or it can be made up of many modules, each
    distinct but part of the same application with access to the same data and services.
    An application must have a default module even if it doesn't do much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will be made up of the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **The module name** |'
  prefs: []
  type: TYPE_TB
- en: '| The obligatory default module | default |'
  prefs: []
  type: TYPE_TB
- en: '| An API package delivering RESTful JSON | api |'
  prefs: []
  type: TYPE_TB
- en: '| A static website serving HTML, CSS, and JavaScript that makes AJAX calls
    to the API module | web |'
  prefs: []
  type: TYPE_TB
- en: Each module will be a Go package and will, therefore, live inside its own folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's reorganize our project into modules by creating a new folder alongside
    the `api` folder called `default`.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to make our default module do anything other than use it for
    configuration, as we want our other modules to do all the meaningful work. But
    if we leave this folder empty, the Google App Engine SDK will complain that it
    has nothing to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `default` folder, add the following placeholder `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This file does nothing except allow our `default` module to exist
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would have been nice for our package names to match the folders, but `default`
    is a reserved keyword in Go, so we have a good reason to break that rule.
  prefs: []
  type: TYPE_NORMAL
- en: The other module in our application will be called `web`, so create another
    folder alongside the `api` and `default` folders called `web`. In this chapter,
    we are only going to build the API for our application and cheat by downloading
    the web module.
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the project home page at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints),
    access the content for **Second Edition**, and look for the download link for
    the *web components for* [Chapter 9](part0201_split_000.html#5VM122-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 9.  Building a Q&A Application for Google App Engine"), *Building a Q&A
    Application for Google App Engine* in the Downloads section of the `README` file.
    The ZIP file contains the source files for the web component, which should be
    unzipped and placed inside the `web` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our application structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Specifying modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To specify which module our `api` package will become, we must add a property
    to the `app.yaml` inside our **api** folder. Update it to include the `module`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our default module will need to be deployed as well, we also need to
    add an `app.yaml` configuration file to it. Duplicate the `api/app.yaml` file
    inside `default/app.yaml`, changing the module to `default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Routing to modules with dispatch.yaml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to route traffic appropriately to our modules, we will create another
    configuration file called `dispatch.yaml`, which will let us map URL patterns
    to the modules.
  prefs: []
  type: TYPE_NORMAL
- en: We want all traffic beginning with the `/api/` path to be routed to the `api`
    module and everything else to the `web` module. As mentioned earlier, we won't
    expect our `default` module to handle any traffic, but it will have more utility
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `answersapp` folder (alongside our module folders not inside any of
    the module folders), create a new file called `dispatch.yaml` with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The same `application` property tells the Google App Engine SDK for Go which
    application we are referring to, and the `dispatch` section routes URLs to modules.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Datastore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the services available to App Engine developers is Google Cloud Datastore,
    a NoSQL document database built for automatic scaling and high performance. Its
    limited featureset guarantees very high scale, but understanding the caveats and
    best practices is vital to a successful project.
  prefs: []
  type: TYPE_NORMAL
- en: Denormalizing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers with experience of relational databases (RDBMS) will often aim to
    reduce data redundancy (trying to have each piece of data appear only once in
    their database) by **normalizing** data, spreading it across many tables, and
    adding references (foreign keys) before joining it back via a query to build a
    complete picture. In schemaless and NoSQL databases, we tend to do the opposite.
    We **denormalize** data so that each document contains the complete picture it
    needs, making read times extremely fast since it only needs to go and get a single
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider how we might model tweets in a relational database such
    as MySQL or Postgres:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Denormalizing data](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A tweet itself contains only its unique ID, a foreign key reference to the Users
    table representing the author of the tweet, and perhaps many URLs that were mentioned
    in `TweetBody`.
  prefs: []
  type: TYPE_NORMAL
- en: One nice feature of this design is that a user can change their Name or AvatarURL
    and it will be reflected in all of their tweets, past and future, something you
    wouldn't get for free in a denormalized world.
  prefs: []
  type: TYPE_NORMAL
- en: However, in order to present a tweet to the user, we must load the tweet itself,
    look up (via a join) the user to get their name and avatar URL, and then load
    the associated data from the URLs table in order to show a preview of any links.
    At scale, this becomes difficult because all three tables of data might well be
    physically separated from each other, which means lots of things need to happen
    in order to build up this complete picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what a denormalized design would look like instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Denormalizing data](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We still have the same three buckets of data, except that now our tweet contains
    everything it needs in order to render to the user without having to look up data
    from anywhere else. The hardcore relational database designers out there are realizing
    what this means by now, and it is no doubt making them feel uneasy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this approach means that:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is repeated - `AvatarURL` in User is repeated as `UserAvatarURL` in the
    tweet (waste of space, right?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user changes their `AvatarURL`, `UserAvatarURL` in the tweet will be
    out of date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database design, at the end of the day, comes down to physics. We are deciding
    that our tweet is going to be read far more times than it is going to be written,
    so we'd rather take the pain upfront and take a hit in storage. There's nothing
    wrong with repeated data as long as there is an understanding about which set
    is the master set and which is duplicated for speed.
  prefs: []
  type: TYPE_NORMAL
- en: Changing data is an interesting topic in itself, but let's think about a few
    reasons why we might be OK with the trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the speed benefit to reading tweets is probably worth the unexpected
    behavior of changes to master data not being reflected in historical documents;
    it would be perfectly acceptable to decide to live with this emerged functionality
    for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we might decide that it makes sense to keep a snapshot of data at
    a specific moment in time. For example, imagine if someone tweets asking whether
    people like their profile picture. If the picture changed, the tweet context would
    be lost. For a more serious example, consider what might happen if you were pointing
    to a row in an Addresses table for an order delivery and the address later changed.
    Suddenly, the order might look like it was shipped to a different place.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, storage is becoming increasingly cheaper, so the need for normalizing
    data to save space is lessened. Twitter even goes as far as copying the entire
    tweet document for each of your followers. 100 followers on Twitter means that
    your tweet will be copied at least 100 times, maybe more for redundancy. This
    sounds like madness to relational database enthusiasts, but Twitter is making
    smart trade-offs based on its user experience; they'll happily spend a lot of
    time writing a tweet and storing it many times to ensure that when you refresh
    your feed, you don't have to wait very long to get updates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to get a sense of the scale of this, check out the Twitter API and
    look at what a tweet document consists of. It's a lot of data. Then, go and look
    at how many followers Lady Gaga has. This has become known in some circles as
    "the Lady Gaga problem" and is addressed by a variety of different technologies
    and techniques that are out of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of good NoSQL design practices, let's implement
    the types, functions, and methods required to drive the data part of our API.
  prefs: []
  type: TYPE_NORMAL
- en: Entities and data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To persist data in Google Cloud Datastore, we need a struct to represent each
    entity. These entity structures will be serialized and deserialized when we save
    and load data through the `datastore` API. We can add helper methods to perform
    the interactions with the data store, which is a nice way to keep such functionality
    physically close to the entities themselves. For example, we will model an answer
    with a struct called `Answer` and add a `Create` method that in turn calls the
    appropriate function from the `datastore` package. This prevents us from bloating
    our HTTP handlers with lots of data access code and allows us to keep them clean
    and simple instead.
  prefs: []
  type: TYPE_NORMAL
- en: One of the foundation blocks of our application is the concept of a question.
    A question can be asked by a user and answered by many. It will have a unique
    ID so that it is addressable (referable in a URL), and we'll store a timestamp
    of when it was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside `answersapp` called `questions.go` and add the following
    `struct` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The structure describes a question in our application. Most of it will seem
    quite obvious, as we've done similar things in the previous chapters. The `UserCard`
    struct represents a denormalized `User` entity, both of which we'll add later.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can import the `datastore` package in your Go project using this: `import
    "google.golang.org/appengine/datastore"`'
  prefs: []
  type: TYPE_NORMAL
- en: It's worth spending a little time understanding the `datastore.Key` type.
  prefs: []
  type: TYPE_NORMAL
- en: Keys in Google Cloud Datastore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every entity in Datastore has a key, which uniquely identifies it. They can
    be made up of either a string or an integer depending on what makes sense for
    your case. You are free to decide the keys for yourself or let Datastore automatically
    assign them for you; again, your use case will usually decide which is the best
    approach to take and we'll explore both in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Keys are created using the `datastore.NewKey` and `datastore.NewIncompleteKey`
    functions and are used to put and get data into and out of Datastore via the `datastore.Get`
    and `datastore.Put` functions.
  prefs: []
  type: TYPE_NORMAL
- en: In Datastore, keys and entity bodies are distinct, unlike in MongoDB or SQL
    technologies, where it is just another field in the document or record. This is
    why we are excluding `Key` from our `Question` struct with the `datastore:"-"`
    field tag. Like the `json` tags, this indicates that we want Datastore to ignore
    the `Key` field altogether when it is getting and putting data.
  prefs: []
  type: TYPE_NORMAL
- en: Keys may optionally have parents, which is a nice way of grouping associated
    data together and Datastore makes certain assurances about such groups of entities,
    which you can read more about in the Google Cloud Datastore documentation online.
  prefs: []
  type: TYPE_NORMAL
- en: Putting data into Google Cloud Datastore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we save data into Datastore, we want to ensure that our question is
    valid. Add the following method underneath the Question struct definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `OK` function will return an error if something is wrong with the question,
    or else it will return `nil`. In this case, we just check to make sure the question
    has at least 10 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To persist this data in the data store, we are going to add a method to the
    `Question` struct itself. At the bottom of `questions.go`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Create` method takes a pointer to `Question` as the receiver, which is
    important because we want to make changes to the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the receiver was `(q Question)` without `*`, we would get a copy of the question
    rather than a pointer to it, and any changes we made to it would only affect our
    local copy and not the original `Question` struct itself.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is use `log` (from the [https://godoc.org/google.golang.org/appengine/log](https://godoc.org/google.golang.org/appengine/log) package)
    to write a debug statement saying we are saving the question. When you run your
    code in a development environment, you will see this appear in the terminal; in
    production, it goes into a dedicated logging service provided by Google Cloud
    Platform.
  prefs: []
  type: TYPE_NORMAL
- en: If the key is `nil` (that means this is a new question), we assign an incomplete
    key to the field, which informs Datastore that we want it to generate a key for
    us. The three arguments we pass are `context.Context` (which we must pass to all
    datastore functions and methods), a string describing the kind of entity, and
    the parent key; in our case, this is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know there is a key in place, we call a method (which we will add later)
    to get or create `User` from an App Engine user and set it to the question and
    then set the `CTime` field (created time) to `time.Now`, timestamping the point
    at which the question was asked.
  prefs: []
  type: TYPE_NORMAL
- en: One we have our `Question` function in good shape, we call `datastore.Put` to
    actually place it inside the data store. As usual, the first argument is `context.Context`,
    followed by the question key and the question entity itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Google Cloud Datastore treats keys as separate and distinct from entities,
    we have to do a little extra work if we want to keep them together in our own
    code. The `datastore.Put` method returns two arguments: the complete key and `error`.
    The key argument is actually useful because we''re sending in an incomplete key
    and asking the data store to create one for us, which it does during the put operation.
    If successful, it returns a new `datastore.Key` object to us, representing the
    completed key, which we then store in our `Key` field in the `Question` object.'
  prefs: []
  type: TYPE_NORMAL
- en: If all is well, we return `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another helper to update an existing question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is very similar except that it doesn't set the `CTime` or `User`
    fields, as they will already have been set.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from Google Cloud Datastore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading data is as simple as putting it with the `datastore.Get` method, but
    since we want to maintain keys in our entities (and `datastore` methods don''t
    work like that), it''s common to add a helper function like the one we are going
    to add to `questions.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `GetQuestion` function takes `context.Context` and the `datastore.Key` method
    of the question to get. It then does the simple task of calling `datastore.Get`
    and assigning the key to the entity before returning it. Of course, errors are
    handled in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: This is a nice pattern to follow so that users of your code know that they never
    have to interact with `datastore.Get` and `datastore.Put` directly but rather
    use the helpers that can ensure the entities are properly populated with the keys
    (along with any other tweaks that they might want to do before saving or after
    loading).
  prefs: []
  type: TYPE_NORMAL
- en: Google App Engine users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another service we are going to make use of is the Google App Engine Users API,
    which provides the authentication of Google accounts (and Google Apps accounts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `users.go` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `Question` struct, we have `Key` and a few fields that make up
    the `User` entity. This struct represents an object that belongs to our application
    that describes a user; we will have one for every authenticated user in our system,
    but this isn't the same user object that we'll get from the Users API.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the [https://godoc.org/google.golang.org/appengine/user](https://godoc.org/google.golang.org/appengine/user) package
    and calling the `user.Current(context.Context)` function will return either nil
    (if no user is authenticated) or a `user.User` object. This object belongs to
    the Users API and isn't suitable for our data store, so we need to write a helper
    function that will translate the App Engine user into our `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Watch out that `goimports` doesn't automatically import `os/user` instead; sometimes
    it's best if you handle imports manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `users.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We get the currently authenticated user by calling `user.Current`, and if it
    is `nil`, we return with an error. This means that the user is not logged in and
    the operation cannot complete. Our web package will be checking and ensuring that
    users are logged in for us, so by the time they hit an API endpoint, we'll expect
    them to be authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `appUser` variable (which is of our `User` type) and set
    `datastore.Key`. This time, we aren't making an incomplete key; instead, we are
    using `datastore.NewKey` and specifying a string ID, matching the User API ID.
    This key predictability means that not only will there only be one `User` entity
    per authenticated user in our application, but it also allows us to load a `User`
    entity without having to use a query.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we had the App Engine User ID as a field instead, we would need to do a query
    to find the record we are interested in. Querying is a more expensive operation
    compared to a direct `Get` method, so this approach is always preferred if you
    can do it.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `datastore.Get` to attempt to load the `User` entity. If this is
    the first time the user has logged in, there will be no entity and the returned
    error will be the special `datastore.ErrNoSuchEntity` variable. If that's the
    case, we set the appropriate fields and use `datastore.Put` to save it. Otherwise,
    we just return the loaded `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are checking for early returns in this function. This is to ensure
    that it is easy to read the execution flow of our code without having to follow
    it in and out of indented blocks. I call this the line of sight of code and have
    written about it on my blog at [https://medium.com/@matryer](https://medium.com/@matryer).
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''ll use Gravatar again for avatar pictures, so add the following
    helper function to the bottom of `users.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Embedding denormalized data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you recall, our Question type doesn't take the author as `User`; rather,
    the type was `UserCard`. When we embed denormalized data into other entities,
    sometimes we will want them to look slightly different from the master entity.
    In our case, since we do not store the key in the `User` entity (remember the
    `Key` fields have `datastore:"-"`), we need to have a new type that stores the
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `users.go`, add the `UserCard` struct and the associated helper
    method for `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that `UserCard` doesn't specify a `datastore` tag, so the `Key` field will
    indeed be persisted in the data store. Our `Card()` helper function just builds
    and returns `UserCard` by copying the values of each field. This seems wasteful
    but offers great control, especially if you want embedded data to look very different
    from its original entity.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in Google Cloud Datastore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transactions allow you to specify a series of changes to the data store and
    commit them as one. If any of the individual operations fails, the whole transaction
    will not be applied. This is extremely useful if you want to maintain counters
    or have multiple entities that depend on each other's state. During a transaction
    in Google Cloud Datastore, all entities that are read are locked (other code is
    prevented from making changes) until the transaction is complete, providing an
    additional sense of security and preventing data races.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you were building a bank (it seems crazy, but the guys at Monzo in London
    are indeed building a bank using Go), you might represent user accounts as an
    entity called `Account`. To transfer money from one account to another, you'd
    need to make sure the money was deducted from account A and deposited into account
    B as a single transaction. If either fails, people aren't going to be happy (to
    be fair, if the deduction operation failed, the owner of account A would probably
    be happy because B would get the money without it costing A anything).
  prefs: []
  type: TYPE_NORMAL
- en: To see where we are going to use transactions, let's first add model answers
    to the questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `answers.go` and add the following struct and validation
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Answer` is similar to a question, has `datastore.Key` (which will not be persisted),
    has `CTime` to capture the timestamp, and embeds `UserCard` (representing the
    person answering the question). It also has a `Score` integer field, which will
    go up and down as users vote on the answers.'
  prefs: []
  type: TYPE_NORMAL
- en: Using transactions to maintain counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `Question` struct has a field called `AnswerCount`, where we intend to store
    an integer that represents the number of answers that a question has solicited.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at what can happen if we don''t use a transaction to keep
    track of the `AnswerCount` field by tracking the concurrent activity of answers
    4 and 5 of a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Step** | **Answer 4** | **Answer 5** | **Question.AnswerCount** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Load question | Load question | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | AnswerCount=3 | AnswerCount=3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | AnswerCount++ | AnswerCount++ | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | AnswerCount=4 | AnswerCount=4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Save the answer and question | Save the answer and question | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'You can see from the table that without locking Question, AnswerCount would
    end up being 4 instead of 5 if the answers came in at the same time. Locking with
    a transaction will look more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Step** | **Answer 4** | **Answer 5** | **Question.AnswerCount** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Lock the question | Lock the question | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | AnswerCount=3 | Waiting for unlock | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | AnswerCount++ | Waiting for unlock | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Save the answer and question | Waiting for unlock | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Release lock | Waiting for unlock | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Finished | Lock the question | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 |  | AnswerCount=4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 |  | AnswerCount++ | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 |  | Save the answer and question | 5 |'
  prefs: []
  type: TYPE_TB
- en: In this case, whichever answer obtains the lock first will perform its operation,
    and the other operation will wait before continuing. This is likely to slow down
    the operation (since it has to wait for the other one to finish), but that's a
    price worth paying in order to get the numbers right.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's best to keep the amount of work inside a transaction as small as possible
    because you are essentially blocking other people while the transaction is underway.
    Outside of transactions, Google Cloud Datastore is extremely fast because it isn't
    making the same kinds of guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, we use the `datastore.RunInTransaction` function. Add the following
    to `answers.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We first create a new incomplete key (using the `Answer` kind) and set the parent
    as the question key. This will mean that the question will become the ancestor
    to all these answers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ancestor keys are special in Google Cloud Datastore, and it is recommended that
    you read about the nuances behind them in the documentation on the Google Cloud
    Platform website.
  prefs: []
  type: TYPE_NORMAL
- en: Using our `UserFromAEUser` function, we get the user who is answering the question
    and set `UserCard` inside `Answer` before setting `CTime` to the current time,
    as done earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we start our transaction by calling the `datastore.RunInTransaction` function
    that takes a context as well as a function where the transactional code will go.
    There is a third argument, which is a set of `datastore.TransactionOptions` that
    we need to use in order to set `XG` to `true`, which informs the data store that
    we'll be performing a transaction across entity groups (both `Answer` and `Question`
    kinds).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to writing your own functions and designing your own APIs, it
    is highly recommended that you place any function arguments at the end; otherwise,
    inline function blocks such as the ones in the preceding code obscure the fact
    that there is another argument afterwards. It's quite difficult to realize that
    the `TransactionOptions` object is an argument being passed into the `RunInTransaction`
    function, and I suspect somebody on the Google team regrets this decision.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions work by providing a new context for us to use, which means that
    code inside the transaction function looks the same, as if it weren't in a transaction.
    This is a nice piece of API design (and it means that we can forgive the function
    for not being the final argument).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the transaction function, we use our `GetQuestion` helper to load the
    question. Loading data inside the transaction function is what obtains a lock
    on it. We then put the answer to save it, update the `AnswerCount` integer, and
    update the question. If all is well (provided none of these steps returns an error),
    the answer will be saved and `AnswerCount` will increase by one.
  prefs: []
  type: TYPE_NORMAL
- en: If we do return an error from our transaction function, the other operations
    are canceled and the error is returned. If that happens, we'll just return that
    error from our `Answer.Create` method and let the user try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add our `GetAnswer` helper, which is similar to our `GetQuestion`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to add our `Put` helper method in `answers.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These two functions are very similar to the `GetQuestion` and `Question.Put`
    methods, but let's resist the temptation of abstracting it and drying up the code
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding early abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copying and pasting is generally seen by programmers as a bad thing because
    it is usually possible to abstract the general idea and **DRY** (**Don't repeat
    yourself**) up the code. However, it is worth resisting the temptation to do this
    right away because it is very easy to design a bad abstraction, which you are
    then stuck with since your code will start to depend on it. It is better to duplicate
    the code in a few places first and later revisit them to see whether a sensible
    abstraction is lurking there.
  prefs: []
  type: TYPE_NORMAL
- en: Querying in Google Cloud Datastore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only been putting and getting single objects into and out of
    Google Cloud Datastore. When we display a list of answers to a question, we want
    to load all of these answers in a single operation, which we can do with `datastore.Query`.
  prefs: []
  type: TYPE_NORMAL
- en: The querying interface is a fluent API, where each method returns the same object
    or a modified object, allowing you to chain calls together. You can use it to
    build up a query consisting of ordering, limits, ancestors, filters, and so on.
    We will use it to write a function that will load all the answers for a given
    question, showing the most popular (those with a higher `Score` value) first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function to `answers.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We first create an empty slice of pointers to `Answer` and use `datastore.NewQuery`
    to start building a query. The `Ancestor` method indicates that we're looking
    only for answers that belong to the specific question, where the `Order` method
    calls specify that we want to first order by descending `Score` and then by the
    newest first. The `GetAll` method performs the operation, which takes in a pointer
    to our slice (where the results will go) and returns a new slice containing all
    the keys.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order of the keys returned will match the order of the entities in the slice.
    This is how we know which key corresponds to each item.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are keeping keys and the entity fields together, we range over the
    answers and assign `answer.Key` to the corresponding `datastore.Key` argument
    returned from `GetAll`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are keeping our API simple for the first version by not implementing paging,
    but ideally you would need to; otherwise, as the number of questions and answers
    grows, you will end up trying to deliver everything in a single request, which
    would overwhelm the user and maybe the servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had a step in our application of authorizing the answer (to protect it
    from spam or inappropriate content), we might want to add an additional filter
    for `Authorized` to be `true`, in which case we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on querying and filtering, consult the Google Cloud Datastore
    API documentation online.
  prefs: []
  type: TYPE_NORMAL
- en: Another place where we need to query data is when we show the top questions
    on the home page of our app. Our first version of top questions will just show
    those questions that have the most answers; we consider them to be the most interesting,
    but you could change this functionality in the future without breaking the API
    to order by score or even question views.
  prefs: []
  type: TYPE_NORMAL
- en: We will build `Query` on the `Question` kind and use the `Order` method to first
    order by the number of answers (with the highest first), followed by time (also,
    highest/latest first). We will also use the `Limit` method to make sure we only
    select the top 25 questions for this API. Later, if we implement paging, we can
    even make this dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `questions.go`, add the `TopQuestions` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code is similar to loading the answers, and we end up returning a slice
    of `Question` objects or an error.
  prefs: []
  type: TYPE_NORMAL
- en: Votes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have modeled questions and answers in our application, it's time
    to think about how voting might work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s design it a little:'
  prefs: []
  type: TYPE_NORMAL
- en: Users vote answers up and down based on their opinion of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers are ordered by their score so the best ones appear first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each person is allowed one vote per answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user votes again, they should replace their previous vote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will make use of a few things we have learned so far in this chapter; transactions
    will help us ensure the correct score is calculated for answers, and we'll use
    predictable keys again to ensure that each person gets only one vote per answer.
  prefs: []
  type: TYPE_NORMAL
- en: We will first build a structure to represent each vote and use field tags to
    be a little more specific about how we want the data store to index our data.
  prefs: []
  type: TYPE_NORMAL
