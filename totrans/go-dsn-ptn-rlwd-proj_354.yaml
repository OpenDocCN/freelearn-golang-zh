- en: Contributing to Go open source projects in GitHub
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GitHub上为Go开源项目做出贡献
- en: One important thing to mention about Go packaging system is that it needs to
    have a proper folder structure within the GOPATH. This introduces a small problem
    when working with GitHub projects. We are used to forking a project, cloning our
    fork and start working before committing the pull-request to the original project.
    Wrong!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go打包系统的一个重要事项是，它需要在GOPATH内部有一个合适的文件夹结构。这在使用GitHub项目时引入了一个小问题。我们习惯于fork一个项目，克隆我们的fork并开始工作，在向原始项目提交pull-request之前。错误！
- en: 'When you fork a project, you create a new repository on GitHub within your
    username. If you clone this repository and start working with it, all new import
    references in the project will point to your repository instead of the original!
    Imagine the following case in the original repository:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你fork一个项目时，你会在GitHub上以你的用户名创建一个新的仓库。如果你克隆这个仓库并开始工作，项目中所有新的导入引用都将指向你的仓库，而不是原始仓库！想象以下情况在原始仓库中：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you make a fork and add a subfolder with a library called `a_library/my_library`
    that you want to use from the main package. The result is going to be the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建一个fork，并添加一个包含名为`a_library/my_library`的库的子文件夹，你希望从主包中使用这个库。结果将是以下这样：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now if you commit this line, the original repository that contains the code
    you have pushed will download this code anyways from your account again and it
    will use the references downloaded! Not the ones contained in the project!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你提交这一行，包含你已推送代码的原始仓库仍然会从你的账户再次下载这段代码，并且它会使用下载的引用！而不是项目中的那些引用！
- en: 'So, the solution to this is simply to replace the `git clone` command with
    a `go get` pointing to the original library:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个问题的解决方案很简单，只需将`git clone`命令替换为指向原始库的`go get`命令：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this modification, you can work normally in the original code without fear
    as the references will stay correct. Once you are done you just have to commit
    and push to your remote.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这样的修改，你可以在原始代码中正常工作，无需担心，因为引用将保持正确。一旦完成，你只需提交并推送到远程仓库。
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, you can now access the GitHub web user interface and open the pull
    request without polluting the actual original code with references to your account.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你现在可以访问GitHub的Web用户界面并打开pull request，而不会将你的账户引用污染实际的原始代码。
