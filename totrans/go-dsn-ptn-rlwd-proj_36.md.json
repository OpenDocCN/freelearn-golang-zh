["```go\ntype Question struct { \n  Key *datastore.Key `json:\"id\" datastore:\"-\"` \n  CTime time.Time `json:\"created\" datastore:\",noindex\"` \n  Question string `json:\"question\" datastore:\",noindex\"` \n  User UserCard `json:\"user\"` \n  AnswersCount int `json:\"answers_count\"` \n} \n\n```", "```go\ntype Answer struct { \n  Key *datastore.Key `json:\"id\" datastore:\"-\"` \n  Answer string `json:\"answer\" datastore:\",noindex\"` \n  CTime time.Time `json:\"created\"` \n  User UserCard `json:\"user\" datastore:\",noindex\"` \n  Score int `json:\"score\"` \n} \n\n```", "```go\ntype Vote struct { \n  Key *datastore.Key `json:\"id\" datastore:\"-\"` \n  MTime time.Time `json:\"last_modified\" datastore:\",noindex\"` \n  Question QuestionCard `json:\"question\" datastore:\",noindex\"` \n  Answer AnswerCard `json:\"answer\" datastore:\",noindex\"` \n  User UserCard `json:\"user\" datastore:\",noindex\"` \n  Score int `json:\"score\" datastore:\",noindex\"` \n} \n\n```", "```go\ntype Vote struct { \n  Key *datastore.Key `json:\"id\" datastore:\"-\"` \n  MTime time.Time `json:\"last_modified\" datastore:\",noindex\"` \n  Question QuestionCard `json:\"question\" datastore:\",noindex\"` \n  Answer AnswerCard `json:\"answer\" datastore:\",noindex\"` \n  User UserCard `json:\"user\" datastore:\",noindex\"` \n  Score int `json:\"score\" datastore:\",noindex\"` \n} \n\n```", "```go\ntype QuestionCard struct { \n  Key *datastore.Key `json:\"id\" datastore:\",noindex\"` \n  Question string `json:\"question\" datastore:\",noindex\"` \n  User     UserCard `json:\"user\" datastore:\",noindex\"` \n} \nfunc (q Question) Card() QuestionCard { \n  return QuestionCard{ \n    Key:      q.Key, \n    Question: q.Question, \n    User:     q.User, \n  } \n} \n\n```", "```go\ntype AnswerCard struct { \n  Key    *datastore.Key `json:\"id\" datastore:\",noindex\"` \n  Answer string         `json:\"answer\" datastore:\",noindex\"` \n  User   UserCard       `json:\"user\" datastore:\",noindex\"` \n} \n\nfunc (a Answer) Card() AnswerCard { \n  return AnswerCard{ \n    Key:    a.Key, \n    Answer: a.Answer, \n    User:   a.User, \n  } \n} \n\n```", "```go\nfunc CastVote(ctx context.Context, answerKey *datastore.Key, score int) (*Vote, error) { \n  question, err := GetQuestion(ctx, answerKey.Parent()) \n  if err != nil { \n    return nil, err \n  } \n  user, err := UserFromAEUser(ctx) \n  if err != nil { \n    return nil, err \n  } \n  var vote Vote \n  err = datastore.RunInTransaction(ctx, func(ctx context.Context) error { \n    var err error \n    vote, err = castVoteInTransaction(ctx, answerKey, question, user, \n     score) \n    if err != nil { \n      return err \n    } \n    return nil \n  }, &datastore.TransactionOptions{XG: true}) \n  if err != nil { \n    return nil, err \n  } \n  return &vote, nil \n} \n\n```", "```go\nfunc castVoteInTransaction(ctx context.Context, answerKey *datastore.Key, question *Question, user *User, score int) (Vote, error) { \n  var vote Vote \n  answer, err := GetAnswer(ctx, answerKey) \n  if err != nil { \n    return vote, err \n  } \n  voteKeyStr := fmt.Sprintf(\"%s:%s\", answerKey.Encode(), user.Key.Encode()) \n  voteKey := datastore.NewKey(ctx, \"Vote\", voteKeyStr, 0, nil) \n  var delta int // delta describes the change to answer score \n  err = datastore.Get(ctx, voteKey, &vote) \n  if err != nil && err != datastore.ErrNoSuchEntity { \n    return vote, err \n  } \n  if err == datastore.ErrNoSuchEntity { \n    vote = Vote{ \n      Key:      voteKey, \n      User:     user.Card(), \n      Answer:   answer.Card(), \n      Question: question.Card(), \n      Score:    score, \n    } \n  } else { \n    // they have already voted - so we will be changing \n    // this vote \n    delta = vote.Score * -1 \n  } \n  delta += score \n  answer.Score += delta \n  err = answer.Put(ctx) \n  if err != nil { \n    return vote, err \n  } \n  vote.Key = voteKey \n  vote.Score = score \n  vote.MTime = time.Now() \n  err = vote.Put(ctx) \n  if err != nil { \n    return vote, err \n  } \n  return vote, nil \n} \n\n```", "```go\nif obj, ok := v.(interface{ OK() error }); ok { \n  // v has OK() method \n} else { \n  // v does not have OK() method \n} \n\n```", "```go\nfunc decode(r *http.Request, v interface{}) error { \n  err := json.NewDecoder(r.Body).Decode(v) \n  if err != nil { \n    return err \n  } \n  if valid, ok := v.(interface { \n    OK() error \n  }); ok { \n    err = valid.OK() \n    if err != nil { \n      return err \n    } \n  } \n  return nil \n} \n\n```", "```go\nfunc respond(ctx context.Context, w http.ResponseWriter,\n r *http.Request, v interface{}, code int) { \n  var buf bytes.Buffer \n  err := json.NewEncoder(&buf).Encode(v) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusInternalServerError) \n    return \n  } \n  w.Header().Set(\"Content-Type\", \n   \"application/json; charset=utf-8\") \n  w.WriteHeader(code) \n  _, err = buf.WriteTo(w) \n  if err != nil { \n    log.Errorf(ctx, \"respond: %s\", err) \n  } \n} \n\n```", "```go\nfunc respondErr(ctx context.Context, w http.ResponseWriter,\n r *http.Request, err error, code int) { \n  errObj := struct { \n    Error string `json:\"error\"` \n  }{ Error: err.Error() } \n  w.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\") \n  w.WriteHeader(code) \n  err = json.NewEncoder(w).Encode(errObj) \n  if err != nil { \n    log.Errorf(ctx, \"respondErr: %s\", err) \n  } \n} \n\n```", "```go\nfunc TestPathParams(t *testing.T) { \n  r, err := http.NewRequest(\"GET\", \"1/2/3/4/5\", nil) \n  if err != nil { \n    t.Errorf(\"NewRequest: %s\", err) \n  } \n  params := pathParams(r, \"one/two/three/four\") \n  if len(params) != 4 { \n    t.Errorf(\"expected 4 params but got %d: %v\", len(params), params) \n  } \n  for k, v := range map[string]string{ \n    \"one\":   \"1\", \n    \"two\":   \"2\", \n    \"three\": \"3\", \n    \"four\":  \"4\", \n  } { \n    if params[k] != v { \n      t.Errorf(\"%s: %s != %s\", k, params[k], v) \n    } \n  } \n  params = pathParams(r, \"one/two/three/four/five/six\") \n  if len(params) != 5 { \n    t.Errorf(\"expected 5 params but got %d: %v\", len(params), params) \n  } \n  for k, v := range map[string]string{ \n    \"one\":   \"1\", \n    \"two\":   \"2\", \n    \"three\": \"3\", \n    \"four\":  \"4\", \n    \"five\":  \"5\", \n  } { \n    if params[k] != v { \n      t.Errorf(\"%s: %s != %s\", k, params[k], v) \n    } \n  } \n} \n\n```", "```go\nfunc pathParams(r *http.Request,pattern string) map[string]string{ \n  params := map[string]string{} \n  pathSegs := strings.Split(strings.Trim(r.URL.Path, \"/\"), \"/\") \n  for i, seg := range strings.Split(strings.Trim(pattern, \"/\"), \"/\") { \n    if i > len(pathSegs)-1 { \n      return params \n    } \n    params[seg] = pathSegs[i] \n  } \n  return params \n} \n\n```", "```go\nquestions: questions\nid:        123\n\n```", "```go\nfunc handleQuestions(w http.ResponseWriter, r *http.Request) { \n  switch r.Method { \n  case \"POST\": \n    handleQuestionCreate(w, r) \n  case \"GET\": \n    params := pathParams(r, \"/api/questions/:id\") \n    questionID, ok := params[\":id\"] \n    if ok { // GET /api/questions/ID \n      handleQuestionGet(w, r, questionID) \n      return \n    } \n    handleTopQuestions(w, r) // GET /api/questions/ \n  default: \n    http.NotFound(w, r) \n  } \n} \n\n```", "```go\nfunc handleQuestionCreate(w http.ResponseWriter, r *http.Request) { \n  ctx := appengine.NewContext(r) \n  var q Question \n  err := decode(r, &q) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  err = q.Create(ctx) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusInternalServerError) \n    return \n  } \n  respond(ctx, w, r, q, http.StatusCreated) \n} \n\n```", "```go\nfunc handleQuestionGet(w http.ResponseWriter, r *http.Request,\n questionID string) { \n  ctx := appengine.NewContext(r) \n  questionKey, err := datastore.DecodeKey(questionID) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  question, err := GetQuestion(ctx, questionKey) \n  if err != nil { \n    if err == datastore.ErrNoSuchEntity { \n      respondErr(ctx, w, r, datastore.ErrNoSuchEntity,\n       http.StatusNotFound) \n      return \n    } \n    respondErr(ctx, w, r, err, http.StatusInternalServerError) \n    return \n  } \n  respond(ctx, w, r, question, http.StatusOK) \n} \n\n```", "```go\nfunc handleAnswers(w http.ResponseWriter, r *http.Request) { \n  switch r.Method { \n  case \"GET\": \n    handleAnswersGet(w, r) \n  case \"POST\": \n    handleAnswerCreate(w, r) \n  default: \n    http.NotFound(w, r) \n  } \n} \n\n```", "```go\nfunc handleAnswersGet(w http.ResponseWriter, r *http.Request) { \n  ctx := appengine.NewContext(r) \n  q := r.URL.Query() \n  questionIDStr := q.Get(\"question_id\") \n  questionKey, err := datastore.DecodeKey(questionIDStr) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  answers, err := GetAnswers(ctx, questionKey) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusInternalServerError) \n    return \n  } \n  respond(ctx, w, r, answers, http.StatusOK) \n} \n\n```", "```go\n/api/answers?question_id=abc123 \n\n```", "```go\nfunc handleAnswerCreate(w http.ResponseWriter, r *http.Request) { \n  ctx := appengine.NewContext(r) \n  var newAnswer struct { \n    Answer \n    QuestionID string `json:\"question_id\"` \n  } \n  err := decode(r, &newAnswer) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  questionKey, err := datastore.DecodeKey(newAnswer.QuestionID) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  err = newAnswer.OK() \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  answer := newAnswer.Answer \n  user, err := UserFromAEUser(ctx) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  answer.User = user.Card() \n  err = answer.Create(ctx, questionKey) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusInternalServerError) \n    return \n  } \n  respond(ctx, w, r, answer, http.StatusCreated) \n} \n\n```", "```go\nfunc handleVotes(w http.ResponseWriter, r *http.Request) { \n  if r.Method != \"POST\" { \n    http.NotFound(w, r) \n    return \n  } \n  handleVote(w, r) \n} \n\n```", "```go\nfunc validScore(score int) bool { \n  return score == -1 || score == 1 \n} \n\n```", "```go\nfunc validScore(score int) error { \n  if score != -1 && score != 1 { \n    return errors.New(\"invalid score\") \n  } \n  return nil \n} \n\n```", "```go\nfunc handleVote(w http.ResponseWriter, r *http.Request) { \n  ctx := appengine.NewContext(r) \n  var newVote struct { \n    AnswerID string `json:\"answer_id\"` \n    Score    int    `json:\"score\"` \n  } \n  err := decode(r, &newVote) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  err = validScore(newVote.Score) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusBadRequest) \n    return \n  } \n  answerKey, err := datastore.DecodeKey(newVote.AnswerID) \n  if err != nil { \n    respondErr(ctx, w, r, errors.New(\"invalid answer_id\"), \n    http.StatusBadRequest) \n    return \n  } \n  vote, err := CastVote(ctx, answerKey, newVote.Score) \n  if err != nil { \n    respondErr(ctx, w, r, err, http.StatusInternalServerError) \n    return \n  } \n  respond(ctx, w, r, vote, http.StatusCreated) \n} \n\n```", "```go\nfunc init() { \n  http.HandleFunc(\"/api/questions/\", handleQuestions) \n  http.HandleFunc(\"/api/answers/\", handleAnswers) \n  http.HandleFunc(\"/api/votes/\", handleVotes) \n} \n\n```", "```go\ngoapp serve dispatch.yaml default/app.yaml api/app.yaml\n     web/app.yaml\n\n```", "```go\ngoapp deploy default/app.yaml api/app.yaml web/app.yaml\n\n```", "```go\nappcfg.py update_dispatch .\n\n```", "```go\nappcfg.py update_indexes -A **YOUR_APPLICATION_ID_HERE** ./default\n\n```"]