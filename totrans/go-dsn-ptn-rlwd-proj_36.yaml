- en: Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reads from Google Cloud Datastore are extremely fast due to the extensive use
    of indexes. By default, every field in our structure is indexed. Queries that
    attempt to filter on fields that aren't indexed will fail (the method will return
    an error); the data store doesn't fall back to scanning like some other technologies
    do because it's considered too slow. If one query filters two or more fields,
    an additional index must be added that is composed of all fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'A structure with 10 fields would perform multiple write operations when you
    put it: one for the entity itself and one for each index that needs to be updated.
    So it is sensible to turn off indexing for fields that are you not planning to
    query on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `questions.go`, add the `datastore` field tags to the `Question` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The addition of the `datastore:",noindex"` field tags will tell the data store
    not to index these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `,noindex` value beginning with a comma is a little confusing. The value
    is essentially a list of comma-separated arguments, the first being the name we
    want the data store to use when storing each field (just like it does for the
    `json` tag). Since we don't want to say anything about the name we want the data
    store to use the real field name we are omitting it; so the first argument is
    empty, and the second argument is `noindex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do this for fields that we do not want indexed in the `Answer` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the `Vote` structure, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add a `noindex` declaration to all fields inside our card types:
    `AnswerCard`, `UserCard`, and `QuestionCard`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fields we have left without `noindex` will be used in queries, and we need
    to make sure Google Cloud Datastore does indeed maintain indexes on these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding a different view of entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it''s time to create our `Vote` structure, which we''ll do inside a new
    file called `votes.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A `Vote` structure contains many of our embeddable card types representing `Question`,
    `Answer` and `User` casting the vote. It also contains a `Score` integer, which
    will be either `1` or `-1` (depending on whether they voted up or down). We will
    also keep track of when they cast their vote (or last changed it) with the `MTime`
    `time.Time` field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use pointers to the `*Card` types in the `Vote` struct if you like.
    This would save additional copies being made when if you pass the `Vote` object
    in and out of functions, but that would mean that any changes made inside these
    functions would affect the original data rather than just their local copy. In
    most situations, there isn't much of a performance benefit to using pointers and
    it might be considered simpler to omit them. This book deliberately mixes both
    approaches to show you how they work, but you should understand the implications
    before making a decision.
  prefs: []
  type: TYPE_NORMAL
- en: Like our `UserCard` method, we are going to add appropriate versions for questions
    and answers, but this time we are going to be more selective about which fields
    should be included and which should be left out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `questions.go`, add the `QuestionCard` type and the associated helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `QuestionCard` type captures the `Question` string and who asked it (our
    `UserCard` method, again), but we are leaving out the `CTime` and `AnswersCount`
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `AnswerCard` to `answers.go` next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we are only capturing the `Answer` string and `User` and excluding
    `CTime` and `Score`.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which fields to capture and which to omit is entirely dependent on
    the user experience you wish to provide. We might decide that when we show a vote,
    we want to show the score of `Answer` at the time, or we might want to show the
    current score of `Answer` regardless of what it was at the time the vote was cast.
    Perhaps we want to send a push notification to the user who wrote the answer saying
    something like "Blanca has up-voted your answer to Ernesto's question it now has
    a score of 15", in which case we would need to grab the `Score` field too.
  prefs: []
  type: TYPE_NORMAL
- en: Casting a vote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before our API is a complete feature, we need to add the ability for users to
    cast votes. We'll break this piece into two functions in order to increase the
    readability of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `votes.go`, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `CastVote` function takes (along with the obligatory `Context`) `datastore.Key`
    for the answer that is being voted for and a score integer. It loads the question
    and the current user, starts a data store transaction, and passes execution off
    to the `castVoteInTransaction` function.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing parents via datastore.Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `CastVote` function could require that we know `datastore.Key` for `Question`
    so that we can load it. But one nice feature about ancestor keys is that from
    the key alone, you can access the parent key. This is because the hierarchy of
    keys is maintained in the key itself, a bit like a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three answers to question 1 might have these keys:'
  prefs: []
  type: TYPE_NORMAL
- en: Question,1/Answer,1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Question,1/Answer,2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Question,1/Answer,3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual details of how keys work under the hood are kept internal to the
    datastore package and could change at any time. So it is smart to only rely on
    things that the API guarantees such as being able to access the parent via the
    `Parent` method.
  prefs: []
  type: TYPE_NORMAL
- en: Line of sight in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cost of writing a function is relatively low compared to the cost of maintaining
    it, especially in successful, long-running projects. So it is worth taking the
    time to ensure the code is readable by our future selves and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code can be said to have a good line of sight if it is easy to glance at and
    if it understands the usual, expected flow of the statements (the happy path).
    In Go, we can achieve this by following a few simple rules when we write code:'
  prefs: []
  type: TYPE_NORMAL
- en: Align the happy path to the left edge so that you can scan down a single column
    and see the expected flow of execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't hide the happy path logic inside a nest of indented braces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exit early from your function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indent only to handle errors or edge cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract functions and methods to keep bodies small and readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few more details to writing good line of sight code, which are outlined
    and maintained at [http://bit.ly/lineofsightincode](http://bit.ly/lineofsightincode).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent our `CastVote` function from becoming too big and difficult
    to follow, we have broken out the core functionality into its own function, which
    we will now add to `votes.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While this function is long, its line of sight isn't too bad. The happy path
    flows down the left edge, and we only indent to return early in case of errors
    and the case where we create a new `Vote` object. This means that we can easily
    track what it is doing.
  prefs: []
  type: TYPE_NORMAL
- en: We take in the answer key, the related question, the user casting the vote and
    the score, and return a Vote object, or else an error if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the answer which, since we're inside a transaction, will lock
    it until the transaction is complete (or stops due to an error).
  prefs: []
  type: TYPE_NORMAL
- en: We then build the key for this vote, which is made up of the keys of both the
    answer and the user encoded into a single string. This means that only one `Vote`
    entity will exist in the data store for each user/answer pair; so a user may only
    have one vote per answer as per our design.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the vote key to attempt to load the `Vote` entity from the data
    store. Of course, the first time a user votes on a question, no entity will exist,
    which we can check by seeing whether the error returned from `datastore.Get` is
    the special `datastore.ErrNoSuchEntity` value or not. If it is, we create the
    new `Vote` object, setting the appropriate fields.
  prefs: []
  type: TYPE_NORMAL
- en: We are maintaining a score `delta` integer, which will represent the number
    that needs to be added to the answer score after the vote has happened. When it's
    the first time a user has voted on a question, the delta will be either `1` or
    `-1`. If they are changing their vote from down to up (`-1` to `1`), the delta
    will be `2`,Â which cancels out the previous vote and adds the new one. We multiply
    the delta by `-1` to undo the previous vote if there was one (if `err != datastore.ErrNoSuchEntity`).
    This has the nice effect of also not making any difference (`delta` will be 0)
    if they happen to cast the same vote twice in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we change the score on the answer and put it back into the data store
    before updating the final fields in our `Vote` object and putting that in too.
    We then return and our `CastVote` function exits the `datastore.RunInTransaction`
    function block, thus releasing Answer and letting others cast their votes on it
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing data operations over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built all of our entities and the data access methods that
    operate on them, it's time to wire them up to an HTTP API. This will feel more
    familiar as we have already done this kind of thing a few times in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Optional features with type assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use interface types in Go, you can perform type assertions to see whether
    the objects implement other interfaces, and since you can write interfaces inline,
    it is possible to very easily find out whether an object implements a specific
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `v` is `interface{}`, we can see whether it has the `OK` method using this
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the `v` object implements the method described in the interface, `ok` will
    be `true` and `obj` will be an object on which the OK method can be called. Otherwise,
    `ok` will be false.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem with this approach is that it hides the secret functionality from
    users of the code, so you must either document the function very well in order
    to make it clear or perhaps promote the method to its own first-class interface
    and insist that all objects implement it. Remember that we must always seek clear
    code over clever code. As a side exercise, see whether you can add the interface
    and use it in the decode signature instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a function that will help us decode JSON request bodies
    and, optionally, validate the input. Create a new file called `http.go` and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The decode function takes `http.Request` and a destination value called `v`,
    which is where the data from the JSON will go. We check whether the `OK` method
    is implemented, and if it is, we call it. We expect `OK` to return nil if the
    object looks good; otherwise, we expect it to return an error that explains what
    is wrong. If we get an error, we'll return it and let the calling code deal with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If all is well, we return nil at the bottom of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Response helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to add a pair of helper functions that will make responding to
    API requests easy. Add the `respond` function to `http.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The respond method contains a `context`, `ResponseWriter`, `Request`, the object
    to respond with, and a status code. It encodes `v` into an internal buffer before
    setting the appropriate headers and writing the response.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a buffer here because it's possible that the encoding might fail.
    If it does so but has already started writing the response, the 200 OK header
    will be sent to the client, which is misleading. Instead, encoding to a buffer
    lets us be sure that completes without issue before deciding what status code
    to respond with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `respondErr` function at the bottom of `http.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function writes `error` wrapped in a struct that embeds the error string
    as a field called `error`.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing path parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of our API endpoints will need to pull IDs out of the path string, but
    we don't want to add any dependencies to our project (such as an external router
    package); instead, we are going to write a simple function that will parse path
    parameters for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first write a test that will explain how we want our path parsing to
    work. Create a file called http_test.go and add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We expect to be able to pass in a pattern and have a map returned that discovers
    the values from the path in `http.Request`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the test (with `go test -v`) and note that it fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `http.go`, add the following implementation to make the test
    pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The function breaks the path from the specific `http.Request` and builds a
    map of the values with keys taken from breaking the pattern path. So for a pattern
    of `/questions/id` and a path of `/questions/123`, it would return the following
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we'd ignore the `questions` key, but `id` will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing functionality via an HTTP API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have all the tools we need in order to put together our API: helper
    functions to encode and decode data payloads in JSON, path parsing functions,
    and all the entities and data access functionality to persist and query data in
    Google Cloud Datastore.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP routing in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The three endpoints we are going to add in order to handle questions are outlined
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP request** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `POST /questions` | Ask a new question |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /questions/{id}` | Get the question with the specific ID |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /questions` | Get the top questions |'
  prefs: []
  type: TYPE_TB
- en: Since our API design is relatively simple, there is no need to bloat out our
    project with an additional dependency to solve routing for us. Instead, we'll
    roll our own very simple adhoc routing using normal Go code. We can use a simple
    `switch` statement to detect which HTTP method was used and our `pathParams` helper
    function to see whether an ID was specified before passing execution to the appropriate
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `handle_questions.go` and add the following `http.HandlerFunc`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the HTTP method is `POST`, then we'll call `handleQuestionCreate`. If it's
    `GET`, then we'll see whether we can extract the ID from the path and call `handleQuestionGet`
    if we can, or `handleTopQuestions` if we cannot.
  prefs: []
  type: TYPE_NORMAL
- en: Context in Google App Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember, all of our calls to App Engine functions took a `context.Context`
    object as the first parameter, but what is that and how do we create one?
  prefs: []
  type: TYPE_NORMAL
- en: '`Context` is actually an interface that provides cancelation signals, execution
    deadlines, and request-scoped data throughout a stack of function calls across
    many components and API boundaries. The Google App Engine SDK for Go uses it throughout
    its APIs, the details of which are kept internal to the package, which means that
    we (as users of the SDK) don''t have to worry about it. This is a good goal for
    when you use Context in your own packages; ideally, the complexity should be kept
    internal and hidden.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can, and should, learn more about `Context` through various online resources,
    starting with the *Go Concurrency Patterns: Context* blog post at [https://blog.golang.org/context](https://blog.golang.org/context).'
  prefs: []
  type: TYPE_NORMAL
- en: To create a context suitable for App Engine calls, you use the `appengine.NewContext`
    function, which takes `http.Request` as an argument to which the context will
    belong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the routing code we just added, let''s add the handler that will
    be responsible for creating a question, and we can see how we will create a new
    context for each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We create `Context` and store it in the `ctx` variable, which has become somewhat
    an accepted pattern throughout the Go community. We then decode our Question (which,
    due to the `OK` method, will also validate it for us) before calling the `Create`
    helper method that we wrote earlier. Every step of the way, we pass our context
    along.
  prefs: []
  type: TYPE_NORMAL
- en: If anything goes wrong, we make a call out to our `respondErr` function, which
    will write out the response to the client before returning and exiting early from
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: If all is well, we respond with `Question` and a `http.StatusCreated` status
    code (201).
  prefs: []
  type: TYPE_NORMAL
- en: Decoding key strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are exposing the `datastore.Key` objects as the `id` field in our objects
    (via the `json` field tags), we expect users of our API to pass back these same
    ID strings when referring to specific objects. This means that we need to decode
    these strings and turn them back into `datastore.Key` objects. Luckily, the `datastore`
    package provides the answer in the form of the `datastore.DecodeKey` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `handle_questions.go`, add the following handle function to
    get a single question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After we create Context again, we decode the `question ID` argument to turn
    the string back into a `datastore.Key` object. The `question ID` string is passed
    in from our routing handler code, which we added at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming `question ID` is a valid key and the SDK was successfully able to turn
    it into `datastore.Key`, we call our `GetQuestion` helper function to load `Question`.
    If we get the `datastore.ErrNoSuchEntity` error, then we respond with a 404 (not
    found) status; otherwise, we'll report the error with a `http.StatusInternalServerError`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When writing APIs, check out the HTTP status codes and other HTTP standards
    and see whether you can make use of them. Developers are used to them and your
    API will feel more natural if it speaks the same language.
  prefs: []
  type: TYPE_NORMAL
- en: If we are able to load the question, we call `respond` and send it back to the
    client as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to expose the functionality related to answers via a similar
    API to the one we used for questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP request** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `POST /answers` | Submit an answer |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /answers` | Get the answers with the specified question ID |'
  prefs: []
  type: TYPE_TB
- en: 'Create a new file called `handle_answers.go` and add the routing `http.HandlerFunc`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For `GET` requests, we call `handleAnswersGet`; for `POST` requests, we call
    `handleAnswerCreate`. By default, we'll respond with a `404 Not Found` response.
  prefs: []
  type: TYPE_NORMAL
- en: Using query parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an alternative to parsing the path, you can just take query parameters from
    the URL in the request, which we will do when we add the handler that reads answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `r.URL.Query()` to get the `http.Values` that contains the query
    parameters and use the Get method to pull out `question_id`. So, the API call
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be consistent in your API in the real world. We have used a mix of
    path parameters and query parameters to show off the differences, but it is recommended
    that you pick one style and stick to it.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous structs for request data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The API for answering a question is to post to `/api/answers` with a body that
    contains the answer details as well as the question ID string. This structure
    is not the same as our internal representation of `Answer` because the question
    ID string would need to be decoded into `datastore.Key`. We could leave the field
    in and indicate with field tags that it should be omitted from both the JSON and
    the data store, but there is a cleaner approach.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify an inline, anonymous structure to hold the new answer, and the
    best place to do this is inside the handler function that deals with that data
    this means that we don't need to add a new type to our API, but we can still represent
    the request data we are expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `handle_answers.go`, add the `handleAnswerCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Look at the somewhat unusual `var newAnswer struct` line. We are declaring a
    new variable called `newAnswer`, which has a type of an anonymous struct (it has
    no name) that contains `QuestionID string` and embeds `Answer`. We can decode
    the request body into this type, and we will capture any specific `Answer` fields
    as well as `QuestionID`. We then decode the question ID into `datastore.Key` as
    we did earlier, validate the answer, and set the `User` (`UserCard`) field by
    getting the currently authenticated user and calling the `Card` helper method.
  prefs: []
  type: TYPE_NORMAL
- en: If all is well, we call `Create`, which will do the work to save the answer
    to the question.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to expose the voting functionality in our API.
  prefs: []
  type: TYPE_NORMAL
- en: Writing self-similar code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our voting API has only a single endpoint, a post to `/votes`. So, of course,
    there is no need to do any routing on this method (we could just check the method
    in the handler itself), but there is something to be said for writing code that
    is familiar and similar to other code in the same package. In our case, omitting
    a router might jar a little if somebody else is looking at our code and expects
    one after seeing the routers for questions and answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s add a simple router handler to a new file called `handle_votes.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our router just checks the method and exits early if it's not `POST`, before
    calling the `handleVote` function, which we will add next.
  prefs: []
  type: TYPE_NORMAL
- en: Validation methods that return an error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OK` method that we added to some of our objects is a nice way to add validation
    methods to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to ensure that the incoming score value is valid (in our case, either
    `-1` or `1`), so we could write a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we used this function in a few places, we would have to keep repeating the
    code that explained that the score was not valid. If, however, the function returns
    an error, you can encapsulate that in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `votes.go`, add the following `validScore` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we return `nil` if the score is valid; otherwise, we return
    an error that explains what is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make use of this validation function when we add our `handleVote` function
    to `handle_votes.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will look pretty familiar by now, which highlights why we put all the data
    access logic in a different place to our handlers; the handlers can then focus
    on HTTP tasks, such as decoding the request and writing the response, and leave
    the application specifics to the other objects.
  prefs: []
  type: TYPE_NORMAL
- en: We have also broken down the logic into distinct files, with a pattern of prefixing
    HTTP handler code with `handle_`, so we quickly know where to look when we want
    to work on a specific piece of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the router handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s update our `main.go` file by changing the `init` function to map the
    real handlers to HTTP paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can also remove the now redundant `handleHello` handler function.
  prefs: []
  type: TYPE_NORMAL
- en: Running apps with multiple modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For applications such as ours that have multiple modules, we need to list out
    all the YAML files for the `goapp` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To serve our new application, in a terminal, execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with the dispatch file, we are listing all the associated configuration
    files. If you miss any, you will see an error when you try to serve your application.
    Here, you will notice that the output now lists that each module is being deployed
    on a different port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running apps with multiple modules](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can access modules directly by visiting each port, but luckily we have our
    dispatcher running on port `:8080`, which will do that for us based on the rules
    we specified in our `dispatch.yaml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Testing locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have built our application, head over to `localhost:8080` to see
    it in action. Use the features of the application by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in using your real e-mail address (that way, you'll see your Gravatar picture).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask a question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submit a couple of answers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vote the answers up and down and see the scores changing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open another browser and sign in as someone else to see what the application
    looks like from their point of view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the admin console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The admin console is running alongside our application and is accessible at
    `localhost:8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the admin console](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Datastore Viewer** lets you inspect the data of your application. You can
    use it to see (and even make changes to) the questions, answers, and votes data
    that are being generated as you use the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically generated indexes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also see which indexes have been automatically created by the development
    server in order to satisfy the queries your application makes. In fact, if you
    look in the default folder, you will notice that a new file called `index.yaml`
    has magically appeared. This file describes those same indexes that your application
    will need, and when you deploy your application, this file goes up to the cloud
    with it to tell Google Cloud Datastore to maintain these same indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying apps with multiple modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying the application is slightly more complicated with multiple modules,
    as the dispatcher and index files each require a dedicated deployment command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the modules with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the operation has finished, we can update the dispatcher using the `appcfg.py`
    command (which you must ensure is in your path you''ll find it in the Google App
    Engine SDK for the Go folder we downloaded at the start of the chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dispatch has been updated, we can push the indexes to the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that the application is deployed, we can see it in the wild by navigating
    to our *appspot* URL; `https://YOUR_APPLICATION_ID_HERE.appspot.com/`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might get an error that says `The index for this query is not ready to serve`.
    This is because it takes Google Cloud Datastore a little time to prepare things
    on the server; usually, it doesn't take more than a few minutes, so go and have
    a cup of coffee and try again later.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting aside is that if you hit the URL with HTTPS, Google's servers
    will serve it using HTTP/2.
  prefs: []
  type: TYPE_NORMAL
- en: Once your application is functional, ask an interesting question and send the
    link to your friends to solicit answers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a fully functional question and answer application
    for Google App Engine.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use the Google App Engine SDK for Go to build and test our
    application locally before deploying it to the cloud, ready for our friends and
    family to use. The application is ready to scale if it suddenly starts getting
    a lot of traffic, and we can rely on the healthy quota to satisfy early traffic.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how to model data in Go code, keep track of keys, and persist and
    query data in Google Cloud Datastore. We also explored strategies to denormalize
    such data in order to make it quicker to read back at scale. We saw how transactions
    can guarantee data integrity by ensuring that only one operation occurs at a particular
    point in time, allowing us to build reliable counters for the score of our answers.
    We used predictable data store keys to ensure that our users can only have one
    vote per answer, and we used incomplete keys when we wanted the data store to
    generate the keys for us.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the techniques explored in this chapter would apply to any kind of
    application that persists data and interacts over a RESTful JSON API so the skills
    are highly transferrable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore modern software architecture by
    building a real micro-service using the Go Kit framework. There are a lot of benefits
    to building solutions using micro-services, and so they have become a very popular
    choice for large, distributed systems. Lots of companies are already running such
    architectures (mostly written in Go) in production, and we will look at how they
    do it.
  prefs: []
  type: TYPE_NORMAL
