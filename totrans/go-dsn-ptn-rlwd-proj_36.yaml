- en: Indexing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: Reads from Google Cloud Datastore are extremely fast due to the extensive use
    of indexes. By default, every field in our structure is indexed. Queries that
    attempt to filter on fields that aren't indexed will fail (the method will return
    an error); the data store doesn't fall back to scanning like some other technologies
    do because it's considered too slow. If one query filters two or more fields,
    an additional index must be added that is composed of all fields.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于广泛使用索引，从 Google Cloud Datastore 读取速度极快。默认情况下，我们结构中的每个字段都是索引的。尝试在未索引的字段上过滤的查询将失败（方法将返回错误）；数据存储不会像某些其他技术那样回退到扫描，因为这被认为太慢。如果一个查询过滤了两个或多个字段，必须添加一个额外的索引，该索引由所有字段组成。
- en: 'A structure with 10 fields would perform multiple write operations when you
    put it: one for the entity itself and one for each index that needs to be updated.
    So it is sensible to turn off indexing for fields that are you not planning to
    query on.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你放置一个包含 10 个字段的结构时，它将执行多个写操作：一个用于实体本身，一个用于需要更新的每个索引。因此，对于你不想查询的字段关闭索引是有意义的。
- en: 'In `questions.go`, add the `datastore` field tags to the `Question` structure:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `questions.go` 中，向 `Question` 结构添加 `datastore` 字段标签：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The addition of the `datastore:",noindex"` field tags will tell the data store
    not to index these fields.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `datastore:",noindex"` 字段标签将告诉数据存储不要索引这些字段。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `,noindex` value beginning with a comma is a little confusing. The value
    is essentially a list of comma-separated arguments, the first being the name we
    want the data store to use when storing each field (just like it does for the
    `json` tag). Since we don't want to say anything about the name we want the data
    store to use the real field name we are omitting it; so the first argument is
    empty, and the second argument is `noindex`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以逗号开头的 `,noindex` 值有点令人困惑。该值本质上是一个逗号分隔的参数列表，第一个是我们希望数据存储在存储每个字段时使用的名称（就像它对 `json`
    标签所做的那样）。由于我们不想说任何关于我们希望数据存储使用的名称的事情，所以我们省略了真实字段名称；因此，第一个参数是空的，第二个参数是 `noindex`。
- en: 'Do this for fields that we do not want indexed in the `Answer` structure:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们不想在 `Answer` 结构中索引的字段，这样做：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And for the `Vote` structure, do this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Vote` 结构，这样做：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also add a `noindex` declaration to all fields inside our card types:
    `AnswerCard`, `UserCard`, and `QuestionCard`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 `noindex` 声明添加到我们卡片类型内部的全部字段：`AnswerCard`、`UserCard` 和 `QuestionCard`。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fields we have left without `noindex` will be used in queries, and we need
    to make sure Google Cloud Datastore does indeed maintain indexes on these fields.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有添加 `noindex` 的字段将用于查询，我们需要确保 Google Cloud Datastore 确实在这些字段上维护索引。
- en: Embedding a different view of entities
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入实体的不同视图
- en: 'Now it''s time to create our `Vote` structure, which we''ll do inside a new
    file called `votes.go`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的 `Vote` 结构了，我们将在一个名为 `votes.go` 的新文件中完成：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A `Vote` structure contains many of our embeddable card types representing `Question`,
    `Answer` and `User` casting the vote. It also contains a `Score` integer, which
    will be either `1` or `-1` (depending on whether they voted up or down). We will
    also keep track of when they cast their vote (or last changed it) with the `MTime`
    `time.Time` field.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vote` 结构包含许多我们可嵌入的卡片类型，代表 `Question`、`Answer` 和 `User` 投票。它还包含一个 `Score` 整数，其值为
    `1` 或 `-1`（取决于他们是否投了赞成票或反对票）。我们还将使用 `MTime` `time.Time` 字段跟踪他们投票的时间（或最后更改它）。'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use pointers to the `*Card` types in the `Vote` struct if you like.
    This would save additional copies being made when if you pass the `Vote` object
    in and out of functions, but that would mean that any changes made inside these
    functions would affect the original data rather than just their local copy. In
    most situations, there isn't much of a performance benefit to using pointers and
    it might be considered simpler to omit them. This book deliberately mixes both
    approaches to show you how they work, but you should understand the implications
    before making a decision.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以在 `Vote` 结构中使用 `*Card` 类型的指针。这会在你将 `Vote` 对象传入和传出函数时节省额外的副本，但这意味着在这些函数内部所做的任何更改都会影响原始数据，而不仅仅是它们的本地副本。在大多数情况下，使用指针的性能提升不大，可能更简单的是省略它们。这本书故意混合了两种方法，以向您展示它们是如何工作的，但在做出决定之前，您应该了解其影响。
- en: Like our `UserCard` method, we are going to add appropriate versions for questions
    and answers, but this time we are going to be more selective about which fields
    should be included and which should be left out.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的`UserCard`方法一样，我们将为问题和答案添加适当的版本，但这次我们将更仔细地选择哪些字段应该包含，哪些应该排除。
- en: 'In `questions.go`, add the `QuestionCard` type and the associated helper method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`questions.go`中添加`QuestionCard`类型及其相关辅助方法：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `QuestionCard` type captures the `Question` string and who asked it (our
    `UserCard` method, again), but we are leaving out the `CTime` and `AnswersCount`
    fields.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuestionCard`类型捕获`Question`字符串和谁提出了它（再次是我们的`UserCard`方法），但我们排除了`CTime`和`AnswersCount`字段。'
- en: 'Let''s add `AnswerCard` to `answers.go` next:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`answers.go`中添加`AnswerCard`：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similarly, we are only capturing the `Answer` string and `User` and excluding
    `CTime` and `Score`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们只捕获`Answer`字符串和`User`，排除`CTime`和`Score`。
- en: Deciding which fields to capture and which to omit is entirely dependent on
    the user experience you wish to provide. We might decide that when we show a vote,
    we want to show the score of `Answer` at the time, or we might want to show the
    current score of `Answer` regardless of what it was at the time the vote was cast.
    Perhaps we want to send a push notification to the user who wrote the answer saying
    something like "Blanca has up-voted your answer to Ernesto's question it now has
    a score of 15", in which case we would need to grab the `Score` field too.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 决定要捕获哪些字段以及要排除哪些字段完全取决于你希望提供的用户体验。我们可能会决定，当我们显示投票时，我们想显示`Answer`在当时的分数，或者我们可能想显示`Answer`当前的分数，无论投票时它是什么。也许我们想向写答案的用户发送推送通知，比如“Blanca已经对Ernesto的问题的答案进行了点赞，现在得分为15”，在这种情况下，我们还需要获取`Score`字段。
- en: Casting a vote
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投票
- en: Before our API is a complete feature, we need to add the ability for users to
    cast votes. We'll break this piece into two functions in order to increase the
    readability of our code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的API功能完整之前，我们需要添加用户投票的能力。我们将把这个功能分成两个函数，以提高我们代码的可读性。
- en: 'Inside `votes.go`, add the following function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`votes.go`内部，添加以下函数：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `CastVote` function takes (along with the obligatory `Context`) `datastore.Key`
    for the answer that is being voted for and a score integer. It loads the question
    and the current user, starts a data store transaction, and passes execution off
    to the `castVoteInTransaction` function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`CastVote`函数接受（包括必填的`Context`）要投票的答案的`datastore.Key`和一个分数整数。它加载问题当前用户，开始数据存储事务，并将执行传递给`castVoteInTransaction`函数。'
- en: Accessing parents via datastore.Key
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过datastore.Key访问父键
- en: Our `CastVote` function could require that we know `datastore.Key` for `Question`
    so that we can load it. But one nice feature about ancestor keys is that from
    the key alone, you can access the parent key. This is because the hierarchy of
    keys is maintained in the key itself, a bit like a path.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CastVote`函数可能需要我们知道`Question`的`datastore.Key`以便加载它。但关于祖先键的一个很好的特性是，仅从键本身，你就可以访问父键。这是因为键的层次结构被保存在键本身中，有点像路径。
- en: 'Three answers to question 1 might have these keys:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1可能有以下键的三个答案：
- en: Question,1/Answer,1
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题，1/答案，1
- en: Question,1/Answer,2
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题，1/答案，2
- en: Question,1/Answer,3
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题，1/答案，3
- en: The actual details of how keys work under the hood are kept internal to the
    datastore package and could change at any time. So it is smart to only rely on
    things that the API guarantees such as being able to access the parent via the
    `Parent` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关键如何在底层工作的实际细节被保留在datastore包内部，并且可能会随时更改。因此，只依赖于API保证的事情是明智的，比如能够通过`Parent`方法访问父键。
- en: Line of sight in code
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码的视线
- en: The cost of writing a function is relatively low compared to the cost of maintaining
    it, especially in successful, long-running projects. So it is worth taking the
    time to ensure the code is readable by our future selves and others.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于维护函数的成本，编写函数的成本相对较低，尤其是在成功且长期运行的项目中。因此，花时间确保代码可以被未来的我们和其他人阅读是值得的。
- en: 'Code can be said to have a good line of sight if it is easy to glance at and
    if it understands the usual, expected flow of the statements (the happy path).
    In Go, we can achieve this by following a few simple rules when we write code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码易于浏览，并且理解语句的通常、预期流程（即“快乐路径”），则可以说代码具有良好的视线。在Go中，我们可以通过编写代码时遵循一些简单的规则来实现这一点：
- en: Align the happy path to the left edge so that you can scan down a single column
    and see the expected flow of execution
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“快乐路径”对齐到左侧边缘，这样你可以扫描单列并看到预期的执行流程。
- en: Don't hide the happy path logic inside a nest of indented braces
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将快乐路径逻辑隐藏在嵌套缩进的括号中
- en: Exit early from your function
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期退出你的函数
- en: Indent only to handle errors or edge cases
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅缩进以处理错误或边缘情况
- en: Extract functions and methods to keep bodies small and readable
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取函数和方法以保持代码体小且可读
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: There are a few more details to writing good line of sight code, which are outlined
    and maintained at [http://bit.ly/lineofsightincode](http://bit.ly/lineofsightincode).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 写好视线代码还有一些更多细节，这些细节在 [http://bit.ly/lineofsightincode](http://bit.ly/lineofsightincode)
    中概述并维护。
- en: 'In order to prevent our `CastVote` function from becoming too big and difficult
    to follow, we have broken out the core functionality into its own function, which
    we will now add to `votes.go`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的 `CastVote` 函数变得太大且难以跟踪，我们将核心功能拆分到自己的函数中，现在我们将将其添加到 `votes.go` 中：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While this function is long, its line of sight isn't too bad. The happy path
    flows down the left edge, and we only indent to return early in case of errors
    and the case where we create a new `Vote` object. This means that we can easily
    track what it is doing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数很长，但其视线并不太差。快乐路径沿着左侧边缘流动，我们仅缩进以在出现错误或创建新的 `Vote` 对象的情况下提前返回。这意味着我们可以轻松跟踪它在做什么。
- en: We take in the answer key, the related question, the user casting the vote and
    the score, and return a Vote object, or else an error if something goes wrong.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接收答案键、相关问题和投票用户以及分数，并返回一个投票对象，或者在出错时返回一个错误。
- en: First, we get the answer which, since we're inside a transaction, will lock
    it until the transaction is complete (or stops due to an error).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取答案，由于我们处于事务中，它将锁定答案直到事务完成（或由于错误而停止）。
- en: We then build the key for this vote, which is made up of the keys of both the
    answer and the user encoded into a single string. This means that only one `Vote`
    entity will exist in the data store for each user/answer pair; so a user may only
    have one vote per answer as per our design.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为这次投票构建键，这个键由答案和用户键编码成单个字符串。这意味着对于每个用户/答案对，数据存储中只存在一个 `Vote` 实体；因此，根据我们的设计，用户对每个答案只能投一次票。
- en: We then use the vote key to attempt to load the `Vote` entity from the data
    store. Of course, the first time a user votes on a question, no entity will exist,
    which we can check by seeing whether the error returned from `datastore.Get` is
    the special `datastore.ErrNoSuchEntity` value or not. If it is, we create the
    new `Vote` object, setting the appropriate fields.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用投票键尝试从数据存储中加载 `Vote` 实体。当然，当用户第一次对一个问题进行投票时，将不存在实体，我们可以通过检查 `datastore.Get`
    返回的错误是否是特殊的 `datastore.ErrNoSuchEntity` 值来检查这一点。如果是，我们创建新的 `Vote` 对象，并设置适当的字段。
- en: We are maintaining a score `delta` integer, which will represent the number
    that needs to be added to the answer score after the vote has happened. When it's
    the first time a user has voted on a question, the delta will be either `1` or
    `-1`. If they are changing their vote from down to up (`-1` to `1`), the delta
    will be `2`, which cancels out the previous vote and adds the new one. We multiply
    the delta by `-1` to undo the previous vote if there was one (if `err != datastore.ErrNoSuchEntity`).
    This has the nice effect of also not making any difference (`delta` will be 0)
    if they happen to cast the same vote twice in either direction.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们维护一个名为 `delta` 的分数整数，它将代表在投票发生后需要添加到答案分数中的数字。当用户第一次对一个问题进行投票时，`delta` 将是 `1`
    或 `-1`。如果他们从反对变为支持（`-1` 到 `1`），`delta` 将是 `2`，这将取消之前的投票并添加新的投票。我们通过将 `delta` 乘以
    `-1` 来撤销之前的投票（如果有的话，即 `err != datastore.ErrNoSuchEntity`）。这也有一个很好的效果，即如果他们意外地在两个方向上投了相同的票两次，也不会有任何区别（`delta`
    将为 0）。
- en: Finally, we change the score on the answer and put it back into the data store
    before updating the final fields in our `Vote` object and putting that in too.
    We then return and our `CastVote` function exits the `datastore.RunInTransaction`
    function block, thus releasing Answer and letting others cast their votes on it
    too.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在更新 `Vote` 对象的最终字段并将它放回数据存储之前，更改答案的分数。然后我们返回，我们的 `CastVote` 函数退出 `datastore.RunInTransaction`
    函数块，从而释放答案，让其他人也可以对其投票。
- en: Exposing data operations over HTTP
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTP 暴露数据操作
- en: Now that we have built all of our entities and the data access methods that
    operate on them, it's time to wire them up to an HTTP API. This will feel more
    familiar as we have already done this kind of thing a few times in the book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了所有实体以及操作它们的数据库访问方法，是时候将它们连接到HTTP API上了。这会感觉更熟悉，因为我们已经在书中做过几次类似的事情了。
- en: Optional features with type assertions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带类型断言的可选功能
- en: When you use interface types in Go, you can perform type assertions to see whether
    the objects implement other interfaces, and since you can write interfaces inline,
    it is possible to very easily find out whether an object implements a specific
    function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Go中使用接口类型时，你可以执行类型断言来查看对象是否实现了其他接口，并且由于你可以内联编写接口，因此可以非常容易地找出对象是否实现了特定函数。
- en: 'If `v` is `interface{}`, we can see whether it has the `OK` method using this
    pattern:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`v`是`interface{}`，我们可以使用以下模式查看它是否有`OK`方法：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the `v` object implements the method described in the interface, `ok` will
    be `true` and `obj` will be an object on which the OK method can be called. Otherwise,
    `ok` will be false.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`v`对象实现了接口中描述的方法，`ok`将为`true`，并且`obj`将是一个可以调用OK方法的对象。否则，`ok`将为`false`。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One problem with this approach is that it hides the secret functionality from
    users of the code, so you must either document the function very well in order
    to make it clear or perhaps promote the method to its own first-class interface
    and insist that all objects implement it. Remember that we must always seek clear
    code over clever code. As a side exercise, see whether you can add the interface
    and use it in the decode signature instead.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是它隐藏了代码用户的秘密功能，因此你必须非常详细地记录该函数，以便使其清晰，或者可能将该方法提升为其自己的第一类接口，并坚持要求所有对象实现它。记住，我们总是寻求清晰的代码而不是巧妙的代码。作为辅助练习，看看你是否可以添加接口并在解码签名中使用它。
- en: 'We are going to add a function that will help us decode JSON request bodies
    and, optionally, validate the input. Create a new file called `http.go` and add
    the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个函数，帮助我们解码JSON请求体，并且可选地验证输入。创建一个名为`http.go`的新文件，并添加以下代码：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The decode function takes `http.Request` and a destination value called `v`,
    which is where the data from the JSON will go. We check whether the `OK` method
    is implemented, and if it is, we call it. We expect `OK` to return nil if the
    object looks good; otherwise, we expect it to return an error that explains what
    is wrong. If we get an error, we'll return it and let the calling code deal with
    it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解码函数接受`http.Request`和一个名为`v`的目标值，其中JSON数据将放入。我们检查是否实现了`OK`方法，如果是，则调用它。我们期望`OK`在对象看起来不错时返回`nil`；否则，我们期望它返回一个错误，解释出了什么问题。如果我们得到一个错误，我们将返回它，并让调用代码处理它。
- en: If all is well, we return nil at the bottom of the function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们在函数底部返回`nil`。
- en: Response helpers
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应辅助函数
- en: 'We are going to add a pair of helper functions that will make responding to
    API requests easy. Add the `respond` function to `http.go`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一对辅助函数，这将使响应API请求变得容易。将`respond`函数添加到`http.go`中：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The respond method contains a `context`, `ResponseWriter`, `Request`, the object
    to respond with, and a status code. It encodes `v` into an internal buffer before
    setting the appropriate headers and writing the response.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 响应方法包含一个`context`、`ResponseWriter`、`Request`、要响应的对象和状态码。它在设置适当的头和写入响应之前将`v`编码到内部缓冲区中。
- en: We are using a buffer here because it's possible that the encoding might fail.
    If it does so but has already started writing the response, the 200 OK header
    will be sent to the client, which is misleading. Instead, encoding to a buffer
    lets us be sure that completes without issue before deciding what status code
    to respond with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用缓冲区，因为编码可能会失败。如果它失败了，但已经开始写入响应，那么200 OK头将被发送到客户端，这是误导的。相反，将编码到缓冲区让我们能够确保在决定响应的状态码之前，它能够无问题地完成。
- en: 'Now add the `respondErr` function at the bottom of `http.go`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`respondErr`函数添加到`http.go`文件的底部：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function writes `error` wrapped in a struct that embeds the error string
    as a field called `error`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将`error`封装在一个结构体中，该结构体将错误字符串作为名为`error`的字段嵌入。
- en: Parsing path parameters
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析路径参数
- en: Some of our API endpoints will need to pull IDs out of the path string, but
    we don't want to add any dependencies to our project (such as an external router
    package); instead, we are going to write a simple function that will parse path
    parameters for us.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些 API 端点将需要从路径字符串中提取 ID，但我们不想向我们的项目添加任何依赖（例如外部路由包）；相反，我们将编写一个简单的函数来为我们解析路径参数。
- en: 'Let''s first write a test that will explain how we want our path parsing to
    work. Create a file called http_test.go and add the following unit test:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先编写一个测试来解释我们希望我们的路径解析如何工作。创建一个名为 http_test.go 的文件，并添加以下单元测试：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We expect to be able to pass in a pattern and have a map returned that discovers
    the values from the path in `http.Request`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望能够传递一个模式，并返回一个映射，该映射从 `http.Request` 中的路径发现值。
- en: Run the test (with `go test -v`) and note that it fails.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试（使用 `go test -v`），并注意它失败了。
- en: 'At the bottom of `http.go`, add the following implementation to make the test
    pass:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `http.go` 的底部，添加以下实现以使测试通过：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function breaks the path from the specific `http.Request` and builds a
    map of the values with keys taken from breaking the pattern path. So for a pattern
    of `/questions/id` and a path of `/questions/123`, it would return the following
    map:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从特定的 `http.Request` 路径中分解，并构建一个包含从分解模式路径中获取的键的值映射。因此，对于模式 `/questions/id`
    和路径 `/questions/123`，它将返回以下映射：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, we'd ignore the `questions` key, but `id` will be useful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们会忽略 `questions` 键，但 `id` 将是有用的。
- en: Exposing functionality via an HTTP API
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 HTTP API 暴露功能
- en: 'Now we have all the tools we need in order to put together our API: helper
    functions to encode and decode data payloads in JSON, path parsing functions,
    and all the entities and data access functionality to persist and query data in
    Google Cloud Datastore.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建我们的 API 所需的所有工具：用于在 JSON 中编码和解码数据负载的辅助函数、路径解析函数，以及所有实体和数据访问功能，以在
    Google Cloud Datastore 中持久化和查询数据。
- en: HTTP routing in Go
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 中的 HTTP 路由
- en: 'The three endpoints we are going to add in order to handle questions are outlined
    in the following table:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的三个端点，以便处理问题，已在以下表格中概述：
- en: '| **HTTP request** | **Description** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 请求** | **描述** |'
- en: '| `POST /questions` | Ask a new question |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `POST /questions` | 提出一个新问题 |'
- en: '| `GET /questions/{id}` | Get the question with the specific ID |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `GET /questions/{id}` | 获取具有特定 ID 的问题 |'
- en: '| `GET /questions` | Get the top questions |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `GET /questions` | 获取顶级问题 |'
- en: Since our API design is relatively simple, there is no need to bloat out our
    project with an additional dependency to solve routing for us. Instead, we'll
    roll our own very simple adhoc routing using normal Go code. We can use a simple
    `switch` statement to detect which HTTP method was used and our `pathParams` helper
    function to see whether an ID was specified before passing execution to the appropriate
    place.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 API 设计相对简单，没有必要通过添加额外的依赖来膨胀我们的项目以解决路由问题。相反，我们将使用正常的 Go 代码编写一个非常简单的 adhoc
    路由。我们可以使用简单的 `switch` 语句来检测使用了哪种 HTTP 方法，并使用我们的 `pathParams` 辅助函数来查看是否指定了 ID，然后再将执行传递到适当的位置。
- en: 'Create a new file called `handle_questions.go` and add the following `http.HandlerFunc`
    function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `handle_questions.go` 的新文件，并添加以下 `http.HandlerFunc` 函数：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the HTTP method is `POST`, then we'll call `handleQuestionCreate`. If it's
    `GET`, then we'll see whether we can extract the ID from the path and call `handleQuestionGet`
    if we can, or `handleTopQuestions` if we cannot.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 方法是 `POST`，则我们将调用 `handleQuestionCreate`。如果是 `GET`，则我们将查看是否可以从路径中提取
    ID，如果可以，则调用 `handleQuestionGet`，否则调用 `handleTopQuestions`。
- en: Context in Google App Engine
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google App Engine 中的 Context
- en: If you remember, all of our calls to App Engine functions took a `context.Context`
    object as the first parameter, but what is that and how do we create one?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们调用 App Engine 函数时，所有调用都使用了 `context.Context` 对象作为第一个参数，但那是什么，我们如何创建一个？
- en: '`Context` is actually an interface that provides cancelation signals, execution
    deadlines, and request-scoped data throughout a stack of function calls across
    many components and API boundaries. The Google App Engine SDK for Go uses it throughout
    its APIs, the details of which are kept internal to the package, which means that
    we (as users of the SDK) don''t have to worry about it. This is a good goal for
    when you use Context in your own packages; ideally, the complexity should be kept
    internal and hidden.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`实际上是一个接口，它提供取消信号、执行截止时间和在整个函数调用堆栈中跨许多组件和 API 边界请求范围内的数据。Google App
    Engine SDK for Go 在其 API 中使用它，其细节保留在包内部，这意味着我们（作为 SDK 的用户）不必担心它。当您在自己的包中使用 Context
    时，这是一个好的目标；理想情况下，复杂性应该保持在内部并隐藏起来。'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can, and should, learn more about `Context` through various online resources,
    starting with the *Go Concurrency Patterns: Context* blog post at [https://blog.golang.org/context](https://blog.golang.org/context).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过各种在线资源了解更多关于`Context`的信息，从[https://blog.golang.org/context](https://blog.golang.org/context)上的*Go
    Concurrency Patterns: Context*博客文章开始。'
- en: To create a context suitable for App Engine calls, you use the `appengine.NewContext`
    function, which takes `http.Request` as an argument to which the context will
    belong.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建适合 App Engine 调用的上下文，您使用`appengine.NewContext`函数，该函数接受`http.Request`作为参数，上下文将属于该参数。
- en: 'Underneath the routing code we just added, let''s add the handler that will
    be responsible for creating a question, and we can see how we will create a new
    context for each request:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的路由代码下面，让我们添加一个负责创建问题的处理器，我们可以看到我们将为每个请求创建一个新的上下文：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We create `Context` and store it in the `ctx` variable, which has become somewhat
    an accepted pattern throughout the Go community. We then decode our Question (which,
    due to the `OK` method, will also validate it for us) before calling the `Create`
    helper method that we wrote earlier. Every step of the way, we pass our context
    along.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`Context`并将其存储在`ctx`变量中，这在 Go 社区中已经变成了一种接受的模式。然后我们在调用我们之前编写的`Create`辅助方法之前解码我们的`Question`（由于`OK`方法，它也会为我们验证它）。每一步，我们都传递我们的上下文。
- en: If anything goes wrong, we make a call out to our `respondErr` function, which
    will write out the response to the client before returning and exiting early from
    the function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何问题发生，我们会调用我们的`respondErr`函数，该函数会在返回并提前退出函数之前向客户端写入响应。
- en: If all is well, we respond with `Question` and a `http.StatusCreated` status
    code (201).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将以`Question`和`http.StatusCreated`状态代码（201）进行响应。
- en: Decoding key strings
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码键字符串
- en: Since we are exposing the `datastore.Key` objects as the `id` field in our objects
    (via the `json` field tags), we expect users of our API to pass back these same
    ID strings when referring to specific objects. This means that we need to decode
    these strings and turn them back into `datastore.Key` objects. Luckily, the `datastore`
    package provides the answer in the form of the `datastore.DecodeKey` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`datastore.Key`对象作为`id`字段暴露在我们的对象中（通过`json`字段标签），我们期望我们的 API 用户在引用特定对象时传递回这些相同的
    ID 字符串。这意味着我们需要解码这些字符串并将它们转换回`datastore.Key`对象。幸运的是，`datastore`包以`datastore.DecodeKey`函数的形式提供了答案。
- en: 'At the bottom of `handle_questions.go`, add the following handle function to
    get a single question:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handle_questions.go`的底部，添加以下处理函数以获取单个问题：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After we create Context again, we decode the `question ID` argument to turn
    the string back into a `datastore.Key` object. The `question ID` string is passed
    in from our routing handler code, which we added at the top of the file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次创建 Context 之后，我们将解码`问题 ID`参数，将其字符串转换回`datastore.Key`对象。`问题 ID`字符串是从我们添加在文件顶部的路由处理器代码中传递进来的。
- en: Assuming `question ID` is a valid key and the SDK was successfully able to turn
    it into `datastore.Key`, we call our `GetQuestion` helper function to load `Question`.
    If we get the `datastore.ErrNoSuchEntity` error, then we respond with a 404 (not
    found) status; otherwise, we'll report the error with a `http.StatusInternalServerError`
    code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`问题 ID`是一个有效的键，并且 SDK 成功将其转换为`datastore.Key`，我们将调用我们的`GetQuestion`辅助函数来加载`Question`。如果我们得到`datastore.ErrNoSuchEntity`错误，那么我们将以404（未找到）状态响应；否则，我们将使用`http.StatusInternalServerError`代码报告错误。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When writing APIs, check out the HTTP status codes and other HTTP standards
    and see whether you can make use of them. Developers are used to them and your
    API will feel more natural if it speaks the same language.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 API 时，检查 HTTP 状态码和其他 HTTP 标准，看看你是否可以利用它们。开发者们已经习惯了这些，如果你的 API 使用相同的语言，它将感觉更加自然。
- en: If we are able to load the question, we call `respond` and send it back to the
    client as JSON.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够加载问题，我们就调用 `respond` 并将 JSON 格式的数据发送回客户端。
- en: 'Next, we are going to expose the functionality related to answers via a similar
    API to the one we used for questions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个与用于问题的类似 API 来公开与答案相关的功能：
- en: '| **HTTP request** | **Description** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 请求** | **描述** |'
- en: '| `POST /answers` | Submit an answer |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `POST /answers` | 提交答案 |'
- en: '| `GET /answers` | Get the answers with the specified question ID |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `GET /answers` | 使用指定的问题 ID 获取答案 |'
- en: 'Create a new file called `handle_answers.go` and add the routing `http.HandlerFunc`
    function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `handle_answers.go` 的新文件，并添加路由 `http.HandlerFunc` 函数：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For `GET` requests, we call `handleAnswersGet`; for `POST` requests, we call
    `handleAnswerCreate`. By default, we'll respond with a `404 Not Found` response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GET` 请求，我们调用 `handleAnswersGet`；对于 `POST` 请求，我们调用 `handleAnswerCreate`。默认情况下，我们将响应一个
    `404 Not Found`。
- en: Using query parameters
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用查询参数
- en: 'As an alternative to parsing the path, you can just take query parameters from
    the URL in the request, which we will do when we add the handler that reads answers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解析路径的替代方案，你可以直接从请求的 URL 中获取查询参数，当我们添加读取答案的处理程序时，我们将这样做：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we use `r.URL.Query()` to get the `http.Values` that contains the query
    parameters and use the Get method to pull out `question_id`. So, the API call
    will look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `r.URL.Query()` 来获取包含查询参数的 `http.Values`，并使用 Get 方法提取 `question_id`。因此，API
    调用将如下所示：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should be consistent in your API in the real world. We have used a mix of
    path parameters and query parameters to show off the differences, but it is recommended
    that you pick one style and stick to it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的 API 中，你应该保持一致性。我们使用了路径参数和查询参数的混合来展示它们之间的区别，但建议你选择一种风格并坚持下去。
- en: Anonymous structs for request data
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求数据的匿名结构体
- en: The API for answering a question is to post to `/api/answers` with a body that
    contains the answer details as well as the question ID string. This structure
    is not the same as our internal representation of `Answer` because the question
    ID string would need to be decoded into `datastore.Key`. We could leave the field
    in and indicate with field tags that it should be omitted from both the JSON and
    the data store, but there is a cleaner approach.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 回答问题的 API 是通过将包含答案详情以及问题 ID 字符串的正文发送到 `/api/answers` 来实现的。这个结构与我们的内部 `Answer`
    表示不同，因为问题 ID 字符串需要解码成 `datastore.Key`。我们可以保留该字段，并通过字段标签指示它应从 JSON 和数据存储中省略，但有一个更干净的方法。
- en: We can specify an inline, anonymous structure to hold the new answer, and the
    best place to do this is inside the handler function that deals with that data
    this means that we don't need to add a new type to our API, but we can still represent
    the request data we are expecting.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个内联的匿名结构体来保存新的答案，并且最好的地方是在处理该数据的处理程序函数内部这样做意味着我们不需要在我们的 API 中添加一个新类型，但我们仍然可以表示我们期望的请求数据。
- en: 'At the bottom of `handle_answers.go`, add the `handleAnswerCreate` function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handle_answers.go` 的底部添加 `handleAnswerCreate` 函数：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Look at the somewhat unusual `var newAnswer struct` line. We are declaring a
    new variable called `newAnswer`, which has a type of an anonymous struct (it has
    no name) that contains `QuestionID string` and embeds `Answer`. We can decode
    the request body into this type, and we will capture any specific `Answer` fields
    as well as `QuestionID`. We then decode the question ID into `datastore.Key` as
    we did earlier, validate the answer, and set the `User` (`UserCard`) field by
    getting the currently authenticated user and calling the `Card` helper method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下有些不寻常的 `var newAnswer struct` 行。我们声明了一个名为 `newAnswer` 的新变量，它具有匿名结构体的类型（它没有名字），包含
    `QuestionID string` 并嵌入 `Answer`。我们可以将请求体解码到这种类型中，并捕获任何特定的 `Answer` 字段以及 `QuestionID`。然后，我们将问题
    ID 解码成 `datastore.Key`，就像我们之前做的那样，验证答案，并通过获取当前认证用户并调用 `Card` 辅助方法来设置 `User` (`UserCard`)
    字段。
- en: If all is well, we call `Create`, which will do the work to save the answer
    to the question.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将调用 `Create`，这将完成将答案保存到问题的相关工作。
- en: Finally, we need to expose the voting functionality in our API.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的 API 中公开投票功能。
- en: Writing self-similar code
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自相似代码
- en: Our voting API has only a single endpoint, a post to `/votes`. So, of course,
    there is no need to do any routing on this method (we could just check the method
    in the handler itself), but there is something to be said for writing code that
    is familiar and similar to other code in the same package. In our case, omitting
    a router might jar a little if somebody else is looking at our code and expects
    one after seeing the routers for questions and answers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们投票API只有一个端点，即对`/votes`的POST请求。所以，当然，在这个方法上不需要进行任何路由（我们可以在处理器本身中检查方法），但是编写熟悉且与其他同一包中的代码相似的代码是有一定道理的。在我们的情况下，如果有人查看我们的代码并看到问题路由器后期望有一个路由器，那么省略路由器可能会让人感到有些不适应。
- en: 'So let''s add a simple router handler to a new file called `handle_votes.go`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们向一个名为`handle_votes.go`的新文件中添加一个简单的路由处理器：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our router just checks the method and exits early if it's not `POST`, before
    calling the `handleVote` function, which we will add next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由器仅检查方法，如果它不是`POST`，则在调用`handleVote`函数之前就提前退出，我们将在下一部分添加这个函数。
- en: Validation methods that return an error
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回错误的验证方法
- en: The `OK` method that we added to some of our objects is a nice way to add validation
    methods to our code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到一些对象中的`OK`方法是一种很好的方式，可以将验证方法添加到我们的代码中。
- en: 'We want to ensure that the incoming score value is valid (in our case, either
    `-1` or `1`), so we could write a function like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确保传入的分数值是有效的（在我们的例子中，是`-1`或`1`），因此我们可以编写一个像这样的函数：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we used this function in a few places, we would have to keep repeating the
    code that explained that the score was not valid. If, however, the function returns
    an error, you can encapsulate that in one place.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在几个地方使用这个函数，我们就必须重复解释分数无效的代码。然而，如果函数返回一个错误，你可以在一个地方封装它。
- en: 'To `votes.go`, add the following `validScore` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`validScore`函数添加到`votes.go`中：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this version, we return `nil` if the score is valid; otherwise, we return
    an error that explains what is wrong.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，如果分数有效，我们返回`nil`；否则，我们返回一个错误，解释了哪里出了问题。
- en: 'We will make use of this validation function when we add our `handleVote` function
    to `handle_votes.go`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`handleVote`函数添加到`handle_votes.go`时，我们将使用这个验证函数：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will look pretty familiar by now, which highlights why we put all the data
    access logic in a different place to our handlers; the handlers can then focus
    on HTTP tasks, such as decoding the request and writing the response, and leave
    the application specifics to the other objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这看起来已经很熟悉了，这突出了为什么我们将所有数据访问逻辑放在与我们的处理器不同的地方；处理器可以专注于HTTP任务，例如解码请求和写入响应，并将应用程序的特定细节留给其他对象。
- en: We have also broken down the logic into distinct files, with a pattern of prefixing
    HTTP handler code with `handle_`, so we quickly know where to look when we want
    to work on a specific piece of the project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将逻辑分解为不同的文件，以`handle_`作为HTTP处理器代码的前缀模式，这样当我们想要工作在项目的特定部分时，我们可以快速知道在哪里查找。
- en: Mapping the router handlers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由处理器映射
- en: 'Let''s update our `main.go` file by changing the `init` function to map the
    real handlers to HTTP paths:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将`init`函数更改为将实际处理器映射到HTTP路径来更新我们的`main.go`文件：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also remove the now redundant `handleHello` handler function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以移除现在多余的`handleHello`处理器函数。
- en: Running apps with multiple modules
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行具有多个模块的应用程序
- en: For applications such as ours that have multiple modules, we need to list out
    all the YAML files for the `goapp` command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我们这样的具有多个模块的应用程序，我们需要列出所有`goapp`命令的YAML文件。
- en: 'To serve our new application, in a terminal, execute this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供我们的新应用程序，在终端中执行以下命令：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Starting with the dispatch file, we are listing all the associated configuration
    files. If you miss any, you will see an error when you try to serve your application.
    Here, you will notice that the output now lists that each module is being deployed
    on a different port:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从调度文件开始，我们列出了所有相关的配置文件。如果你遗漏了任何一个，当你尝试提供你的应用程序服务时，你会看到一个错误。在这里，你会注意到输出现在列出了每个模块正在不同的端口上部署：
- en: '![Running apps with multiple modules](img/00068.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![运行具有多个模块的应用程序](img/00068.jpeg)'
- en: We can access modules directly by visiting each port, but luckily we have our
    dispatcher running on port `:8080`, which will do that for us based on the rules
    we specified in our `dispatch.yaml` configuration file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接通过访问每个端口来访问模块，但幸运的是，我们的分发器正在端口`:8080`上运行，它将根据我们在`dispatch.yaml`配置文件中指定的规则为我们做这件事。
- en: Testing locally
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地测试
- en: 'Now that we have built our application, head over to `localhost:8080` to see
    it in action. Use the features of the application by performing the following
    steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了应用程序，转到`localhost:8080`来查看它的实际运行情况。通过以下步骤使用应用程序的功能：
- en: Log in using your real e-mail address (that way, you'll see your Gravatar picture).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的真实电子邮件地址登录（这样，你将看到你的Gravatar图片）。
- en: Ask a question.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提出一个问题。
- en: Submit a couple of answers.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交几个答案。
- en: Vote the answers up and down and see the scores changing.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对答案进行上下投票，并查看分数的变化。
- en: Open another browser and sign in as someone else to see what the application
    looks like from their point of view.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个浏览器，以其他身份登录，看看应用程序从他们的角度来看是什么样子。
- en: Using the admin console
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用管理控制台
- en: 'The admin console is running alongside our application and is accessible at
    `localhost:8000`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 管理控制台与我们的应用程序并行运行，并且可以通过`localhost:8000`访问：
- en: '![Using the admin console](img/00069.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![使用管理控制台](img/00069.jpeg)'
- en: '**Datastore Viewer** lets you inspect the data of your application. You can
    use it to see (and even make changes to) the questions, answers, and votes data
    that are being generated as you use the application.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据存储查看器**让你检查应用程序的数据。你可以用它来查看（甚至修改）当你使用应用程序时生成的问答和投票数据。'
- en: Automatically generated indexes
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动生成的索引
- en: You can also see which indexes have been automatically created by the development
    server in order to satisfy the queries your application makes. In fact, if you
    look in the default folder, you will notice that a new file called `index.yaml`
    has magically appeared. This file describes those same indexes that your application
    will need, and when you deploy your application, this file goes up to the cloud
    with it to tell Google Cloud Datastore to maintain these same indexes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看开发服务器为满足你的应用程序查询而自动创建的哪些索引。实际上，如果你查看默认文件夹，你会注意到一个名为`index.yaml`的新文件神奇地出现了。这个文件描述了你的应用程序需要的相同索引，当你部署你的应用程序时，这个文件会随着它一起上传到云端，以告诉谷歌云数据存储维护这些相同的索引。
- en: Deploying apps with multiple modules
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署具有多个模块的应用程序
- en: Deploying the application is slightly more complicated with multiple modules,
    as the dispatcher and index files each require a dedicated deployment command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 部署具有多个模块的应用程序稍微复杂一些，因为分发器和索引文件每个都需要一个专门的部署命令。
- en: 'Deploy the modules with the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令部署模块：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the operation has finished, we can update the dispatcher using the `appcfg.py`
    command (which you must ensure is in your path you''ll find it in the Google App
    Engine SDK for the Go folder we downloaded at the start of the chapter):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作完成，我们可以使用`appcfg.py`命令（你必须确保它在你的路径中，你可以在我们本章开始时下载的谷歌应用引擎SDK for Go文件夹中找到它）更新分发器：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the dispatch has been updated, we can push the indexes to the cloud:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分发器更新后，我们可以将索引推送到云端：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that the application is deployed, we can see it in the wild by navigating
    to our *appspot* URL; `https://YOUR_APPLICATION_ID_HERE.appspot.com/`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经部署，我们可以通过导航到我们的*appspot* URL来在野外看到它；`https://YOUR_APPLICATION_ID_HERE.appspot.com/`。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might get an error that says `The index for this query is not ready to serve`.
    This is because it takes Google Cloud Datastore a little time to prepare things
    on the server; usually, it doesn't take more than a few minutes, so go and have
    a cup of coffee and try again later.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到一个错误，说“此查询的索引尚未准备好提供服务”。这是因为谷歌云数据存储需要一点时间来在服务器上准备事情；通常，这不会超过几分钟，所以去喝杯咖啡，稍后再试。
- en: An interesting aside is that if you hit the URL with HTTPS, Google's servers
    will serve it using HTTP/2.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的细节是，如果你用HTTPS访问URL，谷歌的服务器将使用HTTP/2来提供服务。
- en: Once your application is functional, ask an interesting question and send the
    link to your friends to solicit answers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用程序功能正常，提出一个有趣的问题，并将链接发送给你的朋友以征求答案。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a fully functional question and answer application
    for Google App Engine.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为谷歌应用引擎构建了一个完全功能性的问答应用。
- en: We learned how to use the Google App Engine SDK for Go to build and test our
    application locally before deploying it to the cloud, ready for our friends and
    family to use. The application is ready to scale if it suddenly starts getting
    a lot of traffic, and we can rely on the healthy quota to satisfy early traffic.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用谷歌应用引擎SDK for Go在本地构建和测试我们的应用程序，然后再将其部署到云端，以便我们的朋友和家人使用。如果应用程序突然开始获得大量流量，它就可以扩展，我们可以依赖健康的配额来满足早期流量。
- en: We explored how to model data in Go code, keep track of keys, and persist and
    query data in Google Cloud Datastore. We also explored strategies to denormalize
    such data in order to make it quicker to read back at scale. We saw how transactions
    can guarantee data integrity by ensuring that only one operation occurs at a particular
    point in time, allowing us to build reliable counters for the score of our answers.
    We used predictable data store keys to ensure that our users can only have one
    vote per answer, and we used incomplete keys when we wanted the data store to
    generate the keys for us.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何在Go代码中建模数据，跟踪键，以及在Google Cloud Datastore中持久化和查询数据。我们还探讨了如何通过去规范化这些数据来提高大规模读取的速度。我们看到了如何通过确保在特定时间点只发生一个操作来保证数据完整性，从而为我们答案的得分构建可靠的计数器。我们使用可预测的数据存储键来确保我们的用户对每个答案只能投一票，当我们希望数据存储为我们生成键时，我们使用不完整的键。
- en: A lot of the techniques explored in this chapter would apply to any kind of
    application that persists data and interacts over a RESTful JSON API so the skills
    are highly transferrable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨的许多技术都适用于任何需要持久化数据并通过RESTful JSON API进行交互的应用程序，因此这些技能具有很强的可迁移性。
- en: In the next chapter, we are going to explore modern software architecture by
    building a real micro-service using the Go Kit framework. There are a lot of benefits
    to building solutions using micro-services, and so they have become a very popular
    choice for large, distributed systems. Lots of companies are already running such
    architectures (mostly written in Go) in production, and we will look at how they
    do it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用Go Kit框架构建一个真实的微服务来探索现代软件架构。使用微服务构建解决方案有很多好处，因此它们已经成为大型分布式系统的一个非常流行的选择。许多公司已经在生产中运行这样的架构（主要是用Go编写的），我们将看看他们是怎样做到的。
