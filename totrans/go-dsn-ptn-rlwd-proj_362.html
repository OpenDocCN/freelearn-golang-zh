<html><head></head><body>
<div class="book" title="Chapter&#xA0;2.&#xA0;Creational Patterns - Singleton, Builder, Factory, Prototype, and Abstract Factory Design Patterns">
<div class="book" title="Singleton design pattern - having a unique instance of a type in the entire program">
<div class="book" title="Writing unit tests first"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec034" class="calibre1"/>Writing unit tests first</h2></div></div></div><p class="calibre10">Go's implementation of this pattern is slightly different from what you'll find in pure object-oriented languages such as Java or C++, where you have static members. In Go, there's nothing like static members, but we have package scope to deliver a similar result.</p><p class="calibre10">To set up our project, we must create a new folder within our <code class="email">$GOPATH/src</code> directory. The general rule as we mentioned in the <a class="calibre1" title="Chapter 1. Ready... Steady... Go!" href="part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 1</a>, <span class="strong"><em class="calibre11">Ready... Steady... Go!</em></span>, is to create a subfolder with the VCS provider (such as GitHub), the username, and the name of the project.</p><p class="calibre10">For example, in my case, I use GitHub as my VCS and my username is <span class="strong"><em class="calibre11">sayden,</em></span> so I will create the path <code class="email">$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton</code>. The <code class="email">go-design-patterns</code> instance in the path is the project name, the creational subfolder will also be our library name, and singleton the name of this particular package and subfolder:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">mkdir -p $GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton
</strong></span>
<span class="strong"><strong class="calibre2">cd $GOPATH/src/github.com/sayden/go-design-</strong></span>
<span class="strong"><strong class="calibre2">patterns/creational/singleton</strong></span>
</pre><p class="calibre10">Create a new file inside the singleton folder called <code class="email">singleton.go</code> to also reflect the name of the package and write the following package declarations for the <code class="email">singleton</code> type:</p><pre class="programlisting">package singleton 
 
type Singleton interface { 
    AddOne() int 
} 
 
type singleton struct { 
    count int 
} 
 
var instance *singleton 
 
func GetInstance() Singleton { 
    return nil 
} 
func (s *singleton) AddOne() int { 
    return 0 
} 
</pre><p class="calibre10">As we are following a TDD approach while writing the code, let's code the tests that use the functions we have just declared. The tests are going to be defined by following the acceptance criteria that we have written earlier. By convention in test files, we must create a file with the same name as the file to test, suffixed with <code class="email">_test.go</code>. Both must reside in the same folder:</p><pre class="programlisting">package singleton 
 
import "testing" 
 
func TestGetInstance(t *testing.T) { 
   counter1 := GetInstance() 
 
   if counter1 == nil { 
         //Test of acceptance criteria 1 failed 
         t.Error("expected pointer to Singleton after calling GetInstance(), not nil") 
   } 
 
   expectedCounter := counter1 
} 
</pre><p class="calibre10">The first test checks something obvious, but no less important, in complex applications. We actually receive something when we ask for an instance of the counter. We have to think of it as a Creational pattern--we delegate the creation of the object to an unknown package that could fail in the creation or retrieval of the object. We also store the current counter in the <code class="email">expectedCounter</code> variable to make a comparison later:</p><pre class="programlisting">currentCount := counter1.AddOne() 
if currentCount != 1 { 
     t.Errorf("After calling for the first time to count, the count must be 1 but it is %d\n", currentCount) 
} 
</pre><p class="calibre10">Now we take advantage of the zero-initialization feature of Go. Remember that integer types in Go cannot be nil and as we know, that this is the first call to the counter, and it is an integer type of variable, and we also know that it is zero-initialized. So after the first call to the <code class="email">AddOne()</code> function, the value of the count must be 1.</p><p class="calibre10">The test that checks the second condition proves that the <code class="email">expectedConnection</code> variable is not different to the returned connection that we requested later. If they were different, the message <code class="email">Singleton instances must be different</code> will cause the test to fail:</p><pre class="programlisting">counter2 := GetInstance() 
if counter2 != expectedCounter { 
    //Test 2 failed 
    t.Error("Expected same instance in counter2 but it got a different instance") 
} 
</pre><p class="calibre10">The last test is simply counting 1 again with the second instance. The previous result was 1, so now it must give us 2:</p><pre class="programlisting">currentCount = counter2.AddOne() 
if currentCount != 2 { 
    t.Errorf("After calling 'AddOne' using the second counter, the current count must be 2 but was %d\n", currentCount) 
} 
</pre><p class="calibre10">The last thing we have to do to finish our test part is to execute the tests to make sure that they are failing before implementation. If one of them doesn't fail, it implies that we have done something wrong, and we have to reconsider that particular test. We must open the terminal and navigate to the path of the singleton package to execute:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetInstance</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestGetInstance (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        singleton_test.go:9: expected pointer to Singleton after calling GetInstance(), not nil</strong></span>
<span class="strong"><strong class="calibre2">        singleton_test.go:15: After calling for the first time to count, the count must be 1 but it is 0</strong></span>
<span class="strong"><strong class="calibre2">        singleton_test.go:27: After calling 'AddOne' using the second counter, the current count must be 2 but was 0</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre></div></div></div></body></html>