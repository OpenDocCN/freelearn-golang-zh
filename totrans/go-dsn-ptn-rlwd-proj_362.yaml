- en: Writing unit tests first
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先编写单元测试
- en: Go's implementation of this pattern is slightly different from what you'll find
    in pure object-oriented languages such as Java or C++, where you have static members.
    In Go, there's nothing like static members, but we have package scope to deliver
    a similar result.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 对该模式的实现与你在像 Java 或 C++ 这样的纯面向对象语言中找到的略有不同，在这些语言中你有静态成员。在 Go 中，没有类似静态成员的东西，但我们有包作用域来达到类似的效果。
- en: To set up our project, we must create a new folder within our `$GOPATH/src`
    directory. The general rule as we mentioned in the [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!*, is to create a
    subfolder with the VCS provider (such as GitHub), the username, and the name of
    the project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的项目，我们必须在 `$GOPATH/src` 目录内创建一个新的文件夹。正如我们在 [第 1 章](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第 1 章。准备... 就绪... 开始！") 中提到的，一般的规则是创建一个包含版本控制系统提供者（如 GitHub）、用户名和项目名称的子文件夹。
- en: 'For example, in my case, I use GitHub as my VCS and my username is *sayden,*
    so I will create the path `$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton`.
    The `go-design-patterns` instance in the path is the project name, the creational
    subfolder will also be our library name, and singleton the name of this particular
    package and subfolder:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的情况下，我使用 GitHub 作为我的版本控制系统，我的用户名是 *sayden*，所以我将创建路径 `$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton`。路径中的
    `go-design-patterns` 实例是项目名称，创建性子文件夹也将是我们的库名称，而 singleton 是这个特定包和子文件夹的名称：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new file inside the singleton folder called `singleton.go` to also
    reflect the name of the package and write the following package declarations for
    the `singleton` type:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在单例文件夹内创建一个名为 `singleton.go` 的新文件，以反映包名，并为 `singleton` 类型编写以下包声明：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we are following a TDD approach while writing the code, let''s code the
    tests that use the functions we have just declared. The tests are going to be
    defined by following the acceptance criteria that we have written earlier. By
    convention in test files, we must create a file with the same name as the file
    to test, suffixed with `_test.go`. Both must reside in the same folder:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在编写代码时遵循 TDD 方法，让我们编写使用我们刚刚声明的函数的测试。测试将通过遵循我们之前编写的验收标准来定义。按照测试文件的惯例，我们必须创建一个与要测试的文件同名的文件，后缀为
    `_test.go`。这两个文件都必须位于同一个文件夹中：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first test checks something obvious, but no less important, in complex
    applications. We actually receive something when we ask for an instance of the
    counter. We have to think of it as a Creational pattern--we delegate the creation
    of the object to an unknown package that could fail in the creation or retrieval
    of the object. We also store the current counter in the `expectedCounter` variable
    to make a comparison later:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试检查的是复杂应用程序中的一个明显但同样重要的内容。当我们请求计数器的实例时，我们实际上收到了一些东西。我们必须将其视为一个创建型模式--我们将对象的创建委托给一个未知的包，该包可能在创建或检索对象时失败。我们还将在
    `expectedCounter` 变量中存储当前计数器，以便稍后进行比较：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we take advantage of the zero-initialization feature of Go. Remember that
    integer types in Go cannot be nil and as we know, that this is the first call
    to the counter, and it is an integer type of variable, and we also know that it
    is zero-initialized. So after the first call to the `AddOne()` function, the value
    of the count must be 1.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们利用 Go 的零初始化功能。记住，Go 中的整数类型不能为 nil，并且我们知道，这是对计数器的第一次调用，它是一个整数类型的变量，我们也知道它是零初始化的。所以，在第一次调用
    `AddOne()` 函数后，计数器的值必须是 1。
- en: 'The test that checks the second condition proves that the `expectedConnection`
    variable is not different to the returned connection that we requested later.
    If they were different, the message `Singleton instances must be different` will
    cause the test to fail:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 检查第二个条件的测试证明了 `expectedConnection` 变量与我们后来请求返回的连接没有不同。如果它们不同，消息 `Singleton 实例必须不同`
    将导致测试失败：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last test is simply counting 1 again with the second instance. The previous
    result was 1, so now it must give us 2:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试只是用第二个实例再次计数 1。前一个结果是 1，所以现在它必须给出 2：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last thing we have to do to finish our test part is to execute the tests
    to make sure that they are failing before implementation. If one of them doesn''t
    fail, it implies that we have done something wrong, and we have to reconsider
    that particular test. We must open the terminal and navigate to the path of the
    singleton package to execute:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成测试部分最后要做的，就是执行测试以确保在实施之前它们都在失败。如果其中之一没有失败，这意味着我们做错了什么，我们必须重新考虑那个特定的测试。我们必须打开终端并导航到单例包的路径来执行：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
