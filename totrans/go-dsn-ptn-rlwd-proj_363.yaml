- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we have to implement the Singleton pattern. As we mentioned earlier,
    we''ll usually write a `static` method and instance to retrieve the Singleton
    instance in languages such as Java or C++. In Go, we don''t have the keyword `static`,
    but we can achieve the same result by using the scope of the package. First, we
    create a `struct` that contains the object which we want to guarantee to be a
    Singleton during the execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We must pay close attention to this piece of code. In languages such as Java
    or C++, the variable instance would be initialized to NULL at the beginning of
    the program. In Go, you can initialize a pointer to a struct as `nil`, but you
    cannot initialize a structure to `nil` (the equivalent of NULL). So the `var instance
    *singleton` line defines a pointer to a struct of type Singleton as nil, and the
    variable called `instance`.
  prefs: []
  type: TYPE_NORMAL
- en: We created a `GetInstance` method that checks if the instance has not been initialized
    already (`instance == nil`), and creates an instance in the space already allocated
    in the line `instance = new(singleton)`. Remember, when we use the keyword `new`,
    we are creating a pointer to an instance of the type between the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddOne` method will take the count of the variable instance, raise it by
    1, and return the current value of the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run now our unit tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
