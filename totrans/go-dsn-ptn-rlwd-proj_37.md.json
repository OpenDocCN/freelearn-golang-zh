["```go\nfunc veryLongFunctionWithLotsOfArguments(one string, two int, three\n http.Handler, four string) (bool, error) { \n  log.Println(\"first line of the function\") \n} \n\n```", "```go\nPOST /users \n{ \n  \"name\": \"Mat\", \n  \"twitter\": \"@matryer\" \n} \n\n```", "```go\n201 Created \n{ \n  \"id\": 1, \n  \"name\": \"Mat\", \n  \"twitter\": \"@matryer\" \n} \n\n```", "```go\n<person> \n  <name>MAT</name> \n</person> \n\n```", "```go\n{\"name\":\"MAT\"} \n\n```", "```go\ngo get -u github.com/golang/protobuf/{proto,protoc-gen-go}\n\n```", "```go\nsyntax = \"proto3\"; \npackage pb; \nservice Vault { \n  rpc Hash(HashRequest) returns (HashResponse) {} \n  rpc Validate(ValidateRequest) returns (ValidateResponse) {} \n} \nmessage HashRequest { \n  string password = 1; \n} \nmessage HashResponse { \n  string hash = 1; \n  string err = 2; \n} \nmessage ValidateRequest { \n  string password = 1; \n  string hash = 2; \n} \nmessage ValidateResponse { \n  bool valid = 1; \n} \n\n```", "```go\ntype name = position; \n\n```", "```go\nprotoc vault.proto --go_out=plugins=grpc:.\n\n```", "```go\n// Service provides password hashing capabilities. \ntype Service interface { \n  Hash(ctx context.Context, password string) (string,\n    error) \n  Validate(ctx context.Context, password, hash string)\n    (bool, error) \n} \n\n```", "```go\ntype vaultService struct{} \n\n```", "```go\npackage vault \nimport ( \n  \"testing\" \n  \"golang.org/x/net/context\" \n) \nfunc TestHasherService(t *testing.T) { \n  srv := NewService() \n  ctx := context.Background() \n  h, err := srv.Hash(ctx, \"password\") \n  if err != nil { \n    t.Errorf(\"Hash: %s\", err) \n  } \n  ok, err := srv.Validate(ctx, \"password\", h) \n  if err != nil { \n    t.Errorf(\"Valid: %s\", err) \n  } \n  if !ok { \n    t.Error(\"expected true from Valid\") \n  } \n  ok, err = srv.Validate(ctx, \"wrong password\", h) \n  if err != nil { \n    t.Errorf(\"Valid: %s\", err) \n  } \n  if ok { \n    t.Error(\"expected false from Valid\") \n  } \n} \n\n```", "```go\n// NewService makes a new Service. \nfunc NewService() Service { \n  return vaultService{} \n} \n\n```", "```go\nfunc (vaultService) Hash(ctx context.Context, password\n string) (string, error) { \n  hash, err :=\n    bcrypt.GenerateFromPassword([]byte(password),\n    bcrypt.DefaultCost) \n  if err != nil { \n    return \"\", err \n  } \n  return string(hash), nil \n} \n\n```", "```go\nfunc (vaultService) Validate(ctx context.Context,\n  password, hash string) (bool, error) { \n  err := bcrypt.CompareHashAndPassword([]byte(hash),\n    []byte(password)) \n  if err != nil { \n    return false, nil \n  } \n  return true, nil \n} \n\n```", "```go\ntype hashRequest struct { \n  Password string `json:\"password\"` \n} \ntype hashResponse struct { \n  Hash string `json:\"hash\"` \n  Err  string `json:\"err,omitempty\"` \n} \n\n```", "```go\nfunc decodeHashRequest(ctx context.Context, r\n *http.Request) (interface{}, error) { \n  var req hashRequest \n  err := json.NewDecoder(r.Body).Decode(&req) \n  if err != nil { \n    return nil, err \n  } \n  return req, nil \n} \n\n```", "```go\ntype validateRequest struct { \n  Password string `json:\"password\"` \n  Hash     string `json:\"hash\"` \n} \ntype validateResponse struct { \n  Valid bool   `json:\"valid\"` \n  Err   string `json:\"err,omitempty\"` \n} \nfunc decodeValidateRequest(ctx context.Context, \n r *http.Request) (interface{}, error) { \n  var req validateRequest \n  err := json.NewDecoder(r.Body).Decode(&req) \n  if err != nil { \n    return nil, err \n  } \n  return req, nil \n} \n\n```", "```go\nfunc encodeResponse(ctx context.Context, \n  w http.ResponseWriter, response interface{})\nerror { \n  return json.NewEncoder(w).Encode(response) \n} \n\n```", "```go\ntype Endpoint func(ctx context.Context, request\n  interface{})  \n(response interface{}, err error) \n\n```", "```go\nfunc MakeHashEndpoint(srv Service) endpoint.Endpoint { \n  return func(ctx context.Context, request interface{})\n  (interface{}, error) { \n    req := request.(hashRequest) \n    v, err := srv.Hash(ctx, req.Password) \n    if err != nil { \n      return hashResponse{v, err.Error()}, nil \n    } \n    return hashResponse{v, \"\"}, nil \n  } \n} \n\n```", "```go\nfunc MakeValidateEndpoint(srv Service) endpoint.Endpoint { \n  return func(ctx context.Context, request interface{})\n  (interface{}, error) { \n    req := request.(validateRequest) \n    v, err := srv.Validate(ctx, req.Password, req.Hash) \n    if err != nil { \n      return validateResponse{false, err.Error()}, nil \n    } \n    return validateResponse{v, \"\"}, nil \n  } \n} \n\n```", "```go\ntype Endpoints struct { \n  HashEndpoint     endpoint.Endpoint \n  ValidateEndpoint endpoint.Endpoint \n} \n\n```", "```go\nfunc (e Endpoints) Hash(ctx context.Context, password\n  string) (string, error) { \n  req := hashRequest{Password: password} \n  resp, err := e.HashEndpoint(ctx, req) \n  if err != nil { \n    return \"\", err \n  } \n  hashResp := resp.(hashResponse) \n  if hashResp.Err != \"\" { \n    return \"\", errors.New(hashResp.Err) \n  } \n  return hashResp.Hash, nil \n} \n\n```", "```go\nfunc (e Endpoints) Validate(ctx context.Context, password,\n hash string) (bool, error) { \n  req := validateRequest{Password: password, Hash: hash} \n  resp, err := e.ValidateEndpoint(ctx, req) \n  if err != nil { \n    return false, err \n  } \n  validateResp := resp.(validateResponse) \n  if validateResp.Err != \"\" { \n    return false, errors.New(validateResp.Err) \n  } \n  return validateResp.Valid, nil \n} \n\n```", "```go\npackage vault \nimport ( \n  \"net/http\" \n  httptransport \"github.com/go-kit/kit/transport/http\" \n  \"golang.org/x/net/context\" \n) \nfunc NewHTTPServer(ctx context.Context, endpoints\n Endpoints) http.Handler { \n  m := http.NewServeMux() \n  m.Handle(\"/hash\", httptransport.NewServer( \n    ctx, \n    endpoints.HashEndpoint, \n    decodeHashRequest, \n    encodeResponse, \n  )) \n  m.Handle(\"/validate\", httptransport.NewServer( \n    ctx, \n    endpoints.ValidateEndpoint, \n    decodeValidateRequest, \n    encodeResponse, \n  )) \n  return m \n} \n\n```", "```go\ntype VaultServer interface { \n  Hash(context.Context, *HashRequest)\n    (*HashResponse, error) \n  Validate(context.Context, *ValidateRequest)\n    (*ValidateResponse, error) \n} \n\n```", "```go\npackage vault \nimport ( \n  \"golang.org/x/net/context\" \n  grpctransport \"github.com/go-kit/kit/transport/grpc\" \n) \ntype grpcServer struct { \n  hash     grpctransport.Handler \n  validate grpctransport.Handler \n} \nfunc (s *grpcServer) Hash(ctx context.Context,\n r *pb.HashRequest) (*pb.HashResponse, error) { \n  _, resp, err := s.hash.ServeGRPC(ctx, r) \n  if err != nil { \n    return nil, err \n  } \n  return resp.(*pb.HashResponse), nil \n} \nfunc (s *grpcServer) Validate(ctx context.Context,\n r *pb.ValidateRequest) (*pb.ValidateResponse, error) { \n  _, resp, err := s.validate.ServeGRPC(ctx, r) \n  if err != nil { \n    return nil, err \n  } \n  return resp.(*pb.ValidateResponse), nil \n} \n\n```", "```go\nfunc EncodeGRPCHashRequest(ctx context.Context,\n  r interface{}) (interface{}, error) { \n  req := r.(hashRequest) \n  return &pb.HashRequest{Password: req.Password}, nil \n} \n\n```", "```go\nfunc DecodeGRPCHashRequest(ctx context.Context,\n r interface{}) (interface{}, error) { \n  req := r.(*pb.HashRequest) \n  return hashRequest{Password: req.Password}, nil \n} \nfunc EncodeGRPCHashResponse(ctx context.Context,\n r interface{}) (interface{}, error) { \n  res := r.(hashResponse) \n  return &pb.HashResponse{Hash: res.Hash, Err: res.Err},\n    nil \n} \nfunc DecodeGRPCHashResponse(ctx context.Context,\n r interface{}) (interface{}, error) { \n  res := r.(*pb.HashResponse) \n  return hashResponse{Hash: res.Hash, Err: res.Err}, nil \n} \nfunc EncodeGRPCValidateRequest(ctx context.Context,\n r interface{}) (interface{}, error) { \n  req := r.(validateRequest) \n  return &pb.ValidateRequest{Password: req.Password,\n    Hash: req.Hash}, nil \n} \nfunc DecodeGRPCValidateRequest(ctx context.Context,\n r interface{}) (interface{}, error) { \n  req := r.(*pb.ValidateRequest) \n  return validateRequest{Password: req.Password,\n    Hash: req.Hash}, nil \n} \nfunc EncodeGRPCValidateResponse(ctx context.Context,\n r interface{}) (interface{}, error) { \n  res := r.(validateResponse) \n  return &pb.ValidateResponse{Valid: res.Valid}, nil \n} \nfunc DecodeGRPCValidateResponse(ctx context.Context,\n r interface{}) (interface{}, error) { \n  res := r.(*pb.ValidateResponse) \n  return validateResponse{Valid: res.Valid}, nil \n} \n\n```", "```go\nfunc NewGRPCServer(ctx context.Context, endpoints\n Endpoints) pb.VaultServer { \n  return &grpcServer{ \n    hash: grpctransport.NewServer( \n      ctx, \n      endpoints.HashEndpoint, \n      DecodeGRPCHashRequest, \n      EncodeGRPCHashResponse, \n    ), \n    validate: grpctransport.NewServer( \n      ctx, \n      endpoints.ValidateEndpoint, \n      DecodeGRPCValidateRequest, \n      EncodeGRPCValidateResponse, \n    ), \n  } \n} \n\n```", "```go\nimport ( \n  \"flag\" \n  \"fmt\" \n  \"log\" \n  \"net\" \n  \"net/http\" \n  \"os\" \n  \"os/signal\" \n  \"syscall\" \n  \"your/path/to/vault\" \n  \"your/path/to/vault/pb\" \n  \"golang.org/x/net/context\" \n  \"google.golang.org/grpc\" \n) \n\n```", "```go\nfunc main() { \n  var ( \n    httpAddr = flag.String(\"http\", \":8080\",\n      \"http listen address\") \n    gRPCAddr = flag.String(\"grpc\", \":8081\",\n      \"gRPC listen address\") \n  ) \n  flag.Parse() \n  ctx := context.Background() \n  srv := vault.NewService() \n  errChan := make(chan error) \n\n```", "```go\n  go func() { \n    c := make(chan os.Signal, 1) \n    signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) \n    errChan <- fmt.Errorf(\"%s\", <-c) \n  }() \n\n```", "```go\n  hashEndpoint := vault.MakeHashEndpoint(srv) \n  validateEndpoint := vault.MakeValidateEndpoint(srv) \n  endpoints := vault.Endpoints{ \n    HashEndpoint:     hashEndpoint, \n    ValidateEndpoint: validateEndpoint, \n  } \n\n```", "```go\n  // HTTP transport \n  go func() { \n    log.Println(\"http:\", *httpAddr) \n    handler := vault.NewHTTPServer(ctx, endpoints) \n    errChan <- http.ListenAndServe(*httpAddr, handler) \n  }() \n\n```", "```go\n  go func() { \n    listener, err := net.Listen(\"tcp\", *gRPCAddr) \n    if err != nil { \n      errChan <- err \n      return \n    } \n    log.Println(\"grpc:\", *gRPCAddr) \n    handler := vault.NewGRPCServer(ctx, endpoints) \n    gRPCServer := grpc.NewServer() \n    pb.RegisterVaultServer(gRPCServer, handler) \n    errChan <- gRPCServer.Serve(listener) \n  }() \n\n```", "```go\n  log.Fatalln(<-errChan) \n} \n\n```", "```go\ngo run main.go\n\n```", "```go\nhttp: :8080\ngrpc: :8081\n\n```", "```go\ncurl -XPOST -d '{\"password\":\"hernandez\"}'\n    http://localhost:8080/hash\n\n```", "```go\n {\"hash\":\"$2a$10$IXYT10DuK3Hu.\n      NZQsyNafF1tyxe5QkYZKM5by/5Ren\"} \n\n```", "```go\ncurl -XPOST -d\n     '{\"password\":\"hernandez\",\n       \"hash\":\"PASTE_YOUR_HASH_HERE\"}'\n     http://localhost:8080/validate\n\n```", "```go\n{\"valid\":true}\n\n```", "```go\n{\"valid\":false}\n\n```", "```go\nfunc New(conn *grpc.ClientConn) vault.Service { \n  var hashEndpoint = grpctransport.NewClient( \n    conn, \"Vault\", \"Hash\", \n    vault.EncodeGRPCHashRequest, \n    vault.DecodeGRPCHashResponse, \n    pb.HashResponse{}, \n  ).Endpoint() \n  var validateEndpoint = grpctransport.NewClient( \n    conn, \"Vault\", \"Validate\", \n    vault.EncodeGRPCValidateRequest, \n    vault.DecodeGRPCValidateResponse, \n    pb.ValidateResponse{}, \n  ).Endpoint() \n  return vault.Endpoints{ \n    HashEndpoint:     hashEndpoint, \n    ValidateEndpoint: validateEndpoint, \n  } \n} \n\n```", "```go\nvaultcli hash MyPassword\n\n```", "```go\nvaultcli hash MyPassword HASH_GOES_HERE\n\n```", "```go\nfunc main() { \n  var ( \n    grpcAddr = flag.String(\"addr\", \":8081\",\n     \"gRPC address\") \n  ) \n  flag.Parse() \n  ctx := context.Background() \n  conn, err := grpc.Dial(*grpcAddr, grpc.WithInsecure(),  \n  grpc.WithTimeout(1*time.Second)) \n  if err != nil { \n    log.Fatalln(\"gRPC dial:\", err) \n  } \n  defer conn.Close() \n  vaultService := grpcclient.New(conn) \n  args := flag.Args() \n  var cmd string \n  cmd, args = pop(args) \n  switch cmd { \n  case \"hash\": \n    var password string \n    password, args = pop(args) \n    hash(ctx, vaultService, password) \n  case \"validate\": \n    var password, hash string \n    password, args = pop(args) \n    hash, args = pop(args) \n    validate(ctx, vaultService, password, hash) \n  default: \n    log.Fatalln(\"unknown command\", cmd) \n  } \n} \n\n```", "```go\ngo test\n\n```", "```go\nfunc TestPop(t *testing.T) { \n  args := []string{\"one\", \"two\", \"three\"} \n  var s string \n  s, args = pop(args) \n  if s != \"one\" { \n    t.Errorf(\"unexpected \"%s\"\", s) \n  } \n  s, args = pop(args) \n  if s != \"two\" { \n    t.Errorf(\"unexpected \"%s\"\", s) \n  } \n  s, args = pop(args) \n  if s != \"three\" { \n    t.Errorf(\"unexpected \"%s\"\", s) \n  } \n  s, args = pop(args) \n  if s != \"\" { \n    t.Errorf(\"unexpected \"%s\"\", s) \n  } \n} \n\n```", "```go\nfunc pop(s []string) (string, []string) { \n  if len(s) == 0 { \n    return \"\", s \n  } \n  return s[0], s[1:] \n} \n\n```", "```go\nfunc hash(ctx context.Context, service vault.Service, \n  password string) { \n  h, err := service.Hash(ctx, password) \n  if err != nil { \n    log.Fatalln(err.Error()) \n  } \n  fmt.Println(h) \n} \nfunc validate(ctx context.Context, service vault.Service,  \n  password, hash string) { \n  valid, err := service.Validate(ctx, password, hash) \n  if err != nil { \n    log.Fatalln(err.Error()) \n  } \n  if !valid { \n    fmt.Println(\"invalid\") \n    os.Exit(1) \n  } \n  fmt.Println(\"valid\") \n} \n\n```", "```go\ngo install\n\n```", "```go\ngo run main.go\n\n```", "```go\nvaultcli hash blanca\n\n```", "```go\nvaultcli validate blanca PASTE_HASH_HERE\n\n```", "```go\nrlbucket := ratelimit.NewBucket(1*time.Second, 5) \n\n```", "```go\nimport ratelimitkit \"github.com/go-kit/kit/ratelimit\"  \n\n```", "```go\ntype Middleware func(Endpoint) Endpoint \n\n```", "```go\ntype Endpoint func(ctx context.Context, request\n  interface{}) (response interface{}, err error) \n\n```", "```go\nfunc NewTokenBucketLimiter(tb *ratelimit.Bucket)\n  endpoint.Middleware { \n  return func(next endpoint.Endpoint) endpoint.Endpoint { \n    return func(ctx context.Context, request interface{})\n    (interface{}, error) { \n      if tb.TakeAvailable(1) == 0 { \n        return nil, ErrLimited \n      } \n      return next(ctx, request) \n    } \n  } \n} \n\n```", "```go\ne := getEndpoint(srv) \n{ \n  e = getSomeMiddleware()(e) \n  e = getLoggingMiddleware(logger)(e) \n  e = getAnotherMiddleware(something)(e) \n} \n\n```", "```go\n  hashEndpoint := vault.MakeHashEndpoint(srv) \n  { \n    hashEndpoint = ratelimitkit.NewTokenBucketLimiter\n     (rlbucket)(hashEndpoint) \n  } \n  validateEndpoint := vault.MakeValidateEndpoint(srv) \n  { \n    validateEndpoint = ratelimitkit.NewTokenBucketLimiter\n     (rlbucket)(validateEndpoint) \n  } \n  endpoints := vault.Endpoints{ \n    HashEndpoint:     hashEndpoint, \n    ValidateEndpoint: validateEndpoint, \n  } \n\n```", "```go\ngo run main.go\n\n```", "```go\nvaultcli hash bourgon\n\n```", "```go\n$ vaultcli hash bourgon\n$2a$10$q3NTkjG0YFZhTG6gBU2WpenFmNzdN74oX0MDSTryiAqRXJ7RVw9sy\n$ vaultcli hash bourgon\n$2a$10$CdEEtxSDUyJEIFaykbMMl.EikxvV5921gs/./7If6VOdh2x0Q1oLW\n$ vaultcli hash bourgon\n$2a$10$1DSqQJJGCmVOptwIx6rrSOZwLlOhjHNC83OPVE8SdQ9q73Li5x2le\n$ vaultcli hash bourgon\nInvoke: rpc error: code = 2 desc = rate limit exceeded\n$ vaultcli hash bourgon\nInvoke: rpc error: code = 2 desc = rate limit exceeded\n$ vaultcli hash bourgon\nInvoke: rpc error: code = 2 desc = rate limit exceeded\n$ vaultcli hash bourgon\n$2a$10$kriTDXdyT6J4IrqZLwgBde663nLhoG3innhCNuf8H2nHf7kxnmSza\n\n```", "```go\n  hashEndpoint := vault.MakeHashEndpoint(srv) \n  { \n    hashEndpoint = ratelimitkit.NewTokenBucketThrottler(rlbucket,\n     time.Sleep)(hashEndpoint) \n  } \n  validateEndpoint := vault.MakeValidateEndpoint(srv) \n  { \n    validateEndpoint = ratelimitkit.NewTokenBucketThrottler(rlbucket,\n      time.Sleep)(validateEndpoint) \n  } \n  endpoints := vault.Endpoints{ \n    HashEndpoint:     hashEndpoint, \n    ValidateEndpoint: validateEndpoint, \n  } \n\n```"]