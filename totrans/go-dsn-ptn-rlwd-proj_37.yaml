- en: Chapter 10.  Micro-services in Go with the Go kit Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Micro-services** are discrete components working together to provide functionality
    and business logic for a larger application, usually communicating over a network
    protocol (such as HTTP/2 or some other binary transport) and distributed across
    many physical machines. Each component is isolated from the others, and they take
    in well-defined inputs and yield well-defined outputs. Multiple instances of the
    same service can run across many servers and traffic can be load balanced between
    them. If designed correctly, it is possible for an individual instance to fail
    without bringing down the whole system and for new instances to be spun up during
    runtime to help handle load spikes.'
  prefs: []
  type: TYPE_NORMAL
- en: Go kit (refer to [https://gokit.io](https://gokit.io)) is a distributed programming
    toolkit for the building of applications with a micro-service architecture founded
    by Peter Bourgon (`@peterbourgon` on Twitter) and now maintained by a slice of
    Gophers in the open. It aims to solve many of the foundational (and sometimes
    boring) aspects of building such systems as well as encouraging good design patterns,
    allowing you to focus on the business logic that makes up your product or service.
  prefs: []
  type: TYPE_NORMAL
- en: Go kit doesn't try to solve every problem from scratch; rather, it integrates
    with many popular related services to solve **SOA** (**service-oriented architecture**)
    problems, such as service discovery, metrics, monitoring, logging, load balancing,
    circuit breaking, and many other important aspects of correctly running micro-services
    at scale. As we build our service by hand using Go kit, you will notice that we
    will write a lot of boilerplate or scaffold code in order to get things working.
  prefs: []
  type: TYPE_NORMAL
- en: For smaller products and services with a small team of developers, you may well
    decide it is easier to just expose a simple JSON endpoint, but Go kit really shines
    for larger teams, building substantial systems with many different services, each
    being run tens or hundreds of times within the architecture. Having consistent
    logging, instrumentation, distributed tracing, and each item being similar to
    the next means running and maintaining such a system becomes significantly easier.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Go kit is ultimately about encouraging good design practice within a service:
    SOLID design, or domain-driven-design, or the hexagonal architecture, etc. It''s
    not dogmatically any of those, but tries to make good design/software engineering
    tractable.” —Peter Bourgon*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to build some micro-services that address various
    security challenges (in a project called `vault`) –upon which we would be able
    to build further functionality. The business logic will be kept very simple, allowing
    us to focus on learning the principles around building micro-service systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some alternatives to Go kit as a technology choice; most of them have
    a similar approach but with different priorities, syntax, and patterns. Ensure
    that you look around at other options before embarking on a project, but the principles
    you learn in this chapter will apply across the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to hand code a micro-service using Go kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What gRPC is and how to use it to build servers and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Google's protocol buffers and associated tools to describe services
    and communicate in a highly efficient binary format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How endpoints in Go kit allow us to write a single service implementation and
    have it exposed via multiple transport protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Go kits-included subpackages help us solve lots of common problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Middleware lets us wrap endpoints to adapt their behavior without touching
    the implementation itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to describe method calls as requests and response messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to rate limit our services to protect from surges in traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few other idiomatic Go tips and tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some lines of code in this chapter stretch over many lines; they are written
    with the overflowing content right-aligned on the next line, as shown in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines in the preceding snippet should be written as one line.
    Don't worry; the Go compiler will be kind enough to point out if you get this
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many options when it comes to how our services will communicate with
    each other and how clients will communicate with the services, and Go kit doesn't
    care (rather, it doesn't mind–it cares enough to provide implementations of many
    popular mechanisms). In fact, we are able to add multiple options for our users
    and let them decide which one they want to use. We will add support the familiar
    JSON over HTTP, but we are also going to introduce a new technology choice for
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC, short for Google's **Remote Procedure Call**, is an open source mechanism
    used to call code that is running remotely over a network. It uses HTTP/2 for
    transport and protocol buffers to represent the data that makes up services and
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: An RPC service differs from RESTful web services because rather than making
    changes to data using well-defined HTTP standards, as you do with REST (`POST`
    to create something, `PUT` to update something, `DELETE` to delete something,
    and so on), you are triggering a remote function or method instead, passing in
    expected arguments and getting back one or more pieces of data in response.
  prefs: []
  type: TYPE_NORMAL
- en: 'To highlight the difference, imagine that we are creating a new user. In a
    RESTful world, we could make a request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And we might get a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: RESTful calls represent queries or changes to the state of resources. In an
    RPC world, we would use generated code instead in order to make binary serialized
    procedure calls that feel much more like normal methods or functions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: The only other key difference between a RESTful service and a gPRC service is
    that rather than JSON or XML, gPRC speaks a special format called **protocol buffers**.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protocol buffers (called `protobuf` in code) are a binary serialization format
    that is very small and extremely quick to encode and decode. You describe data
    structures in an abstract way using a declarative mini language, and generate
    source code (in a variety of languages) to make reading and writing the data easy
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of protocol buffers as a modern alternative to XML, except that
    the definition of the data structure is separated from the content, and the content
    is in a binary format rather than text.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s clear to see the benefits when you look at a real example. If we wanted
    to represent a person with a name in XML, we could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes up about 30 bytes (discounting whitespace). Let''s see how it would
    look in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we're down to 14 bytes, but the structure is still embedded in the content
    (the name field is spelled out along with the value).
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent content in protocol buffers would only take five bytes. The
    following table shows each byte, along with the first five bytes of the XML and
    JSON representations for comparison. The **Description** row explains the meaning
    of the bytes in the **Content** row, which shows the protocol buffer bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte** | **1** | **2** | **3** | **4** | **5** |'
  prefs: []
  type: TYPE_TB
- en: '| **Content** | 0a | 03 | 4d | 61 | 72 |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Type (string) | Length (3) | M | A | T |'
  prefs: []
  type: TYPE_TB
- en: '| **XML** | < | p | e | r | s |'
  prefs: []
  type: TYPE_TB
- en: '| **JSON** | { | " | n | a | m |'
  prefs: []
  type: TYPE_TB
- en: The structure definition lives in a special `.proto` file, separate from the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: There are still plenty of cases where XML or JSON would be a better choice than
    protocol buffers, and file size isn't the only measure when deciding a data format
    to use, but for fixed schema structures and remote procedure calls or for applications
    running at a truly massive scale, it's a popular choice for good reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Installing protocol buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some tools to compile and generate source code for protocol buffers,
    which you can grab from the GitHub home page of the project at [https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases).
    Once you''ve downloaded the file, unpack it and place the `protoc` file from the
    bin folder into an appropriate folder on your machine: one that is mentioned in
    your `$PATH` environment variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the protoc command is ready, we''ll need to add a plugin that will allow
    us to work with Go code. In a terminal, execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will install two packages that we'll make use of later.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To define our data structure, we are going to use the third version of the protocol
    buffers language, known as `proto3`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in your `$GOPATH` called `vault`, and a subfolder called
    `pb` inside that. The `pb` package is where our protocol buffer definition and
    the generated source code will live.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to define a service called `Vault`, which has two methods, `Hash`
    and `Validate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Hash` | Generate a secure hash for a given password. The hash can be stored
    instead of storing the password in plain text. |'
  prefs: []
  type: TYPE_TB
- en: '| `Validate` | Given a password and a previously generated hash, the Validate
    method will check to ensure that the password is correct. |'
  prefs: []
  type: TYPE_TB
- en: 'Each service call has a request and response pair, which we will define as
    well. Inside `pb`, insert the following code into a new file called `vault.proto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vertical whitespace has been removed to save paper, but you are free to add
    spaces between each block if you think it improves readability.
  prefs: []
  type: TYPE_NORMAL
- en: The first things we specify in our file are that we are using the `proto3` syntax
    and the name of the package for the generated source code is `pb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `service` block defines `Vault` and the two methods-with `HashRequest`,
    `HashResponse`, `ValidateRequest`, and `ValidateResponse` messages defined underneath.
    The lines beginning with `rpc` inside the service block indicate that our service
    consists of two remote procedure calls: `Hash` and `Validate`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fields inside a message take the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `type` is a string that describes the scalar value type, such as `string`,
    `bool`, `double`, `float`, `int32`, `int64`, and so on. The `name` is a human-readable
    string that describes the field, such as `hash` and `password`. The position is
    an integer that indicates where in the data stream that field appears. This is
    important because the content is a stream of bytes, and lining up the content
    to the definition is vital to being able to use the format. Additionally, if we
    were to add (or even rename) fields later (one of the key design features of protocol
    buffers), we could do so without breaking components that expect certain fields
    in a specific order; they would continue to work untouched, ignoring new data
    and just transparently passing it along.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of the supported types as well as a deep dive into the entire
    language, check out the documentation at [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3).
  prefs: []
  type: TYPE_NORMAL
- en: Note that each method call has an associated request and response pair. These
    are the messages that will be sent over the network when the remote method is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Hash method takes a single password string argument, the `HashRequest`
    object contains a single password string field. Like normal Go functions, the
    responses may contain an error, which is why both `HashResponse` and `ValidateResponse`
    have two fields. There is no dedicated `error` interface in proto3 like there
    is in Go, so we are going to turn the error into a string instead.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Go code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go doesn''t understand proto3 code, but luckily the protocol buffer compiler
    and Go plugin we installed earlier can translate it into something Go does understand:
    Go code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, navigate to the `pb` folder and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a new file called `vault.pb.go`. Open the file and inspect
    its contents. It has done a lot of work for us, including defining the messages
    and even creating `VaultClient` and `VaultServer` types for us to use, which will
    allow us to consume and expose the service, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are free to decode the rest of the generated code (the file descriptor looks
    especially interesting) if you are interested in the details. For now, we're going
    to trust that it works and use the `pb` package to build our service implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Building the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the day, whatever other dark magic is going on in our architecture,
    it will come down to some Go method being called, doing some work, and returning
    a result. So the next thing we are going to do is define and implement the Vault
    service itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `vault` folder, add the following code to a new `service.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This interface defines the service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might think that `VaultService` would be a better name than just `Service`,
    but remember that since this is a Go package, it will been seen externally as
    `vault.Service`, which reads nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define our two methods: `Hash` and `Validate`. Each takes `context.Context`
    as the first argument, followed by normal `string` arguments. The responses are
    normal Go types as well: `string`, `bool`, and `error`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some libraries may still require the old context dependency, `golang.org/x/net/context`,
    rather than the `context` package that was made available first in Go 1.7\. Watch
    out for errors complaining about mixed use and make sure you're importing the
    right one.
  prefs: []
  type: TYPE_NORMAL
- en: Part of designing micro-services is being careful about where state is stored.
    Even though you will implement the methods of a service in a single file, with
    access to global variables, you should never use them to store the per-request
    or even per-service state. It's important to remember that each service is likely
    to be running on many physical machines multiple times, each with no access to
    the others' global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this spirit, we are going to implement our service using an empty `struct`,
    essentially a neat idiomatic Go trick to group methods together in order to implement
    an interface without storing any state in the object itself. To `service.go`,
    add the following `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the implementation did require any dependencies (such as a database connection
    or a configuration object), you could store them inside the struct and use the
    method receivers in your function bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where possible, starting by writing test code has many advantages that usually
    end up increasing the quality and maintainability of your code. We are going to
    write a unit test that will use our new service to hash and then validate a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `service_test.go` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will create a new service via the `NewService` method and then use it to
    call the `Hash` and `Validate` methods. We even test an unhappy case, where we
    get the password wrong and ensure that `Validate` returns `false`–otherwise, it
    wouldn't be very secure at all.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **constructor** in other object-oriented languages is a special kind of function
    that creates instances of classes. It performs any initialization and takes in
    required arguments such as dependencies, among others. It is usually the only
    way to create an object in these languages, but it often has weird syntax or relies
    on naming conventions (such as the function name being the same as the class,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: Go doesn't have constructors; it's much simpler and just has functions, and
    since functions can return arguments, a constructor would just be a global function
    that returns a usable instance of a struct. The Go philosophy of simplicity drives
    these kinds of decisions for the language designers; rather than forcing people
    to have to learn about a new concept of constructing objects, developers only
    have to learn how functions work and they can build constructors with them.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we aren't doing any special work in the construction of an object (such
    as initializing fields, validating dependencies, and so on), it is sometimes worth
    adding a construction function anyway. In our case, we do not want to bloat the
    API by exposing the `vaultService` type since we already have our `Service` interface
    type exposed and are hiding it inside a constructor is a nice way to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `vaultService` struct definition, add the `NewService` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Not only does this prevent us from needing to expose our internals, but if in
    the future we do need to do more work to prepare the `vaultService` for use, we
    can also do it without changing the API and, therefore, without requiring the
    users of our package to change anything on their end, which is a big win for API
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing and validating passwords with bcrypt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first method we will implement in our service is `Hash`. It will take a
    password and generate a hash. The resulting hash can then be passed (along with
    a password) to the `Validate` method later, which will either confirm or deny
    that the password is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the correct way to store passwords in applications, check
    out the Coda Hale blog post on the subject at [https://codahale.com/how-to-safely-store-a-password/](https://codahale.com/how-to-safely-store-a-password/).
  prefs: []
  type: TYPE_NORMAL
- en: The point of our service is to ensure that passwords never need to be stored
    in a database, since that's a security risk if anyone is ever able to get unauthorized
    access to the database. Instead, you can generate a one-way hash (it cannot be
    decoded) that can safely be stored, and when users attempt to authenticate, you
    can perform a check to see whether the password generates the same hash or not.
    If the hashes match, the passwords are the same; otherwise, they are not.
  prefs: []
  type: TYPE_NORMAL
- en: The `bcrypt` package provides methods that do this work for us in a secure and
    trustworthy way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `service.go`, add the `Hash` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you import the appropriate `bcrypt` package (try `golang.org/x/crypto/bcrypt`).
    We are essentially wrapping the `GenerateFromPassword` function to generate the
    hash, which we then return provided no errors occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the receiver in the `Hash` method is just `(vaultService)`; we don't
    capture the variable because there is no way we can store state on an empty `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let''s add the `Validate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `Hash`, we are calling `bcrypt.CompareHashAndPassword` to determine
    (in a secure way) whether the password is correct or not. If an error is returned,
    it means that something is amiss and we return `false` indicating that. Otherwise,
    we return `true` when the password is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling method calls with requests and responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our service will be exposed through various transport protocols, we will
    need a way to model the requests and responses in and out of our service. We will
    do this by adding a `struct` for each type of message our service will accept
    or return.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for somebody to call the `Hash` method and then receive the hashed
    password as a response, we''ll need to add the following two structures to `service.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `hashRequest` type contains a single field, the password, and the `hashResponse`
    has the resulting hash and an `Err` string field in case something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To model remote method calls, you essentially create a `struct` for the incoming
    arguments and a `struct` for the return arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, see whether you can model the same request/response pair
    for the `Validate` method. Look at the signature in the `Service` interface, examine
    the arguments it accepts, and think about what kind of responses it will need
    to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a helper method (of type `http.DecodeRequestFunc` from
    Go kit) that will be able to decode the JSON body of `http.Request` to `service.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The signature for `decodeHashRequest` is dictated by Go kit because it will
    later use it to decode HTTP requests on our behalf. In this function, we just
    use `json.Decoder` to unmarshal the JSON into our `hashRequest` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the request and response structures as well as a decode helper
    function for the `Validate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `validateRequest` struct takes both `Password` and `Hash` strings,
    since the signature has two input arguments and returns a response containing
    a `bool` datatype called `Valid` or `Err`.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing we need to do is encode the response. In this case, we can write
    a single method to encode both the `hashResponse` and `validateResponse` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `service.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our `encodeResponse` method just asks `json.Encoder` to do the work for us.
    Note again that the signature is general since the `response` type is `interface{}`;
    this is because it's a Go kit mechanism for decoding to `http.ResponseWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints in Go kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Endpoints are a special function type in Go kit that represent a single RPC
    method. The definition is inside the `endpoint` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: An endpoint function takes `context.Context` and `request`, and it returns `response`
    or `error`. The `request` and `response` types are `interface{}`, which tells
    us that it is up to the implementation code to deal with the actual types when
    building endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Endpoints are powerful because, like `http.Handler` (and `http.HandlerFunc`),
    you can wrap them with generalized middleware to solve a myriad of common issues
    that arise when building micro-services: logging, tracing, rate limiting, error
    handling, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Go kit solves transporting over various protocols and uses endpoints as a general
    way to jump from their code to ours. For example, the gRPC server will listen
    on a port, and when it receives the appropriate message, it will call the corresponding
    `Endpoint` function. Thanks to Go kit, this will all be transparent to us, as
    we only need to deal in Go code with our `Service` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Making endpoints for service methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to turn our service methods into `endpoint.Endpoint` functions, we're
    going to write a function that handles the incoming `hashRequest`, calls the `Hash`
    service method, and depending on the response, builds and returns an appropriate
    `hashResponse` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `service.go`, add the `MakeHashEndpoint` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This function takes `Service` as an argument, which means that we can generate
    an endpoint from any implementation of our `Service` interface. We then use a
    type assertion to specify that the request argument should, in fact, be of type
    `hashRequest`. We call the `Hash` method, passing in the context and `Password`,
    which we get from `hashRequest`. If all is well, we build `hashResponse` with
    the value we got back from the `Hash` method and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the same for the `Validate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are doing the same: taking the request and using it to call the method
    before building a response. Note that we never return an error from the `Endpoint`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Different levels of error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main types of errors in Go kit: transport errors (network failure,
    timeouts, dropped connection, and so on) and business logic errors (where the
    infrastructure of making the request and responding was successful, but something
    in the logic or data wasn''t correct).'
  prefs: []
  type: TYPE_NORMAL
- en: If the `Hash` method returns an error, we are not going to return it as the
    second argument; instead, we are going to build `hashResponse`, which contains
    the error string (accessible via the `Error` method). This is because the error
    returned from an endpoint is intended to indicate a transport error, and perhaps
    Go kit will be configured to retry the call a few times by some middleware. If
    our service methods return an error, it is considered a business logic error and
    will probably always return the same error for the same input, so it's not worth
    retrying. This is why we wrap the error into the response and return it to the
    client so that they can deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping endpoints into a Service implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another very useful trick when dealing with endpoints in Go kit is to write
    an implementation of our `vault.Service` interface, which just makes the necessary
    calls to the underlying endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `service.go`, add the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In order to implement the `vault.Service` interface, we are going to add the
    two methods to our `Endpoints` structure, which will build a request object, make
    the request, and parse the resulting response object into the normal arguments
    to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `Hash` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are calling `HashEndpoint` with `hashRequest`, which we create using the
    password argument before caching the general response to `hashResponse` and returning
    the Hash value from it or an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do this for the Validate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These two methods will allow us to treat the endpoints we have created as though
    they are normal Go methods; very useful for when we actually consume our service
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP server in Go kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The true value of Go kit becomes apparent when we create an HTTP server for
    our endpoints to hash and validate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `server_http.go` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are importing the `github.com/go-kit/kit/transport/http` package and (since
    we're also importing the `net/http` package) telling Go that we're going to explicitly
    refer to this package as `httptransport`.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `NewServeMux` function from the standard library to build `http.Handler` 
    interface with simple routing and mapping the `/hash` and `/validate` paths. We
    take the `Endpoints` object since we want our HTTP server to serve these endpoints,
    including any middleware that we will add later. Calling `httptransport.NewServer`
    is how we get Go kit to give us an HTTP handler for each endpoint. Like most functions,
    we pass in `context.Context` as the first argument, which will form the base context
    for each request. We also pass in the endpoint as well as the decoding and encoding
    functions that we wrote earlier so that the server knows how to unmarshal and
    marshal the JSON messages.
  prefs: []
  type: TYPE_NORMAL
- en: A gRPC server in Go kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a gPRC server using Go kit is almost as easy as adding a JSON/HTTP server,
    like we did in the last section. In our generated code (in the `pb` folder), we
    were given the following `pb.VaultServer` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This type is very similar to our own `Service` interface, except that it takes
    in generated request and response classes rather than raw arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining a type that will implement the preceding interface.
    Add the following code to a new file called `server_grpc.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that you'll need to import `github.com/go-kit/kit/transport/grpc` as `grpctransport`,
    along with the generated `pb` package.
  prefs: []
  type: TYPE_NORMAL
- en: The `grpcServer` struct contains a field for each of the service endpoints,
    this time of type `grpctransport.Handler`. Then, we implement the methods of the
    interface, calling the `ServeGRPC` method on the appropriate handler. This method
    will actually serve requests by first decoding them, calling the appropriate endpoint
    function, getting the response, and encoding it and sending it back to the client
    who made the request.
  prefs: []
  type: TYPE_NORMAL
- en: Translating from protocol buffer types to our types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll notice that we're using the request and response objects from the `pb`
    package, but remember that our own endpoints use the structures we added to `service.go`
    earlier. We are going to need a method for each type in order to translate to
    and from our own types.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's a lot of repetitive typing coming up; feel free to copy and paste this
    from the GitHub repository at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    to save your fingers. We're hand coding this manually because it's important to
    understand all the pieces that make up the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `server_grpc.go`, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function is an `EncodeRequestFunc` function defined by Go kit, and it is
    used to translate our own `hashRequest` type into a protocol buffer type that
    can be used to communicate with the client. It uses `interface{}` types because
    it's general, but in our case, we can be sure about the types so we cast the incoming
    request to `hashRequest` (our own type) and then build a new `pb.HashRequest`
    object using the appropriate fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to do this for both encoding and decoding requests and responses
    for both hash and validate endpoints. Add the following code to `server_grpc.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is a lot of boilerplate coding to do in order to get things
    working.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code generation (not covered here) would have great application here, since
    the code is very predictable and self-similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing to do in order to get our gRPC server working is to provide
    a helper function to create an instance of our `grpcServer` structure. Underneath
    the `grpcServer` struct, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Like our HTTP server, we take in a base context and the actual `Endpoints` implementation
    that we are exposing via the gRPC server. We create and return a new instance
    of our `grpcServer` type, setting the handlers for both `hash` and `validate`
    by calling `grpctransport.NewServer`. We use our `endpoint.Endpoint` functions
    for our service and tell the service which of our encoding/decoding functions
    to use for each case.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all of our service code lives inside the `vault` package. We are now
    going to use this package to create a new tool to expose the server functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in `vault` called `cmd`, and inside it create another called
    `vaultd`. We are going to put our command code inside the `vaultd` folder because
    even though the code will be in the `main` package, the name of the tool will
    be `vaultd` by default. If we just put the command in the `cmd` folder, the tool
    would be built into a binary called `cmd`-which is pretty confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go projects, if the primary use of the package is to be imported into other
    programs (such as Go kit), then the root level files should make up the package
    and will have an appropriate package name (not `main`). If the primary purpose
    is a command-line tool, such as the Drop command ([https://github.com/matryer/drop](https://github.com/matryer/drop)),
    then the root files will be in the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale for this comes down to usability; when importing a package, you
    want the string the user has to type to be the shortest it can be. Similarly,
    when using `go install`, you want the path to be short and sweet.
  prefs: []
  type: TYPE_NORMAL
- en: The tool we are going to build (suffixed with `d`, indicating that it is a daemon
    or a background task) will spin up both our gRPC and JSON/HTTP servers. Each will
    run in their own goroutine, and we will trap any termination signals or errors
    from the servers, which will cause the termination of our program.
  prefs: []
  type: TYPE_NORMAL
- en: In Go kit, main functions end up being quite large, which is by design; there
    is a single function that contains the entirety of your micro-service; from there,
    you can dig down into the details, but it provides an at-a-glance view of each
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build up the `main` function piece by piece inside a new `main.go`
    file in the `vaultd` folder, starting with the fairly big list of imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `your/path/to` prefixes should be replaced with the actual route from `$GOPATH`
    to where your project is. Pay attention to the context import too; it's quite
    possible that you just need to type context rather than the import listed here
    depending on when Go kit transitions to Go 1.7\. Finally, the `grpc` package from
    Google provides everything we need in order to expose gRPC capabilities over the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will put together our `main` function; remember that all the sections
    following this one go inside the body of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use flags to allow the ops team to decide which endpoints we will listen
    on when exposing the service on the network, but provide sensible defaults of
    `:8080` for the JSON/HTTP server and :`8081` for the gRPC server.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new context using the `context.Background()` function, which
    returns a non-nil, empty context that has no cancelation or deadline specified
    and contains no values, perfect for the base context of all of our services. Requests
    and middleware are free to create new context objects from this one in order to
    add request-scoped data or deadlines.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use our `NewService` constructor to make a new `Service` type for us
    and make a zero-buffer channel, which can take an error should one occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add the code that traps termination signals (such as *Ctrl + C*)
    and sends an error down `errChan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, in a new goroutine, we ask `signal.Notify` to tell us when we receive
    the `SIGINT` or `SIGTERM` signals. When that happens, the signal will be sent
    down the `c` channel, at which point we'll format it as a string (its `String()`
    method will be called), and we turn that into an error, which we'll send down
    `errChan`, resulting in the termination of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go kit endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to create one of our endpoints instances that we can pass to our
    servers. Add the following code to the main function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are assigning the fields to the output of our endpoint helper functions for
    both the hash and validate methods. We are passing in the same service for both,
    so the `endpoints` variable essentially ends up being a wrapper around our `srv`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be tempted to neaten up this code by removing the assignment to the
    variables altogether and just set the return of the helper functions to the fields
    in the struct initialization, but when we come to add middleware later, you'll
    be thankful for this approach.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to start up our JSON/HTTP and gRPC servers using these endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Running the HTTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will add the goroutine to make and run the JSON/HTTP server to the main
    function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All the heavy lifting has already been done for us in our package code by Go
    kit, so we are left with simply calling the `NewHTTPServer` function, passing
    in the background context and the service endpoints we wish for it to expose,
    before calling the standard library's `http.ListenAndServe`, which exposes the
    handler functionality in the specified `httpAddr`. If an error occurs, we send
    it down the error channel.
  prefs: []
  type: TYPE_NORMAL
- en: Running the gRPC server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a little more work to do in order to run the gRPC server, but it is
    still pretty simple. We must create a low-level TCP network listener and serve
    the gRPC server over that. Add the following code to the main function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We make the TCP listener on the `gRPCAddr` endpoint specified, sending any errors
    down the `errChan` error channel. We use `vault.NewGRPCServer` to create the handler,
    again passing in the background context and the instance of `Endpoints` we are
    exposing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how both the JSON/HTTP server and the gRPC server are actually exposing
    the same service–literally the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new gRPC server from Google's `grpc` package and register it
    using our own generated `pb` package via the `RegisterVaultServer` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `RegisterVaultService` function just calls `RegisterService` on our `grpcServer`
    but hides the internals of the service description that was automatically generated.
    If you look in `vault.pb.go` and search for the `RegisterVaultServer` function,
    you will see that it makes a reference to something like `&_Vault_serviceDesc`,
    which is the description of the service. Feel free to dig around the generated
    code; the metadata is especially interesting, but out of scope for this book.
  prefs: []
  type: TYPE_NORMAL
- en: We then ask the server to `Serve` itself, throwing any errors down the same
    error channel if they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's out of scope for this chapter, but it is recommended that every service
    be delivered with **Transport Layer Security** (**TLS**), especially the ones
    dealing with passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing a main function from terminating immediately
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we closed our main function here, it would immediately exit and terminate
    all of our servers. This is because everything we're doing that would prevent
    this is inside its own goroutine. To prevent this, we need a way to block the
    function at the end to wait until something tells the program to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using the `errChan` error channel for errors, this is a perfect
    candidate. We can just listen on this channel, which (while nothing has been sent
    down it) will block and allow the other goroutines to do their work. If something
    goes wrong (or if a termination signal is received), the `<-errChan` call will
    unblock and exit and all goroutines will be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the main function, add the final statement and closing block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When an error occurs, we'll just log it and exit with a nonzero code.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the service over HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have wired everything up, we can test the HTTP server using the
    `curl` command–or any tool that lets us make JSON/HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, let''s start by running our servers. Head over to the `vault/cmd/vaultd`
    folder and start the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is running, you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open another terminal and issue the following HTTP request using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We are making a POST request to the hash endpoint with a JSON body that contains
    the password we want for hashing. Then, we get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hash in this example won't match yours–there are many acceptable hashes
    and there's no way to know which one you'll get. Ensure that you copy and paste
    your actual hash (everything inside the double quotes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting hash is what we would store in our data store given the specified
    password. Then, when the user tries to log in again, we will make a request with
    the password they entered, along with this hash, to the validate endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Make this request by copying and pasting the correct hash and entering the
    same `hernandez` password, and you will see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the password (this is equivalent to the user getting it wrong)
    and you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the JSON/HTTP micro-service exposure for our vault service
    is complete and working.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how we can consume the gRPC version.
  prefs: []
  type: TYPE_NORMAL
- en: Building a gRPC client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike JSON/HTTP services, gRPC services aren't easy for humans to interact
    with. They're really intended as machine-to-machine protocols, and so we must
    write a program if we wish to use them.
  prefs: []
  type: TYPE_NORMAL
- en: To help us do this, we are first going to add a new package inside our vault
    service called `vault/client/grpc`. It will, given a gRPC client connection object
    that we get from Google's `grpc` package, provide an object that performs the
    appropriate calls, encoding and decoding, for us, all hidden behind our own `vault.Service`
    interface. So, we will be able to use the object as though it is just another
    implementation of our interface.
  prefs: []
  type: TYPE_NORMAL
- en: Create new folders inside vault so that you have the path of `vault/client/grpc`.
    You can imagine adding other clients if you so wish, so this seems a good pattern
    to establish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to a new `client.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `grpctransport` package is referring to `github.com/go-kit/kit/transport/grpc`.
    This might feel familiar by now; we are making two new endpoints based on the
    specified connection, this time being explicit about the `Vault` service name
    and the endpoint names `Hash` and `Validate`. We pass in appropriate encoders
    and decoders from our vault package and empty response objects before wrapping
    them both in our `vault.Endpoints` structure that we added-the one that implements
    the `vault.Service` interface that just triggers the specified endpoints for us.
  prefs: []
  type: TYPE_NORMAL
- en: A command-line tool to consume the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to write a command-line tool (or CLI-command-line
    interface), which will allow us to communicate with our service through the gRPC
    protocol. If we were writing another service in Go, we would use the vault client
    package in the same way as we will when we write our CLI tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tool will let you access the services in a fluent way on the command line
    by separating commands and arguments with spaces such that we can hash a password
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to validate a password with a hash like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `cmd` folder, create a new folder called `vaultcli`. Add a main.go file
    and insert the following main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you import the `vault/client/grpc` package as `grpcclient` and `google.golang.org/grpc`
    as `grpc`. You'll also need to import the `vault` package.
  prefs: []
  type: TYPE_NORMAL
- en: We parse the flags and get a background context as usual before dialing the
    gRPC endpoint to establish a connection. If all is well, we defer the closing
    of the connection and create our vault service client using that connection. Remember
    that this object implements our `vault.Service` interface, so we can just call
    the methods as though they were normal Go methods, without worrying about the
    fact that communication is taking place over a network protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we start parsing the command-line arguments in order to decide which execution
    flow to take.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments in CLIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parsing arguments in command-line tools is very common, and there is a neat
    idiomatic way to do it in Go. The arguments are all available via the `os.Args`
    slice, or if you're using flags, the `flags.Args()` method (which gets arguments
    with flags stripped). We want to take each argument off the slice (from the beginning)
    and consume them in an order, which will help us decide which execution flow to
    take through the program. We're going to add a helper function called `pop`, which
    will return the first item, and the slice with the first item trimmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll write a quick unit test to ensure that our `pop` function is working
    as expected. If you would like to try and write the pop function yourself, then
    you should do that once the test is in place. Remember that you can run tests
    by navigating to the appropriate folder in a terminal and executing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file inside `vaultcli` called `main_test.go` and add the following
    test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We expect each call to pop to yield the next item in the slice and empty arguments
    once the slice is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `main.go`, add the `pop` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Maintaining good line of sight by extracting case bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only thing that remains for us to do is implement the hash and validate
    methods referred to in the switch statement shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We could have embedded this code inside the switch statement itself, but that
    would make the main function very difficult to read and also hide happy path execution
    at different indentation levels, something we should try to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it is a good practice to have the cases inside the switch statement
    jump out to a dedicated function, taking in any arguments it needs. Underneath
    the main function, add the following hash and validate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: These functions simply call the appropriate method on the service, and depending
    on the result, log or print the results to the console. If the validate method
    returns false, the program will exit with an exit code of 1, since nonzero means
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Installing tools from the Go source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the tool, we just have to navigate to the `vaultcli` folder in a
    terminal and type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Provided there are no errors, the package will be built and deployed to the
    `$GOPATH/bin` folder, which should already be listed in your `$PATH` environment
    variable. This means that the tool is ready for use just like a normal command
    in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the binary that is deployed will match the folder name, and this
    is why we have an additional folder inside the `cmd` folder even if we are only
    building a single command.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have installed the command, we can use it to test the gRPC server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to `cmd/vaultd` and start the server (if it isn''t already running)
    by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal, let''s hash a password by typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the hash is returned. Now let''s validate this hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hash may contain special characters that interfere with your terminal, so
    you should escape the string with quotes if required.
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac, format the argument with `$'PASTE_HASH_HERE'` to properly escape it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, try surrounding the argument with exclamation points: `!PASTE_HASH_HERE!`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you get the password right, you'll notice that you see the word `valid`;
    otherwise, you'll see `invalid`.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting with service middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built a complete service, we are going to see how easy it is
    to add middleware to our endpoints in order to extend the service without touching
    the actual implementations themselves.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world services, it is sensible to limit the number of requests it will
    attempt to handle so that the service doesn't get overwhelmed. This can happen
    if the process needs more memory than is available, or we might notice performance
    degradation if it eats up too much of the CPU. In a micro-service architecture,
    the strategy to solving these problems is to add another node and spread the load,
    which means that we want each individual instance to be rate limited.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are providing the client, we should add rate limiting there, which
    would prevent too many requests from getting on the network. But it is also sensible
    to add rate limiting to the server in case many clients are trying to access the
    same services at the same time. Luckily, endpoints in Go kit are used for both
    the client and server, so we can use the same code to add middleware in both places.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add a **Token Bucket**-based rate limiter, which you can read
    more about at [https://en.wikipedia.org/wiki/Token_bucket](https://en.wikipedia.org/wiki/Token_bucket).
    The guys at Juju have written a Go implementation that we can use by importing
    `github.com/juju/ratelimit`, and Go kit has middleware built for this very implementation,
    which will save us a lot of time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: The general idea is that we have a bucket of tokens, and each request will need
    a token in order to do its work. If there are no tokens in the bucket, we have
    reached our limit and the request cannot be completed. Buckets refill over time
    at a specific interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `github.com/juju/ratelimit` and before we create our `hashEndpoint`,
    insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `NewBucket` function creates a new rate limiting bucket that will refill
    at a rate of one token per second, up to a maximum of five tokens. These numbers
    are pretty silly for our case, but we want to be able to reach our limits manually
    during the development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the Go kit `ratelimit` package has the same name as the Juju one, we
    are going to need to import it with a different name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Middleware in Go kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Endpoint middleware in Go kit is specified by the `endpoint.Middleware` function
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A piece of middleware is simply a function that takes `Endpoint` and returns
    `Endpoint`. Remember that `Endpoint` is also a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This gets a little confusing, but they are the same as the wrappers we built
    for `http.HandlerFunc`. A middleware function returns an `Endpoint` function that
    does something before and/or after calling the `Endpoint` being wrapped. The arguments
    passed into the function that returns the `Middleware` are closured in, which
    means that they are available to the inner code (via closures) without the state
    having to be stored anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `NewTokenBucketLimiter` middleware from Go kit''s `ratelimit`
    package, and if we take a look at the code, we''ll see how it uses closures and
    returns functions to inject a call to the token bucket''s `TakeAvailable` method
    before passing execution to the `next` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: A pattern has emerged within Go kit where you obtain the endpoint and then put
    all middleware adaptations inside their own block immediately afterwards. The
    returned function is given the endpoint when it is called, and the same variable
    is overwritten with the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now do this for our endpoints; update the code inside the main function
    to add the rate limiting middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing much to change here; we're just updating the `hashEndpoint`
    and `validateEndpoint` variables before assigning them to the `vault.Endpoints`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: Manually testing the rate limiter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see whether our rate limiter is working, and since we set such low thresholds,
    we can test it just using our command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, restart the server (so the new code runs) by hitting *Ctrl + C* in the
    terminal window running the server. This signal will be trapped by our code, and
    an error will be sent down `errChan`, causing the program to quit. Once it has
    terminated, restart it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in another window, let''s hash some passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat this command a few times–in most terminals, you can press the up arrow
    key and return. You''ll notice that the first few requests succeed because it''s
    within the limits, but if you get a little more aggressive and issue more than
    five requests in a second, you''ll notice that we get errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This shows that our rate limiter is working. We see errors until the token bucket
    fills back up, where our requests are fulfilled again.
  prefs: []
  type: TYPE_NORMAL
- en: Graceful rate limiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than returning an error (which is a pretty harsh response), perhaps we
    would prefer the server to just hold onto our request and fulfill it when it can-called
    throttling. For this case, Go kit provides the `NewTokenBucketThrottler` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the middleware code to use this middleware function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `NewTokenBucketThrottler` is the same endpoint as earlier,
    but now we have added a second argument of `time.Sleep`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go kit allows us to customize the behavior by specifying what should happen
    when the delay needs to take place. In our case, we're passing `time.Sleep`, which
    is a function that will ask execution to pause for the specified amount of time.
    You could write your own function here if you wanted to do something different,
    but this works for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now repeat the test from earlier, but this time, note that we never get an error-instead,
    the terminal will hang for a second until the request can be fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot through this chapter as we put together a real example of a
    micro-service. There is a lot of work involved without code generation, but the
    benefits for large teams and big micro-service architectures pay for the investment
    as you build self-similar, discrete components that make up the system.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how gRPC and protocol buffers give us highly efficient transport
    communications between clients and servers. Using the `proto3` language, we defined
    our service, including messages, and used the tools to generate a Go package that
    provided the client and server code for us.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the fundamentals of Go kit and how we can use endpoints to describe
    the methods of our services. We let Go kit do the heavy lifting for us when it
    came to building HTTP and gRPC servers by making use of the packages included
    in the project. We saw how middleware functions let us easily adapt our endpoints
    to, among other things, rate limit the amount of traffic the server will have
    to handle.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about constructors in Go, a neat trick to parse incoming command-line
    arguments, and how to hash and validate passwords using the `bcrypt` package,
    which is a sensible approach that helps us avoid storing passwords at all.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to building micro-services, and it is recommended that you
    head over to the Go kit website at [https://gokit.io](https://gokit.io) or join
    the conversation on the `#go-kit` slack channel at gophers.slack.com to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built our Vault service, we need to think about our options
    in order to deploy it into the wild. In the next chapter, we'll package our micro-service
    into a Docker container and deploy it to Digital Ocean's cloud.
  prefs: []
  type: TYPE_NORMAL
