- en: Chapter 10.  Micro-services in Go with the Go kit Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用Go kit框架的Go微服务
- en: '**Micro-services** are discrete components working together to provide functionality
    and business logic for a larger application, usually communicating over a network
    protocol (such as HTTP/2 or some other binary transport) and distributed across
    many physical machines. Each component is isolated from the others, and they take
    in well-defined inputs and yield well-defined outputs. Multiple instances of the
    same service can run across many servers and traffic can be load balanced between
    them. If designed correctly, it is possible for an individual instance to fail
    without bringing down the whole system and for new instances to be spun up during
    runtime to help handle load spikes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**是离散的组件，它们协同工作，为更大的应用程序提供功能性和业务逻辑，通常通过网络协议（如HTTP/2或某些其他二进制传输）进行通信，并分布到许多物理机器上。每个组件与其他组件隔离，它们接受定义良好的输入并产生定义良好的输出。同一服务的多个实例可以在多个服务器上运行，并且可以在它们之间进行负载均衡。如果设计得当，单个实例的失败不会导致整个系统崩溃，并且在运行时可以启动新的实例以帮助处理负载峰值。'
- en: Go kit (refer to [https://gokit.io](https://gokit.io)) is a distributed programming
    toolkit for the building of applications with a micro-service architecture founded
    by Peter Bourgon (`@peterbourgon` on Twitter) and now maintained by a slice of
    Gophers in the open. It aims to solve many of the foundational (and sometimes
    boring) aspects of building such systems as well as encouraging good design patterns,
    allowing you to focus on the business logic that makes up your product or service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit（参考[https://gokit.io](https://gokit.io)）是由Peter Bourgon（Twitter上的`@peterbourgon`）创立的，用于构建具有微服务架构的应用程序的分布式编程工具包，目前由一群Gophers在开源社区中维护。它旨在解决构建此类系统时许多基础（有时可能有些枯燥）方面的问题，同时鼓励良好的设计模式，让您能够专注于构成您产品或服务的业务逻辑。
- en: Go kit doesn't try to solve every problem from scratch; rather, it integrates
    with many popular related services to solve **SOA** (**service-oriented architecture**)
    problems, such as service discovery, metrics, monitoring, logging, load balancing,
    circuit breaking, and many other important aspects of correctly running micro-services
    at scale. As we build our service by hand using Go kit, you will notice that we
    will write a lot of boilerplate or scaffold code in order to get things working.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit并不试图从头解决每个问题；相反，它集成了许多流行的相关服务来解决**SOA**（**面向服务的架构**）问题，例如服务发现、度量、监控、日志记录、负载均衡、断路器以及许多其他正确运行大规模微服务的重要方面。当我们使用Go
    kit手动构建服务时，您会注意到我们将编写大量的模板或框架代码，以便使一切正常工作。
- en: For smaller products and services with a small team of developers, you may well
    decide it is easier to just expose a simple JSON endpoint, but Go kit really shines
    for larger teams, building substantial systems with many different services, each
    being run tens or hundreds of times within the architecture. Having consistent
    logging, instrumentation, distributed tracing, and each item being similar to
    the next means running and maintaining such a system becomes significantly easier.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型产品和服务，以及小型开发团队，您可能会决定直接暴露一个简单的JSON端点更容易，但Go kit在大型团队中表现尤为出色，用于构建具有许多不同服务的大量系统，每个服务在架构中运行数十或数百次。具有一致的日志记录、仪表化、分布式跟踪，并且每个组件都与下一个相似，这意味着运行和维护此类系统变得显著更容易。
- en: '*"Go kit is ultimately about encouraging good design practice within a service:
    SOLID design, or domain-driven-design, or the hexagonal architecture, etc. It''s
    not dogmatically any of those, but tries to make good design/software engineering
    tractable.” —Peter Bourgon*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Go kit的最终目的是在服务内部鼓励良好的设计实践：SOLID设计、领域驱动设计或六边形架构等。它并不是教条地遵循任何一种，而是试图使良好的设计/软件工程变得可行。”
    ——Peter Bourgon
- en: In this chapter, we are going to build some micro-services that address various
    security challenges (in a project called `vault`) –upon which we would be able
    to build further functionality. The business logic will be kept very simple, allowing
    us to focus on learning the principles around building micro-service systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一些解决各种安全挑战的微服务（在一个名为`vault`的项目中）——在此基础上，我们可以构建更多的功能。业务逻辑将保持非常简单，这样我们就可以专注于学习构建微服务系统的原则。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are some alternatives to Go kit as a technology choice; most of them have
    a similar approach but with different priorities, syntax, and patterns. Ensure
    that you look around at other options before embarking on a project, but the principles
    you learn in this chapter will apply across the board.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为技术选择，有一些Go kit的替代方案；它们大多数有类似的方法，但优先级、语法和模式不同。在开始项目之前，请确保您已经考虑了其他选项，但本章中学到的原则将适用于所有情况。
- en: 'Specifically, in this chapter, you will learn:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，您将学习：
- en: How to hand code a micro-service using Go kit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Go kit手动编码一个微服务
- en: What gRPC is and how to use it to build servers and clients
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC是什么以及如何使用它来构建服务器和客户端
- en: How to use Google's protocol buffers and associated tools to describe services
    and communicate in a highly efficient binary format
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Google的协议缓冲区和相关工具以高效二进制格式描述服务和进行通信
- en: How endpoints in Go kit allow us to write a single service implementation and
    have it exposed via multiple transport protocols
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go kit中的端点如何允许我们编写单个服务实现，并通过多种传输协议将其公开
- en: How Go kits-included subpackages help us solve lots of common problems
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go kit包含的子包如何帮助我们解决许多常见问题
- en: How Middleware lets us wrap endpoints to adapt their behavior without touching
    the implementation itself
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件如何让我们在不触及实现本身的情况下包装端点以适应其行为
- en: How to describe method calls as requests and response messages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将方法调用描述为请求和响应消息
- en: How to rate limit our services to protect from surges in traffic
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对我们的服务进行速率限制以保护免受流量激增的影响
- en: A few other idiomatic Go tips and tricks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他的Go语言惯用技巧和技巧
- en: 'Some lines of code in this chapter stretch over many lines; they are written
    with the overflowing content right-aligned on the next line, as shown in this
    example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些代码行跨越了许多行；它们是以溢出的内容在下一行右对齐的方式编写的，如下例所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three lines in the preceding snippet should be written as one line.
    Don't worry; the Go compiler will be kind enough to point out if you get this
    wrong.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中的前三行应该写在一行中。不用担心；Go编译器会足够友好地指出您是否出错。
- en: Introducing gRPC
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍gRPC
- en: There are many options when it comes to how our services will communicate with
    each other and how clients will communicate with the services, and Go kit doesn't
    care (rather, it doesn't mind–it cares enough to provide implementations of many
    popular mechanisms). In fact, we are able to add multiple options for our users
    and let them decide which one they want to use. We will add support the familiar
    JSON over HTTP, but we are also going to introduce a new technology choice for
    APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的服务如何相互通信以及客户端如何与服务通信时，有许多选项，Go kit并不关心（更确切地说，它并不介意——它足够关心，以至于提供了许多流行机制的实现）。实际上，我们能够为我们的用户提供多个选项，并让他们决定他们想要使用哪一个。我们将添加对熟悉的JSON
    over HTTP的支持，但我们也将引入一个新的API技术选择。
- en: gRPC, short for Google's **Remote Procedure Call**, is an open source mechanism
    used to call code that is running remotely over a network. It uses HTTP/2 for
    transport and protocol buffers to represent the data that makes up services and
    messages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC，即Google的**远程过程调用**，是一个开源机制，用于通过网络调用远程运行的代码。它使用HTTP/2进行传输，并使用协议缓冲区来表示构成服务和消息的数据。
- en: An RPC service differs from RESTful web services because rather than making
    changes to data using well-defined HTTP standards, as you do with REST (`POST`
    to create something, `PUT` to update something, `DELETE` to delete something,
    and so on), you are triggering a remote function or method instead, passing in
    expected arguments and getting back one or more pieces of data in response.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RPC服务与RESTful网络服务不同，因为您不是使用定义良好的HTTP标准来更改数据（就像您使用REST那样——使用`POST`创建某物，使用`PUT`更新某物，使用`DELETE`删除某物等），而是触发一个远程函数或方法，传递预期的参数，并得到一个或多个数据响应。
- en: 'To highlight the difference, imagine that we are creating a new user. In a
    RESTful world, we could make a request like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出差异，想象一下我们正在创建一个新用户。在一个RESTful的世界里，我们可以发出如下请求：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And we might get a response like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会得到如下响应：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: RESTful calls represent queries or changes to the state of resources. In an
    RPC world, we would use generated code instead in order to make binary serialized
    procedure calls that feel much more like normal methods or functions in Go.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful调用表示对资源状态的查询或更改。在RPC世界中，我们会使用生成的代码来代替，以便进行二进制序列化的过程调用，这些调用在Go中感觉更像正常的方法或函数。
- en: The only other key difference between a RESTful service and a gPRC service is
    that rather than JSON or XML, gPRC speaks a special format called **protocol buffers**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与RESTful服务和gPRC服务之间唯一的另一个关键区别是，gPRC而不是JSON或XML，使用一种称为**协议缓冲区**的特殊格式。
- en: Protocol buffers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲区
- en: Protocol buffers (called `protobuf` in code) are a binary serialization format
    that is very small and extremely quick to encode and decode. You describe data
    structures in an abstract way using a declarative mini language, and generate
    source code (in a variety of languages) to make reading and writing the data easy
    for users.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区（在代码中称为`protobuf`）是一种非常小且编码和解码非常快的二进制序列化格式。您使用声明性迷你语言以抽象方式描述数据结构，并生成源代码（多种语言），以便用户轻松读写数据。
- en: You can think of protocol buffers as a modern alternative to XML, except that
    the definition of the data structure is separated from the content, and the content
    is in a binary format rather than text.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把协议缓冲区看作是XML的现代替代品，只不过数据结构的定义与内容分开，而内容是以二进制格式而不是文本格式。
- en: 'It''s clear to see the benefits when you look at a real example. If we wanted
    to represent a person with a name in XML, we could write this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看真实示例时，可以清楚地看到其好处。如果我们想在XML中表示一个有名字的人，我们可以这样写：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This takes up about 30 bytes (discounting whitespace). Let''s see how it would
    look in JSON:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约占用30个字节（不包括空白）。让我们看看它在JSON中的样子：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we're down to 14 bytes, but the structure is still embedded in the content
    (the name field is spelled out along with the value).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经缩减到14个字节，但结构仍然内嵌在内容中（名称字段与值一起展开）。
- en: 'The equivalent content in protocol buffers would only take five bytes. The
    following table shows each byte, along with the first five bytes of the XML and
    JSON representations for comparison. The **Description** row explains the meaning
    of the bytes in the **Content** row, which shows the protocol buffer bytes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲区中，等效内容只需5个字节。以下表格显示了每个字节，以及XML和JSON表示的前五个字节，以供比较。**描述**行解释了**内容**行中字节的含义：
- en: '| **Byte** | **1** | **2** | **3** | **4** | **5** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **字节** | **1** | **2** | **3** | **4** | **5** |'
- en: '| **Content** | 0a | 03 | 4d | 61 | 72 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **内容** | 0a | 03 | 4d | 61 | 72 |'
- en: '| **Description** | Type (string) | Length (3) | M | A | T |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 类型（字符串） | 长度（3） | M | A | T |'
- en: '| **XML** | < | p | e | r | s |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **XML** | < | p | e | r | s |'
- en: '| **JSON** | { | " | n | a | m |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **JSON** | { | " | n | a | m |'
- en: The structure definition lives in a special `.proto` file, separate from the
    data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结构定义存在于一个特殊的`.proto`文件中，与数据分开。
- en: There are still plenty of cases where XML or JSON would be a better choice than
    protocol buffers, and file size isn't the only measure when deciding a data format
    to use, but for fixed schema structures and remote procedure calls or for applications
    running at a truly massive scale, it's a popular choice for good reasons.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有许多情况下，XML或JSON比协议缓冲区更适合，而在决定使用的数据格式时，文件大小并不是唯一的衡量标准，但对于固定模式结构和远程过程调用，或者对于真正大规模运行的应用程序，它是一个因合理原因而流行的选择。
- en: Installing protocol buffers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装协议缓冲区
- en: 'There are some tools to compile and generate source code for protocol buffers,
    which you can grab from the GitHub home page of the project at [https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases).
    Once you''ve downloaded the file, unpack it and place the `protoc` file from the
    bin folder into an appropriate folder on your machine: one that is mentioned in
    your `$PATH` environment variable.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以编译并生成协议缓冲区的源代码，您可以从项目的GitHub主页[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)获取。一旦下载了文件，解压它并将bin文件夹中的`protoc`文件放置在您的机器上的一个适当文件夹中：一个在您的`$PATH`环境变量中提到的文件夹。
- en: 'Once the protoc command is ready, we''ll need to add a plugin that will allow
    us to work with Go code. In a terminal, execute this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦protoc命令就绪，我们需要添加一个插件，这将允许我们使用Go代码。在终端中执行以下命令：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will install two packages that we'll make use of later.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装两个我们将要使用的包。
- en: Protocol buffers language
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议缓冲区语言
- en: To define our data structure, we are going to use the third version of the protocol
    buffers language, known as `proto3`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的数据结构，我们将使用协议缓冲区语言的第三个版本，称为`proto3`。
- en: Create a new folder in your `$GOPATH` called `vault`, and a subfolder called
    `pb` inside that. The `pb` package is where our protocol buffer definition and
    the generated source code will live.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`$GOPATH`中创建一个名为`vault`的新文件夹，并在其中创建一个名为`pb`的子文件夹。`pb`包将存放我们的协议缓冲区定义和生成的源代码。
- en: 'We are going to define a service called `Vault`, which has two methods, `Hash`
    and `Validate`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`Vault`的服务，它有两个方法，`Hash`和`Validate`：
- en: '| **Method** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Hash` | Generate a secure hash for a given password. The hash can be stored
    instead of storing the password in plain text. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Hash` | 为给定的密码生成一个安全的哈希值。可以存储哈希值而不是存储明文密码。|'
- en: '| `Validate` | Given a password and a previously generated hash, the Validate
    method will check to ensure that the password is correct. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Validate` | 给定一个密码和之前生成的哈希值，`Validate`方法将检查密码是否正确。|'
- en: 'Each service call has a request and response pair, which we will define as
    well. Inside `pb`, insert the following code into a new file called `vault.proto`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务调用都有一个请求和响应对，我们也将定义这些。在`pb`中，将以下代码插入一个名为`vault.proto`的新文件中：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Vertical whitespace has been removed to save paper, but you are free to add
    spaces between each block if you think it improves readability.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省纸张，已经删除了垂直空白，但如果你认为在各个块之间添加空格可以提高可读性，你可以这样做。
- en: The first things we specify in our file are that we are using the `proto3` syntax
    and the name of the package for the generated source code is `pb`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件中首先指定的是使用`proto3`语法，以及生成源代码的包名为`pb`。
- en: 'The `service` block defines `Vault` and the two methods-with `HashRequest`,
    `HashResponse`, `ValidateRequest`, and `ValidateResponse` messages defined underneath.
    The lines beginning with `rpc` inside the service block indicate that our service
    consists of two remote procedure calls: `Hash` and `Validate`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`service`块定义了`Vault`以及在其下方定义的两个方法——`HashRequest`、`HashResponse`、`ValidateRequest`和`ValidateResponse`消息。服务块中以`rpc`开头的行表示我们的服务由两个远程过程调用组成：`Hash`和`Validate`。'
- en: 'The fields inside a message take the following format:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 消息内部字段采用以下格式：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `type` is a string that describes the scalar value type, such as `string`,
    `bool`, `double`, `float`, `int32`, `int64`, and so on. The `name` is a human-readable
    string that describes the field, such as `hash` and `password`. The position is
    an integer that indicates where in the data stream that field appears. This is
    important because the content is a stream of bytes, and lining up the content
    to the definition is vital to being able to use the format. Additionally, if we
    were to add (or even rename) fields later (one of the key design features of protocol
    buffers), we could do so without breaking components that expect certain fields
    in a specific order; they would continue to work untouched, ignoring new data
    and just transparently passing it along.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`是一个描述标量值类型的字符串，例如`string`、`bool`、`double`、`float`、`int32`、`int64`等。`name`是一个人类可读的字符串，用于描述字段，例如`hash`和`password`。位置是一个整数，表示该字段在数据流中的位置。这很重要，因为内容是字节流，将内容与定义对齐对于能够使用该格式至关重要。此外，如果我们稍后添加（甚至重命名）字段（协议缓冲区的一个关键设计特性），我们可以在不破坏期望以特定顺序包含某些字段的组件的情况下这样做；它们将继续无改动地工作，忽略新数据，并透明地传递它。'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a complete list of the supported types as well as a deep dive into the entire
    language, check out the documentation at [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关支持类型的完整列表以及对该语言的深入探讨，请查看[https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)上的文档。
- en: Note that each method call has an associated request and response pair. These
    are the messages that will be sent over the network when the remote method is
    called.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个方法调用都有一个相关的请求和响应对。这些是当远程方法被调用时通过网络发送的消息。
- en: Since the Hash method takes a single password string argument, the `HashRequest`
    object contains a single password string field. Like normal Go functions, the
    responses may contain an error, which is why both `HashResponse` and `ValidateResponse`
    have two fields. There is no dedicated `error` interface in proto3 like there
    is in Go, so we are going to turn the error into a string instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希方法只接受一个密码字符串参数，因此`HashRequest`对象包含一个密码字符串字段。像正常的Go函数一样，响应可能包含一个错误，这就是为什么`HashResponse`和`ValidateResponse`都有两个字段。在proto3中，没有像Go中那样的专用`error`接口，所以我们打算将错误转换为字符串。
- en: Generating Go code
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成Go代码
- en: 'Go doesn''t understand proto3 code, but luckily the protocol buffer compiler
    and Go plugin we installed earlier can translate it into something Go does understand:
    Go code.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Go无法理解proto3代码，但幸运的是，我们之前安装的协议缓冲编译器和Go插件可以将它翻译成Go可以理解的东西：Go代码。
- en: 'In a terminal, navigate to the `pb` folder and run the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到`pb`文件夹，并运行以下命令：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will generate a new file called `vault.pb.go`. Open the file and inspect
    its contents. It has done a lot of work for us, including defining the messages
    and even creating `VaultClient` and `VaultServer` types for us to use, which will
    allow us to consume and expose the service, respectively.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为`vault.pb.go`的新文件。打开该文件并检查其内容。它为我们做了很多工作，包括定义消息，甚至为我们创建了`VaultClient`和`VaultServer`类型，这将允许我们分别消费和公开服务。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You are free to decode the rest of the generated code (the file descriptor looks
    especially interesting) if you are interested in the details. For now, we're going
    to trust that it works and use the `pb` package to build our service implementation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对生成的其余代码（文件描述符看起来特别有趣）感兴趣，你可以自由地解码。现在，我们将相信它工作正常，并使用`pb`包来构建我们的服务实现。
- en: Building the service
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务
- en: At the end of the day, whatever other dark magic is going on in our architecture,
    it will come down to some Go method being called, doing some work, and returning
    a result. So the next thing we are going to do is define and implement the Vault
    service itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论我们的架构中正在进行什么其他黑暗魔法，它最终都会归结为调用某个Go方法，执行一些工作，并返回一个结果。所以接下来我们要做的是定义和实现Vault服务本身。
- en: 'Inside the `vault` folder, add the following code to a new `service.go` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vault`文件夹内，向一个新创建的`service.go`文件中添加以下代码：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This interface defines the service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口定义了服务。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might think that `VaultService` would be a better name than just `Service`,
    but remember that since this is a Go package, it will been seen externally as
    `vault.Service`, which reads nicely.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为`VaultService`比仅仅`Service`更好，但请记住，由于这是一个Go包，它将在外部被视为`vault.Service`，这听起来很顺耳。
- en: 'We define our two methods: `Hash` and `Validate`. Each takes `context.Context`
    as the first argument, followed by normal `string` arguments. The responses are
    normal Go types as well: `string`, `bool`, and `error`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个方法：`Hash`和`Validate`。每个方法都将`context.Context`作为第一个参数，然后是正常的`string`参数。响应也是正常的Go类型：`string`、`bool`和`error`。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some libraries may still require the old context dependency, `golang.org/x/net/context`,
    rather than the `context` package that was made available first in Go 1.7\. Watch
    out for errors complaining about mixed use and make sure you're importing the
    right one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库可能仍然需要旧的上下文依赖项，即`golang.org/x/net/context`，而不是Go 1.7首次提供的`context`包。注意错误关于混合使用的问题，并确保你导入的是正确的。
- en: Part of designing micro-services is being careful about where state is stored.
    Even though you will implement the methods of a service in a single file, with
    access to global variables, you should never use them to store the per-request
    or even per-service state. It's important to remember that each service is likely
    to be running on many physical machines multiple times, each with no access to
    the others' global variables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 设计微服务的一部分是注意状态存储的位置。即使你将在单个文件中实现服务的各种方法，并且可以访问全局变量，你也绝不应该使用它们来存储每个请求或甚至每个服务的状态。重要的是要记住，每个服务可能会在多个物理机器上多次运行，每个机器都无法访问其他机器的全局变量。
- en: 'In this spirit, we are going to implement our service using an empty `struct`,
    essentially a neat idiomatic Go trick to group methods together in order to implement
    an interface without storing any state in the object itself. To `service.go`,
    add the following `struct`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个精神下，我们将使用一个空的`struct`来实现我们的服务，这实际上是一个整洁的Go惯用技巧，可以将方法组合在一起，以便在不存储对象本身中的任何状态的情况下实现接口。向`service.go`添加以下`struct`：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the implementation did require any dependencies (such as a database connection
    or a configuration object), you could store them inside the struct and use the
    method receivers in your function bodies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现确实需要任何依赖项（例如数据库连接或配置对象），你可以将它们存储在结构体中，并在函数体中使用方法接收器。
- en: Starting with tests
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从测试开始
- en: Where possible, starting by writing test code has many advantages that usually
    end up increasing the quality and maintainability of your code. We are going to
    write a unit test that will use our new service to hash and then validate a password.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，首先编写测试代码有许多优点，通常最终会提高代码的质量和可维护性。我们将编写一个单元测试，该测试将使用我们新的服务来散列并验证密码。
- en: 'Create a new file called `service_test.go` and add the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`service_test.go`的新文件，并添加以下代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will create a new service via the `NewService` method and then use it to
    call the `Hash` and `Validate` methods. We even test an unhappy case, where we
    get the password wrong and ensure that `Validate` returns `false`–otherwise, it
    wouldn't be very secure at all.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过`NewService`方法创建一个新的服务，然后使用它来调用`Hash`和`Validate`方法。我们甚至测试了一个不愉快的案例，即我们输入了错误的密码，并确保`Validate`返回`false`——否则，它将非常不安全。
- en: Constructors in Go
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go语言中的构造函数
- en: A **constructor** in other object-oriented languages is a special kind of function
    that creates instances of classes. It performs any initialization and takes in
    required arguments such as dependencies, among others. It is usually the only
    way to create an object in these languages, but it often has weird syntax or relies
    on naming conventions (such as the function name being the same as the class,
    for example).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他面向对象的语言中，**构造函数**是一种特殊的函数，用于创建类的实例。它执行任何初始化并接受所需的参数，例如依赖项等。在这些语言中，通常只有一种创建对象的方式，但它往往具有奇怪的语法或依赖于命名约定（例如，函数名称与类名相同）。
- en: Go doesn't have constructors; it's much simpler and just has functions, and
    since functions can return arguments, a constructor would just be a global function
    that returns a usable instance of a struct. The Go philosophy of simplicity drives
    these kinds of decisions for the language designers; rather than forcing people
    to have to learn about a new concept of constructing objects, developers only
    have to learn how functions work and they can build constructors with them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言没有构造函数；它更简单，只有函数，并且由于函数可以返回参数，构造函数将只是一个全局函数，它返回一个可用的结构体实例。Go语言的简单哲学驱使语言设计者做出这类决策；而不是强迫人们学习关于构建对象的新概念，开发者只需要学习函数的工作方式，他们就可以使用函数构建构造函数。
- en: Even if we aren't doing any special work in the construction of an object (such
    as initializing fields, validating dependencies, and so on), it is sometimes worth
    adding a construction function anyway. In our case, we do not want to bloat the
    API by exposing the `vaultService` type since we already have our `Service` interface
    type exposed and are hiding it inside a constructor is a nice way to achieve this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在构建一个对象的过程中没有进行任何特殊的工作（例如初始化字段、验证依赖关系等），有时添加一个构建函数也是值得的。在我们的情况下，我们不想通过暴露`vaultService`类型来膨胀API，因为我们已经暴露了我们的`Service`接口类型，并且将其隐藏在构造函数中是一种实现这一点的不错方式。
- en: 'Underneath the `vaultService` struct definition, add the `NewService` function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vaultService`结构定义下方，添加`NewService`函数：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Not only does this prevent us from needing to expose our internals, but if in
    the future we do need to do more work to prepare the `vaultService` for use, we
    can also do it without changing the API and, therefore, without requiring the
    users of our package to change anything on their end, which is a big win for API
    design.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅阻止了我们暴露内部结构，而且如果将来我们需要对`vaultService`进行更多工作以准备其使用，我们也可以在不更改API的情况下完成，因此不需要我们的包的用户在他们的端进行任何更改，这对于API设计来说是一个巨大的胜利。
- en: Hashing and validating passwords with bcrypt
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bcrypt散列和验证密码
- en: The first method we will implement in our service is `Hash`. It will take a
    password and generate a hash. The resulting hash can then be passed (along with
    a password) to the `Validate` method later, which will either confirm or deny
    that the password is correct.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在服务中实现的第一个方法是`Hash`。它将接受一个密码并生成一个散列。然后可以将生成的散列（以及密码）传递给稍后要调用的`Validate`方法，该方法将确认或否认密码是否正确。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn more about the correct way to store passwords in applications, check
    out the Coda Hale blog post on the subject at [https://codahale.com/how-to-safely-store-a-password/](https://codahale.com/how-to-safely-store-a-password/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于在应用程序中正确存储密码的方法，请查看Coda Hale关于该主题的博客文章，链接为[https://codahale.com/how-to-safely-store-a-password/](https://codahale.com/how-to-safely-store-a-password/)。
- en: The point of our service is to ensure that passwords never need to be stored
    in a database, since that's a security risk if anyone is ever able to get unauthorized
    access to the database. Instead, you can generate a one-way hash (it cannot be
    decoded) that can safely be stored, and when users attempt to authenticate, you
    can perform a check to see whether the password generates the same hash or not.
    If the hashes match, the passwords are the same; otherwise, they are not.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的目的是确保密码永远不会需要存储在数据库中，因为如果有人能够未经授权访问数据库，那将是一个安全风险。相反，您可以生成一个单向哈希（无法解码），它可以安全地存储，并且当用户尝试进行身份验证时，您可以执行检查以查看密码是否生成相同的哈希。如果哈希匹配，则密码相同；否则，它们不相同。
- en: The `bcrypt` package provides methods that do this work for us in a secure and
    trustworthy way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcrypt` 包提供了以安全可靠的方式为我们完成这项工作的方法。'
- en: 'To `service.go`, add the `Hash` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `service.go` 添加 `Hash` 方法：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ensure that you import the appropriate `bcrypt` package (try `golang.org/x/crypto/bcrypt`).
    We are essentially wrapping the `GenerateFromPassword` function to generate the
    hash, which we then return provided no errors occurred.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您导入适当的 `bcrypt` 包（尝试 `golang.org/x/crypto/bcrypt`）。我们本质上是在包装 `GenerateFromPassword`
    函数以生成哈希，然后在没有错误发生的情况下返回它。
- en: Note that the receiver in the `Hash` method is just `(vaultService)`; we don't
    capture the variable because there is no way we can store state on an empty `struct`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Hash` 方法中的接收器只是 `(vaultService)`；我们没有捕获变量，因为我们无法在空 `struct` 上存储状态。
- en: 'Next up, let''s add the `Validate` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加 `Validate` 方法：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar to `Hash`, we are calling `bcrypt.CompareHashAndPassword` to determine
    (in a secure way) whether the password is correct or not. If an error is returned,
    it means that something is amiss and we return `false` indicating that. Otherwise,
    we return `true` when the password is valid.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Hash` 类似，我们正在调用 `bcrypt.CompareHashAndPassword` 以安全方式确定密码是否正确。如果返回错误，则表示有问题，我们返回
    `false` 表示。否则，当密码有效时，我们返回 `true`。
- en: Modeling method calls with requests and responses
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求和响应模拟方法调用
- en: Since our service will be exposed through various transport protocols, we will
    need a way to model the requests and responses in and out of our service. We will
    do this by adding a `struct` for each type of message our service will accept
    or return.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务将通过各种传输协议公开，我们需要一种方式来模拟服务内外部的请求和响应。我们将通过为服务将接受或返回的每种消息类型添加一个 `struct`
    来实现这一点。
- en: 'In order for somebody to call the `Hash` method and then receive the hashed
    password as a response, we''ll need to add the following two structures to `service.go`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让某人能够调用 `Hash` 方法并接收哈希密码作为响应，我们需要将以下两个结构添加到 `service.go`：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `hashRequest` type contains a single field, the password, and the `hashResponse`
    has the resulting hash and an `Err` string field in case something goes wrong.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashRequest` 类型包含一个字段，即密码，而 `hashResponse` 包含生成的哈希以及一个 `Err` 字符串字段，以防出现错误。'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To model remote method calls, you essentially create a `struct` for the incoming
    arguments and a `struct` for the return arguments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟远程方法调用，您实际上是为传入参数创建一个 `struct`，并为返回参数创建一个 `struct`。
- en: Before continuing, see whether you can model the same request/response pair
    for the `Validate` method. Look at the signature in the `Service` interface, examine
    the arguments it accepts, and think about what kind of responses it will need
    to make.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，看看您是否可以为 `Validate` 方法模拟相同的请求/响应对。查看 `Service` 接口中的签名，检查它接受的参数，并考虑它需要做出什么样的响应。
- en: 'We are going to add a helper method (of type `http.DecodeRequestFunc` from
    Go kit) that will be able to decode the JSON body of `http.Request` to `service.go`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个辅助方法（类型为 Go kit 的 `http.DecodeRequestFunc`），它将能够将 `http.Request` 的 JSON
    主体解码到 `service.go`：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The signature for `decodeHashRequest` is dictated by Go kit because it will
    later use it to decode HTTP requests on our behalf. In this function, we just
    use `json.Decoder` to unmarshal the JSON into our `hashRequest` type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeHashRequest` 的签名由 Go kit 决定，因为它将稍后代表我们解码 HTTP 请求。在这个函数中，我们只是使用 `json.Decoder`
    将 JSON 解码到我们的 `hashRequest` 类型中。'
- en: 'Next, we will add the request and response structures as well as a decode helper
    function for the `Validate` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `Validate` 方法添加请求和响应结构以及一个解码辅助函数：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `validateRequest` struct takes both `Password` and `Hash` strings,
    since the signature has two input arguments and returns a response containing
    a `bool` datatype called `Valid` or `Err`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`validateRequest` 结构体同时接受 `Password` 和 `Hash` 字符串，因为签名有两个输入参数，并返回一个包含名为
    `Valid` 或 `Err` 的 `bool` 数据类型的响应。
- en: The final thing we need to do is encode the response. In this case, we can write
    a single method to encode both the `hashResponse` and `validateResponse` objects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是编码响应。在这种情况下，我们可以编写一个单独的方法来编码 `hashResponse` 和 `validateResponse`
    对象。
- en: 'Add the following code to `service.go`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `service.go` 中：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `encodeResponse` method just asks `json.Encoder` to do the work for us.
    Note again that the signature is general since the `response` type is `interface{}`;
    this is because it's a Go kit mechanism for decoding to `http.ResponseWriter`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `encodeResponse` 方法只是让 `json.Encoder` 帮我们完成工作。再次注意，签名是通用的，因为 `response`
    类型是 `interface{}`；这是因为它是 Go kit 用于解码到 `http.ResponseWriter` 的机制。
- en: Endpoints in Go kit
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go kit 中的端点
- en: 'Endpoints are a special function type in Go kit that represent a single RPC
    method. The definition is inside the `endpoint` package:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 端点是 Go kit 中的一个特殊函数类型，它代表单个 RPC 方法。定义在 `endpoint` 包中：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An endpoint function takes `context.Context` and `request`, and it returns `response`
    or `error`. The `request` and `response` types are `interface{}`, which tells
    us that it is up to the implementation code to deal with the actual types when
    building endpoints.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 端点函数接受 `context.Context` 和 `request`，并返回 `response` 或 `error`。`request` 和 `response`
    类型是 `interface{}`，这告诉我们，在构建端点时，处理实际类型的责任在于实现代码。
- en: 'Endpoints are powerful because, like `http.Handler` (and `http.HandlerFunc`),
    you can wrap them with generalized middleware to solve a myriad of common issues
    that arise when building micro-services: logging, tracing, rate limiting, error
    handling, and more.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 端点很强大，因为，就像 `http.Handler`（和 `http.HandlerFunc`）一样，你可以用通用中间件包装它们，以解决在构建微服务时出现的各种常见问题：日志记录、跟踪、速率限制、错误处理等等。
- en: Go kit solves transporting over various protocols and uses endpoints as a general
    way to jump from their code to ours. For example, the gRPC server will listen
    on a port, and when it receives the appropriate message, it will call the corresponding
    `Endpoint` function. Thanks to Go kit, this will all be transparent to us, as
    we only need to deal in Go code with our `Service` interface.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit 解决了在多种协议上传输的问题，并使用端点作为从它们的代码跳转到我们的代码的通用方式。例如，gRPC 服务器将在端口上监听，并在接收到适当的消息时调用相应的
    `Endpoint` 函数。多亏了 Go kit，这一切对我们来说都是透明的，因为我们只需要用 Go 代码处理我们的 `Service` 接口。
- en: Making endpoints for service methods
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为服务方法创建端点
- en: In order to turn our service methods into `endpoint.Endpoint` functions, we're
    going to write a function that handles the incoming `hashRequest`, calls the `Hash`
    service method, and depending on the response, builds and returns an appropriate
    `hashResponse` object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的服务方法转换为 `endpoint.Endpoint` 函数，我们将编写一个处理传入的 `hashRequest`、调用 `Hash` 服务方法，并根据响应构建和返回适当的
    `hashResponse` 对象的函数。
- en: 'To `service.go`, add the `MakeHashEndpoint` function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MakeHashEndpoint` 函数添加到 `service.go` 中：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function takes `Service` as an argument, which means that we can generate
    an endpoint from any implementation of our `Service` interface. We then use a
    type assertion to specify that the request argument should, in fact, be of type
    `hashRequest`. We call the `Hash` method, passing in the context and `Password`,
    which we get from `hashRequest`. If all is well, we build `hashResponse` with
    the value we got back from the `Hash` method and return it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受 `Service` 作为参数，这意味着我们可以从我们的 `Service` 接口的任何实现中生成端点。然后我们使用类型断言来指定请求参数实际上应该是
    `hashRequest` 类型。我们调用 `Hash` 方法，传入上下文和 `Password`，这些是从 `hashRequest` 获取的。如果一切顺利，我们使用从
    `Hash` 方法返回的值构建 `hashResponse` 并返回它。
- en: 'Let''s do the same for the `Validate` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `Validate` 方法也做同样的事情：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we are doing the same: taking the request and using it to call the method
    before building a response. Note that we never return an error from the `Endpoint`
    function.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们做的是同样的事情：获取请求并使用它来调用方法，然后再构建响应。请注意，我们从不会从 `Endpoint` 函数返回错误。
- en: Different levels of error
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同的错误级别
- en: 'There are two main types of errors in Go kit: transport errors (network failure,
    timeouts, dropped connection, and so on) and business logic errors (where the
    infrastructure of making the request and responding was successful, but something
    in the logic or data wasn''t correct).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go kit中，主要有两种错误类型：传输错误（网络故障、超时、断开连接等）和业务逻辑错误（请求和响应的基础设施执行成功，但逻辑或数据中存在问题）。
- en: If the `Hash` method returns an error, we are not going to return it as the
    second argument; instead, we are going to build `hashResponse`, which contains
    the error string (accessible via the `Error` method). This is because the error
    returned from an endpoint is intended to indicate a transport error, and perhaps
    Go kit will be configured to retry the call a few times by some middleware. If
    our service methods return an error, it is considered a business logic error and
    will probably always return the same error for the same input, so it's not worth
    retrying. This is why we wrap the error into the response and return it to the
    client so that they can deal with it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Hash`方法返回错误，我们不会将其作为第二个参数返回；相反，我们将构建`hashResponse`，其中包含错误字符串（可通过`Error`方法访问）。这是因为从端点返回的错误旨在指示传输错误，也许Go
    kit将通过某些中间件配置为重试调用几次。如果我们的服务方法返回错误，则被视为业务逻辑错误，并且对于相同的输入可能会始终返回相同的错误，因此不值得重试。这就是为什么我们将错误包装到响应中，并将其返回给客户端，以便他们可以处理它。
- en: Wrapping endpoints into a Service implementation
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将端点包装到服务实现中
- en: Another very useful trick when dealing with endpoints in Go kit is to write
    an implementation of our `vault.Service` interface, which just makes the necessary
    calls to the underlying endpoints.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go kit中处理端点时，另一个非常有用的技巧是编写我们`vault.Service`接口的实现，它只是对底层端点进行必要的调用。
- en: 'To `service.go`, add the following structure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下结构体添加到`service.go`中：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order to implement the `vault.Service` interface, we are going to add the
    two methods to our `Endpoints` structure, which will build a request object, make
    the request, and parse the resulting response object into the normal arguments
    to be returned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`vault.Service`接口，我们将在我们的`Endpoints`结构体中添加两个方法，这些方法将构建一个请求对象，发送请求，并将生成的响应对象解析为要返回的正常参数。
- en: 'Add the following `Hash` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下`Hash`方法：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are calling `HashEndpoint` with `hashRequest`, which we create using the
    password argument before caching the general response to `hashResponse` and returning
    the Hash value from it or an error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hashRequest`调用`HashEndpoint`，我们使用密码参数在将一般响应缓存到`hashResponse`并从中返回哈希值或错误之前创建它。
- en: 'We will do this for the Validate method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`Validate`方法做同样的事情：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These two methods will allow us to treat the endpoints we have created as though
    they are normal Go methods; very useful for when we actually consume our service
    later in this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法将使我们能够将我们创建的端点视为正常的Go方法；这对于我们在本章后面实际消费服务时非常有用。
- en: An HTTP server in Go kit
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go kit中的HTTP服务器
- en: The true value of Go kit becomes apparent when we create an HTTP server for
    our endpoints to hash and validate.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为我们的端点创建一个HTTP服务器以进行哈希和验证时，Go kit的真实价值才显现出来。
- en: 'Create a new file called `server_http.go` and add the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`server_http.go`的新文件，并添加以下代码：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are importing the `github.com/go-kit/kit/transport/http` package and (since
    we're also importing the `net/http` package) telling Go that we're going to explicitly
    refer to this package as `httptransport`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入`github.com/go-kit/kit/transport/http`包，并且（由于我们还在导入`net/http`包）告诉Go我们将显式地引用此包为`httptransport`。
- en: We are using the `NewServeMux` function from the standard library to build `http.Handler` 
    interface with simple routing and mapping the `/hash` and `/validate` paths. We
    take the `Endpoints` object since we want our HTTP server to serve these endpoints,
    including any middleware that we will add later. Calling `httptransport.NewServer`
    is how we get Go kit to give us an HTTP handler for each endpoint. Like most functions,
    we pass in `context.Context` as the first argument, which will form the base context
    for each request. We also pass in the endpoint as well as the decoding and encoding
    functions that we wrote earlier so that the server knows how to unmarshal and
    marshal the JSON messages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用标准库中的 `NewServeMux` 函数来构建 `http.Handler` 接口，并进行简单的路由，将 `/hash` 和 `/validate`
    路径映射。我们获取 `Endpoints` 对象，因为我们想让我们的 HTTP 服务器提供这些端点，包括我们稍后可能添加的任何中间件。调用 `httptransport.NewServer`
    是让 Go kit 为每个端点提供 HTTP 处理器的方法。像大多数函数一样，我们传入 `context.Context` 作为第一个参数，这将形成每个请求的基本上下文。我们还传入端点以及我们之前编写的解码和编码函数，以便服务器知道如何反序列化和序列化
    JSON 消息。
- en: A gRPC server in Go kit
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go kit 中的 gRPC 服务器
- en: 'Adding a gPRC server using Go kit is almost as easy as adding a JSON/HTTP server,
    like we did in the last section. In our generated code (in the `pb` folder), we
    were given the following `pb.VaultServer` type:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go kit 添加 gRPC 服务器几乎和添加 JSON/HTTP 服务器一样简单，就像我们在上一节中所做的那样。在我们的生成代码（在 `pb`
    文件夹中），我们得到了以下 `pb.VaultServer` 类型：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This type is very similar to our own `Service` interface, except that it takes
    in generated request and response classes rather than raw arguments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型与我们自己的 `Service` 接口非常相似，只是它接受生成请求和响应类而不是原始参数。
- en: 'We''ll start by defining a type that will implement the preceding interface.
    Add the following code to a new file called `server_grpc.go`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个将实现前面接口的类型。将以下代码添加到一个名为 `server_grpc.go` 的新文件中：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that you'll need to import `github.com/go-kit/kit/transport/grpc` as `grpctransport`,
    along with the generated `pb` package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要导入 `github.com/go-kit/kit/transport/grpc` 作为 `grpctransport`，以及生成的 `pb`
    包。
- en: The `grpcServer` struct contains a field for each of the service endpoints,
    this time of type `grpctransport.Handler`. Then, we implement the methods of the
    interface, calling the `ServeGRPC` method on the appropriate handler. This method
    will actually serve requests by first decoding them, calling the appropriate endpoint
    function, getting the response, and encoding it and sending it back to the client
    who made the request.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`grpcServer` 结构体包含每个服务端点的字段，这次是 `grpctransport.Handler` 类型。然后，我们实现接口的方法，在适当的处理器上调用
    `ServeGRPC` 方法。这个方法实际上会通过首先解码请求，调用适当的端点函数，获取响应，然后编码并发送回请求客户端来处理请求。'
- en: Translating from protocol buffer types to our types
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从协议缓冲类型转换为我们的类型
- en: You'll notice that we're using the request and response objects from the `pb`
    package, but remember that our own endpoints use the structures we added to `service.go`
    earlier. We are going to need a method for each type in order to translate to
    and from our own types.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们正在使用 `pb` 包中的请求和响应对象，但请记住，我们自己的端点使用我们在 `service.go` 中早期添加的结构。我们将需要一个针对每种类型的方法来将其转换为我们的类型。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There's a lot of repetitive typing coming up; feel free to copy and paste this
    from the GitHub repository at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    to save your fingers. We're hand coding this manually because it's important to
    understand all the pieces that make up the service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来会有很多重复的输入；如果你愿意，可以从 GitHub 仓库 [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    复制粘贴以节省你的手指。我们正在手动编码，因为这很重要，要理解构成服务的所有部分。 '
- en: 'To `server_grpc.go`, add the following function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server_grpc.go` 中添加以下函数：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function is an `EncodeRequestFunc` function defined by Go kit, and it is
    used to translate our own `hashRequest` type into a protocol buffer type that
    can be used to communicate with the client. It uses `interface{}` types because
    it's general, but in our case, we can be sure about the types so we cast the incoming
    request to `hashRequest` (our own type) and then build a new `pb.HashRequest`
    object using the appropriate fields.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是 Go kit 定义的 `EncodeRequestFunc` 函数，它用于将我们的 `hashRequest` 类型转换为可以与客户端通信的协议缓冲类型。它使用
    `interface{}` 类型，因为它很通用，但在这个案例中，我们可以确信类型，因此我们将传入的请求转换为 `hashRequest`（我们的类型）然后使用适当的字段构建一个新的
    `pb.HashRequest` 对象。
- en: 'We are going to do this for both encoding and decoding requests and responses
    for both hash and validate endpoints. Add the following code to `server_grpc.go`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, there is a lot of boilerplate coding to do in order to get things
    working.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code generation (not covered here) would have great application here, since
    the code is very predictable and self-similar.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing to do in order to get our gRPC server working is to provide
    a helper function to create an instance of our `grpcServer` structure. Underneath
    the `grpcServer` struct, add the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Like our HTTP server, we take in a base context and the actual `Endpoints` implementation
    that we are exposing via the gRPC server. We create and return a new instance
    of our `grpcServer` type, setting the handlers for both `hash` and `validate`
    by calling `grpctransport.NewServer`. We use our `endpoint.Endpoint` functions
    for our service and tell the service which of our encoding/decoding functions
    to use for each case.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server command
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all of our service code lives inside the `vault` package. We are now
    going to use this package to create a new tool to expose the server functionality.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in `vault` called `cmd`, and inside it create another called
    `vaultd`. We are going to put our command code inside the `vaultd` folder because
    even though the code will be in the `main` package, the name of the tool will
    be `vaultd` by default. If we just put the command in the `cmd` folder, the tool
    would be built into a binary called `cmd`-which is pretty confusing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go projects, if the primary use of the package is to be imported into other
    programs (such as Go kit), then the root level files should make up the package
    and will have an appropriate package name (not `main`). If the primary purpose
    is a command-line tool, such as the Drop command ([https://github.com/matryer/drop](https://github.com/matryer/drop)),
    then the root files will be in the `main` package.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The rationale for this comes down to usability; when importing a package, you
    want the string the user has to type to be the shortest it can be. Similarly,
    when using `go install`, you want the path to be short and sweet.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The tool we are going to build (suffixed with `d`, indicating that it is a daemon
    or a background task) will spin up both our gRPC and JSON/HTTP servers. Each will
    run in their own goroutine, and we will trap any termination signals or errors
    from the servers, which will cause the termination of our program.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In Go kit, main functions end up being quite large, which is by design; there
    is a single function that contains the entirety of your micro-service; from there,
    you can dig down into the details, but it provides an at-a-glance view of each
    component.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build up the `main` function piece by piece inside a new `main.go`
    file in the `vaultd` folder, starting with the fairly big list of imports:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `your/path/to` prefixes should be replaced with the actual route from `$GOPATH`
    to where your project is. Pay attention to the context import too; it's quite
    possible that you just need to type context rather than the import listed here
    depending on when Go kit transitions to Go 1.7\. Finally, the `grpc` package from
    Google provides everything we need in order to expose gRPC capabilities over the
    network.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will put together our `main` function; remember that all the sections
    following this one go inside the body of the `main` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use flags to allow the ops team to decide which endpoints we will listen
    on when exposing the service on the network, but provide sensible defaults of
    `:8080` for the JSON/HTTP server and :`8081` for the gRPC server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new context using the `context.Background()` function, which
    returns a non-nil, empty context that has no cancelation or deadline specified
    and contains no values, perfect for the base context of all of our services. Requests
    and middleware are free to create new context objects from this one in order to
    add request-scoped data or deadlines.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use our `NewService` constructor to make a new `Service` type for us
    and make a zero-buffer channel, which can take an error should one occur.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add the code that traps termination signals (such as *Ctrl + C*)
    and sends an error down `errChan`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, in a new goroutine, we ask `signal.Notify` to tell us when we receive
    the `SIGINT` or `SIGTERM` signals. When that happens, the signal will be sent
    down the `c` channel, at which point we'll format it as a string (its `String()`
    method will be called), and we turn that into an error, which we'll send down
    `errChan`, resulting in the termination of the program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Using Go kit endpoints
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to create one of our endpoints instances that we can pass to our
    servers. Add the following code to the main function body:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are assigning the fields to the output of our endpoint helper functions for
    both the hash and validate methods. We are passing in the same service for both,
    so the `endpoints` variable essentially ends up being a wrapper around our `srv`
    service.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be tempted to neaten up this code by removing the assignment to the
    variables altogether and just set the return of the helper functions to the fields
    in the struct initialization, but when we come to add middleware later, you'll
    be thankful for this approach.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to start up our JSON/HTTP and gRPC servers using these endpoints.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Running the HTTP server
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will add the goroutine to make and run the JSON/HTTP server to the main
    function body:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All the heavy lifting has already been done for us in our package code by Go
    kit, so we are left with simply calling the `NewHTTPServer` function, passing
    in the background context and the service endpoints we wish for it to expose,
    before calling the standard library's `http.ListenAndServe`, which exposes the
    handler functionality in the specified `httpAddr`. If an error occurs, we send
    it down the error channel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit 在我们的包代码中已经为我们完成了所有繁重的工作，所以我们只需调用 `NewHTTPServer` 函数，传递背景上下文和希望公开的服务端点，然后在调用标准库的
    `http.ListenAndServe` 之前，该函数在指定的 `httpAddr` 中公开处理器功能。如果发生错误，我们将它发送到错误通道。
- en: Running the gRPC server
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 gRPC 服务器
- en: 'There is a little more work to do in order to run the gRPC server, but it is
    still pretty simple. We must create a low-level TCP network listener and serve
    the gRPC server over that. Add the following code to the main function body:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行 gRPC 服务器，还需要做一些额外的工作，但仍然相当简单。我们必须创建一个低级别的 TCP 网络监听器，并在其上提供 gRPC 服务器。将以下代码添加到主函数主体中：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We make the TCP listener on the `gRPCAddr` endpoint specified, sending any errors
    down the `errChan` error channel. We use `vault.NewGRPCServer` to create the handler,
    again passing in the background context and the instance of `Endpoints` we are
    exposing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在指定的 `gRPCAddr` 端点创建 TCP 监听器，并将任何错误发送到 `errChan` 错误通道。我们使用 `vault.NewGRPCServer`
    创建处理器，再次传递背景上下文和我们公开的 `Endpoints` 实例。
- en: Tip
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note how both the JSON/HTTP server and the gRPC server are actually exposing
    the same service–literally the same instance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 JSON/HTTP 服务器和 gRPC 服务器实际上公开的是相同的服务——字面上是同一个实例。
- en: We then create a new gRPC server from Google's `grpc` package and register it
    using our own generated `pb` package via the `RegisterVaultServer` function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 Google 的 `grpc` 包创建一个新的 gRPC 服务器，并通过 `RegisterVaultServer` 函数使用我们自己的生成的
    `pb` 包进行注册。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `RegisterVaultService` function just calls `RegisterService` on our `grpcServer`
    but hides the internals of the service description that was automatically generated.
    If you look in `vault.pb.go` and search for the `RegisterVaultServer` function,
    you will see that it makes a reference to something like `&_Vault_serviceDesc`,
    which is the description of the service. Feel free to dig around the generated
    code; the metadata is especially interesting, but out of scope for this book.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterVaultService` 函数只是在我们自己的 `grpcServer` 上调用 `RegisterService`，但隐藏了自动生成的服务描述的内部细节。如果你查看
    `vault.pb.go` 并搜索 `RegisterVaultServer` 函数，你会看到它引用了类似 `&_Vault_serviceDesc` 的内容，这是服务的描述。你可以随意挖掘生成的代码；元数据特别有趣，但本书不涉及这部分内容。'
- en: We then ask the server to `Serve` itself, throwing any errors down the same
    error channel if they occur.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们要求服务器自己 `Serve`，如果发生错误，将错误信息发送到同一个错误通道。
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's out of scope for this chapter, but it is recommended that every service
    be delivered with **Transport Layer Security** (**TLS**), especially the ones
    dealing with passwords.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这章不涉及，但建议每个服务都应提供**传输层安全性**（**TLS**），特别是处理密码的服务。
- en: Preventing a main function from terminating immediately
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止主函数立即终止
- en: If we closed our main function here, it would immediately exit and terminate
    all of our servers. This is because everything we're doing that would prevent
    this is inside its own goroutine. To prevent this, we need a way to block the
    function at the end to wait until something tells the program to terminate.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里关闭了主函数，它将立即退出并终止所有服务器。这是因为我们正在做的所有防止这种情况发生的事情都在它自己的goroutine中。为了防止这种情况，我们需要一种方法在函数末尾阻塞，等待程序收到终止信号。
- en: Since we are using the `errChan` error channel for errors, this is a perfect
    candidate. We can just listen on this channel, which (while nothing has been sent
    down it) will block and allow the other goroutines to do their work. If something
    goes wrong (or if a termination signal is received), the `<-errChan` call will
    unblock and exit and all goroutines will be stopped.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 `errChan` 错误通道来处理错误，这是一个完美的候选者。我们可以监听这个通道，在没有任何内容发送下来时，它会阻塞并允许其他goroutine执行它们的工作。如果出现问题（或收到终止信号），`<-errChan`
    调用将解除阻塞并退出，所有goroutine都将停止。
- en: 'At the bottom of the main function, add the final statement and closing block:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数的底部，添加最后的语句和结束块：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When an error occurs, we'll just log it and exit with a nonzero code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，我们只是记录它并以非零代码退出。
- en: Consuming the service over HTTP
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 HTTP 消费服务
- en: Now that we have wired everything up, we can test the HTTP server using the
    `curl` command–or any tool that lets us make JSON/HTTP requests.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, let''s start by running our servers. Head over to the `vault/cmd/vaultd`
    folder and start the program:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the server is running, you''ll see something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, open another terminal and issue the following HTTP request using `curl`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We are making a POST request to the hash endpoint with a JSON body that contains
    the password we want for hashing. Then, we get something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hash in this example won't match yours–there are many acceptable hashes
    and there's no way to know which one you'll get. Ensure that you copy and paste
    your actual hash (everything inside the double quotes).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting hash is what we would store in our data store given the specified
    password. Then, when the user tries to log in again, we will make a request with
    the password they entered, along with this hash, to the validate endpoint:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Make this request by copying and pasting the correct hash and entering the
    same `hernandez` password, and you will see this result:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, change the password (this is equivalent to the user getting it wrong)
    and you will see this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can see that the JSON/HTTP micro-service exposure for our vault service
    is complete and working.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how we can consume the gRPC version.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Building a gRPC client
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike JSON/HTTP services, gRPC services aren't easy for humans to interact
    with. They're really intended as machine-to-machine protocols, and so we must
    write a program if we wish to use them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: To help us do this, we are first going to add a new package inside our vault
    service called `vault/client/grpc`. It will, given a gRPC client connection object
    that we get from Google's `grpc` package, provide an object that performs the
    appropriate calls, encoding and decoding, for us, all hidden behind our own `vault.Service`
    interface. So, we will be able to use the object as though it is just another
    implementation of our interface.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Create new folders inside vault so that you have the path of `vault/client/grpc`.
    You can imagine adding other clients if you so wish, so this seems a good pattern
    to establish.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to a new `client.go` file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `grpctransport` package is referring to `github.com/go-kit/kit/transport/grpc`.
    This might feel familiar by now; we are making two new endpoints based on the
    specified connection, this time being explicit about the `Vault` service name
    and the endpoint names `Hash` and `Validate`. We pass in appropriate encoders
    and decoders from our vault package and empty response objects before wrapping
    them both in our `vault.Endpoints` structure that we added-the one that implements
    the `vault.Service` interface that just triggers the specified endpoints for us.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: A command-line tool to consume the service
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to write a command-line tool (or CLI-command-line
    interface), which will allow us to communicate with our service through the gRPC
    protocol. If we were writing another service in Go, we would use the vault client
    package in the same way as we will when we write our CLI tool.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tool will let you access the services in a fluent way on the command line
    by separating commands and arguments with spaces such that we can hash a password
    like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will be able to validate a password with a hash like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `cmd` folder, create a new folder called `vaultcli`. Add a main.go file
    and insert the following main function:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Ensure that you import the `vault/client/grpc` package as `grpcclient` and `google.golang.org/grpc`
    as `grpc`. You'll also need to import the `vault` package.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We parse the flags and get a background context as usual before dialing the
    gRPC endpoint to establish a connection. If all is well, we defer the closing
    of the connection and create our vault service client using that connection. Remember
    that this object implements our `vault.Service` interface, so we can just call
    the methods as though they were normal Go methods, without worrying about the
    fact that communication is taking place over a network protocol.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Then, we start parsing the command-line arguments in order to decide which execution
    flow to take.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments in CLIs
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parsing arguments in command-line tools is very common, and there is a neat
    idiomatic way to do it in Go. The arguments are all available via the `os.Args`
    slice, or if you're using flags, the `flags.Args()` method (which gets arguments
    with flags stripped). We want to take each argument off the slice (from the beginning)
    and consume them in an order, which will help us decide which execution flow to
    take through the program. We're going to add a helper function called `pop`, which
    will return the first item, and the slice with the first item trimmed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll write a quick unit test to ensure that our `pop` function is working
    as expected. If you would like to try and write the pop function yourself, then
    you should do that once the test is in place. Remember that you can run tests
    by navigating to the appropriate folder in a terminal and executing this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new file inside `vaultcli` called `main_test.go` and add the following
    test function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We expect each call to pop to yield the next item in the slice and empty arguments
    once the slice is empty.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `main.go`, add the `pop` function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Maintaining good line of sight by extracting case bodies
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only thing that remains for us to do is implement the hash and validate
    methods referred to in the switch statement shown earlier.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We could have embedded this code inside the switch statement itself, but that
    would make the main function very difficult to read and also hide happy path execution
    at different indentation levels, something we should try to avoid.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it is a good practice to have the cases inside the switch statement
    jump out to a dedicated function, taking in any arguments it needs. Underneath
    the main function, add the following hash and validate functions:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These functions simply call the appropriate method on the service, and depending
    on the result, log or print the results to the console. If the validate method
    returns false, the program will exit with an exit code of 1, since nonzero means
    an error.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Installing tools from the Go source code
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the tool, we just have to navigate to the `vaultcli` folder in a
    terminal and type this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Provided there are no errors, the package will be built and deployed to the
    `$GOPATH/bin` folder, which should already be listed in your `$PATH` environment
    variable. This means that the tool is ready for use just like a normal command
    in your terminal.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The name of the binary that is deployed will match the folder name, and this
    is why we have an additional folder inside the `cmd` folder even if we are only
    building a single command.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Once you have installed the command, we can use it to test the gRPC server.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to `cmd/vaultd` and start the server (if it isn''t already running)
    by typing the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In another terminal, let''s hash a password by typing this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that the hash is returned. Now let''s validate this hash:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Tip
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hash may contain special characters that interfere with your terminal, so
    you should escape the string with quotes if required.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac, format the argument with `$'PASTE_HASH_HERE'` to properly escape it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, try surrounding the argument with exclamation points: `!PASTE_HASH_HERE!`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: If you get the password right, you'll notice that you see the word `valid`;
    otherwise, you'll see `invalid`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting with service middleware
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built a complete service, we are going to see how easy it is
    to add middleware to our endpoints in order to extend the service without touching
    the actual implementations themselves.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: In real-world services, it is sensible to limit the number of requests it will
    attempt to handle so that the service doesn't get overwhelmed. This can happen
    if the process needs more memory than is available, or we might notice performance
    degradation if it eats up too much of the CPU. In a micro-service architecture,
    the strategy to solving these problems is to add another node and spread the load,
    which means that we want each individual instance to be rate limited.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Since we are providing the client, we should add rate limiting there, which
    would prevent too many requests from getting on the network. But it is also sensible
    to add rate limiting to the server in case many clients are trying to access the
    same services at the same time. Luckily, endpoints in Go kit are used for both
    the client and server, so we can use the same code to add middleware in both places.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add a **Token Bucket**-based rate limiter, which you can read
    more about at [https://en.wikipedia.org/wiki/Token_bucket](https://en.wikipedia.org/wiki/Token_bucket).
    The guys at Juju have written a Go implementation that we can use by importing
    `github.com/juju/ratelimit`, and Go kit has middleware built for this very implementation,
    which will save us a lot of time and effort.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The general idea is that we have a bucket of tokens, and each request will need
    a token in order to do its work. If there are no tokens in the bucket, we have
    reached our limit and the request cannot be completed. Buckets refill over time
    at a specific interval.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `github.com/juju/ratelimit` and before we create our `hashEndpoint`,
    insert the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `NewBucket` function creates a new rate limiting bucket that will refill
    at a rate of one token per second, up to a maximum of five tokens. These numbers
    are pretty silly for our case, but we want to be able to reach our limits manually
    during the development.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the Go kit `ratelimit` package has the same name as the Juju one, we
    are going to need to import it with a different name:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Middleware in Go kit
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Endpoint middleware in Go kit is specified by the `endpoint.Middleware` function
    type:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A piece of middleware is simply a function that takes `Endpoint` and returns
    `Endpoint`. Remember that `Endpoint` is also a function:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This gets a little confusing, but they are the same as the wrappers we built
    for `http.HandlerFunc`. A middleware function returns an `Endpoint` function that
    does something before and/or after calling the `Endpoint` being wrapped. The arguments
    passed into the function that returns the `Middleware` are closured in, which
    means that they are available to the inner code (via closures) without the state
    having to be stored anywhere else.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `NewTokenBucketLimiter` middleware from Go kit''s `ratelimit`
    package, and if we take a look at the code, we''ll see how it uses closures and
    returns functions to inject a call to the token bucket''s `TakeAvailable` method
    before passing execution to the `next` endpoint:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A pattern has emerged within Go kit where you obtain the endpoint and then put
    all middleware adaptations inside their own block immediately afterwards. The
    returned function is given the endpoint when it is called, and the same variable
    is overwritten with the result.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple example, consider this code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will now do this for our endpoints; update the code inside the main function
    to add the rate limiting middleware:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There's nothing much to change here; we're just updating the `hashEndpoint`
    and `validateEndpoint` variables before assigning them to the `vault.Endpoints`
    struct.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Manually testing the rate limiter
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see whether our rate limiter is working, and since we set such low thresholds,
    we can test it just using our command-line tool.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'First, restart the server (so the new code runs) by hitting *Ctrl + C* in the
    terminal window running the server. This signal will be trapped by our code, and
    an error will be sent down `errChan`, causing the program to quit. Once it has
    terminated, restart it:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, in another window, let''s hash some passwords:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Repeat this command a few times–in most terminals, you can press the up arrow
    key and return. You''ll notice that the first few requests succeed because it''s
    within the limits, but if you get a little more aggressive and issue more than
    five requests in a second, you''ll notice that we get errors:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This shows that our rate limiter is working. We see errors until the token bucket
    fills back up, where our requests are fulfilled again.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Graceful rate limiting
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than returning an error (which is a pretty harsh response), perhaps we
    would prefer the server to just hold onto our request and fulfill it when it can-called
    throttling. For this case, Go kit provides the `NewTokenBucketThrottler` middleware.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the middleware code to use this middleware function instead:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The first argument to `NewTokenBucketThrottler` is the same endpoint as earlier,
    but now we have added a second argument of `time.Sleep`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go kit allows us to customize the behavior by specifying what should happen
    when the delay needs to take place. In our case, we're passing `time.Sleep`, which
    is a function that will ask execution to pause for the specified amount of time.
    You could write your own function here if you wanted to do something different,
    but this works for now.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Now repeat the test from earlier, but this time, note that we never get an error-instead,
    the terminal will hang for a second until the request can be fulfilled.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot through this chapter as we put together a real example of a
    micro-service. There is a lot of work involved without code generation, but the
    benefits for large teams and big micro-service architectures pay for the investment
    as you build self-similar, discrete components that make up the system.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: We learned how gRPC and protocol buffers give us highly efficient transport
    communications between clients and servers. Using the `proto3` language, we defined
    our service, including messages, and used the tools to generate a Go package that
    provided the client and server code for us.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: We explored the fundamentals of Go kit and how we can use endpoints to describe
    the methods of our services. We let Go kit do the heavy lifting for us when it
    came to building HTTP and gRPC servers by making use of the packages included
    in the project. We saw how middleware functions let us easily adapt our endpoints
    to, among other things, rate limit the amount of traffic the server will have
    to handle.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about constructors in Go, a neat trick to parse incoming command-line
    arguments, and how to hash and validate passwords using the `bcrypt` package,
    which is a sensible approach that helps us avoid storing passwords at all.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to building micro-services, and it is recommended that you
    head over to the Go kit website at [https://gokit.io](https://gokit.io) or join
    the conversation on the `#go-kit` slack channel at gophers.slack.com to learn
    more.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built our Vault service, we need to think about our options
    in order to deploy it into the wild. In the next chapter, we'll package our micro-service
    into a Docker container and deploy it to Digital Ocean's cloud.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
