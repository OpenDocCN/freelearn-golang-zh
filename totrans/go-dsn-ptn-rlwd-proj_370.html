<html><head></head><body>
<div class="book" title="Builder design pattern - reusing an algorithm to create many implementations of an interface">
<div class="book" title="Unit test for the vehicle builder"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec041" class="calibre1"/>Unit test for the vehicle builder</h2></div></div></div><p class="calibre10">With the previous acceptance criteria, we will create a director variable, the <code class="email">ManufacturingDirector</code> type, to use the build processes represented by the product builder variables for a car and motorbike. The director is the one in charge of construction of the objects, but the builders are the ones that return the actual vehicle. So our builder declaration will look as follows:</p><pre class="programlisting">package creational 
 
type BuildProcess interface { 
    SetWheels() BuildProcess 
    SetSeats() BuildProcess 
    SetStructure() BuildProcess 
    GetVehicle() VehicleProduct 
} 
</pre><p class="calibre10">This preceding interface defines the steps that are necessary to build a vehicle. Every builder must implement this <code class="email">interface</code> if they are to be used by the manufacturing. On every <code class="email">Set</code> step, we return the same build process, so we can chain various steps together in the same statement, as we'll see later. Finally, we'll need a <code class="email">GetVehicle</code> method to retrieve the <code class="email">Vehicle</code> instance from the builder:</p><pre class="programlisting">type ManufacturingDirector struct {} 
 
func (f *ManufacturingDirector) Construct() { 
    //Implementation goes here 
} 
 
func (f *ManufacturingDirector) SetBuilder(b BuildProcess) { 
    //Implementation goes here 
} 
</pre><p class="calibre10">The <code class="email">ManufacturingDirector</code> director variable is the one in charge of accepting the builders. It has a <code class="email">Construct</code> method that will use the builder that is stored in <code class="email">Manufacturing</code>, and will reproduce the required steps. The <code class="email">SetBuilder</code> method will allow us to change the builder that is being used in the <code class="email">Manufacturing</code> director:</p><pre class="programlisting">type VehicleProduct struct { 
    Wheels    int 
    Seats     int 
    Structure string 
} 
</pre><p class="calibre10">The product is the final object that we want to retrieve while using the manufacturing. In this case, a vehicle is composed of wheels, seats, and a structure:</p><pre class="programlisting">type CarBuilder struct {} 
 
func (c *CarBuilder) SetWheels() BuildProcess { 
    return nil 
} 
 
func (c *CarBuilder) SetSeats() BuildProcess { 
    return nil 
} 
 
func (c *CarBuilder) SetStructure() BuildProcess { 
    return nil 
} 
 
func (c *CarBuilder) Build() VehicleProduct { 
    return VehicleProduct{} 
} 
</pre><p class="calibre10">The first Builder is the <code class="email">Car</code> builder. It must implement every method defined in the <code class="email">BuildProcess</code> interface. This is where we'll set the information for this particular builder:</p><pre class="programlisting">type BikeBuilder struct {} 
 
func (b *BikeBuilder) SetWheels() BuildProcess { 
    return nil 
} 
 
func (b *BikeBuilder) SetSeats() BuildProcess { 
    return nil 
} 
 
func (b *BikeBuilder) SetStructure() BuildProcess { 
    return nil 
} 
 
func (b *BikeBuilder) Build() VehicleProduct { 
    return VehicleProduct{} 
} 
</pre><p class="calibre10">The <code class="email">Motorbike</code> structure must be the same as the <code class="email">Car</code> structure, as they are all Builder implementations, but keep in mind that the process of building each can be very different. With this declaration of objects, we can create the following tests:</p><pre class="programlisting">package creational 
 
import "testing" 
 
func TestBuilderPattern(t *testing.T) { 
    manufacturingComplex := ManufacturingDirector{} 
 
    carBuilder := &amp;CarBuilder{} 
    manufacturingComplex.SetBuilder(carBuilder) 
    manufacturingComplex.Construct() 
 
    car := carBuilder.Build() 
 
    //code continues here... 
</pre><p class="calibre10">We will start with the <code class="email">Manufacturing</code> director and the <code class="email">Car</code> Builder to fulfill the first two acceptance criteria. In the preceding code, we are creating our <code class="email">Manufacturing</code> director that will be in charge of the creation of every vehicle during the test. After creating the <code class="email">Manufacturing</code> director, we created a <code class="email">CarBuilder</code> that we then passed to manufacturing by using the <code class="email">SetBuilder</code> method. Once the <code class="email">Manufacturing</code> director knows what it has to construct now, we can call the <code class="email">Construct</code> method to create the <code class="email">VehicleProduct</code> using <code class="email">CarBuilder</code>. Finally, once we have all the pieces for our car, we call the <code class="email">GetVehicle</code> method on <code class="email">CarBuilder</code> to retrieve a <code class="email">Car</code> instance:</p><pre class="programlisting">if car.Wheels != 4 { 
    t.Errorf("Wheels on a car must be 4 and they were %d\n", car.Wheels) 
} 
 
if car.Structure != "Car" { 
    t.Errorf("Structure on a car must be 'Car' and was %s\n", car.Structure) 
} 
 
if car.Seats != 5 { 
    t.Errorf("Seats on a car must be 5 and they were %d\n", car.Seats) 
} 
</pre><p class="calibre10">We have written three small tests to check if the outcome is a car. We checked that the car has four wheels, the structure has the description <code class="email">Car</code>, and the number of seats is five. We have enough data to execute the tests and make sure that they are failing so that we can consider them reliable:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestBuilder .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestBuilderPattern</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestBuilderPattern (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:15: Wheels on a car must be 4 and they were 0</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:19: Structure on a car must be 'Car' and was</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:23: Seats on a car must be 5 and they were 0</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Perfect! Now we will create tests for a <code class="email">Motorbike</code> builder that covers the third and fourth acceptance criteria:</p><pre class="programlisting">bikeBuilder := &amp;BikeBuilder{} 
 
manufacturingComplex.SetBuilder(bikeBuilder) 
manufacturingComplex.Construct() 
 
motorbike := bikeBuilder.GetVehicle() 
motorbike.Seats = 1 
 
if motorbike.Wheels != 2 { 
    t.Errorf("Wheels on a motorbike must be 2 and they were %d\n", motorbike.Wheels) 
} 
 
if motorbike.Structure != "Motorbike" { 
    t.Errorf("Structure on a motorbike must be 'Motorbike' and was %s\n", motorbike.Structure) 
} 
</pre><p class="calibre10">The preceding code is a continuation of the car tests. As you can see, we reuse the previously created manufacturing to create the bike now by passing the <code class="email">Motorbike</code> builder to it. Then we hit the <code class="email">construct</code> button again to create the necessary parts, and call the builder <code class="email">GetVehicle</code> method to retrieve the motorbike instance.</p><p class="calibre10">Take a quick look, because we have changed the default number of seats for this particular motorbike to 1. What we want to show here is that even while having a builder, you must also be able to change the default information in the returned instance to fit some specific needs. As we set the wheels manually, we won't test this feature.</p><p class="calibre10">Re-running the tests triggers the expected behavior:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=Builder .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestBuilderPattern</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestBuilderPattern (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:15: Wheels on a car must be 4 and they were 0</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:19: Structure on a car must be 'Car' and was</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:23: Seats on a car must be 5 and they were 0</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:35: Wheels on a motorbike must be 2 and they were 0</strong></span>
<span class="strong"><strong class="calibre2">        builder_test.go:39: Structure on a motorbike must be 'Motorbike' and was</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre></div></div></body></html>