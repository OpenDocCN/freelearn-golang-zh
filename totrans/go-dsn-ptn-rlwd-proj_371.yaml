- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We will start implementing the manufacturing. As we said earlier (and as we
    set in our unit tests), the `Manufacturing` director must accept a builder and
    construct a vehicle using the provided builder. To recall, the `BuildProcess`
    interface will define the common steps needed to construct any vehicle and the
    `Manufacturing` director must accept builders and construct vehicles together
    with them:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始实现制造。正如我们之前所说的（以及我们在单元测试中设置的），`Manufacturing` 导演必须接受一个构建器，并使用提供的构建器构建一辆车。为了回忆，`BuildProcess`
    接口将定义构建任何车辆所需的通用步骤，并且 `Manufacturing` 导演必须接受构建器并与它们一起构建车辆：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `ManufacturingDirector` needs a field to store the builder in use; this
    field will be called `builder`. The `SetBuilder` method will replace the stored
    builder with the one provided in the arguments. Finally, take a closer look at
    the `Construct` method. It takes the builder that has been stored and reproduces
    the `BuildProcess` method that will create a full vehicle of some unknown type.
    As you can see, we have used all the setting calls in the same line thanks to
    returning the `BuildProcess` interface on each of the calls. This way the code
    is more compact:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ManufacturingDirector` 需要一个字段来存储正在使用的构建器；这个字段将被称为 `builder`。`SetBuilder`
    方法将用提供的参数中的构建器替换存储的构建器。最后，更仔细地看看 `Construct` 方法。它接受存储的构建器并重现 `BuildProcess` 方法，该方法将创建一个未知类型的完整车辆。正如你所看到的，我们通过在每个调用中返回
    `BuildProcess` 接口，在同一行中使用了所有的设置调用。这样代码就更加紧凑：
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Have you realized that the director entity in the Builder pattern is a clear
    candidate for a Singleton pattern too? In some scenarios, it could be critical
    that just an instance of the Director is available, and that is where you'll create
    a Singleton pattern for the Director of the Builder only. Design patterns composition
    is a very common technique and a very powerful one!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到构建器模式中的导演实体也是一个清晰的 Singleton 模式候选？在某些场景中，可能至关重要的是只有一个导演实例可用，这就是你只为构建器的导演创建
    Singleton 模式的地方。设计模式组合是一个非常常见的技术，也是一个非常强大的技术！
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here is our first builder, the `car` builder. A builder will need to store a
    `VehicleProduct` object, which here we have named `v`. Then we set the specific
    needs that a car has in our business--four wheels, five seats, and a structure
    defined as `Car`. In the `GetVehicle` method, we just return the `VehicleProduct`
    stored within the Builder that must be already constructed by the `ManufacturingDirector` type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的第一个构建器，即 `car` 构建器。构建器需要存储一个 `VehicleProduct` 对象，在这里我们将其命名为 `v`。然后我们设置汽车在我们业务中的特定需求——四个轮子、五个座位，以及定义为
    `Car` 的结构。在 `GetVehicle` 方法中，我们只需返回构建器中存储的 `VehicleProduct`，它必须已经由 `ManufacturingDirector`
    类型构建。
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Motorbike` Builder is the same as the `car` builder. We defined a motorbike
    to have two wheels, two seats, and a structure called `Motorbike`. It's very similar
    to the `car` object, but imagine that you want to differentiate between a sports
    motorbike (with only one seat) and a cruise motorbike (with two seats). You could
    simply create a new structure for sports motorbikes that implements the build
    process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Motorbike` 构造器与 `car` 构造器相同。我们定义摩托车有两个轮子、两个座位和一个名为 `Motorbike` 的结构。它与 `car`
    对象非常相似，但想象一下，你想要区分运动摩托车（只有一个座位）和巡航摩托车（有两个座位）。你可以简单地为运动摩托车创建一个新的结构，该结构实现了构建过程。'
- en: You can see that it's a repetitive pattern, but within the scope of every method
    of the `BuildProcess` interface, you could encapsulate as much complexity as you
    want such that the user need not know the details about the object creation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这是一个重复的模式，但在 `BuildProcess` 接口每个方法的范围内，你可以封装尽可能多的复杂性，这样用户就不必了解对象创建的细节。
- en: 'With the definition of all the objects, let''s run the tests again:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有对象之后，让我们再次运行测试：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Well done! Think how easy it could be to add new vehicles to the `ManufacturingDirector`
    director just create a new class encapsulating the data for the new vehicle. For
    example, let´s add a `BusBuilder` struct:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！想想看，向 `ManufacturingDirector` 添加新车辆有多容易，只需创建一个封装新车辆数据的新的类。例如，让我们添加一个 `BusBuilder`
    结构体：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's all; your `ManufacturingDirector` would be ready to use the new product
    by following the Builder design pattern.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些；你的 `ManufacturingDirector` 就可以通过遵循构建器设计模式来使用新产品了。
