- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start implementing the manufacturing. As we said earlier (and as we
    set in our unit tests), the `Manufacturing` director must accept a builder and
    construct a vehicle using the provided builder. To recall, the `BuildProcess`
    interface will define the common steps needed to construct any vehicle and the
    `Manufacturing` director must accept builders and construct vehicles together
    with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ManufacturingDirector` needs a field to store the builder in use; this
    field will be called `builder`. The `SetBuilder` method will replace the stored
    builder with the one provided in the arguments. Finally, take a closer look at
    the `Construct` method. It takes the builder that has been stored and reproduces
    the `BuildProcess` method that will create a full vehicle of some unknown type.
    As you can see, we have used all the setting calls in the same line thanks to
    returning the `BuildProcess` interface on each of the calls. This way the code
    is more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you realized that the director entity in the Builder pattern is a clear
    candidate for a Singleton pattern too? In some scenarios, it could be critical
    that just an instance of the Director is available, and that is where you'll create
    a Singleton pattern for the Director of the Builder only. Design patterns composition
    is a very common technique and a very powerful one!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here is our first builder, the `car` builder. A builder will need to store a
    `VehicleProduct` object, which here we have named `v`. Then we set the specific
    needs that a car has in our business--four wheels, five seats, and a structure
    defined as `Car`. In the `GetVehicle` method, we just return the `VehicleProduct`
    stored within the Builder that must be already constructed by the `ManufacturingDirector` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Motorbike` Builder is the same as the `car` builder. We defined a motorbike
    to have two wheels, two seats, and a structure called `Motorbike`. It's very similar
    to the `car` object, but imagine that you want to differentiate between a sports
    motorbike (with only one seat) and a cruise motorbike (with two seats). You could
    simply create a new structure for sports motorbikes that implements the build
    process.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it's a repetitive pattern, but within the scope of every method
    of the `BuildProcess` interface, you could encapsulate as much complexity as you
    want such that the user need not know the details about the object creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the definition of all the objects, let''s run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done! Think how easy it could be to add new vehicles to the `ManufacturingDirector`
    director just create a new class encapsulating the data for the new vehicle. For
    example, let´s add a `BusBuilder` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's all; your `ManufacturingDirector` would be ready to use the new product
    by following the Builder design pattern.
  prefs: []
  type: TYPE_NORMAL
