<html><head></head><body>
<div class="book" title="Factory method - delegating the creation of different types of payments">
<div class="book" title="First unit test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec048" class="calibre1"/>First unit test</h2></div></div></div><p class="calibre10">A Factory method has a very simple structure; we just need to identify how many implementations of our interface we are storing, and then provide a method, <code class="email">GetPaymentMethod</code>, where you can pass a type of payment as an argument:</p><pre class="programlisting">type PaymentMethod interface { 
    Pay(amount float32) string 
} 
</pre><p class="calibre10">The preceding lines define the interface of the payment method. They define a way of making a payment at the shop. The Factory method will return instances of types that implement this interface:</p><pre class="programlisting">const ( 
    Cash      = 1 
    DebitCard = 2 
) 
</pre><p class="calibre10">We have to define the identified payment methods of the Factory as constants so that we can call and check the possible payment methods from outside of the package.</p><pre class="programlisting">func GetPaymentMethod(m int) (PaymentMethod, error) { 
    return nil, errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">The preceding code is the function that will create the objects for us. It returns a pointer, which must have an object that implements the <code class="email">PaymentMethod</code> interface, and an error if asked for a method which is not registered.</p><pre class="programlisting">type CashPM struct{} 
type DebitCardPM struct{} 
 
func (c *CashPM) Pay(amount float32) string { 
    return "" 
} 
 
func (c *DebitCardPM) Pay(amount float32) string { 
    return "" 
} 
</pre><p class="calibre10">To finish the declaration of the Factory, we create the two payment methods. As you can see, the <code class="email">CashPM</code> and <code class="email">DebitCardPM</code> structs implement the <code class="email">PaymentMethod</code> interface by declaring a method, <code class="email">Pay(amount float32) string</code>. The returned string will contain information about the payment.</p><p class="calibre10">With this declaration, we will start by writing the tests for the first acceptance criteria: to have a common method to retrieve objects that implement the <code class="email">PaymentMethod</code> interface:</p><pre class="programlisting">package creational 

import ( 
    "strings" 
    "testing" 
) 
 
func TestCreatePaymentMethodCash(t *testing.T) { 
    payment, err := GetPaymentMethod(Cash) 
    if err != nil { 
        t.Fatal("A payment method of type 'Cash' must exist") 
    } 
 
    msg := payment.Pay(10.30) 
    if !strings.Contains(msg, "paid using cash") { 
        t.Error("The cash payment method message wasn't correct") 
    } 
    t.Log("LOG:", msg) 
} 
</pre><p class="calibre10">Now we'll have to separate the tests among a few of the test functions. <code class="email">GetPaymentMethod</code> is a common method to retrieve methods of payment. We use the constant <code class="email">Cash</code>, which we have defined in the implementation file (if we were using this constant outside for the scope of the package, we would call it using the name of the package as the prefix, so the syntax would be <code class="email">creational.Cash</code>). We also check that we have not received an error when asking for a payment method. Observe that if we receive the error when asking for a payment method, we call <code class="email">t.Fatal</code> to stop the execution of the tests; if we called just <code class="email">t.Error</code> like in the previous tests, we would have a problem in the next lines when trying to access the <code class="email">Pay</code> method of a nil object, and our tests would crash execution. We continue by using the <code class="email">Pay</code> method of the interface by passing 10.30 as the amount. The returned message will have to contain the text <code class="email">paid using cash</code>. The <code class="email">t.Log(string)</code> method is a special method in testing. This struct allows us to write some logs when we run the tests if we pass the <code class="email">-v</code> flag.</p><pre class="programlisting">func TestGetPaymentMethodDebitCard(t *testing.T) { 
    payment, err = GetPaymentMethod(Debit9Card) 
 
    if err != nil { 
        t.Error("A payment method of type 'DebitCard' must exist")
    } 
 
    msg = payment.Pay(22.30) 
 
    if !strings.Contains(msg, "paid using debit card") { 
        t.Error("The debit card payment method message wasn't correct") 
    } 
 
    t.Log("LOG:", msg) 
}</pre><p class="calibre10">We repeat the same operation with the debit card method. We ask for the payment method defined with the constant <code class="email">DebitCard,</code> and the returned message, when paying with debit card, must contain the <code class="email">paid using debit card</code> string.</p><pre class="programlisting"> 
func TestGetPaymentMethodNonExistent(t *testing.T) { 
    payment, err = GetPaymentMethod(20) 
 
    if err == nil { 
        t.Error("A payment method with ID 20 must return an error") 
    } 
    t.Log("LOG:", err) 
}</pre><p class="calibre10">Finally, we are going to test the situation when we request a payment method that doesn´t exist (represented by the number 20, which doesn't match any recognized constant in the Factory). We will check if an error message (any) is returned when asking for an unknown payment method.</p><p class="calibre10">Let's check whether all tests are failing:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=GetPaymentMethod .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodCash</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestGetPaymentMethodCash (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:11: A payment method of type 'Cash' must exist</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodDebitCard</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestGetPaymentMethodDebitCard (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:24: A payment method of type 'DebitCard' must exist</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodNonExistent</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestGetPaymentMethodNonExistent (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:38: LOG: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">As you can see in this example, we can only see tests that return the <code class="email">PaymentMethod</code> interfaces failing. In this case, we'll have to implement just a part of the code, and then test again before continuing.</p></div></div></body></html>