- en: First unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次单元测试
- en: 'A Factory method has a very simple structure; we just need to identify how
    many implementations of our interface we are storing, and then provide a method,
    `GetPaymentMethod`, where you can pass a type of payment as an argument:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法有一个非常简单的结构；我们只需要识别我们存储了多少个接口的实现，然后提供一个`GetPaymentMethod`方法，你可以将支付类型作为参数传递：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding lines define the interface of the payment method. They define a
    way of making a payment at the shop. The Factory method will return instances
    of types that implement this interface:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行定义了支付方法的接口。它们定义了在商店进行支付的方式。工厂方法将返回实现此接口的类型实例：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to define the identified payment methods of the Factory as constants
    so that we can call and check the possible payment methods from outside of the
    package.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将工厂识别的支付方法定义为常量，这样我们就可以从包外部调用和检查可能的支付方法。
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code is the function that will create the objects for us. It returns
    a pointer, which must have an object that implements the `PaymentMethod` interface,
    and an error if asked for a method which is not registered.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是用于为我们创建对象的函数。它返回一个指针，该指针必须有一个实现`PaymentMethod`接口的对象，如果请求一个未注册的方法，则返回错误。
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To finish the declaration of the Factory, we create the two payment methods.
    As you can see, the `CashPM` and `DebitCardPM` structs implement the `PaymentMethod`
    interface by declaring a method, `Pay(amount float32) string`. The returned string
    will contain information about the payment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成工厂的声明，我们创建了两种支付方法。正如你所见，`CashPM`和`DebitCardPM`结构体通过声明一个方法`Pay(amount float32)
    string`来实现`PaymentMethod`接口。返回的字符串将包含有关支付的信息。
- en: 'With this declaration, we will start by writing the tests for the first acceptance
    criteria: to have a common method to retrieve objects that implement the `PaymentMethod`
    interface:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个声明，我们将开始编写第一个验收标准的测试：有一个公共方法来检索实现`PaymentMethod`接口的对象：
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we'll have to separate the tests among a few of the test functions. `GetPaymentMethod`
    is a common method to retrieve methods of payment. We use the constant `Cash`,
    which we have defined in the implementation file (if we were using this constant
    outside for the scope of the package, we would call it using the name of the package
    as the prefix, so the syntax would be `creational.Cash`). We also check that we
    have not received an error when asking for a payment method. Observe that if we
    receive the error when asking for a payment method, we call `t.Fatal` to stop
    the execution of the tests; if we called just `t.Error` like in the previous tests,
    we would have a problem in the next lines when trying to access the `Pay` method
    of a nil object, and our tests would crash execution. We continue by using the
    `Pay` method of the interface by passing 10.30 as the amount. The returned message
    will have to contain the text `paid using cash`. The `t.Log(string)` method is
    a special method in testing. This struct allows us to write some logs when we
    run the tests if we pass the `-v` flag.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将测试分散到几个测试函数中。`GetPaymentMethod`是一个用于检索支付方法的标准方法。我们使用在实现文件中定义的常量`Cash`（如果我们在这个包的作用域外使用这个常量，我们会用包的名字作为前缀来调用它，所以语法会是`creational.Cash`）。我们还检查在请求支付方法时是否收到了错误。注意，如果我们请求支付方法时收到错误，我们会调用`t.Fatal`来停止测试的执行；如果我们像之前的测试一样只调用`t.Error`，那么在尝试访问空对象的`Pay`方法时，我们会在下一行遇到问题，并且我们的测试会崩溃执行。我们继续使用接口的`Pay`方法，通过传递10.30作为金额。返回的消息必须包含文本`paid
    using cash`。`t.Log(string)`方法是测试中的一个特殊方法。这个结构体允许我们在运行测试时通过传递`-v`标志来写入一些日志。
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We repeat the same operation with the debit card method. We ask for the payment
    method defined with the constant `DebitCard,` and the returned message, when paying
    with debit card, must contain the `paid using debit card` string.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用借记卡方法重复相同的操作。我们请求用常量`DebitCard`定义的支付方法，当使用借记卡支付时，返回的消息必须包含`paid using debit
    card`字符串。
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, we are going to test the situation when we request a payment method
    that doesn´t exist (represented by the number 20, which doesn't match any recognized
    constant in the Factory). We will check if an error message (any) is returned
    when asking for an unknown payment method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将测试请求一个不存在的支付方法的情况（用数字20表示，它不匹配工厂中识别的任何常量）。我们将检查在请求未知支付方法时是否返回了错误消息。
- en: 'Let''s check whether all tests are failing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查是否所有测试都失败了：
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in this example, we can only see tests that return the `PaymentMethod`
    interfaces failing. In this case, we'll have to implement just a part of the code,
    and then test again before continuing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个示例中可以看到的，我们只能看到返回`PaymentMethod`接口失败的测试。在这种情况下，我们只需实现代码的一部分，然后在继续之前再次进行测试。
