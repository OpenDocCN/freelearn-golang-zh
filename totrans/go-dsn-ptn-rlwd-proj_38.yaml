- en: Chapter 11. Deploying Go Applications Using Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。使用Docker部署Go应用程序
- en: Docker is an open source ecosystem (technology and range of associated services)
    that allows you to package applications into containers that are simple, lightweight,
    and portable; they will run in the same way regardless of which environment they
    run on. This is useful when you consider that our development environment (perhaps
    a Mac) is different from a production environment (such as a Linux server or even
    a cloud service) and that there is a large number of different places that we
    might want to deploy the same application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个开源生态系统（技术和一系列相关服务），它允许您将应用程序打包到简单、轻量级且可移植的容器中；它们将在任何环境中以相同的方式运行。考虑到我们的开发环境（可能是一个Mac）与生产环境（如Linux服务器甚至云服务）不同，以及我们可能希望部署相同应用程序的大量不同位置，这非常有用。
- en: Most cloud platforms already support Docker, which makes it a great option to
    deploy our apps into the wild.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云平台已经支持Docker，这使得它成为将我们的应用程序部署到野外的绝佳选择。
- en: In [Chapter 9](part0201_split_000.html#5VM122-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 9.  Building a Q&A Application for Google App Engine"), *Building a Q&A
    Application for Google App Engine*, we built an application for Google App Engine.
    We would need to make significant changes to our code if we decided that we wanted
    to run our application on a different platform even if we forget about our use
    of Google Cloud Datastore. Building applications with a mind to deploying them
    within Docker containers gives us an additional level of flexibility.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0201_split_000.html#5VM122-9c484ed022e64a0fb0e1aebf8e05d4fd "第9章。为Google
    App Engine构建问答应用程序"), *为Google App Engine构建问答应用程序*中，我们构建了一个适用于Google App Engine的应用程序。如果我们决定在另一个平台上运行我们的应用程序，即使忘记了我们对Google
    Cloud Datastore的使用，我们也需要对我们的代码进行重大修改。以在Docker容器内部署应用程序为目的构建应用程序，为我们提供了额外的灵活性。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Did you know that Docker itself was written in Go? See for yourself by browsing
    the source code at [https://github.com/docker/docker](https://github.com/docker/docker).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道Docker本身是用Go编写的吗？通过浏览[https://github.com/docker/docker](https://github.com/docker/docker)的源代码来亲自看看吧。
- en: 'In this chapter, you will learn:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: How to write a simple Dockerfile to describe an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写简单的Dockerfile来描述应用程序
- en: How to use the `docker` command to build the container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`docker`命令构建容器
- en: How to run Docker containers locally and terminate them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在本地运行Docker容器并终止它们
- en: How to deploy Docker containers to Digital Ocean
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Docker容器部署到Digital Ocean
- en: How to use the features in Digital Ocean to spin up instances that already have
    Docker preconfigured
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Digital Ocean中的功能启动已预配置Docker的实例
- en: We are going to put the Vault service we created in [Chapter 10](part0213_split_000.html#6B47Q1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10.  Micro-services in Go with the Go kit Framework"), *Micro-services
    in Go with the Go kit Framework*, into a Docker image and deploy it to the cloud.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把在[第10章](part0213_split_000.html#6B47Q1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第10章。使用Go kit框架的Go微服务") *使用Go kit框架的Go微服务* 中创建的Vault服务放入Docker镜像，并将其部署到云中。
- en: Using Docker locally
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地使用Docker
- en: Before we can deploy our code to the cloud, we must use the Docker tools on
    our development machine to build and push the image to Docker Hub.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将代码部署到云之前，我们必须使用开发机器上的Docker工具构建并推送镜像到Docker Hub。
- en: Installing Docker tools
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Docker工具
- en: In order to build and run containers, you need to install Docker on your development
    machine. Head over to [https://www.docker.com/products/docker](https://www.docker.com/products/docker)
    and download the appropriate installer for your computer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和运行容器，您需要在您的开发机器上安装Docker。请访问[https://www.docker.com/products/docker](https://www.docker.com/products/docker)并下载适合您电脑的相应安装程序。
- en: Docker and its ecosystem are evolving rapidly, so it is a good idea to make
    sure you're up to date with the latest release. Similarly, it is possible that
    some details will change in this chapter; if you get stuck, visit the project
    home page at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    for some helpful tips.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Docker及其生态系统正在快速发展，因此确保您与最新版本保持同步是个好主意。同样，本章中的一些细节可能会发生变化；如果您遇到困难，请访问项目主页[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)以获取一些有用的提示。
- en: Dockerfile
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile
- en: 'A Docker image is like a mini virtual machine. It contains everything that''s
    needed to run an application: the operating system the code will run on, any dependencies
    that our code might have (such as Go kit in the case of our Vault service), and
    the binaries of our application itself.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像就像一个迷你虚拟机。它包含运行应用程序所需的一切：代码将运行的操作系统，我们代码可能需要的任何依赖项（例如，在我们的Vault服务中是Go
    kit），以及我们应用程序本身的二进制文件。
- en: An image is described with `Dockerfile`; a text file containing a list of special
    commands that instruct Docker how to build the image. They are usually based on
    another container, which saves you from building up everything that might be needed
    in order to build and run Go applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个镜像是通过`Dockerfile`描述的；一个包含一系列特殊命令的文本文件，这些命令指导Docker如何构建镜像。它们通常基于另一个容器，这样可以节省您构建和运行Go应用程序所需的一切。
- en: 'Inside the `vault` folder from the code we wrote in [Chapter 10](part0213_split_000.html#6B47Q1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10.  Micro-services in Go with the Go kit Framework"), *Micro-services
    in Go with the Go kit Framework*, add a file called `Dockerfile` (note that this
    filename has no extension), containing the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中[第10章](part0213_split_000.html#6B47Q1-9c484ed022e64a0fb0e1aebf8e05d4fd "第10章。使用Go
    kit框架的Go微服务")的`vault`文件夹内，添加一个名为`Dockerfile`的文件（注意，此文件名没有扩展名），包含以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each line in a  `Dockerfile` file represents a different command that is run
    while the image is being built. The following table describes each of the commands
    we have used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`文件中的每一行代表在构建镜像时运行的不同命令。以下表格描述了我们使用的每个命令：'
- en: '| **Command** | **Description** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **Command** | **描述** |'
- en: '| `FROM` | The name of the image that this image will be based on. Single words,
    such as scratch, represent official Docker images hosted on Docker Hub. For more
    information on the scratch image, refer to `https://hub.docker.com/_/scratch/`.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `FROM` | 此镜像将基于的镜像名称。单词，如scratch，代表托管在Docker Hub上的官方Docker镜像。有关关于scratch镜像的更多信息，请参阅`https://hub.docker.com/_/scratch/`。|'
- en: '| `ADD` | Copies files into the container. We are copying our `vaultd` binary
    and calling it `vaultd`. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `ADD` | 将文件复制到容器中。我们正在复制我们的`vaultd`二进制文件，并将其命名为`vaultd`。|'
- en: '| `EXPOSE` | Exposes the list of ports; in our case, the Vault service binds
    to `:8080` and `:8081`. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE` | 公开端口号列表；在我们的案例中，Vault服务绑定到`:8080`和`:8081`。|'
- en: '| `ENTRYPOINT` | The binary to run when the container is executed in our case,
    the `vaultd` binary, which will be put there by the previous call to go install.
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT` | 当容器在我们的情况下执行时运行的二进制文件，即`vaultd`二进制文件，它将由之前的go install调用放置在那里。|'
- en: '| `MAINTAINER` | Name and email of the person responsible for maintaining the
    Docker image. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `MAINTAINER` | 维护Docker镜像的人的姓名和电子邮件地址。|'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete list of the supported commands, consult the online Docker documentation
    at [https://docs.docker.com/engine/reference/builder/#dockerfile-reference](https://docs.docker.com/engine/reference/builder/#dockerfile-reference).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取支持的命令的完整列表，请查阅在线Docker文档：[https://docs.docker.com/engine/reference/builder/#dockerfile-reference](https://docs.docker.com/engine/reference/builder/#dockerfile-reference)。
- en: Building Go binaries for different architectures
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为不同架构构建Go二进制文件
- en: Go supports cross-complication, a mechanism by which we can build a binary on
    one machine (say, our Mac) targeted for a different operating system (such as
    Linux or Windows) and architecture. Docker containers are Linux-based; so, in
    order to deliver a binary that can run in that environment, we must first build
    one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持交叉编译，这是一种机制，我们可以在一台机器（比如我们的Mac）上为目标操作系统（如Linux或Windows）和架构构建二进制文件。Docker容器是基于Linux的；因此，为了提供一个可以在该环境中运行的二进制文件，我们必须首先构建一个。
- en: 'In a terminal, navigate to the vault folder and run the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到vault文件夹并运行以下命令：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are essentially calling go build here but with a few extra bits and pieces
    to control the build process. `CGO_ENABLED` and `GOOS` are environment variables
    that go build will pay attention to, `-a` is a flag, and `./cmd/vaultd/` is the
    location of the command we want to build (in our case, the `vaultd` command we
    built in the previous chapter).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实际上是在调用go build，但增加了一些额外的部分来控制构建过程。`CGO_ENABLED`和`GOOS`是go build会注意到的环境变量，`-a`是一个标志，`./cmd/vaultd/`是我们想要构建的命令的位置（在我们的案例中，是我们在上一章中构建的`vaultd`命令）。
- en: The `CGO_ENABLED=0` indicates that we do not want cgo to be enabled. Since we
    are not binding to any C dependencies, we can reduce the size of our build by
    disabling this.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGO_ENABLED=0`表示我们不希望启用cgo。由于我们没有绑定任何C依赖项，我们可以通过禁用此功能来减小构建的大小。'
- en: '`GOOS` is short for Go Operating System and lets us specify which OS we are
    targeting, in our case, Linux. For a complete list of the available options, you
    can look directly in the Go source code by visiting [https://github.com/golang/go/blob/master/src/go/build/syslist.go](https://github.com/golang/go/blob/master/src/go/build/syslist.go).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOOS`是Go操作系统的缩写，允许我们指定我们正在针对哪个操作系统，在我们的例子中，是Linux。要查看完整的选项列表，可以直接访问Go源代码，通过访问[https://github.com/golang/go/blob/master/src/go/build/syslist.go](https://github.com/golang/go/blob/master/src/go/build/syslist.go)。'
- en: After a short while, you'll notice that a new binary has appeared, called `vaultd`.
    If you're on a non-Linux machine, you won't be able to directly execute this but
    don't worry; it'll run inside our Docker container just fine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，你会注意到出现了一个新的二进制文件，名为`vaultd`。如果你使用的是非Linux机器，你将无法直接执行这个文件，但不用担心；它将在我们的Docker容器中正常运行。
- en: Building a Docker image
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: 'To build the image, in a terminal, navigate to `Dockerfile` and run the following
    command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，在终端中导航到`Dockerfile`并运行以下命令：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are using the `docker` command to build the image. The final dot indicates
    that we want to build Dockerfile from the current directory. The `-t` flag specifies
    that we want to give our image the name of `vaultd`. This will allow us to refer
    to it by name rather than a hash that Docker will assign to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`docker`命令来构建镜像。最后的点表示我们想要从当前目录构建Dockerfile。`-t`标志指定我们想要给我们的镜像命名为`vaultd`。这将允许我们通过名称而不是Docker分配给它的哈希值来引用它。
- en: 'If this is the first time you''ve used Docker, and in particular the `scratch`
    base image, then it will take some time to download the required dependencies
    from Docker Hub depending on your Internet connection. Once that''s finished,
    you will see output similar to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次使用Docker，特别是使用`scratch`基础镜像，那么根据你的网络连接，从Docker Hub下载所需的依赖项将需要一些时间。一旦完成，你将看到类似以下输出的内容：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For each command, a new image is created (you can see the intermediate containers
    being disposed of along the way) until we end up with the final image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个命令，都会创建一个新的镜像（你可以在过程中看到中间容器被销毁），直到我们得到最终的镜像。
- en: 'Since we are building our binary on our local machine and copying it into the
    container (with the `ADD` command), our Docker image ends up being only about
    7 MB: pretty small when you consider that it contains everything it needs to run
    our services.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本地机器上构建二进制文件并将其复制到容器中（使用`ADD`命令），我们的Docker镜像最终只有大约7 MB：考虑到它包含了运行服务所需的所有内容，这相当小。
- en: Running a Docker image locally
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地运行Docker镜像
- en: 'Now that our image is built, we can test it by running it with the following
    command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了镜像，我们可以通过以下命令来测试它：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `docker run` command will spin up an instance of the `vaultd` image.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令将启动`vaultd`镜像的一个实例。'
- en: The `-p` flags specify a pair of ports to be exposed, the first value is the
    host port and the second value (following the colon) is the port within the image.
    In our case, we are saying that we want port `8080` to be exposed onto port `6060`
    and port `8081` exposed via port `6061`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`标志指定了一对要公开的端口，第一个值是主机端口，第二个值（冒号之后）是镜像内的端口。在我们的例子中，我们表示我们想要将端口`8080`公开到端口`6060`，端口`8081`通过端口`6061`公开。'
- en: We are giving the running instance a name of `localtest` with the `--name` flag,
    which will help us to identify it when inspecting and stopping it. The `--rm`
    flag indicates that we want the image to be removed once we have stopped it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`--name`标志给运行实例命名为`localtest`，这将帮助我们识别它，当我们检查和停止它时。`--rm`标志表示我们希望在停止后删除镜像。
- en: 'If this is successful, you will notice that the Vault service has indeed begun
    because it is telling us the ports to which it is bound:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，你会注意到Vault服务确实已经开始，因为它在告诉我们它绑定到的端口：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: These are the internal ports; remember that we have mapped these to different
    external ports instead. This seems confusing but ends up being very powerful,
    since the person responsible for spinning up the instances of the service gets
    to decide which ports are right for their environment, and the Vault service itself
    doesn't have to worry about it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是内部端口；记住，我们已经将这些映射到不同的外部端口。这看起来可能有些混乱，但最终却非常强大，因为负责启动服务实例的人可以决定哪些端口适合他们的环境，而Vault服务本身则无需担心这一点。
- en: 'To see this running, open another terminal and use the `curl` command to access
    the JSON endpoint of our password hashing service:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个运行状态，打开另一个终端并使用`curl`命令访问我们的密码散列服务的JSON端点：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see something that resembles the output from the running service:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似运行服务输出的内容：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inspecting Docker processes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Docker进程
- en: 'To see what Docker instances are running, we can use the `docker ps` command.
    In the terminal, type the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看正在运行的Docker实例，我们可以使用`docker ps`命令。在终端中，输入以下内容：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You''ll get a text table outlining the following properties:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个文本表格，概述以下属性：
- en: '| **CONTAINER ID** | `0b5e35dca7cc` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **CONTAINER ID** | `0b5e35dca7cc` |'
- en: '| **IMAGE** | `vaultd` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **IMAGE** | `vaultd` |'
- en: '| **COMMAND** | `/bin/sh -c /go/bin/vaultd` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **COMMAND** | `/bin/sh -c /go/bin/vaultd` |'
- en: '| **CREATED** | `3 seconds ago` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **CREATED** | `3 seconds ago` |'
- en: '| **STATUS** | `Up 2 seconds` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **STATUS** | `Up 2 seconds` |'
- en: '| **PORTS** | `0.0.0.0:6060->8080/tcp, 0.0.0.0:6061->8081/tcp` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **PORTS** | `0.0.0.0:6060->8080/tcp, 0.0.0.0:6061->8081/tcp` |'
- en: '| **NAMES** | `localtest` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **NAMES** | `localtest` |'
- en: The details show you a high-level overview of the image we just started. Note
    that the **PORTS** sections shows you the mapping from external to internal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息显示了我们刚刚启动的镜像的高级概述。请注意，**PORTS**部分显示了外部到内部的映射。
- en: Stopping a Docker instance
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止Docker实例
- en: We are used to hitting *Ctrl + C* in the window running our code to stop it,
    but since it's running inside a container, that won't work. Instead, we need to
    use the `docker stop` command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于在运行代码的窗口中按*Ctrl + C*来停止它，但由于它是在容器中运行的，所以这不会起作用。相反，我们需要使用`docker stop`命令。
- en: 'Since we gave our instance the name `localtest`, we can use this to stop it
    by typing this in an available terminal window:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们给我们的实例命名为`localtest`，我们可以在一个可用的终端窗口中输入以下内容来停止它：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After a few moments, you'll notice that the terminal that was running the image
    has now returned to the prompt.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，你会注意到运行镜像的终端现在已经返回到提示符。
- en: Deploying Docker images
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Docker镜像
- en: Now that we have contained our Vault service inside a Docker container, we are
    going to do some useful things with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Vault服务封装在一个Docker容器中，我们将对它做一些有用的事情。
- en: The first thing we are going to do is push this to the Docker Hub so that other
    people may spin up their own instances or even build new images based on it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是将这个镜像推送到Docker Hub，这样其他人就可以启动自己的实例，甚至基于它构建新的镜像。
- en: Deploying to Docker Hub
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到Docker Hub
- en: Head over to Docker Hub at [https://hub.docker.com](https://hub.docker.com)
    and create an account by clicking on the **Log In** link in the top-right-hand
    corner and then clicking on **Create Account**. Of course, if you already have
    an account, just log in.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Docker Hub [https://hub.docker.com](https://hub.docker.com)，点击右上角的**登录**链接，然后点击**创建账户**来创建一个账户。当然，如果你已经有了账户，只需登录即可。
- en: 'Now in a terminal, you are going to authenticate with this account by running
    Docker''s `login` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端中，你将通过运行Docker的`login`命令来使用此账户进行认证：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you see an error such as `WARNING: Error loading config, permission denied`,
    then try the command again with the `sudo` command prefix. This goes for all of
    Docker commands from this point onwards, since we''re using a secured configuration.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你看到类似“WARNING: Error loading config, permission denied”的错误，那么请尝试使用带有`sudo`命令前缀的命令再次执行。这一点适用于从现在开始的所有Docker命令，因为我们正在使用一个受保护的配置。'
- en: Ensure that you replace `USERNAME` and `PASSWORD` with your actual username
    and password of the account you just created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`USERNAME`和`PASSWORD`替换为你刚刚创建的账户的实际用户名和密码。
- en: If successful, you'll see, **Login Succeeded**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，你将看到“**登录成功**”。
- en: Next, back in the web browser, click on **Create Repository** and create a new
    repository called  `vault`. The actual name for this image is going to be  `USERNAME/vault`,
    so we're going to need to rebuild the image locally to match this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，回到网页浏览器中，点击**创建仓库**并创建一个名为`vault`的新仓库。这个镜像的实际名称将是`USERNAME/vault`，因此我们需要在本地重新构建镜像以匹配这个名称。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that for public consumption, we are calling the image `vault` rather than `vaultd`.
    This is a deliberate difference so that we can make sure we are dealing with the
    right image, but this is also a better name for users anyway.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了公开使用，我们称镜像为`vault`而不是`vaultd`。这是一个故意的区别，以确保我们处理的是正确的镜像，但这对用户来说也是一个更好的名称。
- en: 'In a terminal, build the new repository with the correct name:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，使用正确的名称构建新的存储库：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will build the image again, this time with the appropriate name. To deploy
    the image to the Docker Hub, we use Docker''s `push` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次构建镜像，这次使用适当的名称。要将镜像部署到Docker Hub，我们使用Docker的`push`命令：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After some time, the image and its dependencies will be pushed to Docker Hub:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，镜像及其依赖项将被推送到Docker Hub：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now head over to the Docker Hub to see the details of your image, or look at
    an example at [https://hub.docker.com/r/matryer/vault/](https://hub.docker.com/r/matryer/vault/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到Docker Hub查看您镜像的详细信息，或者查看[https://hub.docker.com/r/matryer/vault/](https://hub.docker.com/r/matryer/vault/)的示例。
- en: Deploying to Digital Ocean
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Digital Ocean
- en: Digital Ocean is a cloud service provider that offers competitive prices to
    host virtual machines. It makes deploying and serving Docker images very easy.
    In this section, we are going to deploy a droplet (Digital Ocean's terminology
    for a single machine) that runs our dockerized Vault service in the cloud.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Digital Ocean是一家提供具有竞争力的价格来托管虚拟机的云服务提供商。它使得部署和提供Docker镜像变得非常容易。在本节中，我们将部署一个droplet（Digital
    Ocean对单个机器的术语），在云中运行我们的docker化Vault服务。
- en: 'Specifically, following are the steps to deploy Docker images to Digital Ocean:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，以下是将Docker镜像部署到Digital Ocean的步骤：
- en: Create a droplet.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建droplet。
- en: Gain access to it via a web-based console.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过基于Web的控制台访问它。
- en: Pull our `USERNAME/vault` container.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取`USERNAME/vault`容器。
- en: Run the container.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行容器。
- en: Access our hosted Vault service remotely via the `curl` command.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`curl`命令远程访问我们的托管Vault服务。
- en: Digital Ocean is a **Platform as a Service** (**PaaS**) architecture, and as
    such, the user experience is likely to change from time to time, so the exact
    flow described here might not be entirely accurate by the time you come to perform
    these tasks. Usually, by looking around at the options, you will be able to figure
    out how to proceed, but screenshots have been included to help guide you.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Digital Ocean是一个**平台即服务**（**PaaS**）架构，因此用户体验可能会不时发生变化，所以这里描述的精确流程在您执行这些任务时可能并不完全准确。通常，通过查看选项，您将能够找出如何进行操作，但已经包括了截图以帮助您。
- en: This section also assumes that you have enabled any billing that might be required
    in order to create droplets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还假设您已启用创建droplets可能需要的任何计费。
- en: Creating a droplet
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建droplet
- en: Sign up or log in to Digital Ocean by visiting [https://www.digitalocean.com](https://www.digitalocean.com)
    in the browser. Ensure that you use a real e-mail address, as this is where they
    will send the root password for the droplet you are going to create.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览器访问[https://www.digitalocean.com](https://www.digitalocean.com)注册或登录到Digital
    Ocean。请确保您使用真实的电子邮件地址，因为这将是他们发送您创建的droplet的root密码的地方。
- en: 'If you have no other droplets, you will be presented with a blank screen. Click
    on **Create Droplet**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有其他droplets，您将看到一个空白屏幕。点击**创建Droplet**：
- en: '![Creating a droplet](img/00070.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![创建droplet](img/00070.jpeg)'
- en: Inside the **One-click apps** tab, look for the latest Docker option; at the
    time of writing this, it is **Docker 1.12.1 on 16.04**, which means Docker version
    1.12.1 is running on Ubuntu 16.04.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在**一键应用**标签页中，查找最新的Docker选项；在撰写本文时，它是**Docker 1.12.1 on 16.04**，这意味着Docker版本1.12.1正在Ubuntu
    16.04上运行。
- en: Scroll down the page to select the remaining options, including picking a size
    (the smallest size will do for now) and a location (pick the closest geographic
    location to you). We won't bother adding additional services (such as volumes,
    networking, or backups) for now just proceed with the simple droplet.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动页面选择剩余的选项，包括选择大小（目前最小的尺寸即可）和位置（选择离您最近的地理位置）。现在我们不会添加额外的服务（如卷、网络或备份），只需进行简单的droplet。
- en: 'It might be a nice idea to give your droplet a meaningful hostname so that
    it''s easy to find later, something like `vault-service-1` or similar; it doesn''t
    really matter for now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 给您的droplet起一个有意义的名称可能是个好主意，这样以后就更容易找到，比如`vault-service-1`或类似名称；现在这并不重要：
- en: '![Creating a droplet](img/00071.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![创建droplet](img/00071.jpeg)'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can optionally add SSH keys for additional security, but for simplicity's
    sake, we are going to continue without it. For production, it is recommended that
    you always do this.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择添加SSH密钥以增加额外的安全性，但为了简单起见，我们将继续不添加它。对于生产环境，建议你始终这样做。
- en: 'At the bottom of the page, click on **Create**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面底部，点击**创建**：
- en: '![Creating a droplet](img/00072.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![创建droplet](img/00072.jpeg)'
- en: Accessing the droplet's console
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问droplet的控制台
- en: Once your droplet has been created, select it from the **Droplets** list and
    look for the **Console** option (it may be written as `Access console`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的droplet创建完成，从**Droplets**列表中选择它，并查找**控制台**选项（它可能被写成`Access console`）。
- en: 'After a few moments, you will be presented with a web-based terminal. This
    is how we will control the droplet, but first, we must log in:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，你将看到一个基于Web的终端。这就是我们将如何控制droplet，但首先，我们必须登录：
- en: '![Accessing the droplet''s console](img/00073.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![访问droplet的控制台](img/00073.jpeg)'
- en: Enter the login username as `root`, and check your e-mail for the root password
    that Digital Ocean has sent you. At the time of writing this, you cannot copy
    and paste this, so be ready to carefully type out a long string as accurately
    as you can.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输入登录用户名为`root`，并检查你的电子邮件以获取Digital Ocean发送给你的root密码。在撰写本文时，你不能复制粘贴，所以请准备好尽可能准确地输入一个长字符串。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The password might well be a lowercase hexadecimal string, which will help you
    know which characters are likely to appear. For example, everything that looks
    like an *O* is probably *zero*, and *1* is unlikely to be an *I* or *L*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 密码可能是一个小写十六进制字符串，这将帮助你了解哪些字符可能出现。例如，所有看起来像*O*的字符可能都是*零*，而*1*不太可能是*I*或*L*。
- en: Once you've logged in for the first time, you'll be asked to change your password
    which involves typing the long generated password again! Security can be so inconvenient
    at times.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次登录后，你将被要求更改密码，这需要再次输入生成的长密码！有时安全性会如此不方便。
- en: Pulling Docker images
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取Docker镜像
- en: Since we selected the Docker app as a starting point for our droplet, Digital
    Ocean has kindly configured Docker to already be running inside our instance,
    so we can just use the `docker` command to finish setting things up.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们选择了Docker应用作为我们的droplet的起点，Digital Ocean已经友好地配置了Docker，使其已经在我们的实例中运行，因此我们可以直接使用`docker`命令来完成设置。
- en: 'In the web-based terminal, pull your container with the following command,
    remembering to replace `USERNAME` with your Docker Hub username:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Web的终端中，使用以下命令拉取你的容器，记得将`USERNAME`替换为你的Docker Hub用户名：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If, for whatever reason, this isn''t working for you, you can try using the
    Docker image placed there by the author by typing this:  `docker pull matryer/vault`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因，这对你不起作用，你可以尝试使用作者放置在那里的Docker镜像，通过输入以下命令：`docker pull matryer/vault`
- en: 'Docker will go and pull down everything it needs in order to run the image
    we created earlier:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将会去拉取它运行我们之前创建的镜像所需的所有内容：
- en: '![Pulling Docker images](img/00074.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![拉取Docker镜像](img/00074.jpeg)'
- en: Running Docker images in the cloud
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在云中运行Docker镜像
- en: 'Once the image and its dependencies have successfully downloaded, we will be
    able to run it using a the `docker run` command, this time with the `-d` flag
    to specify that we want it to run as a background daemon. In the web-based terminal,
    type the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像及其依赖项成功下载，我们就可以使用`docker run`命令来运行它，这次使用`-d`标志来指定我们希望它作为后台守护进程运行。在基于Web的终端中，输入以下命令：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is similar to the command we ran earlier, except that this time, we are
    giving it the name vault, and we have omitted the `--rm` flag, since it is not
    compatible (and doesn't make sense) with the background daemon mode.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前我们运行的命令类似，但这次我们给它命名为vault，并且省略了`--rm`标志，因为它与后台守护进程模式不兼容（并且没有意义）。
- en: The Docker image containing our Vault service will start running and is now
    ready to test.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 包含我们的Vault服务的Docker镜像将开始运行，现在已准备好测试。
- en: Accessing Docker images in the cloud
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问云中的Docker镜像
- en: Now that our Docker image is running in our droplet within Digital Ocean's platform,
    we can start using it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的Docker镜像已经在Digital Ocean平台上运行的droplet中运行，我们可以开始使用它了。
- en: In the Digital Ocean web control panel, select **Droplets** and look for the
    one we just created. We need to know the IP address so that we can access the
    services remotely. Once you have located the IP address of the droplet, click
    on it to copy it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Digital Ocean的Web控制面板中，选择**Droplets**并查找我们刚刚创建的那个。我们需要知道IP地址，以便我们可以远程访问服务。一旦你找到了droplet的IP地址，点击它以复制它。
- en: 'Open a local terminal on your computer (do not use the web-based terminal)
    and use the `curl` command (or equivalent) to make the following request:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的电脑上打开本地终端（不要使用基于网页的终端）并使用 `curl` 命令（或等效命令）执行以下请求：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember to replace `IPADDRESS` with the actual IP address you copied from Digital
    Ocean's web control panel.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将 `IPADDRESS` 替换为你从 Digital Ocean 的网页控制面板中复制的实际 IP 地址。
- en: 'You will notice that you have successfully managed to access the JSON/HTTP
    endpoint of our Vault service when you get a response similar to the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到以下类似响应时，你会注意到你已经成功管理访问了我们的 Vault 服务的 JSON/HTTP 端点：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See whether you can modify the `curl` command to validate the hash that was
    provided using the `/validate` endpoint.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以修改 `curl` 命令，使用 `/validate` 端点验证提供的哈希值。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built and deployed our Vault Go application using Docker
    to Digital Ocean's cloud.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Docker 在 Digital Ocean 的云平台上构建和部署了 Vault Go 应用程序。
- en: After installing the Docker tools, we saw how easy it was to package up our
    Go application into a Docker image and push it to Docker Hub. We created our Digital
    Ocean droplet using the helpful Docker app that they provide and controlled it
    via a web-based console. Once inside, we were able to pull our Docker image from
    the Docker Hub and run it inside our droplet.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Docker 工具后，我们看到了如何轻松地将我们的 Go 应用程序打包成 Docker 镜像并推送到 Docker Hub。我们使用他们提供的有用的
    Docker 应用程序创建了 Digital Ocean 的 Droplet，并通过基于网页的控制台进行控制。一旦进入，我们就能从 Docker Hub 拉取我们的
    Docker 镜像并在 Droplet 中运行它。
- en: Using the public IP of the droplet, we were then able to remotely access the
    Vault service's JSON/HTTP endpoint to hash and validate passwords.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Droplet 的公网 IP，我们能够远程访问 Vault 服务器的 JSON/HTTP 端点以哈希和验证密码。
- en: Appendix Appendix. Good Practices for a Stable Go Environment
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 附录。稳定 Go 环境的良好实践
- en: Writing Go code is a fun and enjoyable experience, where compile-time errors
    rather than being a pain actually guide you to write robust, high-quality code.
    However, every now and then, you will encounter environmental issues that start
    to get in the way and break your flow. While you can usually resolve these issues
    after some searching and a little tweaking, setting up your development environment
    correctly goes a long way in reducing problems, allowing you to focus on building
    useful applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Go 代码是一种有趣且愉快的体验，编译时错误不再是痛苦，而是引导你编写健壮、高质量的代码。然而，时不时地，你将遇到一些环境问题，这些问题开始妨碍你的工作流程。虽然你通常可以通过一些搜索和微调来解决这些问题，但正确设置你的开发环境在很大程度上可以减少问题，让你能够专注于构建有用的应用程序。
- en: In this chapter, we are going to install Go from scratch on a new machine and
    discuss some of the environmental options we have and the impact they might have
    in the future. We will also consider how collaboration might influence some of
    our decisions as well as what impact open sourcing our packages might have.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始在新的机器上安装 Go，并讨论我们的一些环境选项及其可能对未来产生的影响。我们还将考虑协作如何影响我们的决策，以及开源我们的包可能产生的影响。
- en: 'Specifically, we are going to:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将：
- en: Install Go on your development machine
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的开发机上安装 Go
- en: Learn what the `GOPATH` environment variable is for and discuss a sensible approach
    for its use
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `GOPATH` 环境变量的用途，并讨论其合理的使用方法
- en: Learn about the Go tools and how to use them to keep the quality of our code
    high
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Go 工具及其使用方法，以保持我们代码的高质量
- en: Learn how to use a tool to automatically manage our imports
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用工具自动管理我们的导入
- en: Think about on *save* operations for our `.go` files and how we can integrate
    the Go tools as part of our daily development
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到我们的 `.go` 文件的 *保存* 操作，以及我们如何将 Go 工具集成到日常开发中
- en: Look at some popular code editor options to write Go code
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看一些流行的代码编辑器选项来编写 Go 代码
- en: Installing Go
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Go
- en: The best way to install Go is to use one of the many installers available online
    at [https://golang.org/dl/](https://golang.org/dl/). Go to the Go website and
    click on **Download**, and then look for the latest 1.x version for your computer.
    The **Featured downloads** section at the top of the page contains links to the
    most popular versions, so yours will probably be in that list.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Go 的最佳方式是使用网络上可用的众多安装程序之一，请访问 [https://golang.org/dl/](https://golang.org/dl/)。访问
    Go 网站，点击 **下载**，然后查找适合你电脑的最新 1.x 版本。页面顶部的 **特色下载** 部分包含指向最受欢迎版本的链接，所以你的版本可能就在这个列表中。
- en: The code in this book has been tested with Go 1.7, but any 1.x release will
    work. For future versions of Go (2.0 and higher), you may need to tweak the code
    as major version releases may well contain breaking changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码已经使用 Go 1.7 进行了测试，但任何 1.x 版本都将工作。对于 Go 的未来版本（2.0 及更高版本），你可能需要调整代码，因为主要版本发布可能包含破坏性更改。
- en: Configuring Go
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Go
- en: Go is now installed, but in order to use the tools, we must ensure that it is
    properly configured. To make calling the tools easier, we need to add our `go/bin`
    path to the `PATH` environment variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Go 现已安装，但为了使用工具，我们必须确保它已正确配置。为了使调用工具更简单，我们需要将我们的 `go/bin` 路径添加到 `PATH` 环境变量中。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Unix systems, you should add export `PATH=$PATH:/opt/go/bin` (make sure it
    is the path you chose when installing Go) to your `.bashrc` file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统上，你应该将 `export PATH=$PATH:/opt/go/bin`（确保它是你安装 Go 时选择的路径）添加到你的 `.bashrc`
    文件中。
- en: On Windows, open **System Properties** (try right-clicking on **My Computer**),
    and under **Advanced**, click on the **Environment Variables** button and use
    the UI to ensure that the `PATH` variable contains the path to your `go/bin` folder.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，打开 **系统属性**（尝试右键单击 **我的电脑**），然后在 **高级** 选项卡中点击 **环境变量** 按钮，并使用 UI
    确保路径变量包含你的 `go/bin` 文件夹路径。
- en: 'In a terminal (you may need to restart it for your changes to take effect),
    you can make sure this worked by printing the value of the `PATH` variable:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中（你可能需要重启终端以使更改生效），你可以通过打印 `PATH` 变量的值来确保这已经生效：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ensure that the value printed contains the correct path to your `go/bin` folder;
    for example, on my machine it prints as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保打印的值包含正确的 `go/bin` 文件夹路径；例如，在我的机器上它打印如下：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The colons (semicolons on Windows) between the paths indicate that the `PATH`
    variable is actually a list of folders rather than just one folder. This indicates
    that each folder included will be searched when you enter commands in your terminal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 路径之间的冒号（在 Windows 上是分号）表示 `PATH` 变量实际上是一个文件夹列表，而不仅仅是一个文件夹。这表明当你输入终端中的命令时，将搜索每个包含的文件夹。
- en: 'Now we can make sure the Go build we just made runs successfully:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以确保我们刚刚创建的 Go 构建可以成功运行：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Executing the `go` command (which can be found in your `go/bin` location) like
    this will print out the current version for us. For example, for Go 1.77.1, you
    should see something similar to the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式执行 `go` 命令（可以在你的 `go/bin` 位置找到）将为我们打印出当前版本。例如，对于 Go 1.77.1，你应该看到以下类似的内容：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Getting GOPATH right
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确设置 GOPATH
- en: '`GOPATH` is another environment variable to a folder (such as `PATH` in the
    previous section) that is used to specify the location for the Go source code
    and the compiled binary packages. Using the `import` command in your Go programs
    will cause the compiler to look in the `GOPATH` location to find the packages
    you are referring to. When using `go get` and other commands, projects are downloaded
    into the `GOPATH` folder.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPATH` 是另一个指向文件夹的环境变量（如上一节中的 `PATH`），用于指定 Go 源代码和编译的二进制包的位置。在你的 Go 程序中使用
    `import` 命令会导致编译器在 `GOPATH` 位置查找你引用的包。当使用 `go get` 和其他命令时，项目会被下载到 `GOPATH` 文件夹中。'
- en: While the `GOPATH` location can contain a list of colon-separated folders, such
    as `PATH` and you can even have a different value for `GOPATH` depending on which
    project you are working in it is strongly recommended that you use a single `GOPATH`
    location for everything, and this is what we will assume you will do for the projects
    in this book.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `GOPATH` 位置可以包含一系列由冒号分隔的文件夹，例如 `PATH`，并且你可以根据你正在工作的项目为 `GOPATH` 设置不同的值，但强烈建议你为所有内容使用单个
    `GOPATH` 位置，这是我们假设你在本书的项目中会这样做。
- en: 'Create a new folder called `go`, this time in your `Users` folder somewhere
    perhaps in a `Work` subfolder. This will be our `GOPATH` target and is where all
    the third-party code and binaries will end up as well as where we will write our
    Go programs and packages. Using the same technique you used when setting the `PATH`
    environment variable in the previous section, set the `GOPATH` variable to the
    new `go` folder. Let''s open a terminal and use one of the newly installed commands
    to get a third-party package for us to use:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `go` 的新文件夹，这次在 `Users` 文件夹中，可能在 `Work` 子文件夹中。这将是我们 `GOPATH` 的目标，所有第三方代码和二进制文件都将在这里结束，我们也将在这里编写我们的
    Go 程序和包。使用你在上一节中设置 `PATH` 环境变量时使用的相同技术，将 `GOPATH` 变量设置为新的 `go` 文件夹。让我们打开一个终端并使用新安装的命令之一为我们获取第三方包：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Getting the `silk` library will actually cause this folder structure to be
    created: `$GOPATH/src/github.com/matryer/silk`. You can see that the path segments
    are important in how Go organizes things, which helps namespace projects and keeps
    them unique. For example, if you created your own package called `silk`, you wouldn''t
    keep it in the GitHub repository of `matryer`, so the path would be different.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `silk` 库实际上会导致创建以下文件夹结构：`$GOPATH/src/github.com/matryer/silk`。你可以看到路径段在 Go
    组织事物的方式中非常重要，这有助于命名空间项目并保持它们的独特性。例如，如果你创建了一个名为 `silk` 的自己的包，你不会将其保存在 `matryer`
    的 GitHub 仓库中，所以路径就会不同。
- en: When we create projects in this book, you should consider a sensible `GOPATH`
    root for them. For example, I used `github.com/matryer/goblueprints`, and if you
    were to go get that, you would actually get a complete copy of all the source
    code for this book in your `GOPATH` folder!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本书中创建项目时，你应该考虑一个合理的 `GOPATH` 根目录。例如，我使用了 `github.com/matryer/goblueprints`，如果你去获取它，你实际上会在你的
    `GOPATH` 文件夹中获得这本书所有源代码的完整副本！
- en: Go tools
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 工具
- en: An early decision made by the Go core team was that all Go code should look
    familiar and obvious to everybody who speaks Go rather than each code base requiring
    additional learning in order for new programmers to understand it or work on it.
    This is an especially sensible approach when you consider open source projects,
    some of which have hundreds of contributors coming and going all the time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Go 核心团队早期做出的一个决定是，所有 Go 代码都应该对说 Go 语的每个人来说都熟悉且明显，而不是每个代码库都需要额外的学习才能让新程序员理解它或对其进行工作。当你考虑到开源项目时，这是一个特别合理的做法，其中一些项目有数百名贡献者来来去去。
- en: There is a range of tools that can assist us in achieving the high standards
    set by the Go core team, and we will look at some of the tools in action in this
    section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助我们达到 Go 核心团队设定的高标准，我们将在本节中查看一些工具的实际应用。
- en: 'In your `GOPATH` location, create a new folder called `tooling` and create
    a new `main.go` file containing the following code verbatim:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `GOPATH` 位置，创建一个名为 `tooling` 的新文件夹，并创建一个包含以下代码的新 `main.go` 文件：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The tight spaces and lack of indentation are deliberate as we are going to look
    at a very cool utility that comes with Go.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑的空间和缺乏缩进是有意为之的，因为我们将要查看 Go 附带的一个非常酷的实用工具。
- en: 'In a terminal, navigate to your new folder and run this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到你的新文件夹并运行以下命令：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'At Gophercon 2014 in Denver, Colorado, most people learned that rather than
    pronouncing this little triad as *format* or *f, m, t*, it is actually pronounced
    as a word. Try saying it to yourself now: *fhumt*; it seems that computer programmers
    aren''t weird enough without speaking an alien language to each other too!'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2014 年科罗拉多州丹佛的 Gophercon 大会上，大多数人了解到，与其将这个小三元组读作 *format* 或 *f, m, t*，实际上它是作为一个单词来发音的。现在试着对自己说：*fhumt*；看来，计算机程序员们如果不互相说一种外星语就已经够奇怪的了！
- en: 'You will notice that this little tool has actually tweaked our code file to
    ensure that the layout (or format) of our program matches Go standards. The new
    version is much easier to read:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个小小的工具实际上调整了我们的代码文件，以确保我们的程序布局（或格式）符合 Go 标准。新版本更容易阅读：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `go fmt` command cares about indentation, code blocks, unnecessary whitespace,
    unnecessary extra line feeds, and more. Formatting your code in this way is a
    great practice to ensure that your Go code looks like all other Go code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`go fmt` 命令关注缩进、代码块、不必要的空白、不必要的额外换行符等等。以这种方式格式化你的代码是一种很好的实践，以确保你的 Go 代码看起来像其他所有
    Go 代码。'
- en: 'Next, we are going to vet our program to make sure that we haven''t made any
    mistakes or decisions that might be confusing to our users; we can do this automatically
    with another great tool that we get for free:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将审查我们的程序，以确保我们没有犯任何错误或可能让用户感到困惑的决定；我们可以使用另一个免费获得的神器来自动完成这项工作：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output for our little program points out an obvious and glaring mistake:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小程序输出显示了一个明显且令人瞩目的错误：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are calling `return` at the top of our function and then trying to do other
    things. The `go vet` tool has noticed this and points out that we have unreachable
    code in our file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数顶部调用 `return`，然后尝试做其他事情。`go vet` 工具注意到了这一点，并指出我们在文件中有不可达的代码。
- en: It isn't just silly mistakes like this that `go vet` will catch; it will also
    look for subtler aspects of your program that will guide you toward writing the
    best Go code you can. For an up-to-date list of what the vet tool will report
    on, check out the documentation at [https://golang.org/cmd/vet/](https://golang.org/cmd/vet/).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`go vet`不仅能捕捉到这种愚蠢的错误，它还会寻找你程序中更微妙的问题，这些问题将指导你编写尽可能好的Go代码。要查看vet工具将报告的最新列表，请查看[https://golang.org/cmd/vet/](https://golang.org/cmd/vet/)上的文档。'
- en: 'The final tool we will play with is called `goimports`, and it was written
    by Brad Fitzpatrick to automatically fix (add or remove) `import` statements for
    Go files. It is an error in Go to import a package and not use it, and obviously,
    trying to use a package without importing it won''t work either. The `goimports`
    tool will automatically rewrite our `import` statement based on the contents of
    our code file. First, let''s install `goimports` with this familiar command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的最后一个工具叫做`goimports`，它是由Brad Fitzpatrick编写的，用于自动修复（添加或删除）Go文件的`import`语句。在Go中，导入一个包而不使用它是错误的，显然，尝试使用未导入的包也不会工作。`goimports`工具将根据我们的代码文件内容自动重写我们的`import`语句。首先，让我们使用这个熟悉的命令来安装`goimports`：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Update your program to import some packages that we are not going to use and
    remove the `fmt` package:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的程序，导入一些我们不会使用的包，并移除`fmt`包：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we try to run our program by calling `go run main.go`, we will see that
    we get some errors:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过调用`go run main.go`来尝试运行我们的程序时，我们会看到一些错误：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These errors tell us that we have imported packages that we are not using and
    missing the `fmt` package and that in order to continue, we need to make corrections.
    This is where `goimports` comes in:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误告诉我们，我们导入了未使用的包，缺少了`fmt`包，并且为了继续，我们需要进行修正。这就是`goimports`发挥作用的地方：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are calling the `goimports` command with the `-w` write flag, which will
    save us the task of making corrections to all files ending with `.go`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用带有`-w`写入标志的`goimports`命令，这将节省我们修正所有以`.go`结尾的文件的麻烦。
- en: Have a look at your `main.go` file now, and note that the `net/http` and `sync`
    packages have been removed and the `fmt` package has been put back in.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看你的`main.go`文件，注意`net/http`和`sync`包已经被移除，而`fmt`包已经被放回。
- en: You could argue that switching to a terminal to run these commands takes more
    time than just doing it manually, and you would probably be right in most cases,
    which is why it is highly recommended that you integrate the Go tools with your
    text editor.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为切换到终端运行这些命令比手动操作花费的时间更多，在大多数情况下你可能是对的，这就是为什么强烈建议你将Go工具与你的文本编辑器集成。
- en: Cleaning up, building, and running tests on save
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理、构建和保存时运行测试
- en: 'Since the Go core team has provided us with such great tools as `fmt`, `vet`,
    `test`, and `goimports`, we are going to look at a development practice that has
    proven to be extremely useful. Whenever we save a `.go` file, we want to perform
    the following tasks automatically:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go核心团队为我们提供了像`fmt`、`vet`、`test`和`goimports`这样出色的工具，我们将探讨一种已被证明极其有用的开发实践。每次我们保存`.go`文件时，我们都希望自动执行以下任务：
- en: Use `goimports` and `fmt` to fix our imports and format the code.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`goimports`和`fmt`修复我们的导入并格式化代码。
- en: Vet the code for any faux pas and tell us immediately.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查代码中的任何错误，并立即告诉我们。
- en: Attempt to build the current package and output any build errors.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试构建当前包并输出任何构建错误。
- en: If the build is successful, run the tests for the package and output any failures.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果构建成功，运行包的测试并输出任何失败。
- en: Because Go code compiles so quickly (Rob Pike once actually said that it doesn't
    build quickly, but it's just not slow like everything else), we can comfortably
    build entire packages every time we save a file. This is also true for running
    tests to help us if we are developing in a TDD style, and the experience is great.
    Every time we make changes to our code, we can immediately see whether we have
    broken something or had an unexpected impact on some other part of our project.
    We'll never see package import errors again because our `import` statement will
    have been fixed for us, and our code will be correctly formatted right in front
    of our eyes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go代码编译速度非常快（Rob Pike曾经实际上说过它并不快，但并不像其他所有东西那样慢），我们每次保存文件时都可以舒适地构建整个包。这也适用于运行测试以帮助我们进行TDD风格开发的情况，体验非常棒。每次我们对代码进行更改时，我们都可以立即看到是否破坏了某些内容，或者对我们的项目其他部分产生了意外影响。我们将不再看到包导入错误，因为我们的`import`语句已经为我们修正，而且我们的代码将直接在我们的眼前正确格式化。
- en: 'Some editors are likely to not support running code in response to specific
    events, such as saving a file, which leaves you with two options: you can either
    switch to a better editor, or you can write your own script file that runs in
    response to filesystem changes. The latter solution is out of the scope of this
    book; instead, we will focus on how to implement this functionality in a couple
    of popular editor codes.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编辑器可能不支持在特定事件（如保存文件）响应下运行代码，这给您留下了两个选择：您可以选择切换到更好的编辑器，或者您可以编写自己的脚本文件，该文件会在文件系统更改时运行。后者超出了本书的范围；相反，我们将专注于如何在几个流行的编辑器中实现此功能。
- en: Integrated developer environments
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: The **Integrated Developer Environments** (**IDEs**)  are essentially text editors
    with additional features that make writing code and building software easier.
    Text with special meaning, such as string literals, types, function names, and
    so on are often colored differently by syntax highlighting, or you may get autocomplete
    options as you're typing. Some editors even point out errors in your code before
    you've executed it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成开发环境**（**IDEs**）本质上是一些具有额外功能，使编写代码和构建软件更简单的文本编辑器。具有特殊意义的文本，如字符串字面量、类型、函数名等，通常通过语法高亮以不同的颜色显示，或者您在键入时可能会获得自动完成选项。一些编辑器甚至会在您执行代码之前指出代码中的错误。'
- en: There are many options to choose from, and mostly, it comes down to personal
    preference, but we will look at some of the more popular choices as well as how
    to set them up to build Go projects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可供选择，大多数情况下，这取决于个人喜好，但我们将探讨一些更受欢迎的选择以及如何设置它们以构建Go项目。
- en: 'The most popular editors include the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的编辑器包括以下几种：
- en: Sublime Text 3
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime Text 3
- en: Visual Studio Code
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Atom
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom
- en: Vim (with vim-go)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vim（带vim-go）
- en: You can see a complete curated list of options at [https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins)查看一个完整的精选选项列表。
- en: In this section, we are going to explore Sublime Text 3 and Visual Studio Code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Sublime Text 3和Visual Studio Code。
- en: Sublime Text 3
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sublime Text 3
- en: Sublime Text 3 is an excellent editor to write Go code that runs on OS X, Linux,
    and Windows and has an extremely powerful expansion model, which makes it easy
    to customize and extend. You can download Sublime Text from [http://www.sublimetext.com/](http://www.sublimetext.com/)
    and trial-use it for free before deciding whether you want to buy it or not.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Sublime Text 3是一个优秀的编辑器，可以用于编写在OS X、Linux和Windows上运行的Go代码，它拥有极其强大的扩展模型，这使得它易于定制和扩展。您可以从[http://www.sublimetext.com/](http://www.sublimetext.com/)下载Sublime
    Text，并在决定是否购买之前免费试用。
- en: Thanks to **DisposaBoy** (refer to [https://github.com/DisposaBoy](https://github.com/DisposaBoy)),
    there is already a Sublime expansion package for Go, which actually gives us a
    wealth of features and power that a lot of Go programmers actually miss out on.
    We are going to install this `GoSublime` package and then build upon it to add
    our desired on-save functionality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢**DisposaBoy**（请参阅[https://github.com/DisposaBoy](https://github.com/DisposaBoy)），已经有一个针对Go的Sublime扩展包，实际上为我们提供了许多Go程序员实际上错过的丰富功能和力量。我们将安装这个`GoSublime`包，然后在此基础上添加我们想要的保存功能。
- en: Before we can install `GoSublime`, we need to install Package Control into Sublime
    Text. Head over to [https://sublime.wbond.net/](https://sublime.wbond.net/) and
    click on the **Installation** link for instructions on how to install Package
    Control. At the time of writing this, it's simply a case of copying the single,
    albeit long, line command and pasting it into the Sublime console, which can be
    opened by navigating to **View** | **Show Console** from the menu.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够安装 `GoSublime` 之前，我们需要将 Package Control 安装到 Sublime Text 中。访问 [https://sublime.wbond.net/](https://sublime.wbond.net/)
    并点击 **安装** 链接，获取安装 Package Control 的说明。在撰写本文时，这只是一个复制单行命令（尽管很长）并将其粘贴到 Sublime
    控制台中的简单过程，控制台可以通过从菜单中选择 **视图** | **显示控制台** 来打开。
- en: 'Once this is complete, press *shift + command + P* and type `Package Control:
    Install Package` and press *return* when you have selected the option. After a
    short delay (where Package Control is updating its listings), a box will appear,
    allowing you to search for and install GoSublime just by typing it in, selecting
    it, and pressing *return*. If all is well, GoSublime will be installed and writing
    Go code will just become an order of magnitude easier.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '完成这些后，按 *shift + command + P* 并输入 `Package Control: Install Package`，当你选择了选项后按
    *return*。经过短暂的延迟（Package Control 正在更新其列表），将出现一个框，允许你通过输入、选择并按 *return* 来搜索和安装
    GoSublime。如果一切顺利，GoSublime 将被安装，编写 Go 代码将变得容易得多。'
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Now that you have GoSublime installed, you can open a short help file containing
    the details of the package by pressing *command + ., command + 2* (the command
    key and period at the same time, followed by the command key and number 2).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 GoSublime，你可以通过按 *command + ., command + 2*（同时按住命令键和点号，然后按住命令键和数字 2）来打开一个包含包详细信息的简短帮助文件。
- en: 'For some additional help while saving, press *command + ., command + 5* to
    open the GoSublime settings and add the following entry to the object:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存时需要一些额外帮助的话，请按 *command + ., command + 5* 打开 GoSublime 设置，并在对象中添加以下条目：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the settings file is actually a JSON object, so ensure that you add
    the `on_save` property without corrupting the file. For example, if you have properties
    before and after, ensure the appropriate commas are in place.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，设置文件实际上是一个 JSON 对象，所以确保你在不损坏文件的情况下添加 `on_save` 属性。例如，如果你在前后都有属性，确保适当的逗号已经放置好。
- en: The preceding setting will tell Sublime Text to build the code looking for errors,
    install test dependencies, run tests, and vet the code whenever we save the file.
    Save the settings file (don't close it just yet), and let's see this in action.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的设置将告诉 Sublime Text 在保存文件时查找代码错误、安装测试依赖项、运行测试和审查代码。保存设置文件（暂时不要关闭它），让我们看看这个功能是如何实际应用的。
- en: 'Navigate to **Choose File** | **Open...** from the menu and select a folder
    to open for now, let''s open our `tooling` folder. The simple user interface of
    Sublime Text makes it clear that we only have one file in our project right now:
    `main.go`. Click on the file and add some extra linefeeds, and add and remove
    some indenting. Then, navigate to **File** | **Save** from the menu, or press
    *command + S*. Note that the code is immediately cleaned up, and provided that
    you haven''t removed the oddly placed return statement from `main.go`, you will
    notice that the console has appeared and is reporting the issue thanks to go vet:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单中选择 **选择文件** | **打开...** 并选择一个文件夹现在打开，让我们打开我们的 `tooling` 文件夹。Sublime Text
    的简单用户界面清楚地表明，我们目前项目中的文件只有一个：`main.go`。点击文件并添加一些额外的换行符，并添加和删除一些缩进。然后，从菜单中选择 **文件**
    | **保存**，或者按 *command + S*。请注意，代码会立即被清理，并且如果你没有从 `main.go` 中移除放置不当的返回语句，你会注意到控制台已经出现并报告了问题，这是由于
    go vet 的功劳：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Holding down *command + shift* and double-clicking on the unreachable code line
    in the console will open the file and jump the cursor to the right line in question.
    You can see how helpful this feature is going to be as you continue to write Go
    code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 按住 *command + shift* 并在控制台中的不可达代码行上双击，将打开文件并将光标跳转到相关的行。当你继续编写 Go 代码时，你可以看到这个功能将多么有用。
- en: 'If you add an unwanted import to the file, you will notice that on using `on_save`,
    you are told about the problem, but it wasn''t automatically fixed. This is because
    we have another tweak to make. In the same settings file as the one you added
    the `on_save` property to, add the following property:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向文件中添加了不需要的导入，你将注意到在使用 `on_save` 时你会被告知问题，但它并没有自动修复。这是因为我们还需要进行另一个调整。在添加
    `on_save` 属性的相同设置文件中，添加以下属性：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This tells GoSublime to use the `goimports` command instead of `go fmt`. Save
    this file again, and head back to `main.go`. Add `net/http` to the imports again,
    remove `fmt` import, and save the file. Note that the unused package was removed,
    and `fmt` was put back again.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 GoSublime 使用 `goimports` 命令而不是 `go fmt`。再次保存此文件，然后返回 `main.go`。再次将 `net/http`
    添加到导入中，删除 `fmt` 导入，并保存文件。请注意，已删除未使用的包，并将 `fmt` 再次放回。
- en: Visual Studio Code
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: A surprise entry in the running for best Go IDE is Microsoft's Visual Studio
    Code, available for free at [https://code.visualstudio.com](https://code.visualstudio.com).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳 Go IDE 竞选中出现的一个惊喜是微软的 Visual Studio Code，可在 [https://code.visualstudio.com](https://code.visualstudio.com)
    免费获得。
- en: 'Once you''ve downloaded it from the website, open a Go file (any file with
    a `.go` extension) and note that Visual Studio Code asks whether you''d like to
    install the recommended plugins to make working with Go files easier:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您从网站上下载它，打开一个 Go 文件（任何以 `.go` 扩展名结尾的文件），请注意 Visual Studio Code 会询问您是否希望安装推荐的插件以使处理
    Go 文件更容易：
- en: '![Visual Studio Code](img/00075.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code](img/00075.jpeg)'
- en: 'Click on **Show Recommendations** and click on **Install** next to the suggested
    Go plugin:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **显示推荐** 并点击建议的 Go 插件旁边的 **安装**：
- en: '![Visual Studio Code](img/00076.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code](img/00076.jpeg)'
- en: 'It may ask you to restart Visual Studio Code to enable the plugin, and it may
    also ask you to install some additional commands:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会要求您重新启动 Visual Studio Code 以启用插件，并且它还可能要求您安装一些额外的命令：
- en: '![Visual Studio Code](img/00077.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code](img/00077.jpeg)'
- en: Click on **Install All** to install all the dependencies, being sure to wait
    for the previous installation process to finish before initiating others. After
    a short while, you will notice that a few tools were installed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **安装所有** 以安装所有依赖项，确保在启动其他安装过程之前等待之前的安装过程完成。不久后，您会注意到安装了一些工具。
- en: Write some messy code (or copy and paste some from [https://github.com/matryer/goblueprints/blob/master/appendixA/messycode/main.go](https://github.com/matryer/goblueprints/blob/master/appendixA/messycode/main.go))
    into Visual Studio Code and hit save. You will notice that the imports were fixed
    and the code was nicely formatted as per the Go standard.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中编写一些混乱的代码（或从 [https://github.com/matryer/goblueprints/blob/master/appendixA/messycode/main.go](https://github.com/matryer/goblueprints/blob/master/appendixA/messycode/main.go)
    复制粘贴一些）并保存。您会注意到导入已修复，代码已按照 Go 标准格式化。
- en: There are many more features that you can make use of, but we won't dig into
    them further here.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用更多功能，但在这里我们不会进一步探讨。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we installed Go and are now ready to start building real projects.
    We learned about the `GOPATH` environment variable and discovered a common practice
    of keeping one value for all projects. This approach dramatically simplifies working
    on Go projects, where you are likely to continue to encounter tricky failures
    otherwise.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们安装了 Go，现在准备好开始构建真实的项目。我们了解了 `GOPATH` 环境变量，并发现了一个常见做法，即对所有项目保持一个值。这种方法大大简化了在
    Go 项目上的工作，否则您可能会继续遇到棘手的失败。
- en: We discovered how the Go toolset can really help us produce high-quality, community-standards-compliant
    code that any other programmer could pick up and work on with little to no additional
    learning. And more importantly, we looked at how automating the use of these tools
    means we can truly get down to the business of writing applications and solving
    problems, which is all developers really want to do.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了 Go 工具集如何真正帮助我们产生高质量、符合社区标准的代码，任何其他程序员都可以轻松地拾起并在此基础上进行工作，无需额外的学习。更重要的是，我们探讨了自动化这些工具的使用意味着我们可以真正专注于编写应用程序和解决问题，这正是开发者真正想做的事情。
- en: We looked at a couple of options for code editors or IDEs and saw how easy it
    was to add plugins or extensions that help writing Go code easier.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了一些代码编辑器或 IDE 的选项，并看到了如何轻松添加插件或扩展，以使编写 Go 代码更容易。
- en: Bibliography
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献列表
- en: 'This learning path has been prepared for you to help you build production-ready
    solutions in Go using cutting-edge technology and techniques. It comprises of
    the following Packt products:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这条学习路径是为您准备的，以帮助您使用最先进的技术和技巧在 Go 中构建生产就绪的解决方案。它包括以下 Packt 产品：
- en: '*Learning Go programming, Vladimir Vivien*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习 Go 编程，弗拉基米尔·维维安*'
- en: '*Go Design Patterns, Mario Castro Contreras*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go 设计模式，马里奥·卡斯特罗·孔特拉斯*'
- en: '*Go Programming Blueprints - Second Edition, Mat Ryer*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go 编程蓝图 - 第二版，马特·瑞尔*'
