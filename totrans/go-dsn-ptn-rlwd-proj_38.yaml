- en: Chapter 11. Deploying Go Applications Using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is an open source ecosystem (technology and range of associated services)
    that allows you to package applications into containers that are simple, lightweight,
    and portable; they will run in the same way regardless of which environment they
    run on. This is useful when you consider that our development environment (perhaps
    a Mac) is different from a production environment (such as a Linux server or even
    a cloud service) and that there is a large number of different places that we
    might want to deploy the same application.
  prefs: []
  type: TYPE_NORMAL
- en: Most cloud platforms already support Docker, which makes it a great option to
    deploy our apps into the wild.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](part0201_split_000.html#5VM122-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 9.  Building a Q&A Application for Google App Engine"), *Building a Q&A
    Application for Google App Engine*, we built an application for Google App Engine.
    We would need to make significant changes to our code if we decided that we wanted
    to run our application on a different platform even if we forget about our use
    of Google Cloud Datastore. Building applications with a mind to deploying them
    within Docker containers gives us an additional level of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you know that Docker itself was written in Go? See for yourself by browsing
    the source code at [https://github.com/docker/docker](https://github.com/docker/docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to write a simple Dockerfile to describe an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `docker` command to build the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run Docker containers locally and terminate them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deploy Docker containers to Digital Ocean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the features in Digital Ocean to spin up instances that already have
    Docker preconfigured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to put the Vault service we created in [Chapter 10](part0213_split_000.html#6B47Q1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10.  Micro-services in Go with the Go kit Framework"), *Micro-services
    in Go with the Go kit Framework*, into a Docker image and deploy it to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can deploy our code to the cloud, we must use the Docker tools on
    our development machine to build and push the image to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to build and run containers, you need to install Docker on your development
    machine. Head over to [https://www.docker.com/products/docker](https://www.docker.com/products/docker)
    and download the appropriate installer for your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and its ecosystem are evolving rapidly, so it is a good idea to make
    sure you're up to date with the latest release. Similarly, it is possible that
    some details will change in this chapter; if you get stuck, visit the project
    home page at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    for some helpful tips.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Docker image is like a mini virtual machine. It contains everything that''s
    needed to run an application: the operating system the code will run on, any dependencies
    that our code might have (such as Go kit in the case of our Vault service), and
    the binaries of our application itself.'
  prefs: []
  type: TYPE_NORMAL
- en: An image is described with `Dockerfile`; a text file containing a list of special
    commands that instruct Docker how to build the image. They are usually based on
    another container, which saves you from building up everything that might be needed
    in order to build and run Go applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `vault` folder from the code we wrote in [Chapter 10](part0213_split_000.html#6B47Q1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 10.  Micro-services in Go with the Go kit Framework"), *Micro-services
    in Go with the Go kit Framework*, add a file called `Dockerfile` (note that this
    filename has no extension), containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in a  `Dockerfile` file represents a different command that is run
    while the image is being built. The following table describes each of the commands
    we have used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `FROM` | The name of the image that this image will be based on. Single words,
    such as scratch, represent official Docker images hosted on Docker Hub. For more
    information on the scratch image, refer to `https://hub.docker.com/_/scratch/`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ADD` | Copies files into the container. We are copying our `vaultd` binary
    and calling it `vaultd`. |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPOSE` | Exposes the list of ports; in our case, the Vault service binds
    to `:8080` and `:8081`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ENTRYPOINT` | The binary to run when the container is executed in our case,
    the `vaultd` binary, which will be put there by the previous call to go install.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MAINTAINER` | Name and email of the person responsible for maintaining the
    Docker image. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of the supported commands, consult the online Docker documentation
    at [https://docs.docker.com/engine/reference/builder/#dockerfile-reference](https://docs.docker.com/engine/reference/builder/#dockerfile-reference).
  prefs: []
  type: TYPE_NORMAL
- en: Building Go binaries for different architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go supports cross-complication, a mechanism by which we can build a binary on
    one machine (say, our Mac) targeted for a different operating system (such as
    Linux or Windows) and architecture. Docker containers are Linux-based; so, in
    order to deliver a binary that can run in that environment, we must first build
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, navigate to the vault folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are essentially calling go build here but with a few extra bits and pieces
    to control the build process. `CGO_ENABLED` and `GOOS` are environment variables
    that go build will pay attention to, `-a` is a flag, and `./cmd/vaultd/` is the
    location of the command we want to build (in our case, the `vaultd` command we
    built in the previous chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The `CGO_ENABLED=0` indicates that we do not want cgo to be enabled. Since we
    are not binding to any C dependencies, we can reduce the size of our build by
    disabling this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOOS` is short for Go Operating System and lets us specify which OS we are
    targeting, in our case, Linux. For a complete list of the available options, you
    can look directly in the Go source code by visiting [https://github.com/golang/go/blob/master/src/go/build/syslist.go](https://github.com/golang/go/blob/master/src/go/build/syslist.go).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a short while, you'll notice that a new binary has appeared, called `vaultd`.
    If you're on a non-Linux machine, you won't be able to directly execute this but
    don't worry; it'll run inside our Docker container just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build the image, in a terminal, navigate to `Dockerfile` and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `docker` command to build the image. The final dot indicates
    that we want to build Dockerfile from the current directory. The `-t` flag specifies
    that we want to give our image the name of `vaultd`. This will allow us to refer
    to it by name rather than a hash that Docker will assign to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the first time you''ve used Docker, and in particular the `scratch`
    base image, then it will take some time to download the required dependencies
    from Docker Hub depending on your Internet connection. Once that''s finished,
    you will see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For each command, a new image is created (you can see the intermediate containers
    being disposed of along the way) until we end up with the final image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are building our binary on our local machine and copying it into the
    container (with the `ADD` command), our Docker image ends up being only about
    7 MB: pretty small when you consider that it contains everything it needs to run
    our services.'
  prefs: []
  type: TYPE_NORMAL
- en: Running a Docker image locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our image is built, we can test it by running it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `docker run` command will spin up an instance of the `vaultd` image.
  prefs: []
  type: TYPE_NORMAL
- en: The `-p` flags specify a pair of ports to be exposed, the first value is the
    host port and the second value (following the colon) is the port within the image.
    In our case, we are saying that we want port `8080` to be exposed onto port `6060`
    and port `8081` exposed via port `6061`.
  prefs: []
  type: TYPE_NORMAL
- en: We are giving the running instance a name of `localtest` with the `--name` flag,
    which will help us to identify it when inspecting and stopping it. The `--rm`
    flag indicates that we want the image to be removed once we have stopped it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is successful, you will notice that the Vault service has indeed begun
    because it is telling us the ports to which it is bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are the internal ports; remember that we have mapped these to different
    external ports instead. This seems confusing but ends up being very powerful,
    since the person responsible for spinning up the instances of the service gets
    to decide which ports are right for their environment, and the Vault service itself
    doesn't have to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this running, open another terminal and use the `curl` command to access
    the JSON endpoint of our password hashing service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see something that resembles the output from the running service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting Docker processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see what Docker instances are running, we can use the `docker ps` command.
    In the terminal, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get a text table outlining the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONTAINER ID** | `0b5e35dca7cc` |'
  prefs: []
  type: TYPE_TB
- en: '| **IMAGE** | `vaultd` |'
  prefs: []
  type: TYPE_TB
- en: '| **COMMAND** | `/bin/sh -c /go/bin/vaultd` |'
  prefs: []
  type: TYPE_TB
- en: '| **CREATED** | `3 seconds ago` |'
  prefs: []
  type: TYPE_TB
- en: '| **STATUS** | `Up 2 seconds` |'
  prefs: []
  type: TYPE_TB
- en: '| **PORTS** | `0.0.0.0:6060->8080/tcp, 0.0.0.0:6061->8081/tcp` |'
  prefs: []
  type: TYPE_TB
- en: '| **NAMES** | `localtest` |'
  prefs: []
  type: TYPE_TB
- en: The details show you a high-level overview of the image we just started. Note
    that the **PORTS** sections shows you the mapping from external to internal.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a Docker instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are used to hitting *Ctrl + C* in the window running our code to stop it,
    but since it's running inside a container, that won't work. Instead, we need to
    use the `docker stop` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we gave our instance the name `localtest`, we can use this to stop it
    by typing this in an available terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After a few moments, you'll notice that the terminal that was running the image
    has now returned to the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have contained our Vault service inside a Docker container, we are
    going to do some useful things with it.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we are going to do is push this to the Docker Hub so that other
    people may spin up their own instances or even build new images based on it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Head over to Docker Hub at [https://hub.docker.com](https://hub.docker.com)
    and create an account by clicking on the **Log In** link in the top-right-hand
    corner and then clicking on **Create Account**. Of course, if you already have
    an account, just log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in a terminal, you are going to authenticate with this account by running
    Docker''s `login` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you see an error such as `WARNING: Error loading config, permission denied`,
    then try the command again with the `sudo` command prefix. This goes for all of
    Docker commands from this point onwards, since we''re using a secured configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you replace `USERNAME` and `PASSWORD` with your actual username
    and password of the account you just created.
  prefs: []
  type: TYPE_NORMAL
- en: If successful, you'll see, **Login Succeeded**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, back in the web browser, click on **Create Repository** and create a new
    repository called  `vault`. The actual name for this image is going to be  `USERNAME/vault`,
    so we're going to need to rebuild the image locally to match this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that for public consumption, we are calling the image `vault` rather than `vaultd`.
    This is a deliberate difference so that we can make sure we are dealing with the
    right image, but this is also a better name for users anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, build the new repository with the correct name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will build the image again, this time with the appropriate name. To deploy
    the image to the Docker Hub, we use Docker''s `push` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After some time, the image and its dependencies will be pushed to Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now head over to the Docker Hub to see the details of your image, or look at
    an example at [https://hub.docker.com/r/matryer/vault/](https://hub.docker.com/r/matryer/vault/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Digital Ocean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital Ocean is a cloud service provider that offers competitive prices to
    host virtual machines. It makes deploying and serving Docker images very easy.
    In this section, we are going to deploy a droplet (Digital Ocean's terminology
    for a single machine) that runs our dockerized Vault service in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, following are the steps to deploy Docker images to Digital Ocean:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a droplet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gain access to it via a web-based console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull our `USERNAME/vault` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access our hosted Vault service remotely via the `curl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Digital Ocean is a **Platform as a Service** (**PaaS**) architecture, and as
    such, the user experience is likely to change from time to time, so the exact
    flow described here might not be entirely accurate by the time you come to perform
    these tasks. Usually, by looking around at the options, you will be able to figure
    out how to proceed, but screenshots have been included to help guide you.
  prefs: []
  type: TYPE_NORMAL
- en: This section also assumes that you have enabled any billing that might be required
    in order to create droplets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a droplet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sign up or log in to Digital Ocean by visiting [https://www.digitalocean.com](https://www.digitalocean.com)
    in the browser. Ensure that you use a real e-mail address, as this is where they
    will send the root password for the droplet you are going to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have no other droplets, you will be presented with a blank screen. Click
    on **Create Droplet**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a droplet](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inside the **One-click apps** tab, look for the latest Docker option; at the
    time of writing this, it is **Docker 1.12.1 on 16.04**, which means Docker version
    1.12.1 is running on Ubuntu 16.04.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll down the page to select the remaining options, including picking a size
    (the smallest size will do for now) and a location (pick the closest geographic
    location to you). We won't bother adding additional services (such as volumes,
    networking, or backups) for now just proceed with the simple droplet.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might be a nice idea to give your droplet a meaningful hostname so that
    it''s easy to find later, something like `vault-service-1` or similar; it doesn''t
    really matter for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a droplet](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can optionally add SSH keys for additional security, but for simplicity's
    sake, we are going to continue without it. For production, it is recommended that
    you always do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the page, click on **Create**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a droplet](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the droplet's console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once your droplet has been created, select it from the **Droplets** list and
    look for the **Console** option (it may be written as `Access console`).
  prefs: []
  type: TYPE_NORMAL
- en: 'After a few moments, you will be presented with a web-based terminal. This
    is how we will control the droplet, but first, we must log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the droplet''s console](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the login username as `root`, and check your e-mail for the root password
    that Digital Ocean has sent you. At the time of writing this, you cannot copy
    and paste this, so be ready to carefully type out a long string as accurately
    as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The password might well be a lowercase hexadecimal string, which will help you
    know which characters are likely to appear. For example, everything that looks
    like an *O* is probably *zero*, and *1* is unlikely to be an *I* or *L*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've logged in for the first time, you'll be asked to change your password
    which involves typing the long generated password again! Security can be so inconvenient
    at times.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we selected the Docker app as a starting point for our droplet, Digital
    Ocean has kindly configured Docker to already be running inside our instance,
    so we can just use the `docker` command to finish setting things up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the web-based terminal, pull your container with the following command,
    remembering to replace `USERNAME` with your Docker Hub username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If, for whatever reason, this isn''t working for you, you can try using the
    Docker image placed there by the author by typing this:  `docker pull matryer/vault`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker will go and pull down everything it needs in order to run the image
    we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pulling Docker images](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running Docker images in the cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the image and its dependencies have successfully downloaded, we will be
    able to run it using a the `docker run` command, this time with the `-d` flag
    to specify that we want it to run as a background daemon. In the web-based terminal,
    type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the command we ran earlier, except that this time, we are
    giving it the name vault, and we have omitted the `--rm` flag, since it is not
    compatible (and doesn't make sense) with the background daemon mode.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker image containing our Vault service will start running and is now
    ready to test.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Docker images in the cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our Docker image is running in our droplet within Digital Ocean's platform,
    we can start using it.
  prefs: []
  type: TYPE_NORMAL
- en: In the Digital Ocean web control panel, select **Droplets** and look for the
    one we just created. We need to know the IP address so that we can access the
    services remotely. Once you have located the IP address of the droplet, click
    on it to copy it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a local terminal on your computer (do not use the web-based terminal)
    and use the `curl` command (or equivalent) to make the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember to replace `IPADDRESS` with the actual IP address you copied from Digital
    Ocean's web control panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that you have successfully managed to access the JSON/HTTP
    endpoint of our Vault service when you get a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See whether you can modify the `curl` command to validate the hash that was
    provided using the `/validate` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built and deployed our Vault Go application using Docker
    to Digital Ocean's cloud.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the Docker tools, we saw how easy it was to package up our
    Go application into a Docker image and push it to Docker Hub. We created our Digital
    Ocean droplet using the helpful Docker app that they provide and controlled it
    via a web-based console. Once inside, we were able to pull our Docker image from
    the Docker Hub and run it inside our droplet.
  prefs: []
  type: TYPE_NORMAL
- en: Using the public IP of the droplet, we were then able to remotely access the
    Vault service's JSON/HTTP endpoint to hash and validate passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix Appendix. Good Practices for a Stable Go Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Go code is a fun and enjoyable experience, where compile-time errors
    rather than being a pain actually guide you to write robust, high-quality code.
    However, every now and then, you will encounter environmental issues that start
    to get in the way and break your flow. While you can usually resolve these issues
    after some searching and a little tweaking, setting up your development environment
    correctly goes a long way in reducing problems, allowing you to focus on building
    useful applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to install Go from scratch on a new machine and
    discuss some of the environmental options we have and the impact they might have
    in the future. We will also consider how collaboration might influence some of
    our decisions as well as what impact open sourcing our packages might have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Go on your development machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what the `GOPATH` environment variable is for and discuss a sensible approach
    for its use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the Go tools and how to use them to keep the quality of our code
    high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use a tool to automatically manage our imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about on *save* operations for our `.go` files and how we can integrate
    the Go tools as part of our daily development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at some popular code editor options to write Go code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to install Go is to use one of the many installers available online
    at [https://golang.org/dl/](https://golang.org/dl/). Go to the Go website and
    click on **Download**, and then look for the latest 1.x version for your computer.
    The **Featured downloads** section at the top of the page contains links to the
    most popular versions, so yours will probably be in that list.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this book has been tested with Go 1.7, but any 1.x release will
    work. For future versions of Go (2.0 and higher), you may need to tweak the code
    as major version releases may well contain breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is now installed, but in order to use the tools, we must ensure that it is
    properly configured. To make calling the tools easier, we need to add our `go/bin`
    path to the `PATH` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Unix systems, you should add export `PATH=$PATH:/opt/go/bin` (make sure it
    is the path you chose when installing Go) to your `.bashrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, open **System Properties** (try right-clicking on **My Computer**),
    and under **Advanced**, click on the **Environment Variables** button and use
    the UI to ensure that the `PATH` variable contains the path to your `go/bin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal (you may need to restart it for your changes to take effect),
    you can make sure this worked by printing the value of the `PATH` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the value printed contains the correct path to your `go/bin` folder;
    for example, on my machine it prints as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The colons (semicolons on Windows) between the paths indicate that the `PATH`
    variable is actually a list of folders rather than just one folder. This indicates
    that each folder included will be searched when you enter commands in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can make sure the Go build we just made runs successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the `go` command (which can be found in your `go/bin` location) like
    this will print out the current version for us. For example, for Go 1.77.1, you
    should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Getting GOPATH right
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GOPATH` is another environment variable to a folder (such as `PATH` in the
    previous section) that is used to specify the location for the Go source code
    and the compiled binary packages. Using the `import` command in your Go programs
    will cause the compiler to look in the `GOPATH` location to find the packages
    you are referring to. When using `go get` and other commands, projects are downloaded
    into the `GOPATH` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: While the `GOPATH` location can contain a list of colon-separated folders, such
    as `PATH` and you can even have a different value for `GOPATH` depending on which
    project you are working in it is strongly recommended that you use a single `GOPATH`
    location for everything, and this is what we will assume you will do for the projects
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `go`, this time in your `Users` folder somewhere
    perhaps in a `Work` subfolder. This will be our `GOPATH` target and is where all
    the third-party code and binaries will end up as well as where we will write our
    Go programs and packages. Using the same technique you used when setting the `PATH`
    environment variable in the previous section, set the `GOPATH` variable to the
    new `go` folder. Let''s open a terminal and use one of the newly installed commands
    to get a third-party package for us to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the `silk` library will actually cause this folder structure to be
    created: `$GOPATH/src/github.com/matryer/silk`. You can see that the path segments
    are important in how Go organizes things, which helps namespace projects and keeps
    them unique. For example, if you created your own package called `silk`, you wouldn''t
    keep it in the GitHub repository of `matryer`, so the path would be different.'
  prefs: []
  type: TYPE_NORMAL
- en: When we create projects in this book, you should consider a sensible `GOPATH`
    root for them. For example, I used `github.com/matryer/goblueprints`, and if you
    were to go get that, you would actually get a complete copy of all the source
    code for this book in your `GOPATH` folder!
  prefs: []
  type: TYPE_NORMAL
- en: Go tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An early decision made by the Go core team was that all Go code should look
    familiar and obvious to everybody who speaks Go rather than each code base requiring
    additional learning in order for new programmers to understand it or work on it.
    This is an especially sensible approach when you consider open source projects,
    some of which have hundreds of contributors coming and going all the time.
  prefs: []
  type: TYPE_NORMAL
- en: There is a range of tools that can assist us in achieving the high standards
    set by the Go core team, and we will look at some of the tools in action in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `GOPATH` location, create a new folder called `tooling` and create
    a new `main.go` file containing the following code verbatim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The tight spaces and lack of indentation are deliberate as we are going to look
    at a very cool utility that comes with Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, navigate to your new folder and run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At Gophercon 2014 in Denver, Colorado, most people learned that rather than
    pronouncing this little triad as *format* or *f, m, t*, it is actually pronounced
    as a word. Try saying it to yourself now: *fhumt*; it seems that computer programmers
    aren''t weird enough without speaking an alien language to each other too!'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that this little tool has actually tweaked our code file to
    ensure that the layout (or format) of our program matches Go standards. The new
    version is much easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `go fmt` command cares about indentation, code blocks, unnecessary whitespace,
    unnecessary extra line feeds, and more. Formatting your code in this way is a
    great practice to ensure that your Go code looks like all other Go code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to vet our program to make sure that we haven''t made any
    mistakes or decisions that might be confusing to our users; we can do this automatically
    with another great tool that we get for free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for our little program points out an obvious and glaring mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are calling `return` at the top of our function and then trying to do other
    things. The `go vet` tool has noticed this and points out that we have unreachable
    code in our file.
  prefs: []
  type: TYPE_NORMAL
- en: It isn't just silly mistakes like this that `go vet` will catch; it will also
    look for subtler aspects of your program that will guide you toward writing the
    best Go code you can. For an up-to-date list of what the vet tool will report
    on, check out the documentation at [https://golang.org/cmd/vet/](https://golang.org/cmd/vet/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final tool we will play with is called `goimports`, and it was written
    by Brad Fitzpatrick to automatically fix (add or remove) `import` statements for
    Go files. It is an error in Go to import a package and not use it, and obviously,
    trying to use a package without importing it won''t work either. The `goimports`
    tool will automatically rewrite our `import` statement based on the contents of
    our code file. First, let''s install `goimports` with this familiar command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Update your program to import some packages that we are not going to use and
    remove the `fmt` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to run our program by calling `go run main.go`, we will see that
    we get some errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These errors tell us that we have imported packages that we are not using and
    missing the `fmt` package and that in order to continue, we need to make corrections.
    This is where `goimports` comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We are calling the `goimports` command with the `-w` write flag, which will
    save us the task of making corrections to all files ending with `.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at your `main.go` file now, and note that the `net/http` and `sync`
    packages have been removed and the `fmt` package has been put back in.
  prefs: []
  type: TYPE_NORMAL
- en: You could argue that switching to a terminal to run these commands takes more
    time than just doing it manually, and you would probably be right in most cases,
    which is why it is highly recommended that you integrate the Go tools with your
    text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up, building, and running tests on save
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the Go core team has provided us with such great tools as `fmt`, `vet`,
    `test`, and `goimports`, we are going to look at a development practice that has
    proven to be extremely useful. Whenever we save a `.go` file, we want to perform
    the following tasks automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `goimports` and `fmt` to fix our imports and format the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vet the code for any faux pas and tell us immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempt to build the current package and output any build errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the build is successful, run the tests for the package and output any failures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because Go code compiles so quickly (Rob Pike once actually said that it doesn't
    build quickly, but it's just not slow like everything else), we can comfortably
    build entire packages every time we save a file. This is also true for running
    tests to help us if we are developing in a TDD style, and the experience is great.
    Every time we make changes to our code, we can immediately see whether we have
    broken something or had an unexpected impact on some other part of our project.
    We'll never see package import errors again because our `import` statement will
    have been fixed for us, and our code will be correctly formatted right in front
    of our eyes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some editors are likely to not support running code in response to specific
    events, such as saving a file, which leaves you with two options: you can either
    switch to a better editor, or you can write your own script file that runs in
    response to filesystem changes. The latter solution is out of the scope of this
    book; instead, we will focus on how to implement this functionality in a couple
    of popular editor codes.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrated developer environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Integrated Developer Environments** (**IDEs**)  are essentially text editors
    with additional features that make writing code and building software easier.
    Text with special meaning, such as string literals, types, function names, and
    so on are often colored differently by syntax highlighting, or you may get autocomplete
    options as you're typing. Some editors even point out errors in your code before
    you've executed it.
  prefs: []
  type: TYPE_NORMAL
- en: There are many options to choose from, and mostly, it comes down to personal
    preference, but we will look at some of the more popular choices as well as how
    to set them up to build Go projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular editors include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sublime Text 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vim (with vim-go)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see a complete curated list of options at [https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to explore Sublime Text 3 and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Sublime Text 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sublime Text 3 is an excellent editor to write Go code that runs on OS X, Linux,
    and Windows and has an extremely powerful expansion model, which makes it easy
    to customize and extend. You can download Sublime Text from [http://www.sublimetext.com/](http://www.sublimetext.com/)
    and trial-use it for free before deciding whether you want to buy it or not.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to **DisposaBoy** (refer to [https://github.com/DisposaBoy](https://github.com/DisposaBoy)),
    there is already a Sublime expansion package for Go, which actually gives us a
    wealth of features and power that a lot of Go programmers actually miss out on.
    We are going to install this `GoSublime` package and then build upon it to add
    our desired on-save functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can install `GoSublime`, we need to install Package Control into Sublime
    Text. Head over to [https://sublime.wbond.net/](https://sublime.wbond.net/) and
    click on the **Installation** link for instructions on how to install Package
    Control. At the time of writing this, it's simply a case of copying the single,
    albeit long, line command and pasting it into the Sublime console, which can be
    opened by navigating to **View** | **Show Console** from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is complete, press *shift + command + P* and type `Package Control:
    Install Package` and press *return* when you have selected the option. After a
    short delay (where Package Control is updating its listings), a box will appear,
    allowing you to search for and install GoSublime just by typing it in, selecting
    it, and pressing *return*. If all is well, GoSublime will be installed and writing
    Go code will just become an order of magnitude easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have GoSublime installed, you can open a short help file containing
    the details of the package by pressing *command + ., command + 2* (the command
    key and period at the same time, followed by the command key and number 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'For some additional help while saving, press *command + ., command + 5* to
    open the GoSublime settings and add the following entry to the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the settings file is actually a JSON object, so ensure that you add
    the `on_save` property without corrupting the file. For example, if you have properties
    before and after, ensure the appropriate commas are in place.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding setting will tell Sublime Text to build the code looking for errors,
    install test dependencies, run tests, and vet the code whenever we save the file.
    Save the settings file (don't close it just yet), and let's see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Choose File** | **Open...** from the menu and select a folder
    to open for now, let''s open our `tooling` folder. The simple user interface of
    Sublime Text makes it clear that we only have one file in our project right now:
    `main.go`. Click on the file and add some extra linefeeds, and add and remove
    some indenting. Then, navigate to **File** | **Save** from the menu, or press
    *command + S*. Note that the code is immediately cleaned up, and provided that
    you haven''t removed the oddly placed return statement from `main.go`, you will
    notice that the console has appeared and is reporting the issue thanks to go vet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Holding down *command + shift* and double-clicking on the unreachable code line
    in the console will open the file and jump the cursor to the right line in question.
    You can see how helpful this feature is going to be as you continue to write Go
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add an unwanted import to the file, you will notice that on using `on_save`,
    you are told about the problem, but it wasn''t automatically fixed. This is because
    we have another tweak to make. In the same settings file as the one you added
    the `on_save` property to, add the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This tells GoSublime to use the `goimports` command instead of `go fmt`. Save
    this file again, and head back to `main.go`. Add `net/http` to the imports again,
    remove `fmt` import, and save the file. Note that the unused package was removed,
    and `fmt` was put back again.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A surprise entry in the running for best Go IDE is Microsoft's Visual Studio
    Code, available for free at [https://code.visualstudio.com](https://code.visualstudio.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve downloaded it from the website, open a Go file (any file with
    a `.go` extension) and note that Visual Studio Code asks whether you''d like to
    install the recommended plugins to make working with Go files easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual Studio Code](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Show Recommendations** and click on **Install** next to the suggested
    Go plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual Studio Code](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It may ask you to restart Visual Studio Code to enable the plugin, and it may
    also ask you to install some additional commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual Studio Code](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Install All** to install all the dependencies, being sure to wait
    for the previous installation process to finish before initiating others. After
    a short while, you will notice that a few tools were installed.
  prefs: []
  type: TYPE_NORMAL
- en: Write some messy code (or copy and paste some from [https://github.com/matryer/goblueprints/blob/master/appendixA/messycode/main.go](https://github.com/matryer/goblueprints/blob/master/appendixA/messycode/main.go))
    into Visual Studio Code and hit save. You will notice that the imports were fixed
    and the code was nicely formatted as per the Go standard.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more features that you can make use of, but we won't dig into
    them further here.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, we installed Go and are now ready to start building real projects.
    We learned about the `GOPATH` environment variable and discovered a common practice
    of keeping one value for all projects. This approach dramatically simplifies working
    on Go projects, where you are likely to continue to encounter tricky failures
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: We discovered how the Go toolset can really help us produce high-quality, community-standards-compliant
    code that any other programmer could pick up and work on with little to no additional
    learning. And more importantly, we looked at how automating the use of these tools
    means we can truly get down to the business of writing applications and solving
    problems, which is all developers really want to do.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at a couple of options for code editors or IDEs and saw how easy it
    was to add plugins or extensions that help writing Go code easier.
  prefs: []
  type: TYPE_NORMAL
- en: Bibliography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This learning path has been prepared for you to help you build production-ready
    solutions in Go using cutting-edge technology and techniques. It comprises of
    the following Packt products:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning Go programming, Vladimir Vivien*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Go Design Patterns, Mario Castro Contreras*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Go Programming Blueprints - Second Edition, Mat Ryer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
