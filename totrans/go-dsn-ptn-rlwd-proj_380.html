<html><head></head><body>
<div class="book" title="Factory method - delegating the creation of different types of payments">
<div class="book" title="Upgrading the Debitcard method to a new platform"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch02lvl2sec050" class="calibre1"/>Upgrading the Debitcard method to a new platform</h2></div></div></div><p class="calibre10">Now imagine that your <code class="email">DebitCard</code> payment method has changed for some reason, and you need a new struct for it. To achieve this scenario, you will only need to create the new struct and replace the old one when the user asks for the <code class="email">DebitCard</code> payment method:</p><pre class="programlisting">type CreditCardPM struct {} 
 func (d *CreditCardPM) Pay(amount float32) string { 
   return fmt.Sprintf("%#0.2f paid using new credit card implementation\n", amount) 
} 
</pre><p class="calibre10">This is our new type that will replace the <code class="email">DebitCardPM</code> structure. The <code class="email">CreditCardPM</code> implements the same <code class="email">PaymentMethod</code> interface as the debit card. We haven't deleted the previous one in case we need it in the future. The only difference lies in the returned message that now contains the information about the new type. We also have to modify the method to retrieve the payment methods:</p><pre class="programlisting">func GetPaymentMethod(m int) (PaymentMethod, error) { 
    switch m { 
        case Cash: 
        return new(CashPM), nil 
        case DebitCard: 
        return new(CreditCardPM), nil 
        default: 
        return nil, errors.New(fmt.Sprintf("Payment method %d not recognized\n", m)) 
   } 
} 
</pre><p class="calibre10">The only modification is in the line where we create the new debit card that now points to the newly created struct. Let's run the tests to see if everything is still correct:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=GetPaymentMethod .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodCash</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestGetPaymentMethodCash (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:18: LOG: 10.30 paid using cash</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodDebitCard</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestGetPaymentMethodDebitCard (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:28: The debit card payment method message wasn't correct</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:30: LOG: 22.30 paid using new debit card implementation</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodNonExistent</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestGetPaymentMethodNonExistent (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:38: LOG: Payment method 20 not recognized</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Uh, oh! Something has gone wrong. The expected message when paying with a credit card does not match the returned message. Does it mean that our code isn't correct? Generally speaking, yes, you shouldn't modify your tests to make your program work. When defining tests, you should be also aware of not defining them too much because you could achieve some coupling in the tests that you didn't have in your code. With the message restriction, we have a few grammatically correct possibilities for the message, so we'll change it to the following:</p><pre class="programlisting">return fmt.Sprintf("%#0.2f paid using debit card (new)\n", amount) 
</pre><p class="calibre10">We run the tests again now:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=GetPaymentMethod .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodCash</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestGetPaymentMethodCash (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:18: LOG: 10.30 paid using cash</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodDebitCard</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestGetPaymentMethodDebitCard (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:30: LOG: 22.30 paid using debit card (new)</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestGetPaymentMethodNonExistent</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestGetPaymentMethodNonExistent (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        factory_test.go:38: LOG: Payment method 20 not recognized</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Everything is okay again. This was just a small example of how to write good unit tests, too. When we wanted to check that a debit card payment method returns a message that contains <code class="email">paid using debit card</code> string, we were probably being a bit restrictive, and it would be better to check for those words separately or define a better formatting for the returned messages.</p></div></div></body></html>