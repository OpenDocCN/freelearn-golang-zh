<html><head></head><body>
<div class="book" title="Abstract Factory - a factory of factories">
<div class="book" title="Unit test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec056" class="calibre1"/>Unit test</h2></div></div></div><p class="calibre10">This is going to be a long example, so pay attention, please. We will have the following entities:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Vehicle</strong></span>: The interface that all objects in our factories must implement:<div class="book"><ul class="itemizedlist1"><li class="listitem"><span class="strong"><strong class="calibre2">Motorbike</strong></span>: An interface for motorbikes of the types sport (one seat) and cruise (two seats).</li><li class="listitem"><span class="strong"><strong class="calibre2">Car</strong></span>: An interface for cars of types luxury (with four doors) and family (with five doors).</li></ul></div><p class="calibre29">
</p></li><li class="listitem"><span class="strong"><strong class="calibre2">VehicleFactory</strong></span>: An interface (the Abstract Factory) to retrieve factories that implement the <code class="email">VehicleFactory</code> method:<div class="book"><ul class="itemizedlist1"><li class="listitem"><span class="strong"><strong class="calibre2">Motorbike</strong></span> Factory: A factory that implements the <code class="email">VehicleFactory</code> interface to return vehicle that implements the <code class="email">Vehicle</code> and <code class="email">Motorbike</code> interfaces.</li><li class="listitem"><span class="strong"><strong class="calibre2">Car</strong></span> Factory: Another factory that implements the <code class="email">VehicleFactory</code> interface to return vehicles that implement the <code class="email">Vehicle</code> and <code class="email">Car</code> interfaces.</li></ul></div><p class="calibre29">
</p></li></ul></div><p class="calibre10">For clarity, we are going to separate each entity into a different file. We will start with the <code class="email">Vehicle</code> interface, which will be in the <code class="email">vehicle.go</code> file:</p><pre class="programlisting">package abstract_factory 
 
type Vehicle interface { 
    NumWheels() int 
    NumSeats() int 
} 
</pre><p class="calibre10">The <code class="email">Car</code> and <code class="email">Motorbike</code> interfaces will be in the <code class="email">car.go</code> and <code class="email">motorbike.go</code> files, respectively:</p><pre class="programlisting">// Package abstract_factory file: car.go 
package abstract_factory 
 
type Car interface { 
    NumDoors() int 
} 
// Package abstract_factory file: motorbike.go 
package abstract_factory 
 
type Motorbike interface { 
    GetMotorbikeType() int 
} 
</pre><p class="calibre10">We have one last interface, the one that each factory must implement. This will be in the <code class="email">vehicle_factory.go</code> file:</p><pre class="programlisting">package abstract_factory 
 
type VehicleFactory interface { 
    NewVehicle(v int) (Vehicle, error) 
} 
</pre><p class="calibre10">So, now we are going to declare the car factory. It must implement the <code class="email">VehicleFactory</code> interface defined previously to return <code class="email">Vehicles</code> instances:</p><pre class="programlisting">const ( 
    LuxuryCarType = 1 
    FamilyCarType = 2 
) 
 
type CarFactory struct{} 
func (c *CarFactory) NewVehicle(v int) (Vehicle, error) { 
    switch v { 
        case LuxuryCarType: 
        return new(LuxuryCar), nil 
        case FamilyCarType: 
        return new(FamilyCar), nil 
        default: 
        return nil, errors.New(fmt.Sprintf("Vehicle of type %d not recognized\n", v)) 
    } 
} 
</pre><p class="calibre10">We have defined two types of cars--luxury and family. The <code class="email">car</code> Factory will have to return cars that implement the <code class="email">Car</code> and the <code class="email">Vehicle</code> interfaces, so we need two concrete implementations:</p><pre class="programlisting">//luxury_car.go 
package abstract_factory 
 
type LuxuryCar struct{} 
 
func (*LuxuryCar) NumDoors() int { 
    return 4 
} 
func (*LuxuryCar) NumWheels() int { 
    return 4 
} 
func (*LuxuryCar) NumSeats() int { 
    return 5 
} 
 
package abstract_factory 
 
type FamilyCar struct{} 
 
func (*FamilyCar) NumDoors() int { 
    return 5 
} 
func (*FamilyCar) NumWheels() int { 
    return 4 
} 
func (*FamilyCar) NumSeats() int { 
    return 5 
} 
</pre><p class="calibre10">That's all for cars. Now we need the motorbike factory, which, like the car factory, must implement the <code class="email">VehicleFactory</code> interface:</p><pre class="programlisting">const ( 
    SportMotorbikeType = 1 
    CruiseMotorbikeType = 2 
) 
 
type MotorbikeFactory struct{} 
 
func (m *MotorbikeFactory) Build(v int) (Vehicle, error) { 
    switch v { 
        case SportMotorbikeType: 
        return new(SportMotorbike), nil 
        case CruiseMotorbikeType: 
        return new(CruiseMotorbike), nil 
        default: 
        return nil, errors.New(fmt.Sprintf("Vehicle of type %d not recognized\n", v)) 
    } 
} 
</pre><p class="calibre10">For the motorbike Factory, we have also defined two types of motorbikes using the <code class="email">const</code> keywords: <code class="email">SportMotorbikeType</code> and <code class="email">CruiseMotorbikeType</code>. We will switch over the <code class="email">v</code> argument in the <code class="email">Build</code> method to know which type shall be returned. Let's write the two concrete motorbikes:</p><pre class="programlisting">//sport_motorbike.go 
package abstract_factory 
 
type SportMotorbike struct{} 
 
func (s *SportMotorbike) NumWheels() int { 
    return 2 
} 
func (s *SportMotorbike) NumSeats() int { 
    return 1 
} 
func (s *SportMotorbike) GetMotorbikeType() int { 
    return SportMotorbikeType 
} 
 
//cruise_motorbike.go 
package abstract_factory 
 
type CruiseMotorbike struct{} 
 
func (c *CruiseMotorbike) NumWheels() int { 
    return 2 
} 
func (c *CruiseMotorbike) NumSeats() int { 
    return 2 
} 
func (c *CruiseMotorbike) GetMotorbikeType() int { 
    return CruiseMotorbikeType 
} 
</pre><p class="calibre10">To finish, we need the abstract factory itself, which we will put in the previously created <code class="email">vehicle_factory.go</code> file:</p><pre class="programlisting">package abstract_factory 
 
import ( 
    "fmt" 
    "errors" 
) 
 
type VehicleFactory interface { 
    Build(v int) (Vehicle, error) 
} 
 
const ( 
    CarFactoryType = 1 
    MotorbikeFactoryType = 2 
) 
 
func BuildFactory(f int) (VehicleFactory, error) { 
    switch f { 
        default: 
        return nil, errors.New(fmt.Sprintf("Factory with id %d not recognized\n", f)) 
    } 
}</pre><p class="calibre10">We are going to write enough tests to make a reliable check as the scope of the book doesn't cover 100% of the statements. It will be a good exercise for the reader to finish these tests. First, a <code class="email">motorbike</code> Factory test:</p><pre class="programlisting">package abstract_factory 
 
import "testing" 
 
func TestMotorbikeFactory(t *testing.T) { 
    motorbikeF, err := BuildFactory(MotorbikeFactoryType) 
    if err != nil { 
        t.Fatal(err) 
    } 
 
    motorbikeVehicle, err := motorbikeF.Build(SportMotorbikeType) 
    if err != nil { 
        t.Fatal(err) 
    } 
 
    t.Logf("Motorbike vehicle has %d wheels\n", motorbikeVehicle.NumWheels()) 
 
    sportBike, ok := motorbikeVehicle.(Motorbike) 
    if !ok { 
        t.Fatal("Struct assertion has failed") 
    } 
    t.Logf("Sport motorbike has type %d\n", sportBike.GetMotorbikeType()) 
} 
</pre><p class="calibre10">We use the package method, <code class="email">BuildFactory</code> , to retrieve a motorbike Factory (passing the <code class="email">MotorbikeFactory</code> ID in the parameters), and check if we get any error. Then, already with the motorbike factory, we ask for a vehicle of the type <code class="email">SportMotorbikeType</code> and check for errors again. With the returned vehicle, we can ask for methods of the vehicle interface (<code class="email">NumWheels</code> and <code class="email">NumSeats</code>). We know that it is a motorbike, but we cannot ask for the type of motorbike without using the type assertion. We use the type assertion on the vehicle to retrieve the motorbike that the <code class="email">motorbikeVehicle</code> represents in the code line <code class="email">sportBike, found := motorbikeVehicle.(Motorbike)</code>, and we must check that the type we have received is correct.</p><p class="calibre10">Finally, now we have a motorbike instance, we can ask for the bike type by using the <code class="email">GetMotorbikeType</code> method. Now we are going to write a test that checks the car factory in the same manner:</p><pre class="programlisting">func TestCarFactory(t *testing.T) { 
    carF, err := BuildFactory(CarFactoryType) 
    if err != nil { 
        t.Fatal(err) 
    } 
 
    carVehicle, err := carF.Build(LuxuryCarType) 
    if err != nil { 
        t.Fatal(err) 
    } 
 
    t.Logf("Car vehicle has %d seats\n", carVehicle.NumWheels()) 
 
    luxuryCar, ok := carVehicle.(Car) 
    if !ok { 
        t.Fatal("Struct assertion has failed") 
    } 
    t.Logf("Luxury car has %d doors.\n", luxuryCar.NumDoors()) 
} 
</pre><p class="calibre10">Again, we use the <code class="email">BuildFactory</code> method to retrieve a <code class="email">Car</code> Factory by using the <code class="email">CarFactoryType</code> in the parameters. With this factory, we want a car of the <code class="email">Luxury</code> type so that it returns a <code class="email">vehicle</code> instance. We again do the type assertion to point to a car instance so that we can ask for the number of doors using the <code class="email">NumDoors</code> method.</p><p class="calibre10">Let's run the unit tests:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=Factory .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestMotorbikeFactory</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestMotorbikeFactory (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        vehicle_factory_test.go:8: Factory with id 2 not recognized</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCarFactory</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestCarFactory (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        vehicle_factory_test.go:28: Factory with id 1 not recognized</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL </strong></span>
</pre><p class="calibre10">Done. It can't recognize any factory as their implementation is still not done.</p></div></div></body></html>