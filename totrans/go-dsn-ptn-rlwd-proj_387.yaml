- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'This is going to be a long example, so pay attention, please. We will have
    the following entities:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将很长的例子，所以请注意。我们将有以下实体：
- en: '**Vehicle**: The interface that all objects in our factories must implement:'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vehicle**：所有我们工厂中的对象都必须实现的接口：'
- en: '**Motorbike**: An interface for motorbikes of the types sport (one seat) and
    cruise (two seats).'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩托车**：一个用于运动型（单座）和巡航型（双座）摩托车的接口。'
- en: '**Car**: An interface for cars of types luxury (with four doors) and family
    (with five doors).'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汽车**：一个用于豪华型（带四个车门）和家庭型（带五个车门）汽车的接口。'
- en: '**VehicleFactory**: An interface (the Abstract Factory) to retrieve factories
    that implement the `VehicleFactory` method:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VehicleFactory**：一个接口（抽象工厂），用于检索实现`VehicleFactory`方法的工厂：'
- en: '**Motorbike** Factory: A factory that implements the `VehicleFactory` interface
    to return vehicle that implements the `Vehicle` and `Motorbike` interfaces.'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩托车**工厂：一个实现`VehicleFactory`接口的工厂，用于返回实现`Vehicle`和`Motorbike`接口的车辆。'
- en: '**Car** Factory: Another factory that implements the `VehicleFactory` interface
    to return vehicles that implement the `Vehicle` and `Car` interfaces.'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汽车**工厂：另一个实现`VehicleFactory`接口的工厂，用于返回实现`Vehicle`和`Car`接口的车辆。'
- en: 'For clarity, we are going to separate each entity into a different file. We
    will start with the `Vehicle` interface, which will be in the `vehicle.go` file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们将每个实体分开到不同的文件中。我们将从`Vehicle`接口开始，它将位于`vehicle.go`文件中：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Car` and `Motorbike` interfaces will be in the `car.go` and `motorbike.go`
    files, respectively:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`和`Motorbike`接口将分别位于`car.go`和`motorbike.go`文件中：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have one last interface, the one that each factory must implement. This
    will be in the `vehicle_factory.go` file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个最后的接口，每个工厂都必须实现。这将位于`vehicle_factory.go`文件中：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, now we are going to declare the car factory. It must implement the `VehicleFactory`
    interface defined previously to return `Vehicles` instances:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们将声明汽车工厂。它必须实现之前定义的`VehicleFactory`接口，以返回`Vehicles`实例：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have defined two types of cars--luxury and family. The `car` Factory will
    have to return cars that implement the `Car` and the `Vehicle` interfaces, so
    we need two concrete implementations:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了两种类型的汽车——豪华型和家庭型。`汽车`工厂必须返回实现`Car`和`Vehicle`接口的汽车，因此我们需要两个具体的实现：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s all for cars. Now we need the motorbike factory, which, like the car
    factory, must implement the `VehicleFactory` interface:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于汽车来说，这些都结束了。现在我们需要摩托车工厂，它，就像汽车工厂一样，必须实现`VehicleFactory`接口：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the motorbike Factory, we have also defined two types of motorbikes using
    the `const` keywords: `SportMotorbikeType` and `CruiseMotorbikeType`. We will
    switch over the `v` argument in the `Build` method to know which type shall be
    returned. Let''s write the two concrete motorbikes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于摩托车工厂，我们也使用`const`关键字定义了两种类型的摩托车：`SportMotorbikeType`和`CruiseMotorbikeType`。我们将通过在`Build`方法中切换`v`参数来知道应该返回哪种类型。让我们编写两个具体的摩托车：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To finish, we need the abstract factory itself, which we will put in the previously
    created `vehicle_factory.go` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要抽象工厂本身，我们将将其放入之前创建的`vehicle_factory.go`文件中：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are going to write enough tests to make a reliable check as the scope of
    the book doesn''t cover 100% of the statements. It will be a good exercise for
    the reader to finish these tests. First, a `motorbike` Factory test:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写足够的测试以确保可靠性检查，因为本书的范围并不涵盖100%的语句。对于读者来说，完成这些测试将是一个很好的练习。首先，一个`摩托车`工厂测试：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the package method, `BuildFactory` , to retrieve a motorbike Factory
    (passing the `MotorbikeFactory` ID in the parameters), and check if we get any
    error. Then, already with the motorbike factory, we ask for a vehicle of the type
    `SportMotorbikeType` and check for errors again. With the returned vehicle, we
    can ask for methods of the vehicle interface (`NumWheels` and `NumSeats`). We
    know that it is a motorbike, but we cannot ask for the type of motorbike without
    using the type assertion. We use the type assertion on the vehicle to retrieve
    the motorbike that the `motorbikeVehicle` represents in the code line `sportBike,
    found := motorbikeVehicle.(Motorbike)`, and we must check that the type we have
    received is correct.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用包方法，`BuildFactory`，来检索一辆摩托车工厂（通过参数传递`MotorbikeFactory` ID），并检查是否有任何错误。然后，已经拥有了摩托车工厂，我们请求一个`SportMotorbikeType`类型的车辆并再次检查错误。有了返回的车辆，我们可以请求车辆接口的方法（`NumWheels`和`NumSeats`）。我们知道它是一辆摩托车，但如果不使用类型断言，我们无法请求摩托车的类型。我们在代码行`sportBike,
    found := motorbikeVehicle.(Motorbike)`中对车辆使用类型断言来检索`motorbikeVehicle`表示的摩托车，并且我们必须检查我们收到的类型是否正确。
- en: 'Finally, now we have a motorbike instance, we can ask for the bike type by
    using the `GetMotorbikeType` method. Now we are going to write a test that checks
    the car factory in the same manner:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们有一个摩托车实例，我们可以使用`GetMotorbikeType`方法请求自行车类型。现在我们将编写一个测试来以相同的方式检查汽车工厂：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, we use the `BuildFactory` method to retrieve a `Car` Factory by using
    the `CarFactoryType` in the parameters. With this factory, we want a car of the `Luxury`
    type so that it returns a `vehicle` instance. We again do the type assertion to
    point to a car instance so that we can ask for the number of doors using the `NumDoors`
    method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用`BuildFactory`方法通过参数中的`CarFactoryType`检索一个`Car`工厂。使用这个工厂，我们想要一个`Luxury`类型的车辆，以便返回一个`vehicle`实例。我们再次进行类型断言，指向一个车辆实例，这样我们就可以使用`NumDoors`方法请求门数。
- en: 'Let''s run the unit tests:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行单元测试：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Done. It can't recognize any factory as their implementation is still not done.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。它无法识别任何工厂，因为它们的实现还没有完成。
