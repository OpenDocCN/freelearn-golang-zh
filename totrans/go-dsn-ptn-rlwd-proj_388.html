<html><head></head><body>
<div class="book" title="Abstract Factory - a factory of factories">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec057" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">The implementation of every factory is already done for the sake of brevity. They are very similar to the Factory method with the only difference being that in the Factory method, we don't use an instance of the Factory method because we use the package functions directly. The implementation of the <code class="email">vehicle</code> Factory is as follows:</p><pre class="programlisting">func BuildFactory(f int) (VehicleFactory, error) { 
    switch f { 
        case CarFactoryType: 
        return new(CarFactory), nil 
        case MotorbikeFactoryType: 
        return new(MotorbikeFactory), nil 
        default: 
        return nil, errors.New(fmt.Sprintf("Factory with id %d not recognized\n", f)) 
    } 
} 
</pre><p class="calibre10">Like in any factory, we switched between the factory possibilities to return the one that was demanded. As we have already implemented all concrete vehicles, the tests must run too:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=Factory -cover .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestMotorbikeFactory</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestMotorbikeFactory (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        vehicle_factory_test.go:16: Motorbike vehicle has 2 wheels</strong></span>
<span class="strong"><strong class="calibre2">        vehicle_factory_test.go:22: Sport motorbike has type 1</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCarFactory</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestCarFactory (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        vehicle_factory_test.go:36: Car vehicle has 4 seats</strong></span>
<span class="strong"><strong class="calibre2">        vehicle_factory_test.go:42: Luxury car has 4 doors.</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">coverage: 45.8% of statements</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">All of them passed. Take a close look and note that we have used the <code class="email">-cover</code> flag when running the tests to return a coverage percentage of the package: 45.8%. What this tells us is that 45.8% of the lines are covered by the tests we have written, but 54.2% are still not under the tests. This is because we haven't covered the cruise motorbike and the family car with the tests. If you write those tests, the result should rise to around 70.8%.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="tip011" class="calibre1"/>Tip</h3><p class="calibre10">Type assertion is also known as <span class="strong"><strong class="calibre2">casting</strong></span> in other languages. When you have an interface instance, which is essentially a pointer to a struct, you just have access to the interface methods. With type assertion, you can tell the compiler the type of the pointed struct, so you can access the entire struct fields and methods.</p></div></div></div></body></html>