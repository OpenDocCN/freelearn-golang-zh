<html><head></head><body>
<div class="book" title="Prototype design pattern">
<div class="book" title="Unit test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec063" class="calibre1"/>Unit test</h2></div></div></div><p class="calibre10">First, we will need a <code class="email">ShirtCloner</code> interface and an object that implements it. Also, we need a package-level function called <code class="email">GetShirtsCloner</code> to retrieve a new instance of the cloner:</p><pre class="programlisting">type ShirtCloner interface { 
    GetClone(s int) (ItemInfoGetter, error) 
} 
 
const ( 
    White = 1 
    Black = 2 
    Blue  = 3 
) 
 
func GetShirtsCloner() ShirtCloner { 
    return nil 
} 
 
type ShirtsCache struct {} 
func (s *ShirtsCache)GetClone(s int) (ItemInfoGetter, error) { 
    return nil, errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">Now we need an object struct to clone, which implements an interface to retrieve the information of its fields. We will call the object <code class="email">Shirt</code> and theÂ <code class="email">ItemInfoGetter</code> interface:</p><pre class="programlisting">type ItemInfoGetter interface { 
    GetInfo() string 
} 
 
type ShirtColor byte 
 
type Shirt struct { 
    Price float32 
    SKU   string 
    Color ShirtColor 
} 
func (s *Shirt) GetInfo()string { 
    return "" 
} 
 
func GetShirtsCloner() ShirtCloner { 
    return nil 
} 
 
var whitePrototype *Shirt = &amp;Shirt{ 
    Price: 15.00, 
    SKU:   "empty", 
    Color: White, 
} 
 
func (i *Shirt) GetPrice() float32 { 
    return i.Price 
} 
</pre><div class="informaltable" title="Note"><h3 class="title2"><a id="tip012" class="calibre1"/>Tip</h3><p class="calibre10">Have you realized that the type called <code class="email">ShirtColor</code> that we defined is just a <code class="email">byte</code> type? Maybe you are wondering why we haven't simply used the byte <code class="email">type</code>. We could, but this way we created an easily readable struct, which we can upgrade with some methods in the future if required. For example, we could write a <code class="email">String()</code> method that returns the color in the string format (<code class="email">White</code> for type 1, <code class="email">Black</code> for type 2, and <code class="email">Blue</code> for type 3).</p></div><p class="calibre10">With this code, we can already write our first tests:</p><pre class="programlisting">func TestClone(t *testing.T) { 
    shirtCache := GetShirtsCloner() 
    if shirtCache == nil { 
        t.Fatal("Received cache was nil") 
    } 
 
    item1, err := shirtCache.GetClone(White) 
    if err != nil { 
        t.Error(err) 
} 

//more code continues here... 
</pre><p class="calibre10">We will cover the first case of our scenario, where we need a cloner object that we can use to ask for different shirt colors.</p><p class="calibre10">For the second case, we will take the original object (which we can access because we are in the scope of the package), and we will compare it with our <code class="email">shirt1</code> instance.</p><pre class="programlisting">if item1 == whitePrototype { 
    t.Error("item1 cannot be equal to the white prototype"); 
} 
</pre><p class="calibre10">Now, for the third case. First, we will type assert <code class="email">item1</code> to a shirt so that we can set an SKU. We will create a second shirt, also white, and we will type assert it too to check that the SKUs are different:</p><pre class="programlisting">shirt1, ok := item1.(*Shirt) 
if !ok { 
    t.Fatal("Type assertion for shirt1 couldn't be done successfully") 
} 
shirt1.SKU = "abbcc" 
 
item2, err := shirtCache.GetClone(White) 
if err != nil { 
    t.Fatal(err) 
} 
 
shirt2, ok := item2.(*Shirt) 
if !ok { 
    t.Fatal("Type assertion for shirt1 couldn't be done successfully") 
} 
 
if shirt1.SKU == shirt2.SKU { 
    t.Error("SKU's of shirt1 and shirt2 must be different") 
} 
 
if shirt1 == shirt2 { 
    t.Error("Shirt 1 cannot be equal to Shirt 2") 
} 
</pre><p class="calibre10">Finally, for the fourth case, we log the info of the first and second shirts:</p><pre class="programlisting">t.Logf("LOG: %s", shirt1.GetInfo()) 
t.Logf("LOG: %s", shirt2.GetInfo()) 
</pre><p class="calibre10">We will be printing the memory positions of both shirts, so we make this assertion at a more physical level:</p><pre class="programlisting">t.Logf("LOG: The memory positions of the shirts are different %p != %p \n\n", &amp;shirt1, &amp;shirt2) 
</pre>Finally, we run the tests so we can check that it fails:
<pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -run=TestClone . 
--- FAIL: TestClone (0.00s) 
prototype_test.go:10: Not implemented yet 
FAIL 
FAIL</strong></span>
</pre><p class="calibre10">We have to stop there so that the tests don't panic if we try to use a nil object that is returned by the <code class="email">GetShirtsCloner</code> function.</p></div></div></body></html>