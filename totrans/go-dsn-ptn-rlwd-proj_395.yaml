- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'First, we will need a `ShirtCloner` interface and an object that implements
    it. Also, we need a package-level function called `GetShirtsCloner` to retrieve
    a new instance of the cloner:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`ShirtCloner`接口以及一个实现该接口的对象。此外，我们还需要一个包级别的函数`GetShirtsCloner`来获取克隆器的新实例：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we need an object struct to clone, which implements an interface to retrieve
    the information of its fields. We will call the object `Shirt` and the `ItemInfoGetter`
    interface:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个对象结构体来克隆，该结构体实现了一个用于检索其字段信息的方法。我们将该对象称为`Shirt`，以及`ItemInfoGetter`接口：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Have you realized that the type called `ShirtColor` that we defined is just
    a `byte` type? Maybe you are wondering why we haven't simply used the byte `type`.
    We could, but this way we created an easily readable struct, which we can upgrade
    with some methods in the future if required. For example, we could write a `String()`
    method that returns the color in the string format (`White` for type 1, `Black`
    for type 2, and `Blue` for type 3).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到我们定义的`ShirtColor`类型实际上只是一个`byte`类型？也许你在想为什么我们没有简单地使用`byte`类型。我们可以这样做，但这样我们创建了一个易于阅读的结构体，如果需要的话，我们可以通过一些方法在未来对其进行升级。例如，我们可以编写一个`String()`方法，该方法以字符串格式返回颜色（类型1为`White`，类型2为`Black`，类型3为`Blue`）。
- en: 'With this code, we can already write our first tests:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们目前已经可以编写我们的第一个测试：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will cover the first case of our scenario, where we need a cloner object
    that we can use to ask for different shirt colors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖我们场景的第一个案例，其中我们需要一个克隆器对象，我们可以用它来请求不同的衬衫颜色。
- en: For the second case, we will take the original object (which we can access because
    we are in the scope of the package), and we will compare it with our `shirt1`
    instance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，我们将使用原始对象（因为我们处于包的作用域内，所以我们可以访问它），并将其与我们的`shirt1`实例进行比较。
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, for the third case. First, we will type assert `item1` to a shirt so that
    we can set an SKU. We will create a second shirt, also white, and we will type
    assert it too to check that the SKUs are different:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于第三种情况。首先，我们将`item1`断言为一件衬衫，这样我们就可以设置一个SKU。我们将创建第二件衬衫，也是白色的，并且我们也将其断言以检查SKU是否不同：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, for the fourth case, we log the info of the first and second shirts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于第四种情况，我们记录第一件和第二件衬衫的信息：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will be printing the memory positions of both shirts, so we make this assertion
    at a more physical level:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打印两件衬衫的内存位置，因此我们在更物理的层面上进行这个断言：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we run the tests so we can check that it fails:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们运行测试以检查它是否失败：
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have to stop there so that the tests don't panic if we try to use a nil object
    that is returned by the `GetShirtsCloner` function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里停止，这样当尝试使用由`GetShirtsCloner`函数返回的nil对象时，测试不会恐慌。
