- en: Description
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: 'In the Composite design pattern, you will create hierarchies and trees of objects.
    Objects have different objects with their own fields and methods inside them.
    This approach is very powerful and solves many problems of inheritance and multiple
    inheritances. For example, a typical inheritance problem is when you have an entity
    that inherits from two completely different classes, which have absolutely no
    relationship between them. Imagine an athlete who trains, and who is a swimmer who
    swims:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合设计模式中，你将创建对象层次结构和树。对象内部有不同的对象，它们有自己的字段和方法。这种方法非常强大，解决了许多继承和多继承的问题。例如，一个典型的继承问题是当你有一个实体从两个完全不同的类中继承，这两个类之间没有任何关系。想象一个训练的运动员，他也是一个游泳者，会游泳：
- en: The `Athlete` class has a `Train()` method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Athlete`类有一个`Train()`方法'
- en: The `Swimmer` class has a `Swim()` method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swimmer`类有一个`Swim()`方法'
- en: The `Swimmer` class inherits from the `Athlete` class, so it inherits its `Train`
    method and declares its own `Swim` method. You could also have a cyclist who is
    also an athlete, and declares a `Ride` method.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swimmer`类继承自`Athlete`类，因此它继承了其`Train`方法并声明了自己的`Swim`方法。你也可以有一个既是运动员又是自行车的骑行者，并声明一个`Ride`方法。'
- en: 'But now imagine an animal that eats, like a dog that also barks:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在想象一个像狗一样会吃也会吠叫的动物：
- en: The `Cyclist` class has a `Ride()` method
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cyclist`类有一个`Ride()`方法'
- en: The `Animal` class has `Eat()`, `Dog()`, and `Bark()` methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animal`类有`Eat()`、`Dog()`和`Bark()`方法'
- en: Nothing fancy. You could also have a fish that is an animal, and yes, swims!
    So, how do you solve it? A fish cannot be a swimmer that also trains. Fish don't
    train (as far as I know!). You could make a `Swimmer` interface with a `Swim`
    method, and make the swimmer athlete and fish implement it. This would be the
    best approach, but you still would have to implement `swim` method twice, so code
    reusability would be affected. What about a triathlete? They are athletes who
    swim, run, and ride. With multiple inheritances, you could have a sort of solution,
    but that will become complex and not maintainable very soon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别之处。你也可以有一个既是动物又是鱼的鱼，是的，它会游泳！那么，你该如何解决这个问题呢？鱼不能既是游泳者又是训练者。据我所知，鱼不会训练！你可以创建一个带有`Swim`方法的`Swimmer`接口，并让游泳运动员和鱼实现它。这将是一个最佳方案，但你仍然需要实现两次`swim`方法，因此代码的可重用性会受到影响。那么，关于铁人三项运动员呢？他们是既游泳又跑步骑行的运动员。使用多继承，你可以有一种解决方案，但很快就会变得复杂且难以维护。
