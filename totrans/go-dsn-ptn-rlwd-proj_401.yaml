- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Composite design pattern, you will create hierarchies and trees of objects.
    Objects have different objects with their own fields and methods inside them.
    This approach is very powerful and solves many problems of inheritance and multiple
    inheritances. For example, a typical inheritance problem is when you have an entity
    that inherits from two completely different classes, which have absolutely no
    relationship between them. Imagine an athlete who trains, and who is a swimmer who
    swims:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Athlete` class has a `Train()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Swimmer` class has a `Swim()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Swimmer` class inherits from the `Athlete` class, so it inherits its `Train`
    method and declares its own `Swim` method. You could also have a cyclist who is
    also an athlete, and declares a `Ride` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now imagine an animal that eats, like a dog that also barks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cyclist` class has a `Ride()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Animal` class has `Eat()`, `Dog()`, and `Bark()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing fancy. You could also have a fish that is an animal, and yes, swims!
    So, how do you solve it? A fish cannot be a swimmer that also trains. Fish don't
    train (as far as I know!). You could make a `Swimmer` interface with a `Swim`
    method, and make the swimmer athlete and fish implement it. This would be the
    best approach, but you still would have to implement `swim` method twice, so code
    reusability would be affected. What about a triathlete? They are athletes who
    swim, run, and ride. With multiple inheritances, you could have a sort of solution,
    but that will become complex and not maintainable very soon.
  prefs: []
  type: TYPE_NORMAL
