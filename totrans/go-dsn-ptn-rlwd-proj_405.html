<html><head></head><body>
<div class="book" title="Chapter&#xA0;3.&#xA0;Structural Patterns - Composite, Adapter, and Bridge Design Patterns">
<div class="book" title="Composite design pattern">
<div class="book" title="Creating compositions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec070" class="calibre1"/>Creating compositions</h2></div></div></div><p class="calibre10">The Composite design pattern is a pure structural pattern, and it doesn't have much to test apart from the structure itself. We won't write unit tests in this case, and we'll simply describe the ways to create those compositions in Go.</p><p class="calibre10">First, we'll start with the <code class="email">Athlete</code> structure and its <code class="email">Train</code> method:</p><pre class="programlisting">type Athlete struct{} 
 
func (a *Athlete) Train() { 
  fmt.Println("Training") 
} 
</pre><p class="calibre10">The preceding code is pretty straightforward. Its <code class="email">Train</code> method prints the word <code class="email">Training</code> and a new line. We'll create a composite swimmer that has an <code class="email">Athlete</code> struct inside it:</p><pre class="programlisting">type CompositeSwimmerA struct{ 
  MyAthlete Athlete 
  MySwim func() 
} 
</pre><p class="calibre10">The <code class="email">CompositeSwimmerA</code> type has a <code class="email">MyAthlete</code> field of type <code class="email">Athlete</code>. It also stores a <code class="email">func()</code> type. Remember that in Go, functions are first-class citizens and they can be used as parameters, fields, or arguments just like any variable. So <code class="email">CompositeSwimmerA</code> has a <code class="email">MySwim</code> field that stores a <span class="strong"><strong class="calibre2">closure</strong></span>, which takes no arguments and returns nothing. How can I assign a function to it? Well, let's create a function that matches the <code class="email">func()</code> signature (no arguments, no return):</p><pre class="programlisting">func Swim(){ 
  fmt.Println("Swimming!") 
} 
</pre><p class="calibre10">That's all! The <code class="email">Swim()</code> function takes no arguments and returns nothing, so it can be used as the <code class="email">MySwim</code> field in the <code class="email">CompositeSwimmerA</code> struct:</p><pre class="programlisting">swimmer := CompositeSwimmerA{ 
  MySwim: Swim, 
} 

swimmer.MyAthlete.Train() 
swimmer.MySwim() 
</pre><p class="calibre10">Because we have a function called <code class="email">Swim()</code>, we can assign it to the <code class="email">MySwim</code> field. Note that the <code class="email">Swim</code> type doesn't have the parenthesis that will execute its contents. This way we take the entire function and copy it to <code class="email">MySwim</code> method.</p><p class="calibre10">But wait. We haven't passed any athlete to the <code class="email">MyAthlete</code> field and we are using it! It's going to fail! Let's see what happens when we execute this snippet:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Training</strong></span>
<span class="strong"><strong class="calibre2">Swimming!</strong></span>
</pre><p class="calibre10">That's weird, isn't it? Not really because of the nature of zero-initialization in Go. If you don't pass an <code class="email">Athlete</code> struct to the <code class="email">CompositeSwimmerA</code> type, the compiler will create one with its values zero-initialized, that is, an <code class="email">Athlete</code> struct with its fields initialized to zero. Check out 
<a class="calibre1" title="Chapter 1. Ready... Steady... Go!" href="part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 1</a>,
<span class="strong"><em class="calibre11"> Ready... Steady... Go!</em></span> to recall zero-initialization if this seems confusing. Consider the <code class="email">CompositeSwimmerA</code> struct code again:</p><pre class="programlisting">type CompositeSwimmerA struct{ 
  MyAthlete Athlete 
  MySwim    func() 
} 
</pre><p class="calibre10">Now we have a pointer to a function stored in the <code class="email">MySwim</code> field. We can assign the <code class="email">Swim</code> function the same way, but with an extra step:</p><pre class="programlisting">localSwim := Swim 
 
swimmer := CompositeSwimmerA{ 
  MySwim: localSwim, 
} 
 
swimmer.MyAthlete.Train() 
swimmer.MySwim () 
</pre><p class="calibre10">First, we need a variable that contains the function <code class="email">Swim</code>. This is because a function doesn't have an address to pass it to the <code class="email">CompositeSwimmerA</code> type. Then, to use this function within the struct, we have to make a two-step call.</p><p class="calibre10">What about our fish problem? With our <code class="email">Swim</code> function, it is not a problem anymore. First, we create the <code class="email">Animal</code> struct:</p><pre class="programlisting">type Animal struct{} 
 
func (r *Animal)Eat() { 
  println("Eating") 
} 
</pre><p class="calibre10">Then we'll create a <code class="email">Shark</code> object that embeds the <code class="email">Animal</code> object:</p><pre class="programlisting">type Shark struct{ 
  Animal 
  Swim func() 
} 
</pre><p class="calibre10">Wait a second! Where is the field name of the <code class="email">Animal</code> type? Did you realize that I used the word <span class="strong"><em class="calibre11">embed</em></span> in the previous paragraph? This is because, in Go, you can also embed objects within objects to make it look a lot like inheritance. That is, we won't have to explicitly call the field name to have access to its fields and method because they'll be part of us. So the following code will be perfectly okay:</p><pre class="programlisting">fish := Shark{ 
  Swim: Swim, 
} 
 
fish.Eat() 
fish.Swim() 
</pre><p class="calibre10">Now we have an <code class="email">Animal</code> type, which is zero-initialized and embedded. This is why I can call the <code class="email">Eat</code> method of the <code class="email">Animal</code> struct without creating it or using the intermediate field name. The output of this snippet is the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go 
Eating 
Swimming!</strong></span>
</pre><p class="calibre10">Finally, there is a third method to use the Composite pattern. We could create a <code class="email">Swimmer</code> interface with a <code class="email">Swim</code> method and a <code class="email">SwimmerImpl</code> type to embed it in the athlete swimmer:</p><pre class="programlisting">type Swimmer interface { 
  Swim() 
} 
type Trainer interface { 
  Train() 
} 
 
type SwimmerImpl struct{} 
func (s *SwimmerImpl) Swim(){ 
  println("Swimming!") 
} 
 
type CompositeSwimmerB struct{ 
  Trainer 
  Swimmer 
} 
</pre><p class="calibre10">With this method, you have more explicit control over object creation. The <code class="email">Swimmer</code> field is embedded, but won't be zero-initialized as it is a pointer to an interface. The correct use of this approach will be the following:</p><pre class="programlisting">swimmer := CompositeSwimmerB{ 
  &amp;Athlete{}, 
  &amp;SwimmerImpl{}, 
} 
 
swimmer.Train() 
swimmer.Swim() 
</pre><p class="calibre10">And the output for <code class="email">CompositeSwimmerB</code> is the following, as expected:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Training</strong></span>
<span class="strong"><strong class="calibre2">Swimming!</strong></span>
</pre><p class="calibre10">Which approach is better? Well, I have a personal preference, which shouldn't be considered the rule of thumb. In my opinion, the <span class="strong"><em class="calibre11">interfaces</em></span> approach is the best for quite a few reasons, but mainly for explicitness. First of all, you are working with interfaces  which are preferred instead of structs. Second, you aren't leaving parts of your code to the zero-initialization feature of the compiler. It's a really powerful feature, but one that must be used with care, because it can lead to runtime problems which you'll find at compile time when working with interfaces. In different situations, zero-initialization will save you at runtime, in fact! But I prefer to work with interfaces as much as possible, so this is not actually one of the options.</p></div></div></div></body></html>