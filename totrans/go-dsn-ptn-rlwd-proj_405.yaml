- en: Creating compositions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建组合
- en: The Composite design pattern is a pure structural pattern, and it doesn't have
    much to test apart from the structure itself. We won't write unit tests in this
    case, and we'll simply describe the ways to create those compositions in Go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复合设计模式是一个纯粹的结构模式，除了结构本身之外，没有太多可以测试的。在这种情况下，我们不会编写单元测试，而只是描述在Go中创建这些组合的方法。
- en: 'First, we''ll start with the `Athlete` structure and its `Train` method:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`Athlete`结构和它的`Train`方法开始：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is pretty straightforward. Its `Train` method prints the
    word `Training` and a new line. We''ll create a composite swimmer that has an
    `Athlete` struct inside it:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码相当直接。它的`Train`方法打印出单词`Training`和换行符。我们将创建一个包含`Athlete`结构体的复合游泳者：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `CompositeSwimmerA` type has a `MyAthlete` field of type `Athlete`. It
    also stores a `func()` type. Remember that in Go, functions are first-class citizens
    and they can be used as parameters, fields, or arguments just like any variable.
    So `CompositeSwimmerA` has a `MySwim` field that stores a **closure**, which takes
    no arguments and returns nothing. How can I assign a function to it? Well, let''s
    create a function that matches the `func()` signature (no arguments, no return):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositeSwimmerA`类型有一个类型为`Athlete`的`MyAthlete`字段。它还存储了一个`func()`类型。记住，在Go中，函数是一等公民，它们可以用作参数、字段或参数，就像任何变量一样。所以`CompositeSwimmerA`有一个存储**闭包**的`MySwim`字段，它不接受任何参数也不返回任何内容。我如何将一个函数分配给它？好吧，让我们创建一个与`func()`签名匹配的函数（没有参数，没有返回值）：'
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s all! The `Swim()` function takes no arguments and returns nothing,
    so it can be used as the `MySwim` field in the `CompositeSwimmerA` struct:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！`Swim()`函数不接受任何参数也不返回任何内容，所以它可以作为`CompositeSwimmerA`结构体中的`MySwim`字段使用：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we have a function called `Swim()`, we can assign it to the `MySwim`
    field. Note that the `Swim` type doesn't have the parenthesis that will execute
    its contents. This way we take the entire function and copy it to `MySwim` method.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有一个名为`Swim()`的函数，我们可以将其分配给`MySwim`字段。请注意，`Swim`类型没有执行其内容的括号。这样我们就将整个函数复制到`MySwim`方法中。
- en: 'But wait. We haven''t passed any athlete to the `MyAthlete` field and we are
    using it! It''s going to fail! Let''s see what happens when we execute this snippet:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。我们还没有将任何运动员传递到`MyAthlete`字段，但我们正在使用它！这将会失败！让我们看看当我们执行这个片段时会发生什么：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s weird, isn''t it? Not really because of the nature of zero-initialization
    in Go. If you don''t pass an `Athlete` struct to the `CompositeSwimmerA` type,
    the compiler will create one with its values zero-initialized, that is, an `Athlete`
    struct with its fields initialized to zero. Check out [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!* to recall zero-initialization
    if this seems confusing. Consider the `CompositeSwimmerA` struct code again:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这很奇怪，不是吗？其实不是，因为Go中零初始化的性质。如果你没有将`Athlete`结构体传递给`CompositeSwimmerA`类型，编译器将创建一个具有其值零初始化的，也就是说，一个字段初始化为零的`Athlete`结构体。查看[第1章](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第1章。准备... 稳定... 开始！")，*准备... 稳定... 开始！*来回忆零初始化，如果这看起来很困惑。再次考虑`CompositeSwimmerA`结构体代码：
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have a pointer to a function stored in the `MySwim` field. We can assign
    the `Swim` function the same way, but with an extra step:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个存储在`MySwim`字段中的函数指针。我们可以以相同的方式分配`Swim`函数，但需要额外一步：
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we need a variable that contains the function `Swim`. This is because
    a function doesn't have an address to pass it to the `CompositeSwimmerA` type.
    Then, to use this function within the struct, we have to make a two-step call.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个包含函数`Swim`的变量。这是因为函数没有地址可以传递给`CompositeSwimmerA`类型。然后，为了在结构体内部使用这个函数，我们必须进行两步调用。
- en: 'What about our fish problem? With our `Swim` function, it is not a problem
    anymore. First, we create the `Animal` struct:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的鱼问题怎么办？有了我们的`Swim`函数，这不再是问题。首先，我们创建`Animal`结构体：
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we''ll create a `Shark` object that embeds the `Animal` object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个嵌入`Animal`对象的`Shark`对象：
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wait a second! Where is the field name of the `Animal` type? Did you realize
    that I used the word *embed* in the previous paragraph? This is because, in Go,
    you can also embed objects within objects to make it look a lot like inheritance.
    That is, we won''t have to explicitly call the field name to have access to its
    fields and method because they''ll be part of us. So the following code will be
    perfectly okay:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！`Animal`类型的字段名在哪里？你意识到我在上一段中使用了“嵌入”这个词吗？这是因为，在Go语言中，你还可以将对象嵌入到对象中，使其看起来很像继承。也就是说，我们不需要显式地调用字段名来访问其字段和方法，因为它们将是我们的一部分。所以下面的代码将完全没问题：
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have an `Animal` type, which is zero-initialized and embedded. This
    is why I can call the `Eat` method of the `Animal` struct without creating it
    or using the intermediate field name. The output of this snippet is the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Animal`类型，它是零初始化并嵌入的。这就是为什么我可以调用`Animal`结构体的`Eat`方法，而无需创建它或使用中间字段名。这个片段的输出如下：
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, there is a third method to use the Composite pattern. We could create
    a `Swimmer` interface with a `Swim` method and a `SwimmerImpl` type to embed it
    in the athlete swimmer:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用组合模式还有第三种方法。我们可以创建一个带有`Swim`方法和一个`SwimmerImpl`类型的`Swimmer`接口，将其嵌入到运动员游泳者中：
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this method, you have more explicit control over object creation. The
    `Swimmer` field is embedded, but won''t be zero-initialized as it is a pointer
    to an interface. The correct use of this approach will be the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你对对象创建有更明确的控制。`Swimmer`字段是嵌入的，但不会像它是一个接口指针那样零初始化。正确使用这种方法的方式如下：
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the output for `CompositeSwimmerB` is the following, as expected:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`CompositeSwimmerB`的输出如下：
- en: '[PRE13]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Which approach is better? Well, I have a personal preference, which shouldn't
    be considered the rule of thumb. In my opinion, the *interfaces* approach is the
    best for quite a few reasons, but mainly for explicitness. First of all, you are
    working with interfaces  which are preferred instead of structs. Second, you aren't
    leaving parts of your code to the zero-initialization feature of the compiler.
    It's a really powerful feature, but one that must be used with care, because it
    can lead to runtime problems which you'll find at compile time when working with
    interfaces. In different situations, zero-initialization will save you at runtime,
    in fact! But I prefer to work with interfaces as much as possible, so this is
    not actually one of the options.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？嗯，我有个人偏好，这不应该被视为规则。在我看来，*接口*方法在许多原因上都是最好的，但主要是为了明确性。首先，你正在使用接口，而不是结构体。其次，你没有将代码的一部分留给编译器的零初始化功能。这是一个非常强大的功能，但必须谨慎使用，因为它可能导致运行时问题，这些问题你会在使用接口时在编译时发现。在不同的情境下，零初始化实际上可以节省你运行时的时间！但我更喜欢尽可能多地使用接口，所以这实际上并不是一个选项。
