- en: Creating compositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Composite design pattern is a pure structural pattern, and it doesn't have
    much to test apart from the structure itself. We won't write unit tests in this
    case, and we'll simply describe the ways to create those compositions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll start with the `Athlete` structure and its `Train` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is pretty straightforward. Its `Train` method prints the
    word `Training` and a new line. We''ll create a composite swimmer that has an
    `Athlete` struct inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CompositeSwimmerA` type has a `MyAthlete` field of type `Athlete`. It
    also stores a `func()` type. Remember that in Go, functions are first-class citizens
    and they can be used as parameters, fields, or arguments just like any variable.
    So `CompositeSwimmerA` has a `MySwim` field that stores a **closure**, which takes
    no arguments and returns nothing. How can I assign a function to it? Well, let''s
    create a function that matches the `func()` signature (no arguments, no return):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! The `Swim()` function takes no arguments and returns nothing,
    so it can be used as the `MySwim` field in the `CompositeSwimmerA` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because we have a function called `Swim()`, we can assign it to the `MySwim`
    field. Note that the `Swim` type doesn't have the parenthesis that will execute
    its contents. This way we take the entire function and copy it to `MySwim` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait. We haven''t passed any athlete to the `MyAthlete` field and we are
    using it! It''s going to fail! Let''s see what happens when we execute this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s weird, isn''t it? Not really because of the nature of zero-initialization
    in Go. If you don''t pass an `Athlete` struct to the `CompositeSwimmerA` type,
    the compiler will create one with its values zero-initialized, that is, an `Athlete`
    struct with its fields initialized to zero. Check out [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!* to recall zero-initialization
    if this seems confusing. Consider the `CompositeSwimmerA` struct code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a pointer to a function stored in the `MySwim` field. We can assign
    the `Swim` function the same way, but with an extra step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we need a variable that contains the function `Swim`. This is because
    a function doesn't have an address to pass it to the `CompositeSwimmerA` type.
    Then, to use this function within the struct, we have to make a two-step call.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about our fish problem? With our `Swim` function, it is not a problem
    anymore. First, we create the `Animal` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll create a `Shark` object that embeds the `Animal` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a second! Where is the field name of the `Animal` type? Did you realize
    that I used the word *embed* in the previous paragraph? This is because, in Go,
    you can also embed objects within objects to make it look a lot like inheritance.
    That is, we won''t have to explicitly call the field name to have access to its
    fields and method because they''ll be part of us. So the following code will be
    perfectly okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an `Animal` type, which is zero-initialized and embedded. This
    is why I can call the `Eat` method of the `Animal` struct without creating it
    or using the intermediate field name. The output of this snippet is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a third method to use the Composite pattern. We could create
    a `Swimmer` interface with a `Swim` method and a `SwimmerImpl` type to embed it
    in the athlete swimmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, you have more explicit control over object creation. The
    `Swimmer` field is embedded, but won''t be zero-initialized as it is a pointer
    to an interface. The correct use of this approach will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output for `CompositeSwimmerB` is the following, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Which approach is better? Well, I have a personal preference, which shouldn't
    be considered the rule of thumb. In my opinion, the *interfaces* approach is the
    best for quite a few reasons, but mainly for explicitness. First of all, you are
    working with interfaces  which are preferred instead of structs. Second, you aren't
    leaving parts of your code to the zero-initialization feature of the compiler.
    It's a really powerful feature, but one that must be used with care, because it
    can lead to runtime problems which you'll find at compile time when working with
    interfaces. In different situations, zero-initialization will save you at runtime,
    in fact! But I prefer to work with interfaces as much as possible, so this is
    not actually one of the options.
  prefs: []
  type: TYPE_NORMAL
