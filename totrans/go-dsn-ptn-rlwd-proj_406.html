<html><head></head><body>
<div class="book" title="Chapter&#xA0;3.&#xA0;Structural Patterns - Composite, Adapter, and Bridge Design Patterns">
<div class="book" title="Composite design pattern">
<div class="book" title="Binary Tree compositions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch03lvl2sec071" class="calibre1"/>Binary Tree compositions</h2></div></div></div><p class="calibre10">Another very common approach to the Composite pattern is when working with Binary Tree structures. In a Binary Tree, you need to store instances of itself in a field:</p><pre class="programlisting">type Tree struct { 
  LeafValue int 
  Right     *Tree 
  Left      *Tree 
} 
</pre><p class="calibre10">This is some kind of recursive compositing, and, because of the nature of recursivity, we must use pointers so that the compiler knows how much memory it must reserve for this struct. Our <code class="email">Tree</code> struct stored a <code class="email">LeafValue</code> object for each instance and a new <code class="email">Tree</code> in its <code class="email">Right</code> and <code class="email">Left</code> fields.</p><p class="calibre10">With this structure, we could create an object like this:</p><pre class="programlisting">root := Tree{ 
  LeafValue: 0, 
  Right:&amp;Tree{ 
    LeafValue: 5, 
    Right: &amp;1Tree{ 6, nil, nil }, 
    Left: nil, 
  }, 
  Left:&amp;Tree{ 4, nil, nil }, 
} 
</pre><p class="calibre10">We can print the contents of its deepest branch like this:</p><pre class="programlisting">fmt.Println(root.Right.Right.LeafValue) 
 
<span class="strong"><strong class="calibre2">$ go run main.go 
6</strong></span>
</pre></div></div></div></body></html>