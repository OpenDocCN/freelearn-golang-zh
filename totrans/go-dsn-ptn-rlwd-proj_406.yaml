- en: Binary Tree compositions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉树组合
- en: 'Another very common approach to the Composite pattern is when working with
    Binary Tree structures. In a Binary Tree, you need to store instances of itself
    in a field:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理组合模式的一个非常常见的方法是在处理二叉树结构时。在二叉树中，你需要在一个字段中存储它自身的实例：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is some kind of recursive compositing, and, because of the nature of recursivity,
    we must use pointers so that the compiler knows how much memory it must reserve
    for this struct. Our `Tree` struct stored a `LeafValue` object for each instance
    and a new `Tree` in its `Right` and `Left` fields.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种递归组合，由于递归的性质，我们必须使用指针，以便编译器知道它必须为这个结构保留多少内存。我们的`Tree`结构为每个实例存储了一个`LeafValue`对象，并在其`Right`和`Left`字段中存储了一个新的`Tree`。
- en: 'With this structure, we could create an object like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，我们可以创建一个像这样的对象：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can print the contents of its deepest branch like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样打印其最深分支的内容：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
