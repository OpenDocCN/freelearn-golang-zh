- en: Composite pattern versus inheritance
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合模式与继承
- en: 'When using the Composite design pattern in Go, you must be very careful not
    to confuse it with inheritance. For example, when you embed a `Parent` struct
    within a `Son` struct, like in the following example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中使用组合设计模式时，你必须非常小心，不要将其与继承混淆。例如，当你将 `Parent` 结构体嵌入到 `Son` 结构体中时，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You cannot consider that the `Son` struct is also the `Parent` struct. What
    this means is that you cannot pass an instance of the `Son` struct to a function
    that is expecting a `Parent` struct like the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能认为 `Son` 结构体也是 `Parent` 结构体。这意味着你不能将 `Son` 结构体的一个实例传递给期望 `Parent` 结构体的函数，如下所示：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you try to pass a `Son` instance to the `GetParentField` method, you will
    get the following error message:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将一个 `Son` 实例传递给 `GetParentField` 方法时，你会得到以下错误信息：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This, in fact, makes a lot of sense. What''s the solution for this? Well, you
    can simply composite the `Son`  struct with the parent without embedding so that
    you can access the `Parent` instance later:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这很有道理。这个问题的解决方案是什么？嗯，你可以简单地将 `Son` 结构体与父结构体组合，而不嵌入，这样你就可以稍后访问 `Parent` 实例：
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So now you could use the `P` field to pass it to the `GetParentField` method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在你可以使用 `P` 字段将其传递给 `GetParentField` 方法：
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
