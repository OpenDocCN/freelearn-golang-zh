<html><head></head><body>
<div class="book" title="Adapter design pattern">
<div class="book" title="Unit testing our Printer adapter"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec078" class="calibre1"/>Unit testing our Printer adapter</h2></div></div></div><p class="calibre10">We will write the legacy code first, but we won't test it as we should imagine that it isn't our code:</p><pre class="programlisting">type LegacyPrinter interface { 
  Print(s string) string 
} 
type MyLegacyPrinter struct {} 
 
func (l *MyLegacyPrinter) Print(s string) (newMsg string) { 
  newMsg = fmt.Sprintf("Legacy Printer: %s\n", s) 
  println(newMsg) 
  return 
} 
</pre><p class="calibre10">The legacy interface called <code class="email">LegacyPrinter</code> has a <code class="email">Print</code> method that accepts a string and returns a message. Our <code class="email">MyLegacyPrinter</code> struct implements the <code class="email">LegacyPrinter</code> interface and modifies the passed string by prefixing the text <code class="email">Legacy Printer:</code>. After modifying the text, the <code class="email">MyLegacyPrinter</code> struct prints the text on the console, and then returns it.</p><p class="calibre10">Now we'll declare the new interface that we'll have to adapt:</p><pre class="programlisting">type ModernPrinter interface { 
  PrintStored() string 
} 
</pre><p class="calibre10">In this case, the new <code class="email">PrintStored</code> method doesn't accept any string as an argument, because it will have to be stored in the implementers in advance. We will call our Adapter pattern's <code class="email">PrinterAdapter</code> interface:</p><pre class="programlisting">type PrinterAdapter struct{ 
  OldPrinter LegacyPrinter 
  Msg        string 
} 
func(p *PrinterAdapter) PrintStored() (newMsg string) { 
  return 
} 
</pre><p class="calibre10">As mentioned earlier, the <code class="email">PrinterAdapter</code> adapter must have a field to store the string to print. It must also have a field to store an instance of the <code class="email">LegacyPrinter</code> adapter. So let's write the unit tests:</p><pre class="programlisting">func TestAdapter(t *testing.T){ 
  msg := "Hello World!" 
</pre><p class="calibre10">We will use the message <code class="email">Hello World!</code> for our adapter. When using this message with an instance of the <code class="email">MyLegacyPrinter</code> struct, it prints the text <code class="email">Legacy Printer: Hello World!</code>:</p><pre class="programlisting">adapter := PrinterAdapter{OldPrinter: &amp;MyLegacyPrinter{}, Msg: msg} 
</pre><p class="calibre10">We created an instance of the <code class="email">PrinterAdapter</code> interface called <code class="email">adapter</code>. We passed an instance of the <code class="email">MyLegacyPrinter</code> struct as the <code class="email">LegacyPrinter</code> field called <code class="email">OldPrinter</code>. Also, we set the message we want to print in the <code class="email">Msg</code> field:</p><pre class="programlisting">returnedMsg := adapter.PrintStored() 

if returnedMsg != "Legacy Printer: Adapter: Hello World!\n" { 
  t.Errorf("Message didn't match: %s\n", returnedMsg) 
} 
</pre><p class="calibre10">Then we used the <code class="email">PrintStored</code> method of the <code class="email">ModernPrinter</code> interface; this method doesn't accept any argument and must return the modified string. We know that the <code class="email">MyLegacyPrinter</code> struct returns the passed string prefixed with the text <code class="email">LegacyPrinter:</code>, and the adapter will prefix it with the text <code class="email">Adapter:</code> So, in the end, we must have the text <code class="email">Legacy Printer: Adapter: Hello World!\n</code>.</p><p class="calibre10">As we are storing an instance of an interface, we must also check that we handle the situation where the pointer is nil. This is done with the following test:</p><pre class="programlisting">adapter = PrinterAdapter{OldPrinter: nil, Msg: msg} 
returnedMsg = adapter.PrintStored() 

if returnedMsg != "Hello World!" { 
  t.Errorf("Message didn't match: %s\n", returnedMsg) 
} 
</pre><p class="calibre10">If we don't pass an instance of the <code class="email">LegacyPrinter</code> interface, the Adapter must ignore its adapt nature, and simply print and return the original message. Time to run our tests; consider the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestAdapter</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestAdapter (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        adapter_test.go:11: Message didn't match: </strong></span>
<span class="strong"><strong class="calibre2">        adapter_test.go:17: Message didn't match: </strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre></div></div></body></html>