- en: Unit testing our Printer adapter
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试我们的打印机适配器
- en: 'We will write the legacy code first, but we won''t test it as we should imagine
    that it isn''t our code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写遗留代码，但我们将不会像应该想象的那样测试它，因为我们认为这不是我们的代码：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The legacy interface called `LegacyPrinter` has a `Print` method that accepts
    a string and returns a message. Our `MyLegacyPrinter` struct implements the `LegacyPrinter` interface
    and modifies the passed string by prefixing the text `Legacy Printer:`. After
    modifying the text, the `MyLegacyPrinter` struct prints the text on the console,
    and then returns it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `LegacyPrinter` 的遗留接口有一个接受字符串并返回消息的 `Print` 方法。我们的 `MyLegacyPrinter` 结构体实现了
    `LegacyPrinter` 接口，并通过在文本前添加 `Legacy Printer:` 前缀来修改传递的字符串。修改文本后，`MyLegacyPrinter`
    结构体在控制台上打印文本，然后返回它。
- en: 'Now we''ll declare the new interface that we''ll have to adapt:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明我们将要适配的新接口：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case, the new `PrintStored` method doesn''t accept any string as an
    argument, because it will have to be stored in the implementers in advance. We
    will call our Adapter pattern''s `PrinterAdapter` interface:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，新的 `PrintStored` 方法不接受任何字符串作为参数，因为它必须事先存储在实现者中。我们将调用我们的适配器模式的 `PrinterAdapter`
    接口：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As mentioned earlier, the `PrinterAdapter` adapter must have a field to store
    the string to print. It must also have a field to store an instance of the `LegacyPrinter`
    adapter. So let''s write the unit tests:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`PrinterAdapter` 适配器必须有一个字段来存储要打印的字符串。它还必须有一个字段来存储 `LegacyPrinter` 适配器的实例。因此，让我们编写单元测试：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will use the message `Hello World!` for our adapter. When using this message
    with an instance of the `MyLegacyPrinter` struct, it prints the text `Legacy Printer:
    Hello World!`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将为适配器使用消息 `Hello World!`。当使用这个消息与 `MyLegacyPrinter` 结构体的一个实例一起时，它打印文本 `Legacy
    Printer: Hello World!`：'
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We created an instance of the `PrinterAdapter` interface called `adapter`.
    We passed an instance of the `MyLegacyPrinter` struct as the `LegacyPrinter` field
    called `OldPrinter`. Also, we set the message we want to print in the `Msg` field:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `adapter` 的 `PrinterAdapter` 接口实例。我们将 `MyLegacyPrinter` 结构体的一个实例作为名为
    `OldPrinter` 的 `LegacyPrinter` 字段传递。此外，我们在 `Msg` 字段中设置了我们想要打印的消息：
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we used the `PrintStored` method of the `ModernPrinter` interface; this
    method doesn''t accept any argument and must return the modified string. We know
    that the `MyLegacyPrinter` struct returns the passed string prefixed with the
    text `LegacyPrinter:`, and the adapter will prefix it with the text `Adapter:`
    So, in the end, we must have the text `Legacy Printer: Adapter: Hello World!\n`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们使用了 `ModernPrinter` 接口的 `PrintStored` 方法；这个方法不接受任何参数，并且必须返回修改后的字符串。我们知道
    `MyLegacyPrinter` 结构体会返回带有文本 `LegacyPrinter:` 的传递字符串，适配器将在这个文本前添加文本 `Adapter:`。因此，最终我们必须有文本
    `Legacy Printer: Adapter: Hello World!\n`。'
- en: 'As we are storing an instance of an interface, we must also check that we handle
    the situation where the pointer is nil. This is done with the following test:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在存储一个接口的实例，我们还必须检查我们是否处理了指针为 nil 的情况。这是通过以下测试完成的：
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we don''t pass an instance of the `LegacyPrinter` interface, the Adapter
    must ignore its adapt nature, and simply print and return the original message.
    Time to run our tests; consider the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有传递 `LegacyPrinter` 接口的一个实例，适配器必须忽略其适配特性，并简单地打印并返回原始消息。现在是运行我们的测试的时候了；考虑以下情况：
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
