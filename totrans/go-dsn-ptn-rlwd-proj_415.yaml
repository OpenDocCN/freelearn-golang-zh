- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'To make our single test pass, we must reuse the old `MyLegacyPrinter` that
    is stored in `PrinterAdapter` struct:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的单个测试通过，我们必须重用存储在 `PrinterAdapter` 结构体中的旧 `MyLegacyPrinter`：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `PrintStored` method, we check whether we actually have an instance of
    a `LegacyPrinter`. In this case, we compose a new string with the stored message
    and the `Adapter` prefix to store it in the returning variable (called `newMsg`).
    Then we use the pointer to the `MyLegacyPrinter` struct to print the composed
    message using the `LegacyPrinter` interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PrintStored` 方法中，我们检查是否实际上有一个 `LegacyPrinter` 的实例。在这种情况下，我们使用存储的消息和 `Adapter`
    前缀组合成一个新的字符串，并将其存储在返回变量（称为 `newMsg`）中。然后我们使用指向 `MyLegacyPrinter` 结构体的指针，通过 `LegacyPrinter`
    接口打印组合后的消息。
- en: 'In case there is no `LegacyPrinter` instance stored in the `OldPrinter` field,
    we simply assign the stored message to the returning variable `newMsg` and return
    the method. This should be enough to pass our tests:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `OldPrinter` 字段中没有存储 `LegacyPrinter` 实例，我们只需将存储的消息赋值给返回变量 `newMsg` 并返回方法。这应该足以通过我们的测试：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Perfect! Now we can still use the old `LegacyPrinter` interface by using this
    `Adapter` while we use the `ModernPrinter` interface for future implementations.
    Just keep in mind that the Adapter pattern must ideally just provide the way to
    use the old `LegacyPrinter` and nothing else. This way, its scope will be more
    encapsulated and more maintainable in the future.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们仍然可以通过使用这个 `Adapter` 来使用旧的 `LegacyPrinter` 接口，同时我们使用 `ModernPrinter`
    接口进行未来的实现。只需记住，适配器模式理想上只应提供使用旧 `LegacyPrinter` 的方式，而无需其他功能。这样，它的作用域将更加封装，并且在未来更容易维护。
