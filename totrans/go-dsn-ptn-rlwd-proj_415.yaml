- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make our single test pass, we must reuse the old `MyLegacyPrinter` that
    is stored in `PrinterAdapter` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the `PrintStored` method, we check whetherÂ we actually have an instance of
    a `LegacyPrinter`. In this case, we compose a new string with the stored message
    and the `Adapter` prefix to store it in the returning variable (called `newMsg`).
    Then we use the pointer to the `MyLegacyPrinter` struct to print the composed
    message using the `LegacyPrinter` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case there is no `LegacyPrinter` instance stored in the `OldPrinter` field,
    we simply assign the stored message to the returning variable `newMsg` and return
    the method. This should be enough to pass our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now we can still use the old `LegacyPrinter` interface by using this
    `Adapter` while we use the `ModernPrinter` interface for future implementations.
    Just keep in mind that the Adapter pattern must ideally just provide the way to
    use the old `LegacyPrinter` and nothing else. This way, its scope will be more
    encapsulated and more maintainable in the future.
  prefs: []
  type: TYPE_NORMAL
