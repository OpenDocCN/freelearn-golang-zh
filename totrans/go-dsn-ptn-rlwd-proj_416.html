<html><head></head><body>
<div class="book" title="Adapter design pattern">
<div class="book" title="Examples of the Adapter pattern in Go's source code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch03lvl2sec080" class="calibre1"/>Examples of the Adapter pattern in Go's source code</h2></div></div></div><p class="calibre10">You can find Adapter implementations at many places in the Go language's source code. The famous <code class="email">http.Handler</code> interface has a very interesting adapter implementation. A very simple, <code class="email">Hello World</code> server in Go is usually done like this:</p><pre class="programlisting">package main 
 
import ( 
    "fmt" 
    "log" 
    "net/http" 
) 
type MyServer struct{ 
  Msg string 
} 
func (m *MyServer) ServeHTTP(w http.ResponseWriter,r *http.Request){ 
  fmt.Fprintf(w, "Hello, World") 
} 
 
func main() { 
  server := &amp;MyServer{ 
  Msg:"Hello, World", 
} 
 
http.Handle("/", server)  
log.Fatal(http.ListenAndServe(":8080", nil)) 
} 
</pre><p class="calibre10">The HTTP package has a function called <code class="email">Handle</code> (like a <code class="email">static</code> method in Java) that accepts two parameters--a string to represent the route and a <code class="email">Handler</code> interface. The <code class="email">Handler</code> interface is like the following:</p><pre class="programlisting">type Handler interface { 
  ServeHTTP(ResponseWriter, *Request) 
} 
</pre><p class="calibre10">We need to implement a <code class="email">ServeHTTP</code> method that the server side of an HTTP connection will use to execute its context. But there is also a function <code class="email">HandlerFunc</code> that allows you to define some endpoint behavior:</p><pre class="programlisting">func main() { 
  http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { 
    fmt.Fprintf(w, "Hello, World") 
  }) 
 
  log.Fatal(http.ListenAndServe(":8080", nil)) 
} 
</pre><p class="calibre10">The <code class="email">HandleFunc</code> function is actually part of an adapter for using functions directly as <code class="email">ServeHTTP</code> implementations. Read the last sentence slowly again--can you guess how it is done?</p><pre class="programlisting">type HandlerFunc func(ResponseWriter, *Request) 
 
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { 
  f(w, r) 
} 
</pre><p class="calibre10">We can define a type that is a function in the same way that we define a struct. We make this function-type to implement the <code class="email">ServeHTTP</code> method. Finally, from the <code class="email">ServeHTTP</code> function, we call the receiver itself <code class="email">f(w, r)</code>.</p><p class="calibre10">You have to think about the implicit interface implementation of Go. When we define a function like <code class="email">func(ResponseWriter, *Request)</code>, it is implicitly being recognized as <code class="email">HandlerFunc</code>. And because the <code class="email">HandleFunc</code> function implements the <code class="email">Handler</code> interface, our function implements the <code class="email">Handler</code> interface implicitly too. Does this sound familiar to you? If <span class="strong"><em class="calibre11">A = B</em></span> and <span class="strong"><em class="calibre11">B = C</em></span>, then <span class="strong"><em class="calibre11">A = C</em></span>. Implicit implementation gives a lot of flexibility and power to Go, but you must also be careful, because you don't know if a method or function could be implementing some interface that could provoke undesirable behaviors.</p><p class="calibre10">We can find more examples in Go's source code. The <code class="email">io</code> package has another powerful example with the use of pipes. A pipe in Linux is a flow mechanism that takes something on the input and outputs something else on the output. The <code class="email">io</code> package has two interfaces, which are used everywhere in Go's source code--the <code class="email">io.Reader</code> and the <code class="email">io.Writer</code> interface:</p><pre class="programlisting">type Reader interface { 
  Read(p []byte) (n int, err error) 
} 
 
type Writer interface { 
  Write(p []byte) (n int, err error) 
} 
</pre><p class="calibre10">We use <code class="email">io.Reader</code> everywhere, for example, when you open a file using <code class="email">os.OpenFile</code>, it returns a file, which, in fact, implements the <code class="email">io.Reader</code> interface. Why is it useful? Imagine that you write a <code class="email">Counter</code> struct that counts from the number you provide to zero:</p><pre class="programlisting">type Counter struct {} 
func (f *Counter) Count(n uint64) uint64 { 
  if n == 0 { 
    println(strconv.Itoa(0)) 
    return 0 
  } 
 
  cur := n 
  println(strconv.FormatUint(cur, 10)) 
  return f.Count(n - 1) 
} 
</pre><p class="calibre10">If you provide the number 3 to this small snippet, it will print the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">3</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
<span class="strong"><strong class="calibre2">1</strong></span>
</pre><p class="calibre10">Well, not really impressive! What if I want to write to a file instead of printing? We can implement this method too. What if I want to print to a file and to the console? Well, we can implement this method too. We must modularize it a bit more by using the <code class="email">io.Writer</code> interface:</p><pre class="programlisting">type Counter struct { 
  Writer io.Writer 
} 
func (f *Counter) Count(n uint64) uint64 { 
  if n == 0 { 
    f.Writer.Write([]byte(strconv.Itoa(0) + "\n")) 
    return 0 
  } 
 
  cur := n 
  f.Writer.Write([]byte(strconv.FormatUint(cur, 10) + "\n")) 
  return f.Count(n - 1) 
}
 
</pre><p class="calibre10">Now we provide an <code class="email">io.Writer</code> in the <code class="email">Writer</code> field. This way, we could create the counter like this: <code class="email">c := Counter{os.Stdout}</code>, and we will get a console <code class="email">Writer</code>. But wait a second, we haven't solved the issue where we wanted to take the count to many <code class="email">Writer</code> consoles. But we can write a new <code class="email">Adapter</code> with an <code class="email">io.Writer</code> and, using a <code class="email">Pipe()</code> to connect a reader with a writer, we can read on the opposite extreme. This way, you can solve the issue where these two interfaces, <code class="email">Reader</code> and <code class="email">Writer</code>, which are incompatible, can be used together.</p><p class="calibre10">In fact, we don't need to write the Adapter--the Go's <code class="email">io</code> library has one for us in <code class="email">io.Pipe()</code>. The pipe will allow us to convert a <code class="email">Reader</code> to a <code class="email">Writer</code> interface. The <code class="email">io.Pipe()</code> method will provide us a <code class="email">Writer</code> (the entrance of the pipe) and a <code class="email">Reader</code> (the exit) to play with. So let's create a pipe, and assign the provided writer to the <code class="email">Counter</code> of the preceding example:</p><pre class="programlisting">pipeReader, pipeWriter := io.Pipe() 
defer pw.Close() 
defer pr.Close() 
 
counter := Counter{ 
  Writer: pipeWriter, 
} 
</pre><p class="calibre10">Now we have a <code class="email">Reader</code> interface where we previously had a <code class="email">Writer</code>. Where can we use the <code class="email">Reader</code>? The <code class="email">io.TeeReader</code> function helps us to copy the stream of data from a <code class="email">Reader</code> interface to the <code class="email">Writer</code> interface and, it returns a new <code class="email">Reader</code> that you can still use to stream data again to a second writer. So we will stream the data from the same reader to two writers--the <code class="email">file</code> and the <code class="email">Stdout</code>.</p><pre class="programlisting">tee := io.TeeReader(pipeReader, file) 
</pre><p class="calibre10">So now we know that we are writing to a file that we have passed to the <code class="email">TeeReader</code> function. We still need to print to the console. The <code class="email">io.Copy</code> adapter can be used like <code class="email">TeeReader</code>--it takes a reader and writes its contents to a writer:</p><pre class="programlisting">go func(){ 
  io.Copy(os.Stdout, tee) 
}() 
</pre><p class="calibre10">We have to launch the <code class="email">Copy</code> function in a different Go routine so that the writes are performed concurrently, and one read/write doesn't block a different read/write. Let's modify the <code class="email">counter</code> variable to make it count till 5 again:</p><pre class="programlisting">counter.Count(5) 
</pre><p class="calibre10">With this modification to the code, we get the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run counter.go</strong></span>
<span class="strong"><strong class="calibre2">5</strong></span>
<span class="strong"><strong class="calibre2">4</strong></span>
<span class="strong"><strong class="calibre2">3</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">0</strong></span>
</pre><p class="calibre10">Okay, the count has been printed on the console. What about the file?</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ cat /tmp/pipe</strong></span>
<span class="strong"><strong class="calibre2">5</strong></span>
<span class="strong"><strong class="calibre2">4</strong></span>
<span class="strong"><strong class="calibre2">3</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">0</strong></span>
</pre><p class="calibre10">Awesome! By using the <code class="email">io.Pipe()</code> adapter provided in the Go native library, we have uncoupled our counter from its output, and we have adapted a <code class="email">Writer</code> interface to a <code class="email">Reader</code> one.</p></div></div></body></html>