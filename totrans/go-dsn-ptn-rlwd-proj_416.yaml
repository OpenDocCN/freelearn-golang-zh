- en: Examples of the Adapter pattern in Go's source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find Adapter implementations at many places in the Go language''s source
    code. The famous `http.Handler` interface has a very interesting adapter implementation.
    A very simple, `Hello World` server in Go is usually done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP package has a function called `Handle` (like a `static` method in
    Java) that accepts two parameters--a string to represent the route and a `Handler`
    interface. The `Handler` interface is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to implement a `ServeHTTP` method that the server side of an HTTP connection
    will use to execute its context. But there is also a function `HandlerFunc` that
    allows you to define some endpoint behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `HandleFunc` function is actually part of an adapter for using functions
    directly as `ServeHTTP` implementations. Read the last sentence slowly again--can
    you guess how it is done?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can define a type that is a function in the same way that we define a struct.
    We make this function-type to implement the `ServeHTTP` method. Finally, from
    the `ServeHTTP` function, we call the receiver itself `f(w, r)`.
  prefs: []
  type: TYPE_NORMAL
- en: You have to think about the implicit interface implementation of Go. When we
    define a function like `func(ResponseWriter, *Request)`, it is implicitly being
    recognized as `HandlerFunc`. And because the `HandleFunc` function implements
    the `Handler` interface, our function implements the `Handler` interface implicitly
    too. Does this sound familiar to you? If *A = B* and *B = C*, then *A = C*. Implicit
    implementation gives a lot of flexibility and power to Go, but you must also be
    careful, because you don't know if a method or function could be implementing
    some interface that could provoke undesirable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find more examples in Go''s source code. The `io` package has another
    powerful example with the use of pipes. A pipe in Linux is a flow mechanism that
    takes something on the input and outputs something else on the output. The `io`
    package has two interfaces, which are used everywhere in Go''s source code--the `io.Reader`
    and the `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `io.Reader` everywhere, for example, when you open a file using `os.OpenFile`,
    it returns a file, which, in fact, implements the `io.Reader` interface. Why is
    it useful? Imagine that you write a `Counter` struct that counts from the number
    you provide to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you provide the number 3 to this small snippet, it will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, not really impressive! What if I want to write to a file instead of printing?
    We can implement this method too. What if I want to print to a file and to the
    console? Well, we can implement this method too. We must modularize it a bit more
    by using the `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we provide an `io.Writer` in the `Writer` field. This way, we could create
    the counter like this: `c := Counter{os.Stdout}`, and we will get a console `Writer`.
    But wait a second, we haven't solved the issue where we wanted to take the count
    to many `Writer` consoles. But we can write a new `Adapter` with an `io.Writer`
    and, using a `Pipe()` to connect a reader with a writer, we can read on the opposite
    extreme. This way, you can solve the issue where these two interfaces, `Reader`
    and `Writer`, which are incompatible, can be used together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we don''t need to write the Adapter--the Go''s `io` library has one
    for us in `io.Pipe()`. The pipe will allow us to convert a `Reader` to a `Writer`
    interface. The `io.Pipe()` method will provide us a `Writer` (the entrance of
    the pipe) and a `Reader` (the exit) to play with. So let''s create a pipe, and
    assign the provided writer to the `Counter` of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `Reader` interface where we previously had a `Writer`. Where can
    we use the `Reader`? The `io.TeeReader` function helps us to copy the stream of
    data from a `Reader` interface to the `Writer` interface and, it returns a new
    `Reader` that you can still use to stream data again to a second writer. So we
    will stream the data from the same reader to two writers--the `file` and the `Stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we know that we are writing to a file that we have passed to the `TeeReader`
    function. We still need to print to the console. The `io.Copy` adapter can be
    used like `TeeReader`--it takes a reader and writes its contents to a writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to launch the `Copy` function in a different Go routine so that the
    writes are performed concurrently, and one read/write doesn''t block a different
    read/write. Let''s modify the `counter` variable to make it count till 5 again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this modification to the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Okay, the count has been printed on the console. What about the file?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! By using the `io.Pipe()` adapter provided in the Go native library,
    we have uncoupled our counter from its output, and we have adapted a `Writer`
    interface to a `Reader` one.
  prefs: []
  type: TYPE_NORMAL
