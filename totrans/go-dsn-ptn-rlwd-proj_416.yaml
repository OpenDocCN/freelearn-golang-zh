- en: Examples of the Adapter pattern in Go's source code
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 源代码中适配器模式的例子
- en: 'You can find Adapter implementations at many places in the Go language''s source
    code. The famous `http.Handler` interface has a very interesting adapter implementation.
    A very simple, `Hello World` server in Go is usually done like this:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Go 语言源代码的许多地方找到适配器实现。著名的 `http.Handler` 接口有一个非常有趣的适配器实现。一个简单的 Go 中的 `Hello
    World` 服务器通常是这样做的：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The HTTP package has a function called `Handle` (like a `static` method in
    Java) that accepts two parameters--a string to represent the route and a `Handler`
    interface. The `Handler` interface is like the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 包有一个名为 `Handle` 的函数（类似于 Java 中的 `static` 方法），它接受两个参数——一个字符串来表示路由和一个 `Handler`
    接口。`Handler` 接口如下：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need to implement a `ServeHTTP` method that the server side of an HTTP connection
    will use to execute its context. But there is also a function `HandlerFunc` that
    allows you to define some endpoint behavior:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个 `ServeHTTP` 方法，服务器端的一个 HTTP 连接将使用它来执行其上下文。但还有一个名为 `HandlerFunc` 的函数，它允许你定义一些端点行为：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `HandleFunc` function is actually part of an adapter for using functions
    directly as `ServeHTTP` implementations. Read the last sentence slowly again--can
    you guess how it is done?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleFunc` 函数实际上是用于直接将函数作为 `ServeHTTP` 实现的适配器的一部分。再慢一点读最后一句话——你能猜到它是怎么做的吗？'
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can define a type that is a function in the same way that we define a struct.
    We make this function-type to implement the `ServeHTTP` method. Finally, from
    the `ServeHTTP` function, we call the receiver itself `f(w, r)`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个类型，就像我们定义一个结构体一样。我们使这个函数类型实现 `ServeHTTP` 方法。最后，从 `ServeHTTP` 函数中，我们调用接收者本身
    `f(w, r)`。
- en: You have to think about the implicit interface implementation of Go. When we
    define a function like `func(ResponseWriter, *Request)`, it is implicitly being
    recognized as `HandlerFunc`. And because the `HandleFunc` function implements
    the `Handler` interface, our function implements the `Handler` interface implicitly
    too. Does this sound familiar to you? If *A = B* and *B = C*, then *A = C*. Implicit
    implementation gives a lot of flexibility and power to Go, but you must also be
    careful, because you don't know if a method or function could be implementing
    some interface that could provoke undesirable behaviors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须考虑 Go 的隐式接口实现。当我们定义一个像 `func(ResponseWriter, *Request)` 这样的函数时，它隐式地被识别为 `HandlerFunc`。因为
    `HandleFunc` 函数实现了 `Handler` 接口，所以我们的函数也隐式地实现了 `Handler` 接口。这听起来熟悉吗？如果 *A = B*
    和 *B = C*，那么 *A = C*。隐式实现给了 Go 很多的灵活性和能力，但你必须也要小心，因为你不知道一个方法或函数是否在实现某个可能会引起不良行为的接口。
- en: 'We can find more examples in Go''s source code. The `io` package has another
    powerful example with the use of pipes. A pipe in Linux is a flow mechanism that
    takes something on the input and outputs something else on the output. The `io`
    package has two interfaces, which are used everywhere in Go''s source code--the `io.Reader`
    and the `io.Writer` interface:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Go 的源代码中找到更多例子。`io` 包使用管道有一个非常强大的例子。Linux 中的管道是一种流机制，它从输入获取一些内容，并在输出输出其他内容。`io`
    包有两个接口，这两个接口在 Go 的源代码中到处使用——`io.Reader` 和 `io.Writer` 接口：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We use `io.Reader` everywhere, for example, when you open a file using `os.OpenFile`,
    it returns a file, which, in fact, implements the `io.Reader` interface. Why is
    it useful? Imagine that you write a `Counter` struct that counts from the number
    you provide to zero:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到处都使用 `io.Reader`，例如，当你使用 `os.OpenFile` 打开一个文件时，它返回一个文件，实际上实现了 `io.Reader`
    接口。为什么它有用呢？想象一下你编写一个 `Counter` 结构体，它从你提供的数字开始计数到零：
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you provide the number 3 to this small snippet, it will print the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向这个小片段提供数字 3，它将打印以下内容：
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Well, not really impressive! What if I want to write to a file instead of printing?
    We can implement this method too. What if I want to print to a file and to the
    console? Well, we can implement this method too. We must modularize it a bit more
    by using the `io.Writer` interface:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，并不那么令人印象深刻！如果我想写入文件而不是打印呢？我们也可以实现这个方法。如果我想同时打印到文件和控制台呢？嗯，我们也可以实现这个方法。我们必须通过使用
    `io.Writer` 接口来进一步模块化它：
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we provide an `io.Writer` in the `Writer` field. This way, we could create
    the counter like this: `c := Counter{os.Stdout}`, and we will get a console `Writer`.
    But wait a second, we haven't solved the issue where we wanted to take the count
    to many `Writer` consoles. But we can write a new `Adapter` with an `io.Writer`
    and, using a `Pipe()` to connect a reader with a writer, we can read on the opposite
    extreme. This way, you can solve the issue where these two interfaces, `Reader`
    and `Writer`, which are incompatible, can be used together.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们提供一个`io.Writer`到`Writer`字段。这样，我们可以创建计数器，如下所示：`c := Counter{os.Stdout}`，我们将得到一个控制台`Writer`。但是等等，我们还没有解决我们想要将计数发送到多个`Writer`控制台的问题。但是我们可以编写一个新的`Adapter`，使用`io.Writer`，并通过使用`Pipe()`连接一个reader和一个writer，我们可以在相反的极端进行读取。这样，你可以解决这两个接口`Reader`和`Writer`不兼容的问题，使它们可以一起使用。
- en: 'In fact, we don''t need to write the Adapter--the Go''s `io` library has one
    for us in `io.Pipe()`. The pipe will allow us to convert a `Reader` to a `Writer`
    interface. The `io.Pipe()` method will provide us a `Writer` (the entrance of
    the pipe) and a `Reader` (the exit) to play with. So let''s create a pipe, and
    assign the provided writer to the `Counter` of the preceding example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要编写适配器--Go的`io`库已经为我们提供了`io.Pipe()`。这个管道将允许我们将`Reader`转换为`Writer`接口。`io.Pipe()`方法将为我们提供一个`Writer`（管道的入口）和一个`Reader`（管道的出口）以供操作。所以让我们创建一个管道，并将提供的writer分配给前面示例中的`Counter`：
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have a `Reader` interface where we previously had a `Writer`. Where can
    we use the `Reader`? The `io.TeeReader` function helps us to copy the stream of
    data from a `Reader` interface to the `Writer` interface and, it returns a new
    `Reader` that you can still use to stream data again to a second writer. So we
    will stream the data from the same reader to two writers--the `file` and the `Stdout`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Reader`接口，之前我们有的是`Writer`。我们可以在哪里使用`Reader`？`io.TeeReader`函数帮助我们从一个`Reader`接口复制数据流到`Writer`接口，并且它返回一个新的`Reader`，你可以用它再次将数据流到一个第二个writer。所以我们将从相同的reader向两个writer流数据--文件和标准输出。
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So now we know that we are writing to a file that we have passed to the `TeeReader`
    function. We still need to print to the console. The `io.Copy` adapter can be
    used like `TeeReader`--it takes a reader and writes its contents to a writer:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道我们正在向传递给`TeeReader`函数的文件中写入。我们仍然需要打印到控制台。`io.Copy`适配器可以像`TeeReader`一样使用--它接受一个reader并将其内容写入writer：
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have to launch the `Copy` function in a different Go routine so that the
    writes are performed concurrently, and one read/write doesn''t block a different
    read/write. Let''s modify the `counter` variable to make it count till 5 again:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在不同的Go协程中启动`Copy`函数，以便并发执行写入操作，一个读写操作不会阻塞另一个读写操作。让我们修改`counter`变量，使其再次计数到5：
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this modification to the code, we get the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行此修改，我们得到以下输出：
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Okay, the count has been printed on the console. What about the file?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，计数已经打印到控制台上了。那么文件呢？
- en: '[PRE13]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Awesome! By using the `io.Pipe()` adapter provided in the Go native library,
    we have uncoupled our counter from its output, and we have adapted a `Writer`
    interface to a `Reader` one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过使用Go原生库中提供的`io.Pipe()`适配器，我们已经将计数器与其输出解耦，并将`Writer`接口适配为`Reader`接口。
