<html><head></head><body>
<div class="book" title="Bridge design pattern">
<div class="book" title="Unit testing the Bridge pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec086" class="calibre1"/>Unit testing the Bridge pattern</h2></div></div></div><p class="calibre10">Let's start with <span class="strong"><em class="calibre11">acceptance criteria 1</em></span>, the <code class="email">PrinterAPI</code> interface. Implementers of this interface must provide a <code class="email">PrintMessage(string)</code> method that will print the message passed as an argument:</p><pre class="programlisting">type PrinterAPI interface { 
  PrintMessage(string) error 
} 
</pre><p class="calibre10">We will pass to <span class="strong"><em class="calibre11">acceptance criteria 2</em></span> with an implementation of the previous API:</p><pre class="programlisting">type PrinterImpl1 struct{} 
 
func (p *PrinterImpl1) PrintMessage(msg string) error { 
  return errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">Our <code class="email">PrinterImpl1</code> is a type that implements the <code class="email">PrinterAPI</code> interface by providing an implementation of the <code class="email">PrintMessage</code> method. The <code class="email">PrintMessage</code> method is not implemented yet, and returns an error. This is enough to write our first unit test to cover <code class="email">PrinterImpl1</code>:</p><pre class="programlisting">func TestPrintAPI1(t *testing.T){ 
  api1 := PrinterImpl1{} 
 
  err := api1.PrintMessage("Hello") 
  if err != nil { 
    t.Errorf("Error trying to use the API1 implementation: Message: %s\n", err.Error()) 
  } 
} 
</pre><p class="calibre10">In our test to cover <code class="email">PrintAPI1</code>, we created an instance of <code class="email">PrinterImpl1</code> type. Then we used its <code class="email">PrintMessage</code> method to print the message <code class="email">Hello</code> to the console. As we have no implementation yet, it must return the error srring <code class="email">Not implemented yet</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestPrintAPI1 . 
=== RUN   TestPrintAPI1 
--- FAIL: TestPrintAPI1 (0.00s) 
        bridge_test.go:14: Error trying to use the API1 implementation: Message: Not implemented yet 
FAIL 
exit status 1 
FAIL    _/C_/Users/mario/Desktop/go-design-patterns/structural/bridge/traditional</strong></span>
</pre><p class="calibre10">Okay. Now we have to write the second API test that will work with an <code class="email">io.Writer</code> interface:</p><pre class="programlisting">type PrinterImpl2 struct{ 
  Writer io.Writer 
} 
 
func (d *PrinterImpl2) PrintMessage(msg string) error { 
  return errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">As you can see, our <code class="email">PrinterImpl2</code> struct stores an <code class="email">io.Writer</code> implementer. Also, our <code class="email">PrintMessage</code> method follows the <code class="email">PrinterAPI</code> interface.</p><p class="calibre10">Now that we are familiar with the <code class="email">io.Writer</code> interface, we are going to make a test object that implements this interface, and stores whatever is written to it in a local field. This will help us check the contents that are being sent through the writer:</p><pre class="programlisting">type TestWriter struct { 
  Msg string 
} 
 
func (t *TestWriter) Write(p []byte) (n int, err error) { 
  n = len(p) 
  if n &gt; 0 { 
    t.Msg = string(p) 
    return n, nil 
  } 
  err = errors.New("Content received on Writer was empty") 
  return 
} 
</pre><p class="calibre10">In our test object, we checked that the content isn't empty before writing it to the local field. If it's empty, we return the error, and if not, we write the contents of <code class="email">p</code> in the <code class="email">Msg</code> field. We will use this small struct in the following tests for the second API:</p><pre class="programlisting">func TestPrintAPI2(t *testing.T){ 
  api2 := PrinterImpl2{} 
 
  err := api2.PrintMessage("Hello") 
  if err != nil { 
    expectedErrorMessage := "You need to pass an io.Writer to PrinterImpl2" 
    if !strings.Contains(err.Error(), expectedErrorMessage) { 
      t.Errorf("Error message was not correct.\n 
      Actual: %s\nExpected: %s\n", err.Error(), expectedErrorMessage) 
    } 
  } 
</pre><p class="calibre10">Let's stop for a second here. We create an instance of <code class="email">PrinterImpl2</code> called <code class="email">api2</code> in the first line of the preceding code. We haven't passed any instance of <code class="email">io.Writer</code> on purpose, so we also checked that we actually receive an error first. Then we try to use its <code class="email">PrintMessage</code> method, but we must get an error because it doesn't have any <code class="email">io.Writer</code> instance stored in the <code class="email">Writer</code> field. The error must be <code class="email">You need to pass an io.Writer to PrinterImpl2</code>, and we implicitly check the contents of the error. Let's continue with the test:</p><pre class="programlisting">  testWriter := TestWriter{} 
  api2 = PrinterImpl2{ 
    Writer: &amp;testWriter, 
  } 
 
  expectedMessage := "Hello" 
  err = api2.PrintMessage(expectedMessage) 
  if err != nil { 
    t.Errorf("Error trying to use the API2 implementation: %s\n", err.Error()) 
  } 
 
  if testWriter.Msg !=  expectedMessage { 
    t.Fatalf("API2 did not write correctly on the io.Writer. \n  Actual: %s\nExpected: %s\n", testWriter.Msg, expectedMessage) 
  } 
} 
</pre><p class="calibre10">For the second part of this unit test, we use an instance of the <code class="email">TestWriter</code> object as an <code class="email">io.Writer</code> interface, <code class="email">testWriter</code>. We passed the message <code class="email">Hello</code> to <code class="email">api2</code>, and checked whether we receive any error. Then, we check the contents of the <code class="email">testWriter.Msg</code> field--remember that we have written an <code class="email">io.Writer</code> interface that stored any bytes passed to its <code class="email">Write</code> method in the <code class="email">Msg</code> field. If everything is correct, the message should contain the word <code class="email">Hello</code>.</p><p class="calibre10">Those were our tests for <code class="email">PrinterImpl2</code>. As we don't have any implementations yet, we should get a few errors when running this test:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestPrintAPI2 .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPrintAPI2</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestPrintAPI2 (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">bridge_test.go:39: Error message was not correct.</strong></span>
<span class="strong"><strong class="calibre2">Actual: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">Expected: You need to pass an io.Writer to PrinterImpl2</strong></span>
<span class="strong"><strong class="calibre2">bridge_test.go:52: Error trying to use the API2 implementation: Not </strong></span>
<span class="strong"><strong class="calibre2">implemented yet</strong></span>
<span class="strong"><strong class="calibre2">bridge_test.go:57: API2 did not write correctly on the io.Writer.</strong></span>
<span class="strong"><strong class="calibre2">Actual:</strong></span>
<span class="strong"><strong class="calibre2">Expected: Hello</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">At least one test passes--the one that checks that an error message (any) is being returned when using the <code class="email">PrintMessage</code> without <code class="email">io.Writer</code> being stored. Everything else fails, as expected at this stage.</p><p class="calibre10">Now we need a printer abstraction for objects that can use <code class="email">PrinterAPI</code> implementers. We will define this as the <code class="email">PrinterAbstraction</code> interface with a <code class="email">Print</code> method. This covers the <span class="strong"><em class="calibre11">acceptance criteria 4</em></span>:</p><pre class="programlisting">type PrinterAbstraction interface { 
  Print() error 
} 
</pre><p class="calibre10">For <span class="strong"><em class="calibre11">acceptance criteria 5</em></span>, we need a normal printer. A <code class="email">Printer</code> abstraction will need a field to store a <code class="email">PrinterAPI</code>. So our the <code class="email">NormalPrinter</code> could look like the following:</p><pre class="programlisting">type NormalPrinter struct { 
  Msg     string 
  Printer PrinterAPI 
} 
 
func (c *NormalPrinter) Print() error { 
  return errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">This is enough to write a unit test for the <code class="email">Print()</code> method:</p><pre class="programlisting">func TestNormalPrinter_Print(t *testing.T) { 
  expectedMessage := "Hello io.Writer" 
 
  normal := NormalPrinter{ 
    Msg:expectedMessage, 
    Printer: &amp;PrinterImpl1{}, 
  } 
 
  err := normal.Print() 
  if err != nil { 
    t.Errorf(err.Error()) 
  } 
} 
</pre><p class="calibre10">The first part of the test checks that the <code class="email">Print()</code> method isn't implemented yet when using <code class="email">PrinterImpl1 PrinterAPI</code> interface. The message we'll use along this test is <code class="email">Hello io.Writer</code>. With the <code class="email">PrinterImpl1,</code> we don't have an easy way to check the contents of the message, as we print directly to the console. Checking, in this case, is visual, so we can check <span class="strong"><em class="calibre11">acceptance criteria 6:</em></span>
</p><pre class="programlisting">  testWriter := TestWriter{} 
  normal = NormalPrinter{ 
    Msg: expectedMessage, 
    Printer: &amp;PrinterImpl2{ 
      Writer:&amp;testWriter, 
    }, 
  } 
 
  err = normal.Print() 
  if err != nil { 
    t.Error(err.Error()) 
  } 
 
  if testWriter.Msg != expectedMessage { 
    t.Errorf("The expected message on the io.Writer doesn't match actual.\n  Actual: %s\nExpected: %s\n", testWriter.Msg, expectedMessage) 
  } 
} 
</pre><p class="calibre10">The second part of <code class="email">NormalPrinter</code> tests uses <code class="email">PrinterImpl2</code>, the one that needs an <code class="email">io.Writer</code> interface implementer. We reuse our <code class="email">TestWriter</code> struct here to check the contents of the message. So, in short, we want a <code class="email">NormalPrinter</code> struct that accepts a <code class="email">Msg</code> of type string and a Printer of type <code class="email">PrinterAPI</code>. At this point, if I use the <code class="email">Print</code> method, I shouldn't get any error, and the <code class="email">Msg</code> field on <code class="email">TestWriter</code> must contain the message we passed to <code class="email">NormalPrinter</code> on its initialization.</p><p class="calibre10">Let's run the tests:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestNormalPrinter_Print .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestNormalPrinter_Print</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestNormalPrinter_Print (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    bridge_test.go:72: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">    bridge_test.go:85: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">    bridge_test.go:89: The expected message on the io.Writer doesn't match actual.</strong></span>
<span class="strong"><strong class="calibre2">             Actual:</strong></span>
<span class="strong"><strong class="calibre2">             Expected: Hello io.Writer</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">There is a trick to quickly check the validity of a unit test--the number of times we called <code class="email">t.Error</code> or <code class="email">t.Errorf</code> must match the number of messages of error on the console and the lines where they were produced. In the preceding test results, there are three errors at <span class="strong"><em class="calibre11">lines 72</em></span>, <span class="strong"><em class="calibre11">85</em></span>, and <span class="strong"><em class="calibre11">89</em></span>, which exactly match the checks we wrote.</p><p class="calibre10">Our <code class="email">PacktPrinter</code> struct will have a very similar definition to <code class="email">NormalPrinter</code> at this point:</p><pre class="programlisting">type PacktPrinter struct { 
  Msg     string 
  Printer PrinterAPI 
} 
 
func (c *PacktPrinter) Print() error { 
  return errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">This covers <span class="strong"><em class="calibre11">acceptance criteria 7</em></span>. And we can almost copy and paste the contents of the previous test with a few changes:</p><pre class="programlisting">func TestPacktPrinter_Print(t *testing.T) { 
  passedMessage := "Hello io.Writer" 
  expectedMessage := "Message from Packt: Hello io.Writer" 
 
  packt := PacktPrinter{ 
    Msg:passedMessage, 
    Printer: &amp;PrinterImpl1{}, 
  } 
 
  err := packt.Print() 
  if err != nil { 
    t.Errorf(err.Error()) 
  } 
 
  testWriter := TestWriter{} 
  packt = PacktPrinter{ 
    Msg: passedMessage, 
    Printer:&amp;PrinterImpl2{ 
      Writer:&amp;testWriter, 
    }, 
  } 
 
  err = packt.Print() 
  if err != nil { 
    t.Error(err.Error()) 
  } 
 
  if testWriter.Msg != expectedMessage { 
    t.Errorf("The expected message on the io.Writer doesn't match actual.\n  Actual: %s\nExpected: %s\n", testWriter.Msg,expectedMessage) 
  } 
} 
</pre><p class="calibre10">What have we changed here? Now we have <code class="email">passedMessage</code>, which represents the message we are passing to <code class="email">PackPrinter</code>. We also have an expected message that contains the prefixed message from <code class="email">Packt</code>. If you remember <span class="strong"><em class="calibre11">acceptance criteria 8</em></span>, this abstraction must prefix the text <code class="email">Message from Packt:</code> to any message that is passed to it, and, at the same time, it must be able to use any implementation of a <code class="email">PrinterAPI</code> interface.</p><p class="calibre10">The second change is that we actually create <code class="email">PacktPrinter</code> structs instead of the <code class="email">NormalPrinter</code> structs; everything else is the same:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestPacktPrinter_Print .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPacktPrinter_Print</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestPacktPrinter_Print (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    bridge_test.go:104: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">    bridge_test.go:117: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">    bridge_test.go:121: The expected message on the io.Writer d</strong></span>
<span class="strong"><strong class="calibre2">oesn't match actual.</strong></span>
<span class="strong"><strong class="calibre2">        Actual:</strong></span>
<span class="strong"><strong class="calibre2">        Expected: Message from Packt: Hello io.Writer</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Three checks, three errors. All tests have been covered, and we can finally move on to the implementation.</p></div></div></body></html>