- en: Unit testing the Bridge pattern
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试桥接模式
- en: 'Let''s start with *acceptance criteria 1*, the `PrinterAPI` interface. Implementers
    of this interface must provide a `PrintMessage(string)` method that will print
    the message passed as an argument:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*验收标准1*，即`PrinterAPI`接口开始。此接口的实现者必须提供一个`PrintMessage(string)`方法，该方法将打印作为参数传递的消息：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will pass to *acceptance criteria 2* with an implementation of the previous
    API:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前API的实现通过*验收标准2*：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our `PrinterImpl1` is a type that implements the `PrinterAPI` interface by
    providing an implementation of the `PrintMessage` method. The `PrintMessage` method
    is not implemented yet, and returns an error. This is enough to write our first
    unit test to cover `PrinterImpl1`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PrinterImpl1`是一个通过提供`PrintMessage`方法的实现来实现`PrinterAPI`接口的类型。`PrintMessage`方法尚未实现，并返回一个错误。这足以编写我们的第一个单元测试来覆盖`PrinterImpl1`：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our test to cover `PrintAPI1`, we created an instance of `PrinterImpl1`
    type. Then we used its `PrintMessage` method to print the message `Hello` to the
    console. As we have no implementation yet, it must return the error srring `Not
    implemented yet`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对`PrintAPI1`的测试中，我们创建了一个`PrinterImpl1`类型的实例。然后我们使用它的`PrintMessage`方法将消息`Hello`打印到控制台。由于我们还没有实现，它必须返回错误字符串`Not
    implemented yet`：
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Okay. Now we have to write the second API test that will work with an `io.Writer`
    interface:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们必须编写第二个API测试，它将使用`io.Writer`接口：
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, our `PrinterImpl2` struct stores an `io.Writer` implementer.
    Also, our `PrintMessage` method follows the `PrinterAPI` interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的`PrinterImpl2`结构体存储了一个`io.Writer`实现者。我们的`PrintMessage`方法遵循`PrinterAPI`接口。
- en: 'Now that we are familiar with the `io.Writer` interface, we are going to make
    a test object that implements this interface, and stores whatever is written to
    it in a local field. This will help us check the contents that are being sent
    through the writer:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了`io.Writer`接口，我们将创建一个实现此接口的测试对象，并将写入的内容存储在本地字段中。这将帮助我们检查通过writer发送的内容：
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our test object, we checked that the content isn''t empty before writing
    it to the local field. If it''s empty, we return the error, and if not, we write
    the contents of `p` in the `Msg` field. We will use this small struct in the following
    tests for the second API:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试对象中，我们在将其写入本地字段之前检查了内容是否为空。如果为空，我们返回错误，如果不为空，我们在`Msg`字段中写入`p`的内容。我们将在以下针对第二个API的测试中使用这个小结构体：
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s stop for a second here. We create an instance of `PrinterImpl2` called
    `api2` in the first line of the preceding code. We haven''t passed any instance
    of `io.Writer` on purpose, so we also checked that we actually receive an error
    first. Then we try to use its `PrintMessage` method, but we must get an error
    because it doesn''t have any `io.Writer` instance stored in the `Writer` field.
    The error must be `You need to pass an io.Writer to PrinterImpl2`, and we implicitly
    check the contents of the error. Let''s continue with the test:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里暂停一下。在前面的代码的第一行中，我们创建了一个名为`PrinterImpl2`的实例`api2`。我们没有故意传递任何`io.Writer`的实例，所以我们首先检查是否确实收到了一个错误。然后我们尝试使用它的`PrintMessage`方法，但我们必须得到一个错误，因为它在`Writer`字段中没有存储任何`io.Writer`实例。错误必须是`You
    need to pass an io.Writer to PrinterImpl2`，并且我们隐式地检查了错误的 内容。让我们继续进行测试：
- en: '[PRE7]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the second part of this unit test, we use an instance of the `TestWriter`
    object as an `io.Writer` interface, `testWriter`. We passed the message `Hello`
    to `api2`, and checked whether we receive any error. Then, we check the contents
    of the `testWriter.Msg` field--remember that we have written an `io.Writer` interface
    that stored any bytes passed to its `Write` method in the `Msg` field. If everything
    is correct, the message should contain the word `Hello`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单元测试的第二部分，我们使用`TestWriter`对象的实例作为`io.Writer`接口，命名为`testWriter`。我们将消息`Hello`传递给`api2`，并检查是否收到任何错误。然后，我们检查`testWriter.Msg`字段的
    内容——记住，我们已经编写了一个存储传递给其`Write`方法的任何字节的`io.Writer`接口，在`Msg`字段中。如果一切正常，消息应该包含单词`Hello`。
- en: 'Those were our tests for `PrinterImpl2`. As we don''t have any implementations
    yet, we should get a few errors when running this test:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那些是我们的`PrinterImpl2`的测试。由于我们还没有任何实现，在运行此测试时应会得到一些错误：
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At least one test passes--the one that checks that an error message (any) is
    being returned when using the `PrintMessage` without `io.Writer` being stored.
    Everything else fails, as expected at this stage.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一个测试通过了——那就是检查在未存储`io.Writer`的情况下使用`PrintMessage`时是否返回错误消息（任何错误）。其他所有测试都如预期的那样失败了。
- en: 'Now we need a printer abstraction for objects that can use `PrinterAPI` implementers.
    We will define this as the `PrinterAbstraction` interface with a `Print` method.
    This covers the *acceptance criteria 4*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个可以使用 `PrinterAPI` 实现者的打印机抽象。我们将定义这个为 `PrinterAbstraction` 接口，其中包含一个
    `Print` 方法。这涵盖了 *验收标准 4*：
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For *acceptance criteria 5*, we need a normal printer. A `Printer` abstraction
    will need a field to store a `PrinterAPI`. So our the `NormalPrinter` could look
    like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *验收标准 5*，我们需要一个普通打印机。`Printer` 抽象需要一个字段来存储 `PrinterAPI`。因此，我们的 `NormalPrinter`
    可能看起来像以下这样：
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is enough to write a unit test for the `Print()` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以编写 `Print()` 方法的单元测试：
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first part of the test checks that the `Print()` method isn't implemented
    yet when using `PrinterImpl1 PrinterAPI` interface. The message we'll use along
    this test is `Hello io.Writer`. With the `PrinterImpl1,` we don't have an easy
    way to check the contents of the message, as we print directly to the console.
    Checking, in this case, is visual, so we can check *acceptance criteria 6:*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一部分检查在使用 `PrinterImpl1 PrinterAPI` 接口时，`Print()` 方法尚未实现。我们将使用 `Hello io.Writer`
    作为这个测试的消息。使用 `PrinterImpl1`，我们没有简单的方法来检查消息的内容，因为我们直接打印到控制台。在这种情况下，检查是可视的，因此我们可以检查
    *验收标准 6*：
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second part of `NormalPrinter` tests uses `PrinterImpl2`, the one that needs
    an `io.Writer` interface implementer. We reuse our `TestWriter` struct here to
    check the contents of the message. So, in short, we want a `NormalPrinter` struct
    that accepts a `Msg` of type string and a Printer of type `PrinterAPI`. At this
    point, if I use the `Print` method, I shouldn't get any error, and the `Msg` field
    on `TestWriter` must contain the message we passed to `NormalPrinter` on its initialization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`NormalPrinter` 测试的第二部分使用 `PrinterImpl2`，它需要一个 `io.Writer` 接口实现者。我们在这里重用我们的
    `TestWriter` 结构体来检查消息的内容。所以，简而言之，我们想要一个接受类型为字符串的 `Msg` 和类型为 `PrinterAPI` 的 `Printer`
    的 `NormalPrinter` 结构体。在这个时候，如果我使用 `Print` 方法，我不应该得到任何错误，并且 `TestWriter` 上的 `Msg`
    字段必须包含我们传递给 `NormalPrinter` 的初始化消息。'
- en: 'Let''s run the tests:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试：
- en: '[PRE13]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is a trick to quickly check the validity of a unit test--the number of
    times we called `t.Error` or `t.Errorf` must match the number of messages of error
    on the console and the lines where they were produced. In the preceding test results,
    there are three errors at *lines 72*, *85*, and *89*, which exactly match the
    checks we wrote.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个技巧可以快速检查单元测试的有效性——我们调用 `t.Error` 或 `t.Errorf` 的次数必须与控制台上错误消息的数量以及它们产生的行数相匹配。在先前的测试结果中，第
    72 行、第 85 行和第 89 行有三种错误，这与我们编写的检查完全一致。
- en: 'Our `PacktPrinter` struct will have a very similar definition to `NormalPrinter`
    at this point:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 `PacktPrinter` 结构体将与 `NormalPrinter` 非常相似：
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This covers *acceptance criteria 7*. And we can almost copy and paste the contents
    of the previous test with a few changes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了 *验收标准 7*。我们几乎可以复制粘贴上一个测试的内容，只需做少许修改：
- en: '[PRE15]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What have we changed here? Now we have `passedMessage`, which represents the
    message we are passing to `PackPrinter`. We also have an expected message that
    contains the prefixed message from `Packt`. If you remember *acceptance criteria
    8*, this abstraction must prefix the text `Message from Packt:` to any message
    that is passed to it, and, at the same time, it must be able to use any implementation
    of a `PrinterAPI` interface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了什么改变？现在我们有 `passedMessage`，它代表我们传递给 `PackPrinter` 的消息。我们还有一个包含来自 `Packt`
    的前缀消息的预期消息。如果你还记得 *验收标准 8*，这个抽象必须将文本 `Message from Packt:` 前缀添加到传递给它的任何消息上，同时它必须能够使用任何
    `PrinterAPI` 接口的实现。
- en: 'The second change is that we actually create `PacktPrinter` structs instead
    of the `NormalPrinter` structs; everything else is the same:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变化是我们实际上创建了 `PacktPrinter` 结构体而不是 `NormalPrinter` 结构体；其他一切保持不变：
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Three checks, three errors. All tests have been covered, and we can finally
    move on to the implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 三次检查，三次错误。所有测试都已覆盖，我们最终可以继续到实现部分。
