- en: Unit testing the Bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with *acceptance criteria 1*, the `PrinterAPI` interface. Implementers
    of this interface must provide a `PrintMessage(string)` method that will print
    the message passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will pass to *acceptance criteria 2* with an implementation of the previous
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `PrinterImpl1` is a type that implements the `PrinterAPI` interface by
    providing an implementation of the `PrintMessage` method. The `PrintMessage` method
    is not implemented yet, and returns an error. This is enough to write our first
    unit test to cover `PrinterImpl1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test to cover `PrintAPI1`, we created an instance of `PrinterImpl1`
    type. Then we used its `PrintMessage` method to print the message `Hello` to the
    console. As we have no implementation yet, it must return the error srring `Not
    implemented yet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. Now we have to write the second API test that will work with an `io.Writer`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `PrinterImpl2` struct stores an `io.Writer` implementer.
    Also, our `PrintMessage` method follows the `PrinterAPI` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are familiar with the `io.Writer` interface, we are going to make
    a test object that implements this interface, and stores whatever is written to
    it in a local field. This will help us check the contents that are being sent
    through the writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test object, we checked that the content isn''t empty before writing
    it to the local field. If it''s empty, we return the error, and if not, we write
    the contents of `p` in the `Msg` field. We will use this small struct in the following
    tests for the second API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s stop for a second here. We create an instance of `PrinterImpl2` called
    `api2` in the first line of the preceding code. We haven''t passed any instance
    of `io.Writer` on purpose, so we also checked that we actually receive an error
    first. Then we try to use its `PrintMessage` method, but we must get an error
    because it doesn''t have any `io.Writer` instance stored in the `Writer` field.
    The error must be `You need to pass an io.Writer to PrinterImpl2`, and we implicitly
    check the contents of the error. Let''s continue with the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For the second part of this unit test, we use an instance of the `TestWriter`
    object as an `io.Writer` interface, `testWriter`. We passed the message `Hello`
    to `api2`, and checked whether we receive any error. Then, we check the contents
    of the `testWriter.Msg` field--remember that we have written an `io.Writer` interface
    that stored any bytes passed to its `Write` method in the `Msg` field. If everything
    is correct, the message should contain the word `Hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those were our tests for `PrinterImpl2`. As we don''t have any implementations
    yet, we should get a few errors when running this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At least one test passes--the one that checks that an error message (any) is
    being returned when using the `PrintMessage` without `io.Writer` being stored.
    Everything else fails, as expected at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a printer abstraction for objects that can use `PrinterAPI` implementers.
    We will define this as the `PrinterAbstraction` interface with a `Print` method.
    This covers the *acceptance criteria 4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For *acceptance criteria 5*, we need a normal printer. A `Printer` abstraction
    will need a field to store a `PrinterAPI`. So our the `NormalPrinter` could look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to write a unit test for the `Print()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the test checks that the `Print()` method isn't implemented
    yet when using `PrinterImpl1 PrinterAPI` interface. The message we'll use along
    this test is `Hello io.Writer`. With the `PrinterImpl1,` we don't have an easy
    way to check the contents of the message, as we print directly to the console.
    Checking, in this case, is visual, so we can check *acceptance criteria 6:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The second part of `NormalPrinter` tests uses `PrinterImpl2`, the one that needs
    an `io.Writer` interface implementer. We reuse our `TestWriter` struct here to
    check the contents of the message. So, in short, we want a `NormalPrinter` struct
    that accepts a `Msg` of type string and a Printer of type `PrinterAPI`. At this
    point, if I use the `Print` method, I shouldn't get any error, and the `Msg` field
    on `TestWriter` must contain the message we passed to `NormalPrinter` on its initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is a trick to quickly check the validity of a unit test--the number of
    times we called `t.Error` or `t.Errorf` must match the number of messages of error
    on the console and the lines where they were produced. In the preceding test results,
    there are three errors at *lines 72*, *85*, and *89*, which exactly match the
    checks we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PacktPrinter` struct will have a very similar definition to `NormalPrinter`
    at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This covers *acceptance criteria 7*. And we can almost copy and paste the contents
    of the previous test with a few changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What have we changed here? Now we have `passedMessage`, which represents the
    message we are passing to `PackPrinter`. We also have an expected message that
    contains the prefixed message from `Packt`. If you remember *acceptance criteria
    8*, this abstraction must prefix the text `Message from Packt:` to any message
    that is passed to it, and, at the same time, it must be able to use any implementation
    of a `PrinterAPI` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second change is that we actually create `PacktPrinter` structs instead
    of the `NormalPrinter` structs; everything else is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Three checks, three errors. All tests have been covered, and we can finally
    move on to the implementation.
  prefs: []
  type: TYPE_NORMAL
