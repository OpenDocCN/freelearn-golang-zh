<html><head></head><body>
<div class="book" title="Bridge design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec087" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">We will start implementing in the same order that we created our tests, first with the <code class="email">PrinterImpl1</code> definition:</p><pre class="programlisting">type PrinterImpl1 struct{} 
func (d *PrinterImpl1) PrintMessage(msg string) error { 
  fmt.Printf("%s\n", msg) 
  return nil 
} 
</pre><p class="calibre10">Our first API takes the message <code class="email">msg</code> and prints it to the console. In the case of an empty string, nothing will be printed. This is enough to pass the first test:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestPrintAPI1 .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPrintAPI1</strong></span>
<span class="strong"><strong class="calibre2">Hello</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestPrintAPI1 (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">You can see the <code class="email">Hello</code> message in the second line of the output of the test, just after the <code class="email">RUN</code> message.</p><p class="calibre10">The <code class="email">PrinterImpl2</code> struct isn't very complex either. The difference is that instead of printing to the console, we are going to write on an <code class="email">io.Writer</code> interface, which must be stored in the struct:</p><pre class="programlisting">type PrinterImpl2 struct { 
  Writer io.Writer 
} 
 
func (d *PrinterImpl2) PrintMessage(msg string) error { 
  if d.Writer == nil { 
    return errors.New("You need to pass an io.Writer to PrinterImpl2") 
  } 
 
  fmt.Fprintf(d.Writer, "%s", msg) 
  return nil 
} 
</pre><p class="calibre10">As defined in our tests, we checked the contents of the <code class="email">Writer</code> field first and returned the expected error message <code class="email">
<span class="strong"><strong class="calibre2">You need to pass an io.Writer to PrinterImpl2</strong></span>
</code>, if nothing is stored. This is the message we'll check later in the test. Then, the <code class="email">fmt.Fprintf</code> method takes an <code class="email">io.Writer</code> interface as the first field and a message formatted as the rest, so we simply forward the contents of the <code class="email">msg</code> argument to the <code class="email">io.Writer</code> provided:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestPrintAPI2 .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPrintAPI2</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestPrintAPI2 (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Now we'll continue with the normal printer. This printer must simply forward the message to the <code class="email">PrinterAPI</code> interface stored without any modification. In our test, we are using two implementations of <code class="email">PrinterAPI</code>--one that prints to the console and one that writes to an <code class="email">io.Writer</code> interface:</p><pre class="programlisting">type NormalPrinter struct { 
  Msg     string 
  Printer PrinterAPI 
} 
 
func (c *NormalPrinter) Print() error { 
  c.Printer.PrintMessage(c.Msg) 
  return nil 
}</pre><p class="calibre10">We returned nil as no error has occurred. This should be enough to pass the unit tests:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestNormalPrinter_Print .
</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestNormalPrinter_Print
</strong></span>
<span class="strong"><strong class="calibre2">Hello io.Writer
</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestNormalPrinter_Print (0.00s)
</strong></span>
<span class="strong"><strong class="calibre2">PASS
</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">In the preceding output, you can see the <code class="email">Hello io.Writer</code> message that the <code class="email">PrinterImpl1</code> struct writes to <code class="email">stdout</code>. We can consider this check as having passed:</p><p class="calibre10">Finally, the <code class="email">PackPrinter</code> method is similar to <code class="email">NormalPrinter</code>, but just prefixes every message with the text <code class="email">Message from Packt:</code> :</p><pre class="programlisting">type PacktPrinter struct { 
  Msg     string 
  Printer PrinterAPI 
} 
 
func (c *PacktPrinter) Print() error { 
  c.Printer.PrintMessage(fmt.Sprintf("Message from Packt: %s", c.Msg)) 
  return nil 
} 
</pre><p class="calibre10">Like in the <code class="email">NormalPrinter</code> method, we accepted a <code class="email">Msg</code> string and a <code class="email">PrinterAPI</code> implementation in the <code class="email">Printer</code> field. Then we used the <code class="email">fmt.Sprintf</code> method to compose a new string with the text <code class="email">Message from Packt:</code> and the provided message. We took the composed text and passed it to the <code class="email">PrintMessage</code> method of <code class="email">PrinterAPI</code> stored in the <code class="email">Printer</code> field of the <code class="email">PacktPrinter</code> struct:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestPacktPrinter_Print .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPacktPrinter_Print</strong></span>
<span class="strong"><strong class="calibre2">Message from Packt: Hello io.Writer</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestPacktPrinter_Print (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Again, you can see the results of using <code class="email">PrinterImpl1</code> for writing to <code class="email">stdout</code> with the text <code class="email">Message from Packt: Hello io.Writer</code>. This last test should cover all of our code in the Bridge pattern. As you have seen previously, you can check the coverage by using the <code class="email">-cover</code> flag:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -cover .</strong></span>
<span class="strong"><strong class="calibre2">ok      
2.622s  coverage: 100.0% of statements</strong></span>
</pre><p class="calibre10">Wow! 100% coverage-this looks good. However, this doesn't mean that the code is perfect. We haven't checked that the contents of the messages weren't empty, maybe something that should be avoided, but it isn't a part of our requirements, which is also an important point. Just because some feature isn't in the requirements or the acceptance criteria doesn't mean that it shouldn't be covered.</p></div></div></body></html>