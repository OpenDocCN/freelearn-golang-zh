- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start implementing in the same order that we created our tests, first
    with the `PrinterImpl1` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first API takes the message `msg` and prints it to the console. In the
    case of an empty string, nothing will be printed. This is enough to pass the first
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `Hello` message in the second line of the output of the test,
    just after the `RUN` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PrinterImpl2` struct isn''t very complex either. The difference is that
    instead of printing to the console, we are going to write on an `io.Writer` interface,
    which must be stored in the struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As defined in our tests, we checked the contents of the `Writer` field first
    and returned the expected error message `**You need to pass an io.Writer to PrinterImpl2**`
    , if nothing is stored. This is the message we''ll check later in the test. Then,
    the `fmt.Fprintf` method takes an `io.Writer` interface as the first field and
    a message formatted as the rest, so we simply forward the contents of the `msg`
    argument to the `io.Writer` provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll continue with the normal printer. This printer must simply forward
    the message to the `PrinterAPI` interface stored without any modification. In
    our test, we are using two implementations of `PrinterAPI`--one that prints to
    the console and one that writes to an `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We returned nil as no error has occurred. This should be enough to pass the
    unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, you can see the `Hello io.Writer` message that the `PrinterImpl1` struct
    writes to `stdout`. We can consider this check as having passed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `PackPrinter` method is similar to `NormalPrinter`, but just prefixes
    every message with the text `Message from Packt:` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in the `NormalPrinter` method, we accepted a `Msg` string and a `PrinterAPI`
    implementation in the `Printer` field. Then we used the `fmt.Sprintf` method to
    compose a new string with the text `Message from Packt:` and the provided message.
    We took the composed text and passed it to the `PrintMessage` method of `PrinterAPI`
    stored in the `Printer` field of the `PacktPrinter` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can see the results of using `PrinterImpl1` for writing to `stdout`
    with the text `Message from Packt: Hello io.Writer`. This last test should cover
    all of our code in the Bridge pattern. As you have seen previously, you can check
    the coverage by using the `-cover` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Wow! 100% coverage-this looks good. However, this doesn't mean that the code
    is perfect. We haven't checked that the contents of the messages weren't empty,
    maybe something that should be avoided, but it isn't a part of our requirements,
    which is also an important point. Just because some feature isn't in the requirements
    or the acceptance criteria doesn't mean that it shouldn't be covered.
  prefs: []
  type: TYPE_NORMAL
