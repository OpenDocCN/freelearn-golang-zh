- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We will start implementing in the same order that we created our tests, first
    with the `PrinterImpl1` definition:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照创建测试的顺序开始实现，首先是 `PrinterImpl1` 的定义：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our first API takes the message `msg` and prints it to the console. In the
    case of an empty string, nothing will be printed. This is enough to pass the first
    test:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个API接受消息 `msg` 并将其打印到控制台。在空字符串的情况下，将不会打印任何内容。这足以通过第一个测试：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see the `Hello` message in the second line of the output of the test,
    just after the `RUN` message.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在测试输出的第二行看到 `Hello` 消息，就在 `RUN` 消息之后。
- en: 'The `PrinterImpl2` struct isn''t very complex either. The difference is that
    instead of printing to the console, we are going to write on an `io.Writer` interface,
    which must be stored in the struct:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrinterImpl2` 结构体也不复杂。区别在于，我们不是打印到控制台，而是将要写入一个 `io.Writer` 接口，这个接口必须存储在结构体中：'
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As defined in our tests, we checked the contents of the `Writer` field first
    and returned the expected error message `**You need to pass an io.Writer to PrinterImpl2**`
    , if nothing is stored. This is the message we''ll check later in the test. Then,
    the `fmt.Fprintf` method takes an `io.Writer` interface as the first field and
    a message formatted as the rest, so we simply forward the contents of the `msg`
    argument to the `io.Writer` provided:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的测试定义，我们首先检查了 `Writer` 字段的内容，如果没有存储任何内容，则返回预期的错误消息 `**你需要向 PrinterImpl2
    传递一个 io.Writer**`。这是我们将在测试中稍后检查的消息。然后，`fmt.Fprintf` 方法将 `io.Writer` 接口作为第一个字段，将格式化的消息作为其余部分，所以我们只需将
    `msg` 参数的内容转发到提供的 `io.Writer`：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we''ll continue with the normal printer. This printer must simply forward
    the message to the `PrinterAPI` interface stored without any modification. In
    our test, we are using two implementations of `PrinterAPI`--one that prints to
    the console and one that writes to an `io.Writer` interface:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续使用正常的打印机。这个打印机必须简单地将消息转发到存储的 `PrinterAPI` 接口，没有任何修改。在我们的测试中，我们使用了 `PrinterAPI`
    的两个实现——一个打印到控制台，另一个写入 `io.Writer` 接口：
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We returned nil as no error has occurred. This should be enough to pass the
    unit tests:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回了 nil，因为没有发生错误。这应该足以通过单元测试：
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding output, you can see the `Hello io.Writer` message that the `PrinterImpl1` struct
    writes to `stdout`. We can consider this check as having passed:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到 `PrinterImpl1` 结构体写入 `stdout` 的 `Hello io.Writer` 消息。我们可以认为这个检查已经通过：
- en: 'Finally, the `PackPrinter` method is similar to `NormalPrinter`, but just prefixes
    every message with the text `Message from Packt:` :'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，`PackPrinter` 方法与 `NormalPrinter` 类似，但只是在每个消息前加上文本 `Message from Packt:`
    :'
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Like in the `NormalPrinter` method, we accepted a `Msg` string and a `PrinterAPI`
    implementation in the `Printer` field. Then we used the `fmt.Sprintf` method to
    compose a new string with the text `Message from Packt:` and the provided message.
    We took the composed text and passed it to the `PrintMessage` method of `PrinterAPI`
    stored in the `Printer` field of the `PacktPrinter` struct:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 `NormalPrinter` 方法中一样，我们在 `Printer` 字段中接受了一个 `Msg` 字符串和一个 `PrinterAPI` 实现然后我们使用了
    `fmt.Sprintf` 方法来组合一个新的字符串，包含文本 `Message from Packt:` 和提供的信息。我们将组合的文本传递给存储在 `PacktPrinter`
    结构体 `Printer` 字段的 `PrintMessage` 方法：
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, you can see the results of using `PrinterImpl1` for writing to `stdout`
    with the text `Message from Packt: Hello io.Writer`. This last test should cover
    all of our code in the Bridge pattern. As you have seen previously, you can check
    the coverage by using the `-cover` flag:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，你可以看到使用 `PrinterImpl1` 将文本 `Message from Packt: Hello io.Writer` 写入 `stdout`
    的结果。这个最后的测试应该覆盖我们桥接模式中的所有代码。正如你之前看到的，你可以使用 `-cover` 标志来检查覆盖率：'
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Wow! 100% coverage-this looks good. However, this doesn't mean that the code
    is perfect. We haven't checked that the contents of the messages weren't empty,
    maybe something that should be avoided, but it isn't a part of our requirements,
    which is also an important point. Just because some feature isn't in the requirements
    or the acceptance criteria doesn't mean that it shouldn't be covered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！100%覆盖率——看起来不错。然而，这并不意味着代码是完美的。我们还没有检查消息的内容是否为空，可能是一些应该避免的东西，但这不是我们的要求的一部分，这也是一个重要的点。仅仅因为某个特性不在要求或验收标准中，并不意味着它不应该被覆盖。
