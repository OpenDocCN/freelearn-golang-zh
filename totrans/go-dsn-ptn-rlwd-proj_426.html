<html><head></head><body><div class="book" title="Summary" id="3IE3G1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec037" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">We have seen the power of composition in this chapter and many of the ways that Go takes advantage of it by its own nature. We have seen that the Adapter pattern can help us make two incompatible interfaces work together by using an <code class="email">Adapter</code> object in between. At the same time, we have seen some real-life examples in Go's source code, where the creators of the language used this design pattern to improve the possibilities of some particular piece of the standard library. Finally, we have seen the Bridge pattern and its possibilities, allowing us to create swapping structures with complete reusability between objects and their implementations.</p><p class="calibre10">Also, we have used the Composite design pattern throughout the chapter, not only when explaining it. We have mentioned it earlier but design patterns make use of each other very frequently. We have used pure composition instead of embedding to increase readability, but, as you have learned, you can use both interchangeably according to your needs. We will keep using the Composite pattern in the following chapters, as it is the foundation for building relationships in the Go programming language.</p></div></body></html>