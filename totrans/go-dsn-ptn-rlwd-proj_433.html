<html><head></head><body>
<div class="book" title="Chapter&#xA0;4.&#xA0;Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design Patterns">
<div class="book" title="Proxy design pattern">
<div class="book" title="Unit test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch04lvl2sec093" class="calibre1"/>Unit test</h2></div></div></div><p class="calibre10">Since version 1.7 of Go, we can embed tests within tests by using closures so we can group them in a more human-readable way, and reduce the number of <code class="email">Test_</code> functions. Refer to <a class="calibre1" title="Chapter 1. Ready... Steady... Go!" href="part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd">
Chapter 1
</a>, <span class="strong"><em class="calibre11">Ready... Steady... Go!</em></span> to learn how to install the new version of Go if your current version is older than version 1.7.</p><p class="calibre10">The types for this pattern will be the proxy user and user list structs as well as a <code class="email">UserFinder</code> interface that the database and the Proxy will implement. This is key because the Proxy must implement the same interfaces as the features of the type it tries to wrap:</p><pre class="programlisting">type UserFinder interface { 
  FindUser(id int32) (User, error) 
} 
</pre><p class="calibre10">The <code class="email">UserFinder</code> is the interface that the database and the Proxy implement. The <code class="email">User</code> is a type with a member called <code class="email">ID</code>, which is <code class="email">int32</code> type:</p><pre class="programlisting">type User struct { 
  ID int32 
} 
</pre><p class="calibre10">Finally, the <code class="email">UserList</code> is a type of a slice of users. Consider the following syntax for that:</p><pre class="programlisting">type UserList []User 
</pre><p class="calibre10">If you are asking why we aren't using a slice of users directly, the answer is that by declaring a sequence of users this way, we can implement the <code class="email">UserFinder</code> interface but with a slice, we can't.</p><p class="calibre10">Finally, the Proxy type, called <code class="email">UserListProxy</code> will be composed of a <code class="email">UserList</code> slice, which will be our database representation. The <code class="email">StackCache</code> members which will also be of <code class="email">UserList</code> type for simplicity, <code class="email">StackCapacity</code> to give our stack the size we want.</p><p class="calibre10">We will cheat a bit for the purpose of this tutorial and declare a Boolean state on a field called <code class="email">DidDidLastSearchUsedCache</code> that will hold if the last performed search has used the cache, or has accessed the database:</p><pre class="programlisting">type UserListProxy struct { 
  SomeDatabase UserList 
  StackCache UserList 
  StackCapacity int 
  DidDidLastSearchUsedCache bool 
} 
 
func (u *UserListProxy) FindUser(id int32) (User, error) { 
  return User{}, errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">The <code class="email">UserListProxy</code> type will cache a maximum of <code class="email">StackCapacity</code> users, and rotate the cache if it reaches this limit. The <code class="email">StackCache</code> members will be populated from objects from <code class="email">SomeDatabase</code> type.</p><p class="calibre10">The first test is called <code class="email">TestUserListProxy</code>, and is listed next:</p><pre class="programlisting">import ( 
   "math/rand" 
   "testing" 
) 
 
func Test_UserListProxy(t *testing.T) { 
  someDatabase := UserList{} 
 
  rand.Seed(2342342) 
  for i := 0; i &lt; 1000000; i++ { 
    n := rand.Int31() 
    someDatabase = append(someDatabase, User{ID: n}) 
  } 
</pre><p class="calibre10">The preceding test creates a user list of 1 million users with random names. To do so, we feed the random number generator by calling the <code class="email">Seed()</code> function with some constant seed so our randomized results are also constant; and the user IDs are generated from it. It might have some duplicates, but it serves our purpose.</p><p class="calibre10">Next, we need a proxy with a reference to <code class="email">someDatabase</code>, which we have just created:</p><pre class="programlisting">proxy := UserListProxy{ 
  SomeDatabase:  &amp;someDatabase, 
  StackCapacity:  2, 
  StackCache: UserList{}, 
} 
</pre><p class="calibre10">At this point, we have a <code class="email">proxy</code> object composed of a mock database with 1 million users, and a cache implemented as a FIFO stack with a size of 2. Now we will get three random IDs from <code class="email">someDatabase</code> to use in our stack:</p><pre class="programlisting">knownIDs := [3]int32 {someDatabase[3].ID, someDatabase[4].ID,someDatabase[5].ID} 
</pre><p class="calibre10">We took the fourth, fifth, and sixth IDs from the slice (remember that arrays and slices start with 0, so the index 3 is actually the fourth position in the slice).</p><p class="calibre10">This is going to be our starting point before launching the embedded tests. To create an embedded test, we have to call the <code class="email">Run</code> method of the <code class="email">testing.T</code> pointer, with a description and a closure with the <code class="email">func(t *testing.T)</code> signature: </p><pre class="programlisting">t.Run("FindUser - Empty cache", func(t *testing.T) { 
  user, err := proxy.FindUser(knownIDs[0]) 
  if err != nil { 
    t.Fatal(err) 
  } 
</pre><p class="calibre10">For example, in the preceding code snippet, we give the description <code class="email">FindUser - Empty cache</code>. Then we define our closure. First it tries to find a user with a known ID, and checks for errors. As the description implies, the cache is empty at this point, and the user will have to be retrieved from the <code class="email">someDatabase</code> array:</p><pre class="programlisting">  if user.ID != knownIDs[0] { 
    t.Error("Returned user name doesn't match with expected") 
  } 

  if len(proxy.StackCache) != 1 { 
    t.Error("After one successful search in an empty cache, the size of it must be one") 
  } 
 
  if proxy.DidLastSearchUsedCache { 
    t.Error("No user can be returned from an empty cache") 
  } 
} 
</pre><p class="calibre10">Finally, we check whether the returned user has the same ID as that of the expected user at index 0 of the <code class="email">knownIDs</code> slice, and that the proxy cache now has a size of 1. The state of the member <code class="email">DidLastSearchUsedCache</code> proxy must not be <code class="email">true</code>, or we will not pass the test. Remember, this member tells us whether the last search has been retrieved from the slice that represents a database, or from the cache.</p><p class="calibre10">The second embedded test for the Proxy pattern is to ask for the same user as before, which must now be returned from the cache. It's very similar to the previous test, but now we have to check if the user is returned from the cache:</p><pre class="programlisting">t.Run("FindUser - One user, ask for the same user", func(t *testing.T) { 
  user, err := proxy.FindUser(knownIDs[0]) 
  if err != nil { 
    t.Fatal(err) 
  } 
 
  if user.ID != knownIDs[0] { 
    t.Error("Returned user name doesn't match with expected") 
  } 
 
  if len(proxy.StackCache) != 1 { 
    t.Error("Cache must not grow if we asked for an object that is stored on it") 
  } 
 
  if !proxy.DidLastSearchUsedCache { 
    t.Error("The user should have been returned from the cache") 
  } 
}) 
</pre><p class="calibre10">So, again we ask for the first known ID. The proxy cache must maintain a size of 1 after this search, and the <code class="email">DidLastSearchUsedCache</code> member must be true this time, or the test will fail.</p><p class="calibre10">The last test will overflow the <code class="email">StackCache</code> array on the <code class="email">proxy</code> type. We will search for two new users that our <code class="email">proxy</code> type will have to retrieve from the database. Our stack has a size of 2, so it will have to remove the first user to allocate space for the second and third users:</p><pre class="programlisting">user1, err := proxy.FindUser(knownIDs[0]) 
if err != nil { 
  t.Fatal(err) 
} 
 
user2, _ := proxy.FindUser(knownIDs[1]) 
if proxy.DidLastSearchUsedCache { 
  t.Error("The user wasn't stored on the proxy cache yet") 
} 
 
user3, _ := proxy.FindUser(knownIDs[2]) 
if proxy.DidLastSearchUsedCache { 
  t.Error("The user wasn't stored on the proxy cache yet") 
} 
</pre><p class="calibre10">We have retrieved the first three users. We aren't checking for errors because that was the purpose of the previous tests. This is important to recall that there is no need to over-test your code. If there is any error here, it will arise in the previous tests. Also, we have checked that the <code class="email">user2</code> and <code class="email">user3</code> queries do not use the cache; they shouldn't be stored there yet.</p><p class="calibre10">Now we are going to look for the <code class="email">user1</code> query in the Proxy. It shouldn't exist, as the stack has a size of 2, and <code class="email">user1</code> was the first to enter, hence, the first to go out:</p><pre class="programlisting">for i := 0; i &lt; len(proxy.StackCache); i++ { 
  if proxy.StackCache[i].ID == user1.ID { 
    t.Error("User that should be gone was found") 
  } 
} 
 
if len(proxy.StackCache) != 2 { 
  t.Error("After inserting 3 users the cache should not grow" + 
" more than to two") 
} 
</pre><p class="calibre10">It doesn't matter if we ask for a thousand users; our cache can't be bigger than our configured size.</p><p class="calibre10">Finally, we are going to again range over the users stored in the cache, and compare them with the last two we queried. This way, we will check that just those users are stored in the cache. Both must be found on it:</p><pre class="programlisting">  for _, v := range proxy.StackCache { 
    if v != user2 &amp;&amp; v != user3 { 
      t.Error("A non expected user was found on the cache") 
    } 
  } 
} 
</pre><p class="calibre10">Running the tests now should give some errors, as usual. Let's run them now:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_UserListProxy</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_UserListProxy/FindUser_-_Empty_cache</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: Test_UserListProxy (0.06s)</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        proxy_test.go:28: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        proxy_test.go:47: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        proxy_test.go:66: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">So, let's implement the <code class="email">FindUser</code> method to act as our Proxy.</p></div></div></div></body></html>