["```go\ntype UserFinder interface { \n  FindUser(id int32) (User, error) \n} \n\n```", "```go\ntype User struct { \n  ID int32 \n} \n\n```", "```go\ntype UserList []User \n\n```", "```go\ntype UserListProxy struct { \n  SomeDatabase UserList \n  StackCache UserList \n  StackCapacity int \n  DidDidLastSearchUsedCache bool \n} \n\nfunc (u *UserListProxy) FindUser(id int32) (User, error) { \n  return User{}, errors.New(\"Not implemented yet\") \n} \n\n```", "```go\nimport ( \n   \"math/rand\" \n   \"testing\" \n) \n\nfunc Test_UserListProxy(t *testing.T) { \n  someDatabase := UserList{} \n\n  rand.Seed(2342342) \n  for i := 0; i < 1000000; i++ { \n    n := rand.Int31() \n    someDatabase = append(someDatabase, User{ID: n}) \n  } \n\n```", "```go\nproxy := UserListProxy{ \n  SomeDatabase:  &someDatabase, \n  StackCapacity:  2, \n  StackCache: UserList{}, \n} \n\n```", "```go\nknownIDs := [3]int32 {someDatabase[3].ID, someDatabase[4].ID,someDatabase[5].ID} \n\n```", "```go\nt.Run(\"FindUser - Empty cache\", func(t *testing.T) { \n  user, err := proxy.FindUser(knownIDs[0]) \n  if err != nil { \n    t.Fatal(err) \n  } \n\nFindUser - Empty cache. Then we define our closure. First it tries to find a user with a known ID, and checks for errors. As the description implies, the cache is empty at this point, and the user will have to be retrieved from the someDatabase array:\n```", "```go\n  if user.ID != knownIDs[0] { \n    t.Error(\"Returned user name doesn't match with expected\") \n  } \n\n  if len(proxy.StackCache) != 1 { \n    t.Error(\"After one successful search in an empty cache, the size of it must be one\") \n  } \n\n  if proxy.DidLastSearchUsedCache { \n    t.Error(\"No user can be returned from an empty cache\") \n  } \n} \n\n```", "```go\nt.Run(\"FindUser - One user, ask for the same user\", func(t *testing.T) { \n  user, err := proxy.FindUser(knownIDs[0]) \n  if err != nil { \n    t.Fatal(err) \n  } \n\n  if user.ID != knownIDs[0] { \n    t.Error(\"Returned user name doesn't match with expected\") \n  } \n\n  if len(proxy.StackCache) != 1 { \n    t.Error(\"Cache must not grow if we asked for an object that is stored on it\") \n  } \n\n  if !proxy.DidLastSearchUsedCache { \n    t.Error(\"The user should have been returned from the cache\") \n  } \n}) \n\n```", "```go\nuser1, err := proxy.FindUser(knownIDs[0]) \nif err != nil { \n  t.Fatal(err) \n} \n\nuser2, _ := proxy.FindUser(knownIDs[1]) \nif proxy.DidLastSearchUsedCache { \n  t.Error(\"The user wasn't stored on the proxy cache yet\") \n} \n\nuser3, _ := proxy.FindUser(knownIDs[2]) \nif proxy.DidLastSearchUsedCache { \n  t.Error(\"The user wasn't stored on the proxy cache yet\") \n} \n\n```", "```go\nfor i := 0; i < len(proxy.StackCache); i++ { \n  if proxy.StackCache[i].ID == user1.ID { \n    t.Error(\"User that should be gone was found\") \n  } \n} \n\nif len(proxy.StackCache) != 2 { \n  t.Error(\"After inserting 3 users the cache should not grow\" + \n\" more than to two\") \n} \n\n```", "```go\n  for _, v := range proxy.StackCache { \n    if v != user2 && v != user3 { \n      t.Error(\"A non expected user was found on the cache\") \n    } \n  } \n} \n\n```", "```go\n$ go test -v .\n=== RUN   Test_UserListProxy\n=== RUN   Test_UserListProxy/FindUser_-_Empty_cache\n=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user\n=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack\n--- FAIL: Test_UserListProxy (0.06s)\n --- FAIL: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)\n proxy_test.go:28: Not implemented yet\n --- FAIL: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)\n proxy_test.go:47: Not implemented yet\n --- FAIL: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)\n proxy_test.go:66: Not implemented yet\nFAIL\nexit status 1\nFAIL\n\n```"]