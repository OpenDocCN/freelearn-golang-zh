- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Since version 1.7 of Go, we can embed tests within tests by using closures so
    we can group them in a more human-readable way, and reduce the number of `Test_`
    functions. Refer to [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!") , *Ready... Steady... Go!* to learn how to
    install the new version of Go if your current version is older than version 1.7.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自Go 1.7版本以来，我们可以通过使用闭包在测试中嵌入测试，这样我们可以以更易于阅读的方式分组它们，并减少 `Test_` 函数的数量。请参阅[第1章](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第1章。准备... 就绪... 开始！")，*准备... 就绪... 开始！*了解如果您的当前版本早于1.7版本，如何安装Go的新版本。
- en: 'The types for this pattern will be the proxy user and user list structs as
    well as a `UserFinder` interface that the database and the Proxy will implement.
    This is key because the Proxy must implement the same interfaces as the features
    of the type it tries to wrap:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的类型将是代理用户和用户列表结构以及数据库和Proxy将实现的 `UserFinder` 接口。这是关键，因为Proxy必须实现与它试图包装的类型相同的接口：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `UserFinder` is the interface that the database and the Proxy implement.
    The `User` is a type with a member called `ID`, which is `int32` type:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserFinder` 是数据库和Proxy实现的接口。`User` 是一个具有名为 `ID` 的成员的类型，其类型为 `int32`：'
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, the `UserList` is a type of a slice of users. Consider the following
    syntax for that:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`UserList` 是用户切片的类型。考虑以下语法：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are asking why we aren't using a slice of users directly, the answer
    is that by declaring a sequence of users this way, we can implement the `UserFinder`
    interface but with a slice, we can't.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问为什么我们不直接使用用户切片，答案是：通过这种方式声明用户序列，我们可以实现 `UserFinder` 接口，但如果我们使用切片，则不能。
- en: Finally, the Proxy type, called `UserListProxy` will be composed of a `UserList`
    slice, which will be our database representation. The `StackCache` members which
    will also be of `UserList` type for simplicity, `StackCapacity` to give our stack
    the size we want.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，名为 `UserListProxy` 的Proxy类型将由 `UserList` 切片组成，这将是我们的数据库表示。为了简单起见，`StackCache`
    成员也将是 `UserList` 类型，`StackCapacity` 以给我们的栈赋予我们想要的大小。
- en: 'We will cheat a bit for the purpose of this tutorial and declare a Boolean
    state on a field called `DidDidLastSearchUsedCache` that will hold if the last
    performed search has used the cache, or has accessed the database:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本教程的目的，我们将稍微作弊一下，在名为 `DidDidLastSearchUsedCache` 的字段上声明一个布尔状态，该字段将保存最后一次执行搜索是否使用了缓存，或者是否访问了数据库：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UserListProxy` type will cache a maximum of `StackCapacity` users, and
    rotate the cache if it reaches this limit. The `StackCache` members will be populated
    from objects from `SomeDatabase` type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserListProxy` 类型将缓存最多 `StackCapacity` 个用户，并在达到此限制时旋转缓存。`StackCache` 成员将从
    `SomeDatabase` 类型的对象中填充。'
- en: 'The first test is called `TestUserListProxy`, and is listed next:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试称为 `TestUserListProxy`，并列在下面：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding test creates a user list of 1 million users with random names.
    To do so, we feed the random number generator by calling the `Seed()` function
    with some constant seed so our randomized results are also constant; and the user
    IDs are generated from it. It might have some duplicates, but it serves our purpose.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试创建了一个包含1百万用户且具有随机名称的用户列表。为此，我们通过调用带有某些常量种子的 `Seed()` 函数来喂养随机数生成器，以便我们的随机结果也是恒定的；用户ID由此生成。可能会有一些重复，但这符合我们的目的。
- en: 'Next, we need a proxy with a reference to `someDatabase`, which we have just
    created:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个具有对 `someDatabase` 引用的代理，这是我们刚刚创建的：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, we have a `proxy` object composed of a mock database with 1 million
    users, and a cache implemented as a FIFO stack with a size of 2\. Now we will
    get three random IDs from `someDatabase` to use in our stack:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个由1百万用户组成的模拟数据库和一个大小为2的FIFO栈实现的缓存`proxy`对象。现在我们将从 `someDatabase` 中获取三个随机ID用于我们的栈：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We took the fourth, fifth, and sixth IDs from the slice (remember that arrays
    and slices start with 0, so the index 3 is actually the fourth position in the
    slice).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从切片中取了第四、第五和第六个ID（记住数组和切片从0开始，所以索引3实际上是切片中的第四个位置）。
- en: 'This is going to be our starting point before launching the embedded tests.
    To create an embedded test, we have to call the `Run` method of the `testing.T`
    pointer, with a description and a closure with the `func(t *testing.T)` signature:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是启动嵌入式测试之前的起点。为了创建一个嵌入式测试，我们必须调用 `testing.T` 指针的 `Run` 方法，并带有描述和具有 `func(t
    *testing.T)` 签名的闭包：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, we check whether the returned user has the same ID as that of the expected
    user at index 0 of the `knownIDs` slice, and that the proxy cache now has a size
    of 1\. The state of the member `DidLastSearchUsedCache` proxy must not be `true`,
    or we will not pass the test. Remember, this member tells us whether the last
    search has been retrieved from the slice that represents a database, or from the
    cache.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查返回的用户是否与`knownIDs`切片中索引为0的预期用户具有相同的ID，并且代理缓存现在的大小为1。代理成员`DidLastSearchUsedCache`的状态必须不为`true`，否则我们将不会通过测试。记住，这个成员告诉我们最后一次搜索是从表示数据库的切片中检索的，还是从缓存中检索的。
- en: 'The second embedded test for the Proxy pattern is to ask for the same user
    as before, which must now be returned from the cache. It''s very similar to the
    previous test, but now we have to check if the user is returned from the cache:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的第二次内嵌测试是要求与之前相同的用户，现在必须从缓存中返回。这与之前的测试非常相似，但现在我们必须检查用户是否是从缓存中返回的：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, again we ask for the first known ID. The proxy cache must maintain a size
    of 1 after this search, and the `DidLastSearchUsedCache` member must be true this
    time, or the test will fail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们再次请求第一个已知的ID。在这次搜索之后，代理缓存必须保持大小为1，并且这次`DidLastSearchUsedCache`成员必须为true，否则测试将失败。
- en: 'The last test will overflow the `StackCache` array on the `proxy` type. We
    will search for two new users that our `proxy` type will have to retrieve from
    the database. Our stack has a size of 2, so it will have to remove the first user
    to allocate space for the second and third users:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试将溢出`proxy`类型的`StackCache`数组。我们将搜索两个新的用户，我们的`proxy`类型将不得不从数据库中检索这些用户。我们的栈大小为2，因此它必须移除第一个用户为第二个和第三个用户腾出空间：
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have retrieved the first three users. We aren't checking for errors because
    that was the purpose of the previous tests. This is important to recall that there
    is no need to over-test your code. If there is any error here, it will arise in
    the previous tests. Also, we have checked that the `user2` and `user3` queries
    do not use the cache; they shouldn't be stored there yet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检索了前三个用户。我们不需要检查错误，因为这是之前测试的目的。重要的是要记住，没有必要过度测试你的代码。如果这里有任何错误，它将在之前的测试中出现。此外，我们已经检查了`user2`和`user3`查询没有使用缓存；它们还不应该被存储在那里。
- en: 'Now we are going to look for the `user1` query in the Proxy. It shouldn''t
    exist, as the stack has a size of 2, and `user1` was the first to enter, hence,
    the first to go out:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在代理中查找`user1`查询。它不应该存在，因为栈的大小为2，而`user1`是第一个进入的，因此也是第一个出去的：
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It doesn't matter if we ask for a thousand users; our cache can't be bigger
    than our configured size.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们请求多少用户，我们的缓存大小都不能超过我们配置的大小。
- en: 'Finally, we are going to again range over the users stored in the cache, and
    compare them with the last two we queried. This way, we will check that just those
    users are stored in the cache. Both must be found on it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将再次遍历缓存中存储的用户，并将它们与最后查询的两个用户进行比较。这样，我们将检查只有那些用户被存储在缓存中。两者都必须在缓存中找到：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the tests now should give some errors, as usual. Let''s run them now:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试应该会给出一些错误，就像往常一样。让我们现在运行它们：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, let's implement the `FindUser` method to act as our Proxy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现`FindUser`方法来充当我们的代理。
