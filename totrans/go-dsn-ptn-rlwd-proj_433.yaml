- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since version 1.7 of Go, we can embed tests within tests by using closures so
    we can group them in a more human-readable way, and reduce the number of `Test_`
    functions. Refer to [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!") , *Ready... Steady... Go!* to learn how to
    install the new version of Go if your current version is older than version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types for this pattern will be the proxy user and user list structs as
    well as a `UserFinder` interface that the database and the Proxy will implement.
    This is key because the Proxy must implement the same interfaces as the features
    of the type it tries to wrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserFinder` is the interface that the database and the Proxy implement.
    The `User` is a type with a member called `ID`, which is `int32` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `UserList` is a type of a slice of users. Consider the following
    syntax for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you are asking why we aren't using a slice of users directly, the answer
    is that by declaring a sequence of users this way, we can implement the `UserFinder`
    interface but with a slice, we can't.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Proxy type, called `UserListProxy` will be composed of a `UserList`
    slice, which will be our database representation. The `StackCache` members which
    will also be of `UserList` type for simplicity, `StackCapacity` to give our stack
    the size we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cheat a bit for the purpose of this tutorial and declare a Boolean
    state on a field called `DidDidLastSearchUsedCache` that will hold if the last
    performed search has used the cache, or has accessed the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `UserListProxy` type will cache a maximum of `StackCapacity` users, and
    rotate the cache if it reaches this limit. The `StackCache` members will be populated
    from objects from `SomeDatabase` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test is called `TestUserListProxy`, and is listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test creates a user list of 1 million users with random names.
    To do so, we feed the random number generator by calling the `Seed()` function
    with some constant seed so our randomized results are also constant; and the user
    IDs are generated from it. It might have some duplicates, but it serves our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a proxy with a reference to `someDatabase`, which we have just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have a `proxy` object composed of a mock database with 1 million
    users, and a cache implemented as a FIFO stack with a size of 2\. Now we will
    get three random IDs from `someDatabase` to use in our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We took the fourth, fifth, and sixth IDs from the slice (remember that arrays
    and slices start with 0, so the index 3 is actually the fourth position in the
    slice).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is going to be our starting point before launching the embedded tests.
    To create an embedded test, we have to call the `Run` method of the `testing.T`
    pointer, with a description and a closure with the `func(t *testing.T)` signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we check whether the returned user has the same ID as that of the expected
    user at index 0 of the `knownIDs` slice, and that the proxy cache now has a size
    of 1\. The state of the member `DidLastSearchUsedCache` proxy must not be `true`,
    or we will not pass the test. Remember, this member tells us whether the last
    search has been retrieved from the slice that represents a database, or from the
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second embedded test for the Proxy pattern is to ask for the same user
    as before, which must now be returned from the cache. It''s very similar to the
    previous test, but now we have to check if the user is returned from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, again we ask for the first known ID. The proxy cache must maintain a size
    of 1 after this search, and the `DidLastSearchUsedCache` member must be true this
    time, or the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last test will overflow the `StackCache` array on the `proxy` type. We
    will search for two new users that our `proxy` type will have to retrieve from
    the database. Our stack has a size of 2, so it will have to remove the first user
    to allocate space for the second and third users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have retrieved the first three users. We aren't checking for errors because
    that was the purpose of the previous tests. This is important to recall that there
    is no need to over-test your code. If there is any error here, it will arise in
    the previous tests. Also, we have checked that the `user2` and `user3` queries
    do not use the cache; they shouldn't be stored there yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to look for the `user1` query in the Proxy. It shouldn''t
    exist, as the stack has a size of 2, and `user1` was the first to enter, hence,
    the first to go out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't matter if we ask for a thousand users; our cache can't be bigger
    than our configured size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to again range over the users stored in the cache, and
    compare them with the last two we queried. This way, we will check that just those
    users are stored in the cache. Both must be found on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the tests now should give some errors, as usual. Let''s run them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, let's implement the `FindUser` method to act as our Proxy.
  prefs: []
  type: TYPE_NORMAL
