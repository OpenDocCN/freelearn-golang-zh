- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our Proxy, the `FindUser` method will search for a specified ID in the cache
    list. If it finds it, it will return the ID. If not, it will search in the database.
    Finally, if it's not in the database list, it will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, our Proxy pattern is composed of two `UserList` types (one
    of them a pointer), which are actually slices of `User` type. We will implement
    a `FindUser` method in `User` type too, which, by the way, has the same signature
    as the `UserFinder` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `FindUser` method in the `UserList` slice will iterate over the list to
    try and find a user with the same ID as the `id` argument, or return an error
    if it can't find it.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the pointer `t` is between parentheses. This is to
    dereference the underlying array before accessing its indexes. Without it, you'll
    have a compilation error, because the compiler tries to search the index before
    dereferencing the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first part of the proxy `FindUser` method can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use the preceding method to search for a user in the `StackCache` member.
    The error will be nil if it can find it, so we check this to print a message to
    the console, change the state of `DidLastSearchUsedCache` to `true` so that the
    test can check whether the user was retrieved from cache, and finally, return
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if the error was not nil, it means that it couldn''t find the user in the
    stack. So, the next step is to search in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can reuse the `FindUser` method we wrote for `UserList` database in this
    case, because both have the same type for the purpose of this example. Again,
    it searches the user in the database represented  by the `UserList` slice, but
    in this case, if the user isn't found, it returns the error generated in `UserList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user is found (`err` is nil), we have to add the user to the stack.
    For this purpose, we write a dedicated private method that receives a pointer
    of type `UserListProxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addUserToStack` method takes the user argument, and adds it to the stack
    in place. If the stack is full, it removes the first element in it before adding.
    We have also written an `addUser` method to `UserList` to help us in this. So,
    now in `FindUser` method, we just have to add one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This adds the new user to the stack, removing the last if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we just have to return the new user of the stack, and set the appropriate
    value on `DidLastSearchUsedCache` variable. We also write a message to the console
    to help in the testing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have enough to pass our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding messages that our Proxy has worked flawlessly.
    It has returned the first search from the database. Then, when we search for the
    same user again, it uses the cache. Finally, we made a new test that calls three
    different users and we can observe, by looking at the console output, that just
    the first was returned from the cache and that the other two were fetched from
    the database.
  prefs: []
  type: TYPE_NORMAL
