- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In our Proxy, the `FindUser` method will search for a specified ID in the cache
    list. If it finds it, it will return the ID. If not, it will search in the database.
    Finally, if it's not in the database list, it will return an error.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代理中，`FindUser`方法将在缓存列表中搜索指定的ID。如果找到，它将返回ID。如果没有找到，它将在数据库中搜索。最后，如果不在数据库列表中，它将返回错误。
- en: 'If you remember, our Proxy pattern is composed of two `UserList` types (one
    of them a pointer), which are actually slices of `User` type. We will implement
    a `FindUser` method in `User` type too, which, by the way, has the same signature
    as the `UserFinder` interface:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们的代理模式由两个`UserList`类型组成（其中一个是指针），实际上它们是`User`类型的切片。我们将在`User`类型中实现一个`FindUser`方法，顺便说一下，它的签名与`UserFinder`接口相同：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `FindUser` method in the `UserList` slice will iterate over the list to
    try and find a user with the same ID as the `id` argument, or return an error
    if it can't find it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserList`切片中的`FindUser`方法将遍历列表以尝试找到与`id`参数具有相同ID的用户，如果找不到，则返回错误。'
- en: You may be wondering why the pointer `t` is between parentheses. This is to
    dereference the underlying array before accessing its indexes. Without it, you'll
    have a compilation error, because the compiler tries to search the index before
    dereferencing the pointer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么指针`t`在括号之间。这是在访问索引之前取消引用底层数组。没有它，你将遇到编译错误，因为编译器试图在取消引用指针之前搜索索引。
- en: 'So, the first part of the proxy `FindUser` method can be written as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代理`FindUser`方法的第一部分可以写成如下：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use the preceding method to search for a user in the `StackCache` member.
    The error will be nil if it can find it, so we check this to print a message to
    the console, change the state of `DidLastSearchUsedCache` to `true` so that the
    test can check whether the user was retrieved from cache, and finally, return
    the user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的方法在`StackCache`成员中搜索用户。如果找到，错误将为nil，因此我们检查这一点以在控制台上打印消息，将`DidLastSearchUsedCache`的状态更改为`true`，以便测试可以检查用户是否从缓存中检索，最后返回用户。
- en: 'So, if the error was not nil, it means that it couldn''t find the user in the
    stack. So, the next step is to search in the database:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果错误不为nil，这意味着它无法在堆栈中找到用户。所以下一步是搜索数据库：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can reuse the `FindUser` method we wrote for `UserList` database in this
    case, because both have the same type for the purpose of this example. Again,
    it searches the user in the database represented  by the `UserList` slice, but
    in this case, if the user isn't found, it returns the error generated in `UserList`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以重用我们为`UserList`数据库编写的`FindUser`方法，因为这两个示例都具有相同的目的类型。再次强调，它搜索由`UserList`切片表示的数据库中的用户，但在这个例子中，如果找不到用户，它将返回`UserList`中生成的错误。
- en: 'When the user is found (`err` is nil), we have to add the user to the stack.
    For this purpose, we write a dedicated private method that receives a pointer
    of type `UserListProxy`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到用户时（`err`为nil），我们必须将用户添加到堆栈中。为此，我们编写了一个专门的自定义私有方法，该方法接收一个类型为`UserListProxy`的指针：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `addUserToStack` method takes the user argument, and adds it to the stack
    in place. If the stack is full, it removes the first element in it before adding.
    We have also written an `addUser` method to `UserList` to help us in this. So,
    now in `FindUser` method, we just have to add one line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`addUserToStack`方法接受用户参数，并将其就地添加到堆栈中。如果堆栈已满，则在添加之前会移除其中的第一个元素。我们还在`UserList`中编写了一个`addUser`方法来帮助我们。因此，现在在`FindUser`方法中，我们只需添加一行：'
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This adds the new user to the stack, removing the last if necessary.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将新用户添加到堆栈中，如果需要则移除最后一个。
- en: 'Finally, we just have to return the new user of the stack, and set the appropriate
    value on `DidLastSearchUsedCache` variable. We also write a message to the console
    to help in the testing process:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需返回堆栈中的新用户，并在`DidLastSearchUsedCache`变量上设置适当的值。我们还在控制台上写入一条消息以帮助测试过程：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this, we have enough to pass our tests:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了足够的测试通过：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see in the preceding messages that our Proxy has worked flawlessly.
    It has returned the first search from the database. Then, when we search for the
    same user again, it uses the cache. Finally, we made a new test that calls three
    different users and we can observe, by looking at the console output, that just
    the first was returned from the cache and that the other two were fetched from
    the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的消息中看到，我们的代理工作得非常完美。它已经从数据库中返回了第一条搜索结果。然后，当我们再次搜索同一用户时，它使用了缓存。最后，我们进行了一个新的测试，调用三个不同的用户，并且通过查看控制台输出，我们可以观察到只有第一条是从缓存中返回的，而其他两条是从数据库中获取的。
