- en: Objectives
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: When you think about extending legacy code without the risk of breaking something,
    you should think of the Decorator pattern first. It's a really powerful approach
    to deal with this particular problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑在不破坏现有代码的前提下扩展遗留代码时，你应该首先想到装饰器模式。这是一种处理此类特定问题的非常强大的方法。
- en: A different field where the Decorator is very powerful may not be so obvious
    though it reveals itself when creating types with lots of features based on user
    inputs, preferences, or similar inputs. Like in a Swiss knife, you have a base
    type (the frame of the knife), and from there you unfold its functionalities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在某个不同领域可能非常强大，尽管它在基于用户输入、偏好或类似输入创建具有许多特性的类型时才会显现出来。就像瑞士军刀一样，你有一个基础类型（刀的框架），然后从这里展开其功能。
- en: 'So, precisely when are we going to use the Decorator pattern? Answer to this
    question:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们究竟在什么情况下会使用装饰器模式呢？回答这个问题：
- en: When you need to add functionality to some code that you don't have access to,
    or you don't want to modify to avoid a negative effect on the code, and follow
    the open/close principle (like legacy code)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要向某些你无法访问或不想修改以避免对代码产生负面影响的部分添加功能时，或者遵循开闭原则（如遗留代码）
- en: When you want the functionality of an object to be created or altered dynamically,
    and the number of features is unknown and could grow fast
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你希望对象的函数能动态创建或修改，且功能数量未知且可能迅速增长时
