<html><head></head><body>
<div class="book" title="Decorator design pattern">
<div class="book" title="Unit test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec0100" class="calibre1"/>Unit test</h2></div></div></div><p class="calibre10">To launch our unit tests, we must first create the basic structures described in accordance with the acceptance criteria. To begin with, the interface that all decorating types must implement is as follows:</p><pre class="programlisting">type IngredientAdd interface { 
  AddIngredient() (string, error) 
} 
</pre><p class="calibre10">The following code defines the <code class="email">PizzaDecorator</code> type, which must have <code class="email">IngredientAdd</code> inside, and which implements <code class="email">IngredientAdd</code> too:</p><pre class="programlisting">type PizzaDecorator struct{ 
  Ingredient IngredientAdd 
} 

func (p *PizzaDecorator) AddIngredient() (string, error) { 
  return "", errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">The definition of the <code class="email">Meat</code> type will be very similar to that of the  <code class="email">PizzaDecorator</code> structure:</p><pre class="programlisting">type Meat struct { 
  Ingredient IngredientAdd 
} 
 
func (m *Meat) AddIngredient() (string, error) { 
  return "", errors.New("Not implemented yet") 
} 
</pre><p class="calibre10">Now we define the <code class="email">Onion</code> struct in a similar fashion:</p><pre class="programlisting">type Onion struct { 
  Ingredient IngredientAdd 
} 
 
func (o *Onion) AddIngredient() (string, error) { 
  return "", errors.New("Not implemented yet") 
}  
</pre><p class="calibre10">This is enough to implement the first unit test, and to allow the compiler to run them without any compiling errors:</p><pre class="programlisting">func TestPizzaDecorator_AddIngredient(t *testing.T) { 
  pizza := &amp;PizzaDecorator{} 
  pizzaResult, _ := pizza.AddIngredient() 
  expectedText := "Pizza with the following ingredients:" 
  if !strings.Contains(pizzaResult, expectedText) { 
    t.Errorf("When calling the add ingredient of the pizza decorator it must return the text %sthe expected text, not '%s'", pizzaResult, expectedText) 
  } 
} 
</pre><p class="calibre10">Now it must compile without problems, so we can check that the test fails:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestPizzaDecorator .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPizzaDecorator_AddIngredient</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestPizzaDecorator_AddIngredient (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:29: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:34: When the the AddIngredient method of the pizza decorator object is called, it must return the text</strong></span>
<span class="strong"><strong class="calibre2">Pizza with the following ingredients:</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL </strong></span>
</pre><p class="calibre10">Our first test is done, and we can see that the <code class="email">PizzaDecorator</code> struct isn't returning anything yet, that's why it fails. We can now move on to the <code class="email">Onion</code> type. The test of the <code class="email">Onion</code> type is quite similar to that of the <code class="email">Pizza</code> decorator, but we must also make sure that we actually add the ingredient to the <code class="email">IngredientAdd</code> method and not to a nil pointer:</p><pre class="programlisting">func TestOnion_AddIngredient(t *testing.T) { 
  onion := &amp;Onion{} 
  onionResult, err := onion.AddIngredient() 
  if err == nil { 
    t.Errorf("When calling AddIngredient on the onion decorator without" + "an IngredientAdd on its Ingredient field must return an error, not a string with '%s'", onionResult) 
  } 
</pre><p class="calibre10">The first half of the preceding test examines the returning error when no <code class="email">IngredientAdd</code> method is passed to the <code class="email">Onion</code> struct initializer. As no pizza is available to add the ingredient, an error must be returned:</p><pre class="programlisting">  onion = &amp;Onion{&amp;PizzaDecorator{}} 
  onionResult, err = onion.AddIngredient() 

  if err != nil { 
    t.Error(err) 
  } 
  if !strings.Contains(onionResult, "onion") { 
    t.Errorf("When calling the add ingredient of the onion decorator it" + "must return a text with the word 'onion', not '%s'", onionResult) 
  } 
} 
</pre><p class="calibre10">The second part of the <code class="email">Onion</code> type test actually passes <code class="email">PizzaDecorator</code> structure to the initializer. Then, we check whether no error is being returned, and also whether the returning string contains the word <code class="email">onion</code> in it. This way, we can ensure that onion has been added to the pizza.</p><p class="calibre10">Finally for the <code class="email">Onion</code> type, the console output of this test with our current implementation will be the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=TestOnion_AddIngredient .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestOnion_AddIngredient</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestOnion_AddIngredient (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:48: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:52: When calling the add ingredient of the onion decorator it must return a text with the word 'onion', not ''</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">The <code class="email">meat</code> ingredient is exactly the same, but we change the type to meat instead of onion:</p><pre class="programlisting">func TestMeat_AddIngredient(t *testing.T) { 
  meat := &amp;Meat{} 
  meatResult, err := meat.AddIngredient() 
  if err == nil { 
    t.Errorf("When calling AddIngredient on the meat decorator without" + "an IngredientAdd in its Ingredient field must return an error," + "not a string with '%s'", meatResult) 
  } 
 
  meat = &amp;Meat{&amp;PizzaDecorator{}} 
  meatResult, err = meat.AddIngredient() 
  if err != nil { 
    t.Error(err) 
  } 

  if !strings.Contains(meatResult, "meat") { 
    t.Errorf("When calling the add ingredient of the meat decorator it" + "must return a text with the word 'meat', not '%s'", meatResult) 
  } 
} 
</pre><p class="calibre10">So, the result of the tests will be similar:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=TestMeat_AddIngredient .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestMeat_AddIngredient</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestMeat_AddIngredient (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:68: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:72: When calling the add ingredient of the meat decorator it must return a text with the word 'meat', not ''</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Finally, we must check the full stack test. Creating a pizza with onion and meat must return the text <code class="email">Pizza with the following ingredients: meat, onion</code>:</p><pre class="programlisting">func TestPizzaDecorator_FullStack(t *testing.T) { 
  pizza := &amp;Onion{&amp;Meat{&amp;PizzaDecorator{}}} 
  pizzaResult, err := pizza.AddIngredient() 
  if err != nil { 
    t.Error(err) 
  } 
 
  expectedText := "Pizza with the following ingredients: meat, onion" 
  if !strings.Contains(pizzaResult, expectedText){ 
    t.Errorf("When asking for a pizza with onion and meat the returned " + "string must contain the text '%s' but '%s' didn't have it", expectedText,pizzaResult) 
  } 
 
  t.Log(pizzaResult) 
} 
</pre><p class="calibre10">Our test creates a variable called <code class="email">pizza</code> which, like the m<span class="strong"><em class="calibre11">atryoshka dolls</em></span>, embeds types of the <code class="email">IngredientAdd</code> method in several levels. Calling the <code class="email">AddIngredient</code> method executes the method at the "onion" level, which executes the "meat" one, which, finally, executes that of the <code class="email">PizzaDecorator</code> struct. After checking that no error had been returned, we check whether the returned text follows the needs of the <span class="strong"><em class="calibre11">acceptance criteria 5</em></span>. The tests are run with the following command:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=TestPizzaDecorator_FullStack .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPizzaDecorator_FullStack</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestPizzaDecorator_FullStack (0.</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:80: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:87: When asking for a pizza with onion and meat the returned string must contain the text 'Pizza with the following ingredients: meat, onion' but '' didn't have it</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">From the preceding output, we can see that the tests now return an empty string for our decorated type. This is, of course, because no implementation has been done yet. This was the last test to check the fully decorated implementation. Let's look closely at the implementation then.</p></div></div></body></html>