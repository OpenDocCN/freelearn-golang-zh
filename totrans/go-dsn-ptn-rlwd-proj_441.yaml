- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To launch our unit tests, we must first create the basic structures described
    in accordance with the acceptance criteria. To begin with, the interface that
    all decorating types must implement is as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的单元测试，我们必须首先创建符合验收标准的基结构。首先，所有装饰类型都必须实现的接口如下：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following code defines the `PizzaDecorator` type, which must have `IngredientAdd`
    inside, and which implements `IngredientAdd` too:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了`PizzaDecorator`类型，它必须在内部包含`IngredientAdd`，并且还实现了`IngredientAdd`：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The definition of the `Meat` type will be very similar to that of the  `PizzaDecorator` structure:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meat`类型的定义将与`PizzaDecorator`结构体非常相似：'
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we define the `Onion` struct in a similar fashion:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以类似的方式定义`Onion`结构体：
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is enough to implement the first unit test, and to allow the compiler
    to run them without any compiling errors:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够实现第一个单元测试，并允许编译器在没有编译错误的情况下运行它们：
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now it must compile without problems, so we can check that the test fails:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它必须没有问题地编译，因此我们可以检查测试是否失败：
- en: '[PRE5]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our first test is done, and we can see that the `PizzaDecorator` struct isn''t
    returning anything yet, that''s why it fails. We can now move on to the `Onion`
    type. The test of the `Onion` type is quite similar to that of the `Pizza` decorator,
    but we must also make sure that we actually add the ingredient to the `IngredientAdd` method
    and not to a nil pointer:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测试已经完成，我们可以看到`PizzaDecorator`结构体还没有返回任何内容，这就是它失败的原因。现在我们可以继续到`Onion`类型。`Onion`类型的测试与`Pizza`装饰器的测试非常相似，但我们还必须确保我们实际上是将配料添加到`IngredientAdd`方法中，而不是一个空指针：
- en: '[PRE6]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first half of the preceding test examines the returning error when no `IngredientAdd` method
    is passed to the `Onion` struct initializer. As no pizza is available to add the
    ingredient, an error must be returned:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前半部分的测试检查了当没有将`IngredientAdd`方法传递给`Onion`结构体初始化器时返回的错误。由于没有披萨可以添加配料，必须返回一个错误：
- en: '[PRE7]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second part of the `Onion` type test actually passes `PizzaDecorator` structure
    to the initializer. Then, we check whether no error is being returned, and also
    whether the returning string contains the word `onion` in it. This way, we can
    ensure that onion has been added to the pizza.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Onion`类型测试的第二部分实际上将`PizzaDecorator`结构体传递给初始化器。然后，我们检查是否没有返回错误，以及返回的字符串中是否包含单词`onion`。这样，我们可以确保洋葱已经添加到披萨中。'
- en: 'Finally for the `Onion` type, the console output of this test with our current
    implementation will be the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`Onion`类型，当前实现下的测试控制台输出将是以下内容：
- en: '[PRE8]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `meat` ingredient is exactly the same, but we change the type to meat instead
    of onion:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 肉类配料与洋葱完全相同，但我们将其类型改为肉类而不是洋葱：
- en: '[PRE9]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, the result of the tests will be similar:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试的结果将是类似的：
- en: '[PRE10]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we must check the full stack test. Creating a pizza with onion and
    meat must return the text `Pizza with the following ingredients: meat, onion`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们必须检查完整的堆栈测试。用洋葱和肉类制作的披萨必须返回文本`Pizza with the following ingredients: meat,
    onion`：'
- en: '[PRE11]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our test creates a variable called `pizza` which, like the m*atryoshka dolls*,
    embeds types of the `IngredientAdd` method in several levels. Calling the `AddIngredient`
    method executes the method at the "onion" level, which executes the "meat" one,
    which, finally, executes that of the `PizzaDecorator` struct. After checking that
    no error had been returned, we check whether the returned text follows the needs
    of the *acceptance criteria 5*. The tests are run with the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试创建了一个名为`pizza`的变量，它就像套娃一样，嵌套了`IngredientAdd`方法的类型在几个层级中。调用`AddIngredient`方法将执行“洋葱”级别的操作，然后执行“肉类”级别的操作，最后执行`PizzaDecorator`结构的操作。在确认没有返回错误后，我们检查返回的文本是否符合*验收标准5*。测试使用以下命令运行：
- en: '[PRE12]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the preceding output, we can see that the tests now return an empty string
    for our decorated type. This is, of course, because no implementation has been
    done yet. This was the last test to check the fully decorated implementation.
    Let's look closely at the implementation then.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到，现在测试为我们的装饰类型返回了一个空字符串。这当然是因为还没有进行任何实现。这是最后一个测试，用于检查完整装饰实现。那么，让我们仔细看看实现。
