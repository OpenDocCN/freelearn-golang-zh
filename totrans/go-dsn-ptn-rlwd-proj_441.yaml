- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To launch our unit tests, we must first create the basic structures described
    in accordance with the acceptance criteria. To begin with, the interface that
    all decorating types must implement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code defines the `PizzaDecorator` type, which must have `IngredientAdd`
    inside, and which implements `IngredientAdd` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `Meat` type will be very similar to that of the  `PizzaDecorator` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define the `Onion` struct in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to implement the first unit test, and to allow the compiler
    to run them without any compiling errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it must compile without problems, so we can check that the test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first test is done, and we can see that the `PizzaDecorator` struct isn''t
    returning anything yet, that''s why it fails. We can now move on to the `Onion`
    type. The test of the `Onion` type is quite similar to that of the `Pizza` decorator,
    but we must also make sure that we actually add the ingredient to the `IngredientAdd` method
    and not to a nil pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first half of the preceding test examines the returning error when no `IngredientAdd` method
    is passed to the `Onion` struct initializer. As no pizza is available to add the
    ingredient, an error must be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The second part of the `Onion` type test actually passes `PizzaDecorator` structure
    to the initializer. Then, we check whether no error is being returned, and also
    whether the returning string contains the word `onion` in it. This way, we can
    ensure that onion has been added to the pizza.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally for the `Onion` type, the console output of this test with our current
    implementation will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `meat` ingredient is exactly the same, but we change the type to meat instead
    of onion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the result of the tests will be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must check the full stack test. Creating a pizza with onion and
    meat must return the text `Pizza with the following ingredients: meat, onion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test creates a variable called `pizza` which, like the m*atryoshka dolls*,
    embeds types of the `IngredientAdd` method in several levels. Calling the `AddIngredient`
    method executes the method at the "onion" level, which executes the "meat" one,
    which, finally, executes that of the `PizzaDecorator` struct. After checking that
    no error had been returned, we check whether the returned text follows the needs
    of the *acceptance criteria 5*. The tests are run with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that the tests now return an empty string
    for our decorated type. This is, of course, because no implementation has been
    done yet. This was the last test to check the fully decorated implementation.
    Let's look closely at the implementation then.
  prefs: []
  type: TYPE_NORMAL
