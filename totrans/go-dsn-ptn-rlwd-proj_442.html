<html><head></head><body>
<div class="book" title="Decorator design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch04lvl2sec0101" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">We are going to start implementing the <code class="email">PizzaDecorator</code> type. Its role is to provide the initial text of the full pizza:</p><pre class="programlisting">type PizzaDecorator struct { 
  Ingredient IngredientAdd 
} 
 
func (p *PizzaDecorator) AddIngredient() (string, error) { 
  return "Pizza with the following ingredients:", nil 
} 
</pre><p class="calibre10">A single line change on the return of the <code class="email">AddIngredient</code> method was enough to pass the test:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=TestPizzaDecorator_Add .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPizzaDecorator_AddIngredient</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestPizzaDecorator_AddIngredient (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Moving on to the <code class="email">Onion</code>Â struct implementation, we must take the beginning of our <code class="email">IngredientAdd</code> returned string, and add the word <code class="email">onion</code> at the end of it in order to get a composed pizza in return:</p><pre class="programlisting">type Onion struct { 
  Ingredient IngredientAdd 
} 
 
func (o *Onion) AddIngredient() (string, error) { 
  if o.Ingredient == nil { 
    return "", errors.New("An IngredientAdd is needed in the Ingredient field of the Onion") 
  } 
  s, err := o.Ingredient.AddIngredient() 
  if err != nil { 
    return "", err 
  } 
  return fmt.Sprintf("%s %s,", s, "onion"), nil 
} 
</pre><p class="calibre10">Checking that we actually have a pointer to <code class="email">IngredientAdd</code> first, we use the contents of the inner <code class="email">IngredientAdd</code>, and check it for errors. If no errors occur, we receive a new string composed of this content, a space, and the word <code class="email">onion</code> (and no errors). Looks good enough to run the tests:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=TestOnion_AddIngredient .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestOnion_AddIngredient</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestOnion_AddIngredient (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Implementation of the <code class="email">Meat</code> struct is very similar:</p><pre class="programlisting">type Meat struct { 
  Ingredient IngredientAdd 
} 
 
func (m *Meat) AddIngredient() (string, error) { 
  if m.Ingredient == nil { 
    return "", errors.New("An IngredientAdd is needed in the Ingredient field of the Meat") 
  } 
  s, err := m.Ingredient.AddIngredient() 
  if err != nil { 
    return "", err 
  } 
  return fmt.Sprintf("%s %s,", s, "meat"), nil 
} 
</pre><p class="calibre10">And here goes their test execution:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=TestMeat_AddIngredient .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestMeat_AddIngredient</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestMeat_AddIngredient (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Okay. So, now all the pieces are to be tested separately. If everything is okay, the test of the <span class="strong"><em class="calibre11">full stacked</em></span> solution must be passing smoothly:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v -run=TestPizzaDecorator_FullStack .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestPizzaDecorator_FullStack</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestPizzaDecorator_FullStack (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">decorator_test.go:92: Pizza with the following ingredients: meat, onion,</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Awesome! With the Decorator pattern, we could keep stacking <code class="email">IngredientAdds</code> which call their inner pointer to add functionality to <code class="email">PizzaDecorator</code>. We aren't touching the core type either, nor modifying or implementing new things. All the new features are implemented by an external type.</p></div></div></body></html>