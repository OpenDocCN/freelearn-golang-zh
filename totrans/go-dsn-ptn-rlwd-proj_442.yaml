- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start implementing the `PizzaDecorator` type. Its role is to
    provide the initial text of the full pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A single line change on the return of the `AddIngredient` method was enough
    to pass the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the `Onion`Â struct implementation, we must take the beginning
    of our `IngredientAdd` returned string, and add the word `onion` at the end of
    it in order to get a composed pizza in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking that we actually have a pointer to `IngredientAdd` first, we use the
    contents of the inner `IngredientAdd`, and check it for errors. If no errors occur,
    we receive a new string composed of this content, a space, and the word `onion`
    (and no errors). Looks good enough to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementation of the `Meat` struct is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here goes their test execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. So, now all the pieces are to be tested separately. If everything is
    okay, the test of the *full stacked* solution must be passing smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! With the Decorator pattern, we could keep stacking `IngredientAdds`
    which call their inner pointer to add functionality to `PizzaDecorator`. We aren't
    touching the core type either, nor modifying or implementing new things. All the
    new features are implemented by an external type.
  prefs: []
  type: TYPE_NORMAL
