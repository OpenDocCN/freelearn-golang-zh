- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We are going to start implementing the `PizzaDecorator` type. Its role is to
    provide the initial text of the full pizza:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始实现`PizzaDecorator`类型。它的作用是提供完整披萨的初始文本：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A single line change on the return of the `AddIngredient` method was enough
    to pass the test:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AddIngredient`方法的返回值上做单行更改就足以通过测试：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Moving on to the `Onion` struct implementation, we must take the beginning
    of our `IngredientAdd` returned string, and add the word `onion` at the end of
    it in order to get a composed pizza in return:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Onion`结构的实现，我们必须取回`IngredientAdd`返回字符串的开头，并在其末尾添加单词`onion`，以便返回一个组合披萨：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Checking that we actually have a pointer to `IngredientAdd` first, we use the
    contents of the inner `IngredientAdd`, and check it for errors. If no errors occur,
    we receive a new string composed of this content, a space, and the word `onion`
    (and no errors). Looks good enough to run the tests:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查我们确实有一个指向`IngredientAdd`的指针之后，我们使用内部`IngredientAdd`的内容，并检查是否有错误。如果没有错误发生，我们将收到一个由这个内容、一个空格和单词`onion`（以及没有错误）组成的新字符串。看起来足够好，可以运行测试：
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implementation of the `Meat` struct is very similar:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meat`结构的实现非常相似：'
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here goes their test execution:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它们的测试执行过程：
- en: '[PRE5]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Okay. So, now all the pieces are to be tested separately. If everything is
    okay, the test of the *full stacked* solution must be passing smoothly:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，现在所有部件都需要单独测试。如果一切正常，*完整堆叠*解决方案的测试必须顺利通过：
- en: '[PRE6]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Awesome! With the Decorator pattern, we could keep stacking `IngredientAdds`
    which call their inner pointer to add functionality to `PizzaDecorator`. We aren't
    touching the core type either, nor modifying or implementing new things. All the
    new features are implemented by an external type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！使用装饰器模式，我们可以不断堆叠`IngredientAdds`，它们调用内部指针来向`PizzaDecorator`添加功能。我们也没有触及核心类型，也没有修改或实现新事物。所有的新功能都是由外部类型实现的。
