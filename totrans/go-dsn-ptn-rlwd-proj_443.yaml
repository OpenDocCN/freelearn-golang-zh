- en: A real-life example - server middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should have understood how the Decorator pattern works. Now we can
    try a more advanced example using the small HTTP server that we designed in the
    Adapter pattern section. You learned that an HTTP server can be created by using
    the `http` package, and implementing the `http.Handler` interface. This interface
    has only one method called `ServeHTTP(http.ResponseWriter, http.Request)`. Can
    we use the Decorator pattern to add more functionality to a server? Of course!
  prefs: []
  type: TYPE_NORMAL
- en: We will add a couple of pieces to this server. First, we are going to log every
    connection made to it to the `io.Writer` interface (for the sake of simplicity,
    we'll use the `io.Writer` implementation of the `os.Stdout` interface so that
    it outputs to the console). The second piece will add basic HTTP authentication
    to every request made to the server. If the authentication passes, a `Hello Decorator!` message
    will appear. Finally, the user will be able to select the number of decoration
    items that he/she wants in the server, and the server will be structured and created
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the common interface, http.Handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already have the common interface that we will decorate using nested types.
    We first need to create our core type, which is going to be the `Handler` that
    returns the sentence `Hello Decorator!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler can be attributed to the `http.Handle` method to define our first
    endpoint. Let''s check this now by creating the package''s `main` function, and
    sending a `GET` request to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the server using the Terminal to execute the  `**go run main.go**`
    command. Then, open a new Terminal to make the `GET` request. We''ll use the `curl`
    command to make our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have crossed the first milestone of our decorated server. The next step
    is to decorate it with logging capabilities. To do so, we must implement the `http.Handler`
    interface, in a new type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We call this type `LoggerServer`. As you can see, it stores not only a `Handler`,
    but also `io.Writer` to write the output of the log. Our implementation of the
    `ServeHTTP` method prints the request URI, the host, the content length, and the
    used method `io.Writer`. Once printing is finished, it calls the `ServeHTTP` function
    of its inner `Handler` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decorate `MyServer` with this `LoggerMiddleware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the `**curl **`  command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our **curl** command returns the same message, but if you look at the Terminal
    where you have run the Go application, you can see the logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have decorated `MyServer` with logging capabilities without actually modifying
    it. Can we do the same with authentication? Of course! After logging the request,
    we will authenticate it by using **HTTP Basic Authentication** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The **BasicAuthMiddleware** middleware stores three fields--a handler to decorate
    like in the previous middlewares, a user, and a password, which will be the only
    authorization to access the contents on the server. The implementation of the
    `decorating` method will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implementation, we use the `BasicAuth` method from `http.Request`
    to automatically retrieve the user and password from the request, plus an `ok/ko`
    from the parsing action. Then we check whether the parsing is correct (returning
    a message to the requester if incorrect, and finishing the request). If no problems
    have been detected during parsing, we check whether the username and the password
    match with the ones stored in `BasicAuthMiddleware`. If the credentials are valid,
    we shall call the decorated type (our server), but if the credentials aren't valid,
    we receive the `User or password incorrect` message in return, and the request
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to provide the user with a way to choose among different types
    of servers. We will retrieve user input data in the main function. We''ll have
    three options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging and authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to use the `Fscanf` function to retrieve input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Fscanf` function needs an `io.Reader`  implementor as the first argument
    (which is going to be the input in the console), and it takes the server selected
    by the user from it. We'll pass `os.Stdin` as the `io.Reader` interface to retrieve
    user input. Then, we'll write the type of data it is going to parse. The `%d` specifier
    refers to an integer number. Finally, we'll write memory direction to store the
    parsed input, in this case, the memory position of the `selection` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user selects an option, we can take the basic server and decorate
    it at runtime, switching over to the selected option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first option will be handled by the default `switch` option--a plain `MyServer`.
    In the case of the second option, we decorate a plain server with logging. The
    third Option is a bit more developed--we ask the user for a username and a password
    using `Fscanf` again. Note that you can scan more than one input, as we are doing
    to retrieve the user and the password. Then, we take the basic server, decorate
    it with authentication, and finally, with logging.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the indentation of the nested types of option three, the request
    passes through the logger, then the authentication middleware, and finally, the `MyServer`
    argument if everything is okay. The requests will follow the same route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end of the main function takes the decorated handler, and launches the
    server on the `8080` port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s launch the server with the third option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first test the plain server by choosing the first option. Run the server
    with the command **go run server_decorator.go**, and select the first option.
    Then, in a different Terminal, run the basic request with curl, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh, oh! It doesn''t give us access. We haven''t passed any user and password,
    so it tells us that we cannot continue. Let''s try with some random user and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'No access! We can also check in the Terminal where we launched the server and
    where every request is being logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enter the correct username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we are! Our request has also been logged, and the server has granted access
    to us. Now we can improve our server as much as we want by writing more middlewares
    to decorate the server's functionality.
  prefs: []
  type: TYPE_NORMAL
