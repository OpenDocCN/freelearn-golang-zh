- en: A real-life example - server middleware
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should have understood how the Decorator pattern works. Now we can
    try a more advanced example using the small HTTP server that we designed in the
    Adapter pattern section. You learned that an HTTP server can be created by using
    the `http` package, and implementing the `http.Handler` interface. This interface
    has only one method called `ServeHTTP(http.ResponseWriter, http.Request)`. Can
    we use the Decorator pattern to add more functionality to a server? Of course!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will add a couple of pieces to this server. First, we are going to log every
    connection made to it to the `io.Writer` interface (for the sake of simplicity,
    we'll use the `io.Writer` implementation of the `os.Stdout` interface so that
    it outputs to the console). The second piece will add basic HTTP authentication
    to every request made to the server. If the authentication passes, a `Hello Decorator!` message
    will appear. Finally, the user will be able to select the number of decoration
    items that he/she wants in the server, and the server will be structured and created
    at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the common interface, http.Handler
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already have the common interface that we will decorate using nested types.
    We first need to create our core type, which is going to be the `Handler` that
    returns the sentence `Hello Decorator!`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This handler can be attributed to the `http.Handle` method to define our first
    endpoint. Let''s check this now by creating the package''s `main` function, and
    sending a `GET` request to it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execute the server using the Terminal to execute the  `**go run main.go**`
    command. Then, open a new Terminal to make the `GET` request. We''ll use the `curl`
    command to make our requests:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have crossed the first milestone of our decorated server. The next step
    is to decorate it with logging capabilities. To do so, we must implement the `http.Handler`
    interface, in a new type, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We call this type `LoggerServer`. As you can see, it stores not only a `Handler`,
    but also `io.Writer` to write the output of the log. Our implementation of the
    `ServeHTTP` method prints the request URI, the host, the content length, and the
    used method `io.Writer`. Once printing is finished, it calls the `ServeHTTP` function
    of its inner `Handler` field.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decorate `MyServer` with this `LoggerMiddleware`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now run the `**curl **`  command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our **curl** command returns the same message, but if you look at the Terminal
    where you have run the Go application, you can see the logging:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have decorated `MyServer` with logging capabilities without actually modifying
    it. Can we do the same with authentication? Of course! After logging the request,
    we will authenticate it by using **HTTP Basic Authentication** as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The **BasicAuthMiddleware** middleware stores three fields--a handler to decorate
    like in the previous middlewares, a user, and a password, which will be the only
    authorization to access the contents on the server. The implementation of the
    `decorating` method will proceed as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding implementation, we use the `BasicAuth` method from `http.Request`
    to automatically retrieve the user and password from the request, plus an `ok/ko`
    from the parsing action. Then we check whether the parsing is correct (returning
    a message to the requester if incorrect, and finishing the request). If no problems
    have been detected during parsing, we check whether the username and the password
    match with the ones stored in `BasicAuthMiddleware`. If the credentials are valid,
    we shall call the decorated type (our server), but if the credentials aren't valid,
    we receive the `User or password incorrect` message in return, and the request
    is finished.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to provide the user with a way to choose among different types
    of servers. We will retrieve user input data in the main function. We''ll have
    three options to choose from:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Simple server
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server with logging and authentication
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to use the `Fscanf` function to retrieve input from the user:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Fscanf` function needs an `io.Reader`  implementor as the first argument
    (which is going to be the input in the console), and it takes the server selected
    by the user from it. We'll pass `os.Stdin` as the `io.Reader` interface to retrieve
    user input. Then, we'll write the type of data it is going to parse. The `%d` specifier
    refers to an integer number. Finally, we'll write memory direction to store the
    parsed input, in this case, the memory position of the `selection` variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user selects an option, we can take the basic server and decorate
    it at runtime, switching over to the selected option:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first option will be handled by the default `switch` option--a plain `MyServer`.
    In the case of the second option, we decorate a plain server with logging. The
    third Option is a bit more developed--we ask the user for a username and a password
    using `Fscanf` again. Note that you can scan more than one input, as we are doing
    to retrieve the user and the password. Then, we take the basic server, decorate
    it with authentication, and finally, with logging.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the indentation of the nested types of option three, the request
    passes through the logger, then the authentication middleware, and finally, the `MyServer`
    argument if everything is okay. The requests will follow the same route.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The end of the main function takes the decorated handler, and launches the
    server on the `8080` port:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, let''s launch the server with the third option:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will first test the plain server by choosing the first option. Run the server
    with the command **go run server_decorator.go**, and select the first option.
    Then, in a different Terminal, run the basic request with curl, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Uh, oh! It doesn''t give us access. We haven''t passed any user and password,
    so it tells us that we cannot continue. Let''s try with some random user and password:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！它没有给我们权限。我们没有通过任何用户名和密码，所以它告诉我们无法继续。让我们尝试使用一些随机的用户名和密码：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'No access! We can also check in the Terminal where we launched the server and
    where every request is being logged:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有权限！我们也可以在启动服务器的终端中检查，那里记录了每一个请求：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, enter the correct username and password:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输入正确的用户名和密码：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we are! Our request has also been logged, and the server has granted access
    to us. Now we can improve our server as much as we want by writing more middlewares
    to decorate the server's functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了！我们的请求也已经记录，服务器已经授予我们访问权限。现在我们可以通过编写更多的中间件来装饰服务器的功能，尽可能多地改进我们的服务器。
