- en: A real-life example - server middleware
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实世界的例子 - 服务器中间件
- en: By now, you should have understood how the Decorator pattern works. Now we can
    try a more advanced example using the small HTTP server that we designed in the
    Adapter pattern section. You learned that an HTTP server can be created by using
    the `http` package, and implementing the `http.Handler` interface. This interface
    has only one method called `ServeHTTP(http.ResponseWriter, http.Request)`. Can
    we use the Decorator pattern to add more functionality to a server? Of course!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经理解了装饰器模式的工作原理。现在我们可以尝试一个更高级的例子，使用我们在适配器模式部分设计的HTTP服务器。你了解到可以通过使用`http`包并实现`http.Handler`接口来创建HTTP服务器。这个接口只有一个方法，称为`ServeHTTP(http.ResponseWriter,
    http.Request)`。我们能否使用装饰器模式向服务器添加更多功能？当然可以！
- en: We will add a couple of pieces to this server. First, we are going to log every
    connection made to it to the `io.Writer` interface (for the sake of simplicity,
    we'll use the `io.Writer` implementation of the `os.Stdout` interface so that
    it outputs to the console). The second piece will add basic HTTP authentication
    to every request made to the server. If the authentication passes, a `Hello Decorator!` message
    will appear. Finally, the user will be able to select the number of decoration
    items that he/she wants in the server, and the server will be structured and created
    at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向这个服务器添加一些功能。首先，我们将记录所有连接到它的连接到`io.Writer`接口（为了简单起见，我们将使用`os.Stdout`接口的`io.Writer`实现，以便输出到控制台）。第二部分将为服务器上的每个请求添加基本的HTTP认证。如果认证通过，将显示一条`Hello
    Decorator!`消息。最后，用户将能够选择在服务器中想要的装饰项目数量，服务器将在运行时构建和创建。
- en: Starting with the common interface, http.Handler
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从常见的接口开始，http.Handler
- en: 'We already have the common interface that we will decorate using nested types.
    We first need to create our core type, which is going to be the `Handler` that
    returns the sentence `Hello Decorator!`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了将要使用嵌套类型进行装饰的通用接口。我们首先需要创建我们的核心类型，它将是一个返回句子`Hello Decorator!`的`Handler`：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This handler can be attributed to the `http.Handle` method to define our first
    endpoint. Let''s check this now by creating the package''s `main` function, and
    sending a `GET` request to it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理器可以被赋予`http.Handle`方法来定义我们的第一个端点。现在让我们通过创建包的`main`函数并向它发送`GET`请求来检查这一点：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execute the server using the Terminal to execute the  `**go run main.go**`
    command. Then, open a new Terminal to make the `GET` request. We''ll use the `curl`
    command to make our requests:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用终端执行服务器，通过执行`**go run main.go**`命令。然后，打开一个新的终端来发送`GET`请求。我们将使用`curl`命令来发送我们的请求：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have crossed the first milestone of our decorated server. The next step
    is to decorate it with logging capabilities. To do so, we must implement the `http.Handler`
    interface, in a new type, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了装饰服务器的第一个里程碑。下一步是为它添加日志功能。为此，我们必须实现一个新的`http.Handler`接口，如下所示：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We call this type `LoggerServer`. As you can see, it stores not only a `Handler`,
    but also `io.Writer` to write the output of the log. Our implementation of the
    `ServeHTTP` method prints the request URI, the host, the content length, and the
    used method `io.Writer`. Once printing is finished, it calls the `ServeHTTP` function
    of its inner `Handler` field.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种类型为`LoggerServer`。正如你所见，它不仅存储了一个`Handler`，还存储了一个`io.Writer`以写入日志的输出。我们实现的`ServeHTTP`方法会打印请求URI、主机、内容长度以及使用的`io.Writer`方法。一旦打印完成，它将调用其内部`Handler`字段的`ServeHTTP`函数。
- en: 'We can decorate `MyServer` with this `LoggerMiddleware`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个`LoggerMiddleware`装饰`MyServer`：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now run the `**curl **`  command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下`**curl **`命令：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our **curl** command returns the same message, but if you look at the Terminal
    where you have run the Go application, you can see the logging:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`curl`命令返回相同的信息，但如果你查看运行Go应用程序的终端，你可以看到日志：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have decorated `MyServer` with logging capabilities without actually modifying
    it. Can we do the same with authentication? Of course! After logging the request,
    we will authenticate it by using **HTTP Basic Authentication** as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实际上没有修改`MyServer`的情况下，为其添加了日志功能。我们能否对认证也这样做？当然可以！在记录请求之后，我们将使用以下方式通过**HTTP基本认证**进行认证：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The **BasicAuthMiddleware** middleware stores three fields--a handler to decorate
    like in the previous middlewares, a user, and a password, which will be the only
    authorization to access the contents on the server. The implementation of the
    `decorating` method will proceed as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**BasicAuthMiddleware** 中间件存储了三个字段——一个用于装饰的处理程序，就像之前的中间件一样，一个用户和一个密码，这些将是访问服务器上内容的唯一授权。`decorating`
    方法的实现将按以下步骤进行：'
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding implementation, we use the `BasicAuth` method from `http.Request`
    to automatically retrieve the user and password from the request, plus an `ok/ko`
    from the parsing action. Then we check whether the parsing is correct (returning
    a message to the requester if incorrect, and finishing the request). If no problems
    have been detected during parsing, we check whether the username and the password
    match with the ones stored in `BasicAuthMiddleware`. If the credentials are valid,
    we shall call the decorated type (our server), but if the credentials aren't valid,
    we receive the `User or password incorrect` message in return, and the request
    is finished.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们使用 `http.Request` 中的 `BasicAuth` 方法自动从请求中检索用户和密码，以及一个来自解析操作的 `ok/ko`。然后我们检查解析是否正确（如果解析不正确，向请求者返回消息并结束请求）。如果在解析过程中没有检测到任何问题，我们将检查用户名和密码是否与存储在
    `BasicAuthMiddleware` 中的匹配。如果凭证有效，我们将调用装饰后的类型（我们的服务器），但如果凭证无效，我们将收到 `User or password
    incorrect` 的消息，请求将结束。
- en: 'Now, we need to provide the user with a way to choose among different types
    of servers. We will retrieve user input data in the main function. We''ll have
    three options to choose from:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为用户提供一种方式来选择不同类型的服务器。我们将在主函数中检索用户输入数据。我们将有三个选项可供选择：
- en: Simple server
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单服务器
- en: Server with logging
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带日志的服务器
- en: Server with logging and authentication
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带日志和身份验证的服务器
- en: 'We have to use the `Fscanf` function to retrieve input from the user:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `Fscanf` 函数从用户那里获取输入：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Fscanf` function needs an `io.Reader`  implementor as the first argument
    (which is going to be the input in the console), and it takes the server selected
    by the user from it. We'll pass `os.Stdin` as the `io.Reader` interface to retrieve
    user input. Then, we'll write the type of data it is going to parse. The `%d` specifier
    refers to an integer number. Finally, we'll write memory direction to store the
    parsed input, in this case, the memory position of the `selection` variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fscanf` 函数需要一个 `io.Reader` 实现者作为第一个参数（这将是控制台中的输入），并从它获取用户选择的服务器。我们将传递 `os.Stdin`
    作为 `io.Reader` 接口来检索用户输入。然后，我们将写入要解析的数据类型。`%d` 说明符指的是一个整数。最后，我们将写入存储解析输入的内存方向，在这种情况下，是
    `selection` 变量的内存位置。'
- en: 'Once the user selects an option, we can take the basic server and decorate
    it at runtime, switching over to the selected option:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了一个选项，我们就可以在运行时将基本服务器装饰起来，切换到所选选项：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first option will be handled by the default `switch` option--a plain `MyServer`.
    In the case of the second option, we decorate a plain server with logging. The
    third Option is a bit more developed--we ask the user for a username and a password
    using `Fscanf` again. Note that you can scan more than one input, as we are doing
    to retrieve the user and the password. Then, we take the basic server, decorate
    it with authentication, and finally, with logging.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项将由默认的 `switch` 选项处理——一个普通的 `MyServer`。在第二个选项的情况下，我们使用日志装饰一个普通的服务器。第三个选项稍微复杂一些——我们再次使用
    `Fscanf` 请求用户输入用户名和密码。请注意，您可以扫描多个输入，就像我们这样做来检索用户和密码。然后，我们取基本服务器，用身份验证装饰它，最后，用日志装饰。
- en: If you follow the indentation of the nested types of option three, the request
    passes through the logger, then the authentication middleware, and finally, the `MyServer`
    argument if everything is okay. The requests will follow the same route.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循选项三嵌套类型的缩进，请求将通过记录器通过，然后是身份验证中间件，最后是如果一切正常的话，`MyServer` 参数。请求将遵循相同的路径。
- en: 'The end of the main function takes the decorated handler, and launches the
    server on the `8080` port:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数的末尾获取装饰后的处理程序，并在 `8080` 端口启动服务器：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, let''s launch the server with the third option:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们使用第三个选项启动服务器：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will first test the plain server by choosing the first option. Run the server
    with the command **go run server_decorator.go**, and select the first option.
    Then, in a different Terminal, run the basic request with curl, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过选择第一个选项来测试普通服务器。使用命令 **go run server_decorator.go** 运行服务器，并选择第一个选项。然后，在另一个终端中，使用以下命令运行基本的
    curl 请求：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Uh, oh! It doesn''t give us access. We haven''t passed any user and password,
    so it tells us that we cannot continue. Let''s try with some random user and password:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！它没有给我们权限。我们没有通过任何用户名和密码，所以它告诉我们无法继续。让我们尝试使用一些随机的用户名和密码：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'No access! We can also check in the Terminal where we launched the server and
    where every request is being logged:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有权限！我们也可以在启动服务器的终端中检查，那里记录了每一个请求：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, enter the correct username and password:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输入正确的用户名和密码：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we are! Our request has also been logged, and the server has granted access
    to us. Now we can improve our server as much as we want by writing more middlewares
    to decorate the server's functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了！我们的请求也已经记录，服务器已经授予我们访问权限。现在我们可以通过编写更多的中间件来装饰服务器的功能，尽可能多地改进我们的服务器。
