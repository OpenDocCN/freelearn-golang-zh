- en: A few words about Go's structural typing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Go的结构化类型的一些说明
- en: Go has a feature that most people dislike at the beginning--structural typing.
    This is when your structure defines your type without explicitly writing it. For
    example, when you implement an interface, you don't have to write explicitly that
    you are actually implementing it, contrary to languages such as Java where you
    have to write the keyword `implements`. If your method follows the signature of
    the interface, you are actually implementing the interface. This can also lead
    to accidental implementations of interface, something that could provoke an impossible-to-track
    mistake, but that is very unlikely.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个大多数人一开始都不喜欢的特性——结构化类型。这是当你的结构定义了你的类型，而不需要明确写出它的时候。例如，当你实现一个接口时，你不需要明确写出你实际上正在实现它，这与Java等语言不同，在这些语言中你必须写出关键字`implements`。如果你的方法遵循接口的签名，你实际上就是在实现接口。这也可能导致意外实现接口，这可能会引发难以追踪的错误，但这种情况非常不可能。
- en: 'However, structural typing also allows you to define an interface after defining
    their implementers. Imagine a `MyPrinter` struct as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结构化类型也允许你在定义了实现者之后定义接口。想象一下以下`MyPrinter`结构体：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Imagine we have been working with the `MyPrinter` type for few months now,
    but it didn''t implement any interface, so it can''t be a possible candidate for
    a Decorator pattern, or maybe it can? What if we wrote an interface that matches
    its `Print` method after a few months? Consider the following code snippet:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们已经和`MyPrinter`类型一起工作了数月，但它没有实现任何接口，所以它不能成为装饰器模式的可能候选者，或者也许它可以？如果我们几个月后编写了一个匹配其`Print`方法的接口会怎样？考虑以下代码片段：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It actually implements the `Printer` interface, and we can use it to create
    a Decorator solution.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它实现了`Printer`接口，我们可以用它来创建一个装饰器解决方案。
- en: Structural typing allows a lot of flexibility when writing programs. If you
    don't know whether a type should be a part of an interface or not, you can leave
    it and add the interface later, when you are completely sure about it. This way,
    you can decorate types very easily and with little modification in your source
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型在编写程序时提供了很大的灵活性。如果你不确定一个类型是否应该是接口的一部分，你可以先不添加，稍后再添加接口，当你完全确定时。这样，你可以非常容易地装饰类型，并且对源代码的修改很少。
