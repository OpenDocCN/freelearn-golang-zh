- en: A few words about Go's structural typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go has a feature that most people dislike at the beginning--structural typing.
    This is when your structure defines your type without explicitly writing it. For
    example, when you implement an interface, you don't have to write explicitly that
    you are actually implementing it, contrary to languages such as Java where you
    have to write the keyword `implements`. If your method follows the signature of
    the interface, you are actually implementing the interface. This can also lead
    to accidental implementations of interface, something that could provoke an impossible-to-track
    mistake, but that is very unlikely.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, structural typing also allows you to define an interface after defining
    their implementers. Imagine a `MyPrinter` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine we have been working with the `MyPrinter` type for few months now,
    but it didn''t implement any interface, so it can''t be a possible candidate for
    a Decorator pattern, or maybe it can? What if we wrote an interface that matches
    its `Print` method after a few months? Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It actually implements the `Printer` interface, and we can use it to create
    a Decorator solution.
  prefs: []
  type: TYPE_NORMAL
- en: Structural typing allows a lot of flexibility when writing programs. If you
    don't know whether a type should be a part of an interface or not, you can leave
    it and add the interface later, when you are completely sure about it. This way,
    you can decorate types very easily and with little modification in your source
    code.
  prefs: []
  type: TYPE_NORMAL
