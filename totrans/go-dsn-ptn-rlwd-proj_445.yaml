- en: Summarizing the Decorator design pattern - Proxy versus Decorator
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结装饰器设计模式 - 代理与装饰器
- en: You might be wondering, what's the difference between the Decorator pattern
    and the Proxy pattern? In the Decorator pattern, we decorate a type dynamically.
    This means that the decoration may or may not be there, or it may be composed
    of one or many types. If you remember, the Proxy pattern wraps a type in a similar
    fashion, but it does so at compile time and it's more like a way to access some
    type.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，装饰器模式和代理模式之间有什么区别？在装饰器模式中，我们动态地装饰一个类型。这意味着装饰可能存在也可能不存在，或者它可能由一个或多个类型组成。如果你还记得，代理模式以类似的方式包装一个类型，但它是在编译时进行的，它更像是一种访问某些类型的方式。
- en: At the same time, a decorator might implement the entire interface that the
    type it decorates also implements **or not**. So you can have an interface with
    10 methods and a decorator that just implements one of them and it will still
    be valid. A call on a method not implemented by the decorator will be passed to
    the decorated type. This is a very powerful feature but also very prone to undesired
    behaviors at runtime if you forget to implement any interface method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，装饰器可能实现它所装饰的类型所实现的整个接口，也可能不实现。这意味着你可以有一个包含10个方法的接口，而装饰器只实现其中的一个，它仍然有效。调用装饰器未实现的方法将传递给被装饰的类型。这是一个非常强大的功能，但如果你忘记实现任何接口方法，在运行时也可能会出现不期望的行为。
- en: In this aspect, you may think that the Proxy pattern is less flexible, and it
    is. But the Decorator pattern is weaker, as you could have errors at runtime,
    which you can avoid at compile time by using the Proxy pattern. Just keep in mind
    that the Decorator is commonly used when you want to add functionality to an object
    at runtime, like in our web server. It's a compromise between what you need and
    what you want to sacrifice to achieve it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方面，你可能认为代理模式不太灵活，确实如此。但装饰器模式较弱，因为你在运行时可能会遇到错误，而使用代理模式可以在编译时避免这些错误。只需记住，装饰器通常用于在运行时向对象添加功能，比如在我们的Web服务器中。这是在所需功能和为了实现它而愿意牺牲的东西之间的折衷。
