- en: Summarizing the Decorator design pattern - Proxy versus Decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be wondering, what's the difference between the Decorator pattern
    and the Proxy pattern? In the Decorator pattern, we decorate a type dynamically.
    This means that the decoration may or may not be there, or it may be composed
    of one or many types. If you remember, the Proxy pattern wraps a type in a similar
    fashion, but it does so at compile time and it's more like a way to access some
    type.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, a decorator might implement the entire interface that the
    type it decorates also implements **or not**. So you can have an interface with
    10 methods and a decorator that just implements one of them and it will still
    be valid. A call on a method not implemented by the decorator will be passed to
    the decorated type. This is a very powerful feature but also very prone to undesired
    behaviors at runtime if you forget to implement any interface method.
  prefs: []
  type: TYPE_NORMAL
- en: In this aspect, you may think that the Proxy pattern is less flexible, and it
    is. But the Decorator pattern is weaker, as you could have errors at runtime,
    which you can avoid at compile time by using the Proxy pattern. Just keep in mind
    that the Decorator is commonly used when you want to add functionality to an object
    at runtime, like in our web server. It's a compromise between what you need and
    what you want to sacrifice to achieve it.
  prefs: []
  type: TYPE_NORMAL
