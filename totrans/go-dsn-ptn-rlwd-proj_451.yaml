- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with our API Facade, we will need an interface with the methods asked
    in *acceptance criteria 2* and *acceptance criteria 3*:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will call *acceptance criteria 2* `GetByCityAndCountryCode`; we will also
    need a city name and a country code in the string format. A country code is a
    two-character code, which represents the **International Organization for Standardization**
    (**ISO**) name of world countries. It returns a `Weather` value, which we will
    define later, and an error if something goes wrong.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '*Acceptance criteria 3* will be called `GetByGeoCoordinates`, and will need
    latitude and longitude values in the `float32` format. It will also return a `Weather`
    value and an error. The `Weather` value is going to be defined according to the
    returned JSON that the `OpenWeatherMap` API works with. You can find the description
    of this JSON at the webpage [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the JSON definition, it has the following type:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It''s quite a long struct, but we have everything that a response could include.
    The struct is called `Weather`, as it is composed of an ID, a name and a Code
    (`Cod`), and a few anonymous structs, which are: `Coord`, `Weather`, `Base`, `Main`,
    `Wind`, `Clouds`, `Rain`, `Dt`, and `Sys`. We could write these anonymous structs
    outside of the `Weather` struct by giving them a name, but it would only be useful
    if we have to work with them separately.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: After every member and struct within our `Weather` struct, you can find a ``
    `json:"something"` `` line. This comes in handy when differentiating between the
    JSON key name and your member name. If the JSON key is `something`, we aren't
    forced to call our member `something`. For example, our ID member will be called
    `id` in the JSON response.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Why don''t we give the name of the JSON keys to our types? Well, if your fields
    in your type are lowercase, the `encoding/json` package won''t parse them correctly.
    Also, that last annotation provides us a certain flexibility, not only in terms
    of changing the members'' names, but also of omitting some key if we don''t need
    it, with the following signature:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With `omitempty` at the end, the parse won't fail if this key is not present
    in the bytes representation of the JSON key.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, our acceptance criteria 1 ask for a single point of access to the API.
    This is going to be called `CurrentWeatherData`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CurrentWeatherData` type has an API key as public member to work. This
    is because you have to be a registered user in `OpenWeatherMap` to enjoy their
    services. Refer to the `OpenWeatherMap` API's webpage for documentation on how
    to get an API key. We won't need it in our example, because we aren't going to
    do integration tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'We need mock data so that we can write a `mock` function to retrieve the data.
    When sending an HTTP request, the response is contained in a member called body
    in the form of an `io.Reader`. We have already worked with types that implement
    the `io.Reader` interface, so this should look familiar to you. Our `mock` function
    appears like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要模拟数据，这样我们就可以编写一个 `mock` 函数来检索数据。在发送 HTTP 请求时，响应包含在形式为 `io.Reader` 的成员 `body`
    中。我们已经处理过实现 `io.Reader` 接口的数据类型，所以这应该对你来说很熟悉。我们的 `mock` 函数看起来像这样：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This preceding mocked data was produced by making a request to `OpenWeatherMap`
    using an API key. The `response` variable is a string containing a JSON response.
    Take a close look at the grave accent (`` ` ``) used to open and close the string.
    This way, you can use as many quotes as you want without any problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之前生成的模拟数据是通过使用 API 密钥向 `OpenWeatherMap` 发送请求得到的。`response` 变量是一个包含 JSON 响应的字符串。仔细观察用于打开和关闭字符串的重音符（``
    ` ``）。这样，你可以使用任意多的引号而不会出现任何问题。
- en: Further on, we use a special function in the bytes package called `NewReader`,
    which accepts an slice of bytes (which we create by converting the type from string),
    and returns an `io.Reader` implementor with the contents of the slice. This is
    perfect to mimic the `Body` member of an HTTP response.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们在 bytes 包中使用一个特殊函数，名为 `NewReader`，它接受一个字节数组切片（我们通过将类型从字符串转换创建），并返回一个包含切片内容的
    `io.Reader` 实现。这非常适合模拟 HTTP 响应的 `Body` 成员。
- en: 'We will write a test to try `response parser`. Both methods return the same
    type, so we can use the same `JSON parser` for both:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个测试来尝试 `response parser`。这两个方法返回相同的数据类型，因此我们可以为两者使用相同的 `JSON parser`：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding test, we first asked for some mock data, which we store in
    the variable `r`. Later, we created a type of `CurrentWeatherData`, which we called
    `openWeatherMap`. Finally, we asked for a weather value for the provided `io.Reader` interface
    that we store in the variable `weather`. After checking for errors, we make sure
    that the ID is the same as the one stored in the mock data that we got from the
    `getMockData` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们首先请求了一些模拟数据，我们将其存储在变量 `r` 中。后来，我们创建了一个名为 `CurrentWeatherData` 的类型，我们称之为
    `openWeatherMap`。最后，我们为提供的 `io.Reader` 接口请求天气值，并将其存储在变量 `weather` 中。在检查错误后，我们确保
    ID 与我们从 `getMockData` 方法获取的模拟数据中存储的 ID 相同。
- en: 'We have to declare the `responseParser` method before running tests, or the
    code won''t compile:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在运行测试之前声明 `responseParser` 方法，否则代码将无法编译：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With all the aforementioned, we can run this test:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，我们可以运行这个测试：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Okay. We won't write more tests, because the rest would be merely integration
    tests, which are outside of the scope of explanation of a structural pattern,
    and will force us to have an API key as well as an Internet connection. If you
    want to see what the integration tests look like for this example, refer to the
    code that comes bundled with the book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们不会编写更多的测试，因为剩下的将仅仅是集成测试，这超出了结构模式解释的范围，并且将迫使我们拥有一个 API 密钥以及互联网连接。如果你想看到这个示例的集成测试是什么样的，请参考书中附带的相关代码。
