- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To start with our API Facade, we will need an interface with the methods asked
    in *acceptance criteria 2* and *acceptance criteria 3*:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的 API Facade，我们需要一个具有 *验收标准 2* 和 *验收标准 3* 中要求的方法的接口：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will call *acceptance criteria 2* `GetByCityAndCountryCode`; we will also
    need a city name and a country code in the string format. A country code is a
    two-character code, which represents the **International Organization for Standardization**
    (**ISO**) name of world countries. It returns a `Weather` value, which we will
    define later, and an error if something goes wrong.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 *验收标准 2* 称为 `GetByCityAndCountryCode`；我们还需要一个城市名称和字符串格式的国家代码。国家代码是两个字符的代码，代表世界国家的
    **国际标准化组织** (**ISO**) 名称。它返回一个我们稍后将定义的 `Weather` 值，如果出现问题，则返回一个错误。
- en: '*Acceptance criteria 3* will be called `GetByGeoCoordinates`, and will need
    latitude and longitude values in the `float32` format. It will also return a `Weather`
    value and an error. The `Weather` value is going to be defined according to the
    returned JSON that the `OpenWeatherMap` API works with. You can find the description
    of this JSON at the webpage [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*验收标准 3* 将被命名为 `GetByGeoCoordinates`，需要 `float32` 格式的纬度和经度值。它也将返回一个 `Weather`
    值和一个错误。`Weather` 值将根据 `OpenWeatherMap` API 使用的返回 JSON 来定义。你可以在网页 [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON)
    上找到这个 JSON 的描述。'
- en: 'If you look at the JSON definition, it has the following type:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 JSON 定义，它具有以下类型：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It''s quite a long struct, but we have everything that a response could include.
    The struct is called `Weather`, as it is composed of an ID, a name and a Code
    (`Cod`), and a few anonymous structs, which are: `Coord`, `Weather`, `Base`, `Main`,
    `Wind`, `Clouds`, `Rain`, `Dt`, and `Sys`. We could write these anonymous structs
    outside of the `Weather` struct by giving them a name, but it would only be useful
    if we have to work with them separately.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的结构体，但我们包含了响应可能包含的所有内容。这个结构体被称为 `Weather`，因为它由一个 ID、一个名称和一个代码 (`Cod`)
    以及几个匿名结构体组成，这些结构体是：`Coord`、`Weather`、`Base`、`Main`、`Wind`、`Clouds`、`Rain`、`Dt`
    和 `Sys`。我们可以通过给它们一个名字将这两个匿名结构体写在外部的 `Weather` 结构体之外，但这只有在我们必须单独处理它们时才有用。
- en: After every member and struct within our `Weather` struct, you can find a ``
    `json:"something"` `` line. This comes in handy when differentiating between the
    JSON key name and your member name. If the JSON key is `something`, we aren't
    forced to call our member `something`. For example, our ID member will be called
    `id` in the JSON response.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Weather` 结构体中的每个成员和结构体之后，你都可以找到一个 `json:"something"` 行。这在区分 JSON 键名和你的成员名时很有用。如果
    JSON 键是 `something`，我们不必将我们的成员命名为 `something`。例如，我们的 ID 成员在 JSON 响应中将被命名为 `id`。
- en: 'Why don''t we give the name of the JSON keys to our types? Well, if your fields
    in your type are lowercase, the `encoding/json` package won''t parse them correctly.
    Also, that last annotation provides us a certain flexibility, not only in terms
    of changing the members'' names, but also of omitting some key if we don''t need
    it, with the following signature:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不给我们的类型命名 JSON 键名呢？好吧，如果你的类型中的字段是小写的，`encoding/json` 包将无法正确解析它们。此外，最后一个注解为我们提供了一定的灵活性，不仅在于更改成员的名称，还在于如果我们不需要某些键，可以省略它们，其签名如下：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With `omitempty` at the end, the parse won't fail if this key is not present
    in the bytes representation of the JSON key.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾加上 `omitempty`，如果这个键不在 JSON 键的字节表示中，解析不会失败。
- en: 'Okay, our acceptance criteria 1 ask for a single point of access to the API.
    This is going to be called `CurrentWeatherData`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的验收标准 1 要求对 API 的单一访问点。这将被称为 `CurrentWeatherData`：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CurrentWeatherData` type has an API key as public member to work. This
    is because you have to be a registered user in `OpenWeatherMap` to enjoy their
    services. Refer to the `OpenWeatherMap` API's webpage for documentation on how
    to get an API key. We won't need it in our example, because we aren't going to
    do integration tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentWeatherData` 类型有一个作为公共成员的 API 密钥来工作。这是因为你必须成为 `OpenWeatherMap` 的注册用户才能享受他们的服务。请参考
    `OpenWeatherMap` API 的网页了解如何获取 API 密钥的文档。在我们的示例中我们不需要它，因为我们不会进行集成测试。'
- en: 'We need mock data so that we can write a `mock` function to retrieve the data.
    When sending an HTTP request, the response is contained in a member called body
    in the form of an `io.Reader`. We have already worked with types that implement
    the `io.Reader` interface, so this should look familiar to you. Our `mock` function
    appears like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要模拟数据，这样我们就可以编写一个 `mock` 函数来检索数据。在发送 HTTP 请求时，响应包含在形式为 `io.Reader` 的成员 `body`
    中。我们已经处理过实现 `io.Reader` 接口的数据类型，所以这应该对你来说很熟悉。我们的 `mock` 函数看起来像这样：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This preceding mocked data was produced by making a request to `OpenWeatherMap`
    using an API key. The `response` variable is a string containing a JSON response.
    Take a close look at the grave accent (`` ` ``) used to open and close the string.
    This way, you can use as many quotes as you want without any problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之前生成的模拟数据是通过使用 API 密钥向 `OpenWeatherMap` 发送请求得到的。`response` 变量是一个包含 JSON 响应的字符串。仔细观察用于打开和关闭字符串的重音符（``
    ` ``）。这样，你可以使用任意多的引号而不会出现任何问题。
- en: Further on, we use a special function in the bytes package called `NewReader`,
    which accepts an slice of bytes (which we create by converting the type from string),
    and returns an `io.Reader` implementor with the contents of the slice. This is
    perfect to mimic the `Body` member of an HTTP response.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们在 bytes 包中使用一个特殊函数，名为 `NewReader`，它接受一个字节数组切片（我们通过将类型从字符串转换创建），并返回一个包含切片内容的
    `io.Reader` 实现。这非常适合模拟 HTTP 响应的 `Body` 成员。
- en: 'We will write a test to try `response parser`. Both methods return the same
    type, so we can use the same `JSON parser` for both:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个测试来尝试 `response parser`。这两个方法返回相同的数据类型，因此我们可以为两者使用相同的 `JSON parser`：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding test, we first asked for some mock data, which we store in
    the variable `r`. Later, we created a type of `CurrentWeatherData`, which we called
    `openWeatherMap`. Finally, we asked for a weather value for the provided `io.Reader` interface
    that we store in the variable `weather`. After checking for errors, we make sure
    that the ID is the same as the one stored in the mock data that we got from the
    `getMockData` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们首先请求了一些模拟数据，我们将其存储在变量 `r` 中。后来，我们创建了一个名为 `CurrentWeatherData` 的类型，我们称之为
    `openWeatherMap`。最后，我们为提供的 `io.Reader` 接口请求天气值，并将其存储在变量 `weather` 中。在检查错误后，我们确保
    ID 与我们从 `getMockData` 方法获取的模拟数据中存储的 ID 相同。
- en: 'We have to declare the `responseParser` method before running tests, or the
    code won''t compile:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在运行测试之前声明 `responseParser` 方法，否则代码将无法编译：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With all the aforementioned, we can run this test:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，我们可以运行这个测试：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Okay. We won't write more tests, because the rest would be merely integration
    tests, which are outside of the scope of explanation of a structural pattern,
    and will force us to have an API key as well as an Internet connection. If you
    want to see what the integration tests look like for this example, refer to the
    code that comes bundled with the book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们不会编写更多的测试，因为剩下的将仅仅是集成测试，这超出了结构模式解释的范围，并且将迫使我们拥有一个 API 密钥以及互联网连接。如果你想看到这个示例的集成测试是什么样的，请参考书中附带的相关代码。
