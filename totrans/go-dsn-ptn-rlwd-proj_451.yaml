- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with our API Facade, we will need an interface with the methods asked
    in *acceptance criteria 2* and *acceptance criteria 3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will call *acceptance criteria 2* `GetByCityAndCountryCode`; we will also
    need a city name and a country code in the string format. A country code is a
    two-character code, which represents the **International Organization for Standardization**
    (**ISO**) name of world countries. It returns a `Weather` value, which we will
    define later, and an error if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '*Acceptance criteria 3* will be called `GetByGeoCoordinates`, and will need
    latitude and longitude values in the `float32` format. It will also return a `Weather`
    value and an error. The `Weather` value is going to be defined according to the
    returned JSON that the `OpenWeatherMap` API works with. You can find the description
    of this JSON at the webpage [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the JSON definition, it has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite a long struct, but we have everything that a response could include.
    The struct is called `Weather`, as it is composed of an ID, a name and a Code
    (`Cod`), and a few anonymous structs, which are: `Coord`, `Weather`, `Base`, `Main`,
    `Wind`, `Clouds`, `Rain`, `Dt`, and `Sys`. We could write these anonymous structs
    outside of the `Weather` struct by giving them a name, but it would only be useful
    if we have to work with them separately.'
  prefs: []
  type: TYPE_NORMAL
- en: After every member and struct within our `Weather` struct, you can find a ``
    `json:"something"` `` line. This comes in handy when differentiating between the
    JSON key name and your member name. If the JSON key is `something`, we aren't
    forced to call our member `something`. For example, our ID member will be called
    `id` in the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why don''t we give the name of the JSON keys to our types? Well, if your fields
    in your type are lowercase, the `encoding/json` package won''t parse them correctly.
    Also, that last annotation provides us a certain flexibility, not only in terms
    of changing the members'' names, but also of omitting some key if we don''t need
    it, with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With `omitempty` at the end, the parse won't fail if this key is not present
    in the bytes representation of the JSON key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, our acceptance criteria 1 ask for a single point of access to the API.
    This is going to be called `CurrentWeatherData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `CurrentWeatherData` type has an API key as public member to work. This
    is because you have to be a registered user in `OpenWeatherMap` to enjoy their
    services. Refer to the `OpenWeatherMap` API's webpage for documentation on how
    to get an API key. We won't need it in our example, because we aren't going to
    do integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need mock data so that we can write a `mock` function to retrieve the data.
    When sending an HTTP request, the response is contained in a member called body
    in the form of an `io.Reader`. We have already worked with types that implement
    the `io.Reader` interface, so this should look familiar to you. Our `mock` function
    appears like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This preceding mocked data was produced by making a request to `OpenWeatherMap`
    using an API key. The `response` variable is a string containing a JSON response.
    Take a close look at the grave accent (`` ` ``) used to open and close the string.
    This way, you can use as many quotes as you want without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: Further on, we use a special function in the bytes package called `NewReader`,
    which accepts an slice of bytes (which we create by converting the type from string),
    and returns an `io.Reader` implementor with the contents of the slice. This is
    perfect to mimic the `Body` member of an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a test to try `response parser`. Both methods return the same
    type, so we can use the same `JSON parser` for both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we first asked for some mock data, which we store in
    the variable `r`. Later, we created a type of `CurrentWeatherData`, which we called
    `openWeatherMap`. Finally, we asked for a weather value for the provided `io.Reader` interface
    that we store in the variable `weather`. After checking for errors, we make sure
    that the ID is the same as the one stored in the mock data that we got from the
    `getMockData` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to declare the `responseParser` method before running tests, or the
    code won''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the aforementioned, we can run this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Okay. We won't write more tests, because the rest would be merely integration
    tests, which are outside of the scope of explanation of a structural pattern,
    and will force us to have an API key as well as an Internet connection. If you
    want to see what the integration tests look like for this example, refer to the
    code that comes bundled with the book.
  prefs: []
  type: TYPE_NORMAL
