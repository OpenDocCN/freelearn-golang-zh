- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'First of all, we are going to implement the parser that our methods will use
    to parse the JSON response from the `OpenWeatherMap` REST API:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现我们的方法将使用的解析器，以解析来自`OpenWeatherMap` REST API的JSON响应：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And this should be enough to pass the test by now:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该足以通过测试：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At least we have our parser well tested. Let''s structure our code to look
    like a library. First, we will create the methods to retrieve the weather of a
    city by its name and its country code, and the method that uses its latitude and
    longitude:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们的解析器已经得到了很好的测试。让我们将我们的代码结构化，使其看起来像一个库。首先，我们将创建通过城市名称和国家代码获取天气的方法，以及使用其纬度和经度的方法：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A piece of cake? Of course! Everything must be as easy as possible, and it is
    a sign of a good job. The complexity in this facade is to create connections to
    the `OpenWeatherMap` API, and control the possible errors. This problem is shared
    between all the Facade methods in our example, so we don't need to write more
    than one API call right now.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一件小菜一碟？当然！一切必须尽可能简单，这是好工作的标志。在这个外观背后的复杂性是创建到`OpenWeatherMap` API的连接和控制可能出现的错误。这个问题在我们示例的所有外观方法之间是共享的，所以我们现在不需要编写超过一个API调用。
- en: 'What we do is pass the URL that the REST API needs in order to return the information
    we desire. This is achieved by the `fmt.Sprintf` function, which formats the strings
    in each case. For example, to gather the data using a city name and a country
    code, we use the following string:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是传递REST API所需的URL，以便返回我们所需的信息。这是通过`fmt.Sprintf`函数实现的，该函数在每种情况下格式化字符串。例如，要使用城市名称和国家代码来收集数据，我们使用以下字符串：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This takes the pre-formatted string [https://openweathermap.org/api](https://openweathermap.org/api)
    and formats it by replacing each `%s` specifier with the city, the `countryCode`
    that we introduced in the arguments, and the API key member of the `CurrentWeatherData`
    type.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这将预格式化的字符串[https://openweathermap.org/api](https://openweathermap.org/api)格式化，通过将每个`%s`指定符替换为城市、我们在参数中引入的`countryCode`以及`CurrentWeatherData`类型的API密钥成员。
- en: But, we haven't set any API key! Yes, because this is a library, and the users
    of the library will have to use their own API keys. We are hiding the complexity
    of creating the URIs, and handling the errors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们没有设置任何API密钥！是的，因为这是一个库，库的用户将必须使用他们自己的API密钥。我们正在隐藏创建URI和处理错误的复杂性。
- en: 'Finally, the `doRequest` function is a big fish, so we will see it in detail,
    step by step:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`doRequest`函数是一个大鱼，我们将逐步详细地查看它：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, the signature tells us that the `doRequest` method accepts a URI string,
    and returns a pointer to the `Weather` variable and an error. We start by creating
    an `http.Client` class, which will make the requests. Then, we create a request
    object, which will use the `GET` method, as described in the `OpenWeatherMap`
    webpage, and the URI we passed. If we were to use a different method, or more
    than one, they would have to be brought about by arguments in the signature. Nevertheless,
    we will use just the `GET` method, so we could hardcode it there.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，签名告诉我们`doRequest`方法接受一个URI字符串，并返回一个指向`Weather`变量的指针和一个错误。我们首先创建一个`http.Client`类，它将发出请求。然后，我们创建一个请求对象，它将使用`GET`方法，如`OpenWeatherMap`网页所述，以及我们传递的URI。如果我们使用不同的方法，或者使用多个方法，它们必须通过签名中的参数来实现。然而，我们将只使用`GET`方法，因此我们可以将其硬编码在那里。
- en: 'Then, we check whether the request object has been created successfully, and
    set a header that says that the content type is a JSON:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查请求对象是否已成功创建，并设置一个标题，说明内容类型是JSON：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then we make the request, and check for errors. Because we have given names
    to our return types, if any error occurs, we just have to return the function,
    and Go will return the variable `err` and the variable `weather` in the state
    they were in at that precise moment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们发出请求，并检查错误。因为我们已经给返回类型命名了，如果发生任何错误，我们只需返回函数，Go就会返回变量`err`和变量`weather`在那一刻的状态。
- en: 'We check the status code of the response, as we only accept 200 as a good response.
    If 200 isn''t returned, we will create an error message with the contents of the
    body and the status code returned:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查响应的状态码，因为我们只接受200作为良好的响应。如果返回的不是200，我们将创建一个包含正文内容和返回状态码的错误消息：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, if everything goes well, we use the `responseParser` function we wrote
    earlier to parse the contents of Body, which is an `io.Reader` interface. Maybe
    you are wondering why we aren't controlling `err` from the `response parser` method.
    It's funny, because we are actually controlling it. `responseParser` and `doRequest`
    have the same return signature. Both return a `Weather` pointer and an error (if
    any), so we can return directly whatever the result was.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，我们使用我们之前编写的 `responseParser` 函数来解析 Body 的内容，它是一个 `io.Reader` 接口。也许你正在想，为什么我们没有从
    `response parser` 方法中控制 `err`。这很有趣，因为我们实际上是在控制它。`responseParser` 和 `doRequest`
    有相同的返回签名。两者都返回一个 `Weather` 指针和一个错误（如果有），所以我们可以直接返回任何结果。
