- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we are going to implement the parser that our methods will use
    to parse the JSON response from the `OpenWeatherMap` REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And this should be enough to pass the test by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At least we have our parser well tested. Let''s structure our code to look
    like a library. First, we will create the methods to retrieve the weather of a
    city by its name and its country code, and the method that uses its latitude and
    longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A piece of cake? Of course! Everything must be as easy as possible, and it is
    a sign of a good job. The complexity in this facade is to create connections to
    the `OpenWeatherMap` API, and control the possible errors. This problem is shared
    between all the Facade methods in our example, so we don't need to write more
    than one API call right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we do is pass the URL that the REST API needs in order to return the information
    we desire. This is achieved by the `fmt.Sprintf` function, which formats the strings
    in each case. For example, to gather the data using a city name and a country
    code, we use the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This takes the pre-formatted string [https://openweathermap.org/api](https://openweathermap.org/api)
    and formats it by replacing each `%s` specifier with the city, the `countryCode`
    that we introduced in the arguments, and the API key member of the `CurrentWeatherData`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: But, we haven't set any API key! Yes, because this is a library, and the users
    of the library will have to use their own API keys. We are hiding the complexity
    of creating the URIs, and handling the errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `doRequest` function is a big fish, so we will see it in detail,
    step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, the signature tells us that the `doRequest` method accepts a URI string,
    and returns a pointer to the `Weather` variable and an error. We start by creating
    an `http.Client` class, which will make the requests. Then, we create a request
    object, which will use the `GET` method, as described in the `OpenWeatherMap`
    webpage, and the URI we passed. If we were to use a different method, or more
    than one, they would have to be brought about by arguments in the signature. Nevertheless,
    we will use just the `GET` method, so we could hardcode it there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we check whether the request object has been created successfully, and
    set a header that says that the content type is a JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then we make the request, and check for errors. Because we have given names
    to our return types, if any error occurs, we just have to return the function,
    and Go will return the variable `err` and the variable `weather` in the state
    they were in at that precise moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We check the status code of the response, as we only accept 200 as a good response.
    If 200 isn''t returned, we will create an error message with the contents of the
    body and the status code returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if everything goes well, we use the `responseParser` function we wrote
    earlier to parse the contents of Body, which is an `io.Reader` interface. Maybe
    you are wondering why we aren't controlling `err` from the `response parser` method.
    It's funny, because we are actually controlling it. `responseParser` and `doRequest`
    have the same return signature. Both return a `Weather` pointer and an error (if
    any), so we can return directly whatever the result was.
  prefs: []
  type: TYPE_NORMAL
