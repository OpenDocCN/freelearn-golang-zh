- en: Example
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: To give an example, we are going to simulate something that you find on betting
    webpages. Imagine the final match of the European championship, which is viewed
    by millions of people across the continent. Now imagine that we own a betting
    webpage, where we provide historical information about every team in Europe. This
    is plenty of information, which is usually stored in some distributed database,
    and each team has, literally, megabytes of information about their players, matches,
    championships, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们将模拟你在投注网页上看到的东西。想象一下欧洲锦标赛的决赛，这是整个大陆数百万人所观看的。现在想象一下我们拥有一个投注网页，我们提供关于欧洲每个球队的历史信息。这是大量的信息，通常存储在一些分布式数据库中，每个球队都有关于他们的球员、比赛、锦标赛等等的数兆字节信息。
- en: If a million users access information about a team and a new instance of the
    information is created for each user querying for historical data, we will run
    out of memory in the blink of an eye. With our Proxy solution, we could make a
    cache of the *n* most recent searches to speed up queries, but if we return a
    clone for every team, we will still get short on memory (but faster thanks to
    our cache). Funny, right?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一百万用户访问关于一支球队的信息，并且为每个查询历史数据的用户创建一个新实例，我们会在一瞬间耗尽内存。有了我们的代理解决方案，我们可以缓存最近的*n*次搜索以加快查询速度，但如果为每个球队返回一个副本，我们仍然会内存不足（但得益于我们的缓存，速度会更快）。有趣，对吧？
- en: Instead, we will store each team's information just once, and we will deliver
    references to them to the users. So, if we face a million users trying to access
    information about a match, we will actually just have two teams in memory with
    a million pointers to the same memory direction.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将只存储每个球队的信息一次，并将它们的引用提供给用户。因此，如果我们面对一百万试图访问比赛信息用户，实际上我们只需在内存中保留两支球队，以及一百万指向相同内存方向的指针。
