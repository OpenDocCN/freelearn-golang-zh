<html><head></head><body>
<div class="book" title="Flyweight design pattern">
<div class="book" title="Basic structs and tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec0116" class="calibre1"/>Basic structs and tests</h2></div></div></div><p class="calibre10">Our <code class="email">Team</code> struct will contain other structs inside, so a total of four structs will be created. The <code class="email">Team</code> struct has the following signature:</p><pre class="programlisting">type Team struct { 
  ID             uint64 
  Name           string 
  Shield         []byte 
  Players        []Player 
  HistoricalData []HistoricalData 
} 
</pre><p class="calibre10">Each team has an ID, a name, some image in an slice of bytes representing the team's shield, a slice of players, and a slice of historical data. This way, we will have two teams' ID:</p><pre class="programlisting">const ( 
  TEAM_A = iota 
  TEAM_B 
) 
</pre><p class="calibre10">We declare two constants by using the <code class="email">const</code> and <code class="email">iota</code> keywords. The <code class="email">const</code> keyword simply declares that the following declarations are constants. <code class="email">iota</code> is a untyped integer that automatically increments its value for each new constant between the parentheses. The <code class="email">iota</code> value starts to reset to 0 when we declare <code class="email">TEAM_A</code>, so <code class="email">TEAM_A</code> is equal to 0. On the <code class="email">TEAM_B</code> variable, <code class="email">iota</code> is incremented by one so <code class="email">TEAM_B</code> is equal to 1. The <code class="email">iota</code> assignment is an elegant way to save typing when declaring constant values that doesn't need specific value (like the <span class="strong"><em class="calibre11">Pi</em></span> constant on the <code class="email">math</code> package).</p><p class="calibre10">Our <code class="email">Player</code> and <code class="email">HistoricalData</code> are the following:</p><pre class="programlisting">type Player struct { 
  Name    string 
  Surname string 
  PreviousTeam uint64 
  Photo   []byte 
} 
 
type HistoricalData struct { 
  Year          uint8 
  LeagueResults []Match 
} 
</pre><p class="calibre10">As you can see, we also need a <code class="email">Match</code> struct, which is stored within <code class="email">HistoricalData</code> struct. A <code class="email">Match</code> struct, in this context, represents the historical result of a match:</p><pre class="programlisting">type Match struct { 
  Date          time.Time 
  VisitorID     uint64 
  LocalID       uint64 
  LocalScore    byte 
  VisitorScore  byte 
  LocalShoots   uint16 
  VisitorShoots uint16 
} 
</pre><p class="calibre10">This is enough to represent a team, and to fulfill <span class="strong"><em class="calibre11">Acceptance Criteria 1</em></span>. You have probably guessed that there is a lot of information on each team, as some of the European teams have existed for more than 100 years.</p><p class="calibre10">For <span class="strong"><em class="calibre11">Acceptance Criteria 2,</em></span> the word <span class="strong"><em class="calibre11">creation</em></span> should give us some clue about how to approach this problem. We will build a factory to create and store our teams. Our Factory will consist of a map of years, including pointers to <code class="email">Teams</code> as values, and a <code class="email">GetTeam</code> function. Using a map will boost the team search if we know their names in advance. We will also dispose of a method to return the number of created objects, which will be called the <code class="email">GetNumberOfObjects</code> method:</p><pre class="programlisting">type teamFlyweightFactory struct { 
  createdTeams map[string]*Team 
} 
 
func (t *teamFlyweightFactory) GetTeam(name string) *Team { 
  return nil 
} 
 
func (t *teamFlyweightFactory) GetNumberOfObjects() int { 
  return 0 
} 
</pre><p class="calibre10">This is enough to write our first unit test:</p><pre class="programlisting">func TestTeamFlyweightFactory_GetTeam(t *testing.T) { 
  factory := teamFlyweightFactory{} 
 
teamA1 := factory.GetTeam(TEAM_A) 
  if teamA1 == nil { 
    t.Error("The pointer to the TEAM_A was nil") 
  } 
 
  teamA2 := factory.GetTeam(TEAM_A) 
  if teamA2 == nil { 
    t.Error("The pointer to the TEAM_A was nil") 
  } 
 
  if teamA1 != teamA2 { 
    t.Error("TEAM_A pointers weren't the same") 
  } 
 
  if factory.GetNumberOfObjects() != 1 { 
    t.Errorf("The number of objects created was not 1: %d\n", factory.GetNumberOfObjects()) 
  } 
} 
</pre><p class="calibre10">In our test, we verify all the acceptance criteria. First we create a factory, and then ask for a pointer of <code class="email">TEAM_A</code>. This pointer cannot be <code class="email">nil</code>, or the test will fail.</p><p class="calibre10">Then we call for a second pointer to the same team. This pointer can't be nil either, and it should point to the same memory address as the previous one so we know that it has not allocated a new memory.</p><p class="calibre10">Finally, we should check whether the number of created teams is only one, because we have asked for the same team twice. We have two pointers but just one instance of the team. Let's run the tests:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=GetTeam .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTeamFlyweightFactory_GetTeam</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">flyweight_test.go:11: The pointer to the TEAM_A was nil</strong></span>
<span class="strong"><strong class="calibre2">flyweight_test.go:21: The pointer to the TEAM_A was nil</strong></span>
<span class="strong"><strong class="calibre2">flyweight_test.go:31: The number of objects created was not 1: 0</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Well, it failed. Both pointers were nil and it has not created any object. Interestingly, the function that compares the two pointers doesn't fail; all in all, nil equals nil.</p></div></div></body></html>