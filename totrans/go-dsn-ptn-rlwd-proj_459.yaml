- en: Basic structs and tests
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本结构和测试
- en: 'Our `Team` struct will contain other structs inside, so a total of four structs
    will be created. The `Team` struct has the following signature:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Team`结构将包含其他结构，因此总共将创建四个结构。`Team`结构具有以下签名：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each team has an ID, a name, some image in an slice of bytes representing the
    team''s shield, a slice of players, and a slice of historical data. This way,
    we will have two teams'' ID:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队都有一个ID、一个名称、一些表示团队盾牌的字节切片中的图像、一个玩家切片和一个历史数据切片。这样，我们将有两个团队的ID：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We declare two constants by using the `const` and `iota` keywords. The `const` keyword
    simply declares that the following declarations are constants. `iota` is a untyped
    integer that automatically increments its value for each new constant between
    the parentheses. The `iota` value starts to reset to 0 when we declare `TEAM_A`,
    so `TEAM_A` is equal to 0\. On the `TEAM_B` variable, `iota` is incremented by
    one so `TEAM_B` is equal to 1\. The `iota` assignment is an elegant way to save
    typing when declaring constant values that doesn't need specific value (like the *Pi*
    constant on the `math` package).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`const`和`iota`关键字声明两个常量。`const`关键字简单地声明以下声明是常量。`iota`是一个无类型的整数，它在括号中的每个新常量之间自动增加其值。`iota`值在声明`TEAM_A`时重置为0，因此`TEAM_A`等于0。在`TEAM_B`变量上，`iota`增加1，因此`TEAM_B`等于1。`iota`赋值是声明不需要特定值（如`math`包中的*Pi*常量）的常量值时的节省打字的一种优雅方式。
- en: 'Our `Player` and `HistoricalData` are the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Player`和`HistoricalData`如下：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we also need a `Match` struct, which is stored within `HistoricalData` struct.
    A `Match` struct, in this context, represents the historical result of a match:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们还需要一个`Match`结构，它存储在`HistoricalData`结构中。在这个上下文中，`Match`结构代表比赛的历 史结果：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is enough to represent a team, and to fulfill *Acceptance Criteria 1*.
    You have probably guessed that there is a lot of information on each team, as
    some of the European teams have existed for more than 100 years.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以表示一个团队，并满足*验收标准 1*。你可能已经猜到，每个团队都有很多信息，因为一些欧洲团队已经存在超过100年了。
- en: 'For *Acceptance Criteria 2,* the word *creation* should give us some clue about
    how to approach this problem. We will build a factory to create and store our
    teams. Our Factory will consist of a map of years, including pointers to `Teams`
    as values, and a `GetTeam` function. Using a map will boost the team search if
    we know their names in advance. We will also dispose of a method to return the
    number of created objects, which will be called the `GetNumberOfObjects` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*验收标准 2*，单词*创建*应该给我们一些关于如何解决这个问题的一些线索。我们将构建一个工厂来创建和存储我们的团队。我们的工厂将包括一个年份映射，其中包含指向`Teams`的指针作为值，以及一个`GetTeam`函数。如果我们事先知道他们的名字，使用映射将提高团队搜索的效率。我们还将提供一个方法来返回创建的对象数量，这个方法将被称为`GetNumberOfObjects`方法：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is enough to write our first unit test:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以编写我们的第一个单元测试：
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our test, we verify all the acceptance criteria. First we create a factory,
    and then ask for a pointer of `TEAM_A`. This pointer cannot be `nil`, or the test
    will fail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们验证所有验收标准。首先我们创建一个工厂，然后请求`TEAM_A`的指针。这个指针不能是`nil`，否则测试将失败。
- en: Then we call for a second pointer to the same team. This pointer can't be nil
    either, and it should point to the same memory address as the previous one so
    we know that it has not allocated a new memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用指向同一团队的第二个指针。这个指针也不能为nil，它应该指向与上一个相同的内存地址，这样我们知道它没有分配新的内存。
- en: 'Finally, we should check whether the number of created teams is only one, because
    we have asked for the same team twice. We have two pointers but just one instance
    of the team. Let''s run the tests:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该检查创建的团队数量是否只有一个，因为我们请求了同一个团队两次。我们有两个指针，但只有一个团队实例。让我们运行测试：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Well, it failed. Both pointers were nil and it has not created any object. Interestingly,
    the function that compares the two pointers doesn't fail; all in all, nil equals
    nil.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它失败了。两个指针都是nil，并且它没有创建任何对象。有趣的是，比较两个指针的函数并没有失败；总的来说，nil等于nil。
