- en: Basic structs and tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `Team` struct will contain other structs inside, so a total of four structs
    will be created. The `Team` struct has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each team has an ID, a name, some image in an slice of bytes representing the
    team''s shield, a slice of players, and a slice of historical data. This way,
    we will have two teams'' ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We declare two constants by using the `const` and `iota` keywords. The `const` keyword
    simply declares that the following declarations are constants. `iota` is a untyped
    integer that automatically increments its value for each new constant between
    the parentheses. The `iota` value starts to reset to 0 when we declare `TEAM_A`,
    so `TEAM_A` is equal to 0\. On the `TEAM_B` variable, `iota` is incremented by
    one so `TEAM_B` is equal to 1\. The `iota` assignment is an elegant way to save
    typing when declaring constant values that doesn't need specific value (like the *Pi*
    constant on the `math` package).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Player` and `HistoricalData` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we also need a `Match` struct, which is stored within `HistoricalData` struct.
    A `Match` struct, in this context, represents the historical result of a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is enough to represent a team, and to fulfill *Acceptance Criteria 1*.
    You have probably guessed that there is a lot of information on each team, as
    some of the European teams have existed for more than 100 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Acceptance Criteria 2,* the word *creation* should give us some clue about
    how to approach this problem. We will build a factory to create and store our
    teams. Our Factory will consist of a map of years, including pointers to `Teams`
    as values, and a `GetTeam` function. Using a map will boost the team search if
    we know their names in advance. We will also dispose of a method to return the
    number of created objects, which will be called the `GetNumberOfObjects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to write our first unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our test, we verify all the acceptance criteria. First we create a factory,
    and then ask for a pointer of `TEAM_A`. This pointer cannot be `nil`, or the test
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Then we call for a second pointer to the same team. This pointer can't be nil
    either, and it should point to the same memory address as the previous one so
    we know that it has not allocated a new memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should check whether the number of created teams is only one, because
    we have asked for the same team twice. We have two pointers but just one instance
    of the team. Let''s run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Well, it failed. Both pointers were nil and it has not created any object. Interestingly,
    the function that compares the two pointers doesn't fail; all in all, nil equals
    nil.
  prefs: []
  type: TYPE_NORMAL
