<html><head></head><body>
<div class="book" title="Flyweight design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch04lvl2sec0117" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">Our <code class="email">GetTeam</code> method will need to scan the <code class="email">map</code> field called <code class="email">createdTeams</code> to make sure the queried team is already created, and return it if so. If the team wasn't created, it will have to create it and store it in the map before returning:</p><pre class="programlisting">func (t *teamFlyweightFactory) GetTeam(teamID int) *Team { 
  if t.createdTeams[teamID] != nil { 
    return t.createdTeams[teamID] 
  } 
 
  team := getTeamFactory(teamID) 
  t.createdTeams[teamID] = &amp;team 
 
  return t.createdTeams[teamID] 
} 
</pre><p class="calibre10">The preceding code is very simple. If the parameter name exists in the <code class="email">createdTeams</code> map, return the pointer. Otherwise, call a factory for team creation. This is interesting enough to stop for a second and analyze. When you use the Flyweight pattern, it is very common to have a Flyweight factory, which uses other types of creational patterns to retrieve the objects it needs.</p><p class="calibre10">So, the <code class="email">getTeamFactory</code> method will give us the team we are looking for, we will store it in the map, and return it. The team factory will be able to create the two teams: <code class="email">TEAM_A</code> and <code class="email">TEAM_B</code>:</p><pre class="programlisting">func getTeamFactory(team int) Team { 
  switch team { 
    case TEAM_B: 
    return Team{ 
      ID:   2, 
      Name: TEAM_B, 
    } 
    default: 
    return Team{ 
      ID:   1, 
      Name: TEAM_A, 
    } 
  } 
} 
</pre><p class="calibre10">We are simplifying the objects' content so that we can focus on the Flyweight pattern's implementation. Okay, so we just have to define the function to retrieve the number of objects created, which is done as follows:</p><pre class="programlisting">func (t *teamFlyweightFactory) GetNumberOfObjects() int { 
  return len(t.createdTeams) 
} 
</pre><p class="calibre10">This was pretty easy. The <code class="email">len</code> function returns the number of elements in an array or slice, the number of characters in a <code class="email">string</code>, and so on. It seems that everything is done, and we can launch our tests again:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=GetTeam . 
=== RUN   TestTeamFlyweightFactory_GetTeam 
--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s) 
panic: assignment to entry in nil map [recovered] 
        panic: assignment to entry in nil map 
 
goroutine 5 [running]: 
panic(0x530900, 0xc0820025c0) 
        /home/mcastro/Go/src/runtime/panic.go:481 +0x3f4 
testing.tRunner.func1(0xc082068120) 
        /home/mcastro/Go/src/testing/testing.go:467 +0x199 
panic(0x530900, 0xc0820025c0) 
        /home/mcastro/Go/src/runtime/panic.go:443 +0x4f7 
/home/mcastro/go-design-patterns/structural/flyweight.(*teamFlyweightFactory).GetTeam(0xc08202fec0, 0x0, 0x0) 
        /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight.go:71 +0x159 
/home/mcastro/go-design-patterns/structural/flyweight.TestTeamFlyweightFactory_GetTeam(0xc082068120) 
        /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight_test.go:9 +0x61 
testing.tRunner(0xc082068120, 0x666580) 
        /home/mcastro/Go/src/testing/testing.go:473 +0x9f 
created by testing.RunTests 
        /home/mcastro/Go/src/testing/testing.go:582 +0x899 
exit status 2 
FAIL</strong></span>
</pre><p class="calibre10">Panic! Have we forgotten something? By reading the stack trace on the panic message, we can see some addresses, some files, and it seems that the <code class="email">GetTeam</code> method is trying to assign an entry to a nil map on <span class="strong"><em class="calibre11">line 71</em></span> of the <code class="email">flyweight.go</code> file. Let's look at <span class="strong"><em class="calibre11">line 71</em></span> closely (remember, if you are writing code while following this tutorial, that the error will probably be in a different line so look closely at your own stark trace):</p><pre class="programlisting">t.createdTeams[teamName] = &amp;team 
</pre><p class="calibre10">Okay, this line is on the <code class="email">GetTeam</code> method, and, when the method passes through here, it means that it had not found the team on the map-it has created it (the variable team), and is trying to assign it to the map. But the map is nil, because we haven't initialized it when creating the factory. This has a quick solution. In our test, initialize the map where we have created the factory:</p><pre class="programlisting">factory := teamFlyweightFactory{ 
  createdTeams: make(map[int]*Team,0), 
} 
</pre><p class="calibre10">I'm sure you have seen the problem here already. If we don't have access to the package, we can initialize the variable. Well, we can make the variable public, and that's all. But this would involve every implementer necessarily knowing that they have to initialize the map, and its signature is neither convenient, or elegant. Instead, we are going to create a simple factory builder to do it for us. This is a very common approach in Go:</p><pre class="programlisting">func NewTeamFactory() teamFlyweightFactory { 
  return teamFlyweightFactory{ 
    createdTeams: make(map[int]*Team), 
  } 
} 
</pre><p class="calibre10">So now, in the test, we replace the factory creation with a call to this function:</p><pre class="programlisting">func TestTeamFlyweightFactory_GetTeam(t *testing.T) { 
  factory := NewTeamFactory() 
  ... 
} 
</pre><p class="calibre10">And we run the test again:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=GetTeam .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTeamFlyweightFactory_GetTeam</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestTeamFlyweightFactory_GetTeam (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok </strong></span>
</pre><p class="calibre10">Perfect! Let's improve the test by adding a second test, just to ensure that everything will be running as expected with more volume. We are going to create a million calls to the team creation, representing a million calls from users. Then, we will simply check that the number of teams created is only two:</p><pre class="programlisting">func Test_HighVolume(t *testing.T) { 
  factory := NewTeamFactory() 
 
  teams := make([]*Team, 500000*2) 
  for i := 0; i &lt; 500000; i++ { 
  teams[i] = factory.GetTeam(TEAM_A) 
} 
 
for i := 500000; i &lt; 2*500000; i++ { 
  teams[i] = factory.GetTeam(TEAM_B) 
} 
 
if factory.GetNumberOfObjects() != 2 { 
  t.Errorf("The number of objects created was not 2: %d\n",factory.GetNumberOfObjects()) 
  } 
} 
</pre><p class="calibre10">In this test, we retrieve <code class="email">TEAM_A</code> and <code class="email">TEAM_B</code> 500,000 times each to reach a million users. Then, we make sure that just two objects were created:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v -run=Volume . 
=== RUN   Test_HighVolume 
--- PASS: Test_HighVolume (0.04s) 
PASS 
ok</strong></span>
</pre><p class="calibre10">Perfect! We can even check where the pointers are pointing to, and where they are located. We will check with the first three as an example. Add these lines at the end of the last test, and run it again:</p><pre class="programlisting">for i:=0; i&lt;3; i++ { 
  fmt.Printf("Pointer %d points to %p and is located in %p\n", i, teams[i], &amp;teams[i]) 
} 
</pre><p class="calibre10">In the preceding test, we use the <code class="email">Printf</code> method to print information about pointers. The <code class="email">%p</code> flag gives you the memory location of the object that the pointer is pointing to. If you reference the pointer by passing the <code class="email">&amp;</code> symbol, it will give you the direction of the pointer itself.</p><p class="calibre10">Run the test again with the same command; you will see three new lines in the output with information similar to the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">Pointer 0 points to 0xc082846000 and is located in 0xc082076000</strong></span>
<span class="strong"><strong class="calibre2">Pointer 1 points to 0xc082846000 and is located in 0xc082076008</strong></span>
<span class="strong"><strong class="calibre2">Pointer 2 points to 0xc082846000 and is located in 0xc082076010</strong></span>
</pre><p class="calibre10">What it tells us is that the first three positions in the map point to the same location, but that we actually have three different pointers, which are, effectively, much lighter than our team object.</p></div></div></body></html>