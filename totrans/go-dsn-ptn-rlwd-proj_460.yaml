- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `GetTeam` method will need to scan the `map` field called `createdTeams`
    to make sure the queried team is already created, and return it if so. If the
    team wasn''t created, it will have to create it and store it in the map before
    returning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very simple. If the parameter name exists in the `createdTeams`
    map, return the pointer. Otherwise, call a factory for team creation. This is
    interesting enough to stop for a second and analyze. When you use the Flyweight
    pattern, it is very common to have a Flyweight factory, which uses other types
    of creational patterns to retrieve the objects it needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `getTeamFactory` method will give us the team we are looking for, we
    will store it in the map, and return it. The team factory will be able to create
    the two teams: `TEAM_A` and `TEAM_B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are simplifying the objects'' content so that we can focus on the Flyweight
    pattern''s implementation. Okay, so we just have to define the function to retrieve
    the number of objects created, which is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This was pretty easy. The `len` function returns the number of elements in
    an array or slice, the number of characters in a `string`, and so on. It seems
    that everything is done, and we can launch our tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Panic! Have we forgotten something? By reading the stack trace on the panic
    message, we can see some addresses, some files, and it seems that the `GetTeam`
    method is trying to assign an entry to a nil map on *line 71* of the `flyweight.go`
    file. Let''s look at *line 71* closely (remember, if you are writing code while
    following this tutorial, that the error will probably be in a different line so
    look closely at your own stark trace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this line is on the `GetTeam` method, and, when the method passes through
    here, it means that it had not found the team on the map-it has created it (the
    variable team), and is trying to assign it to the map. But the map is nil, because
    we haven''t initialized it when creating the factory. This has a quick solution.
    In our test, initialize the map where we have created the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m sure you have seen the problem here already. If we don''t have access
    to the package, we can initialize the variable. Well, we can make the variable
    public, and that''s all. But this would involve every implementer necessarily
    knowing that they have to initialize the map, and its signature is neither convenient,
    or elegant. Instead, we are going to create a simple factory builder to do it
    for us. This is a very common approach in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, in the test, we replace the factory creation with a call to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And we run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Let''s improve the test by adding a second test, just to ensure that
    everything will be running as expected with more volume. We are going to create
    a million calls to the team creation, representing a million calls from users.
    Then, we will simply check that the number of teams created is only two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we retrieve `TEAM_A` and `TEAM_B` 500,000 times each to reach
    a million users. Then, we make sure that just two objects were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! We can even check where the pointers are pointing to, and where they
    are located. We will check with the first three as an example. Add these lines
    at the end of the last test, and run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we use the `Printf` method to print information about
    pointers. The `%p` flag gives you the memory location of the object that the pointer
    is pointing to. If you reference the pointer by passing the `&` symbol, it will
    give you the direction of the pointer itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test again with the same command; you will see three new lines in the
    output with information similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What it tells us is that the first three positions in the map point to the same
    location, but that we actually have three different pointers, which are, effectively,
    much lighter than our team object.
  prefs: []
  type: TYPE_NORMAL
