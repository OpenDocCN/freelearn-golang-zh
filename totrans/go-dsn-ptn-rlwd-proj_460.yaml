- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Our `GetTeam` method will need to scan the `map` field called `createdTeams`
    to make sure the queried team is already created, and return it if so. If the
    team wasn''t created, it will have to create it and store it in the map before
    returning:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `GetTeam` 方法需要扫描名为 `createdTeams` 的 `map` 字段，以确保查询的团队已经创建，如果是的话就返回它。如果没有创建，它将不得不创建它并将它存储在
    `map` 中然后再返回：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is very simple. If the parameter name exists in the `createdTeams`
    map, return the pointer. Otherwise, call a factory for team creation. This is
    interesting enough to stop for a second and analyze. When you use the Flyweight
    pattern, it is very common to have a Flyweight factory, which uses other types
    of creational patterns to retrieve the objects it needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常简单。如果参数名称存在于 `createdTeams` `map` 中，则返回指针。否则，调用工厂进行团队创建。这足以让我们停下来分析一下。当你使用享元模式时，使用享元工厂是非常常见的，它使用其他类型的创建模式来检索它需要的对象。
- en: 'So, the `getTeamFactory` method will give us the team we are looking for, we
    will store it in the map, and return it. The team factory will be able to create
    the two teams: `TEAM_A` and `TEAM_B`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`getTeamFactory` 方法将给我们想要的团队，我们将它在 `map` 中存储，并返回。团队工厂将能够创建两个团队：`TEAM_A` 和
    `TEAM_B`：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are simplifying the objects'' content so that we can focus on the Flyweight
    pattern''s implementation. Okay, so we just have to define the function to retrieve
    the number of objects created, which is done as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简化了对象的内容，以便我们可以专注于享元模式的实现。好吧，我们只需要定义一个函数来检索创建的对象数量，如下所示：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This was pretty easy. The `len` function returns the number of elements in
    an array or slice, the number of characters in a `string`, and so on. It seems
    that everything is done, and we can launch our tests again:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。`len` 函数返回数组或切片中的元素数量，字符串中的字符数量等等。看起来一切都已经完成，我们可以再次启动我们的测试：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Panic! Have we forgotten something? By reading the stack trace on the panic
    message, we can see some addresses, some files, and it seems that the `GetTeam`
    method is trying to assign an entry to a nil map on *line 71* of the `flyweight.go`
    file. Let''s look at *line 71* closely (remember, if you are writing code while
    following this tutorial, that the error will probably be in a different line so
    look closely at your own stark trace):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 惊慌！我们忘记什么了吗？通过阅读恐慌消息的堆栈跟踪，我们可以看到一些地址、一些文件，并且看起来 `GetTeam` 方法正在尝试将一个条目分配给 `flyweight.go`
    文件的第 *71* 行上的 nil `map`。让我们仔细看看 *第71行*（记住，如果你在遵循这个教程的同时编写代码，错误可能出现在不同的行，所以仔细查看你的堆栈跟踪）：
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Okay, this line is on the `GetTeam` method, and, when the method passes through
    here, it means that it had not found the team on the map-it has created it (the
    variable team), and is trying to assign it to the map. But the map is nil, because
    we haven''t initialized it when creating the factory. This has a quick solution.
    In our test, initialize the map where we have created the factory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这一行在 `GetTeam` 方法中，当方法通过这里时，意味着它没有在 `map` 中找到团队——它已经创建了（变量 team），并试图将它分配给
    `map`。但是 `map` 是 nil 的，因为我们没有在创建工厂时初始化它。这有一个快速的解决方案。在我们的测试中，初始化我们创建工厂的 `map`：
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I''m sure you have seen the problem here already. If we don''t have access
    to the package, we can initialize the variable. Well, we can make the variable
    public, and that''s all. But this would involve every implementer necessarily
    knowing that they have to initialize the map, and its signature is neither convenient,
    or elegant. Instead, we are going to create a simple factory builder to do it
    for us. This is a very common approach in Go:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经在这里看到了问题。如果我们无法访问包，我们可以初始化变量。我们可以将变量设置为公共的，这样就结束了。但这将要求每个实现者都知道他们必须初始化
    `map`，并且它的签名既不方便也不优雅。相反，我们将创建一个简单的工厂构建器来为我们完成这项工作。这在 Go 中是一个非常常见的做法：
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So now, in the test, we replace the factory creation with a call to this function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在在测试中，我们用对这个函数的调用替换工厂创建：
- en: '[PRE7]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And we run the test again:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次运行测试：
- en: '[PRE8]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Perfect! Let''s improve the test by adding a second test, just to ensure that
    everything will be running as expected with more volume. We are going to create
    a million calls to the team creation, representing a million calls from users.
    Then, we will simply check that the number of teams created is only two:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！让我们通过添加第二个测试来改进测试，以确保在更大规模的情况下一切都会按预期运行。我们将创建一百万个团队创建的调用，代表一百万个来自用户的调用。然后，我们将简单地检查创建的团队数量只有两个：
- en: '[PRE9]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this test, we retrieve `TEAM_A` and `TEAM_B` 500,000 times each to reach
    a million users. Then, we make sure that just two objects were created:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们分别检索`TEAM_A`和`TEAM_B` 500,000次，以达到一百万用户。然后，我们确保只创建了两个对象：
- en: '[PRE10]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Perfect! We can even check where the pointers are pointing to, and where they
    are located. We will check with the first three as an example. Add these lines
    at the end of the last test, and run it again:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们甚至可以检查指针指向的位置以及它们所在的位置。我们将以前三个为例进行检查。将这些行添加到上一个测试的末尾，然后再次运行：
- en: '[PRE11]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding test, we use the `Printf` method to print information about
    pointers. The `%p` flag gives you the memory location of the object that the pointer
    is pointing to. If you reference the pointer by passing the `&` symbol, it will
    give you the direction of the pointer itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试中，我们使用`Printf`方法打印有关指针的信息。`%p`标志会给出指针所指向的对象的内存位置。如果你通过传递`&`符号来引用指针，它将给出指针本身的指向。
- en: 'Run the test again with the same command; you will see three new lines in the
    output with information similar to the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用相同的命令运行测试；你将在输出中看到三行新信息，内容类似于以下：
- en: '[PRE12]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What it tells us is that the first three positions in the map point to the same
    location, but that we actually have three different pointers, which are, effectively,
    much lighter than our team object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们的是，地图中的前三个位置指向相同的位置，但实际上我们有三个不同的指针，它们实际上比我们的团队对象要轻得多。
