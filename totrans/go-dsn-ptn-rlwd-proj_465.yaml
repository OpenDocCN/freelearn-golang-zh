- en: Description
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Strategy pattern uses different algorithms to achieve some specific functionality.
    These algorithms are hidden behind an interface and, of course, they must be interchangeable.
    All algorithms achieve the same functionality in a different way. For example,
    we could have a `Sort` interface and few sorting algorithms. The result is the
    same, some list is sorted, but we could have used quick sort, merge sort, and
    so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式使用不同的算法来实现一些特定的功能。这些算法隐藏在接口后面，当然，它们必须是可互换的。所有算法都以不同的方式实现相同的功能。例如，我们可以有一个
    `Sort` 接口和几种排序算法。结果是相同的，某个列表被排序了，但我们可能使用了快速排序、归并排序等等。
- en: Can you guess when we used a Strategy pattern in the previous chapters? Three,
    two, one... Well, we heavily used the strategy pattern when we used the `io.Writer`
    interface. The `io.Writer` interface defines a strategy to write, and the functionality
    is always the same--to write something. We could write it to the standard out,
    to some file or to a user-defined type, but we do the same thing at the end--to
    write. We just change the strategy to write (in this case, we change the place
    where we write).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到我们在前几章中何时使用了策略模式吗？三，二，一... 好吧，当我们使用 `io.Writer` 接口时，我们大量使用了策略模式。`io.Writer`
    接口定义了一种写入策略，其功能始终相同——写入某些内容。我们可以将其写入标准输出、某个文件或用户定义的类型，但最终我们做的都是同一件事——写入。我们只是改变了写入的策略（在这种情况下，我们改变了写入的位置）。
