- en: Rendering images or text
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染图像或文本
- en: We are going to do something different for this example. Instead of printing
    text on the console only, we are also going to paint objects on a file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将做一些不同的事情。我们不仅将在控制台上打印文本，还会在文件上绘制对象。
- en: 'In this case, we will have two strategies: console and file. But the user of
    the library won''t have to deal with the complexity behind them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有两个策略：控制台和文件。但库的用户不需要处理它们背后的复杂性。
- en: 'The key feature is that the "caller" doesn´t know how the underlying library
    is working and he just knows the information available on the defined strategy.
    This is nicely seen on the following diagram:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关键特性是“调用者”不知道底层库是如何工作的，他只知道定义的策略上可用的信息。这可以从以下图中清楚地看到：
- en: '![Rendering images or text](img/00031.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![渲染图像或文本](img/00031.jpeg)'
- en: In this diagram, we have chosen to print to console but we won´t deal with the
    **ConsoleStrategy** type directly, we´ll always use an interface that represents
    it. The **ConsoleStrategy** type will hide the implementation details of printing
    to console to caller in `main` function. **FileStrategy** hides its implementation details
    as well as any future strategy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们选择将输出打印到控制台，但我们不会直接处理**ConsoleStrategy**类型，我们将始终使用一个代表它的接口。**ConsoleStrategy**类型将隐藏在`main`函数中对调用者打印到控制台的实现细节。**FileStrategy**同样隐藏其实现细节以及任何未来的策略。
