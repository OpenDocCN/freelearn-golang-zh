<html><head></head><body>
<div class="book" title="Chapter&#xA0;5.&#xA0;Behavioral Patterns - Strategy, Chain of Responsibility, and Command Design Patterns">
<div class="book" title="Strategy design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec0123" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">We aren't going to write tests for this example as it will be quite complicated to check that an image has appeared on the screen (although not impossible by using <span class="strong"><strong class="calibre2">OpenCV</strong></span>, an impressive library for computer vision). We will start directly by defining our strategy interface that each printing strategy must implement (in our case, the file and console types):</p><pre class="programlisting">type PrintStrategy interface { 
  Print() error 
} 
</pre><p class="calibre10">That's all. Our strategy defines a simple <code class="email">Print()</code> method that returns an <code class="email">error</code> (the error-returning type is mandatory when dealing with files, for example). The types that needs to implement <code class="email">PrintStrategy</code> will be called <code class="email">ConsoleSquare</code> and a <code class="email">ImageSquare</code> type:</p><pre class="programlisting">type ConsoleSquare struct {} 
 
type ImageSquare struct { 
  DestinationFilePath string 
} 
</pre><p class="calibre10">The <code class="email">ConsoleSquare</code> struct doesn't need any inner field because it will always print the word <code class="email">Square</code> to the console. The <code class="email">ImageSquare</code> struct will store a field for the destination of the image file where we will print the square. We will start with the implementation of the <code class="email">ConsoleSquare</code> type as it is the simplest:</p><pre class="programlisting">func(c *ConsoleSquare) Print() error { 
  println("Square")  
  return nil 
} 
</pre><p class="calibre10">Very easy, but the image is more complex. We won't spend too much time in explaining in detail how the <code class="email">image</code> package works because the code is easily understandable:</p><pre class="programlisting">func (t *ImageSquare) Print() error { 
  width := 800 
  height := 600 
 
  origin := image.Point{0, 0} 
 
  bgImage := image.NewRGBA(image.Rectangle{ 
    Min: origin, 
    Max: image.Point{X: width, Y: height}, 
  }) 
 
  bgColor := image.Uniform{color.RGBA{R: 70, G: 70, B: 70, A:0}} 
  quality := &amp;jpeg.Options{Quality: 75} 
 
  draw.Print(bgImage, bgImage.Bounds(), &amp;bgColor, origin, draw.Src) 
</pre><p class="calibre10">However, here is a short explanation:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We define a size for the image (<code class="email">width</code> and <code class="email">height</code> variables) of 800 pixels of width and 600 pixels of height. Those are going to be the size limits of our image and anything that we write outside of that size won't be visible.</li><li class="listitem">The <code class="email">origin</code> variable stores an <code class="email">image.Point</code>, a type to represent a position in any two-dimensional space. We set the position of this point at <span class="strong"><em class="calibre11">(0, 0)</em></span>, the upper-left corner of the image.</li><li class="listitem">We need a bitmap that will represent our background, here we called it <code class="email">bgImage</code>. We have a very handy function in the image package to create the <code class="email">image.RGBA</code> types called <code class="email">image.NewRGBA</code>. We need to pass a rectangle to this function so that it knows the bounds of the image. A rectangle is represented by two <code class="email">image.Point</code> types--its upper left corner point (the <code class="email">Min</code> field) and its lower right corner point (the <code class="email">Max</code> field). We use <code class="email">origin</code> as the upper-left and a new point with the values of <code class="email">width</code> and <code class="email">height</code> as the lower-right point.</li><li class="listitem">The image will have a gray background color (<code class="email">bgColor</code>). This is done by instancing a type of <code class="email">image.Uniform</code>, which represents a uniform color (hence the name). The <code class="email">image.Uniform</code> type needs an instance of a <code class="email">color.Color</code> interface. A <code class="email">color.Color</code> type is any type that implements the <code class="email">RGBA() (r, g, b, a uint32) </code> method to return a <code class="email">uint32</code> value for red, green, blue, and alpha colors (RGBA). Alpha is a value for the transparency of a pixel. The <code class="email">color</code> package conveniently provides a type called <code class="email">color.RGBA</code> for this purpose (in case we don't need to implement our own, which is our case).</li><li class="listitem">When storing an image in certain formats, we have to specify the quality of the image. It will affect not only the quality but the size of the file, of course. Here, it is defined as 75; 100 is the maximum quality possible that we can set. As you can see, we are using the <code class="email">jpeg</code> package here to set the value of a type called <code class="email">Options</code> that simply stores the value of the quality, it doesn't have more values to apply.</li><li class="listitem">Finally, the <code class="email">draw.Print</code> function writes the pixels on the supplied image (<code class="email">bgImage</code>) with the characteristics that we have defined on the bounds defined by the same image. The first argument of the <code class="email">draw.Print</code> method takes the destination image, where we used <code class="email">bgImage</code>. The second argument is the bounds of the object to draw in the destination image, we used the same bounds of the image but we could use any other if we wanted a smaller rectangle. The third argument is the color to use to colorize the bounds. The <code class="email">Origin</code> variable is used to tell where the upper-left corner of the bound must be placed. In this case, the bounds are the same size as the image so we need to set it to the origin. The last argument specified is the operation type; just leave it in the <code class="email">draw.Src</code> argument.</li></ul></div><p class="calibre10">Now we have to draw the square. The operation is essentially the same as to draw the background but, in this case, we are drawing a square over the previously drawn <code class="email">bgImage</code>:</p><pre class="programlisting">  squareWidth := 200 
  squareHeight := 200 
  squareColor := image.Uniform{color.RGBA{R: 255, G: 0, B: 0, A: 1}} 
  square := image.Rect(0, 0, squareWidth, squareHeight) 
  square = square.Add(image.Point{ 
    X: (width / 2) - (squareWidth / 2), 
    Y: (height / 2) - (squareHeight / 2), 
  }) 
  squareImg := image.NewRGBA(square) 
 
  draw.Print(bgImage, squareImg.Bounds(), &amp;squareColor, origin, draw.Src) 
</pre><p class="calibre10">The square will be of 200*200 pixels of red color. When using the method <code class="email">Add</code>, the <code class="email">Rect</code> type origin is translated to the supplied point; this is to center the square on the image. We create an image with the square <code class="email">Rect</code> and call the <code class="email">Print</code> function on the <code class="email">bgImage</code> image again to draw the red square over it:</p><pre class="programlisting">  w, err := os.Create(t.DestinationFilePath) 
  if err != nil { 
    return fmt.Errorf("Error opening image") 
  } 
  defer w.Close() 
 
  if err = jpeg.Encode(w, bgImage, quality); err != nil { 
    return fmt.Errorf("Error writing image to disk") 
  } 
 
  return nil 
} 
</pre><p class="calibre10">Finally, we will create a file to store the contents of the image. The file will be stored in the path supplied in the <code class="email">DestinationFilePath</code> field of the <code class="email">ImageSquare</code> struct. To create a file, we use <code class="email">os.Create</code> that returns the <code class="email">*os.File</code>. As with every file, it must be closed after using it so don't forget to use the <code class="email">defer</code> keyword to ensure that you close it when the method finishes.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="tip014" class="calibre1"/>Tip</h3><p class="calibre10">To defer, or not to defer?</p><p class="calibre10">Some people ask why the use of <code class="email">defer</code> at all? Wouldn't it be the same to simply write it without <code class="email">defer</code> at the end of the function? Well, actually not. If any error occurs during the method execution and you return this error, the <code class="email">Close</code> method won't be executed if it's at the end of the function. You can close the file before returning but you'll have to do it in every error check. With <code class="email">defer,</code> you don't have to worry about this because the deferred function is executed always (with or without error). This way, we ensure that the file is closed.</p></div><p class="calibre10">To parse the arguments, we'll use the <code class="email">flag</code> package. We have used it before but let's recall its usage. A flag is a command that the user can pass when executing our app. We can define a flag by using the <code class="email">flag.[type]</code> methods defined in the <code class="email">flag</code> package. We want to read the output that the user wants to use from the console. This flag will be called <code class="email">output</code>. A flag can have a default value; in this case, it will have the value <code class="email">console</code> that will be used when printing to console. So, if the user executes the program without arguments, it prints to console:</p><pre class="programlisting">var output = flag.String("output", "console", "The output to use between 'console' and 'image' file") 
</pre><p class="calibre10">Our final step is to write the main function:</p><pre class="programlisting">func main(){ 
    flag.Parse() 
</pre><p class="calibre10">Remember that the first thing to do in the main when using flags is to parse them using the <code class="email">flag.Parse()</code> method! It's very common to forget this step:</p><pre class="programlisting">var activeStrategy PrintStrategy 
 
switch *output { 
case "console": 
  activeStrategy = &amp;TextSquare{} 
case "image": 
  activeStrategy = &amp;ImageSquare{"/tmp/image.jpg"} 
default: 
  activeStrategy = &amp;TextSquare{} 
} 
</pre><p class="calibre10">We define a variable for the strategy that the user has chosen, called <code class="email">activeStrategy</code>. But check that the <code class="email">activeStrategy</code> variable has the <code class="email">PrintStrategy</code> type so it can be populated with any implementation of the <code class="email">PrintStrategy</code> variable. We will set <code class="email">activeStrategy</code> to a new instance of <code class="email">TextSquare</code> when the user writes the <code class="email">
<span class="strong"><strong class="calibre2">--output=console</strong></span>
</code> command and an <code class="email">ImageSquare</code> when we write the <code class="email">
<span class="strong"><strong class="calibre2">--output=image</strong></span>
</code> command.</p><p class="calibre10">Finally, here is the design pattern execution:</p><pre class="programlisting">  err := activeStrategy.Print() 
  if err != nil { 
    log.Fatal(err) 
  } 
}
</pre><p class="calibre10">Our <code class="email">activeStrategy</code> variable is a type implementing <code class="email">PrintStrategy</code> and either the <code class="email">TextSquare</code> or <code class="email">ImageSquare</code> classes. The user will choose at runtime which strategy he wants to use for each particular case. Also, we could have written a factory method pattern to create strategies, so that the strategy creation will also be uncoupled from the main function and abstracted in a different independent package. Think about it: if we have the strategy creation in a different package, it will also allow us to use this project as a library and not only as a standalone app.</p><p class="calibre10">Now we will execute both strategies; the <code class="email">TextSquare</code> instance will give us a square by printing the word <code class="email">Square</code> on the console:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go --output=console</strong></span>
<span class="strong"><strong class="calibre2">Square</strong></span>
</pre><p class="calibre10">It has worked as expected. Recalling how flags work, we have to use the <code class="email">--</code> (double dash) and the defined flag, <code class="email">output</code> in our case. Then you have two options--using <code class="email">=</code> (equals) and immediately writing the value for the flag or writing <code class="email">&lt;space&gt;</code> and the value for the flag. In this case, we have defined the default value of output to the console so the following three executions are equivalent:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go --output=console</strong></span>
<span class="strong"><strong class="calibre2">Square</strong></span>
<span class="strong"><strong class="calibre2">$ go run main.go --output console</strong></span>
<span class="strong"><strong class="calibre2">Square</strong></span>
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Square</strong></span>
</pre><p class="calibre10">Now we have to try the file strategy. As defined before, the file strategy will print a red square to a file as an image with dark gray background:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go --output image</strong></span>
</pre><p class="calibre10">Nothing happened? But everything worked correctly. This is actually bad practice. Users must always have some sort of feedback when using your app or your library. Also, if they are using your code as a library, maybe they have a specific format for output so it won't be nice to directly print to the console. We will solve this issue later. Right now, open the folder <code class="email">/tmp</code> with your favourite file explorer and you will see a file called <code class="email">image.jpg</code> with our red square in a dark grey background.</p></div></div></div></body></html>