- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We aren''t going to write tests for this example as it will be quite complicated
    to check that an image has appeared on the screen (although not impossible by
    using **OpenCV**, an impressive library for computer vision). We will start directly
    by defining our strategy interface that each printing strategy must implement
    (in our case, the file and console types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all. Our strategy defines a simple `Print()` method that returns an
    `error` (the error-returning type is mandatory when dealing with files, for example).
    The types that needs to implement `PrintStrategy` will be called `ConsoleSquare`
    and a `ImageSquare` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConsoleSquare` struct doesn''t need any inner field because it will always
    print the word `Square` to the console. The `ImageSquare` struct will store a
    field for the destination of the image file where we will print the square. We
    will start with the implementation of the `ConsoleSquare` type as it is the simplest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Very easy, but the image is more complex. We won''t spend too much time in
    explaining in detail how the `image` package works because the code is easily
    understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, here is a short explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a size for the image (`width` and `height` variables) of 800 pixels
    of width and 600 pixels of height. Those are going to be the size limits of our
    image and anything that we write outside of that size won't be visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `origin` variable stores an `image.Point`, a type to represent a position
    in any two-dimensional space. We set the position of this point at *(0, 0)*, the
    upper-left corner of the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a bitmap that will represent our background, here we called it `bgImage`.
    We have a very handy function in the image package to create the `image.RGBA`
    types called `image.NewRGBA`. We need to pass a rectangle to this function so
    that it knows the bounds of the image. A rectangle is represented by two `image.Point`
    types--its upper left corner point (the `Min` field) and its lower right corner
    point (the `Max` field). We use `origin` as the upper-left and a new point with
    the values of `width` and `height` as the lower-right point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image will have a gray background color (`bgColor`). This is done by instancing
    a type of `image.Uniform`, which represents a uniform color (hence the name).
    The `image.Uniform` type needs an instance of a `color.Color` interface. A `color.Color`
    type is any type that implements the `RGBA() (r, g, b, a uint32)`  method to return
    a `uint32` value for red, green, blue, and alpha colors (RGBA). Alpha is a value
    for the transparency of a pixel. The `color` package conveniently provides a type
    called `color.RGBA` for this purpose (in case we don't need to implement our own,
    which is our case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When storing an image in certain formats, we have to specify the quality of
    the image. It will affect not only the quality but the size of the file, of course.
    Here, it is defined as 75; 100 is the maximum quality possible that we can set.
    As you can see, we are using the `jpeg` package here to set the value of a type
    called `Options` that simply stores the value of the quality, it doesn't have
    more values to apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `draw.Print` function writes the pixels on the supplied image (`bgImage`)
    with the characteristics that we have defined on the bounds defined by the same
    image. The first argument of the `draw.Print` method takes the destination image,
    where we used `bgImage`. The second argument is the bounds of the object to draw
    in the destination image, we used the same bounds of the image but we could use
    any other if we wanted a smaller rectangle. The third argument is the color to
    use to colorize the bounds. The `Origin` variable is used to tell where the upper-left
    corner of the bound must be placed. In this case, the bounds are the same size
    as the image so we need to set it to the origin. The last argument specified is
    the operation type; just leave it in the `draw.Src` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we have to draw the square. The operation is essentially the same as to
    draw the background but, in this case, we are drawing a square over the previously
    drawn `bgImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The square will be of 200*200 pixels of red color. When using the method `Add`,
    the `Rect` type origin is translated to the supplied point; this is to center
    the square on the image. We create an image with the square `Rect` and call the
    `Print` function on the `bgImage` image again to draw the red square over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will create a file to store the contents of the image. The file
    will be stored in the path supplied in the `DestinationFilePath` field of the
    `ImageSquare` struct. To create a file, we use `os.Create` that returns the `*os.File`.
    As with every file, it must be closed after using it so don't forget to use the
    `defer` keyword to ensure that you close it when the method finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To defer, or not to defer?
  prefs: []
  type: TYPE_NORMAL
- en: Some people ask why the use of `defer` at all? Wouldn't it be the same to simply
    write it without `defer` at the end of the function? Well, actually not. If any
    error occurs during the method execution and you return this error, the `Close`
    method won't be executed if it's at the end of the function. You can close the
    file before returning but you'll have to do it in every error check. With `defer,`
    you don't have to worry about this because the deferred function is executed always
    (with or without error). This way, we ensure that the file is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To parse the arguments, we''ll use the `flag` package. We have used it before
    but let''s recall its usage. A flag is a command that the user can pass when executing
    our app. We can define a flag by using the `flag.[type]` methods defined in the
    `flag` package. We want to read the output that the user wants to use from the
    console. This flag will be called `output`. A flag can have a default value; in
    this case, it will have the value `console` that will be used when printing to
    console. So, if the user executes the program without arguments, it prints to
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final step is to write the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the first thing to do in the main when using flags is to parse
    them using the `flag.Parse()` method! It''s very common to forget this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We define a variable for the strategy that the user has chosen, called `activeStrategy`.
    But check that the `activeStrategy` variable has the `PrintStrategy` type so it
    can be populated with any implementation of the `PrintStrategy` variable. We will
    set `activeStrategy` to a new instance of `TextSquare` when the user writes the 
    `**--output=console**`  command and an `ImageSquare` when we write the  `**--output=image**`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the design pattern execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `activeStrategy` variable is a type implementing `PrintStrategy` and either
    the `TextSquare` or `ImageSquare` classes. The user will choose at runtime which
    strategy he wants to use for each particular case. Also, we could have written
    a factory method pattern to create strategies, so that the strategy creation will
    also be uncoupled from the main function and abstracted in a different independent
    package. Think about it: if we have the strategy creation in a different package,
    it will also allow us to use this project as a library and not only as a standalone
    app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will execute both strategies; the `TextSquare` instance will give us
    a square by printing the word `Square` on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It has worked as expected. Recalling how flags work, we have to use the `--` (double
    dash) and the defined flag, `output` in our case. Then you have two options--using
    `=` (equals) and immediately writing the value for the flag or writing `<space>`
    and the value for the flag. In this case, we have defined the default value of
    output to the console so the following three executions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to try the file strategy. As defined before, the file strategy
    will print a red square to a file as an image with dark gray background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Nothing happened? But everything worked correctly. This is actually bad practice.
    Users must always have some sort of feedback when using your app or your library.
    Also, if they are using your code as a library, maybe they have a specific format
    for output so it won't be nice to directly print to the console. We will solve
    this issue later. Right now, open the folder `/tmp` with your favourite file explorer
    and you will see a file called `image.jpg` with our red square in a dark grey
    background.
  prefs: []
  type: TYPE_NORMAL
