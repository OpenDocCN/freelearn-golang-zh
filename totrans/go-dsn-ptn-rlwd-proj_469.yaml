- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We aren''t going to write tests for this example as it will be quite complicated
    to check that an image has appeared on the screen (although not impossible by
    using **OpenCV**, an impressive library for computer vision). We will start directly
    by defining our strategy interface that each printing strategy must implement
    (in our case, the file and console types):'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为这个示例编写测试，因为这将是检查图像是否出现在屏幕上相当复杂的事情（尽管使用 **OpenCV**，一个令人印象深刻的计算机视觉库，是可能的）。我们将直接开始定义我们的策略接口，每个打印策略都必须实现（在我们的情况下，是文件和控制台类型）：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s all. Our strategy defines a simple `Print()` method that returns an
    `error` (the error-returning type is mandatory when dealing with files, for example).
    The types that needs to implement `PrintStrategy` will be called `ConsoleSquare`
    and a `ImageSquare` type:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了。我们的策略定义了一个简单的 `Print()` 方法，该方法返回一个 `error`（在处理文件等情况下，返回错误类型是强制性的）。需要实现
    `PrintStrategy` 的类型将被命名为 `ConsoleSquare` 和 `ImageSquare` 类型：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ConsoleSquare` struct doesn''t need any inner field because it will always
    print the word `Square` to the console. The `ImageSquare` struct will store a
    field for the destination of the image file where we will print the square. We
    will start with the implementation of the `ConsoleSquare` type as it is the simplest:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleSquare` 结构体不需要任何内部字段，因为它将始终将单词 `Square` 打印到控制台。`ImageSquare` 结构体将存储一个用于图像文件目的地的字段，我们将在这里打印正方形。我们将从
    `ConsoleSquare` 类型的实现开始，因为它是最简单的：'
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Very easy, but the image is more complex. We won''t spend too much time in
    explaining in detail how the `image` package works because the code is easily
    understandable:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，但图像更复杂。我们不会花太多时间详细解释 `image` 包的工作原理，因为代码很容易理解：
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, here is a short explanation:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个简短的说明：
- en: We define a size for the image (`width` and `height` variables) of 800 pixels
    of width and 600 pixels of height. Those are going to be the size limits of our
    image and anything that we write outside of that size won't be visible.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为图像定义了一个大小（`width` 和 `height` 变量），宽度为 800 像素，高度为 600 像素。这些将成为我们图像的大小限制，任何超出这个范围的写入都不会可见。
- en: The `origin` variable stores an `image.Point`, a type to represent a position
    in any two-dimensional space. We set the position of this point at *(0, 0)*, the
    upper-left corner of the image.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`origin` 变量存储一个 `image.Point` 类型，这是一个表示任何二维空间位置的类型。我们将这个点的位置设置为 *(0, 0)*，即图像的左上角。'
- en: We need a bitmap that will represent our background, here we called it `bgImage`.
    We have a very handy function in the image package to create the `image.RGBA`
    types called `image.NewRGBA`. We need to pass a rectangle to this function so
    that it knows the bounds of the image. A rectangle is represented by two `image.Point`
    types--its upper left corner point (the `Min` field) and its lower right corner
    point (the `Max` field). We use `origin` as the upper-left and a new point with
    the values of `width` and `height` as the lower-right point.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个表示背景的位图，我们将其称为 `bgImage`。在 `image` 包中有一个非常方便的函数来创建 `image.RGBA` 类型，称为
    `image.NewRGBA`。我们需要传递一个矩形给这个函数，这样它就知道图像的边界。一个矩形由两个 `image.Point` 类型表示--其上左角点（`Min`
    字段）和其下右角点（`Max` 字段）。我们使用 `origin` 作为上左角，并使用具有 `width` 和 `height` 值的新点作为下右角。
- en: The image will have a gray background color (`bgColor`). This is done by instancing
    a type of `image.Uniform`, which represents a uniform color (hence the name).
    The `image.Uniform` type needs an instance of a `color.Color` interface. A `color.Color`
    type is any type that implements the `RGBA() (r, g, b, a uint32)`  method to return
    a `uint32` value for red, green, blue, and alpha colors (RGBA). Alpha is a value
    for the transparency of a pixel. The `color` package conveniently provides a type
    called `color.RGBA` for this purpose (in case we don't need to implement our own,
    which is our case).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像将具有灰色背景颜色 (`bgColor`)。这是通过实例化一个表示均匀颜色的 `image.Uniform` 类型来完成的（因此得名）。`image.Uniform`
    类型需要一个 `color.Color` 接口实例。`color.Color` 类型是任何实现了 `RGBA() (r, g, b, a uint32)`
    方法的类型，该方法返回红色、绿色、蓝色和透明度颜色的 `uint32` 值（RGBA）。Alpha 是像素透明度的值。`color` 包提供了一个名为 `color.RGBA`
    的类型，用于此目的（以防我们不需要实现自己的，即我们的情况）。
- en: When storing an image in certain formats, we have to specify the quality of
    the image. It will affect not only the quality but the size of the file, of course.
    Here, it is defined as 75; 100 is the maximum quality possible that we can set.
    As you can see, we are using the `jpeg` package here to set the value of a type
    called `Options` that simply stores the value of the quality, it doesn't have
    more values to apply.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当以某些格式存储图像时，我们必须指定图像的质量。它不仅会影响质量，当然也会影响文件大小。在这里，它被定义为75；100是我们能设置的最大质量。正如你所看到的，我们在这里使用`jpeg`包来设置一个名为`Options`的类型值，它只是存储质量值，没有更多的值要应用。
- en: Finally, the `draw.Print` function writes the pixels on the supplied image (`bgImage`)
    with the characteristics that we have defined on the bounds defined by the same
    image. The first argument of the `draw.Print` method takes the destination image,
    where we used `bgImage`. The second argument is the bounds of the object to draw
    in the destination image, we used the same bounds of the image but we could use
    any other if we wanted a smaller rectangle. The third argument is the color to
    use to colorize the bounds. The `Origin` variable is used to tell where the upper-left
    corner of the bound must be placed. In this case, the bounds are the same size
    as the image so we need to set it to the origin. The last argument specified is
    the operation type; just leave it in the `draw.Src` argument.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`draw.Print`函数将我们定义在相同图像定义的边界内的像素写入提供的图像（`bgImage`）。`draw.Print`方法的第一个参数是目标图像，我们使用了`bgImage`。第二个参数是要在目标图像中绘制的对象的边界，我们使用了图像的相同边界，但如果我们想要一个更小的矩形，我们也可以使用任何其他边界。第三个参数是要使用的颜色来着色边界。`Origin`变量用于告诉边界的左上角必须放置在哪里。在这种情况下，边界的大小与图像相同，因此我们需要将其设置为原点。最后一个指定的参数是操作类型；只需将其留在`draw.Src`参数中即可。
- en: 'Now we have to draw the square. The operation is essentially the same as to
    draw the background but, in this case, we are drawing a square over the previously
    drawn `bgImage`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须绘制一个正方形。这个操作本质上与绘制背景相同，但在这个情况下，我们是在之前绘制的`bgImage`上绘制一个正方形：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The square will be of 200*200 pixels of red color. When using the method `Add`,
    the `Rect` type origin is translated to the supplied point; this is to center
    the square on the image. We create an image with the square `Rect` and call the
    `Print` function on the `bgImage` image again to draw the red square over it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形的颜色将是红色，大小为200*200像素。当使用`Add`方法时，`Rect`类型的原点会被转换到提供的点上；这是为了在图像上居中正方形。我们创建了一个带有正方形`Rect`的图像，并在`bgImage`图像上再次调用`Print`函数来在其上绘制红色正方形：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we will create a file to store the contents of the image. The file
    will be stored in the path supplied in the `DestinationFilePath` field of the
    `ImageSquare` struct. To create a file, we use `os.Create` that returns the `*os.File`.
    As with every file, it must be closed after using it so don't forget to use the
    `defer` keyword to ensure that you close it when the method finishes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个文件来存储图像的内容。该文件将存储在`ImageSquare`结构体的`DestinationFilePath`字段提供的路径中。要创建文件，我们使用`os.Create`，它返回`*os.File`。与每个文件一样，使用后必须关闭，所以不要忘记使用`defer`关键字来确保在方法结束时关闭它。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To defer, or not to defer?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要延迟，还是不要延迟？
- en: Some people ask why the use of `defer` at all? Wouldn't it be the same to simply
    write it without `defer` at the end of the function? Well, actually not. If any
    error occurs during the method execution and you return this error, the `Close`
    method won't be executed if it's at the end of the function. You can close the
    file before returning but you'll have to do it in every error check. With `defer,`
    you don't have to worry about this because the deferred function is executed always
    (with or without error). This way, we ensure that the file is closed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人会问，为什么一定要使用`defer`？难道在函数末尾不使用`defer`直接写出来不是一样吗？实际上并非如此。如果在方法执行过程中发生错误并且你返回这个错误，如果`Close`方法在函数末尾，那么它将不会被执行。你可以在返回之前关闭文件，但你需要对每个错误检查都这样做。使用`defer`，你不必担心这个问题，因为延迟执行的功能总是会执行（无论是否有错误）。这样，我们就能确保文件被关闭。
- en: 'To parse the arguments, we''ll use the `flag` package. We have used it before
    but let''s recall its usage. A flag is a command that the user can pass when executing
    our app. We can define a flag by using the `flag.[type]` methods defined in the
    `flag` package. We want to read the output that the user wants to use from the
    console. This flag will be called `output`. A flag can have a default value; in
    this case, it will have the value `console` that will be used when printing to
    console. So, if the user executes the program without arguments, it prints to
    console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析参数，我们将使用 `flag` 包。我们之前已经使用过它，但让我们回顾一下它的用法。一个标志是用户在执行我们的应用程序时可以传递的命令。我们可以通过使用
    `flag` 包中定义的 `flag.[type]` 方法来定义一个标志。我们希望从控制台读取用户想要使用的输出。这个标志将被称为 `output`。一个标志可以有默认值；在这种情况下，它将具有
    `console` 的值，当打印到控制台时将使用它。所以，如果用户在没有参数的情况下执行程序，它将打印到控制台：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our final step is to write the main function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是编写主函数：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember that the first thing to do in the main when using flags is to parse
    them using the `flag.Parse()` method! It''s very common to forget this step:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用标志时，在主函数中首先要做的是使用 `flag.Parse()` 方法来解析它们！忘记这一步是很常见的：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We define a variable for the strategy that the user has chosen, called `activeStrategy`.
    But check that the `activeStrategy` variable has the `PrintStrategy` type so it
    can be populated with any implementation of the `PrintStrategy` variable. We will
    set `activeStrategy` to a new instance of `TextSquare` when the user writes the 
    `**--output=console**`  command and an `ImageSquare` when we write the  `**--output=image**`
    command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为用户选择的战略定义了一个变量，称为 `activeStrategy`。但请检查 `activeStrategy` 变量是否具有 `PrintStrategy`
    类型，以便它可以被任何 `PrintStrategy` 实现填充。当用户输入 `**--output=console**` 命令时，我们将 `activeStrategy`
    设置为 `TextSquare` 的新实例；当我们输入 `**--output=image**` 命令时，将设置为 `ImageSquare`。
- en: 'Finally, here is the design pattern execution:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是设计模式执行过程：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `activeStrategy` variable is a type implementing `PrintStrategy` and either
    the `TextSquare` or `ImageSquare` classes. The user will choose at runtime which
    strategy he wants to use for each particular case. Also, we could have written
    a factory method pattern to create strategies, so that the strategy creation will
    also be uncoupled from the main function and abstracted in a different independent
    package. Think about it: if we have the strategy creation in a different package,
    it will also allow us to use this project as a library and not only as a standalone
    app.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `activeStrategy` 变量是一个实现 `PrintStrategy` 类型的类型，以及 `TextSquare` 或 `ImageSquare`
    类。用户将在运行时选择他想要为每个特定情况使用的策略。此外，我们还可以编写一个工厂方法模式来创建策略，这样策略的创建也将与主函数解耦，并在不同的独立包中抽象化。想想看：如果我们把策略创建放在不同的包中，这也将允许我们把这个项目作为一个库来使用，而不仅仅是一个独立的程序。
- en: 'Now we will execute both strategies; the `TextSquare` instance will give us
    a square by printing the word `Square` on the console:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行这两种策略；`TextSquare` 实例将通过在控制台上打印 `Square` 单词来给我们一个正方形：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It has worked as expected. Recalling how flags work, we have to use the `--` (double
    dash) and the defined flag, `output` in our case. Then you have two options--using
    `=` (equals) and immediately writing the value for the flag or writing `<space>`
    and the value for the flag. In this case, we have defined the default value of
    output to the console so the following three executions are equivalent:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作。回顾标志的工作方式，我们必须使用 `--`（双横线）和定义的标志，在我们的例子中是 `output`。然后你有两个选择--使用 `=`（等于）并立即为标志写入值，或者写入
    `<space>` 和标志的值。在这种情况下，我们已将输出的默认值定义为控制台，所以以下三种执行方式是等效的：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have to try the file strategy. As defined before, the file strategy
    will print a red square to a file as an image with dark gray background:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须尝试文件策略。如之前定义的，文件策略将以深灰色背景将一个红色正方形打印到文件中，作为一个图像：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Nothing happened? But everything worked correctly. This is actually bad practice.
    Users must always have some sort of feedback when using your app or your library.
    Also, if they are using your code as a library, maybe they have a specific format
    for output so it won't be nice to directly print to the console. We will solve
    this issue later. Right now, open the folder `/tmp` with your favourite file explorer
    and you will see a file called `image.jpg` with our red square in a dark grey
    background.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发生什么吗？但是一切工作都正确无误。这实际上是不良的实践。当用户使用您的应用程序或库时，他们必须始终获得某种形式的反馈。此外，如果他们把您的代码作为库使用，可能他们有一个特定的输出格式，所以直接打印到控制台可能不是很好。我们将在稍后解决这个问题。现在，用您最喜欢的文件浏览器打开
    `/tmp` 文件夹，您会看到一个名为 `image.jpg` 的文件，其中包含我们红色的正方形，背景是深灰色。
