- en: Solving small issues in our library
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决我们库中的小问题
- en: 'We have a few issues in our code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码中存在一些问题：
- en: It cannot be used as a library. We have critical code written in the `main`
    package (strategy creation).
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能作为一个库使用。我们在`main`包（策略创建）中编写了关键代码。
- en: '**Solution**: Abstract to two different packages the strategy creation from
    the command-line application.'
  id: totrans-3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：将策略创建从命令行应用程序中抽象到两个不同的包。'
- en: None of the strategies are doing any logging to file or console. We must provide
    a way to read some logs that an external user can integrate in their logging strategies
    or formats.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何策略正在对文件或控制台进行任何日志记录。我们必须提供一个方式，让外部用户可以将其集成到他们的日志策略或格式中。
- en: '**Solution**: Inject an `io.Writer` interface as dependency to act as a logging
    sink.'
  id: totrans-5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：注入一个`io.Writer`接口作为依赖项，作为日志接收器。'
- en: Our `TextSquare` class is always writing to the console (an implementer of the `io.Writer`
    interface) and the `ImageSquare` is always writing to file (another implementer
    of the `io.Writer` interface). This is too coupled.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`TextSquare`类总是向控制台（`io.Writer`接口的实现者）写入，而`ImageSquare`总是向文件（另一个`io.Writer`接口的实现者）写入。这太耦合了。
- en: '**Solution**: Inject an `io.Writer` interface so that the `TextSquare` and
    `ImageSquare` can write to any of the `io.Writer` implementations that are available
    (file and console, but also bytes buffer, binary encoders, `JSON` handlers...
    dozens of packages).'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：注入一个`io.Writer`接口，这样`TextSquare`和`ImageSquare`就可以写入任何可用的`io.Writer`实现（文件、控制台，以及字节缓冲区、二进制编码器、`JSON`处理器……数十个包）。'
- en: 'So, to use it as a library and solve the first issue, we will follow a common
    approach in Go file structures for apps and libraries. First, we will place our
    main package and function outside of the root package; in this case, in a folder
    called `cli`. It is also common to call this folder `cmd` or even `app`. Then,
    we will place our `PrintStrategy` interface in the root package, which now will
    be called the `strategy` package. Finally, we will create a `shapes` package in
    a folder with the same name where we will put both text and image strategies.
    So, our file structure will be like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将其作为一个库使用并解决第一个问题，我们将遵循Go应用程序和库的常见文件结构方法。首先，我们将把我们的主包和函数放在根包之外；在这种情况下，在一个名为`cli`的文件夹中。通常也把这个文件夹称为`cmd`或甚至`app`。然后，我们将把我们的`PrintStrategy`接口放在根包中，现在将被称为`strategy`包。最后，我们将在一个具有相同名称的文件夹中创建一个`shapes`包，我们将把文本和图像策略都放在里面。所以，我们的文件结构将是这样的：
- en: '**Root package**: strategy'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根包**：strategy'
- en: 'File: `print_strategy.go`'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件：`print_strategy.go`
- en: '**SubPackage**: shapes'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子包**：shapes'
- en: 'Files: `image.go`, `text.go`, `factory.go`'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件：`image.go`，`text.go`，`factory.go`
- en: '**SubPackage**: cli'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子包**：cli'
- en: 'File: `main.go`'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件：`main.go`
- en: 'We are going to modify our interface a bit to fit the needs we have written
    previously:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍微修改一下我们的接口，以适应我们之前写下的需求：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have added the `SetLog(io.Writer)` method to add a logger strategy to our
    types; this is to provide feedback to users. Also, it has a `SetWriter` method
    to set the `io.Writer` strategy. This interface is going to be located on the
    root package in the `print_strategy.go` file. So the final schema looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的类型添加了`SetLog(io.Writer)`方法来添加日志策略；这是为了向用户提供反馈。它还有一个`SetWriter`方法来设置`io.Writer`策略。这个接口将位于根包的`print_strategy.go`文件中。所以最终的架构看起来像这样：
- en: '![Solving small issues in our library](img/00032.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![解决我们库中的小问题](img/00032.jpeg)'
- en: 'Both the `TextSquare` and `ImageSquare` strategies have to satisfy the `SetLog`
    and `SetWriter` methods which simply store some object on their fields so, instead
    of implementing the same twice, we can create a struct that implements them and
    embed this struct in the strategies. By the way, this would be the composite pattern
    we have seen previously:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextSquare`和`ImageSquare`策略都必须满足`SetLog`和`SetWriter`方法，这些方法只是将一些对象存储在其字段上，因此，我们不需要两次实现相同的接口，我们可以创建一个实现这些方法的struct，并将这个struct嵌入到策略中。顺便说一句，这将是之前我们看到的组合模式：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So now each strategy must have the `PrintOutput` struct embedded if we want
    to modify their `Writer` and `logger` fields.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在每个策略都必须嵌入`PrintOutput`struct，如果我们想修改它们的`Writer`和`logger`字段。
- en: 'We also need to modify our strategy implementation. The `TextSquare` struct now
    needs a field to store the output `io.Writer` (the place where it is going to
    write instead of writing always to the console) and the `log` writer. These two
    fields can be provided by embedding the `PrintOutput` struct. The `TextSquare` struct
    is also stored in the file `text.go` within the shapes package. So, the struct
    is now like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的策略实现。现在 `TextSquare` 结构体需要一个字段来存储输出 `io.Writer`（它将要写入的地方，而不是总是写入控制台）和
    `log` 写入器。这两个字段可以通过嵌入 `PrintOutput` 结构体来提供。`TextSquare` 结构体也存储在 `shapes` 包内的 `text.go`
    文件中。因此，结构体现在如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So now the `Print()` method is slightly different because, instead of writing
    directly to the console by using the `println` function, we have to write whichever
    `io.Writer` is stored in the `Writer` field:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在 `Print()` 方法略有不同，因为，我们不是通过使用 `println` 函数直接写入控制台，而是必须写入存储在 `Writer` 字段中的任意
    `io.Writer`：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `bytes.NewReader` is a very useful function that takes an array of bytes
    and converts them to an `io.Reader` interface. We need an `io.Reader` interface
    to use the `io.Copy` function. The `io.Copy` function is also incredibly useful
    as it takes an `io.Reader` (as the second parameter) and pipes it to an `io.Writer`
    (its first parameter). So, we won''t return an error in any case. However, it''s
    easier to do so using directly the `Write` method of `t.Writer`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes.NewReader` 是一个非常有用的函数，它将字节数组转换为 `io.Reader` 接口。我们需要 `io.Reader` 接口来使用
    `io.Copy` 函数。`io.Copy` 函数也非常有用，因为它接受一个 `io.Reader`（作为第二个参数）并将其管道连接到 `io.Writer`（它的第一个参数）。所以，在任何情况下我们都不会返回错误。然而，使用
    `t.Writer` 的 `Write` 方法来做会更简单：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can use whichever method you like more. Usually, you will use the `Write`
    method but it's nice to know the `bytes.NewReader` function too.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你喜欢的任何方法。通常，你会使用 `Write` 方法，但了解 `bytes.NewReader` 函数也很好。
- en: Did you realize that when we use `t.Writer`, we are actually accessing `PrintOutput.Writer`?
    The `TextSquare` type has a `Writer` field because the `PrintOutput` struct has
    it and it's embedded on the `TextSquare` struct.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到当我们使用 `t.Writer` 时，实际上是在访问 `PrintOutput.Writer` 吗？`TextSquare` 类型有一个 `Writer`
    字段，因为 `PrintOutput` 结构体有它，并且它被嵌入到 `TextSquare` 结构体中。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Embedding is not inheritance. We have embedded the `PrintOutput` struct on
    the `TextSquare` struct. Now we can access `PrintOutput` fields as if they were
    in `TextSquare` fields. This feels a bit like inheritance but there is a very
    important difference here: `TextSquare` is not a `PrintOutput` value but it has
    a `PrintOutput` in its composition. What does it mean? That if you have a function
    that expects a `PrintOutput`, you cannot a pass `TextSquare` just because it has
    a `PrintOutput` embedded.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入不是继承。我们在 `TextSquare` 结构体上嵌入了一个 `PrintOutput` 结构体。现在我们可以像访问 `TextSquare` 字段一样访问
    `PrintOutput` 字段。这感觉有点像继承，但这里有一个非常重要的区别：`TextSquare` 不是一个 `PrintOutput` 值，但它在其组合中有一个
    `PrintOutput`。这意味着什么？如果你有一个期望 `PrintOutput` 的函数，你不能仅仅因为 `TextSquare` 嵌入了 `PrintOutput`
    就传递 `TextSquare`。
- en: But, if you have a function that accepts an interface that `PrintOutput` implements,
    you can pass `TextSquare` if it has a `PrintOutput` embedded. This is what we
    are doing in our example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你有一个接受 `PrintOutput` 实现的接口的函数，你可以传递 `TextSquare` 如果它嵌入了一个 `PrintOutput`。这正是我们在我们的例子中所做的。
- en: 'The `ImageSquare` struct is now like the `TextSquare`, with a `PrintOutput`
    embedded:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageSquare` 结构体现在类似于 `TextSquare`，它嵌入了一个 `PrintOutput`：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Print` method also needs to be modified. Now, we aren''t creating a file
    from the `Print` method, as it was breaking the single responsibility principle.
    A file implements an `io.Writer` so we will open the file outside of the `ImageSquare`
    struct and inject it on the `Writer` field. So, we just need to modify the end
    of the `Print()` method where we wrote to the file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print` 方法也需要进行修改。现在，我们不再从 `Print` 方法创建文件，因为这破坏了单一职责原则。文件实现了一个 `io.Writer`，所以我们将文件在外部打开，并将其注入到
    `Writer` 字段。因此，我们只需要修改 `Print()` 方法的末尾，我们在这里写入文件：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you check our previous implementation, after using `draw`, you can see that
    we used the `Print` method, we created a file with `os.Create` and passed it to
    the `jpeg.Encode` function. We have deleted this part about creating the file
    and we have replaced it with a check looking for a `Writer` in the fields (`if
    i.Writer != nil`). Then, on `jpeg.Encode` we can replace the file value we were
    using previously with the content of the `i.Writer` field. Finally, we are using
    `io.Copy` again to log some message to the `LogWriter` if a logging strategy is
    provided.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查我们的先前实现，在使用 `draw` 之后，你可以看到我们使用了 `Print` 方法，我们用 `os.Create` 创建了一个文件，并将其传递给
    `jpeg.Encode` 函数。我们已经删除了关于创建文件的这部分，并用一个检查替换它，检查字段中的 `Writer` (`if i.Writer !=
    nil`)。然后，在 `jpeg.Encode` 中，我们可以用之前使用的文件值替换 `i.Writer` 字段的内容。最后，如果提供了日志策略，我们再次使用
    `io.Copy` 将一些消息记录到 `LogWriter`。
- en: 'We also have to abstract the knowledge needed from the user to create instances
    of implementors of the `PrintStrategy` for which we are going to use a Factory
    method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须抽象出用户创建 `PrintStrategy` 实现实例所需的知识，我们将使用一个工厂方法：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have two constants, one of each of our strategies: `TEXT_STRATEGY` and `IMAGE_STRATEGY`.
    Those are the constants that must be provided to the factory to retrieve each
    square drawer strategy. Our factory method receives an argument `s`, which is
    a string with one of the previous constants.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个常量，每个策略一个：`TEXT_STRATEGY` 和 `IMAGE_STRATEGY`。这些是必须提供给工厂以检索每个方块绘制策略的常量。我们的工厂方法接收一个参数
    `s`，它是一个包含之前常量之一的字符串。
- en: Each strategy has a `PrintOutput` type embedded with a default logger to `stdout`
    but you can override it later by using the `SetLog(io.Writer)` methods. This approach
    could be considered a Factory of prototypes. If it is not a recognized strategy,
    a proper message error will be returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个策略都嵌入了一个 `PrintOutput` 类型，默认将日志输出到 `stdout`，但你可以稍后通过使用 `SetLog(io.Writer)`
    方法来覆盖它。这种方法可以被认为是一个原型的工厂。如果不是一个已识别的策略，将返回一个适当的错误消息。
- en: 'What we have now is a library. We have all the functionality we need between
    the `strategy` and `shapes` packages. Now we will write the `main` package and
    function in a new folder called `cli`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个库。我们在 `strategy` 和 `shapes` 包之间有我们需要的所有功能。现在我们将编写 `main` 包和函数在一个名为 `cli`
    的新文件夹中：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Again, like before, the `main` function starts by parsing the input arguments
    on the console to gather the chosen strategy. We can use the variable output now
    to create a strategy without Factory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，像之前一样，`main` 函数首先解析控制台上的输入参数以收集选择的策略。现在我们可以使用变量 `output` 来创建一个没有工厂的策略：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we will implement the business needs by using our library. For the purpose
    of the `TextStrategy`, we want to write, for example, to `stdout`. For the purpose
    of the image, we will write to `/tmp/image.jpg`. Just like before. So, following
    the previous statements, we can write:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过使用我们的库来实现业务需求。对于 `TextStrategy` 的目的，我们想要写入 `stdout`。对于图像的目的，我们将写入 `/tmp/image.jpg`。就像之前一样。所以，根据之前的陈述，我们可以写入：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the case of `TEXT_STRATEGY`, we use `SetWriter` to set the `io.Writer` to
    `os.Stdout`. In the case of `IMAGE_STRATEGY`, we create an image in any of our
    folders and pass the file variable to the `SetWriter` method. Remember that `os.File`
    implements the `io.Reader` and `io.Writer` interfaces, so it''s perfectly legal
    to pass it as an `io.Writer` to the `SetWriter` method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TEXT_STRATEGY` 的情况下，我们使用 `SetWriter` 将 `io.Writer` 设置为 `os.Stdout`。在 `IMAGE_STRATEGY`
    的情况下，我们在任何我们的文件夹中创建一个图像，并将文件变量传递给 `SetWriter` 方法。记住，`os.File` 实现了 `io.Reader`
    和 `io.Writer` 接口，所以将其作为 `io.Writer` 传递给 `SetWriter` 方法是完全合法的：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we call the `Print` method of whichever strategy was chosen by the
    user and check for possible errors. Let''s try the program now:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用用户选择的策略的 `Print` 方法，并检查可能的错误。现在让我们尝试运行程序：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It has worked as expected. What about the image strategy?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作。图像策略怎么样？
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we check in `/tmp/image.jpg`, we can find our red square on the dark background.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `/tmp/image.jpg` 中检查，我们可以在暗背景上找到我们的红色方块。
