- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The very first thing to do for the chain is, as usual, to define the interface.
    A chain of responsibility interface will usually have, at least, a  `Next()` method.
    The `Next()` method is the one that executes the next link in the chain, of course:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链的第一个要做的，就像往常一样，是定义接口。责任链接口通常至少有一个 `Next()` 方法。`Next()` 方法当然是执行链中的下一个链接：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Next` method on our example''s interface takes the message we want to
    log and passes it to the following link in the chain. As written in the acceptance
    criteria, we need three loggers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例接口上的 `Next` 方法接收我们想要记录的消息，并将其传递给链中的下一个链接。正如接受标准所写，我们需要三个记录器：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `FirstLogger` and `SecondLogger` types have exactly the same structure--both
    implement `ChainLogger` and have a `NextChain` field that points to the next `ChainLogger`.
    The `WriterLogger` type is equal to the `FirstLogger` and `SecondLogger` types
    but also has a field to write its data to, so you can pass any `io.Writer` interface
    to it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstLogger` 和 `SecondLogger` 类型结构完全相同--它们都实现了 `ChainLogger` 并有一个指向下一个 `ChainLogger`
    的 `NextChain` 字段。`WriterLogger` 类型与 `FirstLogger` 和 `SecondLogger` 类型相同，但它还有一个字段用于写入数据，因此你可以向它传递任何
    `io.Writer` 接口。'
- en: 'As we have done before, we''ll implement an `io.Writer` struct to use in our
    testing. In our test file, we define the following struct:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们将实现一个 `io.Writer` 结构体用于我们的测试。在我们的测试文件中，我们定义以下结构体：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will pass an instance of the `myTestWriter` struct to `WriterLogger` so we
    can track what's being logged on testing. The `myTestWriter` class implements
    the common `Write([]byte) (int, error)` method from the `io.Writer` interface.
    Remember, if it has the `Write` method, it can be used as `io.Writer`. The `Write`
    method simply stored the string argument to the `receivedMessage` field so we
    can check later its value on tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递 `myTestWriter` 结构体的一个实例给 `WriterLogger`，这样我们就可以在测试中跟踪记录的内容。`myTestWriter`
    类实现了 `io.Writer` 接口的通用 `Write([]byte) (int, error)` 方法。记住，如果它有 `Write` 方法，它就可以用作
    `io.Writer`。`Write` 方法只是将字符串参数存储到 `receivedMessage` 字段中，这样我们就可以在测试中检查其值。
- en: 'This is the beginning of the first test function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个测试函数的开始：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's describe these few lines a bit as they are quite important. We create
    a variable with a default `myTestWriter` type that we'll use as an `io.Writer` interface
    in the last link of our chain. Then we create the last piece of the link chain,
    the `writerLogger` interface. When implementing the chain, you usually start with
    the last piece on the link and, in our case, it is a `WriterLogger`. The `WriterLogger`
    writes to an `io.Writer` so we pass `myWriter` as `io.Writer` interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细描述这几行，因为它们相当重要。我们创建了一个具有默认 `myTestWriter` 类型的变量，我们将将其用作链的最后一个链接的 `io.Writer`
    接口。然后我们创建了链的最后一部分，即 `writerLogger` 接口。在实现链时，你通常从链的最后一部分开始，在我们的例子中，它是一个 `WriterLogger`。`WriterLogger`
    将数据写入 `io.Writer`，因此我们传递 `myWriter` 作为 `io.Writer` 接口。
- en: Then we have created a `SecondLogger`, the middle link in our chain, with a
    pointer to the `writerLogger`. As we mentioned before, `SecondLogger` just logs
    and passes the message in case it contains the word `hello`. In a production app,
    it could be an error-only logger.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个名为 `SecondLogger` 的中间链接，它指向 `writerLogger`。正如我们之前提到的，`SecondLogger`
    只在消息包含单词 `hello` 时记录并传递消息。在生产应用中，它可能是一个仅记录错误的记录器。
- en: 'Finally, the first link in the chain has the variable name chain. It points
    to the second logger. So, to resume, our chain looks like this: `FirstLogger`
    | `SecondLogger` | `WriterLogger`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，链的第一个链接的变量名为 `chain`。它指向第二个记录器。所以，总结一下，我们的链看起来是这样的：`FirstLogger` | `SecondLogger`
    | `WriterLogger`。
- en: 'This is going to be our default setup for our tests:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的测试默认设置：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Continuing with Go 1.7 or later testing signatures, we define an inner test
    with the following description: *three loggers, two of them write to console,
    the second only if it finds the word ''hello'', the third writes to some variable
    if the second found ''hello''*. It''s quite descriptive and very easy to understand
    if someone else has to maintain this code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 Go 1.7 或更高版本的测试签名，我们定义一个内部测试，其描述如下：*三个记录器，其中两个写入控制台，第二个仅在找到单词 'hello' 时写入，第三个如果第二个找到
    'hello' 则写入某个变量*。这相当详细，如果其他人需要维护此代码，则很容易理解。
- en: First, we use a message on the `Next` method that will not reach the third link
    in the chain as it doesn't contain the word `hello`. We check the contents of
    the `receivedMessage` variable, that by default is empty, to see if it has changed
    because it shouldn't.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`Next`方法上使用了一条消息，这条消息不会达到链中的第三个链接，因为它不包含单词`hello`。我们检查`receivedMessage`变量的内容，该变量默认为空，以查看它是否已更改，因为它不应该改变。
- en: Next, we use the chain variable again, our first link in the chain, and pass
    the message `"Hello\n"`. According to the description of the test, it should log
    using `FirstLogger`, then in `SecondLogger` and finally in `WriterLogger` because
    it contains the word `hello` and the `SecondLogger` will let it pass.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用链变量，即链中的第一个链接，并传递消息`"Hello\n"`。根据测试的描述，它应该使用`FirstLogger`进行记录，然后是`SecondLogger`，最后是`WriterLogger`，因为它包含单词`hello`，而`SecondLogger`将允许它通过。
- en: 'The test checks that `myWriter`, the last link in the chain that stored the
    past message in a variable called `receivedMessage`, has the word that we passed
    first in the chain: hello. Let''s run it so it fails:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检查`myWriter`，即链中的最后一个链接，它将过去的信息存储在一个名为`receivedMessage`的变量中，它包含我们在链中传递的第一个单词：hello。让我们运行它，让它失败：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The test passed for the first check of the test and didn''t for the second
    check. Well... ideally no check should pass before any implementation is done.
    Remember that in test-driven development, tests must fail on the first launch
    because the code they are testing isn''t implemented yet. Go zero-initialization
    misleads us with this passed check on the test. We can solve this in two ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了第一次检查，但没有通过第二次检查。嗯……理想情况下，在完成任何实现之前，不应该有任何检查通过。记住，在测试驱动开发中，测试必须在第一次启动时失败，因为它们测试的代码尚未实现。零初始化错误使我们在这个测试通过的检查上误导。我们可以用两种方式解决这个问题：
- en: 'Making the signature of the `ChainLogger` to return an error: `Next(string)`
    error. This way, we would break the chain returning an error. This is a much more
    convenient way in general, but it will introduce quite a lot of boilerplate right
    now.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ChainLogger`的签名改为返回一个错误：`Next(string)`错误。这样，我们就会在返回错误时断开链。这在一般情况下要方便得多，但会引入相当多的模板代码。
- en: Changing the `receivedMessage` field to a pointer. A default value of a pointer
    is nil, instead of an empty string.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`receivedMessage`字段改为指针。指针的默认值是nil，而不是空字符串。
- en: 'We will use the second option now, as it''s much simpler and quite effective
    too. So let''s change the signature of the `myTestWriter` struct to the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用第二种选项，因为它更简单，也很有效。所以让我们将`myTestWriter`结构的签名改为以下内容：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Check that the type of `receivedMessage` has the asterisk (`*`) now to indicate
    that it's a pointer to a string. The `Write` function needed to change too. Now
    we have to check the contents of the `receivedMessage` field because, as every
    pointer, it's initialized to nil. Then we have to store the message in a variable
    first, so we can take the address in the next line on the assignment `(m.receivedMessage
    = &tempMessage)`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`receivedMessage`的类型现在带有星号（`*`），以表示它是一个指向字符串的指针。`Write`函数也需要改变。现在我们必须检查`receivedMessage`字段的内容，因为，像每个指针一样，它被初始化为nil。然后我们必须先将消息存储在一个变量中，这样我们才能在下一行赋值时获取地址`(m.receivedMessage
    = &tempMessage)`。
- en: 'So now our test code should change a bit too:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的测试代码也需要做一点改变：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we are checking that `myWriter.receivedMessage` is actually `nil`, so no
    content has been written for sure on the variable. Also, we have to change the
    second if to check first that the member isn''t nil before checking its contents
    or it can throw a panic on test. Let''s test it again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在检查`myWriter.receivedMessage`实际上是`nil`，因此可以肯定没有内容被写入该变量。此外，我们必须将第二个if改为首先检查成员是否为nil，然后再检查其内容，否则它可能会在测试中抛出panic。让我们再次测试：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It fails again and, again, the first half of the test passes correctly without
    implemented code. So what should we do now? We have change the signature of the `myWriter`
    type to make the test fail in both checks and, again, just fail in the second.
    Well, in this case we can pass this small issue. When writing tests, we must be
    very careful to not get too crazy about them; unit tests are tools to help us
    write and maintain code, but our target is to write functionality, not tests.
    This is important to keep in mind as you can get really crazy engineering unit
    tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次失败了，测试的前半部分正确通过而没有实现代码。那么我们现在该怎么办呢？我们需要更改`myWriter`类型的签名，使得测试在两个检查中都失败，再次，只在第二个检查中失败。嗯，在这种情况下，我们可以忽略这个小问题。在编写测试时，我们必须非常小心，不要对它们过于狂热；单元测试是我们编写和维护代码的工具，但我们的目标是编写功能，而不是测试。这一点很重要，因为你可以真的编写出非常疯狂的工程单元测试。
