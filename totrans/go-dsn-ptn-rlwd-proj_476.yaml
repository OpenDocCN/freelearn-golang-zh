- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The very first thing to do for the chain is, as usual, to define the interface.
    A chain of responsibility interface will usually have, at least, a  `Next()` method.
    The `Next()` method is the one that executes the next link in the chain, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Next` method on our example''s interface takes the message we want to
    log and passes it to the following link in the chain. As written in the acceptance
    criteria, we need three loggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `FirstLogger` and `SecondLogger` types have exactly the same structure--both
    implement `ChainLogger` and have a `NextChain` field that points to the next `ChainLogger`.
    The `WriterLogger` type is equal to the `FirstLogger` and `SecondLogger` types
    but also has a field to write its data to, so you can pass any `io.Writer` interface
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have done before, we''ll implement an `io.Writer` struct to use in our
    testing. In our test file, we define the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will pass an instance of the `myTestWriter` struct to `WriterLogger` so we
    can track what's being logged on testing. The `myTestWriter` class implements
    the common `Write([]byte) (int, error)` method from the `io.Writer` interface.
    Remember, if it has the `Write` method, it can be used as `io.Writer`. The `Write`
    method simply stored the string argument to the `receivedMessage` field so we
    can check later its value on tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the beginning of the first test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's describe these few lines a bit as they are quite important. We create
    a variable with a default `myTestWriter` type that we'll use as an `io.Writer` interface
    in the last link of our chain. Then we create the last piece of the link chain,
    the `writerLogger` interface. When implementing the chain, you usually start with
    the last piece on the link and, in our case, it is a `WriterLogger`. The `WriterLogger`
    writes to an `io.Writer` so we pass `myWriter` as `io.Writer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have created a `SecondLogger`, the middle link in our chain, with a
    pointer to the `writerLogger`. As we mentioned before, `SecondLogger` just logs
    and passes the message in case it contains the word `hello`. In a production app,
    it could be an error-only logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the first link in the chain has the variable name chain. It points
    to the second logger. So, to resume, our chain looks like this: `FirstLogger`
    | `SecondLogger` | `WriterLogger`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is going to be our default setup for our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing with Go 1.7 or later testing signatures, we define an inner test
    with the following description: *three loggers, two of them write to console,
    the second only if it finds the word ''hello'', the third writes to some variable
    if the second found ''hello''*. It''s quite descriptive and very easy to understand
    if someone else has to maintain this code.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use a message on the `Next` method that will not reach the third link
    in the chain as it doesn't contain the word `hello`. We check the contents of
    the `receivedMessage` variable, that by default is empty, to see if it has changed
    because it shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the chain variable again, our first link in the chain, and pass
    the message `"Hello\n"`. According to the description of the test, it should log
    using `FirstLogger`, then in `SecondLogger` and finally in `WriterLogger` because
    it contains the word `hello` and the `SecondLogger` will let it pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test checks that `myWriter`, the last link in the chain that stored the
    past message in a variable called `receivedMessage`, has the word that we passed
    first in the chain: hello. Let''s run it so it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The test passed for the first check of the test and didn''t for the second
    check. Well... ideally no check should pass before any implementation is done.
    Remember that in test-driven development, tests must fail on the first launch
    because the code they are testing isn''t implemented yet. Go zero-initialization
    misleads us with this passed check on the test. We can solve this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the signature of the `ChainLogger` to return an error: `Next(string)`
    error. This way, we would break the chain returning an error. This is a much more
    convenient way in general, but it will introduce quite a lot of boilerplate right
    now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the `receivedMessage` field to a pointer. A default value of a pointer
    is nil, instead of an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the second option now, as it''s much simpler and quite effective
    too. So let''s change the signature of the `myTestWriter` struct to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Check that the type of `receivedMessage` has the asterisk (`*`) now to indicate
    that it's a pointer to a string. The `Write` function needed to change too. Now
    we have to check the contents of the `receivedMessage` field because, as every
    pointer, it's initialized to nil. Then we have to store the message in a variable
    first, so we can take the address in the next line on the assignment `(m.receivedMessage
    = &tempMessage)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now our test code should change a bit too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are checking that `myWriter.receivedMessage` is actually `nil`, so no
    content has been written for sure on the variable. Also, we have to change the
    second if to check first that the member isn''t nil before checking its contents
    or it can throw a panic on test. Let''s test it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It fails again and, again, the first half of the test passes correctly without
    implemented code. So what should we do now? We have change the signature of the `myWriter`
    type to make the test fail in both checks and, again, just fail in the second.
    Well, in this case we can pass this small issue. When writing tests, we must be
    very careful to not get too crazy about them; unit tests are tools to help us
    write and maintain code, but our target is to write functionality, not tests.
    This is important to keep in mind as you can get really crazy engineering unit
    tests.
  prefs: []
  type: TYPE_NORMAL
