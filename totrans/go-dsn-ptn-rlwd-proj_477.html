<html><head></head><body>
<div class="book" title="Chain of responsibility design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec0130" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">Now we have to implement the first, second, and third loggers called <code class="email">FirstLogger</code>, <code class="email">SecondLogger</code>, and <code class="email">WriterLogger</code> respectively. The <code class="email">FirstLogger</code> logger is the easiest one as described in the first acceptance criterion:<span class="strong"><em class="calibre11"> We need a simple logger that logs the text of a request with a prefix First logger: and passes it to the next link in the chain</em></span>. So let's do it:</p><pre class="programlisting">type FirstLogger struct { 
  NextChain ChainLogger 
} 
 
func (f *FirstLogger) Next(s string) { 
  fmt.Printf("First logger: %s\n", s) 
 
  if f.NextChain != nil { 
    f.NextChain.Next(s) 
  } 
} 
</pre><p class="calibre10">The implementation is quite easy. Using the <code class="email">fmt.Printf</code> method to format and print the incoming string, we appended the text <code class="email">First Logger:</code> text. Then, we check that the <code class="email">NextChain</code> type has actually some content and pass the control to it by calling its <code class="email">Next(string)</code> method. The test shouldn't pass yet so we'll continue with the <code class="email">SecondLogger</code> logger:</p><pre class="programlisting">type SecondLogger struct { 
  NextChain ChainLogger 
} 
 
func (se *SecondLogger) Next(s string) { 
  if strings.Contains(strings.ToLower(s), "hello") { 
    fmt.Printf("Second logger: %s\n", s) 
 
    if se.NextChain != nil { 
      se.NextChain.Next(s) 
    } 
 
    return 
  } 
 
  fmt.Printf("Finishing in second logging\n\n") 
} 
</pre><p class="calibre10">As mentioned in the second acceptance criterion, the <code class="email">SecondLogger</code> description is: <span class="strong"><em class="calibre11">A second logger will write on the console if the incoming text has the word "hello" and pass the request to a third logger</em></span>. First of all, it checks whether the incoming text contains the text <code class="email">hello</code>. If it's true, it prints the message to the console, appending the text <code class="email">Second logger:</code> and passes the message to the next link in the chain (check previous instance that a third link exists).</p><p class="calibre10">But if it doesn't contain the text <code class="email">hello</code>, the chain is broken and it prints the message <code class="email">Finishing in second logging</code>.</p><p class="calibre10">We'll finalize with the <code class="email">WriterLogger</code> type:</p><pre class="programlisting">type WriterLogger struct { 
  NextChain ChainLogger 
  Writer    io.Writer 
} 
 
func (w *WriterLogger) Next(s string) { 
  if w.Writer != nil { 
    w.Writer.Write([]byte("WriterLogger: " + s)) 
  } 
 
  if w.NextChain != nil { 
    w.NextChain.Next(s) 
  } 
} 
</pre><p class="calibre10">The <code class="email">WriterLogger</code> struct's <code class="email">Next</code> method checks that there is an existing <code class="email">io.Writer</code> interface stored in the <code class="email">Writer</code> member and writes there the incoming message appending the text <code class="email">WriterLogger:</code> to it. Then, like the previous links, check that there are more links to pass the message.</p><p class="calibre10">Now the tests will pass successfully:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCreateDefaultChain</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello'</strong></span>
<span class="strong"><strong class="calibre2">First logger: message that breaks the chain</strong></span>
<span class="strong"><strong class="calibre2">Finishing in second logging</strong></span>
<span class="strong"><strong class="calibre2">First logger: Hello</strong></span>
<span class="strong"><strong class="calibre2">Second logger: Hello</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestCreateDefaultChain (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">The first half of the test prints two messages--the <code class="email">First logger:</code> message that breaks the chain, which is the expected message for the <code class="email">FirstLogger</code>. But it halts in the <code class="email">SecondLogger</code> because no <code class="email">hello</code> word has been found on the incoming message; that's why it prints the <code class="email">Finishing in second logging</code> string.   </p><p class="calibre10">The second half of the test receives the message <code class="email">Hello</code>. So the <code class="email">FirstLogger</code> prints and the <code class="email">SecondLogger</code> prints too. The third logger doesn't print to console at all but to our <code class="email">myWriter.receivedMessage</code> line defined in the test.</p></div></div></body></html>