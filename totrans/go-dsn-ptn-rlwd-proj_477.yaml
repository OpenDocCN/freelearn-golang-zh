- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Now we have to implement the first, second, and third loggers called `FirstLogger`,
    `SecondLogger`, and `WriterLogger` respectively. The `FirstLogger` logger is the
    easiest one as described in the first acceptance criterion: *We need a simple
    logger that logs the text of a request with a prefix First logger: and passes
    it to the next link in the chain*. So let''s do it:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须实现第一个、第二个和第三个日志记录器，分别称为`FirstLogger`、`SecondLogger`和`WriterLogger`。正如第一项验收标准所描述的，`FirstLogger`日志记录器是最简单的：*我们需要一个简单的日志记录器，它将带有前缀“First
    logger:”的请求文本记录下来，并将其传递给链中的下一个链接*。所以让我们开始吧：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The implementation is quite easy. Using the `fmt.Printf` method to format and
    print the incoming string, we appended the text `First Logger:` text. Then, we
    check that the `NextChain` type has actually some content and pass the control
    to it by calling its `Next(string)` method. The test shouldn''t pass yet so we''ll
    continue with the `SecondLogger` logger:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单。使用`fmt.Printf`方法格式化和打印传入的字符串，我们附加了文本`First Logger:`。然后，我们检查`NextChain`类型实际上是否有内容，并通过调用其`Next(string)`方法将控制权传递给它。测试不应该通过，所以我们将继续使用`SecondLogger`日志记录器：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As mentioned in the second acceptance criterion, the `SecondLogger` description
    is: *A second logger will write on the console if the incoming text has the word
    "hello" and pass the request to a third logger*. First of all, it checks whether
    the incoming text contains the text `hello`. If it''s true, it prints the message
    to the console, appending the text `Second logger:` and passes the message to
    the next link in the chain (check previous instance that a third link exists).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如第二项验收标准所述，`SecondLogger`的描述是：*第二个日志记录器将在传入的文本包含单词“hello”时写入控制台，并将请求传递给第三个日志记录器*。首先，它检查传入的文本是否包含文本`hello`。如果是真的，它将消息打印到控制台，并附加文本`Second
    logger:`，然后将消息传递给链中的下一个链接（检查之前的实例，检查是否存在第三个链接）。
- en: But if it doesn't contain the text `hello`, the chain is broken and it prints
    the message `Finishing in second logging`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果它不包含文本`hello`，链路就会中断，并打印出消息`Finishing in second logging`。
- en: 'We''ll finalize with the `WriterLogger` type:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`WriterLogger`类型作为结束：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `WriterLogger` struct's `Next` method checks that there is an existing `io.Writer`
    interface stored in the `Writer` member and writes there the incoming message
    appending the text `WriterLogger:` to it. Then, like the previous links, check
    that there are more links to pass the message.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriterLogger`结构体的`Next`方法检查`Writer`成员中是否存储了现有的`io.Writer`接口，并将传入的消息写入其中，并在其后面追加文本`WriterLogger:`。然后，就像之前的链接一样，检查是否有更多的链接来传递消息。'
- en: 'Now the tests will pass successfully:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试将成功通过：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first half of the test prints two messages--the `First logger:` message
    that breaks the chain, which is the expected message for the `FirstLogger`. But
    it halts in the `SecondLogger` because no `hello` word has been found on the incoming
    message; that's why it prints the `Finishing in second logging` string.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的前半部分打印出两条消息——打破链路的`First logger:`消息，这是`FirstLogger`预期的消息。但它会在`SecondLogger`处停止，因为在传入的消息中没有找到`hello`单词；这就是为什么它会打印出`Finishing
    in second logging`字符串。
- en: The second half of the test receives the message `Hello`. So the `FirstLogger`
    prints and the `SecondLogger` prints too. The third logger doesn't print to console
    at all but to our `myWriter.receivedMessage` line defined in the test.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的后半部分接收到的消息是`Hello`。所以`FirstLogger`打印，`SecondLogger`也打印。第三个日志记录器根本不打印到控制台，而是打印到测试中定义的`myWriter.receivedMessage`行。
