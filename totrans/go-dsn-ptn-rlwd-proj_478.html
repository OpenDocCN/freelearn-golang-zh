<html><head></head><body>
<div class="book" title="Chain of responsibility design pattern">
<div class="book" title="What about a closure?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec0131" class="calibre1"/>What about a closure?</h2></div></div></div><p class="calibre10">Sometimes it can be useful to define an even more flexible link in the chain for quick debugging. We can use closures for this so that the link functionality is defined by the caller. What does a closure link look like? Similar to the <code class="email">WriterLogger</code> logger:</p><pre class="programlisting">type ClosureChain struct { 
  NextChain ChainLogger 
  Closure   func(string) 
} 
 
func (c *ClosureChain) Next(s string) { 
  if c.Closure != nil { 
    c.Closure(s) 
  } 
 
  if c.NextChain != nil { 
    c.Next(s) 
  } 
} 
</pre><p class="calibre10">The <code class="email">ClosureChain </code>type has a <code class="email">NextChain</code>, as usual, and a <code class="email">Closure </code>member. Look at the signature of the <code class="email">Closure: func(string)</code>. This means it is a function that takes a <code class="email">string</code> and returns nothing.</p><p class="calibre10">The <code class="email">Next(string)</code> method for <code class="email">ClosureChain</code> checks that the <code class="email">Closure</code> member is stored and executes it with the incoming string. As usual, the link checks for more links to pass the message as every link in the chain.</p><p class="calibre10">So, how do we use it now? We'll define a new test to show its functionality:</p><pre class="programlisting">t.Run("2 loggers, second uses the closure implementation", func(t *testing.T) { 
  myWriter = myTestWriter{} 
  closureLogger := ClosureChain{ 
    Closure: func(s string) { 
      fmt.Printf("My closure logger! Message: %s\n", s) 
      myWriter.receivedMessage = &amp;s 
    }, 
  } 
 
  writerLogger.NextChain = &amp;closureLogger 
 
  chain.Next("Hello closure logger") 
 
  if *myWriter.receivedMessage != "Hello closure logger" { 
    t.Fatal("Expected message wasn't received in myWriter") 
  } 
}) 
</pre><p class="calibre10">The description of this test makes it clear: <code class="email">"2 loggers, second uses the closure implementation".</code> We simply use two <code class="email">ChainLogger</code> implementations and we use the <code class="email">closureLogger</code> in the second link. We have created a new <code class="email">myTestWriter</code> to store the contents of the message. When defining the <code class="email">ClosureChain</code>, we defined an anonymous function directly on the <code class="email">Closure</code> member when creating <code class="email">closureLogger</code>. It prints <code class="email">"My closure logger! Message: %s\n" with the incoming message replacing "%s"</code>. Then, we store the incoming message on <code class="email">myWriter</code>, to check later.</p><p class="calibre10">After defining this new link, we use the third link from the previous test, add the closure as the fourth link, and passed the message <code class="email">Hello closure logger</code>. We use the word <code class="email">Hello</code> at the beginning so that we ensure that the message will pass the <code class="email">SecondLogger</code>.</p><p class="calibre10">Finally, the contents of <code class="email">myWriter.receivedMessage</code> must contain the pased text: <code class="email">Hello closure logger</code>. This is quite a flexible approach with one drawback: when defining a closure like this, we cannot test its contents in a very elegant way. Let's run the tests again:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v . 
=== RUN   TestCreateDefaultChain 
=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' 
First logger: message that breaks the chain 
Finishing in second logging 
 
First logger: Hello 
Second logger: Hello 
=== RUN   TestCreateDefaultChain/2_loggers,_second_uses_the_closure_implementation 
First logger: Hello closure logger 
Second logger: Hello closure logger 
My closure logger! Message: Hello closure logger 
--- PASS: TestCreateDefaultChain (0.00s) 
    --- PASS: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' (0.00s) 
    --- PASS: TestCreateDefaultChain/2_loggers,_second_uses_the_closure_implementation (0.00s) 
PASS 
ok</strong></span>
</pre><p class="calibre10">Look at the third <code class="email">RUN</code>: the message passes correctly through the first, second, and third links to arrive at the closure that prints the expected  <code class="email">My closure logger! Message: Hello closure logger</code> message.</p><p class="calibre10">It's very useful to add a closure method implementation to some interfaces as it provides quite a lot of flexibility when using the library. You can find this approach very often in Go code, being the most known the one of package <code class="email">net/http</code>. The <code class="email">HandleFunc</code> function which we used previously in the structural patterns to define a handler for an HTTP request.</p></div></div></body></html>