- en: What about a closure?
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，闭包呢？
- en: 'Sometimes it can be useful to define an even more flexible link in the chain
    for quick debugging. We can use closures for this so that the link functionality
    is defined by the caller. What does a closure link look like? Similar to the `WriterLogger`
    logger:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时定义链中更灵活的链接进行快速调试可能很有用。我们可以使用闭包来做到这一点，这样链接功能就由调用者定义。闭包链接看起来是什么样子？类似于 `WriterLogger`
    记录器：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ClosureChain` type has a `NextChain`, as usual, and a `Closure` member.
    Look at the signature of the `Closure: func(string)`. This means it is a function
    that takes a `string` and returns nothing.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClosureChain` 类型具有 `NextChain`，就像往常一样，以及一个 `Closure` 成员。看看 `Closure` 的签名：`func(string)`。这意味着它是一个接受
    `string` 并不返回任何内容的函数。'
- en: The `Next(string)` method for `ClosureChain` checks that the `Closure` member
    is stored and executes it with the incoming string. As usual, the link checks
    for more links to pass the message as every link in the chain.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClosureChain` 的 `Next(string)` 方法检查 `Closure` 成员是否已存储，并使用传入的字符串执行它。像往常一样，链接检查是否有更多链接来传递消息，因为链中的每个链接都会传递消息。'
- en: 'So, how do we use it now? We''ll define a new test to show its functionality:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何现在使用它呢？我们将定义一个新的测试来展示其功能：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The description of this test makes it clear: `"2 loggers, second uses the closure
    implementation".` We simply use two `ChainLogger` implementations and we use the
    `closureLogger` in the second link. We have created a new `myTestWriter` to store
    the contents of the message. When defining the `ClosureChain`, we defined an anonymous
    function directly on the `Closure` member when creating `closureLogger`. It prints
    `"My closure logger! Message: %s\n" with the incoming message replacing "%s"`.
    Then, we store the incoming message on `myWriter`, to check later.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '这个测试的描述很清楚：“`2` 个记录器，第二个使用闭包实现”。我们简单地使用两个 `ChainLogger` 实现并使用 `closureLogger`
    作为第二个链接。我们创建了一个新的 `myTestWriter` 来存储消息的内容。在定义 `ClosureChain` 时，我们在创建 `closureLogger`
    时直接在 `Closure` 成员上定义了一个匿名函数。它打印 `"My closure logger! Message: %s\n"`，并用传入的消息替换
    `%s`。然后，我们将传入的消息存储在 `myWriter` 上，以便稍后检查。'
- en: After defining this new link, we use the third link from the previous test,
    add the closure as the fourth link, and passed the message `Hello closure logger`.
    We use the word `Hello` at the beginning so that we ensure that the message will
    pass the `SecondLogger`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义这个新链接后，我们使用上一个测试的第三个链接，将闭包作为第四个链接添加，并传递了消息 `Hello closure logger`。我们在开头使用
    `Hello` 这个词，以确保消息会通过 `SecondLogger`。
- en: 'Finally, the contents of `myWriter.receivedMessage` must contain the pased
    text: `Hello closure logger`. This is quite a flexible approach with one drawback:
    when defining a closure like this, we cannot test its contents in a very elegant
    way. Let''s run the tests again:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`myWriter.receivedMessage` 的内容必须包含传递的文本：`Hello closure logger`。这是一种相当灵活的方法，但有一个缺点：当我们以这种方式定义闭包时，我们无法以非常优雅的方式测试其内容。让我们再次运行测试：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Look at the third `RUN`: the message passes correctly through the first, second,
    and third links to arrive at the closure that prints the expected  `My closure
    logger! Message: Hello closure logger` message.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '看看第三个 `RUN`：消息正确地通过了第一个、第二个和第三个链接，到达了打印预期 `My closure logger! Message: Hello
    closure logger` 消息的闭包。'
- en: It's very useful to add a closure method implementation to some interfaces as
    it provides quite a lot of flexibility when using the library. You can find this
    approach very often in Go code, being the most known the one of package `net/http`.
    The `HandleFunc` function which we used previously in the structural patterns
    to define a handler for an HTTP request.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些接口中添加闭包方法实现非常有用，因为它在使用库时提供了相当多的灵活性。你可以在 Go 代码中经常找到这种方法，其中最著名的是 `net/http`
    包。我们之前在结构模式中使用 `HandleFunc` 函数来定义 HTTP 请求的处理程序。
