- en: What about a closure?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it can be useful to define an even more flexible link in the chain
    for quick debugging. We can use closures for this so that the link functionality
    is defined by the caller. What does a closure link look like? Similar to the `WriterLogger`
    logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ClosureChain` type has a `NextChain`, as usual, and a `Closure` member.
    Look at the signature of the `Closure: func(string)`. This means it is a function
    that takes a `string` and returns nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Next(string)` method for `ClosureChain` checks that the `Closure` member
    is stored and executes it with the incoming string. As usual, the link checks
    for more links to pass the message as every link in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we use it now? We''ll define a new test to show its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of this test makes it clear: `"2 loggers, second uses the closure
    implementation".` We simply use two `ChainLogger` implementations and we use the
    `closureLogger` in the second link. We have created a new `myTestWriter` to store
    the contents of the message. When defining the `ClosureChain`, we defined an anonymous
    function directly on the `Closure` member when creating `closureLogger`. It prints
    `"My closure logger! Message: %s\n" with the incoming message replacing "%s"`.
    Then, we store the incoming message on `myWriter`, to check later.'
  prefs: []
  type: TYPE_NORMAL
- en: After defining this new link, we use the third link from the previous test,
    add the closure as the fourth link, and passed the message `Hello closure logger`.
    We use the word `Hello` at the beginning so that we ensure that the message will
    pass the `SecondLogger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the contents of `myWriter.receivedMessage` must contain the pased
    text: `Hello closure logger`. This is quite a flexible approach with one drawback:
    when defining a closure like this, we cannot test its contents in a very elegant
    way. Let''s run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the third `RUN`: the message passes correctly through the first, second,
    and third links to arrive at the closure that prints the expected  `My closure
    logger! Message: Hello closure logger` message.'
  prefs: []
  type: TYPE_NORMAL
- en: It's very useful to add a closure method implementation to some interfaces as
    it provides quite a lot of flexibility when using the library. You can find this
    approach very often in Go code, being the most known the one of package `net/http`.
    The `HandleFunc` function which we used previously in the structural patterns
    to define a handler for an HTTP request.
  prefs: []
  type: TYPE_NORMAL
