<html><head></head><body>
<div class="book" title="Command design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec0137" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">This pattern is quite simple and we will write a few different examples so we'll implement the library directly to keep things light and short. The classical Command design pattern usually has a common type structure with an <code class="email">Execute</code> method. We are also going to use this structure as it's quite flexible and simple:</p><pre class="programlisting">type Command interface { 
  Execute() 
} 
</pre><p class="calibre10">This is generic enough to fill a lot of unrelated types! Think about it--we are going to create a type that prints to console when using the <code class="email">Execute()</code> method but it could print a number or launch a rocket as well! The key here is to focus on invocations because the handlers are also in Command. So we need some type implementing this interface and printing to the console some sort of message:</p><pre class="programlisting">type ConsoleOutput struct { 
  message string 
} 
 
func (c *ConsoleOutput) Execute() { 
  fmt.Println(c.message) 
} 
</pre><p class="calibre10">The <code class="email">ConsoleOutput</code> type implements the <code class="email">Command</code> interface and prints to the console the member called <code class="email">message</code>.</p><p class="calibre10">As defined in the first acceptance criterion, we need a <code class="email">Command</code> constructor that accepts a message string and returns the <code class="email">Command</code> interface. It will have the signature <code class="email">func CreateCommand(s string) Command</code>:</p><pre class="programlisting"> func CreateCommand(s string) Command { 
   fmt.Println("Creating command") 
 
   return &amp;ConsoleOutput{ 
         message: s, 
   } 
} 
</pre><p class="calibre10">For the command <code class="email">queue</code>, we'll define a very simple type called <code class="email">CommandQueue</code> to store in a queue any type implementing the <code class="email">Command</code> interface:</p><pre class="programlisting">type CommandQueue struct { 
  queue []Command 
} 
 
func (p *CommandQueue) AddCommand(c Command) { 
  p.queue = append(p.queue, c) 
 
  if len(p.queue) == 3 { 
    for _, command := range p.queue { 
      command.Execute() 
    } 
 
    p.queue = make([]Command, 3) 
  } 
} 
</pre><p class="calibre10">The <code class="email">CommandQueue</code> type stores an array of the <code class="email">Commands</code> interface. When the queue array reaches three items, it executes all the commands stored in the queue field. If it hasn't reached the required length yet, it just stores the command.</p><p class="calibre10">We will create five commands, enough to trigger the command queue mechanism, and add them to the queue. Each time a command is created, the message <code class="email">Creating command</code> will be printed to the console. When we create the third command, the automatic command executor will be launched, printing the first three messages. We create and add two commands more, but because we haven't reached the third command again, they won't be printed and just the <code class="email">Creating command</code> messages will be printed:</p><pre class="programlisting">func main() { 
  queue := CommandQueue{} 
 
  queue.AddCommand(CreateCommand("First message")) 
  queue.AddCommand(CreateCommand("Second message")) 
  queue.AddCommand(CreateCommand("Third message")) 
 
  queue.AddCommand(CreateCommand("Fourth message")) 
  queue.AddCommand(CreateCommand("Fifth message")) 
} 
</pre><p class="calibre10">Let's run the <code class="email">main</code> program. Our definition said that the commands are processed once every three messages and we will create a total of five messages. The first three messages must be printed but not the fourth and fifth because we didn't reach a sixth message to trigger the command processing:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$go run command.go</strong></span>
<span class="strong"><strong class="calibre2">Creating command</strong></span>
<span class="strong"><strong class="calibre2">Creating command</strong></span>
<span class="strong"><strong class="calibre2">Creating command</strong></span>
<span class="strong"><strong class="calibre2">First message</strong></span>
<span class="strong"><strong class="calibre2">Second message</strong></span>
<span class="strong"><strong class="calibre2">Third message</strong></span>
<span class="strong"><strong class="calibre2">Creating command</strong></span>
<span class="strong"><strong class="calibre2">Creating command</strong></span>
</pre><p class="calibre10">As you can see, the fourth and fifth messages aren't printed, as expected, but we know that the commands were created and stored on the array. They just weren't processed because the queue was waiting for one command more to trigger the processor.</p></div></div></body></html>