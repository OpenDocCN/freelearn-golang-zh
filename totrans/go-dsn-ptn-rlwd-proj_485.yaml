- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is quite simple and we will write a few different examples so
    we''ll implement the library directly to keep things light and short. The classical
    Command design pattern usually has a common type structure with an `Execute` method.
    We are also going to use this structure as it''s quite flexible and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is generic enough to fill a lot of unrelated types! Think about it--we
    are going to create a type that prints to console when using the `Execute()` method
    but it could print a number or launch a rocket as well! The key here is to focus
    on invocations because the handlers are also in Command. So we need some type
    implementing this interface and printing to the console some sort of message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `ConsoleOutput` type implements the `Command` interface and prints to the
    console the member called `message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As defined in the first acceptance criterion, we need a `Command` constructor
    that accepts a message string and returns the `Command` interface. It will have
    the signature `func CreateCommand(s string) Command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the command `queue`, we''ll define a very simple type called `CommandQueue`
    to store in a queue any type implementing the `Command` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `CommandQueue` type stores an array of the `Commands` interface. When the
    queue array reaches three items, it executes all the commands stored in the queue
    field. If it hasn't reached the required length yet, it just stores the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create five commands, enough to trigger the command queue mechanism,
    and add them to the queue. Each time a command is created, the message `Creating
    command` will be printed to the console. When we create the third command, the
    automatic command executor will be launched, printing the first three messages.
    We create and add two commands more, but because we haven''t reached the third
    command again, they won''t be printed and just the `Creating command` messages
    will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `main` program. Our definition said that the commands are processed
    once every three messages and we will create a total of five messages. The first
    three messages must be printed but not the fourth and fifth because we didn''t
    reach a sixth message to trigger the command processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the fourth and fifth messages aren't printed, as expected, but
    we know that the commands were created and stored on the array. They just weren't
    processed because the queue was waiting for one command more to trigger the processor.
  prefs: []
  type: TYPE_NORMAL
