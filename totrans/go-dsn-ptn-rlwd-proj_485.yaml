- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'This pattern is quite simple and we will write a few different examples so
    we''ll implement the library directly to keep things light and short. The classical
    Command design pattern usually has a common type structure with an `Execute` method.
    We are also going to use this structure as it''s quite flexible and simple:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式相当简单，我们将编写几个不同的示例，因此我们将直接实现库以保持内容简洁。经典的命令设计模式通常有一个具有`Execute`方法的公共类型结构。我们也将使用这种结构，因为它相当灵活且简单：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is generic enough to fill a lot of unrelated types! Think about it--we
    are going to create a type that prints to console when using the `Execute()` method
    but it could print a number or launch a rocket as well! The key here is to focus
    on invocations because the handlers are also in Command. So we need some type
    implementing this interface and printing to the console some sort of message:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够通用，可以填充许多无关的类型！想想看——我们将创建一个类型，当使用`Execute()`方法时会在控制台打印，但它也可以打印一个数字或发射火箭！关键在于关注调用，因为处理程序也在命令中。因此，我们需要某种实现此接口并打印某种消息到控制台的类型：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ConsoleOutput` type implements the `Command` interface and prints to the
    console the member called `message`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleOutput`类型实现了`Command`接口，并将名为`message`的成员打印到控制台。'
- en: 'As defined in the first acceptance criterion, we need a `Command` constructor
    that accepts a message string and returns the `Command` interface. It will have
    the signature `func CreateCommand(s string) Command`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第一项验收标准定义，我们需要一个`Command`构造函数，它接受一个消息字符串并返回`Command`接口。它的签名将是`func CreateCommand(s
    string) Command`：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the command `queue`, we''ll define a very simple type called `CommandQueue`
    to store in a queue any type implementing the `Command` interface:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令`queue`，我们将定义一个非常简单的类型`CommandQueue`，用于存储实现`Command`接口的任何类型：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CommandQueue` type stores an array of the `Commands` interface. When the
    queue array reaches three items, it executes all the commands stored in the queue
    field. If it hasn't reached the required length yet, it just stores the command.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandQueue`类型存储了一个`Commands`接口的数组。当队列数组达到三个项目时，它将执行队列字段中存储的所有命令。如果还没有达到所需的长度，它只是存储命令。'
- en: 'We will create five commands, enough to trigger the command queue mechanism,
    and add them to the queue. Each time a command is created, the message `Creating
    command` will be printed to the console. When we create the third command, the
    automatic command executor will be launched, printing the first three messages.
    We create and add two commands more, but because we haven''t reached the third
    command again, they won''t be printed and just the `Creating command` messages
    will be printed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建五个命令，足以触发命令队列机制，并将它们添加到队列中。每次创建命令时，控制台都会打印出`Creating command`消息。当我们创建第三个命令时，自动命令执行器将被启动，打印出前三个消息。我们再创建并添加两个命令，但由于我们没有再次达到第三个命令，它们不会被打印，只会打印出`Creating
    command`消息：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s run the `main` program. Our definition said that the commands are processed
    once every three messages and we will create a total of five messages. The first
    three messages must be printed but not the fourth and fifth because we didn''t
    reach a sixth message to trigger the command processing:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`main`程序。我们的定义表明命令每三条消息处理一次，我们将创建总共五条消息。前三条消息必须打印，但第四和第五条消息不打印，因为我们没有达到第六条消息来触发命令处理：
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the fourth and fifth messages aren't printed, as expected, but
    we know that the commands were created and stored on the array. They just weren't
    processed because the queue was waiting for one command more to trigger the processor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第四和第五条消息没有打印，正如预期的那样，但我们知道命令已被创建并存储在数组中。只是它们没有被处理，因为队列正在等待一个额外的命令来触发处理器。
