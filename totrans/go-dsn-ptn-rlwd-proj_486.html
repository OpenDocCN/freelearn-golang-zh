<html><head></head><body>
<div class="book" title="Command design pattern">
<div class="book" title="More examples"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec0138" class="calibre1"/>More examples</h2></div></div></div><p class="calibre10">The previous example shows how to use a Command handler that executes the content of the command. But a common way to use a Command pattern is to delegate the information, instead of the execution, to a different object.</p><p class="calibre10">For example, instead of printing to the console, we will create a command that extracts information:</p><pre class="programlisting">type Command interface { 
  Info() string 
} 
</pre><p class="calibre10">In this case, our <code class="email">Command</code> interface will have a method named <code class="email">Info</code> that will retrieve some information from its implementor. We will create two implementations; one will return the time passed since the creation of the command to its execution:</p><pre class="programlisting">type TimePassed struct { 
  start time.Time 
} 
 
func (t *TimePassed) Info() string { 
  return time.Since(t.start).String() 
} 
</pre><p class="calibre10">The <code class="email">time.Since</code> function returns the time elapsed since the time stored in the provided parameter. We returned the string representation of the passed time by calling the <code class="email">String()</code> method on the <code class="email">time.Time</code> type. The second implementation of our new <code class="email">Command</code> will return the message <code class="email">Hello World!</code>:</p><pre class="programlisting">type HelloMessage struct{} 
 
func (h HelloMessage) Info() string { 
  return "Hello world!" 
} 
</pre><p class="calibre10">And our <code class="email">main</code> function will simply create an instance of each type, then waits for a second and print the info returned from each <code class="email">Command</code>:</p><pre class="programlisting">func main() { 
  var timeCommand Command 
  timeCommand = &amp;TimePassed{time.Now()} 
 
  var helloCommand Command 
  helloCommand = &amp;HelloMessage{} 
 
  time.Sleep(time.Second) 
   
  fmt.Println(timeCommand.Info()) 
  fmt.Println(helloCommand.Info()) 
} 
</pre><p class="calibre10">The <code class="email">time.Sleep</code> function stops the execution of the current goroutine for the specified period (a second). So, to recall--the <code class="email">timeCommand</code> variable stores the time when the program was started and its <code class="email">Info()</code> method returns a string representation of the time that passed since we give a value to the type to the moment were we called the <code class="email">Info()</code> method on it. The <code class="email">helloCommand</code> variable returns the message <code class="email">Hello World!</code> when we call its <code class="email">Info()</code> method. Here we haven't implemented a <code class="email">Command</code> handler again to keep things simple but we can consider the console as the handler because we can only print ASCII characters on it like the ones retrieved by the <code class="email">Info()</code> method.</p><p class="calibre10">Let's run the <code class="email">main</code> function:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go run command.go</strong></span>
<span class="strong"><strong class="calibre2">1.000216755s</strong></span>
<span class="strong"><strong class="calibre2">Hello world!</strong></span>
</pre><p class="calibre10">Here we are. In this case, we retrieve some information by using the Command pattern. One type stores <code class="email">time</code> information while the other stores nothing and it simply returns the same simple string. Each time we run the <code class="email">main</code> function will return a different elapsed time, so don't worry if the time doesn't match with the one in the example.</p></div></div></body></html>