<html><head></head><body>
<div class="book" title="Command design pattern">
<div class="book" title="Chain of responsibility of commands"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch05lvl2sec0139" class="calibre1"/>Chain of responsibility of commands</h2></div></div></div><p class="calibre10">Do you remember the chain of responsibility design pattern? We were passing a <code class="email">string</code> message between links to print its contents. But we could be using the previous Command to retrieve information for logging to the console. We'll mainly reuse the code that we have written already.</p><p class="calibre10">The <code class="email">Command</code> interface will be from the type interface that returns a <code class="email">string</code> from the previous example:</p><pre class="programlisting">type Command interface { 
  Info() string 
} 
</pre><p class="calibre10">We will use the <code class="email">Command</code> implementation of the <code class="email">TimePassed</code> type too:</p><pre class="programlisting">type TimePassed struct { 
  start time.Time 
} 
 
func (t *TimePassed) Info() string { 
  return time.Since(t.start).String() 
} 
</pre><p class="calibre10">Remember that this type returns the elapsed time from the object creation on its <code class="email">Info() string</code> method. We also need the <code class="email">ChainLogger</code> interface from the <span class="strong"><em class="calibre11">Chain of responsibility design pattern</em></span> section of this chapter but, this time, it will pass Commands on its <code class="email">Next</code> method instead of <code class="email">string</code>:</p><pre class="programlisting">type ChainLogger interface { 
  Next(Command) 
} 
</pre><p class="calibre10">We'll use just the same type for two links in the chain for simplicity. This link is very similar to the <code class="email">FirstLogger</code> type from the chain of responsibility example, but this time it will append the message <code class="email">Elapsed time from creation:</code> and it will wait 1 second before printing. We'll call it <code class="email">Logger</code> instead of <code class="email">FirstLogger</code>:</p><pre class="programlisting">type Logger struct { 
  NextChain ChainLogger 
} 
 
func (f *Logger) Next(c Command) { 
  time.Sleep(time.Second) 
 
  fmt.Printf("Elapsed time from creation: %s\n", c.Info()) 
 
  if f.NextChain != nil { 
    f.NextChain.Next(c) 
  } 
} 
</pre><p class="calibre10">Finally, we need a <code class="email">main</code> function to execute the chain that takes <code class="email">Command</code> pointers:</p><pre class="programlisting">func main() { 
  second := new(Logger) 
  first := Logger{NextChain: second} 
 
  command := &amp;TimePassed{start: time.Now()} 
 
  first.Next(command) 
} 
</pre><p class="calibre10">Line by line, we create a variable called <code class="email">second</code> with a pointer to a <code class="email">Logger</code>; this is going to be the second link in our chain. Then we create a variable called <code class="email">first</code>, that will be the first link in the chain. The first link points to the <code class="email">second</code> variable, the second link in the chain.</p><p class="calibre10">Then, we create an instance of <code class="email">TimePassed</code> to use it as the <code class="email">Command</code> type. The start time of this command is the execution time (the <code class="email">time.Now()</code> method returns the time in the moment of the execution).</p><p class="calibre10">Finally, we pass the <code class="email">Command</code> interface to the chain on the <code class="email">first.Next(command)</code> statement. The output of this program is the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go run chain_command.go</strong></span>
<span class="strong"><strong class="calibre2">Elapsed time from creation: 1.0003419s</strong></span>
<span class="strong"><strong class="calibre2">Elapsed time from creation: 2.000682s</strong></span>
</pre><p class="calibre10">The resulting output is reflected in the following diagram: The command with the time field is pushed to the first link that knows how to execute Commands of any type. Then it passes the Command to the second link that also knows how to execute Commands:</p><p class="calibre10">This approach hides the complexity behind each <code class="email">Command</code> execution from the Command handlers on each link. The functionality hidden behind a Command can be simple or incredibly complex but the idea here is to reuse the handler to manage many types of unrelated implementations.</p></div></div></body></html>